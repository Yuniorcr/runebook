<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App::Prove::State::Result-個々のテストスイートの結果。</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App::Prove::State::Result::Test-個別のテスト結果。</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">どうやらIBMはFPマスクを左右に変えるコンパイラを使っていたようです(95年頃のある時期?これは</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">彼らの自己利益にアピールしてください! Perl が彼らにとって新しい(したがって怖い)ものであれば、Perl が彼らの問題の一つを解決するために何かできることを見つけてください。それは、Perlが彼らに何か(時間、頭痛、お金)を節約するか、何か(柔軟性、パワー、テスト可能性)を与えることを意味するかもしれません。</target>
        </trans-unit>
        <trans-unit id="7820ab67805cf1ba0f215418474bf3c391c0a394" translate="yes" xml:space="preserve">
          <source>Appearances can be deceptive, especially when it comes to emptiness. If you are scratching your head trying to work out why Test::Tester is saying that your diagnostics are wrong when they look perfectly right then the answer is probably whitespace. From version 0.10 on, Test::Tester surrounds the expected and got diag values with single quotes to make it easier to spot trailing whitespace. So in this example</source>
          <target state="translated">外見は欺くことができ、特に空虚さに関してはそうです。Test::Test::Tester が診断結果を正しく表示しているのに、なぜ間違っていると言うのか、頭を悩ませているのであれば、その答えはおそらく空白ではないかと思います。バージョン 0.10 以降では、Test::Test::Tester は予想されるダイアグ値と取得したダイアグ値を単一引用符で囲むようになっており、後続の空白を見つけやすくなっています。したがって、この例では</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">list-type op内に直接含まれるopのリストに項目を追加し、長くなったリストを返します。</target>
        </trans-unit>
        <trans-unit id="555e00ca2c34efb8f2b3198b481016b18bb0499c" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list. &lt;code&gt;first&lt;/code&gt; is the list-type op, and &lt;code&gt;last&lt;/code&gt; is the op to append to the list. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If &lt;code&gt;first&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="translated">リストタイプのopに直接含まれているopsのリストにアイテムを追加し、長くなったリストを返します。 &lt;code&gt;first&lt;/code&gt; はリストタイプの操作で、 &lt;code&gt;last&lt;/code&gt; はリストに追加する操作です。 &lt;code&gt;optype&lt;/code&gt; は、リストの目的のオペコードを指定します。 &lt;code&gt;first&lt;/code&gt; がまだ適切なタイプのリストでない場合は、1つにアップグレードされます。 &lt;code&gt;first&lt;/code&gt; または &lt;code&gt;last&lt;/code&gt; いずれかがnullの場合、もう一方は変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">の要素を追加します。</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">LISTの要素を配列に追加します。</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">各テストの実行時間を出力に追加します。使用&lt;a href=&quot;../../time/hires&quot;&gt;時間::ハイレゾを&lt;/a&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">各テストの実行時間を出力に追加します。使用&lt;a href=&quot;../time/hires&quot;&gt;時間::ハイレゾを&lt;/a&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="c0d38ef820bcef303880baae14bb62295e88bb8d" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">出力する各テストの実行時間を追加します。使用&lt;a href=&quot;Time::HiRes&quot;&gt;時間::ハイレゾを&lt;/a&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">G_KEEPERR フラグを追加することで</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">与えられた文字列,構文解析木,シーケンスオブジェクトを,この内部シーケンスの構文解析木に追加します.</target>
        </trans-unit>
        <trans-unit id="bc939bc86e4ec12055b78bc1367433c6c3dc048c" translate="yes" xml:space="preserve">
          <source>Apple Mac OS 8/9</source>
          <target state="translated">アップルMac OS 8/9</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">パッチの適用</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">アプリケーションリリース 2001年9月、HP-UX 11.00はPerlが初めて出荷されました。その頃には/opt/perl に perl-5.6.1 が入っていた。最初の出現は CD 5012-7954 にあり、インストールには</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">式を表すオペツリーに構文コンテキストを適用する。</target>
        </trans-unit>
        <trans-unit id="4e768fecef5f9dd672611658c8743f59705b1284" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression. &lt;code&gt;o&lt;/code&gt; is the op tree, and &lt;code&gt;context&lt;/code&gt; must be &lt;code&gt;G_SCALAR&lt;/code&gt;, &lt;code&gt;G_ARRAY&lt;/code&gt;, or &lt;code&gt;G_VOID&lt;/code&gt; to specify the context to apply. The modified op tree is returned.</source>
          <target state="translated">式を表すopツリーに構文コンテキストを適用します。 &lt;code&gt;o&lt;/code&gt; はオペアンプの木である、および &lt;code&gt;context&lt;/code&gt; なければなりません &lt;code&gt;G_SCALAR&lt;/code&gt; 、 &lt;code&gt;G_ARRAY&lt;/code&gt; 、または &lt;code&gt;G_VOID&lt;/code&gt; 適用するコンテキストを指定します。変更されたopツリーが返されます。</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">dl_find_symbol()を @dl_librefs のメンバに適用し、最初に見つかったマッチを返します。</target>
        </trans-unit>
        <trans-unit id="8f16d6f27d971ff843245cdc989aa538f3326e5f" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;#int-EXPR&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to the value returned by &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">ランダムな小数の代わりにランダムな整数が必要な場合は、&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;によって返される値に&lt;a href=&quot;#int-EXPR&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;を適用します。例えば、</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">ランダムな小数ではなくランダムな整数が必要な場合は、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; によって返される値に &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; を適用します。例えば、</target>
        </trans-unit>
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">ランダムな小数ではなくランダムな整数が必要な場合は、 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; によって返される値に &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; を適用します。例えば、</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">正しい POD を見つけるために Perl 固有のヒューリスティックを適用します。これには、Perl ライクな拡張機能を削除したり、数値ではあるが</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">スイッチオプションのリストを状態に適用し、その結果として内部オブジェクトの状態を更新します。何も返されません。</target>
        </trans-unit>
        <trans-unit id="7b0453d0169f10e0dd546ac420ad360f4311387a" translate="yes" xml:space="preserve">
          <source>Applying %s to %s will act on scalar(%s)</source>
          <target state="translated">s を %s に適用すると,スカラ(%s)に作用します.</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; に適用すると、エキゾチックフォーム &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; は、字句スコープの終わりまで構文エラーと見なされます。エキゾチックなフォームを本当に使用する必要がある場合は、代わりに &lt;code&gt;CORE::system&lt;/code&gt; または &lt;code&gt;CORE::exec&lt;/code&gt; を呼び出すか、エキゾチックなフォームを呼び出す前に &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 使用し&lt;a href=&quot;functions/no&quot;&gt;ないで&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="73c33410e3cd1ef38b870e6e841b6a111c44ea15" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; causes the exotic forms &lt;code&gt;system { $cmd } @args &lt;/code&gt; or &lt;code&gt;exec { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; を &lt;code&gt;system&lt;/code&gt; または &lt;code&gt;exec&lt;/code&gt; に適用すると、エキゾチックフォーム &lt;code&gt;system { $cmd } @args &lt;/code&gt; または &lt;code&gt;exec { $cmd } @args&lt;/code&gt; は、字句スコープが終了するまで構文エラーと見なされます。エキゾチックフォームを本当に使用する必要がある場合は、代わりに &lt;code&gt;CORE::system&lt;/code&gt; または &lt;code&gt;CORE::exec&lt;/code&gt; を呼び出すか、エキゾチックフォームを呼び出す前に &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; 使用しないでください。</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">おおよそのPerl相当： &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">おおよそのPerl同等物： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f08b9c9f0996e8f22c8e80713baa3b2c5d6b61a" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt;.</source>
          <target state="translated">同等のおおよそのPerl： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171752021f257ea835e63866304a10e0627a5496" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt;.</source>
          <target state="translated">同等のおおよそのPerl： &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997年04月04日~07日:Jarkko Hietaniemi氏による、ランフォーサム機能の追加。</target>
        </trans-unit>
        <trans-unit id="538beea89400340066f03de9b8531baacd233ee4" translate="yes" xml:space="preserve">
          <source>April 2010</source>
          <target state="translated">2010年4月</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">任意の大きな有理数</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">任意サイズの浮動小数点演算パッケージ</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">任意のサイズの整数/浮動小数点演算パッケージ</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="fa197ea9d1ebf357ab1895c0454edae5ed010094" translate="yes" xml:space="preserve">
          <source>Archive and test</source>
          <target state="translated">アーカイブとテスト</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive::Tar-tar アーカイブを操作するためのモジュール</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar は、tar ファイルを扱うためのオブジェクト指向のメカニズムを提供します。素早く簡単にファイルを扱うためのクラスメソッドを提供する一方で、カスタム操作用の tar ファイルオブジェクトの作成も可能です。IO::Zlib モジュールがインストールされている場合、Archive::Tar は圧縮された tar ファイルや圧縮された tar ファイルもサポートします。</target>
        </trans-unit>
        <trans-unit id="2de9e103622352aeb9a5f8214ffe2d70dee8d73d" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 / xz compressed file and the IO::Uncompress::Bunzip2 / IO::Uncompress::UnXz are not available and simply return.</source>
          <target state="translated">Archive::Tar は、bzip2/xz 圧縮ファイルを渡そうとして IO::Uncompress::Bunzip2/IO::Uncompress::UnXz が利用できない場合に警告を発し、単に戻ります。</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Archive::Tar は、bzip2 圧縮ファイルを渡そうとして IO::Zlib/IO::Uncompress::Bunzip2 モジュールが利用できない場合に警告を発し、単に返すだけです。</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Archive :: Tar-&amp;gt; create_archive（$ file、$ compressed、@filelist）</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">Archive :: Tar-&amp;gt; extract_archive（$ file、$ compressed）</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter（$ filename、[$ compressed、{opt =&amp;gt; $ val}]）</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Archive :: Tar-&amp;gt; list_archive（$ file、$ compressed、[\ @properties]）</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; new（[$ file、$ compressed]）</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar::File-Archive::Tar からメモリ内で抽出されたファイルのサブクラス</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（chunk =&amp;gt; $ chunk）</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（data =&amp;gt; $ path、$ data、$ opt）</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（file =&amp;gt; $ path）</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive::Tar::Files は、メモリ内で抽出されたファイルのためのきちんとした小さなオブジェクト層を提供します。ほとんどの場合、Archive::Tar の内部でコードを整理するために使われていますが、ユーザーがこの API を使わない理由はありません。</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">アーカイブと圧縮</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl の正規表現は DFA ですか NFA ですか?POSIXに準拠していますか?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">これらのスレッドは同じですか?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">まだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="37ca7d873908345ae9a97f86f6ad04967916d66e" translate="yes" xml:space="preserve">
          <source>Are we at end of file?</source>
          <target state="translated">ファイルの最後にいるのか?</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Windowsを起動していて</target>
        </trans-unit>
        <trans-unit id="d10b1e8f0d25e8ced1066c8aec43c1966f5ae507" translate="yes" xml:space="preserve">
          <source>Are you running the latest released version of perl?</source>
          <target state="translated">最新のリリースされた perl を実行していますか?</target>
        </trans-unit>
        <trans-unit id="c3fcfe8bf10e9354f16b7f74dc1d506d9b370761" translate="yes" xml:space="preserve">
          <source>Are you sure what you have is a bug?</source>
          <target state="translated">本当に持っているものはバグなのか?</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">本当に古いバージョンのPerlを使っていませんか?</target>
        </trans-unit>
        <trans-unit id="1f76843fe2bb213b3ad1c4d889f7769d9611e0fa" translate="yes" xml:space="preserve">
          <source>Arg too short for msgsnd</source>
          <target state="translated">Arg が短すぎて msgsnd</target>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">おそらく、これらはCプログラム内からPerlコードのスニペットを実行するために必要な唯一のルーチンです。コードは好きなだけ長くできます。複数のステートメントを含めることができます。&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;、&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;、および&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;を使用して、外部Perlファイルを含めることができます。</target>
        </trans-unit>
        <trans-unit id="1bfedcdfdca0d5a6460d0d9a3f351f6cd3b4ab7e" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;perlfunc#do&quot;&gt;&quot;do&quot; in perlfunc&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">間違いなく、これらは、Cプログラム内からPerlコードのスニペットを実行するために必要な唯一のルーチンです。コードは好きなだけ長くすることができます。複数のステートメントを含めることができます。それは採用することができる&lt;a href=&quot;perlfunc#use&quot;&gt;perlfuncの中で、「使用する」&lt;/a&gt;、&lt;a href=&quot;perlfunc#require&quot;&gt;perlfuncの中で「必要」&lt;/a&gt;、そして&lt;a href=&quot;perlfunc#do&quot;&gt;perlfuncの中で「やる」&lt;/a&gt;外部のPerlファイルをインクルードします。</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="a16749b15d046173fc9fcdf8d075749c151dba6a" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; isn't numeric%s</source>
          <target state="translated">引数 &quot;%s&quot; は数値%sではありません。</target>
        </trans-unit>
        <trans-unit id="c043537672dbd0f8f35895f8245f3c4e263a6c8f" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; treated as 0 in increment (++)</source>
          <target state="translated">引数 &quot;%s&quot; はインクリメントで 0 として扱われます。</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">引数コールバック</target>
        </trans-unit>
        <trans-unit id="f421070543c0b96709c29a61e7bc0e29c9a6f773" translate="yes" xml:space="preserve">
          <source>Argument list not closed for PerlIO layer &quot;%s&quot;</source>
          <target state="translated">PerlIO 層 &quot;%s&quot; で閉じられていない引数リストです。</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">引数スタック</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">コアの引数スタック操作は、XSUBの場合とまったく同じです。スタック操作で使用されるマクロの詳細については、&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;、&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;、および&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">引数は大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">引数は文字列でない場合は強制的に整数形式になります。</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">引数はPPコードに渡され、引数スタック &lt;code&gt;ST&lt;/code&gt; を使用してPPコードから返されます。引数を処理する一般的な方法は、引数をスタックからポップし、必要に応じて処理してから、結果をスタックにプッシュすることです。これは、たとえば余弦演算子がどのように機能するかです。</target>
        </trans-unit>
        <trans-unit id="ad4cbcd9603c1cc923fb5986131d15966c20d956" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt;. The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">引数はPPコードに渡され、引数スタック &lt;code&gt;ST&lt;/code&gt; を使用してPPコードから返されます。引数を処理する一般的な方法は、引数をスタックからポップし、希望どおりに処理してから、結果をスタックにプッシュすることです。たとえば、コサイン演算子は次のように機能します。</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">引数は通常、指定された値を表示するために必要な幅のみにフォーマットされます。ここに数値を入力して幅を上書きするか、次の引数（ &lt;code&gt;*&lt;/code&gt; を使用）または指定した引数（ &lt;code&gt;*2$&lt;/code&gt; ）から幅を取得できます。</target>
        </trans-unit>
        <trans-unit id="79b342195140d9018897c02d4477a0cd2a68bcbe" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt;) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">引数は通常、指定された値を表示するために必要な幅だけになるようにフォーマットされます。ここに数値を入力して幅を上書きするか、次の引数（ &lt;code&gt;*&lt;/code&gt; を使用）または指定した引数（ &lt;code&gt;*2$&lt;/code&gt; ）から幅を取得できます。</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ディレクティブの引数は、（キー、値）のペアです。正当なキーの完全なセットについては、以下の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;オーバーロード可能なオペレーションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cb61e5648eb703f1cc9dab71a052768830d8cd36" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;use overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; below.</source>
          <target state="translated">引数 &lt;code&gt;use overload&lt;/code&gt; ディレクティブは（キー、値）のペアです。有効なキーの完全なセットについては、以下の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;「オーバーロード可能な操作」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">ハイフンで始まらない引数は、レンダリングするサブルーチンまたはフォーマットの名前と見なされます。そのような関数が指定されていない場合、プログラムの本体（サブルーチンの外にあり、use'dまたはrequire'dファイルを含まない）がレンダリングされます。 &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; 、または &lt;code&gt;END&lt;/code&gt; を渡すと、対応するすべての特殊ブロックが印刷されます。引数はオプションに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="c05d8fdf0d667d5e67ac75211debe610ccbb3189" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">ハイフンで始まらない引数は、レンダリングするサブルーチンまたはフォーマットの名前と見なされます。そのような関数が指定されていない場合、プログラムの本体（サブルーチンの外で、use'dまたはrequire'dファイルを含まない）がレンダリングされます。 &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; 、または &lt;code&gt;END&lt;/code&gt; を渡すと、対応するすべての特殊ブロックが出力されます。引数はオプションに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; への引数は、汚染が&lt;b&gt;ないか&lt;/b&gt;チェックされ&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4006b3311082c7bd892aab6f8d46c918fb22f118" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;syswrite&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; および &lt;code&gt;syswrite&lt;/code&gt; の引数は、汚染が&lt;b&gt;ないか&lt;/b&gt;チェックされ&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">テストへの引数</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">コマンドラインに追加する引数</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">これらのコマンドの引数は、オブジェクトの識別文字列に完全に一致する文字列か、オブジェクトの様々な属性に対して大文字小文字を区別せずにマッチする正規表現です。パーサは正規表現をスラッシュで囲んだ場合のみ認識します。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">引数です。COUNTはループを実行する回数、CODEは実行するコードです。CODEはコード参照かevalされる文字列のどちらかです。</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">引数。TIMEはCODEを実行する最小時間の長さであり、CODEは実行するコードです。CODEはコード参照かevalされる文字列のいずれかである可能性があります。</target>
        </trans-unit>
        <trans-unit id="38bfcf708d6931f7d42f920765aaabb5369a9058" translate="yes" xml:space="preserve">
          <source>Aristotle</source>
          <target state="translated">Aristotle</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="aa4a9120c32b4442874b4d46d816ed7dd9bbe6c6" translate="yes" xml:space="preserve">
          <source>Arithmetic methods</source>
          <target state="translated">演算法</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">算術演算子</target>
        </trans-unit>
        <trans-unit id="e6532be8ff2d954f60f4660f2c54f2ea6702b27e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 中の算術演算子整数</target>
        </trans-unit>
        <trans-unit id="104fd3fd5302e037fb8d66ee6c616a71d0739a71" translate="yes" xml:space="preserve">
          <source>Arizona</source>
          <target state="translated">Arizona</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">アーノルド、ケン、ジェームス・ゴズリング。Javaプログラミング言語、第2版、アディソンウェズリー、1998年、ISBN 0-201-31006 アディソンウェズリー、1998年、ISBN 0-201-31006-6。</target>
        </trans-unit>
        <trans-unit id="f59bbf13db8733c389e26cc50790aefa49bd87eb" translate="yes" xml:space="preserve">
          <source>Around line 755:</source>
          <target state="translated">755号線付近。</target>
        </trans-unit>
        <trans-unit id="c85b5fb626816d8525d58d40352050c4cc00a98a" translate="yes" xml:space="preserve">
          <source>Around line 804:</source>
          <target state="translated">804番線付近。</target>
        </trans-unit>
        <trans-unit id="5ab366efdd1504cdfaa681a633d790c9ce967f2c" translate="yes" xml:space="preserve">
          <source>Arranges for &lt;code&gt;sv&lt;/code&gt; to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合、 &lt;code&gt;sv&lt;/code&gt; がスレッド間で共有されるように調整します。</target>
        </trans-unit>
        <trans-unit id="f2eecdf1f299504d5505f21d414522aaf018f39c" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="translated">ランタイムライブラリがバイナリファイルとテキストファイルを区別するシステムで、FILEHANDLEが「バイナリ」モードまたは「テキスト」モードで読み書きされるように調整します。FILEHANDLEが式の場合、値はファイルハンドルの名前として使用されます。成功するとtrueを返します。それ以外の場合は、&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;を返し、&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;を設定します。（errno）。</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">ランタイムライブラリがバイナリファイルとテキストファイルを区別するシステムで、FILEHANDLEが「バイナリ」または「テキスト」モードで読み書きされるようにします。FILEHANDLEが式である場合、値はファイルハンドルの名前として使用されます。成功した場合はtrueを返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。（errno）。</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">ランタイムライブラリがバイナリファイルとテキストファイルを区別するシステムで、FILEHANDLEが「バイナリ」または「テキスト」モードで読み書きされるようにします。FILEHANDLEが式である場合、値はファイルハンドルの名前として使用されます。成功した場合はtrueを返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。（errno）。</target>
        </trans-unit>
        <trans-unit id="9aa41e54fbd34ab084dcbe15fa8b4cafcc06eac6" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on &lt;code&gt;sv&lt;/code&gt; if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合に、 &lt;code&gt;sv&lt;/code&gt; で相互排他ロックを取得するように手配します。</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合、sv上で相互排除ロックが得られるように手配します。</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合に、スレッド間で sv が共有されるようにアレンジします。</target>
        </trans-unit>
        <trans-unit id="77504b93a8457067677bb3cc3aa5311d924675f5" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">指定されたウォールクロック秒数が経過した後、SIGALRMがこのプロセスに配信されるように調整します。SECONDSが指定されていない場合、&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;格納されている値が使用されます。（一部のマシンでは、残念ながら、秒のカウント方法が原因で、経過時間が指定した時間より最大1秒短いか長い場合があり、プロセスのスケジューリングによって信号の配信がさらに遅れる場合があります。）</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">指定されたウォールクロック秒数が経過した後に、SIGALRMがこのプロセスに配信されるようにします。SECONDSが指定されていない場合、 &lt;code&gt;$_&lt;/code&gt; 格納されている値が使用されます。（一部のマシンでは、残念ながら、秒数のカウント方法が原因で、指定した時間よりも経過時間が最大で1秒短くなる場合があります。また、プロセススケジューリングにより、信号の配信がさらに遅れる場合があります。）</target>
        </trans-unit>
        <trans-unit id="8d25b4a3297455b9e035c6b89f1c17b7c2bce696" translate="yes" xml:space="preserve">
          <source>Array (&lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;)</source>
          <target state="translated">配列（ &lt;code&gt;'@'&lt;/code&gt; または &lt;code&gt;'*@'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">配列補間</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">配列操作関数</target>
        </trans-unit>
        <trans-unit id="380a0ee1c3f2add958e20ae4dd8479917cbbbae8" translate="yes" xml:space="preserve">
          <source>Array holding list of directories to be searched for</source>
          <target state="translated">検索対象となるディレクトリのリストを保持する配列</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">静的ビルド時に含める拡張機能名の配列。MakeMaker は通常、スタティックビルド時にインストールされているすべての拡張機能を使用してビルドを行います。INCLUDE_EXT が指定されている場合、MakeMaker は明示的に指定された拡張機能のみを使ってビルドします。(例:[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">静的ビルド時に除外する拡張モジュール名の配列。これは INCLUDE_EXT が存在する場合は無視されます。詳細は INCLUDE_EXT を参照してください。(例:[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">パッケージ作成者の名前(およびメールアドレス)を含む文字列の配列。CPAN メタファイル (META.yml または META.json)および PPM (Perl Package Manager)の PPD (Perl Package Description)ファイルで使用されます。</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">ユニバーサルシンボルとして利用できるようにするための変数のシンボル名の配列。現在のところ、AIX、OS/2、VMS、Win32でのみ使用されています。デフォルトは[]です。(例:[qw(Foo_version Foo_numstreams Foo_tree)])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スカラーの変更、再配置、または一部のスカラーの加算または減算を行う配列演算は、配列でのみ機能します。これらは修正されたリストでは機能しません。配列操作には、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="4a460c81ea3de2b351104bc9016134c2ac95be02" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="translated">スカラーの変更、再配置、または一部のスカラーの加算または減算を行う配列操作は、配列でのみ機能します。これらは修正されたリストでは機能しません。配列操作には、 &lt;code&gt;shift&lt;/code&gt; 、 &lt;code&gt;unshift&lt;/code&gt; 、 &lt;code&gt;push&lt;/code&gt; 、 &lt;code&gt;pop&lt;/code&gt; 、および &lt;code&gt;splice&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="78674941505b9a2d4a3ebcad653295e98eb9dd4f" translate="yes" xml:space="preserve">
          <source>Array passed to stat will be coerced to a scalar%s</source>
          <target state="translated">statに渡された配列は強制的にスカラ%sになります。</target>
        </trans-unit>
        <trans-unit id="b9dd682c69e6440164f6188906ac10fd3b501a3b" translate="yes" xml:space="preserve">
          <source>Array reference of files to examine. May not be specified with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">調べるファイルの配列参照。 &lt;code&gt;dir&lt;/code&gt; で指定することはできません。</target>
        </trans-unit>
        <trans-unit id="e4a46ecccd0814a0e990fda1f36238fc6513b396" translate="yes" xml:space="preserve">
          <source>Array refs</source>
          <target state="translated">配列参照</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">配列の大きさは、こうすることで求めることができます。</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Perl コードのコンパイル時に optree 構築の「チェック」フェーズで呼び出される関数の配列。ほとんどの(すべてではありませんが)opのタイプでは、一旦opが最初に構築され、子opで満たされると、この配列の適切な要素で参照されるチェック関数によってフィルタリングされます。新しい op はチェック関数の唯一の引数として渡され、チェック関数は完成した op を返します。check関数は(その名の通り)opの有効性やシグナルエラーをチェックします。また、オペの一部を初期化したり変更したり、子オペの追加や削除といったより根本的な手術を行ったり、オペを捨てて別のオペを返したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="cbf55f45c7afc72d6bf912afc7befb393f385b76" translate="yes" xml:space="preserve">
          <source>Arrayref containing the facet-data hashes of events nested under this one.</source>
          <target state="translated">このイベントの下に入れ子になっているイベントのファセットデータハッシュを含むArrayref。</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref。たとえば、[qw（archname manext）]は、config.shからARCHNAMEとMANEXTを定義します。MakeMakerはとにかく次の値をCONFIGに追加します。ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">配列参照。例:[qw(name1 name2)]Makefileのセクションをスキップする(書き込まない)。注意! SKIP属性を無視できるほどの高速化のために使用しないでください。結果のMakefileに深刻なダメージを与える可能性があります。本当に必要な場合のみ使用してください。</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">配列とスライスは、 &lt;code&gt;$&quot;&lt;/code&gt; 変数で指定された区切り記号（&quot; use English; &quot;が指定されている場合は &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; ）、デフォルトではスペースで要素を結合することにより、二重引用符で囲まれた文字列に補間されます。以下は同等です。</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">配列のインデックスはゼロです。ここでは、配列の要素を取得する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">配列のインデックスは 0 からです。 同様に substr()と index()の文字列の位置も同様です。</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="758bdbae166b00a3d8e1212d185299f382e9e26b" translate="yes" xml:space="preserve">
          <source>Arrow Notation</source>
          <target state="translated">アロー表記法</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">アロールール</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">ソフトウェアのローカライズに関する記事</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt;に関する記事またはそれを利用する記事。</target>
        </trans-unit>
        <trans-unit id="a75b4962c21a671a678a35a002d5a9cabe9f37df" translate="yes" xml:space="preserve">
          <source>Artistic License</source>
          <target state="translated">芸術的ライセンス</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;Sky AT決定的にDOTネット&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman、「Where Wizards Fear To Tread」、2002年6月11日、&lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http：//www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">など&lt;a href=&quot;../functions/stat&quot;&gt;のstat&lt;/a&gt;または&lt;a href=&quot;../functions/lstat&quot;&gt;lstatは&lt;/a&gt;なく、アクセス/修正/変更ファイルとオペレーティングシステムとファイルシステムは、このようなタイムスタンプをサポートし、両方の場合は、秒未満の解像度のタイムスタンプ。標準のstat（）をオーバーライドするには：</target>
        </trans-unit>
        <trans-unit id="cad0de4aeb2435c3e6250aa64da21872a52c4d61" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#stat&quot;&gt;&quot;stat&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat&quot; in perlfunc&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">&lt;a href=&quot;perlfunc#stat&quot;&gt;perlfuncで「STAT」&lt;/a&gt;または&lt;a href=&quot;perlfunc#lstat&quot;&gt;「LSTAT」はperlfuncで&lt;/a&gt;はなく秒以下の分解能でのアクセス/修正/変更ファイルのタイムスタンプと、もしオペレーティングシステムとファイルシステムの両方をサポートようにタイムスタンプ。標準のstat（）をオーバーライドするには：</target>
        </trans-unit>
        <trans-unit id="674c2b9678e49fe5c48ffe3cac937cee6706d2ff" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt; but with the ability to set the access/modify file timestamps in subsecond resolution, if the operating system and the filesystem, and the mount options of the filesystem, all support such timestamps.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#utime&quot;&gt;perlfuncでは「utime」と&lt;/a&gt;同じですが、アクセス/変更ファイルのタイムスタンプを1秒未満の解像度で設定する機能があり、オペレーティングシステムとファイルシステム、およびファイルシステムのマウントオプションはすべて、そのようなタイムスタンプをサポートします。</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">&lt;b&gt;-nok&lt;/b&gt;それは古いシステムについて報告する点が異なります。</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">古いシステムについて報告することを除いて&lt;b&gt;-okと&lt;/b&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; として、次のいずれかの名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="bdbf26fc42681222abf14a2b96b2aee6d500b3fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt;, one of the following names must be given.</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; として、次のいずれかの名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">以下のよう &lt;code&gt;-Dm&lt;/code&gt; 出力用のPerlIO層を使用している、それはそれ自体で回避再帰に隠されているのSV、かなり束を割り当てます。代わりに &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; によって提供されるSVログを使用する場合は、PerlIOレイヤーをバイパスできます。</target>
        </trans-unit>
        <trans-unit id="2a4f04aeb40af858ae530be27c732d3a12776244" translate="yes" xml:space="preserve">
          <source>As DSM is a trimmed-down Linux system, it lacks many of the tools and libraries commonly found on Linux. The basic tools like sh, cp, rm, etc. are implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;.</source>
          <target state="translated">DSMは縮小されたLinuxシステムであるため、Linuxで一般的に見られるツールやライブラリの多くが欠けています。sh、cp、rmなどの基本的なツールは&lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="37a9797fcef19ae902b7dc1fdcbae68c956c3e1b" translate="yes" xml:space="preserve">
          <source>As I work on a particular part of my module it's most likely that the tests that cover that code will fail. I'd like to run the whole test suite but have it prioritize these 'hot' tests. I can tell prove to do this:</source>
          <target state="translated">モジュールの特定の部分で作業をしていると、そのコードをカバーするテストが失敗する可能性が高いです。テストスイート全体を実行したいのですが、これらの「ホットな」テストを優先させたいのです。これを行うにはどうすればよいか、私は証明することができます。</target>
        </trans-unit>
        <trans-unit id="3f4dc14381957936768414e0ffe59b0595e92060" translate="yes" xml:space="preserve">
          <source>As JSON cannot directly represent Perl objects, you have to choose between a pure JSON representation (without the ability to deserialise the object automatically again), and a nonstandard extension to the JSON syntax, tagged values.</source>
          <target state="translated">JSON は Perl オブジェクトを直接表現できないので、純粋な JSON 表現 (オブジェクトを自動的に再デシリアライズする機能はありません)と、JSON 構文の非標準拡張であるタグ付き値のどちらかを選択しなければなりません。</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">Perl は世界的なボランティアチームによって開発されているため、私たちのドキュメントには、しばしば</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Storable は文字セットを知らないし、気にもしないので (文字が 8 ビット以上の幅であることは知っていますが)、ホストシステムとターゲットシステムの間で文字コードの解釈に違いがあれば、それはあなたの問題です。特に、ホストとターゲットが浮動小数点数のテキスト表現で使用される文字を表現するために異なるコードポイントを使用している場合、nstore()を使用しても浮動小数点データを交換することはできません。</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">Perlプログラマーを始めたばかりの方は、サードパーティ製のモジュールを使用していることが多いでしょう。</target>
        </trans-unit>
        <trans-unit id="053c80fe967b67f5a7cb2ee310e9489c54536633" translate="yes" xml:space="preserve">
          <source>As a code reference, e.g.:</source>
          <target state="translated">コードリファレンスとして、例えば</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; が通常はレイヤーをポップするという事実の結果として、通常、レイヤー仕様の唯一の要素または最初の要素としてそれを使用することは意味があります。最初の要素として使用される場合、それは例えば上に構築するための既知のベースを提供します</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">結果として、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後の数字または &lt;code&gt;*&lt;/code&gt; を無視します。</target>
        </trans-unit>
        <trans-unit id="794de411ca7a9fef9a487a0fcead83c094be14c9" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;pack&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">結果として、 &lt;code&gt;pack&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後の任意の数または &lt;code&gt;*&lt;/code&gt; を無視します。</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">結果として、演算子 % の動作は、Perl の組み込み % 演算子の動作と一致します (perlop の man ページに記載されています)。</target>
        </trans-unit>
        <trans-unit id="b71d9a336a26729c423fab79edbbfcd18fbf6683" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">便宜上、&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;のsetsockopt（）メソッドは数値をパックされたバイトバッファーに変換し、getsockopt（）は正しいサイズのバイトバッファーをアンパックして数値に戻します。</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">便宜上、&lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt;のsetsockopt（）メソッドは数値をパックされたバイトバッファーに変換し、getsockopt（）は正しいサイズのバイトバッファーをアンパックして数値に戻します。</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">便宜上、1つの引数だけが渡された場合、この引数はテストの名前とみなされます(上記の例のように)。</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">デバッグの補助として、Carpを強制的にクロークを告白として扱い、Carpをクラックとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Pod :: Parserからの派生クラスとして、Pod :: PlainTextは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;を参照してください。簡単に言うと、 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 新しいパーサーを作成してから、parse_from_filehandle（）またはparse_from_file（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="64d726339f8e6e60df57582ad6893533391488ae" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simpleの派生クラスとして、Pod :: Manは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simpleからの派生クラスとして、Pod :: Manは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7614b2907ce626d34be33e5f930e92fbced576b9" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simpleの派生クラスとして、Pod :: Textは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。簡単に言うと、 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; を使用して新しいパーサーを作成し、通常はparse_file（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simpleからの派生クラスとして、Pod :: Textは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。簡単に言うと、 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; 新しいパーサーを作成し、通常はparse_file（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">最後の注意点として、%subr は</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">最後に考えておきたいのは、(執筆時点では)ゼロ時やマイナス時に動くような便利なプログラムを作ることはできないということと、この基本原理は次のように書くことができるということを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="b93fce445dda74a4e62d212ddcfc5d79912e276b" translate="yes" xml:space="preserve">
          <source>As a final word of warning, if you're using adb, &lt;code&gt;make test&lt;/code&gt; may appear to hang; this is because it doesn't output anything until it finishes running all tests. You can check its progress by logging into the device, moving to</source>
          <target state="translated">あなたがADBを使用している場合、警告の最後の言葉として、 &lt;code&gt;make test&lt;/code&gt; ハングアップしたように見えることがあり、これは、すべてのテストの実行が終了するまで何も出力しないためです。デバイスにログインし、に移動すると、進行状況を確認できます。</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">さらなる例として、これは、これらのコードを &lt;code&gt;C&lt;/code&gt; （コード）スタイルで記述したい場合に次のことを意味します。</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">さらなる例として。執筆時点では、&quot;biblio &quot;識別子はサポートされていませんが、(通常の段落の書式コードを必然的に含む)書誌参照を示す(例えば)方法として、それを認識するためのプロセッサが書かれていたとしましょう。&quot;biblio &quot;段落が通常の処理のためのものであるという事実は、各 &quot;biblio &quot;識別子の前にコロンを付けることで示されるだろう。</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">さらなる最適化として、 &lt;code&gt;FETCH&lt;/code&gt; の evalブロックからの出口で、ブロックに続くコードの実行が内部ループで引き続き実行されます。例外が発生すると、 &lt;code&gt;docatch&lt;/code&gt; は比較 &lt;code&gt;JMPENV&lt;/code&gt; のレベル &lt;code&gt;CxEVAL&lt;/code&gt; をして &lt;code&gt;PL_top_env&lt;/code&gt; し、それらが異なる場合は、単に例外を再スローします。このようにして、内部ループがポップされます。</target>
        </trans-unit>
        <trans-unit id="52bd4fd38df2dbb2fd4340b3f74e473ef3bdf3bc" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt;, execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">さらなる最適化として、 &lt;code&gt;FETCH&lt;/code&gt; のevalブロックを終了すると、ブロックに続くコードの実行は引き続き内部ループで実行されます。例外が発生すると、 &lt;code&gt;docatch&lt;/code&gt; は比較 &lt;code&gt;JMPENV&lt;/code&gt; のレベル &lt;code&gt;CxEVAL&lt;/code&gt; をして &lt;code&gt;PL_top_env&lt;/code&gt; し、それらが異なる場合は、単に例外を再スローします。このようにして、内側のループがポップされます。</target>
        </trans-unit>
        <trans-unit id="3a1271bc4a381b470fd6a076ccacce4ffa6ad068" translate="yes" xml:space="preserve">
          <source>As a further performance optimisation, the various &lt;code&gt;PUSH&lt;/code&gt; macros all operate using a local variable &lt;code&gt;SP&lt;/code&gt;, rather than the interpreter-global variable &lt;code&gt;PL_stack_sp&lt;/code&gt;. This variable is declared by the &lt;code&gt;dSP&lt;/code&gt; macro - though it is normally implied by XSUBs and similar so it is rare you have to consider it directly. Once declared, the &lt;code&gt;PUSH&lt;/code&gt; macros will operate only on this local variable, so before invoking any other perl core functions you must use the &lt;code&gt;PUTBACK&lt;/code&gt; macro to return the value from the local &lt;code&gt;SP&lt;/code&gt; variable back to the interpreter variable. Similarly, after calling a perl core function which may have had reason to move the stack or push/pop values to it, you must use the &lt;code&gt;SPAGAIN&lt;/code&gt; macro which refreshes the local &lt;code&gt;SP&lt;/code&gt; value back from the interpreter one.</source>
          <target state="translated">さらなるパフォーマンスの最適化として、さまざまな &lt;code&gt;PUSH&lt;/code&gt; マクロはすべて、インタープリターグローバル変数 &lt;code&gt;PL_stack_sp&lt;/code&gt; ではなく、ローカル変数 &lt;code&gt;SP&lt;/code&gt; を使用して動作します。この変数は &lt;code&gt;dSP&lt;/code&gt; マクロによって宣言されます-通常はXSUBなどによって暗示されるため、直接考慮する必要があることはめったにありません。宣言されると、 &lt;code&gt;PUSH&lt;/code&gt; マクロはこのローカル変数でのみ動作するため、他のperlコア関数を呼び出す前に、 &lt;code&gt;PUTBACK&lt;/code&gt; マクロを使用してローカル &lt;code&gt;SP&lt;/code&gt; から値を返す必要があります。変数をインタプリタ変数に戻します。同様に、スタックまたはプッシュ/ポップ値をそこに移動する理由があった可能性のあるperlコア関数を呼び出した後、ローカル &lt;code&gt;SP&lt;/code&gt; 値をインタープリターから更新する &lt;code&gt;SPAGAIN&lt;/code&gt; マクロを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">一般的な経験則として、あなたのコミットメッセージは、Perl のコアを知っているプログラマが、あなたが何をしようとしていたのか、どのようにそれをしようとしていたのか、そしてなぜその変更が Perl にとって重要なのかを素早く理解するのに役立つものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">原則として</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">一般的なルールとして、モジュールがオブジェクト指向である場合、何もエクスポートしません。関数のコレクションだけの場合は、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 以外は何でも &lt;code&gt;@EXPORT&lt;/code&gt; を使用してください。関数名とメソッド名には、エクスポートリストのアンパサンドを前に付けた名前よりも、ベアワードを使用します。</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">一般的なルールとして、モジュールがオブジェクト指向であろうとしている場合は、何もエクスポートしません。ただの関数の集合体であれば @EXPORT_OK 何でも良いのですが、@EXPORT は注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">原則として、モジュールがオブジェクト指向である場合は、何もエクスポートしないでください。関数と変数のコレクションの場合は、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; と呼ばれる別の配列を介してそれらをエクスポートできます。この配列は、ユーザーが特別にこれを実行するように要求しない限り、サブルーチンと変数の名前を名前空間に自動的に配置しません。</target>
        </trans-unit>
        <trans-unit id="d1e3854176f62c2a9d9d5efd5fe3ab87123d6cec" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt;. This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">原則として、モジュールがオブジェクト指向にしようとしている場合は、何もエクスポートしないでください。関数と変数の単なるコレクションである場合は、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; と呼ばれる別の配列を介してそれらをエクスポートできます。この配列は、ユーザーが特に要求しない限り、サブルーチン名と変数名を名前空間に自動的に配置しません。</target>
        </trans-unit>
        <trans-unit id="e7b6a2f89138fc36d28abf12c8042d8936138512" translate="yes" xml:space="preserve">
          <source>As a historical predecessor, Microsoft's variant probably has more rights for the name, though it may be objected that Microsoft shouldn't have used JIS as part of the name in the first place.</source>
          <target state="translated">歴史的な前身としては、マイクロソフトの変種の方が名前の権利を多く持っていると思われますが、そもそもマイクロソフトがJISを名前の一部として使うべきではなかったという反論もあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">しかし、最後の手段として</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">最後の手段として、perlのワンライナーを使うことができます。</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">最後の手段として、 &lt;code&gt;PERL5DB&lt;/code&gt; を使用して、内部変数を直接設定するか、デバッガー関数を呼び出して、デバッガーをカスタマイズすることもできます。</target>
        </trans-unit>
        <trans-unit id="3641087c3ef51813afe729b7c79e589f770bbb23" translate="yes" xml:space="preserve">
          <source>As a matter of policy we do &lt;b&gt;not&lt;/b&gt; edit the history of the blead and maint-* branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll fix it in another commit. The only types of updates allowed on these branches are &quot;fast-forwards&quot;, where all history is preserved.</source>
          <target state="translated">ポリシーの問題として、bleadおよびmaint- *ブランチの履歴は編集しませ&lt;b&gt;ん&lt;/b&gt;。タイプミス（またはさらに悪いこと）がbleadまたはmaint- *のコミットに潜入した場合、別のコミットで修正します。これらのブランチで許可される更新のタイプは、すべての履歴が保持される「早送り」のみです。</target>
        </trans-unit>
        <trans-unit id="04cbbe97dbf5020460c7615ae57692f7d59ba371" translate="yes" xml:space="preserve">
          <source>As a nonstandard extension to the JSON syntax that is enabled by the &lt;code&gt;relaxed&lt;/code&gt; setting, shell-style comments are allowed. They can start anywhere outside strings and go till the end of the line.</source>
          <target state="translated">&lt;code&gt;relaxed&lt;/code&gt; された設定によって有効になるJSON構文の非標準の拡張として、シェルスタイルのコメントが許可されます。文字列の外側のどこからでも開始して、行の終わりまで進むことができます。</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">名詞として、より小さな部分から構成される構文の一部。推移動詞として、&lt;b&gt;コンストラクター&lt;/b&gt;を使用して&lt;b&gt;オブジェクト&lt;/b&gt;を作成し&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d308f1d2a7a4e49c9b329da294e48e6b1847ac8e" translate="yes" xml:space="preserve">
          <source>As a qr// compiled regular expression, e.g.:</source>
          <target state="translated">qr//コンパイルされた正規表現として。</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">これらの問題の結果、v5.20からPerlは、非Unicodeコードポイントを典型的な未割り当てUnicode文字として扱い、それに応じてマッチするようになりました。(注意:Unicode には非定型の未割り当てコードポイントがあります。例えば、非文字コードポイントと、それらが割り当てられた場合、アラビア語やヘブライ語がそうであるように、右から左に書かれるように運命づけられているコードポイントを持っています。Perlは、非Unicodeコードポイントが非定型の特性を持っていないことを前提としています。)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">その結果、 &lt;code&gt;$?&lt;/code&gt; サブプロセスの終了ステータスが正常終了を示した場合は常に0になり、警告またはエラーが発生した場合、またはエンコード_POSIX_EXIT値に準拠したプログラムが実行されてステータスが設定された場合は、0以外になります。</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">スカラー演算子として</target>
        </trans-unit>
        <trans-unit id="752c53cfef8630f9f583dd0b9dbea60f05156327" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be written &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">ショートカットとして &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; を書くことができます &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">ショートカットとして &lt;code&gt;(*MARK:NAME)&lt;/code&gt; と書くことができます &lt;code&gt;(*:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">ショートカットとして、1引数の呼び出しは、ファイルハンドルと同じ名前のグローバルスカラ変数からファイル名を取得します。</target>
        </trans-unit>
        <trans-unit id="039d51ec286cc421077f33a0f875e9f7cff415a2" translate="yes" xml:space="preserve">
          <source>As a shortcut, a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">ショートカットとして、1引数の呼び出しは、ファイルハンドルと同じ名前のグローバルスカラ変数からファイル名を取得します。</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">ショートカットとして、モジュール&lt;a href=&quot;../bignum&quot;&gt;bignumを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="36ff34b524a3157846677e62919073347584851b" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">ショートカットとして、モジュール&lt;a href=&quot;bignum&quot;&gt;bignumを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">副作用として、 &lt;code&gt;_&lt;/code&gt; は機能しないため、スタックされた &lt;code&gt;-f -w $file&lt;/code&gt; テスト演算子（-f -w $ file）も機能しません。</target>
        </trans-unit>
        <trans-unit id="62159e969c4500e73917688c4b98b60605e2b166" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt;) won't work either.</source>
          <target state="translated">副作用として、 &lt;code&gt;_&lt;/code&gt; が機能しないため、スタック &lt;code&gt;-f -w $file&lt;/code&gt; テスト演算子（-f -w $ file）も機能しません。</target>
        </trans-unit>
        <trans-unit id="46d4d9254656022c6da49a40120c1e05ea2c02db" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the keys. In particular, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;呼び出すと、キーを生成する前にHASHまたはARRAYの内部イテレータ（&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;参照）がリセットされます。特に、voidコンテキストで&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;を呼び出すと、他のオーバーヘッドなしでイテレータがリセットされます。</target>
        </trans-unit>
        <trans-unit id="2e28725785d22d9074c048ed573cb348e22b3201" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; resets the HASH or ARRAY's internal iterator (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the values. In particular, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;呼び出すと、値を生成する前にHASHまたはARRAYの内部イテレータ（&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;参照）がリセットされます。特に、voidコンテキストで&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;を呼び出すと、他のオーバーヘッドなしでイテレータがリセットされます。</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、keys（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます（&lt;a href=&quot;#each&quot;&gt;それぞれを&lt;/a&gt;参照）。特に、voidコンテキストでkeys（）を呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、keys（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます（&lt;a href=&quot;each&quot;&gt;それぞれを&lt;/a&gt;参照）。特に、voidコンテキストでkeys（）を呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">副作用として、values（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます。&lt;a href=&quot;#each&quot;&gt;それぞれを&lt;/a&gt;参照してください。 （特に、values（）をvoidコンテキストで呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。イテレーターをリセットする &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; 、リストコンテキストの値 @arrayはプレーン &lt;code&gt;@array&lt;/code&gt; と同じです（voidコンテキスト &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; を使用することをお勧めしますこのために、しかし取っていることを推論した &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; でそれを残してより多くのドキュメントを必要とするアウト。）</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">副作用として、values（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます。&lt;a href=&quot;each&quot;&gt;それぞれを&lt;/a&gt;参照してください。 （特に、values（）をvoidコンテキストで呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。イテレーターをリセットする &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; 、リストコンテキストの値 @arrayはプレーン &lt;code&gt;@array&lt;/code&gt; と同じです（voidコンテキスト &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; を使用することをお勧めしますこのために、しかし取っていることを推論した &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; でそれを残してより多くのドキュメントを必要とするアウト。）</target>
        </trans-unit>
        <trans-unit id="af3e12604d06f443cb762354f1d6409bffc768b2" translate="yes" xml:space="preserve">
          <source>As a side effect, the timestamps of the written specfiles reflect the linear order of all dependencies.</source>
          <target state="translated">副作用として、書き込まれたspecfilesのタイムスタンプは、すべての依存関係の直線的な順序を反映しています。</target>
        </trans-unit>
        <trans-unit id="cb674c50cbe5a1c37b1e7edbe788950bfe9342b0" translate="yes" xml:space="preserve">
          <source>As a simple string.</source>
          <target state="translated">単純な文字列として</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">特殊なケースとして</target>
        </trans-unit>
        <trans-unit id="0643313e18655a38535055ff2dedcaffb5a9d742" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt;) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; の&lt;/a&gt;特殊なケースとして、&lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match演算子&lt;/a&gt;構文（ &lt;code&gt;//&lt;/code&gt; ）で指定された空のパターンは、空の文字列と特に一致します。これは、最後に成功した一致としての通常の解釈とは異なります。</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; の特殊なケースとして、&lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;一致演算子&lt;/a&gt;構文（ &lt;code&gt;//&lt;/code&gt; ）で指定された空のパターンは、空の文字列と明確に一致します。これは、最後に成功した一致としての通常の解釈とは逆です。</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; の特殊なケースとして、&lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;一致演算子&lt;/a&gt;構文（ &lt;code&gt;//&lt;/code&gt; ）で指定された空のパターンは、空の文字列と明確に一致します。これは、最後に成功した一致としての通常の解釈とは逆です。</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">特別なケースとして、オーバーロードがオブジェクト自体を返す場合、それは直接使用されます。 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; のようなものを取得する可能性が高いため、オブジェクトを返すオーバーロードされた変換はおそらくバグです。</target>
        </trans-unit>
        <trans-unit id="a27c6716a696c868b2b90bc0841f6de8cd23a521" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt;.</source>
          <target state="translated">特別な場合として、オーバーロードがオブジェクト自体を返す場合、それは直接使用されます。 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; のようなものが得られる可能性があるため、オブジェクトを返すオーバーロードされた変換はおそらくバグです。</target>
        </trans-unit>
        <trans-unit id="6b483703a04a580981cff65069d8ecd06f49d995" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">特別な場合として、読み取り/書き込みモードと3番目の引数が&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; で&lt;/a&gt;ある3つの引数形式：</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">特別なケースとして、読み取り/書き込みモードと3番目の引数が &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; である3つの引数のフォーム：</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">特別なケースとして、読み取り/書き込みモードと3番目の引数が &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; である3つの引数のフォーム：</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">特別な場合として、 &lt;code&gt;\(@foo)&lt;/code&gt; の内容への参照のリストを返し &lt;code&gt;@foo&lt;/code&gt; 、しないように参照 &lt;code&gt;@foo&lt;/code&gt; 自身を。キー参照がコピーへの参照であることを除いて、 &lt;code&gt;%foo&lt;/code&gt; と同様です（キーは本格的なスカラーではなく単なる文字列であるため）。</target>
        </trans-unit>
        <trans-unit id="783b2ec5714a2b5973ee8fd00ae088eee54cd571" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt;, not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt;, except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">特別な場合として、 &lt;code&gt;\(@foo)&lt;/code&gt; の内容への参照のリストを返し &lt;code&gt;@foo&lt;/code&gt; 、しないように参照 &lt;code&gt;@foo&lt;/code&gt; 自身を。 &lt;code&gt;%foo&lt;/code&gt; の場合も同様ですが、キーの参照がコピーに対するものである点が異なります（キーは本格的なスカラーではなく単なる文字列であるため）。</target>
        </trans-unit>
        <trans-unit id="e559b691f686abba65a2b1bdefbe0a3fb92d6845" translate="yes" xml:space="preserve">
          <source>As a special case, if the constructor is passed a single argument (as opposed to an even-sized list of key/value pairs), it is taken to be the value of the &lt;code&gt;PeerAddr&lt;/code&gt; parameter. This is parsed in the same way, according to the behaviour given in the &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSING section below.</source>
          <target state="translated">特別な場合として、コンストラクターに（キーと値のペアの偶数サイズのリストではなく）単一の引数が渡された場合、それは &lt;code&gt;PeerAddr&lt;/code&gt; パラメーターの値と見なされます。これは、以下の &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSINGセクションに示されている動作に従って、同じ方法で解析されます。</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;for&lt;/code&gt; ループ（または対応する &lt;code&gt;while&lt;/code&gt; ループ）のテストが空の場合、trueとして扱われます。つまり、両方</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">特殊なケースとして、この変数の値がスペースで区切られている場合、尾を &lt;code&gt;o=0&lt;/code&gt; または &lt;code&gt;ornaments=0&lt;/code&gt; に設定することにより、尾を使用して装飾を無効にすることができます。頭は上で説明したとおりでなければなりません、と言う</target>
        </trans-unit>
        <trans-unit id="ea8552b1560e05c9733562fefc877a4a04a62b1f" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt;. The head should be as described above, say</source>
          <target state="translated">特別な場合として、この変数の値がスペースで区切られている場合、テールを &lt;code&gt;o=0&lt;/code&gt; または &lt;code&gt;ornaments=0&lt;/code&gt; に設定することにより、テールを使用してオーナメントを無効にすることができます。頭は上記のようにする必要があります、</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">特殊なケースとして、モジュール名 &lt;code&gt;Unicode&lt;/code&gt; を指定すると、要求されたperlバージョンにバンドルされているUnicode Character Databaseのバージョン番号が取得されます。</target>
        </trans-unit>
        <trans-unit id="ed0f26789d5db7e7c0ccec99b141a92d811bb2de" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt;, you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">特別な場合として、モジュール名 &lt;code&gt;Unicode&lt;/code&gt; を指定すると、要求されたperlバージョンにバンドルされているUnicode文字データベースのバージョン番号を取得します。</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">特殊なケースとして、ハッシュ参照を唯一の引数としてアクセサが呼ばれた場合、これはハッシュ要素全体の代入を引き起こします。オブジェクト参照が返されます。</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">特殊なケースとして、配列参照を唯一の引数としてアクセサが呼ばれた場合、配列要素全体が代入されます。オブジェクト参照が返されます。</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">特別な例外として、(配列やハッシュではなく)リストをスライスした場合、リストが空と評価された場合、その空のリストをスライスすると、常に空のリストが順番に返されます。したがって、次のようになります。</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">ベンダーとして、3年間のサポート契約を超えてセキュリティ修正をバックポートする必要がある場合があります。番号付きのリリースや「公式」パッチを利用できるようにすることもしないこともできますが、可能な限り、これらのパッチをgitの関連する-maintブランチに適用しようとします。そのプロセスを開始するには、&amp;lt;perl5-security-report@perl.org&amp;gt;までご連絡ください。</target>
        </trans-unit>
        <trans-unit id="f4351851a4bb7c858433022e707056375232e54d" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. See &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;&quot;SECURITY VULNERABILITY CONTACT INFORMATION&quot; in perlsec&lt;/a&gt; for details on how to begin that process.</source>
          <target state="translated">ベンダーとして、3年間のサポートコミットメントを超えてセキュリティ修正をバックポートする必要がある場合があります。限られたサポートとアドバイスを提供することができます。可能な場合は、それらのパッチをgitの関連する-maintブランチに適用しようとしますが、番号付きリリースまたは「公式」パッチを利用できるようにする場合としない場合があります。参照してください&lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;perlsecをして「セキュリティ脆弱性の連絡先情報を」&lt;/a&gt;というプロセスを開始する方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">ボランティア組織として、私たちが行うコミットメントは、Perlに貢献する義務のない個人の善意と努力に大きく依存しています。</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">上記と同様ですが、リンク先のノードのテキスト。</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">すべての値がtrueと評価されるため、拡張が存在するかどうかを判断するには、単純な &lt;code&gt;if&lt;/code&gt; テストで十分です。</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">先ほども述べたように、インライン化されたサブジェクトのボディが他に参照を持たないスカラーから構成されている場合、BEGIN 時に動的にインライン化されたサブジェクトを宣言することもできます。ここでは、最初の例だけがインライン化されます。</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; の代替として 制御フローに使用する場合、Perlは &lt;code&gt;and&lt;/code&gt; および &lt;code&gt;or&lt;/code&gt; 演算子を提供します（以下を参照）。短絡動作は同じです。ただし、 &lt;code&gt;&quot;and&quot;&lt;/code&gt; と &lt;code&gt;&quot;or&quot;&lt;/code&gt; の優先順位ははるかに低いため、括弧を必要とせずにリスト演算子の後に安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">Perlではいつものように、それを行う方法は一つだけではありません。以下に、数値表現間で共通の変換を行うためのアプローチの例をいくつか挙げます。これは網羅的なものではなく、代表的なものであることを意図しています。</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">いつものように公式にバグだと宣言されたものがあれば修正されて削除されます。</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">いつものように、サーバーの設定はクライアントの実行よりも少し複雑です。モデルは、サーバーが特別な種類のソケットを作成し、特定のポートで着信接続をリッスンするだけであるというものです。これは、クライアントとは少し異なる引数を指定して &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; メソッドを呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="b052d1d2bb45ec362535f92deef9adc1abd8b3f0" translate="yes" xml:space="preserve">
          <source>As an (ahem) accidental feature, &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines were looked up as methods (using the &lt;code&gt;@ISA&lt;/code&gt; hierarchy) even when the subroutines to be autoloaded were called as plain functions (e.g. &lt;code&gt;Foo::bar()&lt;/code&gt;), not as methods (e.g. &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; or &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt;).</source>
          <target state="translated">（ahem）偶発的な機能として、自動ロードされるサブルーチンがメソッド（ &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; など）ではなくプレーン関数（ &lt;code&gt;Foo::bar()&lt;/code&gt; ）として呼び出された場合でも、 &lt;code&gt;AUTOLOAD&lt;/code&gt; サブルーチンは（ &lt;code&gt;@ISA&lt;/code&gt; 階層を使用して）メソッドとして検索されました。-&amp;gt; bar（）または &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">追加の利便性として、Digest::SHAモジュールはHMAC-SHA-1/224/256/384/512アルゴリズムを使用して鍵付きハッシュを計算するルーチンを提供します。これらのサービスは、機能的な形でのみ存在しており</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">色をリセットする際の補助として、colored()は第一引数にスカラを、第二引数に属性文字列を任意の数だけ受け取り、スカラをエスケープコードで包み込んだものを返します。あるいは、第一引数に配列への参照を渡して、その配列の内容をアトリビュートとカラーコードとして受け取り、残りの引数をテキストとして色付けすることもできます。</target>
        </trans-unit>
        <trans-unit id="0317f97de63b01d4c67910fb17a2e6ee0d204ecf" translate="yes" xml:space="preserve">
          <source>As an alternative to subclassing the components I need to change I can attach callbacks to the default classes. TAP::Harness exposes these callbacks:</source>
          <target state="translated">変更したいコンポーネントをサブクラス化する代わりに、デフォルトのクラスにコールバックをアタッチすることができます。TAP::Harness はこれらのコールバックを公開しています。</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">上記の代わりに、Error モジュールを使用して例外を投げることもできます。</target>
        </trans-unit>
        <trans-unit id="8f3dc04daa3638b5aaf1c862a68465a157788d9e" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">名前付きパラメーターの使用法の代わりに、 &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; オブジェクトを最初の引数として渡すことができ、そのコピーがタイプマップに追加されます。その場合、オブジェクトの後に使用できるのは、名前付きパラメーターの &lt;code&gt;replace&lt;/code&gt; または &lt;code&gt;skip&lt;/code&gt; のみです。例：</target>
        </trans-unit>
        <trans-unit id="f943c4f68c18459667f13d0990dfceca7c5ca2a9" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">名前付きパラメーターの使用法の代わりに、 &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; オブジェクトを最初の引数として渡すことができ、そのコピーがタイプマップに追加されます。その場合、オブジェクトの後に使用できるのは、名前付きパラメーターの &lt;code&gt;replace&lt;/code&gt; または &lt;code&gt;skip&lt;/code&gt; のみです。例：</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">別の方法として、オーバーロードされた定数（&lt;a href=&quot;overload&quot;&gt;overloadを&lt;/a&gt;参照）は、あるパターンを別のパターンに置き換えることにより、REエンジンの機能を拡張する簡単な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">別の方法として、文字のリストの代わりに数字を指定します（たとえば、&lt;b&gt;-D14&lt;/b&gt;は&lt;b&gt;-Dtls&lt;/b&gt;と同等&lt;b&gt;です&lt;/b&gt;）：</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">別の方法として、元の単語よりも長い場合に置換語の大文字小文字を区別しないようにするには、Jeff Pinyanによるこのコードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b70856a89ed6672d06c69a35074c3c6f2093e9dd" translate="yes" xml:space="preserve">
          <source>As an example consider the structure of a zip file. This is a well-defined file format that mixes both compressed and uncompressed sections of data in a single file.</source>
          <target state="translated">例として、zip ファイルの構造を考えてみましょう。これは、データの圧縮された部分と圧縮されていない部分の両方を1つのファイルにまとめる、よく定義されたファイル形式です。</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; でキャッチされたものの例として、それ以外の場合はパターンは</target>
        </trans-unit>
        <trans-unit id="ec5fbaf06c5491bc9e0146955b6b1bccb85f04a8" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt;, but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; 下でキャッチされるものの例として、そうでない場合はパターンがあります</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">この場合の例として、このコードは &quot;Perl exited with active threads.&quot;というメッセージを表示します。2つのスレッドが実行されていて、結合されていません。</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">所有的量詞が適している例として、いくつかのプログラミング言語で使用されている引用符で囲まれた文字列のマッチングを考えてみます。バックスラッシュはエスケープ文字として使用され、次の文字が文字列の別の文字として文字通りに解釈されることを示します。したがって、冒頭の引用符の後には、エスケープされていない引用符やバックスラッシュ以外の文字、またはエスケープされた文字のいずれかの選択肢が(おそらくは空の)連続であることが予想されます。</target>
        </trans-unit>
        <trans-unit id="5cd508967ae1e206046e267640fdf9448ece0fe7" translate="yes" xml:space="preserve">
          <source>As an example, let's implement a &lt;code&gt;THAW&lt;/code&gt; function that regenerates the &lt;code&gt;My::Object&lt;/code&gt; from the &lt;code&gt;FREEZE&lt;/code&gt; example earlier:</source>
          <target state="translated">例として、前の &lt;code&gt;FREEZE&lt;/code&gt; の例から &lt;code&gt;My::Object&lt;/code&gt; を再生成する &lt;code&gt;THAW&lt;/code&gt; 関数を実装しましょう。</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">例として、Perlは &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; を検出すると、文字をUTF-8でエンコードし、$ xに格納します。その後、文字データとしてマークされるため、たとえば、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。ただし、 &lt;code&gt;bytes&lt;/code&gt; プラグマのスコープでは、$ xは一連のバイト（UTF8エンコーディングを構成するバイト）として扱われ、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4cc20e99e2c8e44ee448eca66f36aaad208e30f4" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = chr(400)&lt;/code&gt;, it encodes the character in UTF-8 and stores it in &lt;code&gt;$x&lt;/code&gt;. Then it is marked as character data, so, for instance, &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, &lt;code&gt;$x&lt;/code&gt; is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">例として、Perlが &lt;code&gt;$x = chr(400)&lt;/code&gt; を検出すると、UTF-8で文字をエンコードし、 &lt;code&gt;$x&lt;/code&gt; 格納します。次に、文字データとしてマークされるため、たとえば、 &lt;code&gt;length $x&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。ただし、 &lt;code&gt;bytes&lt;/code&gt; プラグマの範囲では、 &lt;code&gt;$x&lt;/code&gt; は一連のバイト（UTF8エンコーディングを構成するバイト）として扱われ、 &lt;code&gt;length $x&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">暫定的な対策として、スクリプトの #! 行を変更して、古いバージョンの perl を具体的に参照するようにします。例えば、Solaris 9 では #!/usr/perl5/5.00503/bin/perl を使用して、Solaris 8 のデフォルトの perl バージョンを使用するようにします。これは、/usr/perl5 の下の適切なシンボリックリンクを以下のように変更することで行うことができます (Solaris 9 の場合の例)。</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">最適化として、 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 指定されたコマンドシェルを呼び出さない場合があります。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; は外部プロセスを生成し、プロセスの終了を待たずにすぐにそのプロセス指定子を返します。戻り値は、後で &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; で使用できます。サブプロセスの &lt;code&gt;spawn()&lt;/code&gt; の失敗は、 &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; 。 &lt;code&gt;$?&lt;/code&gt; Unixと互換性のある方法で設定されます（つまり、ドキュメンテーションに記載されているように、サブプロセスの終了ステータスは &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot; &amp;gt;&amp;gt; によって取得されます）。 （Win32）</target>
        </trans-unit>
        <trans-unit id="137d06b82a3cf943b3082535121ce9ca48c386c5" translate="yes" xml:space="preserve">
          <source>As another example, this Pod source:</source>
          <target state="translated">別の例として、このPodソース。</target>
        </trans-unit>
        <trans-unit id="24dac5f3b0ae02bfc967e018bd163c71db2de949" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a string composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt;, but not e.g. &lt;code&gt;/ /&lt;/code&gt;). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt;; in particular, this means that</source>
          <target state="translated">別の特別な場合として、&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;、コマンドラインツールのデフォルトの動作をエミュレート&lt;b&gt;awkの&lt;/b&gt;パターンはどちらか省略されているか、単一のスペース文字で構成される文字列（例えば &lt;code&gt;' '&lt;/code&gt; または &lt;code&gt;&quot;\x20&quot;&lt;/code&gt; ではなく、例えば &lt;code&gt;/ /&lt;/code&gt; ）。この場合、EXPRの先頭の空白は分割が発生する前に削除され、代わりにPATTERNは &lt;code&gt;/\s+/&lt;/code&gt; かのように扱われます。特に、これは</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">別の特別な場合として、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 、コマンドラインツールのデフォルトの動作をエミュレート&lt;b&gt;のawkを&lt;/b&gt;パターンのいずれかを省略またはAれるとき</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">別の特別な場合として、 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 、コマンドラインツールのデフォルトの動作をエミュレート&lt;b&gt;のawkを&lt;/b&gt;パターンのいずれかを省略またはAれるとき</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">この問題の別の回避策として、Perlの5.10.0は導入 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; と &lt;code&gt;${^POSTMATCH}&lt;/code&gt; と等価であり、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; や &lt;code&gt;$'&lt;/code&gt; 、&lt;b&gt;を除く&lt;/b&gt;それらはだけに保証されていることを &lt;code&gt;/p&lt;/code&gt; （保持）修飾子を使用して実行された一致が成功した後に定義されます。これらの変数を使用しても、同等の句読点文字とは異なり、グローバルパフォーマンスが低下することはありませんが、トレードオフで、使用するときにperlに通知する必要があります。Perl 5.20以降、これらの3つの変数は &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; および &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;/p&lt;/code&gt; と同等です。 無視されます。</target>
        </trans-unit>
        <trans-unit id="5306125a9b9482228b73d9001504cb8ff0235e3b" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, which are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation character equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">この問題の別の回避策として、Perlの5.10.0は導入 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; と &lt;code&gt;${^POSTMATCH}&lt;/code&gt; と等価であり、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; や &lt;code&gt;$'&lt;/code&gt; 、&lt;b&gt;を除く&lt;/b&gt;それらはだけに保証されていることを &lt;code&gt;/p&lt;/code&gt; （保存）修飾子を使用して実行された一致が成功した後に定義されます。これらの変数を使用しても、句読文字の同等物とは異なり、グローバルなパフォーマンスの低下は発生しませんが、トレードオフとして、いつ使用するかをperlに通知する必要があります。Perl 5.20以降、これらの3つの変数は、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; 、 &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;/p&lt;/code&gt; と同等です。 無視されます。</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">説明したように&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上記&lt;/a&gt;、Perlのような演算子のための方法を呼び出すことができる &lt;code&gt;+&lt;/code&gt; をと &lt;code&gt;&amp;amp;&lt;/code&gt; ような欠落動作を実現する過程において &lt;code&gt;++&lt;/code&gt; 、 &lt;code&gt;+=&lt;/code&gt; 、および &lt;code&gt;&amp;amp;=&lt;/code&gt; 。これらのメソッドは、3番目の引数の定義をテストすることによってこの使用法を検出する可能性がありますが、すべての場合において、オペランドの変更を回避する必要があります。これは、Perlがこれらのメソッドを呼び出す前にコピーコンストラクターを呼び出さないためです。</target>
        </trans-unit>
        <trans-unit id="20dd96aab8100e801c2698dbb8e487016840bd2c" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and &lt;code&gt;&amp;amp;=&lt;/code&gt;. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">説明したように&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上記&lt;/a&gt;、Perlのような演算子のための方法を呼び出すことができる &lt;code&gt;+&lt;/code&gt; をと &lt;code&gt;&amp;amp;&lt;/code&gt; ような欠落動作を実現する過程において &lt;code&gt;++&lt;/code&gt; 、 &lt;code&gt;+=&lt;/code&gt; 、および &lt;code&gt;&amp;amp;=&lt;/code&gt; 。これらのメソッドは、3番目の引数の定義をテストすることでこの使用法を検出できますが、すべての場合において、オペランドの変更を回避する必要があります。これは、Perlがこれらのメソッドを呼び出す前にコピーコンストラクターを呼び出さないためです。</target>
        </trans-unit>
        <trans-unit id="e9c1d88156738ffdc72a22d4eb2c079c412ad705" translate="yes" xml:space="preserve">
          <source>As described earlier, if there are many changes on your smoke-me branch then you should prepare a merge commit in which to give an overview of those changes by using the following command instead of the last command above:</source>
          <target state="translated">先ほど説明したように、もし smoke-me ブランチに多くの変更があった場合は、マージコミットを準備して、その変更の概要を示すために、上記の最後のコマンドの代わりに以下のコマンドを使うべきです。</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">別の場所で議論されているように、Perl は 2 つの世界のそれぞれに片足 (2 本の蹄?)を置いています:ASCII とシングルバイトのロケールの古い世界と、Unicode の新しい世界です。古いコードが明示的に Unicode を使用していない場合、自動的に Unicode への切り替えは行われるべきではありません。</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">上で説明したように、その関数がコンパイルされたときに見える字句変数にアクセスできる匿名関数は、クロージャを作成します。シグナルハンドラや Tk コールバックのように、後になってから実行されなくても、これらの変数へのアクセスは保持されます。</target>
        </trans-unit>
        <trans-unit id="03fe8a37ea6c568501bcfeecc21187a67095c9a8" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot;&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;「ASCIIルールとUnicodeルール」&lt;/a&gt;で説明されているように、ASCIIルールでは、割り当てられていない文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCIIルールとUnicodeルール&lt;/a&gt;で説明されているように、ASCIIルールでは、これらは割り当てられていない文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="48e236093008993b6e4def956b958d0cb620db14" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot;&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist%28%29&quot;&gt;「prop_invlist（）」&lt;/a&gt;で説明されているように、コードポイントがリストにあるかどうかは、インデックスが偶数（in）か奇数（not in）かによって異なります。また、&lt;a href=&quot;#prop_invmap%28%29&quot;&gt;「prop_invmap（）」&lt;/a&gt;で説明されているように、インデックスは、返された並列配列とともに使用され、マッピングが検索されます。</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist（）&lt;/a&gt;で説明したように、コードポイントがリスト内にあるかどうかは、インデックスが偶数（in）か奇数（not in）かによって異なります。そして、&lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap（）&lt;/a&gt;で説明されているように、返された並列配列でインデックスを使用してマッピングを見つけます。</target>
        </trans-unit>
        <trans-unit id="bf0e7abd7a09ee9c2ba9a8344c5b618840f66e79" translate="yes" xml:space="preserve">
          <source>As far as creating the &lt;code&gt;$pOverlapped&lt;/code&gt; structure, you are currently on your own.</source>
          <target state="translated">&lt;code&gt;$pOverlapped&lt;/code&gt; 構造を作成する限り、現在は自分で作成しています。</target>
        </trans-unit>
        <trans-unit id="101540b4758da815d4da97e60284cb84f98af97f" translate="yes" xml:space="preserve">
          <source>As for new features and requests to change common behaviors, please ask the author of JSON::XS (Marc Lehmann, &amp;lt;schmorp[at]schmorp.de&amp;gt;) first, by email (important!), to keep compatibility among JSON.pm backends.</source>
          <target state="translated">新しい機能と一般的な動作の変更要求については、JSON.pm間の互換性を維持するために、最初にJSON :: XS（Marc Lehmann、&amp;lt;schmorp [at] schmorp.de&amp;gt;）の作成者に電子メール（重要！）で問い合わせてください。バックエンド。</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">他の操作については、「=」を実装するサブルーチンに3つの引数が渡されますが、最後の2つは常に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;''&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bf65c0259648a27866b59740e85994dce5ffc5e7" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">他の操作に関しては、 '='を実装するサブルーチンには3つの引数が渡されますが、最後の2つは常に &lt;code&gt;undef&lt;/code&gt; と &lt;code&gt;''&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8cf2ef2540039c1386257379903eff22c20c0bad" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt;, with</source>
          <target state="translated">これらすべてのクラスでは不十分であるかのように、PerlはPOSIXスタイルの文字クラスも定義します。これらの形式は &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt; で、</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">これらすべてのクラスでは不十分であるかのように、PerlはPOSIXスタイルの文字クラスも定義します。これらの形式は &lt;code&gt;[:name:]&lt;/code&gt; で、 &lt;code&gt;name&lt;/code&gt; はPOSIXクラスの名前です。 POSIXクラスは &lt;code&gt;alpha&lt;/code&gt; 、 &lt;code&gt;alnum&lt;/code&gt; 、 &lt;code&gt;ascii&lt;/code&gt; 、 &lt;code&gt;cntrl&lt;/code&gt; 、 &lt;code&gt;digit&lt;/code&gt; 、 &lt;code&gt;graph&lt;/code&gt; 、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;punct&lt;/code&gt; 、 &lt;code&gt;space&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、及び &lt;code&gt;xdigit&lt;/code&gt; 、及び2つの延長、 &lt;code&gt;word&lt;/code&gt; （Perl拡張一致するように &lt;code&gt;\w&lt;/code&gt; ）、および &lt;code&gt;blank&lt;/code&gt; （GNU拡張）。 &lt;code&gt;//a&lt;/code&gt; 修飾子は、これらをASCII範囲でのマッチングに制限します。そうでなければ彼らはそれらの対応するPerlのUnicodeのクラスと同じように一致させることができる： &lt;code&gt;[:upper:]&lt;/code&gt; と同じである &lt;code&gt;\p{IsUpper}&lt;/code&gt; 等（これにはいくつかの例外と落とし穴があり、参照&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclassを&lt;/a&gt;完全な議論のために。） &lt;code&gt;[:digit:]&lt;/code&gt; 、 &lt;code&gt;[:word:]&lt;/code&gt; 、および &lt;code&gt;[:space:]&lt;/code&gt; は、おなじみの &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、および &lt;code&gt;\s&lt;/code&gt; 文字クラスに対応しています。 POSIXクラスを無効にするには、名前の前に &lt;code&gt;^&lt;/code&gt; を付けます。たとえば、 &lt;code&gt;[:^digit:]&lt;/code&gt; は &lt;code&gt;\D&lt;/code&gt; 対応し、Unicodeでは &lt;code&gt;\P{IsDigit}&lt;/code&gt; 。UnicodeおよびPOSIX文字クラスは &lt;code&gt;\d&lt;/code&gt; と同じように使用できますが、POSIX文字クラスは文字クラス内でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c16f46255f2c5b016b34cc67482e93dd7025a2f9" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt;. Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">上記のように、&lt;a href=&quot;perlvar#%25ENV&quot;&gt; &lt;code&gt;%ENV&lt;/code&gt; &lt;/a&gt;を介してアクセスされる環境はグローバルであり、慣例により、プログラム固有の環境変数は &lt;code&gt;Program$Name&lt;/code&gt; 形式になります。各ファイルシステムは現在のディレクトリを維持し、現在のファイルシステムの現在のディレクトリは&lt;b&gt;グローバルな&lt;/b&gt;現在のディレクトリです。その結果、社交的なプログラムは現在のディレクトリを変更せず、フルパス名に依存します。プログラム（およびMakefile）は、親（およびその他すべての人）に影響を与えることなく現在のディレクトリを変更できる子プロセスを生成できると想定できません。 。</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">上記のように、 &lt;code&gt;%ENV&lt;/code&gt; を介してアクセスされる環境はグローバルであり、プログラム固有の環境変数の形式は &lt;code&gt;Program$Name&lt;/code&gt; です。各ファイルシステムは現在のディレクトリを維持し、現在のファイルシステムの現在のディレクトリは&lt;b&gt;グローバルな&lt;/b&gt;現在のディレクトリです。その結果、社交的なプログラムは現在のディレクトリを変更せず、完全パス名に依存します。プログラム（およびMakefile）は、親（およびその他すべての人）に影響を与えずに現在のディレクトリを変更できる子プロセスを生成できるとは想定できません。 。</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">いくつかのシェルのように、変数名を中括弧で囲むことで、後続の英数字 (およびアンダースコア)から変数名を区別することができます。また、変数を文字列に補間する際に、ダブルコロンやアポストロフィから変数名を分離するためにも、このようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">現状では version.pm よりも先行していますが、同じ目標を持っています:バージョンの文字列を可視化して比較可能にすることです。</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">その名前が示すように、コードが必須の警告を発した場合、それが必要かどうかにかかわらず警告が表示されます。たとえば、次のコードは常に「2：」に関する &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 警告を生成します。</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">今述べたように、すべての変数はデフォルトでスレッドローカルです。シェア変数を使用するには、&lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt;もロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="7273a25ae51ae519b823516d45a11747d27d1f68" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">今述べたように、すべての変数はデフォルトでスレッドローカルです。共有変数を使用するには、&lt;a href=&quot;threads::shared&quot;&gt;threads :: shared&lt;/a&gt;：もロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">ロックは勧告的なものなので、変数のロックを取得しようとしない別のスレッドによるデータアクセスや変更を防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="3b3a54f56722c72f0cfe48a91b285385f9f3fe3e" translate="yes" xml:space="preserve">
          <source>As long as a context exists for a given hub, all tools that try to get a context will get the existing instance. If you try to store the context you will pollute other tools with incorrect context information.</source>
          <target state="translated">指定されたハブにコンテキストが存在する限り、コンテキストを取得しようとするすべてのツールは既存のインスタンスを取得します。コンテキストを保存しようとすると、間違ったコンテキスト情報で他のツールを汚染することになります。</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">処理されたすべてのドキュメントの結果が出力である限り、その出力にエラッタ（ &lt;code&gt;--errors=pod&lt;/code&gt; で生成された &lt;code&gt;POD ERRORS&lt;/code&gt; ERRORSセクション）が含まれていても、&lt;b&gt;pod2man&lt;/b&gt;はステータス0で終了します。処理中のドキュメントのいずれかが出力ドキュメント&lt;b&gt;。pod2man&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2man&lt;/b&gt;は終了ステータス255でただちに中止されます。</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">処理されたすべてのドキュメントの結果が出力である限り、その出力にエラッタ（ &lt;code&gt;--errors=pod&lt;/code&gt; で生成された &lt;code&gt;POD ERRORS&lt;/code&gt; ERRORSセクション）が含まれていても、&lt;b&gt;pod2text&lt;/b&gt;はステータス0で終了します。処理中のドキュメントのいずれかが出力ドキュメント、&lt;b&gt;pod2text&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2text&lt;/b&gt;は終了ステータス255でただちに中止されます。</target>
        </trans-unit>
        <trans-unit id="0269a38b4ec57ba243ba2782b49b270dd9c32426" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">長いすべての文書は、その出力がエラッタ（含まれていても、いくつかの出力で結果を処理ほど &lt;code&gt;POD ERRORS&lt;/code&gt; を用いて生成部 &lt;code&gt;--errors=pod&lt;/code&gt; ）、&lt;b&gt;pod2manは、&lt;/b&gt;ドキュメントのいずれかが生じない処理されている場合、ステータス0で終了します出力ドキュメントの場合、&lt;b&gt;pod2man&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;die&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2man&lt;/b&gt;は終了ステータス255ですぐに中止します。</target>
        </trans-unit>
        <trans-unit id="03b9b379a8f2df5ad39a7bc04538ebad9bc6c049" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">長いすべての文書は、その出力がエラッタ（含まれていても、いくつかの出力で結果を処理ほど &lt;code&gt;POD ERRORS&lt;/code&gt; を用いて生成部 &lt;code&gt;--errors=pod&lt;/code&gt; ）、&lt;b&gt;pod2textは、&lt;/b&gt;ドキュメントのいずれかが生じない処理されている場合、ステータス0で終了します出力ドキュメントの場合、&lt;b&gt;pod2text&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;die&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2text&lt;/b&gt;は終了ステータス255ですぐに中止されます。</target>
        </trans-unit>
        <trans-unit id="89c56046221181f7e1bfa30bafe704cdc7899788" translate="yes" xml:space="preserve">
          <source>As long as the code inside the SKIP block at least compiles. Please don't ask how. No, it's not a filter.</source>
          <target state="translated">少なくともSKIPブロック内のコードがコンパイルされていれば問題ありません。方法は聞かないでください。フィルターではありません。</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">モジュール内のどの関数からも参照が返されない限り、外部のモジュールはそのサブルーチンを見ることができません。このサブルーチンの名前は</target>
        </trans-unit>
        <trans-unit id="9a46642b51b5bbcfbb8a5a0fab6a1a748c3835a7" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt;, and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt;, then the code</source>
          <target state="translated">前述の&lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;ように&lt;/a&gt;、この操作は、オブジェクトを他の参照と共有する参照にミューテーターが適用されたときに呼び出されます。たとえば、 &lt;code&gt;$b&lt;/code&gt; が数学であり、 &lt;code&gt;'++'&lt;/code&gt; が &lt;code&gt;'incr'&lt;/code&gt; でオーバーロードされ、 &lt;code&gt;'='&lt;/code&gt; が &lt;code&gt;'clone'&lt;/code&gt; でオーバーロードされている場合、コードは</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">上記の&lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;ように&lt;/a&gt;、この操作は、他の参照とオブジェクトを共有する参照にミューテーターが適用されるときに呼び出されます。たとえば、 &lt;code&gt;$b&lt;/code&gt; が数学的なもので、 &lt;code&gt;'++'&lt;/code&gt; が &lt;code&gt;'incr'&lt;/code&gt; でオーバーロードされ、 &lt;code&gt;'='&lt;/code&gt; が &lt;code&gt;'clone'&lt;/code&gt; でオーバーロードされている場合、コード</target>
        </trans-unit>
        <trans-unit id="4a4d04edd6d111dfba357a91be03d0f8c653a2d2" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">上記の&lt;a href=&quot;#ALIASES&quot;&gt;「エイリアス」で説明したように&lt;/a&gt;、Unicode 6.1は、一部のコードポイントに追加の名前（同義語またはエイリアス）を定義します。そのほとんどは、Perl拡張機能としてすでに利用可能です。これらはすべて、 &lt;code&gt;\N{...}&lt;/code&gt; およびこのモジュールの他の関数によって受け入れられますが、 &lt;code&gt;viacode&lt;/code&gt; 特定の入力コードポイントに対して返す名前を1つ選択する必要があるため、「最適な」名前が返されます。これがどのように機能するかを理解するには、Unicode名のプロパティについて詳しく知ることが役立ちます。すべてのコードポイントには、実際には1つの名前しかありません。これは、（Unicode 2.0以降）コードポイントに文字が割り当てられると変更できません。しかし、名前の割り当てに誤りがありました。たとえば、標準の公開中に誤記が発生し、単語のスペルが間違っていたため、それらを修正する方法がありませんでした。 Name_Aliasプロパティは、これらの状況を処理するために最終的に作成されました。名前が間違っていた場合、Name_Aliasを使用して、修正された同義語が公開されます。 &lt;code&gt;viacode&lt;/code&gt; その修正された同義語をコードポイントの「最良の」名前として返します。 （まだ発生していませんが、修正自体を修正する必要がある可能性もあります。そのため、そのコードポイントに対して別のName_Aliasを作成できます &lt;code&gt;viacode&lt;/code&gt; は最新の修正を返します。）</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">上記の&lt;a href=&quot;#ALIASES&quot;&gt;エイリアス&lt;/a&gt;で説明したように、Unicode 6.1は、いくつかのコードポイントに追加の名前（同義語またはエイリアス）を定義します。そのほとんどは、Perl拡張機能としてすでに利用可能でした。これらすべては、 &lt;code&gt;\N{...}&lt;/code&gt; およびこのモジュールの他の関数によって受け入れられますが、 &lt;code&gt;viacode&lt;/code&gt; 特定の入力コードポイントに対して返す名前を1つ選択する必要があるため、「最適な」名前を返します。これがどのように機能するかを理解するには、Unicode名のプロパティについて詳しく知ることが役立ちます。すべてのコードポイントには実際には単一の名前しかありません。コードポイントに文字が割り当てられると、名前は（Unicode 2.0以降）変更できません。しかし、名前の割り当てに誤りがありました。たとえば、規格の公開中に、単語のスペルミスを引き起こす事務的なエラーが発生したことがあり、それらを修正する方法がありませんでした。 Name_Aliasプロパティは、これらの状況を処理するために最終的に作成されました。名前が間違っている場合は、Name_Aliasを使用して、修正された同義語が発行されます。 &lt;code&gt;viacode&lt;/code&gt; その修正されたシノニムをコードポイントの「最適な」名前として返します。 （まだ発生していませんが、修正自体を修正する必要がある可能性もあります。そのため、そのコードポイントに対して別のName_Aliasを作成できます &lt;code&gt;viacode&lt;/code&gt; は最新の修正を返します。）</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">上記のように、UTF-8は可変数のバイトを使用して文字を格納します。値が0 ... 127の文字は、ASCIIのように1バイトで格納されます。文字128は &lt;code&gt;v194.128&lt;/code&gt; として格納されます。これは文字191、つまり &lt;code&gt;v194.191&lt;/code&gt; まで続きます。ビットが &lt;code&gt;10111111&lt;/code&gt; なったので（191はバイナリ10111111です）、次に進みます。文字192は &lt;code&gt;v195.128&lt;/code&gt; です。 2048 &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;文字目&lt;/a&gt;で3バイトに移動します。perlunicodeのUnicodeエンコーディングは、これがどのように機能するかを示しています。</target>
        </trans-unit>
        <trans-unit id="6394bb5241172d16852f3bd3688b62b5907e9510" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt;; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt;. Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt;) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt;. And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot; in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">上記のように、UTF-8は可変バイト数を使用して文字を格納します。値が0 ... 127の文字は、古き良きASCIIと同じように、1バイトに格納されます。文字128は &lt;code&gt;v194.128&lt;/code&gt; として保存されます。これは、 &lt;code&gt;v194.191&lt;/code&gt; である文字191まで続きます。これでビットが不足したため（191はバイナリ &lt;code&gt;10111111&lt;/code&gt; ）、次に進みます。文字192は &lt;code&gt;v195.128&lt;/code&gt; です。そして、それは続き、文字2048で3バイトに移動します&lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;。perlunicodeの「UnicodeEncodings」に&lt;/a&gt;は、これがどのように機能するかが示されています。</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">上で述べたように、Perlで現在実行中のサブルーチンのコンテキストは</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">このドキュメントの一番上で述べたように、これらの拡張子の例で問題がある場合は、これらの拡張子のどれかがあなたの助けになるかどうかを見てみるといいでしょう。</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">前述したように、Perl は 3 つの形式のうちの任意の 1 つに数値を格納することができますが、ほとんどの演算子は通常、これらの形式のうちの 1 つしか理解できません。このような演算子の引数として数値が渡されると、その演算子が理解する形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">前述のように、「コールバック」キーは &lt;code&gt;TAP::Parser&lt;/code&gt; コンストラクターに追加できます。存在する場合、 &lt;code&gt;run&lt;/code&gt; メソッドが使用されている場合、特定の結果タイプに対応する各コールバックは、結果を引数として呼び出されます。コールバックは、パーサーの結果を引数として呼び出されるサブルーチン参照（または無名サブルーチン）であることが期待されています。</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">前述のように、デフォルトエンジンの場合、 &lt;code&gt;pprivate&lt;/code&gt; は、コンパイルされたプログラムと、正規表現エンジンの実装にプライベートな追加データを保持するregexp_internal構造体へのポインターになります。</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;で述べたように、エンコーディングは（少なくとも現在の実装では）オブジェクトとして定義されます。オブジェクトへのエンコーディング名のマッピングは、 &lt;code&gt;%Encode::Encoding&lt;/code&gt; ハッシュを介して行われます。このハッシュを直接操作することもできますが、この基本クラスモジュールを使用して、encode（）およびdecode（）メソッドを追加することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="4b732b611600d48e618ee4980714b28a0f9ad12e" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;で述べたように、エンコーディングは（少なくとも現在の実装では）オブジェクトとして定義されています。エンコーディング名からオブジェクトへのマッピングは、 &lt;code&gt;%Encode::Encoding&lt;/code&gt; ハッシュを介して行われます。このハッシュを直接操作することもできますが、この基本クラスモジュールを使用して、encode（）メソッドとdecode（）メソッドを追加することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">前の項目で述べたように、UnixとMacintosh間でソケットI/Oを使用する場合、これはまだうまくいきません。その場合は、ラインターミネータをハードコーディングする必要があります。</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">前述したように、ダイナミックローディングは現在のところ利用できませんし、MakeMaker も利用できません。どちらも優先度の高い項目です。</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">前述のように、コードポイントの名前が不明の場合、関数は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。Unicodeでは、これらの適切な名前は空の文字列で、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; によって文字列化されます。（エイリアスを割り当てていない、コードのポイントがUnicodeの法定最大U + 10FFFFを超えている場合、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; と警告が表示されます。）</target>
        </trans-unit>
        <trans-unit id="3d4ae46619b16556205991103a3ee51a24d3e1e6" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;undef&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;undef&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;undef&lt;/code&gt; plus a warning.)</source>
          <target state="translated">前述のように、コードポイントの名前が &lt;code&gt;undef&lt;/code&gt; ない場合、関数はundefを返します。Unicodeでは、これらの適切な名前は空の文字列であり、 &lt;code&gt;undef&lt;/code&gt; 文字列化されます。（エイリアスを割り当てていない、Unicodeの有効な最大値であるU + 10FFFFを超えるコードポイントを要求すると、 &lt;code&gt;undef&lt;/code&gt; と警告が表示されます。）</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">エラーストリームに残っている期待される出力のほとんどはによって作成されるように&lt;a href=&quot;../builder&quot;&gt;テスト:: Builderの&lt;/a&gt;の &lt;code&gt;diag&lt;/code&gt; 機能、&lt;a href=&quot;tester&quot;&gt;テスト::ビルダー:: Testerは&lt;/a&gt;便利な機能を提供し &lt;code&gt;test_diag&lt;/code&gt; あなたの代わりに使用できることを &lt;code&gt;test_err&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="77c366c0e7fb4976a90caf137a45b2b3674180a3" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="translated">エラーストリームに残っている期待される出力のほとんどはによって作成されるように&lt;a href=&quot;Test::Builder&quot;&gt;テスト:: Builderの&lt;/a&gt;の &lt;code&gt;diag&lt;/code&gt; 機能、&lt;a href=&quot;Test::Builder::Tester&quot;&gt;テスト::ビルダー:: Testerは&lt;/a&gt;便利な機能を提供し &lt;code&gt;test_diag&lt;/code&gt; あなたの代わりに使用できることを &lt;code&gt;test_err&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="7e01de119b6c27502755389f5ecb232b0f5fe3f3" translate="yes" xml:space="preserve">
          <source>As much as possible, the version.pm module remains compatible with all current code. However, if your module is using a module that has defined &lt;code&gt;$VERSION&lt;/code&gt; using the version class, there are a couple of things to be aware of. For purposes of discussion, we will assume that we have the following module installed:</source>
          <target state="translated">可能な限り、version.pmモジュールは現在のすべてのコードとの互換性を維持します。ただし、モジュールがバージョンクラスを使用して &lt;code&gt;$VERSION&lt;/code&gt; を定義したモジュールを使用している場合は、注意すべき点がいくつかあります。説明のために、次のモジュールがインストールされていると仮定します。</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">上で述べたように、ファイルが既に存在しない場合は、append-mode openがファイルを作成します。しかし、ファイルが既に存在している場合、古いテキストの終わりを過ぎて新しいテキストを追加することになるので、その内容は害を受けることはありません。</target>
        </trans-unit>
        <trans-unit id="a7e52b3ee94a5bcfcbfa100ffa60b7bfdd3a2e7b" translate="yes" xml:space="preserve">
          <source>As noted above, the &lt;code&gt;mark&lt;/code&gt; variable itself will point at the most recently pushed value on the value stack before the list begins, and so the list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;. The values of the list may be iterated by code such as</source>
          <target state="translated">上記のように、 &lt;code&gt;mark&lt;/code&gt; 変数自体は、リストが始まる前に値スタックで最後にプッシュされた値を指すため、リスト自体は &lt;code&gt;mark + 1&lt;/code&gt; から始まります。リストの値は、次のようなコードで繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="9988c3a40e007efc46894bc022da2f7d4a303e25" translate="yes" xml:space="preserve">
          <source>As noted above, xV references on the main value stack do not contribute to the reference count of an xV, and so another mechanism is used to track when temporary values which live on the stack must be released. This is the job of the temporaries stack.</source>
          <target state="translated">上述したように、メイン値スタック上の xV 参照は xV の参照カウントに寄与しないので、スタック上に存在する一時的な値がいつ解放されなければならないかを追跡するために別のメカニズムが使用されます。これがテンポラリスタックの仕事です。</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">このドキュメントで先に述べたように、リストの代入のスカラー感覚は、代入の右側にある要素の数です。ヌルリストには要素が含まれていないので、パスワードファイルが枯渇すると、結果は2ではなく0になります。</target>
        </trans-unit>
        <trans-unit id="3e5e8b8f30fce2b639027bd3be7728c79d978675" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;use locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">で述べたように&lt;a href=&quot;#USING-LOCALES&quot;&gt;「ロケールを使用する」&lt;/a&gt;、 &lt;code&gt;cmp&lt;/code&gt; する際、現在の照合ロケールに従って比較 &lt;code&gt;use locale&lt;/code&gt; が有効であるが、ロケールが等しいと言うことバック文字列の文字ごとの文字の比較に落ちます。このフォールバックが必要ない場合は、 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">で述べたように&lt;a href=&quot;#USING-LOCALES&quot;&gt;ロケールを用い&lt;/a&gt;、 &lt;code&gt;cmp&lt;/code&gt; する際、現在の照合ロケールに従って比較 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 有効であるが、ロケールが等しいと言うことバック文字列の文字ごとの文字の比較に落ちます。このフォールバックが必要ない場合は、 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="39a23dc03cf7dc5e3d6e19189da7b65ab7a30cf2" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;&quot;TESTING&quot; in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhackの「TESTING」に&lt;/a&gt;記載されているように、テストスクリプトを作成するときは、ファイル</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhackのTESTINGで&lt;/a&gt;述べたように、テストスクリプトを書くとき、ファイル</target>
        </trans-unit>
        <trans-unit id="1655e6b218596b71d5606712f426706cfda24e83" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02以降、install（）は、パターンのリストを使用して、インストールすべきでないファイルを除外することをサポートしています。$ skipが省略されているか未定義の場合、installはCWDのINSTALL.SKIPからリストを読み取ろうとします。このファイルは正規表現のリストであり、&lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils :: Manifestで&lt;/a&gt;使用されるMANIFEST.SKIPファイルとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02以降、install（）はパターンリストの使用をサポートし、インストールすべきでないファイルを除外します。$ skipが省略されているか未定義の場合、installはCWDのINSTALL.SKIPからリストを読み取ろうとします。このファイルは正規表現のリストであり、&lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifestで&lt;/a&gt;使用されるMANIFEST.SKIPファイルと同じです。</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">3.10より、全種類のコードの内部データを変更できるようになりました。</target>
        </trans-unit>
        <trans-unit id="4f51af2e950bc010c45298268ec1c3013383b233" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14の時点では、プラットフォームでサポートされていない場合、これらのいずれも例外を発生させません。ただし、警告が有効になっている場合は、サポートされていない変換フラグに対して&lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;警告クラスの警告が発行されます。代わりに例外を希望する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14以降、これらがプラットフォームでサポートされていない場合でも、例外は発生しません。ただし、警告が有効になっている場合、サポートされていない変換フラグに対して &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告クラスの警告が発行されます。代わりに例外を好む場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14以降、これらがプラットフォームでサポートされていない場合でも、例外は発生しません。ただし、警告が有効になっている場合、サポートされていない変換フラグに対して &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告クラスの警告が発行されます。代わりに例外を好む場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">5.14の時点では、このようにも書けます。</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">5.19.9以降、 &lt;code&gt;$/&lt;/code&gt; を他の参照形式に設定すると、致命的な例外がスローされます。これは、設定するための新しい方法サポートするための準備である &lt;code&gt;$/&lt;/code&gt; 将来的には。</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">5.8.1 の時点では、Sun のコンパイラ (libm に含まれていない追加の数学ルーチンのために必要)を使用していれば、長いダブルスが動作します。</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">5.8.1以降、&lt;b&gt;-Cの&lt;/b&gt;後に数字またはオプション文字のリストを続けることができます。文字、数値、効果は以下の通りです。文字をリストすることは、数字を合計することと同じです。</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、他のディレクティブと同様に、ディレクティブ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; を使用し、それに相当するものはレキシカルにスコープされます。ただし、それらにはコンパイル時と実行時の両方の効果があります。</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、他のディレクティブと同様に、ディレクティブ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; を使用し、それに相当するものはレキシカルにスコープされます。ただし、それらにはコンパイル時と実行時の両方の効果があります。</target>
        </trans-unit>
        <trans-unit id="88f554d7cda5067d9baf3d30fcba8c29b1dbb104" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、ディレクティブ &lt;code&gt;use re 'debug'&lt;/code&gt; re'debug 'とそれに相当するものは、他のディレクティブと同様に字句スコープになります。ただし、コンパイル時と実行時の両方の影響があります。</target>
        </trans-unit>
        <trans-unit id="6609b05c1701ded1ef1eec29d7bb5f4a5b93b02d" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、ディレクティブ &lt;code&gt;use re 'debug'&lt;/code&gt; re'debug 'とそれに相当するものは、他のディレクティブと同様に字句スコープになります。ただし、コンパイル時と実行時の両方の影響があります。</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">以下のように &lt;code&gt;Encode&lt;/code&gt; 2.12、 &lt;code&gt;CHECK&lt;/code&gt; はまた、代替文字を表す引数及び戻りオクテットとしてマッピングされていない文字の順序値をとるコード参照することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">以下のように &lt;code&gt;Encode&lt;/code&gt; バージョン2.21、新しいメソッド &lt;code&gt;mime_name()&lt;/code&gt; したがって、添加されます。</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">CPAN 1.9463以降、デフォルトのperlライブラリディレクトリを書き込む権限がない場合、CPANの設定プロセスで&amp;lt;local :: lib&amp;gt;をブートストラップするかどうかを尋ねられます。これにより、個人のperlライブラリディレクトリを簡単に維持できます。</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Encode 1.87では、古い形式の</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">2002年7月（Perlリリース5.8.0）の時点で、次のプラットフォームは、&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http：&lt;/a&gt; //www.cpan.org/src/にある標準のソースコード配布からPerlをビルドできました。</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10以降では、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 変数を使用できます。これらは、 &lt;code&gt;/p&lt;/code&gt; 修飾子が存在する場合にのみ設定されます。その結果、彼らはプログラムの残りの部分にペナルティを課しません。 Perl 5.20では、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; は、 &lt;code&gt;/p&lt;/code&gt; が使用されているかどうかに関係なく（修飾子は無視されます）、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;$&amp;amp;&lt;/code&gt; は使用できません。速度の違いを引き起こします。</target>
        </trans-unit>
        <trans-unit id="e79e99fb499b4f259d0eaa53033cd09b0a52555d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10以降、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 変数を使用できます。これらは、 &lt;code&gt;/p&lt;/code&gt; 修飾子が存在する場合にのみ設定されます。したがって、プログラムの残りの部分にペナルティを課すことはありません。 Perl 5.20では、 &lt;code&gt;/p&lt;/code&gt; が使用されているかどうかに関係なく、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; が使用可能であり（修飾子は無視されます）、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;$&amp;amp;&lt;/code&gt; は使用されません。速度差が発生します。</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10以降、このプラグマはレキシカルにスコープが設定され、コンパイル時に有効になります。以前のバージョンでは、その効果はグローバルで、実行時に有効になりました。動作を変更するために &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; を使用することを提案するドキュメント：</target>
        </trans-unit>
        <trans-unit id="331b4594e4263cc88f44953b4d0b8305968e3f99" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;eval()&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10以降、このプラグマは字句スコープであり、コンパイル時に有効になります。以前のバージョンでは、その効果はグローバルであり、実行時に有効でした。 &lt;code&gt;eval()&lt;/code&gt; を使用して動作を変更することを提案したドキュメント：</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Perl 5.10以降では、再帰パターンを使用して、バランスの取れたテキストを正規表現と照合できます。Perl 5.10より前は、 &lt;code&gt;(??{})&lt;/code&gt; シーケンスでPerlコードを使用するなど、さまざまなトリックに頼らなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Perl 5.10.0では、PerlはいくつかのPython/PCRE固有の正規表現構文の拡張をサポートしています。PerlプログラマはPerl固有の構文を使用することが推奨されていますが、以下のものも受け入れられています。</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0以降では、純粋な構文糖の形式として、 &lt;code&gt;-f -w -x $file&lt;/code&gt; が &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; と同等の方法でファイルテスト演算子をスタックできます。（これは空想的な構文です： &lt;code&gt;-f $file&lt;/code&gt; 戻り値を別のファイルテスト演算子の引数として使用する場合、特別な魔法は起こりません。）</target>
        </trans-unit>
        <trans-unit id="03db908cbb1531eee3e0f01a16bb3f1d5ad12f15" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt;. (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0以降、純粋なシンタックスシュガーの形式として、 &lt;code&gt;-f -w -x $file&lt;/code&gt; が &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; と同等になるように、ファイルテスト演算子をスタックできます。（これは単なる凝った構文です。 &lt;code&gt;-f $file&lt;/code&gt; 戻り値を別のfiletest演算子への引数として使用する場合、特別な魔法は発生しません。）</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.10.0以降では、カスタム正規表現エンジンを作成できます。Cレベルでプラグインする必要があるので、気弱な人には向いていません。詳細については、&lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Perl 5.10.0以降では、 &lt;code&gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;&lt;/code&gt; 修飾子を使用して、ビッグエンディアンまたはリトルエンディアンのバイト順を強制することもできます。これは、たとえば、符号付き整数または64ビット整数を格納する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Perl 5.10.1 では、デフォルト(線形深さ第一探索)以外のメソッド解決順序をプラグインして使用するための新しいインターフェイスがあります。5.10.0 で追加された C3 メソッド解決命令は、Perl 空間のインターフェイスを変更することなく、プラグインとして再実装されています。</target>
        </trans-unit>
        <trans-unit id="ec3d8a5f4531571b478743636520cd49e4ac13cb" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either a &lt;code&gt;readdir&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readdir&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">Perl 5.12以降、 &lt;code&gt;while&lt;/code&gt; ループで裸の&lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt;を使用できます。これにより、反復ごとに&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;が設定されます。いずれかの場合 &lt;code&gt;readdir&lt;/code&gt; 発現または明示的な割り当て &lt;code&gt;readdir&lt;/code&gt; スカラーへの表現として使用されて &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; の条件、条件は実際にはない、その定期的な真理値のために、式の値の定義済みかをテストします。</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12以降では、 &lt;code&gt;while&lt;/code&gt; ループで裸の &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; を使用でき、反復ごとに &lt;code&gt;$_&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12以降では、 &lt;code&gt;while&lt;/code&gt; ループで裸の &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; を使用でき、反復ごとに &lt;code&gt;$_&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Perl 5.12では、非推奨となった機能やモジュールは、使用されるたびにユーザに警告を発します。モジュールが非推奨になると、CPANでも利用できるようになります。CPAN からインストールすることで、そのモジュールに対する非推奨の警告は表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Perl 5.18 では、すべてのハッシュは独自のハッシュ探索順序を持っており、この順序はハッシュに新しい要素が挿入されるたびに変更されます。この機能は、key()、values()、または each()を用いてハッシュバケットを探索する際に、実際のバケット ID と xor された符号なし整数マスク (U32)を保持することで提供されます。</target>
        </trans-unit>
        <trans-unit id="52e65492e2356da13376652cd3b63537c008c53e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either an &lt;code&gt;each&lt;/code&gt; expression or an explicit assignment of an &lt;code&gt;each&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">Perlの5.18のとして、あなたは裸使用することができ&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;中 &lt;code&gt;while&lt;/code&gt; 設定されますループ、&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;反復ごとに。いずれかの場合には &lt;code&gt;each&lt;/code&gt; 表現または明示的に割り当て &lt;code&gt;each&lt;/code&gt; スカラーへの表現として使用されて &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; の条件、条件は実際にはない、その定期的な真理値のために、式の値の定義済みかをテストします。</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perlの5.18のとして、あなたは裸使用することができ &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;while&lt;/code&gt; 設定されますループ、 &lt;code&gt;$_&lt;/code&gt; 反復ごとに。</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perlの5.18のとして、あなたは裸使用することができ &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;while&lt;/code&gt; 設定されますループ、 &lt;code&gt;$_&lt;/code&gt; 反復ごとに。</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20以降では &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; を使用する代わりにFATAL =&amp;gt; 'all'; あなたは使うことができます：</target>
        </trans-unit>
        <trans-unit id="9ee11b59ca6b84291fdd57fa90c4a5348d5dae02" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20以降、 &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; を使用する代わりにFATAL =&amp;gt; 'all'; 使用できます：</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22の時点で、VARのバックスラッシュが前に付いた変数を受け入れるこのループの実験的な変形があります。この場合、リスト内の項目は参照である必要があります。バックスラッシュ付きの変数は、リスト内の参照される各項目のエイリアスになります。これは、正しいタイプである必要があります。この場合、変数はスカラーである必要はなく、バックスラッシュの後に &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; を付けることができます。このフォームを使用するには、 &lt;code&gt;refaliasing&lt;/code&gt; featureを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; てリエイリアス機能を有効にする必要があります。 （&lt;a href=&quot;feature&quot;&gt;機能&lt;/a&gt;&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;を参照してください。perlrefの参照への割り当て&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="4cc3a1608477d241ae1d9f45daf77429c175f625" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;my&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;use feature&lt;/code&gt;. (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22の時点で、VARのバックスラッシュが前に付いた変数を受け入れるこのループの実験的な変形があります。この場合、LIST内の項目は参照である必要があります。バックスラッシュされた変数は、LIST内の参照される各項目のエイリアスになります。これは、正しいタイプである必要があります。この場合、変数はスカラーである必要はなく、バックスラッシュの後に &lt;code&gt;my&lt;/code&gt; が続く場合があります。このフォームを使用するには、 &lt;code&gt;refaliasing&lt;/code&gt; 機能を介して再エイリアス機能を有効にする必要があり &lt;code&gt;use feature&lt;/code&gt; 。 （&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照してください&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;。perlrefの「参照への割り当て」&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Perl 5.22では、このバギーな動作は下位互換性のために保存されていますが、検出されて非推奨の警告を発します。もしサブルーチンを警告なしでインライン化したい場合は、変数が宣言されている場所以外で変更される可能性のあるコンテキストで使用されていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22以降では、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 、&lt;a href=&quot;functions/undef&quot;&gt;undefの&lt;/a&gt;代わりに &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; を使用することもできます。（ &lt;code&gt;($x) x 2&lt;/code&gt; 実行することもできます。これは、同じ変数に2回割り当てられ、最初に割り当てられた値を破棄するため、あまり役に立ちません。）</target>
        </trans-unit>
        <trans-unit id="adc72631156437f156fe787062790a9076462201" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(undef)x2&lt;/code&gt; instead of &lt;code&gt;undef, undef&lt;/code&gt;. (You can also do &lt;code&gt;($x) x 2&lt;/code&gt;, which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22以降、 &lt;code&gt;undef, undef&lt;/code&gt; 代わりに &lt;code&gt;(undef)x2&lt;/code&gt; を使用することもできます。（ &lt;code&gt;($x) x 2&lt;/code&gt; 実行することもできます。これは、同じ変数に2回割り当てられ、割り当てられた最初の値を壊してしまうため、あまり役に立ちません。）</target>
        </trans-unit>
        <trans-unit id="485dbe5ed6cb5d47f12b9abb8eb25ef72fc078a7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.24, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::postderef&lt;/code&gt; warning category still exists (for compatibility with code that disables it).</source>
          <target state="translated">Perl 5.24以降、 &lt;code&gt;experimental::postderef&lt;/code&gt; 警告カテゴリはまだ存在しますが（それを無効にするコードとの互換性のため）、この機能を使用しても警告はトリガーされなくなりました。</target>
        </trans-unit>
        <trans-unit id="795c67df489058534540e8b295b838da24c8850d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.25 the return was changed to be the count of keys in the hash. If you need access to the old behavior you can use &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; instead.</source>
          <target state="translated">Perl 5.25以降、戻り値はハッシュ内のキーの数になるように変更されました。古い動作にアクセスする必要がある場合は、代わりに &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="9a4dc26e9cc8e6190d88b95c93b52fd5320659be" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, the list-context range operator on strings works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: its behavior depends on the internal encoding of the range endpoint.</source>
          <target state="translated">Perl 5.26以降、文字列のリストコンテキスト範囲演算子は、&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt;スコープで期待どおりに機能します。以前のバージョンでは、その機能の範囲外で、&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeで「「Unicodeバグ」」が発生し&lt;/a&gt;ます。その動作は範囲エンドポイントの内部エンコーディングによって異なります。</target>
        </trans-unit>
        <trans-unit id="f8155f16a3b816f25d3b7bda9eaf9e783e3bae93" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::lexical_subs&lt;/code&gt; warning category still exists (for compatibility with code that disables it). In addition, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="translated">Perl 5.26以降、 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 警告カテゴリはまだ存在しますが（これを無効にするコードとの互換性のため）、この機能を使用しても警告はトリガーされなくなりました。さらに、この構文は実験的なものではなくなっただけでなく、スコープ内の機能宣言に関係なく、すべてのPerlコードで有効になっています。</target>
        </trans-unit>
        <trans-unit id="644c2bcdf8b193d872fddb3b64677c202b8cacc1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26.0, this module has no effect. The internal Perl feature that was used to implement this module has been removed. In recent years, much work has been done on the Perl core to eliminate discrepancies in the treatment of upgraded versus downgraded strings. In addition, the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which caused many of the problems, is no longer supported. Thus, the warnings this module produced are no longer necessary.</source>
          <target state="translated">Perl 5.26.0以降、このモジュールは効果がありません。このモジュールの実装に使用されていた内部Perl機能は削除されました。近年、アップグレードされた文字列とダウングレードされた文字列の処理の不一致を解消するために、Perlコアで多くの作業が行われています。さらに、多くの問題を引き起こしていた&lt;a href=&quot;encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマはサポートされなくなりました。したがって、このモジュールが生成した警告は不要になりました。</target>
        </trans-unit>
        <trans-unit id="c1154c7dc017ae8cf6bc262f38694d16778c8f10" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, setting &lt;code&gt;$/&lt;/code&gt; to a reference of a non-positive integer throws a fatal error.</source>
          <target state="translated">Perl 5.28以降、 &lt;code&gt;$/&lt;/code&gt; を正でない整数の参照に設定すると、致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="097112fced1ea44933320d3c2e627da3a57d8e96" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, these attributes are syntax errors. Since the attributes do not do anything, removing them from your code fixes the syntax error; and removing them will not influence the behaviour of your code.</source>
          <target state="translated">Perl 5.28 では、これらの属性は構文エラーです。属性は何もしないので、コードから削除しても構文エラーは修正されます。</target>
        </trans-unit>
        <trans-unit id="4698cfe65801c463a3e671c9cf65833d68ff49ae" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, this special-cased whitespace splitting works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: characters that are whitespace according to Unicode rules but not according to ASCII rules can be treated as part of fields rather than as field separators, depending on the string's internal encoding.</source>
          <target state="translated">Perl 5.28以降、この特殊なケースの空白の分割は、&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt;スコープで期待どおりに機能します。以前のバージョンでは、その機能の範囲外で、&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeに「「Unicodeバグ」」が表示&lt;/a&gt;されます。Unicodeルールには準拠しているがASCIIルールには準拠していない空白の文字は、フィールドセパレータとしてではなくフィールドの一部として扱うことができます。 、文字列の内部エンコーディングによって異なります。</target>
        </trans-unit>
        <trans-unit id="df44a28f7cb4ce868d57f8dd07bcda2680ebf3e0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.30, use of delimiters which are non-standalone graphemes is fatal, in order to move the language to be able to accept multi-character graphemes as delimiters.</source>
          <target state="translated">Perl 5.30 では、区切り文字として複数の文字の書記素を受け入れられるようにするために、独立していない書記素のデリミタを使用することは致命的です。</target>
        </trans-unit>
        <trans-unit id="3dcb750cd92914748543d04c418a1857ae25be47" translate="yes" xml:space="preserve">
          <source>As of Perl 5.32, this message is no longer generated. Instead, see &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;&quot;&lt;/a&gt;. (W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">Perl 5.32以降、このメッセージは生成されなくなりました。代わりに、&lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;「8進数以外の文字 '％c'は\ o早期に終了します。「％s」として解決され&lt;/a&gt;ます」を参照してください。（W misc、regexp） &lt;code&gt;\08&lt;/code&gt; や &lt;code&gt;\179&lt;/code&gt; ようなものを二重引用符で囲んで書いた。最後の桁を除くすべてが、8進数で指定された単一の文字として扱われます。最後の桁は、文字列の次の文字です。これが本当に必要なものであることをPerlに伝えるには、 &lt;code&gt;\o{ }&lt;/code&gt; 構文を使用するか、正確に3桁を使用して文字の8進数を指定します。</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Perl 5.6 では、ファイルハンドルをスカラ変数で表現することができます。</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">Perl 5.8.0以降、このモジュールを使用した後は、暗黙の &lt;code&gt;$_&lt;/code&gt; または特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; をstat（）またはlstat（）で使用できなくなります。そうしようとすると、奇妙なエラーが発生します。回避策は &lt;code&gt;$_&lt;/code&gt; を明示的にすることです</target>
        </trans-unit>
        <trans-unit id="115a406a7271cc4332af7b8bb93f168d625583f1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, at least the following encodings are recognized. Note that unless otherwise specified, they are all case insensitive (via alias) and all occurrence of spaces are replaced with '-'. In other words, &quot;ISO 8859 1&quot; and &quot;iso-8859-1&quot; are identical.</source>
          <target state="translated">Perl 5.8.0 では、少なくとも以下のエンコーディングが認識されます。特に指定がない限り、これらはすべて大文字小文字を区別せず (エイリアスを介して)、スペースの出現はすべて '-' に置き換えられていることに注意してください。言い換えれば、「ISO 8859 1」と「iso-8859-1」は同じです。</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Perl 5.8.0では、&quot;フル &quot;の大文字小文字の折り返しは</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0以降では、複数の引数を指定して &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; を使用できます。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; のリスト形式と同様に、シェルエスケープは発生しません。</target>
        </trans-unit>
        <trans-unit id="df8794a0813798e6a0cf5a13a0dc7223a79a0992" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;open()&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0以降、 &lt;code&gt;open()&lt;/code&gt; を複数の引数で使用できます。 &lt;code&gt;system()&lt;/code&gt; および &lt;code&gt;exec()&lt;/code&gt; のリスト形式と同様に、シェルエスケープは発生しません。</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Perl 5.8.1以降、SunOS 4.xではライブラリ(DynaLoader,XSLoader)の動的ロード機能も壊れているようです。</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Perl 5.8.1以降、&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;には &lt;code&gt;utf8::is_utf8&lt;/code&gt; 関数もあります。</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Perl 5.9.5 では、デフォルトのもの以外の正規表現エンジンをプラグインしたり使用したりするための新しいインターフェイスが用意されています。</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Perl Symbian 移植版バージョン 0.4.1 の時点では、Perl の標準的な回帰テストスイートのどの部分も、移植された Perl を使用して実際の Symbian デバイス上で実行されていないため、無数のバグが待ち受けているかもしれません。そのため、無数のバグが待ち受けているかもしれません。</target>
        </trans-unit>
        <trans-unit id="470b823d90414a4ffaec0c54908966f5bb0b6779" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module.</source>
          <target state="translated">Perl v5.16.0以降、これは&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;モジュールによって実装されています。</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Perl v5.16.0以降では、&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;モジュールによって実装されます。参照してください&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;その動作の詳細については。</target>
        </trans-unit>
        <trans-unit id="0cf84017310ef88efe853e952dd2c6c52ce61386" translate="yes" xml:space="preserve">
          <source>As of Perl v5.30.0, or under &lt;code&gt;use v5.16&lt;/code&gt;, or &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt;, &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">Perl v5.30.0以降、またはv5.16の &lt;code&gt;use v5.16&lt;/code&gt; 、または &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt; ない場合、 &lt;code&gt;$[&lt;/code&gt; は効果がなくなり、常に0が含まれます。0を割り当てることは許可されていますが、他の値を指定するとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">USS for OS / 390のR2.5およびVM / ESAのバージョン2.3以降、これらのUnixサブシステムは &lt;code&gt;#!&lt;/code&gt; をサポートしていません。スクリプト呼び出しのためのシバントリック。したがって、OS / 390およびVM / ESAのPerlスクリプトは、次の単純なスクリプトと同様のヘッダーを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">Unicode 6.0 では、これは常に空です。</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">VERSION 1.18 では、すべての IO::Socket オブジェクトはデフォルトで自動フラッシュがオンになっています。これは以前のリリースではそうではありませんでした。</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">db-4.2.xでは、この作業を手作業で行う必要がなくなりました。Sleepycatは、HP-UX上で自動的に+zを追加するように設定プロセスを変更しました。</target>
        </trans-unit>
        <trans-unit id="d75d887c21a8a54a73e586867619f60f35cac751" translate="yes" xml:space="preserve">
          <source>As of libcrypt 1.3 (March 2016), you will need to install the libcrypt-devel package for Configure to detect crypt().</source>
          <target state="translated">libcrypt 1.3 (2016年3月)の時点では、Configure for crypt()を検出するための libcrypt-devel パッケージをインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">Perl 5.14以降では、 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; を使用してコンパイル時の字句スコープメカニズムにフックすることが可能です。これは次のように使用されます：</target>
        </trans-unit>
        <trans-unit id="ad95286c36cd410295b8a2ce1cb7201a227c4aba" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt;. This is used like this:</source>
          <target state="translated">perl 5.14以降、 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; を使用してコンパイル時の字句スコープメカニズムにフックすることが可能です。これは次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="11e27b1acb1512cd132ffd47cefd52584149d78c" translate="yes" xml:space="preserve">
          <source>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</source>
          <target state="translated">perl 5.25では、この関数はデバッグ目的でのみ使用され、使用されたハッシュバケットの数はキャッシュされていないため、この関数の実行にはコストがかかります。</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">perl 5.9.5 以降、're' debug には、オプションで呼び出し元の名前空間にエクスポートできるユーティリティ関数が多数含まれています。それらを以下に示します。</target>
        </trans-unit>
        <trans-unit id="e452fc188847c39d477f7724ca763c55646692fe" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5/Win32 0.27, these functions have been moved into the Win32 module. Win32CORE provides stubs for each of the former CORE Win32:: functions that internally just load the Win32 module and call it's version, and Win32CORE is statically linked to perl for both cygwin and regular win32 builds. This will permit these functions to be updated in the CPAN Win32 module independently of updating perl.</source>
          <target state="translated">perl 5.9.5/Win32 0.27 以降、これらの関数は Win32 モジュールに移されました。Win32CORE は、以前の CORE Win32::関数のそれぞれのスタブを提供しており、内部的には Win32 モジュールをロードしてそのバージョンを呼び出すだけです。これにより、これらの関数は、perlの更新とは無関係に、CPAN Win32モジュールで更新されるようになります。</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">perl5.6では、初期化されていないスカラ変数を渡すと、 open()はファイルやディレクトリのハンドルを自動的に参照として認識します。そして、これらの参照を他のスカラと同じように渡して、名前付きハンドルの代わりに使うことができます。</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">perl5.7.2 の時点では、すべてのテストは以下の条件で合格しています。</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">perl5.8.1の時点では、少なくとも1つのテストがまだ失敗しています。</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Perlのリリース5以降、 &lt;code&gt;$[&lt;/code&gt; への割り当てはコンパイラディレクティブとして扱われ、他のファイルの動作に影響を与えることはできません。（そのため、コンパイル時の定数のみを割り当てることができます。）その使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">リリース5.003_01では、Perlはマルチスレッド化されたC RTL DLLにリンクされています。perl自体がマルチスレッド対応でコンパイルされていない場合は、perlのmalloc()は動作しません。ただし、拡張機能は自己責任でマルチスレッドを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">現在のところ、これはパスがボリュームのある絶対パスであれば 2 を返し、ボリュームのない絶対パスであれば 1 を返し、そうでなければ 0 を返します。</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">本ドキュメントの最終更新日現在、以下のシステムにはPA-RISC 2.0チップが搭載されています。</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">この文書の日付の時点で、Perl は HP-UX 11.00 以降では cc と gcc の両方のビルドで 64 ビットに完全に準拠しています。GNU gcc で 64 ビットの Perl をビルドしようとしている場合は、gcc のセクションを注意深く読んでください。</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">このドキュメントが最終改訂された時点で、PerlのVMSポートには以下のPerl関数が実装されています(※印の関数については、以下で詳しく説明します)。</target>
        </trans-unit>
        <trans-unit id="4d788164927e274de517225973608d97db84fe9f" translate="yes" xml:space="preserve">
          <source>As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works. The Encode module has a &lt;code&gt;perlio_ok&lt;/code&gt; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:</source>
          <target state="translated">この記事の執筆時点では、クラスがEncode :: XSおよびEncode :: Unicodeに属するすべてのエンコーディングが機能します。Encodeモジュールには、PerlIOエンコーディングをファイルハンドルに適用する前に使用できる &lt;code&gt;perlio_ok&lt;/code&gt; メソッドがあります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">v5.14では、PerlはUTF-8の警告を3つのサブクラスに区別しています。</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">v5.18.0以降では、 &lt;code&gt;%ENV&lt;/code&gt; に格納されるキーと値の両方が文字列化されます。</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">AutoSplitモジュールのバージョン1.01では、1つのファイル内に複数のパッケージを持つことができます。以下のケースの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">バージョン1.02（perl 5.12に付属）では、オブジェクトは &lt;code&gt;&quot;-X&quot;&lt;/code&gt; オーバーロードを提供しているため、ファイルテスト演算子（ &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; など）を呼び出すことができます。 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="3f4a112eabf93bbafc4bcc9a1025d0ef06b216ad" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">バージョン1.02（perl 5.12で提供）以降、オブジェクトは &lt;code&gt;&quot;-X&quot;&lt;/code&gt; オーバーロードを提供するため、ファイルテスト演算子（ &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; など）を呼び出すことができます。また、次のように呼ばれる &lt;code&gt;-&amp;gt;cando&lt;/code&gt; メソッドを提供します</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">バージョン 1.04 (Perl 5.10)のように、strict は &quot;strict&quot; として使用されていることを検証し、大文字小文字を区別しないファイルシステム上の恐ろしい Strict トラップを回避します。</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">このモジュールのバージョン1.32では、定数の名前にパッケージ名を含めることで、呼び出し元以外のパッケージで定数を定義することができます。</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">バージョン 1.47 では、インストール・インターフェースに以下の追加が行われました。新しい引数スタイルと %result ハッシュの使用が推奨されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">バージョン2.12以降、 &lt;code&gt;Encode&lt;/code&gt; は &lt;code&gt;CHECK&lt;/code&gt; の coderef値をサポートしています。下記参照。</target>
        </trans-unit>
        <trans-unit id="ffc6a36f7c22fafbcd2974930b9d682b59ed0fd0" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt;; see below.</source>
          <target state="translated">バージョン2.12以降、 &lt;code&gt;Encode&lt;/code&gt; は &lt;code&gt;CHECK&lt;/code&gt; のcoderef値をサポートします。下記参照。</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">バージョン 2.32 Getopt::Long では、自動ヘルプが提供されています。</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">バージョン5.00305では、OS/2 perlのバイナリ配布は11のコンポーネントに分割されています。残念ながら、設定可能なバイナリのインストールを可能にするために、zipファイルのファイルパスは絶対パスではなく、どこかのディレクトリへの相対パスになっています。</target>
        </trans-unit>
        <trans-unit id="0a03b6b4ddea7ad90c28bf2de5b6b3532c441bd5" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the time implementation of the operating system it's running on. Instead, it has its own implementation of those routines with a safe range of at least +/- 2**52 (about 142 million years)</source>
          <target state="translated">バージョン5.12.0では、perlは実行しているオペレーティングシステムの時間の実装を使わなくなりました。その代わりに、少なくとも +/-2**52 (約1億4,200万年)の安全な範囲で、これらのルーチンを独自に実装しています。</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">バージョン5.12.0では、perlは実行しているオペレーティングシステムの基礎となる時間ライブラリの使用をやめ、少なくとも+/-2**52(約1億4,200万年)の安全な範囲で、それらのルーチンの独自の実装を持っています。</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">執筆時点(2010-09)では</target>
        </trans-unit>
        <trans-unit id="9bba94e9dfeb863cebb5f1b8b07f6bae30ef1d7d" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi(3)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol(3)&lt;/a&gt;, &lt;code&gt;grok_atoUV&lt;/code&gt; does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</source>
          <target state="translated">対照的に&lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;税引後営業利益（3）&lt;/a&gt;または&lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtolは（3） &lt;/a&gt;、 &lt;code&gt;grok_atoUV&lt;/code&gt; は、オプションの先頭の空白、また負の入力を許可していません。そのような機能が必要な場合、呼び出し元のコードはそれらを明示的に実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">あたりとして&lt;a href=&quot;functions/readline&quot;&gt;のreadline&lt;/a&gt;、スカラコンテキストでは、次の行を返す、または必要があります &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をなし、より多くのデータのために。リストのコンテキストでは、残りのすべての行を返すか、データがない場合は空のリストを返します。返される文字列には、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （ &quot;slurp&quot;モードを意味する）でない限り、入力レコードセパレータ &lt;code&gt;$/&lt;/code&gt; （&lt;a href=&quot;perlvar&quot;&gt;perlvarを&lt;/a&gt;参照）を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="008a0000ee5b61a83c14df2cf7cee7f4e080298a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;perlfunc#readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;undef&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;undef&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">あたりとして&lt;a href=&quot;perlfunc#readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;、スカラコンテキストでは、次の行を返す、または必要があります &lt;code&gt;undef&lt;/code&gt; をなし、より多くのデータのために。リストコンテキストでは、残りのすべての行を返すか、データがない場合は空のリストを返す必要があります。返される文字列には、 &lt;code&gt;undef&lt;/code&gt; （「スラップ」モードを意味する）でない限り、入力レコード区切り文字 &lt;code&gt;$/&lt;/code&gt; （&lt;a href=&quot;perlvar&quot;&gt;perlvarを&lt;/a&gt;参照）を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">get()と同様ですが、紐付けられたファイルハンドルを返します。このファイルハンドルから読み込むと、要求されたメッセージが返されます。このファイルハンドルはメッセージの最後にEOFを返しますので、再利用してはいけません。</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">perlは使っていないので、あまりテストされていません。</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">プラグマは他のモジュールと同様にモジュールとして実装される &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; なる</target>
        </trans-unit>
        <trans-unit id="95ffc5a9c7d9d21832644aa0005e8ab6e5d3fda8" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;use myint;&lt;/code&gt; becomes</source>
          <target state="translated">pragmataは他のモジュールと同様にモジュールとして実装される &lt;code&gt;use myint;&lt;/code&gt; になります</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">前述のように、「スイッチ」機能は非常に実験的なものと見なされています。予告なく変更される場合があります。特に、将来的にトリッキーにならないように変化すると予想されるトリッキーな動作がある &lt;code&gt;when&lt;/code&gt; 。現在の（誤）実装に依存しないでください。 Perlの5.18の前に、 &lt;code&gt;given&lt;/code&gt; 、あなたのコードはPerlの古いバージョンの上で実行する必要がある場合、あなたはまだに注意すべきであるというトリッキーな行動を持っていました。</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">前述のように、(ハッシュ全体ではなく)個々のエントリは設定可能です。Perlはここではブール値のtrueのみを気にしています。</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">設定としては、タイの例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">出荷時に提供されるコマンドライン履歴は、先頭の感嘆符がないかどうかをチェックする単純なものだけです。しかし、CPANからTerm::ReadKeyとTerm::ReadLineモジュール(Term::ReadLine::Gnu、Term::ReadLine::Perlなど)をインストールすると、これらのGNU</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">上記のように、Perl は出力が実際に変更されたかどうかに関わらず、バックアップファイルを作成します。つまり、これはファイルをコピーするための単なるファンシーな方法です。</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; は「関数のように見える」ルールから除外されています。それに続く一対の括弧は、その引数を（必然的に）区切るものではありません。 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; と同等です。また、ほとんどの名前付き演算子とは異なり、これは代入と同じ優先順位を持っています。</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; は「関数のように見える」ルールから除外されています。それに続く一対の括弧は、その引数を（必然的に）区切るものではありません。 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; と同等です。また、ほとんどの名前付き演算子とは異なり、これは代入と同じ優先順位を持っています。</target>
        </trans-unit>
        <trans-unit id="69217332278a487735b9f765568e5e6b60cb13f1" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;goto EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; is equivalent to &lt;code&gt;goto NEXT&lt;/code&gt;. Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">この例に示されているように、 &lt;code&gt;goto EXPR&lt;/code&gt; は「関数のように見える」ルールから除外されています。それに続く括弧のペアは、（必然的に）その引数を区切りません。 &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; は、 &lt;code&gt;goto NEXT&lt;/code&gt; と同等です。また、ほとんどの名前付き演算子とは異なり、これは割り当てと同じ優先順位を持ちます。</target>
        </trans-unit>
        <trans-unit id="9bc78a790919531fd0718a68912f96b73236dccd" translate="yes" xml:space="preserve">
          <source>As some variables are reported by a different name in the output of &lt;code&gt;perl -V&lt;/code&gt; than their actual name in &lt;code&gt;%Config&lt;/code&gt;, I decided to leave the &lt;code&gt;config&lt;/code&gt; entry as close to reality as possible, and put in the entries that might have been guessed by the printed output in a separate block.</source>
          <target state="translated">一部の変数は、 &lt;code&gt;perl -V&lt;/code&gt; の出力で &lt;code&gt;%Config&lt;/code&gt; の実際の名前とは異なる名前で報告されるため、 &lt;code&gt;config&lt;/code&gt; エントリをできるだけ現実に近づけて、推測された可能性のあるエントリを入力することにしました。別のブロックに出力を印刷します。</target>
        </trans-unit>
        <trans-unit id="48a035147de7a604eb6e8f9633c18d50b5e19c9b" translate="yes" xml:space="preserve">
          <source>As soon as one of my failing tests passes it will be removed from the list of failed tests. Eventually I fix them all and prove can find no failing tests to run:</source>
          <target state="translated">私の失敗したテストの一つが通過するとすぐに、失敗したテストのリストから削除されます。最終的にはすべてのテストを修正し、失敗したテストがないことを証明します。</target>
        </trans-unit>
        <trans-unit id="81930da4a8c9e7cfd6af4afe44478552245004db" translate="yes" xml:space="preserve">
          <source>As such, consumers may use this data for informational analysis, but presenting it to the user as canonical or relying on it as such is invariably the height of folly.</source>
          <target state="translated">このように、消費者は情報分析のためにこのデータを使用することができますが、それを正規のものとしてユーザーに提示したり、そのように依存したりすることは、必ずや愚行の極みとなります。</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">そのため、通常は &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; コマンドでの使用に適さないシグナル（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ）は、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; メソッドで使用しても問題ありません（ここでも、上記のように）。 。</target>
        </trans-unit>
        <trans-unit id="2afd2bab6cbdd50c9685439c6b9fc8e46337a3ed" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;kill()&lt;/code&gt; command (e.g., &lt;code&gt;kill('KILL', $$)&lt;/code&gt;) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">そのため、通常は &lt;code&gt;kill()&lt;/code&gt; コマンドで使用するのに適切ではないシグナル（たとえば、 &lt;code&gt;kill('KILL', $$)&lt;/code&gt; ）は、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; メソッドで使用しても問題ありません（これも上記のとおりです）。 。</target>
        </trans-unit>
        <trans-unit id="24bd5acc92d8894261d7ef9b04b6f856fb374ce1" translate="yes" xml:space="preserve">
          <source>As such, you open a pipe using the same &lt;code&gt;open&lt;/code&gt; call that you use for opening files, setting the second (&lt;code&gt;MODE&lt;/code&gt;) argument to special characters that indicate either an input or an output pipe. Use &lt;code&gt;&quot;-|&quot;&lt;/code&gt; for a filehandle that will let your Perl program read data from an external program, and &lt;code&gt;&quot;|-&quot;&lt;/code&gt; for a filehandle that will send data to that program instead.</source>
          <target state="translated">そのため、ファイルを開くために使用するのと同じ &lt;code&gt;open&lt;/code&gt; 呼び出しを使用してパイプを開き、2番目の（ &lt;code&gt;MODE&lt;/code&gt; ）引数を入力パイプまたは出力パイプのいずれかを示す特殊文字に設定します。 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 使用する Perlプログラムが外部プログラムからデータを読み取れるようにするファイルハンドルの場合は &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 、代わりにそのプログラムにデータを送信するファイルハンドルの場合は「|-」。</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">システムライブラリ(特にglibc)もエラーを発生させるので,valgrindはサプレッションファイルを使ってそのようなエラーを抑制することができます.valgrindに付属しているデフォルトの抑制ファイルは,すでに多くのエラーを捕捉しています.いくつかのサプレッションは</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">これは複数のC文であるため、よくあることなので、代わりにこの慣用句を参照してください。</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">&lt;code&gt;'IGNORE'&lt;/code&gt; フックがでサポートされていない &lt;code&gt;__WARN__&lt;/code&gt; 、あなたは空のサブルーチンを使用して警告を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="d759f2151ab12005046fd0fb7fc374d93cc7fcaa" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt;, its effect is the same as using &lt;code&gt;'DEFAULT'&lt;/code&gt;. You can disable warnings using the empty subroutine:</source>
          <target state="translated">&lt;code&gt;'IGNORE'&lt;/code&gt; フックがでサポートされていない &lt;code&gt;__WARN__&lt;/code&gt; 、その効果は使用するのと同じである &lt;code&gt;'DEFAULT'&lt;/code&gt; 。空のサブルーチンを使用して警告を無効にできます。</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Perl インタプリタは、新しいオペコードを実行しようとしているときだけシグナルフラグを見るので、長い間実行されているオペコード(例えば、非常に大きな文字列に対する正規表現操作)の間に到着したシグナルは、現在のオペコードが完了するまで見ることができません。</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">PerlIO レイヤーは内部的に raw IO (バイト)を使用しているので、ファイルシステムのタイプ (ASCII や EBCDIC)などは完全に無視されます。</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">PerlIO レイヤーは内部的に raw IO を使用しているので、ファイルシステムのタイプ(ASCII または EBCDIC)と IO_CONVERSION 環境変数を完全に無視しています。BS2000 の IO 関数がファイルシステムに応じて変換を決定するという古い動作を得たい場合、PerlIO はまだあなたの友人です。いつものように IO_CONVERSION を使用して、Perl にネイティブ IO レイヤーを使用するように指示します。</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">コメントが言うように、これはアクセサを実装する良い方法ではありません。それは遅くて断然賢すぎる。ただし、これを古いPerlコードでアクセサーを提供する方法と見なす場合があります。PerlでのOOコーディングに関する推奨事項については、&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1139ca2064130f83bd2fbbeaae8eb84583cc89ac" translate="yes" xml:space="preserve">
          <source>As the example in &lt;a href=&quot;#new%28%29&quot;&gt;&quot;new()&quot;&lt;/a&gt; shows, you can always create a copy of an existing version object with the same value by the very compact:</source>
          <target state="translated">&lt;a href=&quot;#new%28%29&quot;&gt;「new（）」&lt;/a&gt;の例が示すように、非常にコンパクトで、同じ値を持つ既存のバージョンオブジェクトのコピーをいつでも作成できます。</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">例に示すように、第二引数が空文字列の場合、カテゴリのロケールは対応する環境変数で指定されたデフォルトに戻されます。一般的に、これはPerlが起動したときのデフォルトに戻る結果となります。</target>
        </trans-unit>
        <trans-unit id="1edaf8c27fdae81166329d8ebc45bdc56d4e0e72" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portability to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt;, &lt;code&gt;\N{U+28}&lt;/code&gt;, &lt;code&gt;\N{U+29}&lt;/code&gt;, ..., &lt;code&gt;\N{U+3D}&lt;/code&gt;, &lt;code&gt;\N{U+3E}&lt;/code&gt;, and &lt;code&gt;\N{U+3F}&lt;/code&gt;, whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">上記の最後の2つの例が示すように、範囲エンドポイントに &lt;code&gt;\N{...}&lt;/code&gt; 形式を使用することで、非ASCIIプラットフォームへの移植性を実現できます。これらは、指定された範囲がUnicode値を使用して解釈されることを示しているため、 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; は &lt;code&gt;\N{U+27}&lt;/code&gt; 、 &lt;code&gt;\N{U+28}&lt;/code&gt; +28}と一致することを意味します、 &lt;code&gt;\N{U+29}&lt;/code&gt; 、...、 &lt;code&gt;\N{U+3D}&lt;/code&gt; 、 &lt;code&gt;\N{U+3E}&lt;/code&gt; 、および &lt;code&gt;\N{U+3F}&lt;/code&gt; 、これらのネイティブコードポイントバージョンが何であれ。これらは「Unicode」範囲と呼ばれます。いずれかの端が &lt;code&gt;\N{...}&lt;/code&gt; 形式の場合、範囲はUnicodeと見なされます。 「 &lt;code&gt;regexp&lt;/code&gt; &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; で正規表現の警告が発生します 他のエンドポイントが非移植的に指定されている場合：</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">上記の最後の2つの例が示すように、範囲のエンドポイントに &lt;code&gt;\N{...}&lt;/code&gt; フォームを使用すると、非ASCIIプラットフォームへの移植性を実現できます。これらは、指定された範囲がUnicode値を使用して解釈されることを示しているため、 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; は &lt;code&gt;\N{U+27}&lt;/code&gt; 、 &lt;code&gt;\N{U+28}&lt;/code&gt; と一致することを意味します、 &lt;code&gt;\N{U+29}&lt;/code&gt; 、...、 &lt;code&gt;\N{U+3D}&lt;/code&gt; 、 &lt;code&gt;\N{U+3E}&lt;/code&gt; 、および &lt;code&gt;\N{U+3F}&lt;/code&gt; 、それらのネイティブコードポイントバージョンが何であれ。これらは「Unicode」範囲と呼ばれます。どちらかの端が &lt;code&gt;\N{...}&lt;/code&gt; 形式の場合、範囲はUnicodeと見なされます。 &lt;code&gt;regexp&lt;/code&gt; 警告がで飼育され &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 他のエンドポイントが移植できないように指定されている場合：</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">プロトタイプの最後の文字として、あるいは単にセミコロン、前に &lt;code&gt;@&lt;/code&gt; または &lt;code&gt;%&lt;/code&gt; は、使用することができます &lt;code&gt;_&lt;/code&gt; の代わりに &lt;code&gt;$&lt;/code&gt; ：この引数が提供されていない場合は、 &lt;code&gt;$_&lt;/code&gt; 代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="9cd30084251e957fbd55793c63ff1e2e0b66c3d5" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt;, you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;: if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">プロトタイプの最後の文字として、またはセミコロン、 &lt;code&gt;@&lt;/code&gt; 、または &lt;code&gt;%&lt;/code&gt; の直前に、 &lt;code&gt;$&lt;/code&gt; の代わりに &lt;code&gt;_&lt;/code&gt; を使用できます。この引数が指定されていない場合は、代わりに &lt;code&gt;$_&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">最後の例が示すように、ハンドラは2つ以上のフェーズで(再)呼ばれるように設定することができます。フェーズ名はハンドラの最終引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">パーサーは2番目以降の行をソースストリームから読み取ると、それらの行を &lt;code&gt;cpp&lt;/code&gt; ソースフィルターに通してから処理します。 &lt;code&gt;cpp&lt;/code&gt; フィルタは、単に実際のCプリプロセッサを介して各ラインを通過します。Cプリプロセッサーからの出力は、フィルターによってソースストリームに挿入されます。</target>
        </trans-unit>
        <trans-unit id="de16f72d9bd04b071a155fd420870c413322270a" translate="yes" xml:space="preserve">
          <source>As the parser sees sections like:</source>
          <target state="translated">パーサーは以下のようなセクションを見ています。</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">パーサが Perl プログラムを理解すると、インタープリタが実行中に実行する操作のツリーを構築します。様々な操作を構築してリンクするルーチンは</target>
        </trans-unit>
        <trans-unit id="720247a05069501ddebd25eded634ebdeed59cfd" translate="yes" xml:space="preserve">
          <source>As the sorting is done in the JSON::PP scope, you usually need to prepend &lt;code&gt;JSON::PP::&lt;/code&gt; to the subroutine name, and the special variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; used in the subrontine used by &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="translated">並べ替えはJSON :: PPスコープで行われるため、通常、 &lt;code&gt;JSON::PP::&lt;/code&gt; をサブルーチン名の前に追加し、 &lt;code&gt;sort&lt;/code&gt; 関数で使用されるサブルーチンで使用される特別な変数 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">互換性のない構文を持つ様々な Make プログラムが存在し、オペレーティングシステムシェルを使用していますが、これもまた互換性のない構文を持っています。</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">が使用しているエラー番号が重複しているため</target>
        </trans-unit>
        <trans-unit id="267c472340bc23541eca7afc953c80b9af09e6af" translate="yes" xml:space="preserve">
          <source>As this callback gets called less often then the &lt;code&gt;filter_json_object&lt;/code&gt; one, decoding speed will not usually suffer as much. Therefore, single-key objects make excellent targets to serialise Perl objects into, especially as single-key JSON objects are as close to the type-tagged value concept as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not support this in any way, so you need to make sure your data never looks like a serialised Perl hash.</source>
          <target state="translated">このコールバックは &lt;code&gt;filter_json_object&lt;/code&gt; のコールバックよりも頻繁に呼び出されないため、通常、デコード速度はそれほど低下しません。したがって、シングルキーオブジェクトは、Perlオブジェクトをシリアル化するための優れたターゲットになります。特にシングルキーJSONオブジェクトは、JSONが取得するタイプタグ付きの値の概念に非常に近いためです（基本的にはID / VALUEタプルです）。もちろん、JSONはこれをまったくサポートしていないため、データがシリアル化されたPerlハッシュのように見えないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="4ae4c3659f41e6ea72787219e7dd135169795201" translate="yes" xml:space="preserve">
          <source>As to how you'd implement the Russian example from the beginning of the article, well, There's More Than One Way To Do It, but it could be something like this (using English words for Russian, just so you know what's going on):</source>
          <target state="translated">冒頭のロシア語の例をどのように実装するかについては、まあ、There's More Than One Way To Do Itですが、次のようなことが考えられます(ロシア語の英単語を使って、何が起こっているのかを知ってもらうために)。</target>
        </trans-unit>
        <trans-unit id="7c1931b1f7f35afcd5d7f66942f927b9ab23c40a" translate="yes" xml:space="preserve">
          <source>As to sharing of auxiliary functions, consider the problem of Russian numbers from the beginning of this article; obviously, you'd want to write only once the hairy code that, given a numeric value, would return some specification of which case and number a given quantified noun should use. But suppose that you discover, while localizing an interface for, say, Ukranian (a Slavic language related to Russian, spoken by several million people, many of whom would be relieved to find that your Web site's or software's interface is available in their language), that the rules in Ukranian are the same as in Russian for quantification, and probably for many other grammatical functions. While there may well be no phrases in common between Russian and Ukranian, you could still choose to have the Ukranian module inherit from the Russian module, just for the sake of inheriting all the various grammatical methods. Or, probably better organizationally, you could move those functions to a module called &lt;code&gt;_E_Slavic&lt;/code&gt; or something, which Russian and Ukrainian could inherit useful functions from, but which would (presumably) provide no lexicon.</source>
          <target state="translated">補助関数の共有に関しては、この記事の最初からロシアの数の問題を考えてみてください。明らかに、数値が与えられると、与えられた定量化された名詞が使用すべきケースと番号の仕様を返すヘアリーコードを一度だけ書きたいと思うでしょう。しかし、たとえばウクライナ語（ロシア語に関連するスラブ語、数百万人が話す、多くの人があなたのWebサイトまたはソフトウェアのインターフェイスが自分の言語で利用できることを知って安心する）のインターフェイスをローカライズしているときに発見したとします。 、ウクライナ語の規則は、定量化、およびおそらく他の多くの文法機能について、ロシア語と同じです。ロシア語とウクライナ語に共通するフレーズはないかもしれませんが、ウクライナ語モジュールをロシア語モジュールから継承させることを選択することもできます。さまざまな文法手法をすべて継承するためだけに。または、おそらく組織的には、これらの関数を次のモジュールに移動できます。 &lt;code&gt;_E_Slavic&lt;/code&gt; または何か。ロシア語とウクライナ語は有用な関数を継承できますが、（おそらく）レキシコンを提供しません。</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">上記のように、Perl 5.6.1は5.7.2と同様、AmigaOSでも優れています。 Perl 5.7.2以降（変更＃11423、変更ファイル、および個々の変更を取得する方法についてはファイルpod / perlhack.podを参照）Perlはvfork（）の内部サポートを削除しました。 AmigaOS（ixemulライブラリにはvforkしかないため）。 ext / DynaLoaderのビルド中にビルドが最終的に失敗し、生成されたMakefileでPERLが「0」になるため、「0」を実行しようとしてもうまくいきません。また、バッククォートでminiperlを実行しても何も生成されないようです。おそらく（v）フォークの問題に関連していると考えられます。&lt;b&gt;破損を修正するには、ixemulライブラリに精通している人と、AmigaOSでfork（）を使用せずに外部コマンドを実行する方法を知っている人が必要です。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">通常通り、 &lt;code&gt;PL_restartop&lt;/code&gt; がから抽出され &lt;code&gt;CxEVAL&lt;/code&gt; 、及び &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; が行われ、docatchにCスタックバックをポップました。</target>
        </trans-unit>
        <trans-unit id="2a573f9f62b976f78c5ac59164a50ae13a402046" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt;, and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">通常通り、 &lt;code&gt;PL_restartop&lt;/code&gt; がから抽出され &lt;code&gt;CxEVAL&lt;/code&gt; 、及び &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; が行われ、docatchにCスタックバックをポップました。</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">いつものように走る</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">上で見たように、原則 0 が他の原則に優先します。正規表現は可能な限り早い段階でマッチし、他の原則はその最も早い文字位置での正規表現のマッチ方法を決定します。</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">前に述べたように、Perl の組み込み OO システムは非常に最小限のものですが、非常に柔軟性に富んでいます。長年にわたり、多くの人がPerlの組み込みシステムの上に構築されたシステムを開発し、より多くの機能や利便性を提供してきました。</target>
        </trans-unit>
        <trans-unit id="4f2e51cb7fb14eb8f1de406668bded94aec1752e" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">前に述べたように、ロールは継承の代替手段を提供しますが、Perlには組み込みのロールサポートがありません。Mooseを使用することを選択した場合は、本格的な役割の実装が付属しています。ただし、他の推奨されるOOモジュールのいずれかを使用する場合でも、&lt;a href=&quot;Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt;でロールを使用できます。</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">前に述べたように、ロールは継承の代わりを提供しますが、Perlにはロールサポートが組み込まれていません。Mooseの使用を選択した場合、Mooseには本格的なロール実装が付属しています。ただし、他の推奨されるOOモジュールのいずれかを使用している場合でも、&lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt;でロールを使用できます。</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">先に述べたように、Perlには特別なコンストラクタ構文はありません。つまり、クラスは独自のコンストラクタを実装しなければなりません。コンストラクタは、単に新しいオブジェクトへの参照を返すクラスメソッドです。</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">空のリストを返しているので、すべて問題ありません。</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">前にも言ったように、Perl の最小限の OO システムは、CPAN 上での OO システムの氾濫につながっています。素のままでクラスを手書きで書くこともできますが、現代のPerlではそうする理由がありません。</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">前に述べたように、ほとんどのPerlオブジェクトはハッシュですが、オブジェクトは任意のPerlデータ型（スカラー、配列など）のインスタンスにすることができます。オブジェクトに無地のデータ構造を回しすることによって行われる&lt;b&gt;祝福&lt;/b&gt;のデータ構造は、Perlの使用していることを &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 機能を。</target>
        </trans-unit>
        <trans-unit id="4b99a5371cd1d193aeb40f1c8ec4bf090e8b2c97" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;bless&lt;/code&gt; function.</source>
          <target state="translated">前に述べたように、ほとんどのPerlオブジェクトはハッシュですが、オブジェクトは任意のPerlデータ型（スカラー、配列など）のインスタンスにすることができます。オブジェクトに無地のデータ構造を回しすることによって行われる&lt;b&gt;祝福&lt;/b&gt;のデータ構造は、Perlの使用していることを &lt;code&gt;bless&lt;/code&gt; 機能を。</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">前に見たように、オブジェクトは単に &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数を介してクラスにblessされたデータ構造です。 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; の機能が1つまたは2つの引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="86afd7b293cb09c0f55f2b3f4442d25492c71a40" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;bless&lt;/code&gt; function. The &lt;code&gt;bless&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">前に見たように、オブジェクトは、 &lt;code&gt;bless&lt;/code&gt; 関数を介してクラスにblessされた単なるデータ構造です。 &lt;code&gt;bless&lt;/code&gt; の機能が1つまたは2つの引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">すでに示したように、 &lt;code&gt;call_sv&lt;/code&gt; を使用して無名サブルーチンを呼び出すことができます。ただし、この例では、この操作を実行するためにXSUBを呼び出すPerlスクリプトを示しました。Cコード内でどのように実行できるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">紐付きハッシュや配列を使ってBerkeley DBにアクセスするだけでなく、Berkeley DBのドキュメントで定義されているほとんどのAPI関数を直接利用することも可能です。</target>
        </trans-unit>
        <trans-unit id="0237593efedf8b6eff88bac44019384e6b74f34f" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the array (like &lt;code&gt;av_clear()&lt;/code&gt;), this also frees the memory used by the av to store its list of scalars.</source>
          <target state="translated">配列のすべての要素（ &lt;code&gt;av_clear()&lt;/code&gt; など）を解放するだけでなく、これにより、avがスカラーのリストを格納するために使用するメモリも解放されます。</target>
        </trans-unit>
        <trans-unit id="9a89b3b004de95ce93de721c0f8e3cdeec13f545" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like &lt;code&gt;hv_clear()&lt;/code&gt;), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">ハッシュのすべての要素（ &lt;code&gt;hv_clear()&lt;/code&gt; など）を解放するだけでなく、ハッシュに関連付けられている補助データとストレージも解放します。</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">(hv_clear()のように)ハッシュのすべての要素を解放するだけでなく、ハッシュに関連する補助的なデータやストレージも解放します。</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">グループ化と同様に、括弧は2番目の目的を果たします。これらは、後で使用するために正規表現一致の一部の結果をキャプチャするために使用できます。結果は &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などになります。</target>
        </trans-unit>
        <trans-unit id="3a1788b97e5572fb886ee20a2620cc1ef5c829d9" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">グループ化だけでなく、括弧は2番目の目的を果たします。これらは、後で使用するために正規表現の一致の一部の結果をキャプチャするために使用できます。結果は &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などになります。</target>
        </trans-unit>
        <trans-unit id="998a4f37f47dfa1a21fcb95591647fa7596884ba" translate="yes" xml:space="preserve">
          <source>As well as the following methods, this class inherits all the methods in &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">次のメソッドに加えて、このクラスは&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;および&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handleの&lt;/a&gt;すべてのメソッドを継承します。</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">この2つと同様に、もう1つのコンバーターがあります。</target>
        </trans-unit>
        <trans-unit id="79309f713ddbfafe2f6334a91eabf7f9425eca6b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set prior to unwinding the call stack; any &lt;code&gt;DESTROY&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; handlers can then alter this value, and thus Perl's exit code.</source>
          <target state="translated">&lt;a href=&quot;#exit-EXPR&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt;と同様に、&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;コールスタックを巻き戻す前に設定されます。任意 &lt;code&gt;DESTROY&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; ハンドラが、この値は、したがって、Perlの終了コードを変更することができます。</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">要素をリストするために &lt;code&gt;$_&lt;/code&gt; をエイリアスする &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; と同様に、 &lt;code&gt;pairfirst&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; を指定されたリストの要素にエイリアスします。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; のエイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairgrep&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; エイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairmap&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="fec85543ad9986bf912be9475be1ac989c167db7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;PERL5OPT&lt;/code&gt;, a string of additional &lt;code&gt;cpan(1)&lt;/code&gt; options to add to those you specify on the command line.</source>
          <target state="translated">&lt;code&gt;PERL5OPT&lt;/code&gt; と同様に、コマンドラインで指定したオプションに追加する追加の &lt;code&gt;cpan(1)&lt;/code&gt; オプションの文字列。</target>
        </trans-unit>
        <trans-unit id="cc99e7ad503065bd82f24f799275058edae300da" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;grep&lt;/code&gt; のエイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairfirst&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="4d482c5453c9dc11a8d1e3e4a1d4df1955e90671" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;grep&lt;/code&gt; のエイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairgrep&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">&lt;code&gt;gzerror()&lt;/code&gt; と同様に、数値コンテキストではエラー番号を返し、文字列コンテキストではエラーメッセージを返します。ただし、 &lt;code&gt;gzerror()&lt;/code&gt; とは異なり、エラーメッセージは</target>
        </trans-unit>
        <trans-unit id="ad8ddc963c1faca12f5a1122723298a5bb8081cc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;map&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;map&lt;/code&gt; エイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairmap&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">同じように &lt;code&gt;mro::get_linear_isa&lt;/code&gt; 以上、 &lt;code&gt;UNIVERSAL&lt;/code&gt; は特別です。 &lt;code&gt;UNIVERSAL&lt;/code&gt; （および親の）isarevリストには、すべてのクラスがメソッド継承のために事実上子孫であるとしても、存在するすべてのクラスが含まれているわけではありません。</target>
        </trans-unit>
        <trans-unit id="32eae94f86fad4a1553a0eb1f5e32221b0ef149f" translate="yes" xml:space="preserve">
          <source>As with CORE::utime(), passing undef as both the atime and mtime will call the syscall with a NULL argument.</source>
          <target state="translated">CORE::utime()と同様に、atime と mtime の両方に undef を渡すと、 NULL 引数で syscall を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">G_SCALARと同様に、このフラグには2つの効果があります。</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">GetOptionsFromArrayと同様に、第1引数のハッシュ参照が第2引数になります。</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">すべての &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ディレクティブと同様に、定数の定義はコンパイル時に行われます。したがって、条件付きステートメント内に定数宣言を置くことはおそらく正しくありません（ &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5354f6304cc90aca1a4c69a0041cb7b6c7daa540" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;use&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt;).</source>
          <target state="translated">すべての &lt;code&gt;use&lt;/code&gt; ディレクティブと同様に、定数の定義はコンパイル時に行われます。したがって、条件文の中に定数宣言を入れるのはおそらく正しくありません（ &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">すべてのコンパイラバックエンドオプションと同様に、これらのオプションは '-MO=Deparse' の直後に続き、カンマで区切られていなければなりませんが、空白はありません。</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">すべての標準コマンドと同様に、1文字のスイッチは、次のスイッチがあればクラスタ化することができます。</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Perlのすべてのものと同様に。</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">他の &lt;code&gt;lock_store&lt;/code&gt; ロックスキームと同様に、保護は、lock_storeおよび &lt;code&gt;lock_retrieve&lt;/code&gt; を体系的に使用する場合にのみ機能します。アプリケーションの一方が &lt;code&gt;store&lt;/code&gt; を使用し、もう一方が &lt;code&gt;lock_retrieve&lt;/code&gt; を使用する場合、保護はまったく得られません。</target>
        </trans-unit>
        <trans-unit id="cbbf76ef92d8f729f36aea391937508d71d89ba4" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt;. If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt;, you will get no protection at all.</source>
          <target state="translated">他のアドバイザリロックスキームと同様に、保護は、 &lt;code&gt;lock_store&lt;/code&gt; と &lt;code&gt;lock_retrieve&lt;/code&gt; を体系的に使用する場合にのみ機能します。アプリケーションの一方が &lt;code&gt;store&lt;/code&gt; を使用し、もう一方が &lt;code&gt;lock_retrieve&lt;/code&gt; を使用している場合、保護はまったく得られません。</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">コンストラクタと同様に、Perl は特別なアクセサ宣言構文を提供しないので、クラスは明示的に書かれたアクセサメソッドを提供しなければなりません。アクセサには、読み込み専用と書き込み専用の2つの共通のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">多くの unix ポートと同様に、このポートは、QNX4 の標準とは限らないいくつかの「標準的な」unix ユーティリティに依存しています。</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">通常のPerl配列と同様に、RECNO配列は負のインデックスを使用してアクセスすることができます。インデックス -1 は配列の最後の要素を参照し、-2 は最後の 2 番目の要素を参照します。配列の開始前の要素にアクセスしようとすると、致命的なランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">postfix 配列と同様に、postfix の値のスライスを参照します。</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">サブルーチンと同様に、スレッドのエントリポイント関数から返される値の型は、スレッドの</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">と同様に</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">DB_HASH 形式と同様に、キーの比較を実行するためにユーザ定義の Perl ルーチンを提供することができます。しかし、デフォルトでは、キーは語彙順に格納されます。</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">追加モードと同様に、ファイルを書き込み専用モードで開くと、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; のいずれかを使用して、そのファイルハンドルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="d97479933fa1462fae02a9e50ede26b28a53d5f2" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="translated">追加モードと同様に、書き込み専用モードでファイルを開くと、 &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;say&lt;/code&gt; 、 &lt;code&gt;write&lt;/code&gt; 、または &lt;code&gt;syswrite&lt;/code&gt; のいずれかを使用してそのファイルハンドルに書き込むことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="166455d62d96ee30d0f7c0e9ebb9b193aa0e9037" translate="yes" xml:space="preserve">
          <source>As with the built-in &lt;code&gt;chmod()&lt;/code&gt;, &lt;code&gt;$file&lt;/code&gt; may be a filename or a file handle.</source>
          <target state="translated">組み込みの &lt;code&gt;chmod()&lt;/code&gt; と同様に、 &lt;code&gt;$file&lt;/code&gt; はファイル名またはファイルハンドルです。</target>
        </trans-unit>
        <trans-unit id="1061a3cd33d1bd9d36627a353371c49a4d11968d" translate="yes" xml:space="preserve">
          <source>As with the mark stack to the value stack, the scope stack forms a pair with the save stack. The scope stack stores the height of the save stack at which nested scopes begin, and allows the save stack to be unwound back to that point when the scope is left.</source>
          <target state="translated">マーク スタックから値スタックへのマーク スタックと同様に、 スコープ スタックはセーブ スタックとペアを形成します。スコープスタックは、入れ子になったスコープの開始点であるセーブスタックの高さを格納し、スコープが残っているときにセーブスタックをその点まで巻き戻すことを可能にします。</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 演算子と同様に、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; などの他の区切り文字を使用できます!!! および &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 、さらには &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。単一引用符が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; で使用されている場合、正規表現と置換は単一引用符付きの文字列として扱われ、変数の置換はありません。リストコンテキスト &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は、スカラーコンテキストと同じもの、つまり一致の数を返します。</target>
        </trans-unit>
        <trans-unit id="8a7f1aef7986985cb8cfbcb39be9e92c12b6802e" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;m//&lt;/code&gt; operator, &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;s///&lt;/code&gt; in list context returns the same thing as in scalar context,</source>
          <target state="translated">match &lt;code&gt;m//&lt;/code&gt; 演算子と同様に、 &lt;code&gt;s///&lt;/code&gt; は &lt;code&gt;s!!!&lt;/code&gt; などの他の区切り文字を使用できます!!! および &lt;code&gt;s{}{}&lt;/code&gt; 、さらには &lt;code&gt;s{}//&lt;/code&gt; 。一重引用符が使用されている場合（ &lt;code&gt;s'''&lt;/code&gt; ）、正規表現と置換は一重引用符で囲まれた文字列として扱われ、変数の置換はありません。リストコンテキスト &lt;code&gt;s///&lt;/code&gt; は、スカラーコンテキストの場合と同じものを返します。</target>
        </trans-unit>
        <trans-unit id="5751273786ef031d84398bd287378b577d2ec97d" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters,</source>
          <target state="translated">マッチング演算子と同様に、正規表現の引用符は異なるデリミタを使用することができます。</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">一致する演算子と同様に、正規表現の引用符は &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; 異なる区切り文字を使用できます。、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; 。区切り文字としてのアポストロフィ（ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ）は、補間を禁止します。</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">他のタイプのタイと同様に、このメソッドは &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; が発生したときに呼び出されます。これが発生した場合は、「自動クローズ」が適切な場合があります。以下&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;のuntie Gotchaを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="afcbb54437173c8bdb1b71e9fdd8c918462556a8" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;untie&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="translated">他のタイプのタイと同様に、このメソッドは &lt;code&gt;untie&lt;/code&gt; が発生したときに呼び出されます。これが発生した場合は、「自動クローズ」が適切な場合があります。参照&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;「 &lt;code&gt;untie&lt;/code&gt; ガッチャ」&lt;/a&gt;以下を。</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">他のタイプのタイと同様に、このメソッドはタイドハンドルが破棄されようとしているときに呼び出されます。これは、デバッグや場合によってはクリーンアップに便利です。</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">リターンスタックの場合と同様に、データを押し込む前にリターン配列を事前に拡張することが可能です (そして、小さなパフォーマンスの向上につながります)。</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">シェルと同様に、Perlでは &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; を使用してファイルを読み取り専用モードで開きます。成功した場合、Perlは新しいファイルハンドルを割り当て、以前に未定義の &lt;code&gt;$handle&lt;/code&gt; 引数にそのハンドルへの参照を設定します。</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">ご覧のとおり、3つのレコードがキー &lt;code&gt;Wall&lt;/code&gt; で正常に作成されました。唯一のことは、データベースから取得されたときに、</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">ご覧のとおり、両方のモジュールの構造はおおまかに似ています。どちらも &lt;code&gt;Filter::Util::Call&lt;/code&gt; モジュールを使用しており、どちらにも &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドがあります。それらの違いは、</target>
        </trans-unit>
        <trans-unit id="6c90ba06fa5e1fe7496f3d2e8756e36b17de7ff3" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;import&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">ご覧のとおり、両方のモジュールの構造はほぼ同じです。どちらも &lt;code&gt;Filter::Util::Call&lt;/code&gt; モジュールを利用しており、どちらにも &lt;code&gt;import&lt;/code&gt; メソッドがあります。それらの違いは、</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">概要を見ればわかるように、テンプレートに基づいて、提供された引数が検証されます。</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">ご覧の通りです。</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Fred.pm&lt;/code&gt; からソースを読み取るための新しいストリームが作成されています。このストリームは、 &lt;code&gt;Fred.pm&lt;/code&gt; がすべて解析されるまでアクティブのままです。 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームは引き続き存在しますが、非アクティブです。パーサーがFred.pmの読み取りを完了すると、それに関連付けられているソースストリームが破棄されます。その後、 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームが再びアクティブになり、パーサーが4行目以降を &lt;code&gt;cpp_test&lt;/code&gt; から読み取ります。</target>
        </trans-unit>
        <trans-unit id="d30857f7aa9b41378f7136a05fa07d62994d4300" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt;. This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Fred.pm&lt;/code&gt; からソースを読み取るための新しいストリームが作成されています。このストリームは、 &lt;code&gt;Fred.pm&lt;/code&gt; がすべて解析されるまでアクティブのままになります。 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームは引き続き存在しますが、非アクティブです。パーサーがFred.pmの読み取りを終了すると、それに関連付けられているソースストリームが破棄されます。その後、 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームが再びアクティブになり、パーサーは &lt;code&gt;cpp_test&lt;/code&gt; から4行目以降の行を読み取ります。</target>
        </trans-unit>
        <trans-unit id="25de0c5886c2da663b8272fdb54e70c4ca6e8f92" translate="yes" xml:space="preserve">
          <source>As you can see, either a bare number or a quoted string can usually be used interchangeably, except in the case of a trailing zero, which must be quoted to be converted properly. For this reason, it is strongly recommended that all initializers to qv() be quoted strings instead of bare numbers.</source>
          <target state="translated">ご覧のように、裸の数字と引用符で囲まれた文字列のどちらも通常は互換性を持って使用することができますが、末尾のゼロの場合は引用符で囲まれていなければ適切に変換されません。このため、qv()のすべての初期化子は裸の数値ではなく引用符付きの文字列にすることを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">ご覧のように、ブランチとピースを解析しましたが、最終的にはアトムにすぎませんでした。最後のプログラムは、物事がどのように機能するかを示しています。我々は持っている &lt;code&gt;EXACT&lt;/code&gt; 続いregop、 &lt;code&gt;END&lt;/code&gt; の regopを。括弧内の &lt;code&gt;regnext&lt;/code&gt; は、ノードのregnextがどこに行くかを示します。 &lt;code&gt;regnext&lt;/code&gt; の &lt;code&gt;END&lt;/code&gt; のようregopは、未使用である &lt;code&gt;END&lt;/code&gt; の regopsは、我々が正常に一致した意味します。左側の数字は、regnode配列内のレゴの位置を示します。</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">ご覧のように、それは少し複雑になってきています。だからこそ、時々は一時的なものを取る方が簡単なのです。</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">ご覧のとおり、矢印の「ビッグエンド」が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; に接触しています。これは、 &lt;code&gt;&amp;gt;&lt;/code&gt; がビッグエンディアン修飾子であることを覚えておくのに良い方法です。同じことが明らかに &lt;code&gt;&amp;lt;&lt;/code&gt; でも機能し、「小さな終わり」がコードに触れます。</target>
        </trans-unit>
        <trans-unit id="e38e7377d2adf9700c078e4fa63c0bfa66881f41" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;s&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt;, where the &quot;little end&quot; touches the code.</source>
          <target state="translated">ご覧のとおり、矢印の「ビッグエンド」は &lt;code&gt;s&lt;/code&gt; に接しています。これは、 &lt;code&gt;&amp;gt;&lt;/code&gt; がビッグエンディアン修飾子であることを覚えておくのに適した方法です。同じことが明らかに &lt;code&gt;&amp;lt;&lt;/code&gt; 、「リトルエンド」がコードに触れる場合にも機能します。</target>
        </trans-unit>
        <trans-unit id="66163e2bfe72429a8264b60a772dffb530266b37" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;&quot;|&quot;&lt;/code&gt; binds less tightly than a sequence of ordinary characters. We can override this by using the grouping metacharacters, the parentheses &lt;code&gt;&quot;(&quot;&lt;/code&gt; and &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 通常の文字のシーケンスよりも緊密にバインドされません。グループ化メタ文字である括弧 &lt;code&gt;&quot;(&quot;&lt;/code&gt; および &lt;code&gt;&quot;)&quot;&lt;/code&gt; を使用して、これをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">ご覧のとおり、継続バイトはすべて &lt;code&gt;&quot;10&quot;&lt;/code&gt; で始まり、開始バイトの先頭ビットによって、エンコードされた文字のバイト数がわかります。</target>
        </trans-unit>
        <trans-unit id="d1ec4366039f138acb113c4753f7ee644d2c9618" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt;, and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">ご覧のとおり、継続バイトはすべて &lt;code&gt;&quot;10&quot;&lt;/code&gt; で始まり、開始バイトの先頭ビットは、エンコードされた文字に何バイトあるかを示します。</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">ご覧のように、パスとファイルのデータをオブジェクト自体に格納しています。このオブジェクトは単なるハッシュであることを覚えておいてください。後で、このデータを操作するためにアクセサを書きます。</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">&lt;a href=&quot;perlpod&quot;&gt;perlpodを&lt;/a&gt;見ればわかるように、L &amp;lt;...&amp;gt;コードは、Podのフォーマットコードの中で最も複雑です。以下のポイントは、それが何を意味し、どのようにプロセッサがそれに対処する必要があるかを明確にするでしょう。</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">Perl コアに提出するパッチを作成する際には、良いコミットメッセージを書くことが重要です。これは、あなたの投稿が一連のコミットで構成されている場合には特に重要です。</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">上記のドキュメントと例から推測できるように、 &lt;code&gt;ok&lt;/code&gt; のプロトタイプは &lt;code&gt;($;$$)&lt;/code&gt; です（そして、偶然に &lt;code&gt;skip&lt;/code&gt; は &lt;code&gt;($;$$$)&lt;/code&gt; です）。これは、たとえば、 &lt;code&gt;ok @foo, @bar&lt;/code&gt; を実行して、</target>
        </trans-unit>
        <trans-unit id="60f0e85b8faee0b99818f50244dd5f18552cf61a" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt;'s prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt;'s is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">上記のドキュメントと例から推測できるように、 &lt;code&gt;ok&lt;/code&gt; のプロトタイプは &lt;code&gt;($;$$)&lt;/code&gt; です（ちなみに、 &lt;code&gt;skip&lt;/code&gt; は &lt;code&gt;($;$$$)&lt;/code&gt; です）。これは、たとえば、 &lt;code&gt;ok @foo, @bar&lt;/code&gt; を実行して比較できることを意味します</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">お気づきかもしれませんが、FETCHメソッド(など)の名前は、コンストラクタの名前が異なっていても(TIESCALAR vs TIEARRAY)、すべてのアクセスに対して同じです。理論的には、同じクラスで複数のタイ型を扱うことができますが、実際にはこれは面倒なので、1つのクラスに1つのタイ型だけにしておくのが一番簡単です。</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">ご存知かもしれませんが、これはコンパイル時に &lt;code&gt;attributes&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 関数をこれらのパラメーターで呼び出します：「属性」、呼び出し元のパッケージ名、コードへの参照、および「メソッド」。</target>
        </trans-unit>
        <trans-unit id="62f1e6ecdd027dd1eaef3a110461833a51c5767e" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;import&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">ご存知かもしれませんが、これはコンパイル時に &lt;code&gt;attributes&lt;/code&gt; の &lt;code&gt;import&lt;/code&gt; 関数を次のパラメーターで呼び出します：「属性」、呼び出し元のパッケージ名、コードへの参照、および「メソッド」。</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">これらの例からわかるように、 &lt;code&gt;STDOUT&lt;/code&gt; と &lt;code&gt;STDERR&lt;/code&gt; は出力ハンドルであり、 &lt;code&gt;STDIN&lt;/code&gt; と &lt;code&gt;ARGV&lt;/code&gt; は入力ハンドルです。 &lt;code&gt;@ARGV&lt;/code&gt; 配列や &lt;code&gt;%ENV&lt;/code&gt; ハッシュと同様に、Perlに予約されているため、すべて大文字です。それらの外部関連付けは、シェルによってセットアップされました。</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">ご覧のように、混乱するのは簡単です。この責任の一部はリファレンスベースの実装に起因していますが、実際には初心者のために設計された例を含む既存のドキュメントが不足していることに起因しています。</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">ご覧のように、これはインターネットドメインの TCP サーバと非常によく似ていますが、実際には、spawn()、logmsg()、ctime()、REAPER()といった重複した関数をいくつか省略しています。</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">ご覧の通り、パッケージ名は構造体の名前です。レギュラーフィールドはそれ自体の名前です。さらに、以下のアクセサ関数が用意されています。</target>
        </trans-unit>
        <trans-unit id="1963330f0948df59dbdb1893ed34078a319f8af0" translate="yes" xml:space="preserve">
          <source>As you see, the next buffer begins with \x43. But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.</source>
          <target state="translated">見ての通り、次のバッファは「\x43」から始まっている。しかし、この場合は間違っています。なぜなら、今はJISX 0208の領域にいるので、\x43ではなく、\x43を変換しなければならないからです。utf8 や EUC とは異なり、エスケープベースのエンコーディングでは、与えられたオクテットが文字全体なのか、それともその一部なのかはわかりません。</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">ご覧のとおり、1つの例外があります。ASCIIです。このようにして、目標1を想定できます。そして、 &lt;code&gt;Encode&lt;/code&gt; を使用すると、目標＃2が想定されますが、上記の&lt;b&gt;CAVEATの&lt;/b&gt;段落で言及されているケースには&lt;b&gt;引き続き&lt;/b&gt;注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">ご覧のように、これは少し厄介なことがあります。正規表現は成功の定義を与えるアサーションの集合に過ぎないことを理解することが重要です。定義が特定の文字列に対して成功する方法は0、1、またはいくつかあります。そして、成功する可能性のある複数の方法がある場合、どのような種類の成功が得られるかを知るために、バックトラッキングを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">ご想像のとおり、この修飾子は、たとえば、 &lt;code&gt;\D&lt;/code&gt; が &lt;code&gt;[^0-9]&lt;/code&gt; と同じことを意味します。実際、非ASCII文字はすべて &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、および &lt;code&gt;\W&lt;/code&gt; と一致します。 &lt;code&gt;\b&lt;/code&gt; は、それらの &lt;code&gt;/a&lt;/code&gt; 定義を使用して、 &lt;code&gt;\w&lt;/code&gt; と &lt;code&gt;\W&lt;/code&gt; 境界で一致することを意味します（ &lt;code&gt;\B&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="326d016c49ef7a973850d57e2bcbf3c0189253be" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt;; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt;, using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt;).</source>
          <target state="translated">ご想像のとおり、この修飾子を使用すると、たとえば、 &lt;code&gt;\D&lt;/code&gt; は &lt;code&gt;[^0-9]&lt;/code&gt; と同じ意味になります。実際、すべての非ASCII文字は &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、および &lt;code&gt;\W&lt;/code&gt; 一致します。 &lt;code&gt;\b&lt;/code&gt; は、 &lt;code&gt;\w&lt;/code&gt; と &lt;code&gt;\W&lt;/code&gt; 境界で、それらの &lt;code&gt;/a&lt;/code&gt; 定義を使用して一致することを意味します（ &lt;code&gt;\B&lt;/code&gt; も同様）。</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">アプリケーションを書いているときに、どのようなメッセージを発する必要があるかを自分で決めていきます。通常、あなたはこれを書きに行きます。</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 、最初の引数として空の文字列またはボリューム名で始まるパスを渡すことにより、catdir（）に絶対パスを作成させることができます。ただし、これは下位互換性のためにのみ行われるため、そうしないことを強くお勧めします。 File :: Specの新しいバージョンには、絶対パスを作成するためのポータブルソリューションを提供するように設計された &lt;code&gt;catpath()&lt;/code&gt; （以下を参照）と呼ばれるメソッドが付属しています。ボリューム、ディレクトリ、ファイルの部分を取り、パス全体を返します。ながら &lt;code&gt;catdir()&lt;/code&gt; は依然としての連結に適しています</target>
        </trans-unit>
        <trans-unit id="b050afe32e842917948687f3937c11147c83dc8c" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_bin()&lt;/code&gt;, but with a &quot;0b&quot; prefix.</source>
          <target state="translated">として、 &lt;code&gt;to_bin()&lt;/code&gt; ですが、プレフィックスは「0b」です。</target>
        </trans-unit>
        <trans-unit id="88a7400facc4c4fbcaa07e7c2bb5aa1602866660" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_hex()&lt;/code&gt;, but with a &quot;0x&quot; prefix.</source>
          <target state="translated">として、 &lt;code&gt;to_hex()&lt;/code&gt; ですが、プレフィックスは「0x」です。</target>
        </trans-unit>
        <trans-unit id="743f14ce73f3cd35ea5c0dbbced7d93ed35d470e" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_oct()&lt;/code&gt;, but with a &quot;0&quot; prefix.</source>
          <target state="translated">として、 &lt;code&gt;to_oct()&lt;/code&gt; ですが、プレフィックスは「0」です。</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="ef98034aa566e13ada7b3540ed05db8863763db2" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;my()&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot;&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot;&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt;.</source>
          <target state="translated">実験機能（以下の&lt;a href=&quot;#Signatures&quot;&gt;「署名」を&lt;/a&gt;参照）を除いて、Perlには名前付き仮パラメーターがありません。実際には、これらの &lt;code&gt;my()&lt;/code&gt; リストに割り当てるだけです。プライベートとして宣言されていない変数はグローバル変数です。プライベート変数の作成に関する詳細については、&lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;「my（）を介したプライベート変数」&lt;/a&gt;および&lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;「local（）を介した一時値&lt;/a&gt;」を参照してください。一連の関数の保護された環境を別のパッケージ（およびおそらく別のファイル）で作成するには&lt;a href=&quot;perlmod#Packages&quot;&gt;、perlmodの「パッケージ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">実験的な機能（下記の&lt;a href=&quot;#Signatures&quot;&gt;署名を&lt;/a&gt;参照）を除いて、Perlには名前付きの仮パラメータがありません。実際には、これらの &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; リストに割り当てるだけです。プライベートであると宣言されていない変数はグローバル変数です。プライベート変数の作成に関する詳細については、「&lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;my（）によるプライベート変数」&lt;/a&gt;および「&lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;local（）による一時値」を&lt;/a&gt;参照してください。一連の関数の保護された環境を別のパッケージ（おそらく別のファイル）に作成するには、「&lt;a href=&quot;perlmod#Packages&quot;&gt;perlmodのパッケージ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">新しいPerlの実行ファイルを作成するように指示します。</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">現在のメンテナにお願いして、あなたを共同メンテナにするか、モジュールをあなたに譲渡してもらいましょう。</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">サーバーが受け付けるコマンドについて、「役に立つ情報」(RFCではそう言っています)を聞いてみましょう。</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">尋ねてみてください。利用できる電子メールプロバイダは非常に多く、ローカルシステムがユーザーの電子メールアドレスを決定する方法を知っているとは思えません。</target>
        </trans-unit>
        <trans-unit id="8175f0d205c5d75254bfd57646dfed8cae5e64df" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are not the same.</source>
          <target state="translated">2つの文字列が同じではないことを主張する。</target>
        </trans-unit>
        <trans-unit id="105ecea82b3155461bbe416d044a05c528e58f67" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are the same.</source>
          <target state="translated">2つの文字列が同じであることを主張する。</target>
        </trans-unit>
        <trans-unit id="3cd83e9891bd9f5bea1baf962bedc44d308569ef" translate="yes" xml:space="preserve">
          <source>Assertion %s failed: file &quot;%s&quot;, line %d</source>
          <target state="translated">アサーション %s は失敗しました:ファイル &quot;%s&quot;、行 %d。</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">アサーションは真でなければならない条件であり、実際には部分文字列の一部とは一致しません。バックスラッシュ列として書かれたアサーションが6つあります。</target>
        </trans-unit>
        <trans-unit id="ec473104d4054125a1271db8c3a3c454c061191a" translate="yes" xml:space="preserve">
          <source>Assigned Charset Names by IANA</source>
          <target state="translated">IANAによる文字セット名の割り当て</target>
        </trans-unit>
        <trans-unit id="6a86826951e8fe2168fef92e79a3e63e6f4fad1f" translate="yes" xml:space="preserve">
          <source>Assigned value is not %s reference</source>
          <target state="translated">代入された値は %s 参照ではありません。</target>
        </trans-unit>
        <trans-unit id="9f6fd2dd7df68753c5a7360c0d8b35ab5d159443" translate="yes" xml:space="preserve">
          <source>Assigned value is not a reference</source>
          <target state="translated">代入された値は参照ではありません</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">マジックの割り当て</target>
        </trans-unit>
        <trans-unit id="50bb715253aae843187816dcb0ecbb87efcdec5e" translate="yes" xml:space="preserve">
          <source>Assigning a filehandle to a bareword</source>
          <target state="translated">ベアワードにファイルハンドルを割り当てる</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">変数の代入と参照の解除。</target>
        </trans-unit>
        <trans-unit id="9b18b9bc51526dfb449c1c7223109c18c9530a59" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is fatal</source>
          <target state="translated">0 以外の値を $[に代入するのは致命的です。</target>
        </trans-unit>
        <trans-unit id="a93015f6058ffbf0e4e5d995a578a534b1b45233" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is no longer possible</source>
          <target state="translated">にゼロ以外の値を代入することはできなくなりました。</target>
        </trans-unit>
        <trans-unit id="39852930a7cbed0e34d5b478d338273371ea5664" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to &lt;code&gt;$[&lt;/code&gt; is fatal</source>
          <target state="translated">&lt;code&gt;$[&lt;/code&gt; ゼロ以外を割り当てることは致命的です</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">リファレンスへの割り当て</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">プライベート変数のリストに代入して、引数に名前を付けます。</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">ハッシュのエントリに代入すると、ファイルのタイムスタンプが変更されます。ファイルが存在しない場合は、ファイルが作成されます。ハッシュ要素に単一の整数を代入すると、アクセス時間と修正時間の両方がその値に変更されます。あるいは、2つの値からなる配列への参照を渡すこともできます。最初の配列要素はアクセス時間を設定するために使用され、2番目の要素は修正時間を設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">特別な変数に代入します。</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">代入演算子</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">代入は、左引数を使って右引数のコンテキストを決定するという点で少し特殊です。スカラへの代入はスカラコンテキストで右辺を評価し、配列やハッシュへの代入はリストコンテキストで右辺を評価します。リスト(またはスライス、これはいずれにせよただのリストです)への代入も、リストコンテキストで右辺を評価します。</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">代入演算子はCと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">タイプグローブへの割り当ては、エイリアシング操作を行います。</target>
        </trans-unit>
        <trans-unit id="efdb1ec14f21e9ed5ad15f6e0bef5c8c9ed1a0b1" translate="yes" xml:space="preserve">
          <source>Assignment to both a list and a scalar</source>
          <target state="translated">リストとスカラの両方に代入</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">リストや条件付き三項式では、右辺の値が左辺の各要素に対して正しい型である限り、参照と非参照の代入を組み合わせることができますが、これはコードを難読化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">マッチング変数に関連付けられた &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...ある&lt;b&gt;後方参照&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; 、 &lt;code&gt;\g2&lt;/code&gt; 、...後方参照を使用できる変数にマッチしています</target>
        </trans-unit>
        <trans-unit id="de3f3ea1d0b7efcc3a2ee5d6b60bcc68b1043b48" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;, ... Backreferences are matching variables that can be used</source>
          <target state="translated">マッチング変数に関連付けられた &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...ある&lt;b&gt;後方参照&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; 、 &lt;code&gt;\g2&lt;/code&gt; 、...後方参照を使用できる変数にマッチしています</target>
        </trans-unit>
        <trans-unit id="68987493bca5f5e7abadf4c61d3d6f22214b34fc" translate="yes" xml:space="preserve">
          <source>Associates an internal FILEHANDLE with the external file specified by EXPR. That filehandle will subsequently allow you to perform I/O operations on that file, such as reading from it or writing to it.</source>
          <target state="translated">内部FILEHANDLEをEXPRで指定された外部ファイルに関連付けます。このファイルハンドルを使用して、そのファイルからの読み取りや書き込みなど、そのファイルに対するI/O操作を実行することができます。</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">構造体（特に、システムヘッダーから取得したものなど、ユーザーが制御しないもの）について&lt;b&gt;何かを&lt;/b&gt;想定します。</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">各文は 2 つの空白で終わると仮定して、その間隔を維持しようとします。このオプションを指定しないと、非バーバティム段落の連続した空白はすべて1つのスペースに圧縮されます。</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">4つのクラスA、B、C、Dを想定します。</target>
        </trans-unit>
        <trans-unit id="52c1183f42274e0344acc650141fdfaebc8ac557" translate="yes" xml:space="preserve">
          <source>Assume no one is paying attention and skips prompts for distributions that do that correctly. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="translated">誰も注意を払っていないと仮定し、それを正しく行うディストリビューションのプロンプトをスキップします。 &lt;code&gt;cpan(1)&lt;/code&gt; は、すでに値がない限り（その値がfalseであっても）、これを &lt;code&gt;1&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="2226e484e68600c3306101e70d0302d670391b19" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt;. However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; are portable, and starting in Perl v5.24, the same ranges are portable in &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">文字の数値（&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt; &lt;code&gt;ord&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt; &lt;code&gt;chr&lt;/code&gt; &lt;/a&gt;）については何も想定していません。明示的なコードポイント範囲（ &lt;code&gt;\xHH-\xHH)&lt;/code&gt; は使用しないでください。ただし、Perl v5.22以降では、 &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; ように指定された正規表現パターンの括弧で囲まれた文字クラス範囲は移植可能であり、Perlv5.24以降では同じ範囲が&lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt; &lt;code&gt;tr///&lt;/code&gt; &lt;/a&gt;移植可能です。 &lt;code&gt;[:print:]&lt;/code&gt; のようなシンボリック文字クラスを移植的に使用できます。</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">文字の数値（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）については何も想定していません。明示的なコードポイント範囲（ &lt;code&gt;\xHH-\xHH)&lt;/code&gt; は使用しないでください。ただし、Perl v5.22以降では、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; ように指定された正規表現パターンの括弧で囲まれた文字クラス範囲は移植可能です。 &lt;code&gt;[:print:]&lt;/code&gt; のようなシンボリック文字クラスを移植可能に使用できます。</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">整数は20バイト以下のメモリを取ることができず、floatは24バイト以下のメモリを取ることができず、文字列は32バイト以下のメモリを取ることができないと仮定します(これらの例はすべて32ビットアーキテクチャを想定していますが、結果は64ビットアーキテクチャではかなり悪いものになります)。変数が 3 つの異なる方法のうち 2 つの方法でアクセスされた場合 (整数、float、文字列を必要とする)、メモリフットプリントはさらに 20 バイト増加する可能性があります。ずさんな malloc(3)の実装は、これらの数値を劇的に増加させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">古い DLL の名前が</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">あなたが熟練したポーターであると仮定して、必要なツールがすべてシステム上にすでに存在していることを確認し、Perl のソース・ディストリビューションを入手する方法を知っているとします。それをアンターして、extract ディレクトリに移動して</target>
        </trans-unit>
        <trans-unit id="111d847871723c094fda67b2b5bccd84d523f158" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">デフォルトのTAPバージョン12ではなく、&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parserの&lt;/a&gt;このTAPバージョンを想定します。</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">デフォルトのTAPバージョン12ではなく、&lt;a href=&quot;parser&quot;&gt;TAP :: Parserの&lt;/a&gt;このTAPバージョンを想定します。</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">キャラクターセットについてはほとんど想定していません。</target>
        </trans-unit>
        <trans-unit id="14aa653264a55e7f75e0cffdf8147628d06e0a12" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;PL_op&lt;/code&gt; is the OP that originally triggered the error, and that &lt;code&gt;PL_comppad&lt;/code&gt;/&lt;code&gt;PL_curpad&lt;/code&gt; points to the currently executing pad.</source>
          <target state="translated">PL_opが &lt;code&gt;PL_op&lt;/code&gt; エラーをトリガーしたOPであり、 &lt;code&gt;PL_comppad&lt;/code&gt; / &lt;code&gt;PL_curpad&lt;/code&gt; が現在実行中のパッドを指していると想定します。</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">PL_op が元々エラーを引き起こしたオペであり、PL_comppad/PL_curpad が現在実行中のパッドを指していると仮定します。</target>
        </trans-unit>
        <trans-unit id="40680f85edea3366c2b9e8f14183ac57a5e6081e" translate="yes" xml:space="preserve">
          <source>Assuming NOT a POSIX class since %s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の％s以降、POSIXクラスではないと想定します。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">任意の型のデータに対して任意の型のポインタを参照解除できると仮定すると</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">sizeof(int)==sizeof(long)と仮定すると</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">仮定すると、 &lt;code&gt;man&lt;/code&gt; -filesが適切な位置に置かれた、これは最小限のPerlシステムのインストールを完了します。（バイナリディストリビューションには、多くの追加モジュールとINF形式のドキュメントも含まれています。）</target>
        </trans-unit>
        <trans-unit id="d729092ca24191c5dd2dddf6e45eb913d7433329" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt;-files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; ファイルが適切な場所に配置されていると仮定すると、これで最小限のPerlシステムのインストールが完了します。（バイナリ配布には、多くの追加モジュールとINF形式のドキュメントも含まれています。）</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd、mm/dd/yyy、dd.mm.yyyの3つの形式のいずれかで指定されたカレンダーの日付を一致させる必要があると仮定すると、日付に関連する構成要素をキャプチャするグループの名前として、それぞれ「d」、「m」、「y」を使用する3つの適切なパターンを記述することができます。マッチング演算では、これら3つのパターンを組み合わせて代替案を作成します。</target>
        </trans-unit>
        <trans-unit id="391cee4ecd3812f9caf92f329d5fa158ab37c5f3" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt; and &lt;code&gt;'y'&lt;/code&gt; respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd、mm / dd / yyyy、またはdd.mm.yyyyの3つの形式のいずれかで指定できるカレンダーの日付を一致させる必要があると仮定すると、 &lt;code&gt;'d'&lt;/code&gt; 、 &lt;code&gt;'m'&lt;/code&gt; 」を使用して3つの適切なパターンを記述できます。日付の関連コンポーネントをキャプチャするグループの名前として、それぞれm 'と &lt;code&gt;'y'&lt;/code&gt; 。マッチング操作は、代替手段として3つのパターンを組み合わせます。</target>
        </trans-unit>
        <trans-unit id="31fc34e986ee3355963fe79a5b72db07365ea4e2" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression (see also &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;):</source>
          <target state="translated">「NaN」や「Infinity」などのIEEE表記を気にしないと仮定すると、おそらく正規表現を使用するだけです（&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;および&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;も参照）。</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">NaN」や「Infinity」のようなIEEE表記を気にしないと仮定すると、正規表現を使いたいだけなのかもしれません。</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">文字セットがASCIIっぽいと仮定して</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">文字セットをASCIIだけと仮定すると</target>
        </trans-unit>
        <trans-unit id="f18b4264a48b77c77d31682d53d915137b1c2a2b" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;&quot;savepv&quot; in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Cライブラリ関数のPerlラッパーの戻り値が指す静的メモリの内容は変更されないと仮定します。多くのCライブラリ関数は、静的ストレージへのポインタを返します。このポインタは、同じ関数または関連する関数への後続の呼び出しによって上書きされる可能性があります。Perlには、これらの関数の一部に軽量のラッパーがあり、静的メモリのコピーを作成しません。良い例は、プログラムで有効な環境変数へのインターフェースです。Perlには &lt;code&gt;PerlEnv_getenv&lt;/code&gt; があります環境から値を取得します。ただし、戻り値はCライブラリの静的メモリへのポインタです。値を使用してすぐに何かをテストする場合は問題ありませんが、値を保存し、後の処理で変更されないことが予想される場合は間違いですが、異なるCライブラリの実装が動作するため、おそらくわかりません。別の方法で、テストしているプラ​​ットフォーム上のものが状況に合っている可能性があります。ただし、一部のプラットフォームでは、 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; または関連する関数を後で呼び出すと、最初の呼び出しが指すメモリが上書きされます。これにより、デバッグが難しい問題が発生しました。やる&lt;a href=&quot;perlapi#savepv&quot;&gt;はperlapiで「savepvを」&lt;/a&gt;コピーを作成して、これらの問題を回避します。メモリリークを回避するために、完了したらコピーを解放する必要があります。いつ解放されるかを制御できない場合は、次のように、致命的なスカラーでコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Cライブラリ関数のPerlラッパーの戻り値が指す静的メモリの内容は変化しないと仮定します。多くのCライブラリ関数は、同じまたは関連する関数への後続の呼び出しで上書きできる静的ストレージへのポインターを返します。 Perlには、これらの関数の一部用の軽量ラッパーがあり、静的メモリのコピーを作成しません。良い例は、プログラムに有効な環境変数へのインターフェースです。 Perlには &lt;code&gt;PerlEnv_getenv&lt;/code&gt; があります環境から値を取得します。ただし、戻り値はCライブラリの静的メモリへのポインタです。値を使用してすぐに何かをテストしている場合は問題ありませんが、値を保存し、後の処理で変更されないことが予想される場合は誤りですが、異なるCライブラリの実装が動作するため、おそらくそれを知らないでしょう。別の方法で、テストしているプラ​​ットフォーム上のものが状況に応じて機能する場合があります。ただし、一部のプラットフォームでは、 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; または関連する関数への後続の呼び出しにより、最初の呼び出しが指すメモリが上書きされます。これにより、デバッグが困難な問題が発生しました。行い&lt;a href=&quot;perlapi#savepv&quot;&gt;はperlapiでsavepvを&lt;/a&gt;コピーを作成して、これらの問題を回避します。完了したら、メモリリークを回避するためにコピーを解放する必要があります。いつ解放されるかを制御できない場合は、次のように、致命的なスカラーでコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">先ほどの例のデータベースを想定しています。</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">これらがPerlの &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; と同様に動作すると想定すると、これらの演算子のオーバーロードされた実装は、それらのオペランドを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="3db726b30f88089aabcbf03ff0837b3e46de1fc1" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">それらがPerlの &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; と同様に動作することを想定すると、これらの演算子のオーバーロードされた実装は、それらのオペランドを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="6c0a71c399dfe91f864d3abd9d93805888be04d4" translate="yes" xml:space="preserve">
          <source>Assuming we are on the branch &lt;code&gt;blead&lt;/code&gt; immediately after a pull, this command would be more or less equivalent to:</source>
          <target state="translated">プルの直後にブランチ &lt;code&gt;blead&lt;/code&gt; にいると仮定すると、このコマンドは多かれ少なかれ次のようになります。</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">クラスProjname::L10Nを呼び出すと仮定して、最小で構成されるクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">良いテストカバレッジを持っていると仮定すると、あなたのテストは依存関係が欠けている状態で失敗し、何かが間違っていることをより強くユーザに知らせるべきです。このような場合には</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">UTF-8文字列を扱っていることがわかっているとすると、 &lt;code&gt;UTF8SKIP&lt;/code&gt; マクロを使用して、その最初の文字の長さがどれくらいであるかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">十分な権限で実行している場合、 &lt;code&gt;date(1)&lt;/code&gt; プログラムを実行することにより、システム全体の日付と時刻を設定できるはずです。（プロセスごとに日時を設定する方法はありません。）このメカニズムは、Unix、MS-DOS、Windows、およびNTで機能します。VMSと同等の &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="02ec0a4ff8284bf3708641e3963c674ad5d28a0e" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set time&lt;/code&gt;.</source>
          <target state="translated">十分な権限で実行していると仮定すると、 &lt;code&gt;date(1)&lt;/code&gt; プログラムを実行することで、システム全体の日付と時刻を設定できるはずです。（プロセスごとに時刻と日付を設定する方法はありません。）このメカニズムは、Unix、MS-DOS、Windows、およびNTで機能します。同等のVMSは &lt;code&gt;set time&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">システムがそのようなことをサポートしていると仮定すると、適切なシグナルをプロセスに送信するだけです（&lt;a href=&quot;functions/kill&quot;&gt;killを&lt;/a&gt;参照）。最初にTERMシグナルを送信し、少し待ってから、KILLシグナルを送信して終了するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="a095cda27752254d76d70e270420e5ff5d39b90c" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">システムがそのようなことをサポートしていると仮定すると、プロセスに適切なシグナルを送信するだけです（&lt;a href=&quot;perlfunc#kill&quot;&gt;perlfuncの「kill」を参照&lt;/a&gt;）。最初にTERMシグナルを送信し、少し待ってから、KILLシグナルを送信して終了するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="489e70109e67cf9da0e282567e7dfa75ecfec0d5" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O.</source>
          <target state="translated">非同期I/O。</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">10:23に、この関数はデータファイルの10行目を生成します。午後3時45分に、代わりに15行目を生成します。デフォルトでは、 &lt;code&gt;Memoize&lt;/code&gt; は$ problem_type引数のみを参照します。これを修正するには、ノーマライザーに現在の時間を含めます。</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">与えられた文字位置では、正規表現のマッチを成功させる最初の選択肢がマッチします。ここでは、すべての選択肢が最初の文字列の位置でマッチするので、最初のものがマッチします。</target>
        </trans-unit>
        <trans-unit id="35d56b3c766a2a7d81a6ef179791e69c5926ffe4" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and don't affect the other parts.</source>
          <target state="translated">いつでも、これらの修飾子のうち正確に 1 つが有効になっています。これらの修飾子の存在により、Perlは実際に実行されたときにどのようなルールが有効であるかに関わらず、正規表現の元々のコンパイルされた動作を維持することができます。また、より大きな正規表現に補間された場合、元のルールが適用され、他の部分には影響を与えません。</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">いつでも、これらの修飾子のうち正確に 1 つが有効になっています。これらの修飾子の存在により、Perl は、実際に実行されたときにどのようなルールが有効であるかにかかわらず、正規表現の元々のコンパイルされた動作を維持することができます。そして、それがより大きな正規表現に補間された場合、元のルールが適用され続け、それだけに適用されます。</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">いずれにしても、Unicode文字に関しては、文字の幅（表意文字の場合は倍幅）や方向（アラビア語とヘブライ語の場合はBIDI）などを考慮する必要があるため、 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 使用には疑問があります。</target>
        </trans-unit>
        <trans-unit id="b3d5fa45c550ce1b12a041713732b9ad3afd79b2" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;format&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">いずれにせよ、Unicode文字に関しては、文字幅（表意文字の場合は倍幅）や方向（アラビア語とヘブライ語の場合はBIDI）などを考慮する必要があるため、 &lt;code&gt;format&lt;/code&gt; 使用自体に疑問があります。</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">デシリアライズ時には、同じLISTが返されますが、余分な参照はすべてデシリアライズされた構造体を指しています。</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">各スタックレベルでは、サブルーチンの名前がそのパラメーターとともに表示されます。単純なスカラーの場合、これで十分です。オブジェクトやその他の参照などの複雑なデータ型の場合、これは単に &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; を表示できます。</target>
        </trans-unit>
        <trans-unit id="d3499c5b318f8c7ae1f2cab230c6e5e96c7a777c" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt;.</source>
          <target state="translated">各スタックレベルで、サブルーチンの名前がそのパラメーターとともに表示されます。単純なスカラーの場合、これで十分です。オブジェクトやその他の参照などの複雑なデータ型の場合、これは単に &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 表示できます。</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; 、 &lt;code&gt;perl_run()&lt;/code&gt; 、 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; などのperlへのエントリポイントで、それぞれが &lt;code&gt;JMPENV_PUSH&lt;/code&gt; を実行し、runopsループなどを入力して、可能な例外の戻りを処理します。2リターンの場合、スタックのポップや &lt;code&gt;CHECK&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; ブロックの呼び出しなど、最終的なクリーンアップが実行されます。とりわけ、これは、 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 時にスコープのクリーンアップが依然として行われる方法です。</target>
        </trans-unit>
        <trans-unit id="2c5843723152f1754465e406a2b90b574561ffc4" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt;, &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt;, then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; 、 &lt;code&gt;perl_run()&lt;/code&gt; 、 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; などのperlへのエントリポイントで、それぞれ &lt;code&gt;JMPENV_PUSH&lt;/code&gt; を実行してから、runopsループなどを入力し、可能な例外リターンを処理します。 2リターンの場合、スタックのポップや &lt;code&gt;CHECK&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; ブロックの呼び出しなど、最終的なクリーンアップが実行されます。とりわけ、これは、 &lt;code&gt;exit&lt;/code&gt; 時にスコープのクリーンアップが引き続き行われる方法です。</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">一見すると、 &lt;code&gt;ddd&lt;/code&gt; がターゲット文字列と一致しないのは明らかであるため、印刷すべきではないと思います。しかし、この例を見てください：</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">少なくともWinNTとの整合性を保つためには、推奨値を守っておくべきです。</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">少なくともUnixでは、プロセスのデータサイズ制限を増やすことでこれを回避できる場合があります。csh/ tcshで &lt;code&gt;limit&lt;/code&gt; と &lt;code&gt;limit datasize n&lt;/code&gt; を制限（ &lt;code&gt;n&lt;/code&gt; はキロバイト数）して、現在の制限を確認して変更し、kshで変更します。 / bash / zshは、それぞれ &lt;code&gt;ulimit -a&lt;/code&gt; と &lt;code&gt;ulimit -d n&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="66f7b8a4f3dad67cd26cb07eaab73c32a3b79d31" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt;, respectively.</source>
          <target state="translated">少なくともUnixでは、プロセスのデータサイズ制限を増やすことでこれを乗り越えることができるかもしれません。csh/ tcshでは &lt;code&gt;limit&lt;/code&gt; と &lt;code&gt;limit datasize n&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; はキロバイト数）を使用して現在の制限を確認して変更し、kshでは/ bash / zshは、それぞれ &lt;code&gt;ulimit -a&lt;/code&gt; と &lt;code&gt;ulimit -d n&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">少なくとも大したことをしていない点では下位互換だと思う。</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; の少なくとも1つに目標があり（ &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; の少なくとも1つがゼロ以外である必要があります）、両方が目標を達成している場合は、両方に到達する必要があります。また、文字の折りたたみが複数の文字である場合は、それらすべてを一致させる必要があります（「折りたたみ」については、下のtr21参照を参照してください）。</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">少なくとも3つの組み込み関数 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; 。考えてみればいつかもっと追加するかもしれません。</target>
        </trans-unit>
        <trans-unit id="36309277752b244d6584b5ffd8f2594deef16e94" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;defined(...)&lt;/code&gt;, &lt;code&gt;exists(...)&lt;/code&gt;, and &lt;code&gt;eof(...)&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">少なくとも3つの組み込み関数 &lt;code&gt;defined(...)&lt;/code&gt; 、 &lt;code&gt;exists(...)&lt;/code&gt; 、および &lt;code&gt;eof(...)&lt;/code&gt; 。考えてみれば、いつかこれらを追加するかもしれません。</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">4行目には、あなたが今どこにいるかを教えてくれる便利なポインタがあります。より多くのコードを見るには、もう一度 'v' と入力してください。</target>
        </trans-unit>
        <trans-unit id="0f8b916c14aa42230cca14b7fbe9aee5db398694" translate="yes" xml:space="preserve">
          <source>At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher, and this code point is higher.</source>
          <target state="translated">一時期は、0x7FFF_FFFFまでのコードポイントを持つことがいくつかの規格では合法でしたが、それ以上のコードポイントを持つことはできず、このコードポイントの方が高くなっています。</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">現時点でのリストは、weaken,isweak,dualvar,isvstring,set_prototypeです。</target>
        </trans-unit>
        <trans-unit id="945b483b1ccbe65e925900ec39e83bbc97a9ab8a" translate="yes" xml:space="preserve">
          <source>At present the following compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">現在 IO::Compress::Zip は以下の圧縮方法をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">現在 IO::Compress::Zip でサポートされている圧縮方法は、Store (全く圧縮しない)、Deflate、Bzip2、LZMA の 3 つです。</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">現在、 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; を使用して％ENVを初めて反復するとき、％ENVを完全に入力するために、すべての論理名が読み取られるため、時間のペナルティが発生します。後続の反復では論理名が再度読み取られないため、処理速度は遅くなりませんが、他のプログラムによる論理名テーブルへの変更は反映されません。</target>
        </trans-unit>
        <trans-unit id="214ce8ba80d0a179d1db87f227b4915a835aed62" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;keys&lt;/code&gt;, or &lt;code&gt;values&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">現在、 &lt;code&gt;keys&lt;/code&gt; または &lt;code&gt;values&lt;/code&gt; を使用して％ENVを初めて反復するときは、％ENVを完全に設定するために、すべての論理名が読み取られるときに時間ペナルティが発生します。後続の反復では論理名が再読み取りされないため、速度は低下しませんが、他のプログラムによって引き起こされた論理名テーブルへの変更も反映されません。</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">実行時には、リストアップされた各プラグインは、この擬似コードと同等のものを実行することで、シングルトンオブジェクトとしてインスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">実行時には</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">いつのまにかビルドされたものが死ぬかもしれません。</target>
        </trans-unit>
        <trans-unit id="fdde3eae592d85a1bbf81dc1dcb5f03f478df9d3" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">2008年にオスロで開催されたQAハッカソンでは、Perlモジュールのツールチェーンのメンテナが、ツールチェーンコンポーネント間で設定後の要件を通信するためにCPAN Metaフォーマットを使用することに合意しました。これらのファイル</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">2008年にオスロで開催されたQAハッカソンでは、Perlモジュールのツールチェーンのメンテナが、ツールチェーンコンポーネント間で設定後の要件を通信するためにCPAN Metaフォーマットを使用することに同意しました。これらのファイル</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">わずかなヘッダのオーバーヘッドのコストで、あなたが使用して、すでにオープンされたファイル記述子に格納することができる &lt;code&gt;store_fd&lt;/code&gt; のルーチンを、を介してファイルから取得 &lt;code&gt;fd_retrieve&lt;/code&gt; 。これらの名前はデフォルトではインポートされないため、これらのルーチンが必要な場合は明示的にインポートする必要があります。指定するファイル記述子は、取得する場合は読み取り用、保存する場合は書き込み用にすでに開いている必要があります。</target>
        </trans-unit>
        <trans-unit id="e5ffbd456858663ac301bf7789eac1b059f62c98" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt;. Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">わずかなヘッダのオーバーヘッドのコストで、あなたが使用して、すでにオープンされたファイル記述子に格納することができる &lt;code&gt;store_fd&lt;/code&gt; のルーチンを、を介してファイルから取得 &lt;code&gt;fd_retrieve&lt;/code&gt; 。これらの名前はデフォルトではインポートされないため、これらのルーチンが必要な場合は明示的にインポートする必要があります。指定するファイル記述子は、取得する場合は読み取り用に、保存する場合は書き込み用に、すでに開いている必要があります。</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">の最後に</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">すべての &lt;code&gt;when&lt;/code&gt; ブロックの最後に、暗黙の &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; があります。最初の一致のみに関心がある場合は、明示的な &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; オーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="1e41ae8e63f613457fbc688a05901eda0e76d2fb" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;next&lt;/code&gt;. You can override that with an explicit &lt;code&gt;last&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">すべての &lt;code&gt;when&lt;/code&gt; ブロックの最後に、暗黙の &lt;code&gt;next&lt;/code&gt; があります。最初の一致のみに関心がある場合は、明示的な &lt;code&gt;last&lt;/code&gt; それをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">解析の最後に &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; を呼び出して、ツリーの最上位ノードを取得します。</target>
        </trans-unit>
        <trans-unit id="7dfefef1d68ca5b408b29dae9e3fff68c7b274a2" translate="yes" xml:space="preserve">
          <source>At the end of the subtest, the final &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event is sent to the formatter.</source>
          <target state="translated">サブテストの最後に、最後の&lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt;イベントがフォーマッターに送信されます。</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">最下層では、マクロ new_SV()と del_SV()が SV のヘッドを取得して解放します。(-DD でデバッグしている場合、del_SV()は関数 S_del_sv()を呼び出して、エラーチェックを行いながら SV をフリーリストに戻します。)new_SV()は more_sv()/sv_add_arena()を呼び出して、フリーリストが空の場合に追加のアリーナを追加します。フリーリストの SV は、SvTYPE フィールドがすべての SV に設定されています。</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">執筆の時点で、AIXは2つの異なるネイティブCコンパイラーをサポートしており、それらを支払う必要があります：&lt;b&gt;xlC&lt;/b&gt;と&lt;b&gt;vac&lt;/b&gt;。これら2つのいずれかを使用する場合（これはgccを使用するよりもはるかに簡単です）、利用可能な最新のパッチレベルにアップグレードしてください。現在：</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">当たり前のことを述べる危険を冒して、モジュールはモジュールであることを意図しています。Perl の開発者は、モジュールを使ってアプリケーションの構成要素を組み立てることができるはずです。しかし、ブロックが正しい形であることが重要であり、開発者が必要とするのは小さなブロックだけなのに、大きなブロックを使う必要はありません。</target>
        </trans-unit>
        <trans-unit id="1014d039b0716d418675db8cd3420cc810aff463" translate="yes" xml:space="preserve">
          <source>At the same time, this pragma cannot detect when such a module has installed from CPAN to the core library, and so it would endlessly and uselessly exhort the user to upgrade.</source>
          <target state="translated">同時に、このpragmaは、そのようなモジュールがCPANからコアライブラリにインストールされたことを検出することができないので、ユーザにアップグレードするように延々と無駄に促すことになります。</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">この記事を書いている時点(2009-03)では、3つのYAML実装が動作しています。YAML,YAML::Syck,そしてYAML::XSです。後者の2つはより高速ですが、システムにCコンパイラをインストールする必要があります。他にもYAMLに準拠したモジュールがあるかもしれません。YAML::Tiny と YAML::Perl を試してみましたが、CPAN.pm で動作させるには十分な性能を持っていませんでした。これはその間に変更されたかもしれません。</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">この記事の執筆時（2002年6月）には、 &quot;e&quot;表記を使用しない場合のロングダブルのTru64 libc印刷に既知のバグがあります。値は正確で使用可能ですが、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; などを使用して問題を強制しない限り、表示される桁数は限られています。Tru64バージョンV5.0AからV5.1Aの場合、perl 5.8.0のリリース後にパッチがリリースされる予定です。libcにパッチがまだ適用されていない場合、長いdoubleを選択すると、Configureから警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="cff077ec447ff4f924a23e0da4a7a4062c468c7a" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">この記事の執筆時点（2002年6月）では、「e」表記を使用しない場合のlongdoubleのTru64libc印刷に既知のバグがあります。値は正しく使用可能ですが、 &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; などを使用して問題を強制しない限り、表示される桁数は限られています。Tru64バージョンV5.0AからV5.1Aの場合、perl5.8.0がリリースされた後のいつかパッチが期待されます。libcにまだパッチが適用されていない場合、long doubleを選択すると、Configureから警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">この記事を書いている時点では、Perl 5.18.0 はそのハッシュ実装に対するアルゴリズムの複雑さに対する攻撃に対して十分に強化されていると考えられています。これは主に、以下のような攻撃を軽減するための対策によるものです。</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">最終的なクリーンアップの際に、Perl_destruct()から sv_free_arenas()が呼び出され、インタープリタの起動時から割り当てられたすべてのアリーナを物理的に解放します。</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">fが作成された時点では、匿名サブルーチンがまだ作成されていないので、現在の &quot;a &quot;サブをキャプチャすることはできません。逆に、匿名サブルーチンは今までに作成されて生きているので、次のような警告は出ません。</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">fが作成された時点では、匿名サブルーチンはまだ作成されていないので、$aの現在の値を捕捉することはできません。逆に、匿名サブルーチンは今までに作成されていて生きているので、次のような警告は出ません。</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">このドキュメントが最後に更新された時点では、Cygwin 1.7.16が最新のものでした。</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">少なくとも、これはSelfLoaderが何をスタブだと考えているのかを確認するのに役立つ。</target>
        </trans-unit>
        <trans-unit id="9d086f75055dc823d417d876f240b4ce1aa5f40a" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass needs to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">少なくとも、サブクラスは独自の &lt;code&gt;new()&lt;/code&gt; を提供する必要があり、オブジェクトに追加のハッシュキーを格納できます。定義する必要のあるパッケージグローバルもいくつかあります。例：</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">最低でも、サブクラスは独自の &lt;code&gt;new()&lt;/code&gt; を提供する必要があり、オブジェクトに追加のハッシュキーを格納できます。定義する必要があるいくつかのパッケージグローバルもあります。例：</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">この時点で、もしあなたが</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">この時点で、基本的な正規表現の概念はすべてカバーしているので、より複雑な正規表現の例を挙げてみましょう。ここでは、数字にマッチする正規表現を作っていきます。</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">この時点では、xsubpp はほとんど仕事をしていません-Mytest.xs と Mytest.c の違いは最小限です。</target>
        </trans-unit>
        <trans-unit id="4cb351d8164d812dc7e335f6aa1c330c2f5b0d24" translate="yes" xml:space="preserve">
          <source>At this time, &lt;code&gt;study&lt;/code&gt; does nothing. This may change in the future.</source>
          <target state="translated">現時点では、 &lt;code&gt;study&lt;/code&gt; は何もしません。これは将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">執筆時点では、 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 値には2つのタイプがあります &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; ようなポッドページの名前（@INC / PATHディレクトリ内の実際のPerlモジュールまたはプログラムであるか、またはそれらの場所の.podファイル）;または &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; ようなUnix manページの名前。理論的には、 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; は、「chmod」と呼ばれるポッドページ、またはUnixのマニュアルページ「chmod」（どのmanセクションでも）のあいまいです。ただし、「crontab（5）」のように、括弧内の文字列の存在は、議論されているものがPodページではなく、おそらくUnixのmanページであることを示すには十分です。区別は多くのポッドプロセッサにとって重要ではありません。しかし、ハイパーテキスト形式にレンダリングする一部のプロセッサは、特定のレンダリング方法を知るためにそれらを区別する必要がある場合があります &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; コード。</target>
        </trans-unit>
        <trans-unit id="1402e155751b829c93df5128b5d19d797691621a" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;. In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">執筆時点では、 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 値には2つのタイプがあります &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; ようなポッドページの名前（@INC / PATHディレクトリ内の実際のPerlモジュールまたはプログラムである可能性があります）、またはそれらの場所の.podファイル）;または、 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; ようなUnixのマニュアルページの名前。理論的には、 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; は、「chmod」と呼ばれるポッドページとUnixのマニュアルページ「chmod」（どのmanセクションでも）の間であいまいです。ただし、「crontab（5）」のように、親に文字列が存在することは、議論されているものがポッドページではなく、おそらくUnixのマニュアルページであることを示すのに十分です。この区別は、多くのポッドプロセッサにとって重要ではありません。しかし、ハイパーテキスト形式にレンダリングする一部のプロセッサは、特定のレンダリング方法を知るためにそれらを区別する必要がある場合があります &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; コード。</target>
        </trans-unit>
        <trans-unit id="24f8d626a483cf6ebf2f3cd6cefe211ee98242ab" translate="yes" xml:space="preserve">
          <source>At time of writing, I don't think you'll need to use this.</source>
          <target state="translated">書いている時点では、これを使う必要はないと思います。</target>
        </trans-unit>
        <trans-unit id="6b127225208f5ac9bbb6a72b48b20b7d3616ff18" translate="yes" xml:space="preserve">
          <source>Atari MiNT</source>
          <target state="translated">アタリミエヌティー</target>
        </trans-unit>
        <trans-unit id="7f3342f30bf4c3977d537b68719b3f6636e25cb1" translate="yes" xml:space="preserve">
          <source>Athena</source>
          <target state="translated">Athena</target>
        </trans-unit>
        <trans-unit id="fb5b8f9948a5df2cd992c1e84448561317bc6a25" translate="yes" xml:space="preserve">
          <source>Atrributes such as package, file, and caller are determined automatically, and cannot be specified.</source>
          <target state="translated">パッケージ、ファイル、呼び出し元などのアトリビュートは自動的に決定され、指定することはできません。</target>
        </trans-unit>
        <trans-unit id="3493cb8763751f88e1926ab01085068e369734c9" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="translated">IDで識別される共有メモリセグメントを呼び出しプロセスのアドレス空間に接続します。&lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat（2）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">IDで識別される共有メモリセグメントを呼び出しプロセスのアドレス空間に接続します。&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmatを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; を配列に接続することは許可されていますが、効果はありません。</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">SASL認証を試みます。</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">SASL 認証を試みます。Authen::SASL モジュールが必要です。</target>
        </trans-unit>
        <trans-unit id="ccd854e11a4d11e3e9e58ceb95944b13ef3a518a" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module. The first form constructs a new Authen::SASL object using the given username and password; the second form uses the given Authen::SASL object.</source>
          <target state="translated">SASL 認証を試みます。Authen::SASL モジュールが必要です。最初のフォームでは、与えられたユーザ名とパスワードを使って新しい Authen::SASL オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="883f5c19fa9ca67ce62c443fd2ce7bac60b6089d" translate="yes" xml:space="preserve">
          <source>Attempt to access disallowed key '%s' in a restricted hash</source>
          <target state="translated">制限されたハッシュ内の許可されていないキー '%s' にアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="5cf0ab65502bfcdd00cde497405332ccea4e648b" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a freed package</source>
          <target state="translated">解放されたパッケージに祝福を試みる</target>
        </trans-unit>
        <trans-unit id="8614ea5fd745bc313cc5245a331edbc4dddec890" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a reference</source>
          <target state="translated">リファレンスに祝福を試みる</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">&lt;code&gt;$dir&lt;/code&gt; 指定されたディレクトリにディレクトリを変更しようとします。場合は &lt;code&gt;$dir&lt;/code&gt; ある &lt;code&gt;&quot;..&quot;&lt;/code&gt; 、FTP &lt;code&gt;CDUP&lt;/code&gt; のコマンドは、1つ上のディレクトリに移動しようとするために使用されます。ディレクトリが指定されていない場合は、ディレクトリをルートディレクトリに変更しようとします。</target>
        </trans-unit>
        <trans-unit id="6f0b75ab4748fe5742f8fdfbfa72a1464729d3b5" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt;. If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt;, the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">ディレクトリを &lt;code&gt;$dir&lt;/code&gt; 指定されたディレクトリに変更してみてください。場合は &lt;code&gt;$dir&lt;/code&gt; ある &lt;code&gt;&quot;..&quot;&lt;/code&gt; 、FTP &lt;code&gt;CDUP&lt;/code&gt; のコマンドは、1つ上のディレクトリに移動しようとするために使用されます。ディレクトリが指定されていない場合は、ディレクトリをルートディレクトリに変更しようとします。</target>
        </trans-unit>
        <trans-unit id="c6aef18d28c95173a99a1a9cd9b174366e83e56c" translate="yes" xml:space="preserve">
          <source>Attempt to clear deleted array</source>
          <target state="translated">削除された配列のクリアを試みる</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">絶対ファイル指定を相対指定に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2c4880c9fdd4f4d9c5b79e2c012fb0e250d383e7" translate="yes" xml:space="preserve">
          <source>Attempt to delete disallowed key '%s' from a restricted hash</source>
          <target state="translated">許可されていないキー '%s' を制限されたハッシュから削除しようとしました。</target>
        </trans-unit>
        <trans-unit id="0798ebadbab9bffb1e99c85507d3edee83caa008" translate="yes" xml:space="preserve">
          <source>Attempt to delete readonly key '%s' from a restricted hash</source>
          <target state="translated">制限されたハッシュから読み取り専用キー '%s' を削除しようとしました。</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">まだ解放されていないすべてのオブジェクトを破壊しようとします。</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">現在のホストのインターネット名とドメインの評価を試みる</target>
        </trans-unit>
        <trans-unit id="80fda9c03868b272773d0d41887e0dbe18413719" translate="yes" xml:space="preserve">
          <source>Attempt to free non-arena SV: 0x%x</source>
          <target state="translated">非アリーナの解放を試みる SV:0x%x</target>
        </trans-unit>
        <trans-unit id="54d38b115a5aa938320799c6531228c69b9fa275" translate="yes" xml:space="preserve">
          <source>Attempt to free nonexistent shared string '%s'%s</source>
          <target state="translated">存在しない共有文字列 '%s'%s を解放しようとしました。</target>
        </trans-unit>
        <trans-unit id="1b479273a362ea2e8c34f077e9e3c6360ab77808" translate="yes" xml:space="preserve">
          <source>Attempt to free temp prematurely: SV 0x%x</source>
          <target state="translated">温度の早期解放を試みた。SV 0x%x</target>
        </trans-unit>
        <trans-unit id="a34a51b6be5af9431919f62ebe158c42fa203ea7" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced glob pointers</source>
          <target state="translated">参照されていないグロブ・ポインタの解放を試みます。</target>
        </trans-unit>
        <trans-unit id="40f310189c328c36df3675b24385fea4a52ffa6b" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced scalar: SV 0x%x</source>
          <target state="translated">参照されていないスカラを解放しようとしました。SV 0x%x</target>
        </trans-unit>
        <trans-unit id="51aff28048c322c0b88140e9c1dcb9278d5b60c1" translate="yes" xml:space="preserve">
          <source>Attempt to pack pointer to temporary value</source>
          <target state="translated">一時的な値へのポインタのパックの試み</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">SIGINT(Ctrl-C)で実行が中断された場合、サマリー情報の印刷を試みます。</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">カラー出力を試みる。</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$length&lt;/code&gt; バイトの非圧縮データを &lt;code&gt;$buffer&lt;/code&gt; に読み取ろうとしました。</target>
        </trans-unit>
        <trans-unit id="09a9c5fb7a8cb670c472dd87151c6343a5662154" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">圧縮されていないデータの &lt;code&gt;$length&lt;/code&gt; バイトを &lt;code&gt;$buffer&lt;/code&gt; 読み込もうとします。</target>
        </trans-unit>
        <trans-unit id="9e9d551547de808708f971d391e53086cf3f44fc" translate="yes" xml:space="preserve">
          <source>Attempt to reload %s aborted.</source>
          <target state="translated">%s のリロードの試みは中止されました。</target>
        </trans-unit>
        <trans-unit id="87c4ceba341469a694caa6a8c164987d97a35645" translate="yes" xml:space="preserve">
          <source>Attempt to set length of freed array</source>
          <target state="translated">解放された配列の長さを設定しようとする</target>
        </trans-unit>
        <trans-unit id="cee621066cdf5eff50fe796c90fc14083ab2dd15" translate="yes" xml:space="preserve">
          <source>Attempt to use reference as lvalue in substr</source>
          <target state="translated">参照を lvalue として使用しようとした場合</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">自分自身から継承しようとすると警告が発生します。</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">特殊な浮動小数点値 &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; （無限大、負で、非数）をパックされた整数値（ &lt;code&gt;&quot;L&quot;&lt;/code&gt; など）にパックしようとすると、致命的なエラーになります。これは、これらの特別な値から整数への適切なマッピングがないためです。</target>
        </trans-unit>
        <trans-unit id="d1f53d7ce9f579730ddb96734ab811ab0bbc0590" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt;) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">特別な浮動小数点値 &lt;code&gt;Inf&lt;/code&gt; および &lt;code&gt;NaN&lt;/code&gt; （無限大、負の値、および非数値）をパックされた整数値（ &lt;code&gt;&quot;L&quot;&lt;/code&gt; ）にパックしようとすると、致命的なエラーになります。この理由は、これらの特別な値の整数への適切なマッピングがまったくないためです。</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">データベースを閉じずに再オープンしようとする。</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">システムのホスト名を取得するいくつかの方法を試み、その結果をキャッシュします。Cライブラリのgethostname（）、 &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; 、uname（2）、 &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;`hostname`&lt;/code&gt; 、 &lt;code&gt;`uname -n`&lt;/code&gt; 、およびファイルの最初に利用可能なものを試します</target>
        </trans-unit>
        <trans-unit id="82ba9728173d7f6ba4ffa539ae706dc3eec02b8f" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt;, uname(2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt;, &lt;code&gt;`uname -n`&lt;/code&gt;, and the file</source>
          <target state="translated">システムのホスト名を取得するいくつかの方法を試みてから、結果をキャッシュします。Cライブラリのgethostname（）、 &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; 、uname（2）、 &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt; 、 &lt;code&gt;`hostname`&lt;/code&gt; 、 &lt;code&gt;`uname -n`&lt;/code&gt; 、およびファイルの最初の使用可能を試行します</target>
        </trans-unit>
        <trans-unit id="5ba76ae4290c1441342a9f4f7bc1b58233fe69fb" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like &lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect(2)&lt;/a&gt;. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect（2）と&lt;/a&gt;同様に、リモートソケットへの接続を試みます。成功した場合はtrueを返し、それ以外の場合はfalseを返します。 NAMEは、ソケットに適切なタイプのパックされたアドレスである必要があります。&lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipcの「ソケット：クライアント/サーバー通信」&lt;/a&gt;の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect（2）と同様に、リモートソケットへの接続を試みます。成功した場合はtrue、それ以外の場合はfalseを返します。 NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。 「&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect（2）と同様に、リモートソケットへの接続を試みます。成功した場合はtrue、それ以外の場合はfalseを返します。 NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。 「&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">としてエンコードされたオクテット列のインプレース変換を試みます。</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">SVのPVを文字からバイトに変換しようとします。 PVにバイトに収まらない文字が含まれている場合、この変換は失敗します。この場合、falseを返すか、 &lt;code&gt;fail_ok&lt;/code&gt; がtrueでない場合はcroaksを返します。</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">指定されたホストがファイアウォールの外にあるかどうかを判定します。返り値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">LENGTHの読み取りを試みます。</target>
        </trans-unit>
        <trans-unit id="c8be1bb9a549008dc0e0461ce94dfbc02a8ed8c1" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt;. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with other kinds of reads, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; can cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; or &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read（2）&lt;/a&gt;を使用して、指定されたFILEHANDLEから変数SCALARにLENGTHバイトのデータを読み取ろうとします。バッファリングされたIOを含むすべての&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;レイヤーをバイパスします（ただし、後で説明するように &lt;code&gt;:utf8&lt;/code&gt; レイヤーの存在によって影響を受けます）。したがって、これを他の種類の読み取り、&lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;と混合すると、混乱が生じる可能性があります &lt;code&gt;:perlio&lt;/code&gt; または &lt;code&gt;:crlf&lt;/code&gt; レイヤーは通常、データをバッファリングします。実際に読み取られたバイト数、ファイルの終わりで &lt;code&gt;0&lt;/code&gt; 、またはエラーが発生した場合はundef（後者の場合は&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; )を&lt;/a&gt;返します。も設定されています）。 SCALARは、実際に読み取られた最後のバイトが読み取られた後のスカラーの最後のバイトになるように拡大または縮小されます。</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read（2）を使用して、指定されたFILEHANDLEからデータのLENGTHバイトを変数SCALARに読み取ろうとします。バッファリングされたIOをバイパスするため、これを他の種類の読み取り、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioまたはstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に読み取られたバイト数、ファイルの終わりでは &lt;code&gt;0&lt;/code&gt; を返します。エラーが発生した場合はundefを返します（後者の場合は &lt;code&gt;$!&lt;/code&gt; も設定されます）。 SCALARは拡大または縮小され、実際に読み取られた最後のバイトは、読み取り後のスカラーの最後のバイトになります。</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read（2）を使用して、指定されたFILEHANDLEからデータのLENGTHバイトを変数SCALARに読み取ろうとします。バッファリングされたIOをバイパスするため、これを他の種類の読み取り、 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioまたはstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に読み取られたバイト数、ファイルの終わりでは &lt;code&gt;0&lt;/code&gt; を返します。エラーが発生した場合はundefを返します（後者の場合は &lt;code&gt;$!&lt;/code&gt; も設定されます）。 SCALARは拡大または縮小され、実際に読み取られた最後のバイトは、読み取り後のスカラーの最後のバイトになります。</target>
        </trans-unit>
        <trans-unit id="1a8348f0c0ac76ec0ef2040ebe72ee4d10ad1e13" translate="yes" xml:space="preserve">
          <source>Attempts to set_hints_for unidentifiable subroutine</source>
          <target state="translated">識別不可能なサブルーチンにヒントを設定しようとしました。</target>
        </trans-unit>
        <trans-unit id="2e09b188ae4a3fab1a81562daadb429ed4fd7f6d" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write(2)&lt;/a&gt;. If LENGTH is not specified, writes whole SCALAR. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with reads (other than &lt;code&gt;sysread)&lt;/code&gt;), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; may cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually written, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; if there was an error (in this case the errno variable &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write（2）&lt;/a&gt;を使用して、変数SCALARから指定されたFILEHANDLEにLENGTHバイトのデータを書き込もうとします。 LENGTHが指定されていない場合、SCALAR全体を書き込みます。バッファリングされたIOを含むすべての&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;レイヤーをバイパスします（ただし、後で説明するように &lt;code&gt;:utf8&lt;/code&gt; レイヤーの存在によって影響を受けます）。したがって、これを読み取り（ &lt;code&gt;sysread)&lt;/code&gt; 以外）、&lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;と混合すると混乱が生じる可能性があります。理由 &lt;code&gt;:perlio&lt;/code&gt; と &lt;code&gt;:crlf&lt;/code&gt; の層は通常、データをバッファリングします。実際に書き込まれたバイト数、または&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; を&lt;/a&gt;返しますエラーが発生した場合（この場合、errno変数&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;も設定されます）。LENGTHがOFFSET後にSCALARで使用可能なデータよりも大きい場合、使用可能なデータだけが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write（2）を使用して、変数SCALARから指定されたFILEHANDLEにLENGTHバイトのデータを書き込もうとします。 LENGTHが指定されていない場合、SCALAR全体を書き込みます。バッファリングされたIOをバイパスするため、これを読み取り（ &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 以外）、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioおよびstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に書き込まれたバイト数を返します。エラーが発生した場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します（この場合、errno変数 &lt;code&gt;$!&lt;/code&gt; も設定されます）。 LENGTHがOFFSET後にSCALARで使用可能なデータよりも大きい場合、使用可能なデータだけが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write（2）を使用して、変数SCALARから指定されたFILEHANDLEにLENGTHバイトのデータを書き込もうとします。 LENGTHが指定されていない場合、SCALAR全体を書き込みます。バッファリングされたIOをバイパスするため、これを読み取り（ &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 以外）、 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioおよびstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に書き込まれたバイト数を返します。エラーが発生した場合は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します（この場合、errno変数 &lt;code&gt;$!&lt;/code&gt; も設定されます）。 LENGTHがOFFSET後にSCALARで使用可能なデータよりも大きい場合、使用可能なデータだけが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">単語の補完を試みます。変更はできません。</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="295826f440604d6a675c4c66d0a324dc4eaca56b" translate="yes" xml:space="preserve">
          <source>Attribute prototype(%s) discards earlier prototype attribute in same sub</source>
          <target state="translated">属性プロトタイプ(%s)は同じサブの以前のプロトタイプ属性を破棄します。</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute::Handlers-属性ハンドラのシンプルな定義</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlersは、データ引数（ &lt;code&gt;$_[4]&lt;/code&gt; ）をハンドラーに渡す前に、使用可能な形式に変換するように努力しています（ただし、&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;非解釈属性ハンドラーを&lt;/a&gt;参照）。これらの取り組みが成功すると、解釈されたデータは配列参照で渡されます。失敗した場合、生データは文字列として渡されます。たとえば、次のすべて：</target>
        </trans-unit>
        <trans-unit id="04790e00da71beac2f86333318faed6cfab890a0" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;Non-interpretive attribute handlers&quot;&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlersは、データ引数（ &lt;code&gt;$_[4]&lt;/code&gt; ）をハンドラーに渡す前に使用可能な形式に変換するために多大な努力を払います（ただし、&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;「非解釈属性ハンドラー」を&lt;/a&gt;参照してください）。これらの取り組みが成功した場合、解釈されたデータは配列参照で渡されます。それらが失敗した場合、生データは文字列として渡されます。たとえば、これらすべて：</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="4ce085fab8976266bb7771327c95a06a2d92883d" translate="yes" xml:space="preserve">
          <source>Attributes :locked and :unique</source>
          <target state="translated">属性 :locked と :unique</target>
        </trans-unit>
        <trans-unit id="57744968c9ece6a6fd393a9a1f9a16852d8d26e2" translate="yes" xml:space="preserve">
          <source>Attributes &lt;code&gt;:locked&lt;/code&gt; and &lt;code&gt;:unique&lt;/code&gt;</source>
          <target state="translated">属性 &lt;code&gt;:locked&lt;/code&gt; および &lt;code&gt;:unique&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f65ce706012d5cc8515dbfba3f0c94b3cae90800" translate="yes" xml:space="preserve">
          <source>Attributes =&amp;gt; $sAttributes</source>
          <target state="translated">属性=&amp;gt; $ sAttributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">属性はオブジェクト自体に格納されることが多いです。例えば、オブジェクトが匿名ハッシュであれば、属性名をキーにしてハッシュに属性値を格納することができます。</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">属性は通常、リードオンリーまたはリードライトとして定義されます。読み取り専用属性はオブジェクトが最初に作成されたときにのみ設定でき、読み書き属性はいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; インターフェースとしての属性</target>
        </trans-unit>
        <trans-unit id="dd541d956cc1115542e113d51d19e51923523667" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;tie&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; インターフェースとしての属性</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">タイインターフェースとしての属性</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">属性は、変数を結びつけるための優れた直感的なインターフェースを提供します。例えば</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性は、一度設定されると、それらが設定解除されるまで（属性 &lt;code&gt;clear&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; を出力して）持続します。これを行うように注意してください。そうしないと、スクリプトの実行が終了した後も属性が残り、人々はプロンプトと入力を奇妙な色に変更することに非常に悩まされます。</target>
        </trans-unit>
        <trans-unit id="8aad82b8fbc6c4c52822cc8ecd0cf935a1127780" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;reset&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性は、一度設定されると、設定が解除されるまで続きます（属性を &lt;code&gt;clear&lt;/code&gt; または &lt;code&gt;reset&lt;/code&gt; て出力することにより）。これを行うように注意してください。そうしないと、スクリプトの実行が完了した後も属性が持続し、プロンプトや入力が奇妙な色に変更されることに非常にイライラします。</target>
        </trans-unit>
        <trans-unit id="d51da1fd65173253fff2051ffdb2fb4742bcd89d" translate="yes" xml:space="preserve">
          <source>Audrey Tang</source>
          <target state="translated">オードリー唐</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">オードリー・タン&amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2cb213ffe5688a539a9e042d127473bf2e3ad45" translate="yes" xml:space="preserve">
          <source>August 2005</source>
          <target state="translated">2005年8月</target>
        </trans-unit>
        <trans-unit id="7b22c9a35903363899da803d503fe897e1743fa7" translate="yes" xml:space="preserve">
          <source>August 23, 2005</source>
          <target state="translated">2005年8月23日</target>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="95786e021d4a315fb9439c8c152d524cf9f59cc3" translate="yes" xml:space="preserve">
          <source>Authen::SASL is required for AUTH support.</source>
          <target state="translated">AUTH サポートには Authen::SASL が必要です。</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">パスワードが &lt;code&gt;PASS&lt;/code&gt; の &lt;code&gt;USER&lt;/code&gt; として識別されるサーバーで認証します。&lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;に似ていますが、パスワードはクリアテキストでは送信されません。</target>
        </trans-unit>
        <trans-unit id="2d308c897b8201e557fb3734cdc42302c1f694dd" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt;. Similar to &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">パスワード &lt;code&gt;PASS&lt;/code&gt; を使用して &lt;code&gt;USER&lt;/code&gt; として識別されるサーバーで認証します。&lt;a href=&quot;#login&quot;&gt;「ログイン」に&lt;/a&gt;似ていますが、パスワードはクリアテキストで送信されません。</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">指定されたユーザー名とパスワードを使用して、(RFC2980 で定義されているオリジナルの AUTHINFO USER/AUTHINFO PASS フォームを使用して)サーバーを認証します。パスワードはクリアテキストでサーバーに送信されることに注意してください。サーバーへの接続が何らかの方法で保護されていない限り、このコマンドは貴重なパスワードと一緒に使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="4be2c3e4a055e66e61888715b3835a0acb5d7f3e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">提供されたユーザー名とパスワードを使用して、サーバーを認証します（RFC2980で定義および非推奨の提案されたNNTP V2 AUTHINFO SIMPLEフォームを使用）。&lt;a href=&quot;#authinfo&quot;&gt;「authinfo」&lt;/a&gt;と同様に、パスワードはクリアテキストで送信されます。</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">提供されたユーザー名とパスワードを使用して、サーバーに認証します（RFC2980で定義され、非推奨のNNTP V2 AUTHINFO SIMPLE形式を使用）&lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt;と同様に、パスワードはクリアテキストで送信されます。</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">認証、セキュリティ、暗号化</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="a250719f5509f4b060ed02cea92bc61a08d442f3" translate="yes" xml:space="preserve">
          <source>Author and Copyright Information</source>
          <target state="translated">著者と著作権情報</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">作者とメンテナー：Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">作者と改造履歴</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">本ソフトウェアの作者は、本製品の適合性、信頼性、編集性、編集性、使用性について何ら主張するものではなく、本製品を使用したことにより生じたいかなる損害についても責任を負うものではありません。あなたがそれを使用することができれば、あなたは幸運ですが、そうでない場合は、私は責任を負うべきではありません。手元にバックアップテープの便利なコピーを置いておきましょう。</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">著者：Mark Jason Dominus、Plover Systems（ &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b0d417f355d7d062d5dedda5f6e9d6e446d1132a" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt;)</source>
          <target state="translated">著者：Mark Jason Dominus、Plover Systems（ &lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">著者はL &amp;lt;...&amp;gt;コードをネストしてはなりません。たとえば、「L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;」はエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">ポッドフォーマッタの作成者は、「= over」...「= back」が出力フォーマットのいくつかの異なる構成にマッピングされる可能性があることに注意してください。たとえば、ポッドを（X）HTMLに変換すると、&amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;、&amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;、&amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt;のいずれかにマップできます、または&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;。同様に、「= item」は&amp;lt;li&amp;gt;または&amp;lt;dt&amp;gt;にマップできます。</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">Podフォーマッタの著者は、この構成に注意すべきである。</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Podフォーマッタ/プロセッサの作者は、独自のPodパーサを書かないように努力すべきです。CPANにはすでにいくつかのインターフェイススタイルを持つものがあり、そのうちの一つであるPod::Parserは最新版のPerlに付属しています。</target>
        </trans-unit>
        <trans-unit id="ee6ba2eca154c452d912ba72284ef9425f5cac4c" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</source>
          <target state="translated">Podフォーマッタ/プロセッサの作者は、独自のPodパーサを書かないように努力すべきです。CPANにはすでにいくつかのインターフェイススタイルを持つものがあり、そのうちの1つであるPod::Simpleは最新バージョンのPerlに対応しています。</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">フォーマッタのサブクラスの作者は、まだトークンを取り出し始めていないパーサオブジェクトを呼び出すのに便利なメソッドを見つけられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。get' マジックと演算子のオーバーロードを処理します。</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。演算子のオーバーロードを扱う。get' マジックの処理をスキップします。</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">オートインクリメントとオートデクリメント</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">SV内の値をオートインクリメントし、必要に応じて文字列から数値への変換を行います。get' マジックと演算子のオーバーロードを処理します。</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。演算子のオーバーロードを扱う。get' マジックの処理をスキップします。</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">AutoLoader-要求に応じてサブルーチンのみをロードします。</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オートローダーは自動splitファイルを見つけることができない（あるいは間違ったものを見つける。）の場合であり &lt;code&gt;@INC&lt;/code&gt; には相対パスが含まれ、&lt;b&gt;そして&lt;/b&gt;プログラムはありません &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4651f865ebaf11dee249fb89b162cf3da62c9078" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="translated">オートローダーは自動splitファイルを見つけることができない（あるいは間違ったものを見つける。）の場合であり &lt;code&gt;@INC&lt;/code&gt; には相対パスが含まれ、&lt;b&gt;そして&lt;/b&gt;プログラムはありません &lt;code&gt;chdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5080d78f65857a5bb4650061f6068b73782d0765" translate="yes" xml:space="preserve">
          <source>AutoLoader vs. SelfLoader</source>
          <target state="translated">オートローダーとセルフローダー</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002より前のAutoLoaderのインターフェースは少し異なりました。&lt;b&gt;AutoLoader&lt;/b&gt;を使用する古いモジュールは、新しい呼び出しスタイルに変更する必要があります。通常、これは単にrequireをuseに変更し、必要に応じて明示的な &lt;code&gt;'AUTOLOAD'&lt;/code&gt; インポートを追加し、&lt;b&gt;@ ISA&lt;/b&gt;から &lt;code&gt;@ISA&lt;/code&gt; を削除することを意味します。</target>
        </trans-unit>
        <trans-unit id="7e1e103fc57cef534d77a1863a7beda04c276011" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt;.</source>
          <target state="translated">Perl 5.002より前のオートローダーは、わずかに異なるインターフェースを持っていました。&lt;b&gt;AutoLoader&lt;/b&gt;を使用する古いモジュールは、新しい呼び出しスタイルに変更する必要があります。通常、これは、requireをuseに変更し、必要に応じて明示的な &lt;code&gt;'AUTOLOAD'&lt;/code&gt; インポートを追加し、&lt;b&gt;@ ISA&lt;/b&gt;から &lt;code&gt;@ISA&lt;/code&gt; を削除することを意味します。</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-オートロードのためにパッケージを分割する</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">定数の自動作成</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodieは単純なカテゴリのセットを使用して、類似の組み込みをグループ化します。カテゴリタイプ（コロンで始まる）を要求すると、そのカテゴリの下にあるすべての組み込みの自動ダイが有効になります。たとえば、 &lt;code&gt;:file&lt;/code&gt; を要求すると、 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; の自動ダイが有効になります。</target>
        </trans-unit>
        <trans-unit id="d86d0ceb4ab6dfa49a2928ed69a6b234345c4271" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;fcntl&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;sysopen&lt;/code&gt;.</source>
          <target state="translated">Autodieは、単純なカテゴリセットを使用して、同様の組み込みをグループ化します。カテゴリタイプ（コロンで始まる）を要求すると、そのカテゴリの下にあるすべてのビルトインの自動ダイが有効になります。たとえば、 &lt;code&gt;:file&lt;/code&gt; を要求すると、 &lt;code&gt;close&lt;/code&gt; 、 &lt;code&gt;fcntl&lt;/code&gt; 、 &lt;code&gt;open&lt;/code&gt; 、および &lt;code&gt;sysopen&lt;/code&gt; の自動ダイが有効になります。</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; が他のエラーでfalseを返す場合、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の自動編集は例外を生成します。</target>
        </trans-unit>
        <trans-unit id="dfa0c806bb2bafe199faa77554873951783b04df" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;flock&lt;/code&gt; will generate an exception if &lt;code&gt;flock&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;flock&lt;/code&gt; 場合に例外が発生します &lt;code&gt;flock&lt;/code&gt; 、他のエラーではfalseを返します。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">オートロードとパッケージ語彙</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">XSUBを使ったオートロード</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">バイナリの自動インストール</target>
        </trans-unit>
        <trans-unit id="e7b3540721074f2b16f8319edcdb7f16ebcac6ca" translate="yes" xml:space="preserve">
          <source>Automatic filehandle closure</source>
          <target state="translated">ファイルハンドルの自動閉鎖</target>
        </trans-unit>
        <trans-unit id="4347ed90164094c8291f74a6e4466cefbf468214" translate="yes" xml:space="preserve">
          <source>Automatic pipe flushing</source>
          <target state="translated">自動パイプフラッシング</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">ヘッダーファイルの関数宣言に基づいてXSUBを自動的に生成します。パッケージ &lt;code&gt;C::Scan&lt;/code&gt; がインストールされているはずです。このオプションが指定されている場合、ヘッダーファイルの名前は &lt;code&gt;NAME1,NAME2&lt;/code&gt; ようになります。この場合、指定された文字列の代わりにNAME1が使用されますが、XSUBはファイルNAME2からインクルードされた宣言に対してのみ発行されます。</target>
        </trans-unit>
        <trans-unit id="5d64745dc0e8fe8b3b6097336c3b9ed3a673cecd" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt;. In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">ヘッダーファイルの関数宣言に基づいてXSUBを自動的に生成します。パッケージ &lt;code&gt;C::Scan&lt;/code&gt; をインストールする必要があります。このオプションを指定すると、ヘッダーファイルの名前は &lt;code&gt;NAME1,NAME2&lt;/code&gt; ようになります。この場合、指定された文字列の代わりにNAME1が使用されますが、XSUBは、ファイルNAME2からインクルードされた宣言に対してのみ発行されます。</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">&lt;b&gt;--help&lt;/b&gt;および&lt;b&gt;-？の&lt;/b&gt;サポートを自動的に提供し&lt;b&gt;ます &lt;/b&gt;アプリケーションがこのオプション自体のハンドラーを指定しなかった場合のオプション。</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">アプリケーションがこのオプション自体のハンドラーを指定しなかった場合、&lt;b&gt;-version&lt;/b&gt;オプションのサポートを自動的に提供します。</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">オートタイは、実際に結び付けられているモジュールで最も一般的に使用され、それらを呼び出すすべてのモジュールに属性をエクスポートする必要があります。これを容易にするために、Attribute :: &lt;code&gt;__CALLER__&lt;/code&gt; は特別な「疑似クラス」-__CALLER__を認識します。これは属性の修飾子として指定できます。</target>
        </trans-unit>
        <trans-unit id="caebe3a78fcebc80600d1c2befdf4f9537e79eaa" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt;, which may be specified as the qualifier of an attribute:</source>
          <target state="translated">自動化は、実際に接続するモジュールで最も一般的に使用され、それらを呼び出すモジュールに属性をエクスポートする必要があります。これを容易にするために、Attribute :: &lt;code&gt;__CALLER__&lt;/code&gt; は特別な「疑似クラス」--__ CALLER__を認識します。これは、属性の修飾子として指定できます。</target>
        </trans-unit>
        <trans-unit id="b404ad26695e85bc7cc28bdc0dded7208f879f3b" translate="yes" xml:space="preserve">
          <source>Autovivification</source>
          <target state="translated">Autovivification</target>
        </trans-unit>
        <trans-unit id="bf3b722c40bbbb50ad0fb62696f5d22f07dbb403" translate="yes" xml:space="preserve">
          <source>AvFILL</source>
          <target state="translated">AvFILL</target>
        </trans-unit>
        <trans-unit id="90bf7946c287adae3d715c64ee31d396014df2f6" translate="yes" xml:space="preserve">
          <source>AvFILLp</source>
          <target state="translated">AvFILLp</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">利用可能なプラグイン</target>
        </trans-unit>
        <trans-unit id="3f5fe2a468e50383b2ee86c82b0cbc98dd7d8c3d" translate="yes" xml:space="preserve">
          <source>Available Since 0.05.</source>
          <target state="translated">0.05から利用可能です。</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">利用可能なサブルーチン</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">利用可能な輸出</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perl 5.8.1以降で使用できます。 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; に設定すると、Perl-5.8.0より前のシグナル動作（即時ですが安全ではありません）が復元されます。 &lt;code&gt;safe&lt;/code&gt; に設定すると、安全な（ただし遅延した）信号が使用されます。&lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipcの遅延信号（安全な信号）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="86ef598431b2f464d3fea7c4a79b483722ad9f02" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;, the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt;, then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perl5.8.1以降で利用できます。 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 設定すると、Perl-5.8.0より前の信号の動作（即時ですが安全ではありません）が復元されます。 &lt;code&gt;safe&lt;/code&gt; に設定すると、safe（ただし遅延）信号が使用されます。&lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;perlipcの「DeferredSignals（SafeSignals）」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">バージョン2.22以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">バージョン2.32以上で利用可能</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">バージョン2.66以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">バージョン2.77以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">バージョン2.99以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">バージョン3.00以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="a51b57f95b46e8e4e842d85639326f6206ff272d" translate="yes" xml:space="preserve">
          <source>Available in version 6.18 and above.</source>
          <target state="translated">バージョン6.18以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="c501834b7b0b901f2df0d6603e7d6136330ca271" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_01 and above.</source>
          <target state="translated">バージョン6.30_01以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="fe2902c53bc06bcbcd50a3060b02d4d1a785d162" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_02 and above.</source>
          <target state="translated">バージョン6.30_02以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">バージョン6.31以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">バージョン6.46以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">バージョン6.48以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="6813343f2b8479035fb49fea7be4fff847bf5d84" translate="yes" xml:space="preserve">
          <source>Available in version 6.51_01 and above.</source>
          <target state="translated">バージョン6.51_01以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">バージョン6.52以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">バージョン6.5503以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="50ef4d62519ad32b490887468033714841e5c394" translate="yes" xml:space="preserve">
          <source>Available in version 6.55_03 and above.</source>
          <target state="translated">バージョン6.55_03以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="b94a4ea271ebeb34f1da9b94033460c66ab594da" translate="yes" xml:space="preserve">
          <source>Available in version 6.57_02 and above.</source>
          <target state="translated">バージョン6.57_02以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">バージョン6.64以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="35008f0927cc370d80fa1feb2cb101b493da804e" translate="yes" xml:space="preserve">
          <source>Available in version 6.7501 and above.</source>
          <target state="translated">バージョン6.7501以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="8a0f8c774f58768a8219ed32fc69bb6c645c818c" translate="yes" xml:space="preserve">
          <source>Available in version 6.8305 and above.</source>
          <target state="translated">バージョン6.8305以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="b1a55162e32a4d313034aeda2facf36c09febf1e" translate="yes" xml:space="preserve">
          <source>Available in version 6.8502 and above.</source>
          <target state="translated">バージョン6.8502以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="3781d883fbe89e1fc4d95fc3c8a343771b42879b" translate="yes" xml:space="preserve">
          <source>Available in version 7.12 and above.</source>
          <target state="translated">バージョン7.12以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">64ビットのOpenVMS 8.2以降で利用可能。(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">ソケットハンドルでのみ使用でき、Winsock APIの &lt;code&gt;ioctlsocket()&lt;/code&gt; 呼び出しと同じように機能します。（Win32）</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">ソケットハンドルのみに対応しています。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">スレッドビルドでのみ使用可能なこの関数は、渡されたstash に &lt;code&gt;PL_stashpad&lt;/code&gt; のエントリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="24db3617e94fd8213371a29596a3d186b94b903d" translate="yes" xml:space="preserve">
          <source>Available since 0.05.</source>
          <target state="translated">0.05から利用可能。</target>
        </trans-unit>
        <trans-unit id="8904628a4cafc1997d22ed36de689160cc550e45" translate="yes" xml:space="preserve">
          <source>Available since 0.14.</source>
          <target state="translated">0.14から利用可能。</target>
        </trans-unit>
        <trans-unit id="47b9977311f14febdb908b3d7c8768e488ba1bdf" translate="yes" xml:space="preserve">
          <source>Available since 0.15.</source>
          <target state="translated">0.15から利用可能。</target>
        </trans-unit>
        <trans-unit id="484973f71a15c235b16dffbc3bc34be0d16c15f0" translate="yes" xml:space="preserve">
          <source>Available since 0.19.</source>
          <target state="translated">0.19から利用可能です。</target>
        </trans-unit>
        <trans-unit id="cf20cba49d40f80adc31be98bf7c874514e9c65b" translate="yes" xml:space="preserve">
          <source>Available since version 1.000020.</source>
          <target state="translated">バージョン1.000020から利用可能。</target>
        </trans-unit>
        <trans-unit id="b4ebee27a76026f487f2506be21a330fd5bb55de" translate="yes" xml:space="preserve">
          <source>Available since version 2.141170.</source>
          <target state="translated">バージョン2.141170から利用可能。</target>
        </trans-unit>
        <trans-unit id="04c0a2e766dbfbf8f4dc8178b6428ab302e4b061" translate="yes" xml:space="preserve">
          <source>Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</source>
          <target state="translated">Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">/usr/ucb/ccを避ける。</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">&lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; を使用しないでください。@ ISA = qw（... Class ...）と &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; すると機能します。</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">条件文での割り当ては避けますが、やむを得ない場合は、「if（a &amp;amp;&amp;amp;（b = c））...」のように余分な括弧を使用します。</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">できればベアワード、特にすべての小文字は避けてください。裸語が関数なのか文字列なのかは見ただけではわかりません。文字列には引用符を使い、関数呼び出しには括弧を使うことで、文字列が混同されることはありません。</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; $ ref eq 'FOO'でない限り、&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot;のようなクラス名テストは避けてください。一般に、 &lt;code&gt;eq 'FOO'&lt;/code&gt; の部分を削除しても問題はありません。オブジェクトに自分自身の世話をさせましょう！一般に、ハードワイヤードなクラス名は可能な限り避けてください。</target>
        </trans-unit>
        <trans-unit id="6c6177d46cc76c5db51cee88fceed0a2c4936349" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt;. Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">&lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt; ようなクラス名テストは避けてください。通常、 &lt;code&gt;eq 'FOO'&lt;/code&gt; 部分はまったく害を及ぼすことなく削除できます。オブジェクトに自分の面倒を見てもらいましょう！一般に、ハードワイヤードのクラス名はできるだけ避けてください。</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">パッケージの中に州の情報を入れないようにしてください。複数の他のパッケージがあなたのパッケージを使うのが難しくなります。状態情報はオブジェクトの中に入れておきましょう。</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">libucbは避けてください。</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">特に、モジュールを配置するのに適した階層が既に存在している場合は、新しいトップレベルの階層を開始しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="e368cb46427a0a7114b3f3aa59a320144f3a18b6" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary quotes and stringification</source>
          <target state="translated">不要な引用符や文字列化を避ける</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">voidコンテキストで、つまり戻り値を破棄するだけの場合は、 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; （または &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ）または `backticks` を使用しないでください。これらの関数はすべて戻り値を持っているので、それらを使用してください。それ以外の場合は、代わりに &lt;code&gt;foreach()&lt;/code&gt; ループまたは &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="4d1b147c04752308a754e45a088f0a5ced1e3189" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;grep()&lt;/code&gt; (or &lt;code&gt;map()&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;system()&lt;/code&gt; function instead.</source>
          <target state="translated">無効なコンテキストで、つまり戻り値を破棄する場合は、 &lt;code&gt;grep()&lt;/code&gt; （または &lt;code&gt;map()&lt;/code&gt; ）または `backticks`を使用しないでください。これらの関数はすべて戻り値を持っているので、それらを使用してください。それ以外の場合は、代わりに &lt;code&gt;foreach()&lt;/code&gt; ループまたは &lt;code&gt;system()&lt;/code&gt; 関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">可能な限り、ハードコード化されたテスト番号の使用は避けてください (t/op/tie.t にある EXPECTED/GOT の方が保守性が高く、より良い故障報告が得られます)。</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">qx//と system()は、それらのテストをしている場合を除いては使用しないでください。それらを使う場合は、_すべての_perlプラットフォームをカバーしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">パイプデッドロックの回避</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">繰り返しを避ける</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">アックトラップ</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="960ee8c49bfa63dfbcee503c121c56c7a1e4101b" translate="yes" xml:space="preserve">
          <source>B *</source>
          <target state="translated">B *</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl コンパイラのバックエンド</target>
        </trans-unit>
        <trans-unit id="66cbfa5966aea2edc7cf64e032e34c46ba4f5e91" translate="yes" xml:space="preserve">
          <source>B line</source>
          <target state="translated">ビーライン</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="19869e35c46a3e66430c519067a6d3e7137c0ed7" translate="yes" xml:space="preserve">
          <source>B. Execution</source>
          <target state="translated">B.実行</target>
        </trans-unit>
        <trans-unit id="f96bf8801b12adefc37c1e7fc962c4790aa5f3c1" translate="yes" xml:space="preserve">
          <source>B. K. Oxley (binkley),</source>
          <target state="translated">B.K・オックスレー(ビンクリー)。</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.UNPACK</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B::AV メソッド</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B::BINOP メソッド</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B::BM メソッド</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B::COP メソッド</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B::CV メソッド</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Concise-Perl のシンタックスツリーを歩き、ops に関する簡潔な情報を表示する</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Debug-Perl のシンタックスツリーを歩き、OPS に関するデバッグ情報を表示する</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Perl コードを生成する Perl コンパイラバックエンド</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Deparse は他の perl プログラムからサブバイサブで使用することもできます。</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparseは、perl自体がプログラムの解析後に作成する内部コンパイル済み構造に基づいて、perlソースコードを生成するPerlコンパイラのバックエンドモジュールです。 B :: Deparseの出力は、perlがコメントや空白を追跡せず、perlの構文構造とコンパイルされた構文の間に1対1の対応がないため、元のソースとまったく同じにはなりません形、しかしそれはしばしば近いでしょう。&lt;b&gt;-p&lt;/b&gt;オプションを使用すると、優先順位で必要ない場合でも出力に括弧が含まれるため、perlが意図したとおりに式を解析しているかどうかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B::GV メソッド</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B::HV メソッド</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B::IO メソッド</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::IO オブジェクトは IO オブジェクトから派生しており、IO オブジェクト自体からより多くの情報を得ることができます。</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B::IV メソッド</target>
        </trans-unit>
        <trans-unit id="f3d775a1d64c4d9d033d742b01a011ef21c3139b" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">B::IV,B::NV,B::PV,B::PVIV,B::PVNV,B::PVMG,B::PVLV,B::AV,B::HV,B::CV,B::GV,B::FM,B::IO.これらのクラスは、類似した名前の基礎となる C の構造体に明白な形で対応しています。継承階層は、基礎となる C の「継承」を模倣しています。</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B::IV、B::NV、B::RV、B::PV、B::PVIV、B::PVNV、B::PVMG、B::BM (5.9.5 以前)、B::PVLV、B::AV、B::HV、B::CV、B::GV、B::FM、B::IO。これらのクラスは、類似した名前の基礎となる C の構造体に明白な形で対応しています。継承階層は、基礎となる C の &quot;継承&quot; を模倣しています。5.10.x ブランチでは、(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B::LISTOPメソッド</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B::LOGOP メソッド</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B::LOOP メソッド</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B::マジックメソッド</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B::METHOP メソッド (Perl 5.22 以降)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B::NV メソッド</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B::OP メソッド</target>
        </trans-unit>
        <trans-unit id="9f43dd0af65c2a7397a364fed7e94a6388954481" translate="yes" xml:space="preserve">
          <source>B::OP::terse</source>
          <target state="translated">B::OP::terse</target>
        </trans-unit>
        <trans-unit id="b8644ca464436a14d88fc7211463f2c65ed97695" translate="yes" xml:space="preserve">
          <source>B::Op_private</source>
          <target state="translated">B::Op_private</target>
        </trans-unit>
        <trans-unit id="67239ea053c2700f5ce63cb3454a4558b2cbf5e7" translate="yes" xml:space="preserve">
          <source>B::Op_private - OP op_private flag definitions</source>
          <target state="translated">B::Op_private-OP op_private フラグ定義</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B::PADLIST メソッド</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B::PADNAME メソッド</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B::PADNAMELIST メソッド</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B::PADOPメソッド</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B::PMOP メソッド</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B::PV メソッド</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B::PVLV メソッド</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B::PVMG メソッド</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B::PVOP メソッド</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B::REGEXP メソッド</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B::RV メソッド</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B::SV メソッド</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B::SVOP メソッド</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-関数やファイルで使用される字句変数を表示する</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Terse-Perl の構文ツリーを歩き、ops についての簡潔な情報を表示する</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B::UNOP メソッド</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B::UNOP_AUX メソッド (5.22 以降)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-Perl プログラムのクロスリファレンスレポートを生成する</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">後方互換性と蔑視</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">バックワード互換性</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">基本的な方法</target>
        </trans-unit>
        <trans-unit id="aa6878b1c31a9420245df1daffb7b223338737a3" translate="yes" xml:space="preserve">
          <source>BBB</source>
          <target state="translated">BBB</target>
        </trans-unit>
        <trans-unit id="a76d28d6a4e36d4447b9f4c252abca9f3cac325b" translate="yes" xml:space="preserve">
          <source>BBEdit and TextWrangler</source>
          <target state="translated">BBEditとTextWrangler</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">モジュールを書き始める前に</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="d94255a33af2a233413bdca7bd8b5cd50ff62d1b" translate="yes" xml:space="preserve">
          <source>BEGIN blocks</source>
          <target state="translated">ビギンブロック</target>
        </trans-unit>
        <trans-unit id="38cb5ebde363f32ca7879125654df658667bbf73" translate="yes" xml:space="preserve">
          <source>BEGIN failed--compilation aborted</source>
          <target state="translated">BEGIN 失敗--コンパイルは中断されました。</target>
        </trans-unit>
        <trans-unit id="70821eae507ac85cc9e07ce2b4ef46d0ec3667a3" translate="yes" xml:space="preserve">
          <source>BEGIN not safe after errors--compilation aborted</source>
          <target state="translated">BEGIN はエラーの後に安全ではない--コンパイルは中断された</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">BEGIN、UNITCHECK、CHECK、INIT、END</target>
        </trans-unit>
        <trans-unit id="ee1ec7cf5d1203d7be37071bc2244af5ad59b465" translate="yes" xml:space="preserve">
          <source>BEHAVIOR HOOKS</source>
          <target state="translated">ビヘイビアフック</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">ベストプラクティス</target>
        </trans-unit>
        <trans-unit id="9971e7204a8b08d861ca7fadb789c6c4fe6817b8" translate="yes" xml:space="preserve">
          <source>BINARY_LOCATION</source>
          <target state="translated">BINARY_LOCATION</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="5d021fda0b6b8ed6bd452bf1168689693b7edba7" translate="yes" xml:space="preserve">
          <source>BINMODE this</source>
          <target state="translated">ビンモード</target>
        </trans-unit>
        <trans-unit id="bf55ddd9725aa1a87e415a1396e069c8d47b25d1" translate="yes" xml:space="preserve">
          <source>BLOCK</source>
          <target state="translated">BLOCK</target>
        </trans-unit>
        <trans-unit id="457d9dafbbea9f5d194f2f920ae5f010432f75b2" translate="yes" xml:space="preserve">
          <source>BLOCKDEV</source>
          <target state="translated">BLOCKDEV</target>
        </trans-unit>
        <trans-unit id="b09c96efee066cc539728b4e2b0f68b4e32a0350" translate="yes" xml:space="preserve">
          <source>BOM as integer when fetched in network byte order</source>
          <target state="translated">ネットワークのバイトオーダーでフェッチされた場合のBOMを整数値として指定します。</target>
        </trans-unit>
        <trans-unit id="73fcc9dd1e6686a3a9e94d9fb16092a9ef3f9ef8" translate="yes" xml:space="preserve">
          <source>BOM_UTF8</source>
          <target state="translated">BOM_UTF8</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = less-&amp;gt; of（FEATURE）</target>
        </trans-unit>
        <trans-unit id="3e4c26e4f6f8343f03e02567a3c22dbf6978ed5f" translate="yes" xml:space="preserve">
          <source>BOTTOM_GV</source>
          <target state="translated">BOTTOM_GV</target>
        </trans-unit>
        <trans-unit id="5538bef04345694943fc69521fc1c479110399bf" translate="yes" xml:space="preserve">
          <source>BOTTOM_NAME</source>
          <target state="translated">BOTTOM_NAME</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">ブラケット表記</target>
        </trans-unit>
        <trans-unit id="17d26d9e28cc4c16fe9b307dc7f0b75e8a9d3b1b" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION SECURITY</source>
          <target state="translated">ブラケット表記の安全性</target>
        </trans-unit>
        <trans-unit id="c25e7baf0562de8891b5c53dde5e9d802f4a0b6e" translate="yes" xml:space="preserve">
          <source>BREAKOUT_AT</source>
          <target state="translated">BREAKOUT_AT</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIXはシバン表記（ &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ）をサポートしていないため、代わりに次の行を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="900c916101719763ca728f26535d16592b2fec22" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt;), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIXはshebang表記（ &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ）をサポートしていないため、代わりに次の行を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f442b9234477d8def500a9840cec8cff9ed97e5a" translate="yes" xml:space="preserve">
          <source>BSD</source>
          <target state="translated">BSD</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">BSD::Resource on Solaris</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">BSD::Resource のバージョン 1.09 より前のバージョンは、Proc::ProcessTable と同じ理由で、perl 5.6.0 以降の Solaris 上ではコンパイルできません。1.09 以降の BSD::Resource バージョンでは、この問題を回避できるようになっています。</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">ところで。一度だけプログラムを実行時間の50%高速化したのに、一ヶ月後にまた同じことをするように要求されるのを見て、マネージャーからの圧力にも注意してください(実話)-たとえPerlプログラマであっても、あなたが人間であることを指摘する必要があります。</target>
        </trans-unit>
        <trans-unit id="78253234498ab9f80f071ee0cf6c83a489538d17" translate="yes" xml:space="preserve">
          <source>BUFFERED VS UNBUFFERED (OR STREAMED)</source>
          <target state="translated">バッファード VS アンバッファード (またはストリーミング)</target>
        </trans-unit>
        <trans-unit id="f95da7d5f97af571f044d5a433d68877d16ba4a5" translate="yes" xml:space="preserve">
          <source>BUFFERS</source>
          <target state="translated">BUFFERS</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
