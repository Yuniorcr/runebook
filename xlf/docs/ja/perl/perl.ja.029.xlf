<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="95121980b89b7a9fb796f03c8d74599823515afb" translate="yes" xml:space="preserve">
          <source>In general, there's no need to worry about the order of calls. They will be left-to-right, breadth-first, most-derived-first. This works perfectly for most inherited methods (including destructors), but is inappropriate for some kinds of methods (such as constructors, cloners, debuggers, and initializers) where it's more appropriate that the least-derived methods be called first (as more-derived methods may rely on the behaviour of their &quot;ancestors&quot;). In that case, instead of using the &lt;code&gt;EVERY&lt;/code&gt; pseudo-class:</source>
          <target state="translated">一般に、呼び出しの順序を気にする必要はありません。それらは、左から右、幅優先、最も派生優先です。これは、ほとんどの継承されたメソッド（デストラクタを含む）には完全に機能しますが、最小派生メソッドを最初に呼び出すことがより適切である（コンストラクタ、クローン、デバッガ、初期化子などの）ある種のメソッドには不適切です。メソッドは「祖先」の動作に依存する場合があります）。その場合、 &lt;code&gt;EVERY&lt;/code&gt; 疑似クラスを使用する代わりに：</target>
        </trans-unit>
        <trans-unit id="294f7f9dd3d63c6c658291241c38389ef5522490" translate="yes" xml:space="preserve">
          <source>In general, though, it's best to use the &lt;code&gt;Sv*V&lt;/code&gt; macros.</source>
          <target state="translated">ただし、一般的には、 &lt;code&gt;Sv*V&lt;/code&gt; マクロを使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="aabaf80efaeb23cca024ae206403fa19e6f8a255" translate="yes" xml:space="preserve">
          <source>In general, with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, more detailed information will be available in the exit status for DCL scripts or other native VMS tools, and will give the expected information for Posix programs. It has not been made the default in order to preserve backward compatibility.</source>
          <target state="translated">一般に、 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; を有効にすると、DCLスクリプトまたは他のネイティブVMSツールの終了ステータスでより詳細な情報が利用可能になり、Posixプログラムに期待される情報が提供されます。下位互換性を維持するために、デフォルトにはなりません。</target>
        </trans-unit>
        <trans-unit id="d941c018a8912081ee9a18eaddf237ed10e20a20" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;How can I make my Perl program run faster?&lt;/a&gt;).</source>
          <target state="translated">通常、これはできません。ただし、状況によってはうまくいく場合があります。人々は通常、ソースコードを提供せずに作品を配布したいため、この質問をします。ほとんどのソリューションは、ディスク容量を便宜上トレードオフしています。ほとんどのソリューションでは、Perlインタープリターが最終製品にバンドルされているだけなので、速度の大幅な向上は見られないでしょう（ただし&lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;、Perlプログラムをより高速に実行するに&lt;/a&gt;はどうすればよいですか？を参照）。</target>
        </trans-unit>
        <trans-unit id="a9eadd2908a4639d8decf9b9f18aef810c6f9990" translate="yes" xml:space="preserve">
          <source>In general, you don't &quot;declare&quot; a structure. Just use a (probably anonymous) hash reference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; for details. Here's an example:</source>
          <target state="translated">一般に、構造体を「宣言」することはありません。（おそらく匿名の）ハッシュ参照を使用するだけです。詳細については、&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;および&lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;を参照してください。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="7f00c5d5b02fc95d1502392b2b9783083f707dee" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">受信者がカラー対応のディスプレイデバイスを持っているかどうかわからないため、一般的にはそうではありません。彼らが色を理解するANSI端末を持っていることがわかっている場合は、CPANの&lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="2f87cb8b42da40e06ddcf5b3026af1eac6aa3d5a" translate="yes" xml:space="preserve">
          <source>In general, you either have to know what you're dealing with, or you have to guess. The API function &lt;code&gt;is_utf8_string&lt;/code&gt; can help; it'll tell you if a string contains only valid UTF-8 characters, and the chances of a non-UTF-8 string looking like valid UTF-8 become very small very quickly with increasing string length. On a character-by-character basis, &lt;code&gt;isUTF8_CHAR&lt;/code&gt; will tell you whether the current character in a string is valid UTF-8.</source>
          <target state="translated">一般的には、自分が何を扱っているかを知る必要があるか、推測する必要があります。API関数 &lt;code&gt;is_utf8_string&lt;/code&gt; が役立ちます。文字列に有効なUTF-8文字のみが含まれているかどうかがわかります。また、UTF-8以外の文字列が有効なUTF-8のように見える可能性は、文字列の長さが増えると非常に速くなります。 &lt;code&gt;isUTF8_CHAR&lt;/code&gt; は、文字ごとに、文字列内の現在の文字が有効なUTF-8かどうかを通知します。</target>
        </trans-unit>
        <trans-unit id="26ea48aedd1cf988ca4c353ab67e2113694ba714" translate="yes" xml:space="preserve">
          <source>In human terms, it's a funny way of passing arguments to a subroutine when you define it as well as when you call it. It's useful for setting up little bits of code to run later, such as callbacks. You can even do object-oriented stuff with it, though Perl already provides a different mechanism to do that--see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">人間の言葉で言えば、これは、サブルーチンを定義するとき、および呼び出すときに、引数をサブルーチンに渡す面白い方法です。コールバックなど、後で実行するコードを少し設定するのに役立ちます。Perlはそれを行うための別のメカニズムをすでに提供していますが、オブジェクト指向のものを使用することもできます&lt;a href=&quot;perlobj&quot;&gt;-perlobjを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6ba4c53f21b8779523425f16e680264ebae0decb" translate="yes" xml:space="preserve">
          <source>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that named sequence, and certain characters should match a sequence of multiple characters use under caseless &lt;code&gt;/i&lt;/code&gt; matching. Following those rules could lead to highly confusing situations:</source>
          <target state="translated">逆角かっこで囲まれた文字クラスでは、Perlは通常、名前付きシーケンスと言うUnicodeルールを無視します。特定の文字は、大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; 一致で使用される複数の文字のシーケンスと一致する必要があります。これらのルールに従うと、非常に混乱する状況につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="60a70875c03150cbfc8e14e2cc2dec49ecd50454" translate="yes" xml:space="preserve">
          <source>In its most basic usage, &lt;code&gt;ok(...)&lt;/code&gt; simply takes a single scalar expression. If its value is true, the test passes; if false, the test fails. Examples:</source>
          <target state="translated">最も基本的な使用法では、 &lt;code&gt;ok(...)&lt;/code&gt; は単純に単一のスカラー式を取ります。その値がtrueの場合、テストは成功します。falseの場合、テストは失敗します。例：</target>
        </trans-unit>
        <trans-unit id="4d817298c353371e9d0b73c75cf1950195e64063" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;cond_wait&lt;/code&gt; takes a shared, &lt;b&gt;unlocked&lt;/b&gt; variable followed by a shared, &lt;b&gt;locked&lt;/b&gt; variable. The second variable is unlocked and thread execution suspended until another thread signals the first variable.</source>
          <target state="translated">2番目の形式では、 &lt;code&gt;cond_wait&lt;/code&gt; は共有の&lt;b&gt;ロックさ&lt;/b&gt;れてい&lt;b&gt;ない&lt;/b&gt;変数を受け取り、その後に共有の&lt;b&gt;ロックさ&lt;/b&gt;れた変数が続きます。2番目の変数はロック解除され、別のスレッドが最初の変数に信号を送るまでスレッドの実行が中断されます。</target>
        </trans-unit>
        <trans-unit id="4c9702efe584ddf3df38f0a305879394e6c945fd" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;cond_timedwait&lt;/code&gt; takes a &lt;b&gt;locked&lt;/b&gt; variable and an absolute timeout in</source>
          <target state="translated">2つの引数の形式では、 &lt;code&gt;cond_timedwait&lt;/code&gt; は&lt;b&gt;ロックされた&lt;/b&gt;変数と絶対タイムアウトを受け取ります</target>
        </trans-unit>
        <trans-unit id="fbaa31119043f388b0d536e0c6af6beff83b01ef" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; compares the two scalar values to see if they match. They match if both are undefined, or if</source>
          <target state="translated">2つの引数の形式では、 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; は2つのスカラー値を比較して、それらが一致するかどうかを確認します。両方が定義されていない場合、または</target>
        </trans-unit>
        <trans-unit id="278b05f5c861132c7f4bc86f277c1645adbbdf57" translate="yes" xml:space="preserve">
          <source>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</source>
          <target state="translated">壮大な言い方をすれば、最初の仕事は、パターンをコンピュータが効率的に文字列の中から一致するポイントを見つけるために使えるものに変えることであり、次の仕事は検索そのものを行うことです。</target>
        </trans-unit>
        <trans-unit id="f53ef23dfb1a32e84061a4ee3198583f6963d3be" translate="yes" xml:space="preserve">
          <source>In line 7, we make sure that the SV will have enough room to accommodate the old string, the new string and the null terminator. If &lt;code&gt;LEN&lt;/code&gt; isn't big enough, &lt;code&gt;SvGROW&lt;/code&gt; will reallocate space for us.</source>
          <target state="translated">7行目では、SVに古い文字列、新しい文字列、およびnullターミネーターを収容するのに十分なスペースがあることを確認します。 &lt;code&gt;LEN&lt;/code&gt; が十分に大きくない場合、 &lt;code&gt;SvGROW&lt;/code&gt; はスペースを再割り当てします。</target>
        </trans-unit>
        <trans-unit id="6338eafb38b19e3533d3d49a05621b9aaa4f97d8" translate="yes" xml:space="preserve">
          <source>In line mode, &lt;code&gt;filter_read&lt;/code&gt; will append the next source line to the end of the &lt;code&gt;$_&lt;/code&gt; scalar.</source>
          <target state="translated">行モードでは、 &lt;code&gt;filter_read&lt;/code&gt; は次のソース行を &lt;code&gt;$_&lt;/code&gt; スカラーの最後に追加します。</target>
        </trans-unit>
        <trans-unit id="a450e27bd36ea332e7d75f6381cc8a12782b5b7a" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , like so:</source>
          <target state="translated">リストコンテキスト（これは通常必要なものです）では、関数は、ユーザーが出力を受け入れると思われる言語を（最初に）どの言語で表すかを表す（おそらく空の）言語タグのリストを返します。おそらく、この出力を &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; または &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; ように：</target>
        </trans-unit>
        <trans-unit id="239ff52c002bacbd9ef8a650976d52e44cb1392b" translate="yes" xml:space="preserve">
          <source>In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.</source>
          <target state="translated">リストコンテキストでは、パターンを含む最初の要素と、パターンがコンパイルされたときに使用された修飾子を含む2つの要素のリストを返します。</target>
        </trans-unit>
        <trans-unit id="a8954af69f3e9417a81eb4843c66328678eb290e" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;//g&lt;/code&gt; は一致したグループのリストを返します。グループがない場合は、正規表現全体との一致のリストを返します。そう</target>
        </trans-unit>
        <trans-unit id="4a59e7f9e300ced2156a7bfdcb5c2ed656175ffd" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;//g&lt;/code&gt; は一致したグループのリストを返します。グループがない場合は、正規表現全体との一致のリストを返します。したがって、単語だけが必要な場合は、</target>
        </trans-unit>
        <trans-unit id="ce23af9639d689001f6ad6f1b438efaee509bdfe" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;extract_delimited&lt;/code&gt; returns a array of three elements, the extracted substring (</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;extract_delimited&lt;/code&gt; は3つの要素の配列、抽出された部分文字列（</target>
        </trans-unit>
        <trans-unit id="85fefe43cf3ce99aee8bf62db2fc923ea0e22144" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt; . So we could rewrite it as</source>
          <target state="translated">リストのコンテキストでは、グループとの &lt;code&gt;/regex/&lt;/code&gt; の一致は、一致した値のリスト &lt;code&gt;($1,$2,...)&lt;/code&gt; を返します。したがって、次のように書き直すことができます</target>
        </trans-unit>
        <trans-unit id="c008355e8673133191ef9e0d9724c780f81e596e" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned.</source>
          <target state="translated">リストコンテキストでは、残り時間と間隔の両方が返されます。</target>
        </trans-unit>
        <trans-unit id="4ff8ef7b7f3933511d227abc0760c6958871615f" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt; .</source>
          <target state="translated">リストのコンテキストでは、残り時間と間隔の両方が返されます。間隔は常に、 &lt;code&gt;setitimer()&lt;/code&gt; を使用して入力したものです。</target>
        </trans-unit>
        <trans-unit id="1f52db4aa7cef4591f6ad21954e80ef3d1ce4ff3" translate="yes" xml:space="preserve">
          <source>In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.</source>
          <target state="translated">リストのコンテキストでは、2 番目のパラメータを指定して TRUE を評価した場合は連想配列を返します。連想配列のキーは BTREE でマッチした値に対応し、配列の値はその値が BTREE で何回出現したかを表したものとなります。</target>
        </trans-unit>
        <trans-unit id="611c9c24bc1f7655268ae0a922a1bafe9f75484e" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt; . Note that the values will be returned in an apparently random order.</source>
          <target state="translated">リストのコンテキストでは、 &lt;code&gt;$key&lt;/code&gt; 一致するすべての値を返します。値は明らかにランダムな順序で返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b9e8a08a17d7e9ccb66ceef8551ab60c5578a3cb" translate="yes" xml:space="preserve">
          <source>In list context, it's just the list argument separator, and inserts both its arguments into the list. These arguments are also evaluated from left to right.</source>
          <target state="translated">リストコンテキストでは、リストの引数の区切り文字に過ぎず、その両方の引数をリストに挿入します。これらの引数も左から右に評価されます。</target>
        </trans-unit>
        <trans-unit id="d53a53afd4d30e8bf9ee4f38d18899b7c7ca7c4f" translate="yes" xml:space="preserve">
          <source>In list context, returns a (possibly empty) list of filename expansions on the value of EXPR such as the standard Unix shell</source>
          <target state="translated">リストコンテキストでは、標準的な Unix シェルのような EXPR の値に対するファイル名展開の (おそらく空の)リストを返します。</target>
        </trans-unit>
        <trans-unit id="6f4ce95673df56dca54efc694ff26b54d19e3c4c" translate="yes" xml:space="preserve">
          <source>In list context, returns a list consisting of all the values of the named hash. In Perl 5.12 or later only, will also return a list of the values of an array; prior to that release, attempting to use an array argument will produce a syntax error. In scalar context, returns the number of values.</source>
          <target state="translated">リストコンテキストでは、指定されたハッシュのすべての値からなるリストを返します。Perl 5.12以降では、配列の値のリストを返します。それ以前のリリースでは、配列の引数を使おうとすると構文エラーが発生します。スカラコンテキストでは、値の数を返します。</target>
        </trans-unit>
        <trans-unit id="7bcc561bb33b529c7d0fa7662daf305595924e45" translate="yes" xml:space="preserve">
          <source>In list context, returns a list value consisting of the elements of LIST in the opposite order. In scalar context, concatenates the elements of LIST and returns a string value with all characters in the opposite order.</source>
          <target state="translated">リストコンテキストでは、LISTの要素を逆順に連結したリスト値を返す。スカラコンテキストでは、LISTの要素を連結し、全ての文字を逆順に並べた文字列値を返します。</target>
        </trans-unit>
        <trans-unit id="8b48751518b742e90690dec941b028dbd41c2485" translate="yes" xml:space="preserve">
          <source>In list context, returns the value or values deleted, or the last such element in scalar context. The return list's length always matches that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions.</source>
          <target state="translated">リストコンテキストでは、削除された値や値、スカラコンテキストでは最後に削除された要素を返します。戻り値リストの長さは、常に引数リストの長さと一致します:存在しない要素を削除すると、対応する位置にある未定義の値が返されます。</target>
        </trans-unit>
        <trans-unit id="14dda5a0315cd38b494f1396d6549e05a88ce769" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">リストのコンテキストでは、これはリストをソートし、ソートされたリストの値を返します。スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="c275967193060ed0f99b2fe8baeb485ea49b9b81" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">リストのコンテキストでは、これはリストをソートし、ソートされたリストの値を返します。スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="f04d016b9064bf9bf9d2d6da3b96e6acf6fd1521" translate="yes" xml:space="preserve">
          <source>In literal patterns, the code is parsed at the same time as the surrounding code. While within the pattern, control is passed temporarily back to the perl parser, until the logically-balancing closing brace is encountered. This is similar to the way that an array index expression in a literal string is handled, for example</source>
          <target state="translated">リテラルパターンでは、コードは周囲のコードと同時に解析されます。パターン内では、論理的にバランスのとれた終了波括弧が見つかるまで、制御は一時的にperlパーサに戻されます。これは、リテラル文字列の配列インデックス式が処理される方法に似ています。</target>
        </trans-unit>
        <trans-unit id="1a35afb8085f46becc13477af444009e4d377a40" translate="yes" xml:space="preserve">
          <source>In many cases, methods that are used to set the internal state of the object will return the object itself, so method calls can be conveniently chained together.</source>
          <target state="translated">多くの場合、オブジェクトの内部状態を設定するために使用されるメソッドは、オブジェクト自体を返すことになるので、メソッドの呼び出しは便利に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="e9b8eb0a3ccf1ee1e198f508015d1976e62c80e9" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, sysopen() fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">多くのシステムでは、ファイルを排他モードで開くために &lt;code&gt;O_EXCL&lt;/code&gt; フラグを使用できます。これはロックではあり&lt;b&gt;ません&lt;/b&gt;。排他性とは、ファイルがすでに存在する場合、sysopen（）が失敗することを意味します。 &lt;code&gt;O_EXCL&lt;/code&gt; はネットワークファイルシステムでは機能しない可能性があり、 &lt;code&gt;O_CREAT&lt;/code&gt; フラグも設定されていない場合は効果がありません。 &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; を設定すると、ファイルがシンボリックリンクの場合、ファイルが開かれなくなります。ファイルのパスにあるシンボリックリンクからは保護されません。</target>
        </trans-unit>
        <trans-unit id="8450d241305d74878facdc73fccc0a1c6ea4d3de" translate="yes" xml:space="preserve">
          <source>In module</source>
          <target state="translated">モジュール内</target>
        </trans-unit>
        <trans-unit id="286bdc943117014c33efb93a016a5d1869678221" translate="yes" xml:space="preserve">
          <source>In module filtering context, it can be used as Perl version filter.</source>
          <target state="translated">モジュールフィルタリングのコンテキストでは、Perl のバージョンフィルタとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="a173a70aa245271ccb4f943a053fd8f7539c03d6" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , and &lt;code&gt;OUTPUT&lt;/code&gt; . An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">より実用的な用語では、typemapはC関数のパラメーターと値をPerlの値にマップするために&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーによって使用されるコードフラグメントのコレクションです。タイプマップファイルは、 &lt;code&gt;TYPEMAP&lt;/code&gt; 、 &lt;code&gt;INPUT&lt;/code&gt; 、および &lt;code&gt;OUTPUT&lt;/code&gt; というラベルの付いた3つのセクションで構成されます。ラベルのない最初のセクションは、 &lt;code&gt;TYPEMAP&lt;/code&gt; セクションであると見なされます。 INPUTセクションは、Perl値を特定のCタイプの変数に変換する方法をコンパイラーに指示します。 OUTPUTセクションは、特定のC型の値をPerlが理解できる値に変換する方法をコンパイラーに指示します。 TYPEMAPセクションは、特定のCタイプをPerl値にマップするために使用する必要があるINPUTおよびOUTPUTコードフラグメントをコンパイラーに指示します。セクションは &lt;code&gt;TYPEMAP&lt;/code&gt; とラベル付けします、 &lt;code&gt;INPUT&lt;/code&gt; 、または &lt;code&gt;OUTPUT&lt;/code&gt; は、それ自体が行の最初の列から始まり、大文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="428ffc575a57b1bff79640b48a60fb8f688d9deb" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for xs based extensions.</source>
          <target state="translated">ほとんどの場合、人々はシステムの/bin/makeプログラムよりもGNU makeの方が良い結果が得られると報告しています。</target>
        </trans-unit>
        <trans-unit id="f5afec4e8618986f557789f84e21b385879c2564" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &quot;binmode&quot; before you pass it as argument to the addfile() method.</source>
          <target state="translated">ほとんどの場合、$io_handle を addfile()メソッドの引数に渡す前に、$io_handle が &quot;binmode&quot; であることを確認したいと思います。</target>
        </trans-unit>
        <trans-unit id="c59025c8c8f5462c9fb0d9eec8118a96c3e872c2" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">ほとんどの場合、addfile（）メソッドに引数として渡す前に、$ io_handleが &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="525f40bb529483f51193d29f821ebe7da0a52cf3" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt; , which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt; , but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt; . Generally speaking, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; はドキュメント化されていないシステムサービス &lt;code&gt;$SIGPRC&lt;/code&gt; を介して実装されます。これは、 &lt;code&gt;$FORCEX&lt;/code&gt; と同じ呼び出しシーケンスを持っていますが、強制的に &lt;code&gt;$EXIT&lt;/code&gt; を呼び出すのではなく、ターゲットプロセスで例外をスローします。一般的に、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; はCRTLの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 関数の動作に従いますが、その関数とは異なり、シグナルハンドラー内から呼び出すことができます。また、CRTLの一部のバージョンの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; とは異なり、Perlの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; は渡された信号の有効性をチェックし、認識されない信号を送信しようとするのではなく、エラーを返します。</target>
        </trans-unit>
        <trans-unit id="eede988897716aa1422cf3adeb53444b2cab13f0" translate="yes" xml:space="preserve">
          <source>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</source>
          <target state="translated">ほとんどの場合、単純に文字列の連結を使用した方が簡単でしょう。</target>
        </trans-unit>
        <trans-unit id="ace8b1ddef61865f0aa48c02a6d220e56f6740dd" translate="yes" xml:space="preserve">
          <source>In most cases, patches to modules in</source>
          <target state="translated">ほとんどの場合</target>
        </trans-unit>
        <trans-unit id="3d608639121073b361e23e425be9ba9c84646ab9" translate="yes" xml:space="preserve">
          <source>In most cases, you can just run it interactively from a command line without any special arguments and follow the prompts.</source>
          <target state="translated">ほとんどの場合、特別な引数なしでコマンドラインから対話的に実行し、プロンプトに従うだけです。</target>
        </trans-unit>
        <trans-unit id="2f1846566ce8422fbda676e86cc15846d05061a2" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;#round()&quot;&gt;round()&lt;/a&gt;, &lt;a href=&quot;#bround()&quot;&gt;bround()&lt;/a&gt; or &lt;a href=&quot;#bfround()&quot;&gt;bfround()&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">ほとんどの場合、おそらくround &lt;a href=&quot;#round()&quot;&gt;（）&lt;/a&gt;、&lt;a href=&quot;#bround()&quot;&gt;bround（）、&lt;/a&gt;または&lt;a href=&quot;#bfround()&quot;&gt;bfround（）の&lt;/a&gt;いずれかを使用して明示的に結果を丸めるか、必要な精度を追加パラメーターとして数学演算に渡します。</target>
        </trans-unit>
        <trans-unit id="fbf91aec7f60195ab2e4c16d72de4bd0b0dad318" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;bigint#round()&quot;&gt;round() in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;bigint#bround()&quot;&gt;bround() in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;bigint#bfround()&quot;&gt;bfround() in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;bigint#round()&quot;&gt;Math :: &lt;/a&gt;&lt;a href=&quot;bigint#bround()&quot;&gt;BigIntのround（）、Math :: &lt;/a&gt;&lt;a href=&quot;bigint#bfround()&quot;&gt;BigIntのbround（）、&lt;/a&gt;またはMath :: BigIntのbfround（）のいずれかを使用するか、必要な精度を数学演算に渡して、結果を明示的に丸める必要があります。追加パラメーターとして：</target>
        </trans-unit>
        <trans-unit id="a42b298f707283d45326f409618401d12bc90d6e" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt;, you can use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">ほとんどの場合、それを行うための外部モジュールを作成します。「CとPerlのリンクについてどこで学べますか？[h2xs、xsubpp]」への回答を参照してください。ただし、関数がシステムコールであり、システムが &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt; をサポートしている場合は、 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 関数（&lt;a href=&quot;perlfunc&quot;&gt;perlfuncに記載&lt;/a&gt;）を使用できます。</target>
        </trans-unit>
        <trans-unit id="d19f51a558abe46dfdc218b96bc734b3c276b079" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt; , one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt; , Mac OS uses &lt;code&gt;\015&lt;/code&gt; , and z/OS uses &lt;code&gt;\025&lt;/code&gt; .</source>
          <target state="translated">ほとんどのオペレーティングシステムでは、ファイルの行は改行で終了します。改行として使用されるものは、OSによって異なる場合があります。Unixは伝統的に &lt;code&gt;\012&lt;/code&gt; 使用し、DOSish I / Oの1つのタイプは &lt;code&gt;\015\012&lt;/code&gt; 使用し、Mac OSは &lt;code&gt;\015&lt;/code&gt; 使用し、z / OSは &lt;code&gt;\025&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="59c4293bfbaf72968d51c71aab642ca2822c9579" translate="yes" xml:space="preserve">
          <source>In multithreaded scripts Perl coordinates the threads so that any thread may modify its copy of the &lt;code&gt;$0&lt;/code&gt; and the change becomes visible to ps(1) (assuming the operating system plays along). Note that the view of &lt;code&gt;$0&lt;/code&gt; the other threads have will not change since they have their own copies of it.</source>
          <target state="translated">マルチスレッドスクリプトでは、Perlはスレッドを調整して、どのスレッドも &lt;code&gt;$0&lt;/code&gt; コピーを変更し、その変更をps（1）で認識できるようにします（オペレーティングシステムが動作している場合）。他のスレッドが持っている &lt;code&gt;$0&lt;/code&gt; のビューは、独自のコピーを持っているので変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2ff5aa25fe59ffebaa3d9b983e6ed41dcfbb4c10" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that either advertises a &lt;b&gt;service&lt;/b&gt; or just hangs around at a known location and waits for &lt;b&gt;clients&lt;/b&gt; who need service to get in touch with it.</source>
          <target state="translated">ネットワーキングでは、&lt;b&gt;プロセスは、&lt;/b&gt;どちらかがアドバタイズする&lt;b&gt;サービス&lt;/b&gt;のためか、既知の場所に周りだけでハングアップして待機&lt;b&gt;クライアント&lt;/b&gt;それとの接触を取得するサービスを必要としています。</target>
        </trans-unit>
        <trans-unit id="fe020f31c58d30517974e8b54ebe9cc4a8fb1397" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that initiates contact with a &lt;b&gt;server&lt;/b&gt; process in order to exchange data and perhaps receive a service.</source>
          <target state="translated">ネットワーキングにおいて、データを交換し、場合によってはサービスを受けるために、&lt;b&gt;サーバー&lt;/b&gt;プロセスとの&lt;b&gt;接続&lt;/b&gt;を開始する&lt;b&gt;プロセス&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7faa009c2918d4804b660feca8b23ad35925a6e" translate="yes" xml:space="preserve">
          <source>In networking, an agreed-upon way of sending messages back and forth so that neither correspondent will get too confused.</source>
          <target state="translated">ネットワークでは、通信相手があまり混乱しないように、メッセージを前後に送信する合意された方法。</target>
        </trans-unit>
        <trans-unit id="71b3fd1615492dc9bf230d9f033afbf83da86082" translate="yes" xml:space="preserve">
          <source>In normal &amp;ldquo;computerese&amp;rdquo;, the piece of data of the size most efficiently handled by your computer, typically 32 bits or so, give or take a few powers of 2. In Perl culture, it more often refers to an alphanumeric &lt;b&gt;identifier&lt;/b&gt; (including underscores), or to a string of nonwhitespace &lt;b&gt;characters&lt;/b&gt; bounded by whitespace or string boundaries.</source>
          <target state="translated">通常の「コンピューター」では、コンピューターで最も効率的に処理されるサイズのデータ​​（通常32ビット程度）は、2のべき乗を与えるか、または取ります。Perlカルチャでは、英数字の&lt;b&gt;識別子&lt;/b&gt;（アンダースコアを含む）を参照することが多い）、または空白以外の文字列に&lt;b&gt;文字&lt;/b&gt;空白や文字列の境界線で囲まれました。</target>
        </trans-unit>
        <trans-unit id="2b1437a6901ce1f87cee7f4d6385fbba76b51c73" translate="yes" xml:space="preserve">
          <source>In object-oriented code, we often find that one object references another object. This is called &lt;b&gt;composition&lt;/b&gt;, or a &lt;b&gt;has-a&lt;/b&gt; relationship.</source>
          <target state="translated">オブジェクト指向のコードでは、あるオブジェクトが別のオブジェクトを参照していることがよくあります。これは呼ばれる&lt;b&gt;構成&lt;/b&gt;、あるいは&lt;b&gt;持ってい-&lt;/b&gt;関係を。</target>
        </trans-unit>
        <trans-unit id="0840885f4ae0e15a9e1a64e6e2f2e63bb6055bf6" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">昔は、実際のインデックス（電話帳など）で&lt;b&gt;キー&lt;/b&gt;を検索する行為。しかし、今では、インデックスが含まれていなくても、対応する&lt;b&gt;値&lt;/b&gt;を見つけるためにあらゆる種類のキーまたは位置を使用する行為にすぎません。Perlの &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 関数は、ある文字列の位置（インデックス）を別の文字列に配置するだけであるという点まで、状況は悪化しています。</target>
        </trans-unit>
        <trans-unit id="8954164487b10a1a06bdaedbfbaa22faf258c328" translate="yes" xml:space="preserve">
          <source>In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see</source>
          <target state="translated">古い Unicode バージョンでは、少数の文字 (発見された限りではすべて日中韓互換表意文字です)が誤った分解マッピングを持つ可能性があります (参照)。</target>
        </trans-unit>
        <trans-unit id="25564a5fe1398dbc91939b7e3cb0a5bccfb1e2c1" translate="yes" xml:space="preserve">
          <source>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not &quot;characters&quot;, so converting &quot;data&quot; into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</source>
          <target state="translated">エンコーディングは文字のためのものであり、バイナリデータは「文字」ではないので、「データ」を何らかのエンコーディングに変換することは、バイナリデータがどのような文字セットで、どのようなエンコーディングになっているかがわからなければ意味がありません。</target>
        </trans-unit>
        <trans-unit id="0665aadb9203e48ab11fdbdc61f426bdf069c8ef" translate="yes" xml:space="preserve">
          <source>In one's own MANIFEST.SKIP file, certain directives can be used to include the contents of other MANIFEST.SKIP files. At present two such directives are recognized.</source>
          <target state="translated">自分自身のMANIFEST.SKIPファイルでは、他のMANIFEST.SKIPファイルの内容を含めるために、あるディレクティブを使うことができます。現在のところ、そのような二つのディレクティブが認識されています。</target>
        </trans-unit>
        <trans-unit id="775d518fe37c14b3f79041d34b5efaca033dd3ab" translate="yes" xml:space="preserve">
          <source>In one-liner form:</source>
          <target state="translated">ワンライナー形式で。</target>
        </trans-unit>
        <trans-unit id="3a599813be17001915e0601602237bd798d15d3b" translate="yes" xml:space="preserve">
          <source>In one-shot mode this flag will be set to true if the Perl &lt;code&gt;-T&lt;/code&gt; operator thinks the file contains text.</source>
          <target state="translated">ワンショットモードでは、Perl &lt;code&gt;-T&lt;/code&gt; オペレーターがファイルにテキストが含まれていると見なした場合、このフラグはtrueに設定されます。</target>
        </trans-unit>
        <trans-unit id="0a387689b89f7b0ad51aa990a4b2c214ffa94375" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt; ). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;SYNOPSIS in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">メソッドがまだ定義されていない場合でも、オブジェクトメソッドのルックアップやプロトタイプチェックが正しく機能するためには、各サブルーチンを &quot;前方宣言&quot;する必要があります（ &lt;code&gt;sub NAME;&lt;/code&gt; ）。&lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsubのSYNOPSISを&lt;/a&gt;参照してください。このような前方宣言は、コードのないプレースホルダーである「サブルーチンスタブ」を作成します。</target>
        </trans-unit>
        <trans-unit id="f0241ec9af4c551ca21dc35ad3b6791e44a33543" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use a plug-in library for core math routines. Any module which conforms to the API can be used by Math::BigInt by using this in your program:</source>
          <target state="translated">複数のビッグ整数ライブラリを使用できるようにするために、Math::BigInt はコアの数学ルーチンのためのプラグインライブラリを使用するように書き換えられました。API に準拠したモジュールであれば、これをプログラムで使用することで Math::BigInt で使用することができます。</target>
        </trans-unit>
        <trans-unit id="db68f3a19f1d4b1da9de666e4465352494a86e3b" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use library modules for core math routines. Any module which follows the same API as this can be used instead by using the following:</source>
          <target state="translated">複数のビッグ整数ライブラリを使用できるようにするために、Math::BigInt はコアの数学ルーチンにライブラリモジュールを使用するように書き換えられました。これと同じAPIに従ったモジュールであれば、以下のようにして代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="79f9d107daff2d5afbf356c8809d8a77ed4fb993" translate="yes" xml:space="preserve">
          <source>In order to build your own version of Perl you will need 'make', which is part of Apple's developer tools - also known as Xcode. From Mac OS X 10.7 &quot;Lion&quot; onwards, it can be downloaded separately as the 'Command Line Tools' bundle directly from &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; (you will need a free account to log in), or as a part of the Xcode suite, freely available at the App Store. Xcode is a pretty big app, so unless you already have it or really want it, you are advised to get the 'Command Line Tools' bundle separately from the link above. If you want to do it from within Xcode, go to Xcode -&amp;gt; Preferences -&amp;gt; Downloads and select the 'Command Line Tools' option.</source>
          <target state="translated">独自のバージョンのPerlをビルドするには、「make」が必要です。これは、Appleの開発者ツールの一部であり、Xcodeとしても知られています。 Mac OS X 10.7 &quot;Lion&quot;以降、&lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https：//developer.apple.com/downloads/&lt;/a&gt;から直接「コマンドラインツール」バンドルとして個別にダウンロードできます（ログインするには無料のアカウントが必要です）、またはXcodeスイートの一部として、App Storeから無料で入手できます。 Xcodeはかなり大きなアプリであるため、既に持っている場合や本当に必要な場合を除き、上記のリンクとは別に「コマンドラインツール」バンドルを入手することをお勧めします。 Xcode内から実行する場合は、Xcode-&amp;gt; Preferences-&amp;gt; Downloadsに移動して、[Command Line Tools]オプションを選択します。</target>
        </trans-unit>
        <trans-unit id="a93cd8781d8e041e8355a0aefc4276597d7a98e8" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">文字列をある文字セットから別の文字セットに変換するには、上記の表の右側の列にあるような、Perlの &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 演算子とともに単純な数値のリストを使用するだけです。表のデータはASCII / Latin1の順序になっているため、EBCDIC列は使いやすいASCII / Latin1からEBCDICへの操作を提供し、これらも簡単に逆転できます。</target>
        </trans-unit>
        <trans-unit id="2f5fa67b20e8cfe8e347f59bf69babb07bc272aa" translate="yes" xml:space="preserve">
          <source>In order to install a new regexp handler, &lt;code&gt;$^H{regcomp}&lt;/code&gt; is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the &lt;code&gt;comp&lt;/code&gt; method is executed, and the resulting &lt;code&gt;regexp&lt;/code&gt; structure's engine field is expected to point back at the same structure.</source>
          <target state="translated">新しい正規表現ハンドラーをインストールするために、 &lt;code&gt;$^H{regcomp}&lt;/code&gt; は整数に設定されます（適切にキャストされた場合）これらの構造の1つに解決されます。コンパイル時に &lt;code&gt;comp&lt;/code&gt; メソッドが実行され、結果の &lt;code&gt;regexp&lt;/code&gt; 構造体のengineフィールドが同じ構造体を指すことが期待されます。</target>
        </trans-unit>
        <trans-unit id="437d80cea54e562ec941100e6a72df58383866f9" translate="yes" xml:space="preserve">
          <source>In order to keep lib.pm small and simple, it only works with Unix filepaths. This doesn't mean it only works on Unix, but non-Unix users must first translate their file paths to Unix conventions.</source>
          <target state="translated">lib.pm を小さくシンプルに保つために、Unix のファイルパスでのみ動作します。これは Unix でのみ動作するという意味ではありませんが、Unix 以外のユーザはまずファイルパスを Unix の規約に翻訳しなければなりません。</target>
        </trans-unit>
        <trans-unit id="364bb5f6d99dcae74466742fdf303cf213f25184" translate="yes" xml:space="preserve">
          <source>In order to maintain maximum compatibility with earlier versions of Perl, this function will return either the floating point notation or the multiple dotted notation, depending on whether the original version contained 1 or more dots, respectively.</source>
          <target state="translated">以前のバージョンのPerlとの互換性を最大限に維持するために、この関数は、元のバージョンがそれぞれ1つ以上のドットを含むかどうかに応じて、浮動小数点記法または複数のドット記法のいずれかを返します。</target>
        </trans-unit>
        <trans-unit id="381ea4e1bb108f2a93fb8d7c5edae34da5e15c66" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">古いバージョンのMakeMakerで属性の移植性を維持するために、 &lt;code&gt;Makefile.PL&lt;/code&gt; で&lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt;を使用することができます。</target>
        </trans-unit>
        <trans-unit id="9248f937d9955a6043a592d635bc82f1867f0186" translate="yes" xml:space="preserve">
          <source>In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</source>
          <target state="translated">RECNOをPerlとの互換性を高めるために、すべてのRECNO配列の配列オフセットは、Berkeley DBのように1ではなく0から始まります。</target>
        </trans-unit>
        <trans-unit id="c8f50d2afd74c2c616567dbb29c3d95a6bbbba68" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">攻撃キーセットを生成するためのシードを知ることを不可能にするために、このシードはプロセスの開始時にランダムに初期化されます。これは、PERL_HASH_SEED環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;。perlrunのPERL_HASH_SEEDを&lt;/a&gt;参照してください。アイテムが実際にそれらを介して提示されているか、いない保存されているどのようにこの環境変数のコントロール &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1eda6692f2f4e28d3303c1b91852403d3cf17be" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">MAKETEXTの意味を理解し、そのすべてのコンポーネントを組み合わせるどのように、あなたはおそらく読んで行くべきために&lt;a href=&quot;maketext/tpj13&quot;&gt;TPJ13 ::ロケールを:: MAKETEXT&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="5ff6fc777d96f10921d74c27d5ed5e70b4334507" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt; , does just that.</source>
          <target state="translated">rot13フィルターを使用するには、ソースファイルをrot13形式でエンコードする方法が必要です。以下のスクリプト &lt;code&gt;mkrot13&lt;/code&gt; は、まさにそれを行います。</target>
        </trans-unit>
        <trans-unit id="21d2fc600dcdd5c6cb297e557194c37b7f0f485a" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt; below.</source>
          <target state="translated">下位互換性を維持するために、プラグマ&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;使用機能「unicode_strings」&lt;/a&gt;が指定されていない限り、Perlは完全な内部Unicodeサポートをオンにしません。（ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 以降を&lt;a href=&quot;functions/use&quot;&gt;使用している&lt;/a&gt;場合、これは自動的に選択されます。）これを怠ると、予期しない驚きが発生する可能性があります。下記&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;のUnicodeバグを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fd47550c4a48b602de1804d810fabdd19f1a7062" translate="yes" xml:space="preserve">
          <source>In order to process interior sequences, subclasses implementations of this method will probably want to invoke either &lt;b&gt;interpolate()&lt;/b&gt; or &lt;b&gt;parse_text()&lt;/b&gt;, passing it the text block &lt;code&gt;$text&lt;/code&gt; , and the corresponding line number in &lt;code&gt;$line_num&lt;/code&gt; , and then perform any desired processing upon the returned result.</source>
          <target state="translated">内部シーケンスを処理するために、このメソッドのサブクラス実装は、おそらく&lt;b&gt;interpolate（）&lt;/b&gt;または&lt;b&gt;parse_text（）の&lt;/b&gt;いずれかを呼び出し、&lt;b&gt;それに&lt;/b&gt;テキストブロック &lt;code&gt;$text&lt;/code&gt; と &lt;code&gt;$line_num&lt;/code&gt; 対応する行番号を渡し、必要な処理を実行する必要があります。返された結果。</target>
        </trans-unit>
        <trans-unit id="96a9bbcaad8032f3708be9f9aad29a52e4a152b3" translate="yes" xml:space="preserve">
          <source>In order to test that our extension works, we now need to look at the file Mytest.t. This file is set up to imitate the same kind of testing structure that Perl itself has. Within the test script, you perform a number of tests to confirm the behavior of the extension, printing &quot;ok&quot; when the test is correct, &quot;not ok&quot; when it is not.</source>
          <target state="translated">このファイルは、Perl自身が持っているのと同じようなテスト構造を模倣するように設定されています。テストスクリプトの中で、拡張機能の動作を確認するためにいくつかのテストを実行し、テストが正しい場合は「OK」、正しくない場合は「OKではない」と表示します。</target>
        </trans-unit>
        <trans-unit id="e8108d3bcd39eeb2141d68d5707c2daf6f01568e" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for details.</source>
          <target state="translated">Perlオブジェクトを理解するには、まずPerlでの参照を理解する必要があります。詳細は&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="769d36508232140bd94018f22812d43183fa9db1" translate="yes" xml:space="preserve">
          <source>In order to use &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD subroutine you</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt;のAUTOLOADサブルーチンを使用するには、</target>
        </trans-unit>
        <trans-unit id="af99082b46921b802ae95263001ef07cb7aa2040" translate="yes" xml:space="preserve">
          <source>In ordinary paragraphs and in some command paragraphs, various formatting codes (a.k.a. &quot;interior sequences&quot;) can be used:</source>
          <target state="translated">通常の段落や一部のコマンド段落では、様々な書式コード(別名「内部シーケンス」)を使用することができます。</target>
        </trans-unit>
        <trans-unit id="de5a0be2abf85a22324ace726b3f113f3ddb049b" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">他のブールコンテキストでは、明示的に &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; テストまたは比較なしの &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; warningsプラグマまたは&lt;b&gt;-w&lt;/b&gt;コマンドラインスイッチ（ &lt;code&gt;$^W&lt;/code&gt; 変数）が有効な場合に警告を出します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="633c40ae3272eb641ed90a2b64f933bcfc1ab4fa" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. That will happen on the p5p list.</source>
          <target state="translated">他のケースでは、パッチはより多くの作業や議論を必要とするでしょう。それはp5pリストで行われます。</target>
        </trans-unit>
        <trans-unit id="7b3796099c87e59fc24644465a4e8f63a8bac8d4" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; を使用したい他のファイル：</target>
        </trans-unit>
        <trans-unit id="3b8bb595443598bbfebd43734b72b246e5109db8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:</source>
          <target state="translated">あなたのモジュールを使用したい他のファイルでは、モジュールをロードしてシンボルをインポートするための3つの基本的な方法があります。</target>
        </trans-unit>
        <trans-unit id="dac5b44cbcccec7c46874f1c0dae34c3e4179f83" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt; 's class hierarchy that resulted in the original call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">言い換えると、 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; への呼び出しは、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; への元の呼び出しをもたらした &lt;code&gt;$self&lt;/code&gt; のクラス階層の深さ優先、左から右への検索を再開します。</target>
        </trans-unit>
        <trans-unit id="4828bb0cda42f406a7ca05570f3e0910c8f19571" translate="yes" xml:space="preserve">
          <source>In other words, each type of bracket specified as a delimiter must be balanced and correctly nested within the substring, and any other kind of (&quot;non-delimiter&quot;) bracket in the substring is ignored.</source>
          <target state="translated">言い換えれば、デリミタとして指定された各タイプの括弧は、バランスが取れていて、部分文字列の中に正しく入れ子になっていなければならず、部分文字列の中にある他の種類の括弧(「デリミタではない」)は無視されなければなりません。</target>
        </trans-unit>
        <trans-unit id="74fd5671e652ca312e8092bc1ce538f5b223a43a" translate="yes" xml:space="preserve">
          <source>In other words, if you try this:</source>
          <target state="translated">つまり、これをやってみると</target>
        </trans-unit>
        <trans-unit id="877ca893c0d0ee5563d6603bca839b1fc7617192" translate="yes" xml:space="preserve">
          <source>In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.</source>
          <target state="translated">言い換えれば、 implicate_supers_strictly は文字列のリスト(言語タグと推定され、言語タグでない文字列は無視されます)を受け取り、与えられたリスト全体の後に、与えられたすべてのタグの超従属形を挿入し、入力リストに既に現れているタグを除外します。</target>
        </trans-unit>
        <trans-unit id="25d319aebdebcd5625f4059cfe98447477589bac" translate="yes" xml:space="preserve">
          <source>In other words, in the &quot;C&quot; (or English) locale the above will probably print something like:</source>
          <target state="translated">つまり、&quot;C&quot; (または英語)のロケールでは、上記はおそらく次のように表示されるでしょう。</target>
        </trans-unit>
        <trans-unit id="550ff39ed161b9edd0e84b02fed3dec9d30c2e67" translate="yes" xml:space="preserve">
          <source>In other words, it does not check the full recursion stack.</source>
          <target state="translated">つまり、完全な再帰スタックをチェックしません。</target>
        </trans-unit>
        <trans-unit id="e0fc4bff9ab6a124fdea1a036cef443002eab13f" translate="yes" xml:space="preserve">
          <source>In other words, it takes this:</source>
          <target state="translated">つまり、これが必要なのです。</target>
        </trans-unit>
        <trans-unit id="9c65668195992fe68f06679feb8eacf4cd2f8800" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">言い換えると、コードポイントが64の大文字でxorされた文字です。 &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; は127であるため、ASCIIプラットフォームではDELETE です。 &lt;code&gt;&quot;@&quot;&lt;/code&gt; の ord は64であるため、 &lt;code&gt;\c@&lt;/code&gt; はNULL です。</target>
        </trans-unit>
        <trans-unit id="2b7ead3432ce6ef0a214c631da3fb65f28ad59d4" translate="yes" xml:space="preserve">
          <source>In other words, it's the projection of the vector onto the</source>
          <target state="translated">言い換えれば、ベクトルの</target>
        </trans-unit>
        <trans-unit id="173982625284de4ecdaf57b42d11dd41503a3a62" translate="yes" xml:space="preserve">
          <source>In other words, once the &lt;code&gt;(*COMMIT)&lt;/code&gt; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</source>
          <target state="translated">つまり、 &lt;code&gt;(*COMMIT)&lt;/code&gt; が入力され、パターンが一致しない場合、正規表現エンジンは残りの文字列に対してそれ以上の一致を試みません。</target>
        </trans-unit>
        <trans-unit id="080def995649dc7c78c927509a6265da0f050d82" translate="yes" xml:space="preserve">
          <source>In other words, text outside bracket groups is turned into string literals. Text in brackets is rather more complex, and currently follows these rules:</source>
          <target state="translated">言い換えれば、大括弧グループの外のテキストは文字列リテラルに変換されます。大括弧内のテキストはより複雑で、現在はこれらのルールに従っています。</target>
        </trans-unit>
        <trans-unit id="f68e3679fc5753d52f8311d0156c23ac089d43c6" translate="yes" xml:space="preserve">
          <source>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&amp;lt;use strict;&amp;gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&amp;lt;...&amp;gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</source>
          <target state="translated">つまり、「head1」のポッド処理ハンドラは、「C &amp;lt;use strict;&amp;gt;を覚えていますか？」にも同じ処理を適用します。通常の段落（つまり、「C &amp;lt;...&amp;gt;」のようなフォーマットコード）が解析され、おそらく適切にフォーマットされ、リテラルスペースやタブの形式の空白は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="d0443748797b84576038c7f78a4ac322e4d4dc07" translate="yes" xml:space="preserve">
          <source>In other words, the author of a module should be considered to have final say on modifications to their module whenever possible (bearing in mind that it's expected that everyone involved will work together and arrive at reasonable compromises when there are disagreements).</source>
          <target state="translated">言い換えれば、モジュールの作成者は、可能な限りモジュールの修正について最終的な意見を持つべきであると考えられています (関係者全員が協力し、意見の相違があった場合には合理的な妥協点に到達することが期待されていることを念頭に置いてください)。</target>
        </trans-unit>
        <trans-unit id="585a94d48c61cb81b39fc84dfe81f19ca97413b7" translate="yes" xml:space="preserve">
          <source>In other words, the implementation of &lt;code&gt;extract_tagged&lt;/code&gt; is exactly equivalent to:</source>
          <target state="translated">言い換えると、 &lt;code&gt;extract_tagged&lt;/code&gt; の実装は次とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="6437ac2d46829a1156ddedffd3475d352ba0e256" translate="yes" xml:space="preserve">
          <source>In other words, the previous example, would become:</source>
          <target state="translated">つまり、先ほどの例では、こうなります。</target>
        </trans-unit>
        <trans-unit id="bb35ba757de61444a9e16187e2167074637a80ae" translate="yes" xml:space="preserve">
          <source>In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions: &lt;code&gt;/^$/&lt;/code&gt; matches only if you're at the beginning of the line AND the end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar. &lt;code&gt;/ab/&lt;/code&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.</source>
          <target state="translated">言い換えれば、2つのゼロ幅アサーションは、お互いの仕事の隣に、彼らはあなたが使用したいと同じように、一緒にAND演算しているかのように任意のビルトインアサーション： &lt;code&gt;/^$/&lt;/code&gt; あなたが最初にしている場合にのみマッチ行と行の終わりを同時に。より深い根本的な真実は、垂直バーを使用して明示的なORを書く場合を除いて、正規表現の並列は常にANDを意味するということです。 &lt;code&gt;/ab/&lt;/code&gt; は、「a」と一致することを意味し、「a」は「b」と一致しますが、「a」は幅がゼロのアサーションではなく、幅が1つのアサーションであるため、異なる位置で一致が試みられます。</target>
        </trans-unit>
        <trans-unit id="459d5640fff6f70049a1cb4e21dd9d95f811c50c" translate="yes" xml:space="preserve">
          <source>In other words, this is valid:</source>
          <target state="translated">つまり、これは有効です。</target>
        </trans-unit>
        <trans-unit id="b1e37082db8f86fab9970e0f78a995b4a26a2a25" translate="yes" xml:space="preserve">
          <source>In other words, you can write:</source>
          <target state="translated">つまり、書けばいいのです。</target>
        </trans-unit>
        <trans-unit id="760e520ac926fbcbcf184f0f289efd734964ab6f" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use binmode() on binary data, like images, for example.</source>
          <target state="translated">言い換えれば、プラットフォームに関係なく、例えば画像のようなバイナリデータではbinmode()を使用してください。</target>
        </trans-unit>
        <trans-unit id="9c34e83f6eab1310b3613a944eb5e27cd7e611dd" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt; , change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt; . Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt; ) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">言い換えれば、交換する &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; することにより &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 、削除 &lt;code&gt;DynaLoader&lt;/code&gt; やから &lt;code&gt;@ISA&lt;/code&gt; 、変更の &lt;code&gt;bootstrap&lt;/code&gt; によって &lt;code&gt;XSLoader::load&lt;/code&gt; 。 &lt;code&gt;XSLoader::load&lt;/code&gt; 行でパッケージの名前を引用し、引数（上記の &lt;code&gt;$VERSION&lt;/code&gt; ）の前にコンマ（ &lt;code&gt;,&lt;/code&gt; ）を追加することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="cc33d1c173d87ad8a862029ec4420d308b38832f" translate="yes" xml:space="preserve">
          <source>In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions. It then sets the &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; arrays and the &lt;code&gt;$VERSION&lt;/code&gt; scalar; finally it tells perl to bootstrap the module. Perl will call its dynamic loader routine (if there is one) and load the shared library.</source>
          <target state="translated">私たちのケースでは、Mytest.pmはperlにExporterおよびDynamic Loader拡張機能が必要になることを伝えています。その後、設定し &lt;code&gt;@ISA&lt;/code&gt; と &lt;code&gt;@EXPORT&lt;/code&gt; 配列と &lt;code&gt;$VERSION&lt;/code&gt; スカラを、最後に、perlにモジュールをブートストラップするように指示します。Perlは、動的ローダールーチン（存在する場合）を呼び出し、共有ライブラリをロードします。</target>
        </trans-unit>
        <trans-unit id="92b4893cf24b728e0fae1966639d9078e63fc3f7" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; :</source>
          <target state="translated">この例では、 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; によって参照される基礎となるハッシュで &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; を呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="bc1f779d9a34032474fc9a65f77cb8d2776cbce1" translate="yes" xml:space="preserve">
          <source>In our example we're going to create a shouting handle.</source>
          <target state="translated">この例では、シャウトハンドルを作成します。</target>
        </trans-unit>
        <trans-unit id="a13dbabebbc5437dccc50e5be8ddf3c33a642ee8" translate="yes" xml:space="preserve">
          <source>In our example, 'undef' is really an element containing &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces. Observe:</source>
          <target state="translated">この例では、「undef」は実際には &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 個のスペースを含む要素です。観察する：</target>
        </trans-unit>
        <trans-unit id="aabcb2149f4617fcf7efa6bbc92a17b687ef3353" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">この例では、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; は実際には &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; のスペース数であるため、ここで行う作業が少し増えます。</target>
        </trans-unit>
        <trans-unit id="1f1787ee08eebed75ede8020208e3ff9eccca1a6" translate="yes" xml:space="preserve">
          <source>In our example, a deleted item is &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces:</source>
          <target state="translated">この例では、削除されたアイテムは &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; スペースです。</target>
        </trans-unit>
        <trans-unit id="91424799b59a91080c214218f5e7f8c9b0b084d8" translate="yes" xml:space="preserve">
          <source>In our example, just to show you that you don't</source>
          <target state="translated">私たちの例では、あなたがしないことを示すためだけに</target>
        </trans-unit>
        <trans-unit id="11b35d0e0b09647c243a787b95c24ae27233aecd" translate="yes" xml:space="preserve">
          <source>In our example, that would remove all the user's dot files! It's such a dangerous thing that they'll have to set CLOBBER to something higher than 1 to make it happen.</source>
          <target state="translated">私たちの例では、それはユーザーのドットファイルをすべて削除することになります CLOBBERを1よりも高い値に設定しなければならないほど危険なことなのです。</target>
        </trans-unit>
        <trans-unit id="8f92d427a1809586b396dc516bf348aaa08bbed7" translate="yes" xml:space="preserve">
          <source>In our example, we want to make sure there are no blank (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) entries, so &lt;code&gt;EXTEND&lt;/code&gt; will make use of &lt;code&gt;STORESIZE&lt;/code&gt; to fill elements as needed:</source>
          <target state="translated">この例では、空白（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）のエントリがないことを確認したいので、 &lt;code&gt;EXTEND&lt;/code&gt; は &lt;code&gt;STORESIZE&lt;/code&gt; を使用して、必要に応じて要素を入力します。</target>
        </trans-unit>
        <trans-unit id="24d1f4e04fd957695cb0fc036193c59fca0468cd" translate="yes" xml:space="preserve">
          <source>In our example, we will determine that if an element consists of &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces only, it does not exist:</source>
          <target state="translated">この例では、要素が &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; スペースのみで構成されている場合は存在しないと判断します。</target>
        </trans-unit>
        <trans-unit id="9241072dd02f63704e06d0e4788fd47ef3eca294" translate="yes" xml:space="preserve">
          <source>In our example, we'll use a little shortcut if there is a</source>
          <target state="translated">この例では、ちょっとしたショートカットで</target>
        </trans-unit>
        <trans-unit id="6a2c73ee683cc447274fd115e41a8a6212c0860c" translate="yes" xml:space="preserve">
          <source>In our intranet, we have many modules for internal use. How can I integrate these modules with CPAN.pm but without uploading the modules to CPAN?</source>
          <target state="translated">私たちのイントラネットには、社内で使用するためのモジュールがたくさんあります。これらのモジュールをCPAN.pmと統合しますが、CPANにモジュールをアップロードすることなく統合するにはどうすればよいでしょうか?</target>
        </trans-unit>
        <trans-unit id="e3d33b8a8cd9ee1cbb39097ccf83087f357647e8" translate="yes" xml:space="preserve">
          <source>In our tied hash DotFiles example, we use a regular hash for the object containing several important fields, of which only the &lt;code&gt;{LIST}&lt;/code&gt; field will be what the user thinks of as the real hash.</source>
          <target state="translated">紐付けされたハッシュDotFilesの例では、いくつかの重要なフィールドを含むオブジェクトに通常のハッシュを使用します。このうち &lt;code&gt;{LIST}&lt;/code&gt; フィールドのみが、ユーザーが実際のハッシュと見なすものになります。</target>
        </trans-unit>
        <trans-unit id="07709450f49a2785357dceda9bbcd6e033ef5380" translate="yes" xml:space="preserve">
          <source>In paragraphs where formatting codes (like E&amp;lt;...&amp;gt;, B&amp;lt;...&amp;gt;) are understood (i.e.,</source>
          <target state="translated">書式コード（E &amp;lt;...&amp;gt;、B &amp;lt;...&amp;gt;など）が理解される段落（つまり、</target>
        </trans-unit>
        <trans-unit id="fb0742f46f732e81f9ef6b26f9dd077a50514538" translate="yes" xml:space="preserve">
          <source>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the &lt;code&gt;parse_text&lt;/code&gt; routine in Pod::Parser as an example of a correct implementation.</source>
          <target state="translated">ポッドの解析で特に注意が必要なのは、（潜在的にネストされている！）書式コードの正しい解析です。実装者は、正しい実装の例として、Pod :: Parserの &lt;code&gt;parse_text&lt;/code&gt; ルーチンのコードを調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="e44b2915e9ebcfa80eaf0cd0b8fc6a537b378a7a" translate="yes" xml:space="preserve">
          <source>In parsing an L&amp;lt;...&amp;gt; code, Pod parsers must distinguish at least four attributes:</source>
          <target state="translated">L &amp;lt;...&amp;gt;コードの解析では、ポッドパーサーは少なくとも4つの属性を区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="173ae1b4c7abf280ed9de2a2e4233e82968c1ade" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt; . But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt; ) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt; ). Casing in this document is for improved legibility.</source>
          <target state="translated">これらの構文を解析する際、Perlは常に{中括弧}内のすべての場所で大文字と小文字の違いを無視します。したがって、 &lt;code&gt;\p{Greek}&lt;/code&gt; は &lt;code&gt;\p{greek}&lt;/code&gt; と同じことを意味します。ただし、左中括弧の前に &lt;code&gt;&quot;p&quot;&lt;/code&gt; または &lt;code&gt;&quot;P&quot;&lt;/code&gt; の大文字と小文字を変更すると、構成の意味が「一致」（ &lt;code&gt;\p{}&lt;/code&gt; ）から「一致しない」（ &lt;code&gt;\P{}&lt;/code&gt; 場合）に完全に変わることに注意してください。}）。このドキュメントのケーシングは、読みやすさを向上させるためのものです。</target>
        </trans-unit>
        <trans-unit id="9aaf8e25ca7ca9dd8d4b03a35ad6a47a7f371c04" translate="yes" xml:space="preserve">
          <source>In particular</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="2f4b20effb603658d4594f20068f3202a019f207" translate="yes" xml:space="preserve">
          <source>In particular have a hunt around for the following:</source>
          <target state="translated">特に以下のような狩りをしています。</target>
        </trans-unit>
        <trans-unit id="549a73d37bd647b3d02bdfb1ed4587a94e6c791c" translate="yes" xml:space="preserve">
          <source>In particular the following metacharacters have their standard</source>
          <target state="translated">特に以下のメタキャラクタには、その標準的な</target>
        </trans-unit>
        <trans-unit id="d9ca3d8c112df43cded72f31c7db395214aede20" translate="yes" xml:space="preserve">
          <source>In particular,</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="ef80eb5daee93a0d4fde8126fc49aefdc4e89c82" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Tie::File&lt;/code&gt; will</source>
          <target state="translated">特に、 &lt;code&gt;Tie::File&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="2db3c0671aba0d3ee80c31fffb1da43c83f4160e" translate="yes" xml:space="preserve">
          <source>In particular, braces do not need to be balanced:</source>
          <target state="translated">特に、歯列矯正はバランスをとる必要はありません。</target>
        </trans-unit>
        <trans-unit id="2cbf0bbf93ed5b0e470ae4c77978f151618da6e4" translate="yes" xml:space="preserve">
          <source>In particular, follow these general guidelines for patching Perl sources:</source>
          <target state="translated">特に、Perl のソースにパッチを当てる際には、以下の一般的なガイドラインに従ってください。</target>
        </trans-unit>
        <trans-unit id="588a69fc1734910196fa33dcc3398592c9c2b486" translate="yes" xml:space="preserve">
          <source>In particular, if you are using Info-Zip you need to have zip version 3.x or better to update a Zip64 archive and unzip version 6.x to read a zip64 archive.</source>
          <target state="translated">特に、Info-Zipを使用している場合、Zip64アーカイブを更新するにはZipバージョン3.x以上、Zip64アーカイブを読み込むにはZipバージョン6.x以上が必要です。</target>
        </trans-unit>
        <trans-unit id="b8504eca27d4d7dd980e055d06368ef344507bf5" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">特に、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; を使用してパイプを開いた場合、親プロセスでclose（）を使用して不要なライターを閉じることはできません。このコードを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="55f883bf0e56efd410000618d8c0d414be5f0032" translate="yes" xml:space="preserve">
          <source>In particular, it is not possible to write general-purpose classes in this technique, classes that can advertise themselves as &quot;Put me on your @ISA list and use my methods&quot;. If the other class has different ideas about how the object body is used, there is trouble.</source>
          <target state="translated">特に、この手法では汎用クラスを書くことはできません。&quot;私をあなたの@ISAリストに入れて、私のメソッドを使ってください &quot;と自己PRできるクラス。オブジェクトボディの使い方について、相手のクラスの考え方が違うとトラブルが発生します。</target>
        </trans-unit>
        <trans-unit id="2fd11e0201dc297df1cba370809db0d5939f0ec0" translate="yes" xml:space="preserve">
          <source>In particular, the extensions &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; and &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; are not supported under EBCDIC; likewise for the (now deprecated) &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma.</source>
          <target state="translated">特に、拡張&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;および&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;はEBCDICではサポートされていません。同様に（現在は非推奨）&lt;a href=&quot;encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマ。</target>
        </trans-unit>
        <trans-unit id="b491336832fe24926f813912697f1c74d79ed48d" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt; , regardless of any &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">特に、現在スコープ内にある &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 宣言に関係なく、特別な &lt;code&gt;${^_XYZ}&lt;/code&gt; 変数は常にパッケージ &lt;code&gt;main&lt;/code&gt; にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="5adbc38d169db3c0edbc488274012a781b34d025" translate="yes" xml:space="preserve">
          <source>In particular, this API does &lt;b&gt;not&lt;/b&gt; provide the following functions:</source>
          <target state="translated">特に、このAPIは次の機能を提供しませ&lt;b&gt;ん&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="26d259999f6bd5eabc0e32bc92fd018cffcba101" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">特に、これは、まだインストールされていない拡張機能のテストに使用される &lt;code&gt;@INC&lt;/code&gt; の構造に適用されます。つまり、アンインストールされた拡張機能を実行すると、 &lt;code&gt;make install&lt;/code&gt; 後に同じ拡張機能を実行するよりもオーバーヘッドが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="da2e58986eb4f3be556785c248e50c152e1a4485" translate="yes" xml:space="preserve">
          <source>In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:</source>
          <target state="translated">特に、これは、割り当てのために2つのアグリゲートの間で選択するために使用するべきではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="f7e08b6bdc00b0694ecd1bf1d445c34c08eeec2b" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">コードのテキストが文字どおりソースコード/ pattern /に表示されるのではなく、ランタイム情報から派生するパターンでは、コードはパターンのコンパイルと同時にコンパイルされ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; セキュリティ上の理由から、re 'を使用します。 eval 'はスコープ内にある必要があります。これは、コードスニペットを含むユーザー指定のパターンが実行可能にならないようにするためです。</target>
        </trans-unit>
        <trans-unit id="1ea88d26430c6d46158be27b80e4634d3a9d07c0" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE,EXPR&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14以降では、 &lt;code&gt;fchdir&lt;/code&gt; C関数をサポートしていないWindows以外のシステムでは、ディレクトリハンドル（&lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE、EXPRを&lt;/a&gt;参照）は新しいスレッドにコピーされません。&lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt;の &lt;code&gt;d_fchdir&lt;/code&gt; 変数を使用して、システムがそれをサポートしているかどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="978dbedfe97270c6d04770e8f1b09ed5adf8e8d1" translate="yes" xml:space="preserve">
          <source>In perl 5.8.0, &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; was also used to mark placeholders in restricted hashes. This caused such hash entries not to appear when iterating over the hash or when checking for the keys with the &lt;code&gt;hv_exists&lt;/code&gt; function.</source>
          <target state="translated">perl 5.8.0では、 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; は制限付きハッシュのプレースホルダーをマークするためにも使用されました。これにより、ハッシュを反復するとき、または &lt;code&gt;hv_exists&lt;/code&gt; 関数でキーをチェックするときに、そのようなハッシュエントリが表示されなくなりました。</target>
        </trans-unit>
        <trans-unit id="e2d10ca79661f6cd0c4cfd21cf2e8aa0ee582a6a" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared amongst all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">Perl 5.8.1以降では、Test :: Builderはスレッドセーフです。テスト番号はすべてのスレッド間で共有されます。つまり、1つのスレッドが &lt;code&gt;current_test()&lt;/code&gt; を使用してテスト番号を設定すると、それらすべてが影響を受けます。</target>
        </trans-unit>
        <trans-unit id="1269cc2ad1ea6f2d742e35bd480e05b3838a6225" translate="yes" xml:space="preserve">
          <source>In perl v5.8.0, you can work around this as follows;</source>
          <target state="translated">perl v5.8.0では、以下のように回避することができます。</target>
        </trans-unit>
        <trans-unit id="3903f5f9bb5ec2db6467ae7e05ade21cf24078e9" translate="yes" xml:space="preserve">
          <source>In perls older than 5.8.1, map suffers from this problem as well. But since 5.8.1, this has been fixed, and map is context aware - in void context, no lists are constructed.</source>
          <target state="translated">5.8.1 より古い perls では、map もこの問題に悩まされていました。しかし、5.8.1 以降では、この問題は修正されており、map はコンテキストを認識するようになりました。</target>
        </trans-unit>
        <trans-unit id="201c993ba430d2b34780a5f6bce751f372ee2124" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill()&quot;&gt;kill()&lt;/a&gt;, above.</source>
          <target state="translated">移植可能なPerlコードでは、forkプロセスで &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; 使用してはなりません。フォークされたプロセスを強制終了することは安全ではなく、予期しない結果をもたらします。上記の&lt;a href=&quot;#kill()&quot;&gt;kill（）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="64e70c5c9f546a348d8be9f13ed9b3d5b217325e" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;io/socket/ip&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">実際には、このロジックは&lt;a href=&quot;io/socket/ip&quot;&gt;IO :: Socket :: IPで&lt;/a&gt;実行する方が適切です。</target>
        </trans-unit>
        <trans-unit id="f10d5bbc85368eaaed58b49509d8d5537fcea2c6" translate="yes" xml:space="preserve">
          <source>In practice this makes seldom a difference as &lt;b&gt;parts and results&lt;/b&gt; of expressions will be truncated anyway, but this can, for instance, affect the return value of subroutines:</source>
          <target state="translated">実際には、式の&lt;b&gt;部分と結果&lt;/b&gt;が切り捨てられるため、これがめったに違いを生じることはありませんが、これは、たとえば、サブルーチンの戻り値に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c8bdda291d4d16e099108c0540471c243257c86" translate="yes" xml:space="preserve">
          <source>In practice, Perl scripts that call programs that return _POSIX_EXIT type status values will be expecting those values, and programs that call traditional VMS programs will either be expecting the previous behavior or just checking for a non-zero status.</source>
          <target state="translated">実際には、_POSIX_EXIT型のステータス値を返すプログラムを呼び出すPerlスクリプトはそれらの値を期待しており、従来のVMSプログラムを呼び出すプログラムは、以前の動作を期待しているか、ゼロではないステータスをチェックしているかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="6ed326b6d59e850419b57af366a49ca220934029" translate="yes" xml:space="preserve">
          <source>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</source>
          <target state="translated">実際には、この文字はあまり使われないことが予想されますが、フォーマッタはこの文字をサポートするか、削除するべきです。</target>
        </trans-unit>
        <trans-unit id="796550631a5df07b05a560a67d63d7ad67fdf7c5" translate="yes" xml:space="preserve">
          <source>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</source>
          <target state="translated">これまでのセクションでは、数字と文字列の詰め方を見てきました。もし、いくつかの問題がなければ、C の構造体には他の何も含まれていないので、あなたはすでにすべてを知っています、という簡潔な言葉で、このセクションをすぐに終えることができます。申し訳ありません。</target>
        </trans-unit>
        <trans-unit id="692b842adc759f56816c9c058cae643b8a51086a" translate="yes" xml:space="preserve">
          <source>In principle the unpack() command can be used to convert the bytes back to a number (if the underlying type is known to be a number).</source>
          <target state="translated">原則として、unpack()コマンドはバイトを数値に変換するために使用することができます (基礎となる型が数値であることがわかっている場合)。</target>
        </trans-unit>
        <trans-unit id="1221515422031848620efe6d264c7054adcd4f04" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">以前のバージョンのperlでは、開いているディレクトリハンドルでスレッドを生成すると、インタープリターがクラッシュしました。&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl＃75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d807cc153636cb39c76e4cb0277ef6012694dae7" translate="yes" xml:space="preserve">
          <source>In programs:</source>
          <target state="translated">プログラムの中で</target>
        </trans-unit>
        <trans-unit id="48c74c56dfa96426cf79d4567af2599b0fde094e" translate="yes" xml:space="preserve">
          <source>In recent years, vendors have begun to supply systems free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">近年、ベンダはこの固有のセキュリティバグのないシステムを提供し始めています。そのようなシステムでは、カーネルが set-id スクリプトの名前をインタープリタに渡すときに、お節介なパス名を使うのではなく、代わりに</target>
        </trans-unit>
        <trans-unit id="fc7a0ac9fe9f163678a08865a8ae2ec22fbc06ff" translate="yes" xml:space="preserve">
          <source>In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;, meaning that it doesn't represent a character in the string, but a condition at a certain position.</source>
          <target state="translated">正規表現で言えば、単語の境界(\b)は「ゼロ幅のアサーション」であり、文字列の中の文字ではなく、ある位置の条件を表しています。</target>
        </trans-unit>
        <trans-unit id="1b5ca67e58e909ea0b763b445166b0dc50f9fff9" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt; , for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt; . If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; , by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; .</source>
          <target state="translated">正規表現では、配列の添え字と文字クラスを明確にするために、 &lt;code&gt;${foo[2]}&lt;/code&gt; 構文が必要になる場合があります。 &lt;code&gt;/$length[2345]/&lt;/code&gt; は、たとえば、 &lt;code&gt;$length&lt;/code&gt; 後に文字クラス &lt;code&gt;[2345]&lt;/code&gt; が続くものとして解釈されます。配列の添え字が必要な場合は、 &lt;code&gt;/${length[2345]}/&lt;/code&gt; を見苦しい &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; に変更して、配列の名前を一致しないものに変更することで、警告を回避できます内蔵のキーワード、または単にで警告をオフにすることで、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870f19d24df4b4eee6c062f874fd2afacdfc9f30" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">スカラーコンテキストでは、内部で同じパターンを使用して生の &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を文字列化するときにperlが返すのと同じように返します。引数がコンパイルされた参照でない場合、このルーチンはfalseを返しますが、スカラーコンテキストで定義され、リストコンテキストでは空のリストです。したがって、次の</target>
        </trans-unit>
        <trans-unit id="0a19f93e8a70aa3709a4c5eb5c497d67c74952ec" translate="yes" xml:space="preserve">
          <source>In scalar context will return just the IP address.</source>
          <target state="translated">スカラコンテキストでは、IPアドレスだけを返します。</target>
        </trans-unit>
        <trans-unit id="1370034b95e83c1602601f8f2c93a5f4f13c28ad" translate="yes" xml:space="preserve">
          <source>In scalar context without arguments, this method returns the number of parsers aggregated. In list context without arguments, returns the parsers in the order they were added.</source>
          <target state="translated">引数のないスカラコンテキストでは、このメソッドは集約されたパーサの数を返します。引数のないリストコンテキストでは、追加された順にパーサーを返します。</target>
        </trans-unit>
        <trans-unit id="3e333b48f248d91366426a74dfbbc3da65c8ea7d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&quot;..&quot;&lt;/code&gt; returns a boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and various editors. Each &lt;code&gt;&quot;..&quot;&lt;/code&gt; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&quot;..&quot;&lt;/code&gt; はブール値を返します。演算子はフリップフロップのように双安定であり、&lt;b&gt;sed&lt;/b&gt;、&lt;b&gt;awk&lt;/b&gt;、およびさまざまなエディターの行範囲（カンマ）演算子をエミュレートします。各 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 演算子は、それを含むサブルーチンへの呼び出し間でも、独自のブール状態を維持します。左側のオペランドがfalseである限り、falseです。左側のオペランドが真になると、範囲演算子は右側のオペランドが真になるまで真のままです。</target>
        </trans-unit>
        <trans-unit id="4702696bd1a6606f8c00bfa48b7462e238b219f8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; はctime（3）値を返します。</target>
        </trans-unit>
        <trans-unit id="50ab8480db61cacd9dd3820b8d1635a7c8fbf2e8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; は成功または失敗を示すブール値を返し、成功した場合は、特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; に関連付けられた情報を設定します。</target>
        </trans-unit>
        <trans-unit id="d1818a475de168c2b1a7d2bb086c2af5a3f3a97b" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;$user&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="d16f2c8ac24f3fef816016a050127e8baea1e4f0" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; はctime（3）値を返します。</target>
        </trans-unit>
        <trans-unit id="c038fe7af8fd4fba37237e821dee5726e03d9bcf" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; は成功または失敗を示すブール値を返し、成功した場合は、特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; に関連付けられた情報を設定します。</target>
        </trans-unit>
        <trans-unit id="f361652bf48a4a2a1736272eaacbdbdece5ad741" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;$user&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="67f63380dd91d8509df2b85f67d144a31345d453" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function; see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; を実行するたびに次の一致が検出され、一致する場合はtrueが、それ以上一致しない場合はfalseが返されます。最後の一致後の位置は、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 関数を使用して読み取りまたは設定できます。&lt;a href=&quot;functions/pos&quot;&gt;posを&lt;/a&gt;参照してください。一致が失敗すると、通常、検索位置は文字列の先頭にリセットされますが、 &lt;code&gt;/c&lt;/code&gt; 修飾子（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; ）を追加することで回避できます。ターゲット文字列を変更すると、検索位置もリセットされます。</target>
        </trans-unit>
        <trans-unit id="8800b54c59ca34fbb2fd00902e130cb43eb3acc5" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">スカラーコンテキストでは、山かっこでファイルハンドルを評価すると、そのファイルの次の行（改行がある場合は、それが含まれます）、またはファイルの終わりやエラー時に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が生成されます。ときに &lt;code&gt;$/&lt;/code&gt; に設定されている &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を（時にはファイル吸い込みモードとして知られている）と、ファイルが空である、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を後に。</target>
        </trans-unit>
        <trans-unit id="90d5e99280edc013a52bda47119a081391fd852e" translate="yes" xml:space="preserve">
          <source>In scalar context, just the filehandle is returned.</source>
          <target state="translated">スカラコンテキストでは、ファイルハンドルだけが返されます。</target>
        </trans-unit>
        <trans-unit id="26e7b891880cf2546cd4182b9d0f0a5ab5924094" translate="yes" xml:space="preserve">
          <source>In scalar context, the function returns the most preferred language tag (or undef if no preference was seen).</source>
          <target state="translated">スカラコンテキストでは、この関数は最も優先度の高い言語タグを返します(優先度が見られなかった場合は undef)。</target>
        </trans-unit>
        <trans-unit id="b1d9f6c7ff92d9e4431c44fd49623f31abe26893" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time in the timer is returned.</source>
          <target state="translated">スカラコンテキストでは、タイマーの残り時間が返されます。</target>
        </trans-unit>
        <trans-unit id="f286b508bea32b55376de76bb51800a879183e4c" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time is returned.</source>
          <target state="translated">スカラコンテキストでは、残りの時間が返されます。</target>
        </trans-unit>
        <trans-unit id="1fc032fde56245f910fbc6d13638ce22e45ea79e" translate="yes" xml:space="preserve">
          <source>In scalar context, you get the name, unless the function was a lookup by name, in which case you get the other thing, whatever it is. (If the entry doesn't exist you get the undefined value.) For example:</source>
          <target state="translated">スカラコンテキストでは、関数が名前による検索でない限り、名前を取得します。(エントリが存在しない場合は未定義の値を取得します)。</target>
        </trans-unit>
        <trans-unit id="070ead24adcf97bbf0458e41cddfaf9060fd1c75" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , do not change their behavior with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;スコープ内。が有効な場合、上記のほぼすべての演算子は引数を整数形式に強制し、整数の結果を返します。例外、 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; integerを使用しても動作を変更しません。</target>
        </trans-unit>
        <trans-unit id="d3fd63b759e64d942882eb1c88a05afcfdaffadf" translate="yes" xml:space="preserve">
          <source>In searching for &lt;code&gt;/\bfoo\b/&lt;/code&gt; , only locations in &lt;code&gt;$_&lt;/code&gt; that contain &lt;code&gt;f&lt;/code&gt; will be looked at, because &lt;code&gt;f&lt;/code&gt; is rarer than &lt;code&gt;o&lt;/code&gt; . In general, this is a big win except in pathological cases. The only question is whether it saves you more time than it took to build the linked list in the first place.</source>
          <target state="translated">&lt;code&gt;/\bfoo\b/&lt;/code&gt; 検索では、 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;o&lt;/code&gt; よりも少ないため、 &lt;code&gt;f&lt;/code&gt; を含む &lt;code&gt;$_&lt;/code&gt; 内の場所のみが検索されます。一般的に、これは病理的な場合を除いて大きな勝利です。唯一の問題は、そもそもリンクリストを作成するよりも時間を節約できるかどうかです。</target>
        </trans-unit>
        <trans-unit id="d510b9d55974c5ad5785f6cfe4077983c695078d" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">要するに、Perl 4 は Perl 5 と Perl 6 の両方の親です。Perl 5 は兄妹であり、異なる言語ではありますが、一方を知っている人は他方に多くの類似点があることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="a022deee593194afb675e77892be1749073d500f" translate="yes" xml:space="preserve">
          <source>In simple cases, it is equivalent to:</source>
          <target state="translated">単純に考えれば、これに相当します。</target>
        </trans-unit>
        <trans-unit id="ffcc65b4ec59c10cd981321f645c18e2c2833005" translate="yes" xml:space="preserve">
          <source>In simple terms, this is what happens:</source>
          <target state="translated">簡単に言うと、こうなります。</target>
        </trans-unit>
        <trans-unit id="d121139946109160493990901ec9a05c62500b61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; でこれを有効にする必要がある状況では、汚染チェックも有効にする必要があります。さらに、安全なコンパートメント内で、慎重に制約された評価を使用してください。参照してください&lt;a href=&quot;perlsec&quot;&gt;perlsecを&lt;/a&gt;両方これらのメカニズムの詳細については。</target>
        </trans-unit>
        <trans-unit id="e2046d35bd71cc3166ad97adddb890d2444c1f0f" translate="yes" xml:space="preserve">
          <source>In some cases (starting server processes, for instance) you'll want to completely dissociate the child process from the parent. This is often called daemonization. A well-behaved daemon will also chdir() to the root directory so it doesn't prevent unmounting the filesystem containing the directory from which it was launched, and redirect its standard file descriptors from and to</source>
          <target state="translated">場合によっては (例えばサーバプロセスの起動など)、子プロセスを親プロセスから完全に切り離したいこともあるでしょう。これはしばしばデーモン化と呼ばれます。行儀の良いデーモンは、起動されたディレクトリを含むファイルシステムのアンマウントを妨げないように、ルートディレクトリに chdir()を実行し、その標準ファイルディスクリプタを</target>
        </trans-unit>
        <trans-unit id="fd4562e3425450ab12fc121ff9cd696fd05153a4" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless C&amp;lt;:_exit&amp;gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">File :: Tempによって作成されたファイルがENDブロック内から削除される場合があります。ENDブロックは子プロセスの終了時にトリガーされるため（C &amp;lt;：_ exit&amp;gt;が子によって使用されている場合を除く）、File :: Tempは、特定のプロセスIDによって作成された一時ファイルのみを削除するように注意します。これは、子プロセスが親プロセスによって作成された一時ファイルを削除しようとしないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4cd284f272380bf09ca4f9468d05eb334cb95414" translate="yes" xml:space="preserve">
          <source>In some cases the 'application' can then be reduced to a small</source>
          <target state="translated">いくつかのケースでは、「アプリケーション」を小さな</target>
        </trans-unit>
        <trans-unit id="df381c2814bde8cd15795ab2d100f8c130800cb5" translate="yes" xml:space="preserve">
          <source>In some cases this</source>
          <target state="translated">いくつかのケースでは、これは</target>
        </trans-unit>
        <trans-unit id="cde62ba475df964750a3cdf495be48e1d052051b" translate="yes" xml:space="preserve">
          <source>In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</source>
          <target state="translated">いくつかのケースでは、ファイルが作成されたときにこの変数が真である場合にのみ、ファイルが保持されます。つまり、一時ファイルを作成してこの変数を設定し、プログラムが終了したときに一時ファイルが残っていることを期待することはできません。</target>
        </trans-unit>
        <trans-unit id="3905e6a37b63c12afc3763addc4e36a653fc636f" translate="yes" xml:space="preserve">
          <source>In some cases, using substr() or vec() to simulate arrays can be highly beneficial. For example, an array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one 125-byte bit vector--a considerable memory savings. The standard Tie::SubstrHash module can also help for certain types of data structure. If you're working with specialist data structures (matrices, for instance) modules that implement these in C may use less memory than equivalent Perl modules.</source>
          <target state="translated">場合によっては、配列をシミュレートするために substr()や vec()を使用することは非常に有益です。例えば、1000個のブール演算子の配列は少なくとも20,000バイトのスペースを必要としますが、これを1つの125バイトのビットベクタに変換することができ、かなりのメモリ節約になります。標準の Tie::SubstrHash モジュールは、特定のタイプのデータ構造を扱う際にも役立ちます。特殊なデータ構造 (例えば行列)を扱う場合は、C 言語で実装されているモジュールの方が、同等の Perl モジュールよりも少ないメモリで済むかもしれません。</target>
        </trans-unit>
        <trans-unit id="24e84c8e00f2a5bb70e605cd2c69e1dd80d922f5" translate="yes" xml:space="preserve">
          <source>In some cases, yes. You can use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">いくつかのケースでは、はい。 &lt;code&gt;iter&lt;/code&gt; クラスメソッドを使用すると、メモリ内のすべてのファイルを一度に読み取ることなく、tarball内のファイルを反復処理できます。</target>
        </trans-unit>
        <trans-unit id="da7c53f5c4edfd54be873e35b150cbb2e0f64102" translate="yes" xml:space="preserve">
          <source>In some cases, you may be able to make several patterns into a single regular expression. Beware of situations that require backtracking though.</source>
          <target state="translated">場合によっては、いくつかのパターンを一つの正規表現にすることができるかもしれません。しかし、バックトラックを必要とする状況には注意してください。</target>
        </trans-unit>
        <trans-unit id="55ed1ae3a3af36b978490ace319abb286ca584e8" translate="yes" xml:space="preserve">
          <source>In some cases, you'll want to completely skip an entire testing script.</source>
          <target state="translated">場合によっては、テストスクリプト全体を完全にスキップしたいこともあるでしょう。</target>
        </trans-unit>
        <trans-unit id="b444fb6bd755ce68abe6b0c45e2101b6fb938848" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">一部のコンテキストでは、バックスラッシュの後に2桁または1桁の8進数が続く場合、警告が出たり、バグが原因で、驚くべき結果になることもある8進エスケープとして解釈されることがあります。また、小さいスニペットを連結して正規表現を作成し、使用する数字が3桁未満の場合、1つのスニペットの先頭が、その前のスニペットの末尾に数字を追加すると解釈される場合があります。スニペットの問題の詳細と例については、&lt;a href=&quot;#Absolute-referencing&quot;&gt;絶対参照&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="941b228759db0ad2f21515f9edebce99234327a5" translate="yes" xml:space="preserve">
          <source>In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</source>
          <target state="translated">I18N::LangTagsの将来のバージョンでは、RFC2482スタイルの言語タグのサポートを含めることを計画しています。</target>
        </trans-unit>
        <trans-unit id="b0260d31b907a523df71ffe831436a5256c0c0bb" translate="yes" xml:space="preserve">
          <source>In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.</source>
          <target state="translated">いくつかの文献では、この構成は「アトミック・マッチング」または「所有的マッチング」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="79419ef5fc7d87682a2736d33053a4e99ddcc17b" translate="yes" xml:space="preserve">
          <source>In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.</source>
          <target state="translated">いくつかのプラットフォームでは、1秒以下の解像度でアラームを取得することはできません。</target>
        </trans-unit>
        <trans-unit id="6aef2a6b389cc51b9d270ade7d87dfa403f876dd" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt; . In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">一部のプラットフォームでは、 &lt;code&gt;ps&lt;/code&gt; で示されるように、変更された名前の後にスペースなどの任意の量のパディングがある場合があります。一部のプラットフォームでは、このパディングは、何をしても、引数領域の元の長さにまで及ぶ場合があります（これは、たとえばLinux 2.2の場合です）。</target>
        </trans-unit>
        <trans-unit id="08216ba09095e01bafc1d8f5f89aaf1f507c0440" translate="yes" xml:space="preserve">
          <source>In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.</source>
          <target state="translated">状況によっては、特定のシンボルをエクスポートできないようにしたい場合もあるでしょう。通常、これはシステムによっては存在しない関数や定数を持つ拡張機能に適用されます。</target>
        </trans-unit>
        <trans-unit id="6f0ffd2574e55bd73781b2f238993d92b6b53578" translate="yes" xml:space="preserve">
          <source>In spite of its name,</source>
          <target state="translated">名前の割には</target>
        </trans-unit>
        <trans-unit id="3a8cbd2876234fb0eafe4d9966f4f375e97df144" translate="yes" xml:space="preserve">
          <source>In such cases, to force an additional variable to be declared together with declarations of other variables, place the declaration into a PREINIT: section. The PREINIT: keyword may be used one or more times within an XSUB.</source>
          <target state="translated">このような場合、他の変数の宣言と一緒に追加の変数を強制的に宣言するには、その宣言をPREINIT:セクションに入れます。PREINIT:キーワードはXSUB内で1回以上使用することができます。</target>
        </trans-unit>
        <trans-unit id="ac9198f5929b9dd8df4d3b09d9577116cbbad276" translate="yes" xml:space="preserve">
          <source>In such cases, you are advised to either split the test file into smaller ones, or use a reverse approach, doing &quot;normal&quot; (code) compares and triggering &lt;code&gt;fail()&lt;/code&gt; should anything go unexpected.</source>
          <target state="translated">そのような場合は、テストファイルを小さいファイルに分割するか、逆のアプローチを使用して、「通常の」（コード）比較を行い、予期しない事態が発生した &lt;code&gt;fail()&lt;/code&gt; をトリガーすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a4b3a6172283064c4d2c38bcdfc1abf019578af1" translate="yes" xml:space="preserve">
          <source>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</source>
          <target state="translated">要約すると、Perl は通常、正規表現のマッチのために Unicode 以外のコードポイントを典型的な Unicode 未割り当てコードポイントとして扱い、結果が何であるべきか議論が可能な場合にのみ警告を表示します。しかし、この警告が致命的なものになっている場合、警告はスキップされません。</target>
        </trans-unit>
        <trans-unit id="bdfe847eef52d0f5e340cab498d8b20a1e1ac3a3" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt; . When the user types</source>
          <target state="translated">要約すると、コンパイラバックエンドモジュールは、一部のfooの場合は「B :: Foo」と呼ばれ、その名前の適切なディレクトリに存在する必要があります。 &lt;code&gt;compile&lt;/code&gt; という関数を定義する必要があります。ユーザーが入力したとき</target>
        </trans-unit>
        <trans-unit id="fc74db358d542b3438f19ea437ddcca2306a63f1" translate="yes" xml:space="preserve">
          <source>In summary, local() doesn't make what you think of as private, local variables. It gives a global variable a temporary value. my() is what you're looking for if you want private variables.</source>
          <target state="translated">まとめると、local()はプライベートなローカル変数として考えているものを作りません。グローバル変数に一時的な値を与えます。 プライベート変数が欲しい場合は my()を使用します。</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">要約すると</target>
        </trans-unit>
        <trans-unit id="f27d5775b98cc1edc00b71d0a359c25acea44018" translate="yes" xml:space="preserve">
          <source>In telephony, the temporary electrical circuit between the caller&amp;rsquo;s and the callee&amp;rsquo;s phone. In networking, the same kind of temporary circuit between a &lt;b&gt;client&lt;/b&gt; and a &lt;b&gt;server&lt;/b&gt;.</source>
          <target state="translated">電話において、発信者と着信者の電話間の一時的な電気回路。ネットワーキングでは、&lt;b&gt;クライアント&lt;/b&gt;と&lt;b&gt;サーバー&lt;/b&gt;間の同じ種類の一時的な回線。</target>
        </trans-unit>
        <trans-unit id="8a961ce11a5972421c4f26b07fe69c91b0c3c7f5" translate="yes" xml:space="preserve">
          <source>In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file. We changed this to a relative path so that we could move the extension directory if we wanted to.</source>
          <target state="translated">.xs ファイルには、mylib.h ヘッダファイルへの絶対パスを持つ #include ディレクティブがあります。これを相対パスに変更して、必要に応じて拡張子ディレクトリを移動できるようにしました。</target>
        </trans-unit>
        <trans-unit id="f2ed93444f2e4f61ea8ed89fb84f5492a5e66658" translate="yes" xml:space="preserve">
          <source>In the 5.9.x development version of perl you can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="translated">Perlの5.9.x開発バージョンでは &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; を使用して、解析プロセスに関するいくつかのトレース情報を表示できます。いくつかの単純なパターンから始めて、より複雑なパターンを構築します。</target>
        </trans-unit>
        <trans-unit id="695cc6d82e9a098f429aaf4feaee8cd47933f5d7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">で &lt;code&gt;Encode&lt;/code&gt; モジュール、 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 、実際の正規名である &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; と &lt;code&gt;&quot;8&quot;&lt;/code&gt; 間のハイフンは重要です。それがなければ、 &lt;code&gt;Encode&lt;/code&gt; は「リベラル」になり、（おそらく過度に）許容的になります。</target>
        </trans-unit>
        <trans-unit id="b4feedfc56c9ca92e3c18dcd179dd65dfefb5217" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SvPV&lt;/code&gt; macro, the length of the string returned is placed into the variable &lt;code&gt;len&lt;/code&gt; (this is a macro, so you do</source>
          <target state="translated">で &lt;code&gt;SvPV&lt;/code&gt; のマクロ、返される文字列の長さは、変数に入れられ &lt;code&gt;len&lt;/code&gt; あなたが行うので、これはマクロです（</target>
        </trans-unit>
        <trans-unit id="070901afbf1f09255274e8877eb8bc2c70b45164" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form,</source>
          <target state="translated">では &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形、</target>
        </trans-unit>
        <trans-unit id="95cc687da96e0b7f7623a95a00b37de925f9f2e9" translate="yes" xml:space="preserve">
          <source>In the C part of the XS file (above the first MODULE line) you have</source>
          <target state="translated">XS ファイルの C 部分 (MODULE の最初の行の上)には、以下のように記述されています。</target>
        </trans-unit>
        <trans-unit id="9da81592ea409347d5f06bd8bb3e9dfa81794242" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt; , and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; . There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">説明のために意図的に難読化されている上記のREでは、区切り文字は &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 、修飾子は &lt;code&gt;mx&lt;/code&gt; であり、区切り文字を削除した後のREは &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; と同じです。区切り文字を英数字や空白以外の選択肢に制限することをお勧めする理由は複数あります。</target>
        </trans-unit>
        <trans-unit id="e13a699e1847e4e4560a850a3ff6592656db6884" translate="yes" xml:space="preserve">
          <source>In the above &quot;TAP&quot;, the second and fourth lines will generate &quot;Unknown&quot; tokens.</source>
          <target state="translated">上記の「TAP」では、2行目と4行目で「不明」のトークンが生成されます。</target>
        </trans-unit>
        <trans-unit id="058e91307a10961fd993a819105cb638818d3bdd" translate="yes" xml:space="preserve">
          <source>In the above [A, C] example, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; hook could return:</source>
          <target state="translated">上記の[A、C]の例では、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; のフックは、返すことができます。</target>
        </trans-unit>
        <trans-unit id="eb159de765838e35dcdde7356fd1bd005beb7684" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt; .)</source>
          <target state="translated">上記では、スレッドオブジェクトはスカラーコンテキストで親スレッドに返され、スレッドのエントリポイント関数 &lt;code&gt;foo&lt;/code&gt; はリスト（配列）コンテキストで呼び出され、親スレッドは &lt;code&gt;-&amp;gt;join()&lt;/code&gt; からリスト（配列）を受け取ることができます。（）の呼び出し。（ &lt;code&gt;'array'&lt;/code&gt; は &lt;code&gt;'list'&lt;/code&gt; と同義です。）</target>
        </trans-unit>
        <trans-unit id="9d73b10ae1520507352b424e24dd93e5f334c96c" translate="yes" xml:space="preserve">
          <source>In the above, your &lt;code&gt;frobnicate&lt;/code&gt; function has been changed to be made aware of whether or not it's dealing with UTF-8 data, so that it can handle the string appropriately.</source>
          <target state="translated">上記では、 &lt;code&gt;frobnicate&lt;/code&gt; 関数が変更され、UTF-8データを処理しているかどうかを認識できるようになり、文字列を適切に処理できるようになりました。</target>
        </trans-unit>
        <trans-unit id="e3c7cb8befa26cf8853246bc9e4f9d7c53539559" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_COLLATE&lt;/code&gt; は照合（ソート）ロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_COLLATE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は照合ロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="15ce031d9fce06ed575c3914c8c9ea6101622d1e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_CTYPE&lt;/code&gt; は文字タイプのロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は文字タイプのロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="6468a6eaf61ca1746bc5af34d7e2d7db949b3755" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_MONETARY&lt;/code&gt; は通貨フォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_MONETARY&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は通貨フォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="aa4035e23872d9d83606fa0ea98c9a044e6d0674" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_NUMERIC&lt;/code&gt; は数値形式のロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_NUMERIC&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は数値形式を選択します。</target>
        </trans-unit>
        <trans-unit id="6ab8079d22785df117a0b766ea8b7c3baae6e9c3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_TIME&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_TIME&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="68e71f53c7f8acf89933bfc63a04da9641a2aa37" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">括弧がない場合、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; などのリスト演算子の優先順位は、演算子の左側と右側のどちらを見ているかに応じて、非常に高いか非常に低くなります。たとえば、</target>
        </trans-unit>
        <trans-unit id="8e8c77934a4391ccf6a1b211036cc4430a6aec4a" translate="yes" xml:space="preserve">
          <source>In the argument hashref,</source>
          <target state="translated">引数のhashrefで</target>
        </trans-unit>
        <trans-unit id="c8faecb0e00885cd9d3471fff022824b0e193793" translate="yes" xml:space="preserve">
          <source>In the beginning there was ASCII, the &quot;American Standard Code for Information Interchange&quot;, which works quite well for Americans with their English alphabet and dollar-denominated currency. But it doesn't work so well even for other English speakers, who may use different currencies, such as the pound sterling (as the symbol for that currency is not in ASCII); and it's hopelessly inadequate for many of the thousands of the world's other languages.</source>
          <target state="translated">当初はASCIIという「情報交換のためのアメリカ標準コード」がありましたが、これは英語のアルファベットとドル建ての通貨を使うアメリカ人にとっては非常にうまく機能しています。しかし、ポンドスターリングのような異なる通貨を使用する可能性のある他の英語話者にとっても、それはあまりうまく機能しません(通貨の記号がASCIIではないため)。</target>
        </trans-unit>
        <trans-unit id="4d58fb76f14dae3b712c2d1ef16b33d41abd7aa5" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt;および&lt;b&gt;-mの&lt;/b&gt;場合、これらのオプションはスクリプト内での使用を目的としていないため、これはエラーです。代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; プラグマを使用してください。</target>
        </trans-unit>
        <trans-unit id="468d95254e2569de4c93c44e90ecaaab6e1c8a96" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">以下の場合には &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; 、任意の正規化が行われず、結合文字で不連続な収縮が行われます。したがって、 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;は&lt;/b&gt; &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; &lt;b&gt;と&lt;/b&gt;同等です。ソース文字列が細かく事前 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; されている場合、（正規化=&amp;gt; '事前正規化'）は正規化の時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="5830f7641c2c9f00de57771005c708cf9a4d5c74" translate="yes" xml:space="preserve">
          <source>In the case of a perl test suite, typically</source>
          <target state="translated">Perl のテストスイートの場合、通常は</target>
        </trans-unit>
        <trans-unit id="93b5501796f0c8e106f09c3c3a171aba6b8b3835" translate="yes" xml:space="preserve">
          <source>In the case of a shared array, all the array's elements are shared, and for a shared hash, all the keys and values are shared. This places restrictions on what may be assigned to shared array and hash elements: only simple values or references to shared variables are allowed - this is so that a private variable can't accidentally become shared. A bad assignment will cause the thread to die. For example:</source>
          <target state="translated">共有配列の場合、配列のすべての要素が共有され、共有ハッシュの場合はすべてのキーと値が共有されます。これにより、共有配列やハッシュの要素に代入できるものが制限されます。 単純な値や共有変数への参照のみが許可されます。これは、プライベート変数が誤って共有されてしまうことを防ぐためです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2e771b6edcf0a67e48248188d99cc8c1ee77f6d9" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">文字列の場合、 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; はファイルをロードすることを想定しています。しかし、裸語の場合、それはあなたがモジュールを意味すると仮定します。</target>
        </trans-unit>
        <trans-unit id="92d133184cc1d94941d92f9ddbb74be254d7536c" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will be equivalent to</source>
          <target state="translated">制限のないハッシュの場合、これは</target>
        </trans-unit>
        <trans-unit id="9c7996f6bbe611631e0062a5b0c8688fa0df75c4" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will return an empty list.</source>
          <target state="translated">制限のないハッシュの場合、これは空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="bbcb89949ef30fa331653e26c292cc6bfd5402d5" translate="yes" xml:space="preserve">
          <source>In the case of branching constructs like the following:</source>
          <target state="translated">のような分岐構造の場合。</target>
        </trans-unit>
        <trans-unit id="235ed9f8205c1cb0e0f0c89543ab0c301b45cc8b" translate="yes" xml:space="preserve">
          <source>In the case where bsd_glob() has found some matching paths, but is interrupted by an error, it will return a list of filenames &lt;b&gt;and&lt;/b&gt; set &amp;amp;File::Glob::ERROR.</source>
          <target state="translated">bsd_glob（）が一致するパスをいくつか見つけたが、エラーによって中断された場合、ファイル名のリストを返し、＆File :: Glob :: ERROR &lt;b&gt;を&lt;/b&gt;設定します。</target>
        </trans-unit>
        <trans-unit id="ab44e54a843289d8fb48be15296e74831fd77123" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; . The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD、NFKD、およびFCDの場合、答えは &lt;code&gt;YES&lt;/code&gt; または &lt;code&gt;NO&lt;/code&gt; でなければなりません。答えは &lt;code&gt;MAYBE&lt;/code&gt; NFC、NFKC、およびFCCの場合に返されることがあります。</target>
        </trans-unit>
        <trans-unit id="94e0ab2727afbd4185da2de81e38250408bd5cc4" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">以下のコードでは、 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; すると、すべて「無効なコンテキストでのxxxの無用な使用」警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8fd1596cdd97dc35baf217614ea25fccb283e4de" translate="yes" xml:space="preserve">
          <source>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</source>
          <target state="translated">メモリ要件に対する速度を考慮すると、バランスはより高速な実行に有利に傾いてきました。これはCコンパイラが構造体にメモリを割り当てる方法に影響を与えています。16ビットや32ビットのオペランドがメモリ内の場所間やCPUレジスタとの間を高速に移動できるアーキテクチャでは、偶数アドレスや4の倍数アドレス、8の倍数アドレスにアラインメントされている場合、Cコンパイラは構造体に余分なバイトを詰め込むことで、この速度の利点を提供しています。C の海岸線を渡らないのであれば、このようなことをしても問題になることはありません(ただし、大きなデータ構造を設計する場合や、アーキテクチャ間でコードを移植したい場合は注意が必要です(そうしたいですよね?</target>
        </trans-unit>
        <trans-unit id="9d33a076ef77a2ea3c1cd018606852167138e6c8" translate="yes" xml:space="preserve">
          <source>In the context of the</source>
          <target state="translated">の文脈では</target>
        </trans-unit>
        <trans-unit id="d491c48b25f3ad65e82b4c5c2097be0b50a9588c" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">現在の実装では、スカラー定数は実際にはインライン化可能なサブルーチンです。Perlのバージョン5.004以降、一部のサブルーチン呼び出しの代わりに適切なスカラー定数が直接挿入されるため、サブルーチン呼び出しのオーバーヘッドを節約できます。これがいつどのように発生するかについての詳細は&lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;、perlsubの定数関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3c0455a3b2b53d95f4e20ec0b4340a717b68f76c" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt; , magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; に明示的に値が割り当てられていないデフォルトの場合、魔法の自動生成が有効になります。</target>
        </trans-unit>
        <trans-unit id="9e4e78aa2b33a6d6dac51bbc3211d37de72733b0" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">デフォルトの構成では、オプション名は一意に短縮される場合があり、大文字と小文字は関係ありません。長いオプション名であっても、ダッシュは1つで十分です。また、オプションは非オプション引数の間に置くことができます。参照&lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;設定Getoptの::ロング&lt;/a&gt; Getoptの::ロングを設定する方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="e72101fd159fd0afaf983f558f5b87febb7113ce" translate="yes" xml:space="preserve">
          <source>In the description it is mentioned that</source>
          <target state="translated">説明の中では、次のように述べられています。</target>
        </trans-unit>
        <trans-unit id="ef03d8c00322da2ed4dc98f0803a382ee30a4ed1" translate="yes" xml:space="preserve">
          <source>In the diagram, the further right you go the more deeply nested the scope is. It is only when control is back with perl on the extreme left of the diagram that you will have dropped back to the enclosing scope and any temporaries you have left hanging around will be freed.</source>
          <target state="translated">図では、右に行くほどスコープは深く入れ子になっています。制御が図の左端にあるperlに戻って初めて、スコープを囲んでいる状態に戻り、ぶら下がったままにしておいたテンポラリが解放されることになります。</target>
        </trans-unit>
        <trans-unit id="6f416a980a416e375bc66bc2d4fa36e45d3dee04" translate="yes" xml:space="preserve">
          <source>In the event that your XS code may need the underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale, there are macros available to access this; see &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;Locale-related functions and macros in perlapi&lt;/a&gt;.</source>
          <target state="translated">XSコードが基本的な &lt;code&gt;LC_NUMERIC&lt;/code&gt; ロケールを必要とする場合、これにアクセスするために利用可能なマクロがあります。&lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;perlapiのロケール関連の関数とマクロを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf76bf6bac3fdd00f94042b70f25cd2c0127da6a" translate="yes" xml:space="preserve">
          <source>In the example above $DB_HASH is actually a pre-defined reference to a hash object. &lt;b&gt;DB_File&lt;/b&gt; has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.</source>
          <target state="translated">上記の例では、$ DB_HASHは実際にはハッシュオブジェクトへの事前定義された参照です。&lt;b&gt;DB_Fileに&lt;/b&gt;は、これらの定義済み参照が3つあります。$ DB_HASHの他に、$ DB_BTREEと$ DB_RECNOもあります。</target>
        </trans-unit>
        <trans-unit id="383bad82dbf36df5fcbc2607474fc2833874c49f" translate="yes" xml:space="preserve">
          <source>In the example above, no file in</source>
          <target state="translated">上記の例では</target>
        </trans-unit>
        <trans-unit id="a6fdb80f186445ea957d140c9ee93d85c7f7bc67" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">上記の例では、スレッドが終了するとすぐに &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; メソッドが返されます。スレッドが終了するのを待ち、スレッドが返した可能性のある値を収集することに加えて、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; はスレッドに必要なOSクリーンアップも実行します。このクリーンアップは、特に多くのスレッドを生成する長時間実行プログラムにとって重要になる場合があります。戻り値が不要で、スレッドが終了するまで待機したくない場合は、次に説明するように、代わりに &lt;code&gt;detach()&lt;/code&gt; メソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="e4fb9b67eb5a1d7e86fa97df408aad4ebc6c2e68" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the WRITER filehandle, so it closes it. However, because WRITER was opened using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">上記の例では、真の親はWRITERファイルハンドルへの書き込みを望まないため、それを閉じます。ただし、WRITERは &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; を使用して開かれたため、特別な動作があります。閉じると、サブプロセスの終了を待機するwaitpid（）（&lt;a href=&quot;functions/waitpid&quot;&gt;waitpidを&lt;/a&gt;参照）が呼び出されます。子プロセスが「何か他のことをする」とマークされたセクションで何かが起こるのを待つことになる場合、デッドロックがあります。</target>
        </trans-unit>
        <trans-unit id="e18ac50c69f2e5daf082fad97b93479b32118e7a" translate="yes" xml:space="preserve">
          <source>In the example above, we've created a global variable to temporarily store the computed value of our eval'ed expression. It is also possible and in most cases a better strategy to fetch the return value from</source>
          <target state="translated">上の例では、evalされた式の計算値を一時的に保存するためにグローバル変数を作成しました。から戻り値を取得することも可能ですし、ほとんどの場合はより良い方法です。</target>
        </trans-unit>
        <trans-unit id="215f011f187069670df6baefac97d219cfd4d544" translate="yes" xml:space="preserve">
          <source>In the example above, you can see that we passed &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; to &lt;code&gt;has()&lt;/code&gt; when creating our &lt;code&gt;is_on&lt;/code&gt; attribute. This tells &lt;code&gt;Moose&lt;/code&gt; that this attribute must be a boolean value. If we try to set it to an invalid value, our code will throw an error.</source>
          <target state="translated">上記の例では、 &lt;code&gt;is_on&lt;/code&gt; 属性を作成するときに &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; を &lt;code&gt;has()&lt;/code&gt; に渡したことがわかります。これは、この属性がブール値でなければならないことを &lt;code&gt;Moose&lt;/code&gt; に伝えます。それを無効な値に設定しようとすると、コードはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="7091546bde153dd7889f18e20c48c8bc55eaa567" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt; ) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">フィルタの例では、オブジェクト（ &lt;code&gt;$ref&lt;/code&gt; ）は他のPerlオブジェクトと同じように祝福されています。この例では無名配列を使用していますが、これは必須ではありません。この例ではコンテキスト情報を格納する必要がないため、スカラーまたはハッシュ参照も使用できます。次のセクションでは、コンテキストデータを示します。</target>
        </trans-unit>
        <trans-unit id="7cad79aaf9d1ce6eabd545156fa679d72897f6d5" translate="yes" xml:space="preserve">
          <source>In the example script below, the &lt;code&gt;match&lt;/code&gt; sub uses this feature to find and print the first matching key/value pair given a partial key.</source>
          <target state="translated">以下のスクリプト例では、 &lt;code&gt;match&lt;/code&gt; サブルーチンはこの機能を使用して、部分的なキーを指定して、最初に一致するキーと値のペアを見つけて出力します。</target>
        </trans-unit>
        <trans-unit id="874b0ca5f6d74bc36f1a8bf750e4d758cb8b0d1e" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">上記の例では、ファイルハンドルを使用する前にスカラー変数に割り当てました。これは、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、またはdiamond演算子のような組み込み関数で使用できるのは、ハッシュや配列の式や添え字ではなく、単純なスカラー変数だけだからです。単純なスカラー変数以外のものをファイルハンドルとして使用することは違法であり、コンパイルすらできません。</target>
        </trans-unit>
        <trans-unit id="1d5cb1050428e1b3c39a6dbeac5fa82c4e3ee30c" translate="yes" xml:space="preserve">
          <source>In the examples given to date, any temporaries created in the callback (i.e., parameters passed on the stack to the</source>
          <target state="translated">これまでの例では、コールバックで作成されたテンポラリ(つまり、スタック上で</target>
        </trans-unit>
        <trans-unit id="52df5ff09c57ff6bd4a65152023282e8e3fdf423" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt; , the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">拡張使用形式では、ダンプされる参照にユーザー指定の名前を付けることができます。名前が &lt;code&gt;*&lt;/code&gt; で始まる場合、出力には、ハッシュと配列、およびcoderefに指定された参照の逆参照型が記述されます。 &lt;code&gt;Terse&lt;/code&gt; フラグが設定されている場合、名前の出力は可能な限り回避されます。</target>
        </trans-unit>
        <trans-unit id="1e093183cde30fbf5834bc8c2f2306668f0a93ab" translate="yes" xml:space="preserve">
          <source>In the eyes of the operating system, pseudo-processes created via the fork() emulation are simply threads in the same process. This means that any process-level limits imposed by the operating system apply to all pseudo-processes taken together. This includes any limits imposed by the operating system on the number of open file, directory and socket handles, limits on disk space usage, limits on memory size, limits on CPU utilization etc.</source>
          <target state="translated">オペレーティングシステムから見れば、fork()エミュレーションによって作成された疑似プロセスは、単に同じプロセス内のスレッドに過ぎません。つまり、オペレーティングシステムによって課せられるプロセスレベルの制限は、すべての疑似プロセスに適用されます。これには、ファイル、ディレクトリ、ソケットハンドルのオープン数、ディスクスペースの使用量、メモリサイズの制限、CPU 使用率の制限など、オペレーティングシステムによって課せられる制限が含まれます。</target>
        </trans-unit>
        <trans-unit id="c87855f737ebcf54612bd0d985e7951567552bdc" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; . (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">上記の最後の例では、最初のASCII 16進数字はコードポイント48、文字「0」、およびそれから57までのすべてのコードポイント（「9」）はASCII 16進数字です。コードポイント58〜64はありませんが、97（ &quot;a&quot;）〜102（ &quot;f&quot;）と同様に、65（ &quot;A&quot;）〜70（ &quot;F&quot;）です。 103は、ASCII 16進数字ではないコードポイントの範囲を開始します。その範囲は無限大まで拡張されます。これは、コンピューターでは &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 変数で確認できます。 （この変数は、Perlがプラットフォームで取得できる限り無限に近く、一部の操作が機能するには高すぎる可能性があります。目的に応じて、より小さい数値を使用することもできます。）</target>
        </trans-unit>
        <trans-unit id="acc9782ed3f3e2b680013d144689804f90d54bf6" translate="yes" xml:space="preserve">
          <source>In the first example, an error handler, the flow of control could be as follows. You have created an interface to an external library. Control can reach the external library like this</source>
          <target state="translated">最初の例のエラーハンドラでは、制御の流れは次のようになります。外部ライブラリへのインターフェースを作成したとします。制御は次のように外部ライブラリに到達することができます。</target>
        </trans-unit>
        <trans-unit id="837426c8f21e7781853f5f83912529e607900661" translate="yes" xml:space="preserve">
          <source>In the first form, often referred to as a &quot;string eval&quot;, the return value of EXPR is parsed and executed as if it were a little Perl program. The value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This means, that in particular, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">最初の形式では、しばしば &quot;string eval &quot;と呼ばれ、EXPRの戻り値が解析され、小さなPerlプログラムであるかのように実行されます。式の値(これ自体はスカラコンテキスト内で決定されます)は最初に解析され、エラーがなければ、現在のPerlプログラムの語彙コンテキスト内のブロックとして実行されます。これは、特に、外部の字句変数はすべてそれを見ることができ、パッケージ変数の設定やサブルーチンやフォーマットの定義は、その後も残っていることを意味します。</target>
        </trans-unit>
        <trans-unit id="9907ef81620f333168bdff52969249681c5309f5" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt; . In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">最初の形式では、関数 &lt;code&gt;id_2obj()&lt;/code&gt; で使用するオブジェクトを登録します。2番目の形式では、指定されたハッシュ参照をガベージコレクション用にマークダウンします。これは、オブジェクトがスコープから外れると、 &lt;code&gt;id($obj)&lt;/code&gt; キーの下にある特定のハッシュのエントリがハッシュから削除されることを意味します。</target>
        </trans-unit>
        <trans-unit id="886a42840b4db0f0804225c4bdd1da338f8eaea4" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt; . In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">最初の形式では、匿名ハッシュが &lt;code&gt;$class&lt;/code&gt; クラスに祝福されています。2番目の形式では、匿名ハッシュが現在のパッケージに組み込まれています。</target>
        </trans-unit>
        <trans-unit id="5ba19d40237087370736921c2b055d0f9f4e8621" translate="yes" xml:space="preserve">
          <source>In the first two versions, the body of the subroutine is lexically in the main package,</source>
          <target state="translated">最初の2つのバージョンでは、サブルーチンの本体はメインパッケージに語彙的に含まれています。</target>
        </trans-unit>
        <trans-unit id="78475acfd51fd678e0727a44ada7dcef5de0bc33" translate="yes" xml:space="preserve">
          <source>In the first version above, you let the appropriate encoding layer handle the conversion. In the second, you explicitly translate from one encoding to the other.</source>
          <target state="translated">最初のバージョンでは、適切なエンコーディングレイヤーに変換処理を任せます。2番目のバージョンでは、あるエンコーディングから他のエンコーディングへの変換を明示的に行います。</target>
        </trans-unit>
        <trans-unit id="2414010bede2999a6fc168db89c621d8bb7bb77d" translate="yes" xml:space="preserve">
          <source>In the following all questions and explanations regarding config variables are collected.</source>
          <target state="translated">以下では、config変数に関するすべての質問と説明を収集しています。</target>
        </trans-unit>
        <trans-unit id="33eb6a227648440eaeed500f955607df47c5aa25" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;code&gt;$pad_len&lt;/code&gt; is the length to which you wish to pad the string, &lt;code&gt;$text&lt;/code&gt; or &lt;code&gt;$num&lt;/code&gt; contains the string to be padded, and &lt;code&gt;$pad_char&lt;/code&gt; contains the padding character. You can use a single character string constant instead of the &lt;code&gt;$pad_char&lt;/code&gt; variable if you know what it is in advance. And in the same way you can use an integer in place of &lt;code&gt;$pad_len&lt;/code&gt; if you know the pad length in advance.</source>
          <target state="translated">次の例では、 &lt;code&gt;$pad_len&lt;/code&gt; は文字列にパディングする長さ、 &lt;code&gt;$text&lt;/code&gt; または &lt;code&gt;$num&lt;/code&gt; はパディングされる文字列を含み、 &lt;code&gt;$pad_char&lt;/code&gt; はパディング文字を含みます。事前にわかっている場合は、 &lt;code&gt;$pad_char&lt;/code&gt; 変数の代わりに1文字の文字列定数を使用できます。同様に、パッドの長さが事前にわかっている場合は、 &lt;code&gt;$pad_len&lt;/code&gt; 代わりに整数を使用できます。</target>
        </trans-unit>
        <trans-unit id="76ac42f7d8b0a7d53378ec8bb6883cc947c8612a" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in precedence order.</source>
          <target state="translated">以下のセクションでは、これらの演算子を優先順位の高い順に説明します。</target>
        </trans-unit>
        <trans-unit id="4b178b275b86ca37ae6642cdcf850388ebe0add6" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt; ); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt; .</source>
          <target state="translated">次の表で、数字は優先順位を示します。たとえば、次の表は、 &lt;code&gt;'!'&lt;/code&gt; 実装がない場合、定義されている場合、Perlは &lt;code&gt;'bool'&lt;/code&gt; を使用してそれを実装します（つまり、 &lt;code&gt;'bool'&lt;/code&gt; メソッドから返された値を反転します）。ブール変換も実装されていない場合、Perlは &lt;code&gt;'0+'&lt;/code&gt; を使用するか、失敗すると &lt;code&gt;'&quot;&quot;'&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f8a38bcdad9de0c83d52fd95f8565a94b07788e8" translate="yes" xml:space="preserve">
          <source>In the following tables:</source>
          <target state="translated">以下の表では</target>
        </trans-unit>
        <trans-unit id="770598786b9fb05b86d05d808ab206b9dce08c07" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">3つ以上の引数を取るパイプオープンの形式で、LISTが指定されている場合（コマンド名の後に追加の引数）、LISTは、プラットフォームがサポートしている場合に呼び出されるコマンドの引数になります。非パイプモードで3つ以上の引数を使用して &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; の意味はまだ定義されていませんが、実験的な「レイヤー」は追加のLIST引数の意味を与える場合があります。</target>
        </trans-unit>
        <trans-unit id="351023ba55a42928810e8ea146d7f9a69c7e4007" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">3つ以上の引数を取るパイプオープンの形式で、LISTが指定されている場合（コマンド名の後に追加の引数）、LISTは、プラットフォームがサポートしている場合に呼び出されるコマンドの引数になります。非パイプモードで3つ以上の引数を使用して &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; の意味はまだ定義されていませんが、実験的な「レイヤー」は追加のLIST引数の意味を与える場合があります。</target>
        </trans-unit>
        <trans-unit id="0d9756e636c498fe9304eb168ab8f26e641d5c72" translate="yes" xml:space="preserve">
          <source>In the future, this module will likely use File::Spec for determining paths, as it does now for Mac OS (where Unix-style or Mac-style paths work, and Unix-style paths are converted properly to Mac-style paths before being added to @INC).</source>
          <target state="translated">将来的には、このモジュールは、現在の Mac OS 用のように、パスを決定するために File::Spec を使うことになるでしょう (Unix スタイルまたは Mac スタイルのパスが動作し、@INC に追加される前に Unix スタイルのパスが Mac スタイルのパスに適切に変換されます)。</target>
        </trans-unit>
        <trans-unit id="46cedf56be184729e0d91d65fc9c0d53cad92704" translate="yes" xml:space="preserve">
          <source>In the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">最後の例では、文字列の末尾を単語の境界とみなしています。</target>
        </trans-unit>
        <trans-unit id="6405a42cdbbb08be1356ae610a2c353a3021f6e3" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression, so we use &lt;code&gt;$1&lt;/code&gt; to replace the quoted string with just what was quoted. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regexp in the string:</source>
          <target state="translated">最後の例では、文字列全体が一致しましたが、単一引用符内の部分のみがグループ化されました。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、我々が使用してなど、交換式の使用のためにすぐに利用できる &lt;code&gt;$1&lt;/code&gt; 引用されたものだけを引用符で囲んだ文字列を置換します。グローバル修飾子を使用すると、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; は文字列内のすべての正規表現を検索して置き換えます。</target>
        </trans-unit>
        <trans-unit id="06c06ffd743a05cb45342ceadd66f34d1f6c47cc" translate="yes" xml:space="preserve">
          <source>In the last regex, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regex.</source>
          <target state="translated">最後の正規表現では、スラッシュ &lt;code&gt;'/'&lt;/code&gt; も正規表現を区切るために使用されるため、バックスラッシュが付けられます。</target>
        </trans-unit>
        <trans-unit id="11c4a29ccb7ab2ebd1eeaf108124208b060d0f4a" translate="yes" xml:space="preserve">
          <source>In the last regexp, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome), however, and it is often more readable to change delimiters.</source>
          <target state="translated">最後の正規表現では、スラッシュ &lt;code&gt;'/'&lt;/code&gt; も正規表現を区切るために使用されるため、バックスラッシュが付けられます。これはLTS（つまようじ症候群の傾き）につながる可能性がありますが、区切り文字を変更する方が読みやすい場合があります。</target>
        </trans-unit>
        <trans-unit id="3c351aa56c66843f422f8613ab5ba80764ad66e0" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, &lt;code&gt;'a'&lt;/code&gt; matches because the first character position in the string is the earliest point at which the regexp can match.</source>
          <target state="translated">最後の文では、たとえ &lt;code&gt;'c'&lt;/code&gt; クラスの最初の文字であり、 &lt;code&gt;'a'&lt;/code&gt; 文字列の最初の文字の位置は、正規表現を一致させることができる最も早い時点であるので、マッチ。</target>
        </trans-unit>
        <trans-unit id="eb7827ba059fba337cd380ecde1e864bd7488e84" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt; .</source>
          <target state="translated">最後のステートメントでは、 &lt;code&gt;'c'&lt;/code&gt; はクラスの最初の文字ですが、正規表現が一致できる最も早い時点は &lt;code&gt;'a'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3d9813d8232f26905286fe72c0fb88aaeece44db" translate="yes" xml:space="preserve">
          <source>In the latter case, characters that map to 0212 are first converted to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or 'geta mark') then fed to the decoding engine. U+FFFD is not used, in order to preserve text layout as much as possible.</source>
          <target state="translated">後者の場合、0212に対応する文字はまずU+3013(EUC-JPでは0xA2AE;「豆腐」や「下駄マーク」とも呼ばれる白い四角)に変換され、その後デコードエンジンに送られます。テキストレイアウトを可能な限り保持するため、U+FFFDは使用されません。</target>
        </trans-unit>
        <trans-unit id="a8f8d594e47a7aed4b47d21c04c8b5fc5ac50b38" translate="yes" xml:space="preserve">
          <source>In the latter, foo.h is taken as</source>
          <target state="translated">後者では、foo.h は</target>
        </trans-unit>
        <trans-unit id="9b81dfce26cb69eddfbb13b42d7a921ee8ba05af" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUBのパラメーターのリストでは、パラメーター名の前に &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; キーワードを付けることができます。 &lt;code&gt;IN&lt;/code&gt; キーワードがデフォルトです。他のキーワードは、PerlインターフェースとCインターフェースの違いを示します。</target>
        </trans-unit>
        <trans-unit id="6c32d4238ee6ff96fa8bb06b99ee3f8b0689422e" translate="yes" xml:space="preserve">
          <source>In the method descriptions below</source>
          <target state="translated">以下の方法の説明では</target>
        </trans-unit>
        <trans-unit id="1b237b2ec2e195bf52f7f15f0ad99e5a2c78e4b1" translate="yes" xml:space="preserve">
          <source>In the more general case, you can use the &lt;code&gt;/g&lt;/code&gt; modifier in a &lt;code&gt;while&lt;/code&gt; loop, keeping count of matches.</source>
          <target state="translated">より一般的なケースでは、 &lt;code&gt;while&lt;/code&gt; ループで &lt;code&gt;/g&lt;/code&gt; 修飾子を使用して、一致の数を維持できます。</target>
        </trans-unit>
        <trans-unit id="784f063825aaf77ec4d5f9b15d7c0e7efc2377c9" translate="yes" xml:space="preserve">
          <source>In the mylib directory, create a file mylib.h that looks like this:</source>
          <target state="translated">mylibディレクトリに、以下のようなファイルmylib.hを作成します。</target>
        </trans-unit>
        <trans-unit id="79fbf0c13d713302225cff8f61abd9dd7ac74b43" translate="yes" xml:space="preserve">
          <source>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</source>
          <target state="translated">次の段落では、ここで使用されている用語の簡単な説明に続きます(これらは他の人や文書によって使用されている用語と異なる場合があるため)。</target>
        </trans-unit>
        <trans-unit id="5152e34177e8a3d4c184b97093704f88de6ca9db" translate="yes" xml:space="preserve">
          <source>In the notation discussed so far, the characters &quot;[&quot; and &quot;]&quot; are given special meaning, for opening and closing bracket groups, and &quot;,&quot; has a special meaning inside bracket groups, where it separates items in the group. This begs the question of how you'd express a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and how you'd express a literal comma inside a bracket group. For this purpose I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot; means a literal '[' character anywhere in Bracket Notation (i.e., regardless of whether you're in a bracket group or not), and ditto for &quot;~]&quot; meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho &quot;,&quot; means a literal comma outside of bracket groups -- it's only inside bracket groups that commas are special.)</source>
          <target state="translated">これまで説明してきた記法では、「[&quot;」と「]&quot;」という文字はブラケットグループの開閉に特別な意味を持ち、「,」はブラケットグループの中で特別な意味を持ち、グループ内の項目を区切ることができます。これは、ブラケット記法の文字列の中でリテラルの&quot;[&quot;や&quot;]&quot;をどのように表現するのか、また、ブラケットグループの中でリテラルのカンマをどのように表現するのか、という疑問を投げかけています。この目的のために、エスケープ文字として &quot;~&quot; (チルダ)を採用しました。&quot;~[&quot; は、ブラケット記法のどこにいてもリテラル '[' 文字を意味します (つまり、ブラケットグループにいるかどうかに関係なく)。(「,」は大括弧グループの外ではリテラルカンマを意味しますが、カンマが特別なのは大括弧グループの中だけです)。</target>
        </trans-unit>
        <trans-unit id="9c42fcbdbf3cd24cfb1dac2e8ba1cbc829f18933" translate="yes" xml:space="preserve">
          <source>In the olden, less enlightened times, we all used to use ASCII. Most of us did, anyway. The big problem with ASCII is that it's American. Well, no, that's not actually the problem; the problem is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of it being a standard was lost.</source>
          <target state="translated">昔の、それほど啓蒙されていない時代には、みんなASCIIを使っていました。私たちのほとんどがそうでした。ASCIIの大きな問題は、それがアメリカのものだということです。問題は、ローマ字を使わない人にとっては特に便利なものではないということです。問題は、ローマ字を使わない人にとっては特に便利ではないということです。もちろん、その結果、ASCIIではない文字がたくさん出てきて、標準であることの意味が失われてしまいました。</target>
        </trans-unit>
        <trans-unit id="50b947f69a6b2d22a725a2d7ba0813fc1f66f21b" translate="yes" xml:space="preserve">
          <source>In the one case the code, which does exactly the same thing as far as outputting any debugging information is concerned, in other words nothing, takes 14 seconds, and in the other case the code takes one hundredth of a second. Looks fairly definitive. Use a &lt;code&gt;$DEBUG&lt;/code&gt; variable BEFORE you call the subroutine, rather than relying on the smart functionality inside it.</source>
          <target state="translated">デバッグ情報の出力に関する限りまったく同じことを行うコード、つまり何もない場合は14秒かかり、もう1つの場合は100分の1秒かかります。かなり決定的に見えます。サブルーチンを呼び出す前に、 &lt;code&gt;$DEBUG&lt;/code&gt; 変数を使用してください。サブルーチン内のスマートな機能に依存するのではありません。</target>
        </trans-unit>
        <trans-unit id="9cd2461949e5dab65a2af380d7f878aad8f12946" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">引数の1引数形式と2引数形式では、モードとファイル名を（この順序で）連結する必要があります。できれば空白で区切ります。モードが &lt;code&gt;&amp;lt;&lt;/code&gt; の場合、これらの形式でモードを省略できますが、省略してはなりません。filename引数が既知のリテラルである場合は、常に2引数形式の &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; を使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="6c1895cc93a277f17a7d9aa8c8fca89d99b0c8a2" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">引数の1引数形式と2引数形式では、モードとファイル名を（この順序で）連結する必要があります。できれば空白で区切ります。モードが &lt;code&gt;&amp;lt;&lt;/code&gt; の場合、これらの形式でモードを省略できますが、省略してはなりません。filename引数が既知のリテラルである場合は、常に2引数形式の &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; を使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="9baa512a702be95a00f5cdfa9d3fa8d7a2a0b696" translate="yes" xml:space="preserve">
          <source>In the opposite way, to resolve a hostname to the IP address you can write this:</source>
          <target state="translated">逆に、ホスト名をIPアドレスに解決するには、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="ecb2e91137fed6da0013b83630021f3d72198be0" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">オプション指定では、オプション名の後に等号 &lt;code&gt;=&lt;/code&gt; と文字 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; が続きます。等号は、このオプションに値が必要であることを示します。文字 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; は、この値が任意の文字列であることを示します。他に考えられる値の型は、整数値の場合は &lt;code&gt;i&lt;/code&gt; 、浮動小数点値の場合は &lt;code&gt;f&lt;/code&gt; です。コロンを使用した &lt;code&gt;:&lt;/code&gt; 等号の代わりには、オプションの値がオプションであることを示しています。この場合、適切な値が指定されていないと、文字列値のオプションには空の文字列 &lt;code&gt;''&lt;/code&gt; が割り当てられますが、数値オプションには &lt;code&gt;0&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="53db56988ad2d32c572da0df498153024ad7a10e" translate="yes" xml:space="preserve">
          <source>In the past, the Perl community experimented with a technique called &quot;inside-out objects&quot;. An inside-out object stores its data outside of the object's reference, indexed on a unique property of the object, such as its memory address, rather than in the object itself. This has the advantage of enforcing the encapsulation of object attributes, since their data is not stored in the object itself.</source>
          <target state="translated">過去に Perl コミュニティでは、「インサイドアウト・オブジェクト」と呼ばれる技術を実験的に使用していました。インサイドアウトオブジェクトは、そのデータをオブジェクトの参照の外側に保存し、オブジェクト自体ではなく、そのメモリアドレスのようなオブジェクトのユニークなプロパティにインデックスを付けます。これは、オブジェクトの属性のデータがオブジェクト自体に保存されないので、オブジェクトの属性のカプセル化を強制するという利点があります。</target>
        </trans-unit>
        <trans-unit id="8a3a725cb056826efb62b17fb21f5a5c69a3ce79" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">過去には、大手 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; オプションでしたが、省略すると非推奨の警告が表示されます。 v5.22.0以降では、省略すると構文エラーが発生します。古いコードでこの構造に遭遇した場合は、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; を追加するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="3a63857af592db7e75d88e816c7c7a1180f9eb89" translate="yes" xml:space="preserve">
          <source>In the pathological case that a script is called via a relative path</source>
          <target state="translated">スクリプトが相対パスを経由して呼び出されるという病理学的なケースでは</target>
        </trans-unit>
        <trans-unit id="b5cb98f00aa6aaa22eb71c271690cbb1ebc9df81" translate="yes" xml:space="preserve">
          <source>In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot; and after the &quot;m&quot;. These patterns match /\Bam\B/:</source>
          <target state="translated">パターン/\Bam\B/では、&quot;a &quot;の前と &quot;m &quot;の後に単語の文字があるはず。これらのパターンは、/\\BamB/と一致する。</target>
        </trans-unit>
        <trans-unit id="d454ee791b9ae0c5bbb81657f656033f3c0c5a24" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">特殊な &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; フォームでは、VERSIONは、5.006などの正の小数であり、 &lt;code&gt;$]&lt;/code&gt; と比較されます。または、フォームv5.6.1のv文字列で、 &lt;code&gt;$^V&lt;/code&gt; （別名$ PERL_VERSION）。 VERSIONが現在のPerlインタープリターのバージョンより大きい場合、例外が発生します。 Perlは残りのファイルの解析を試みません。実行時に同様のチェックを実行できる&lt;a href=&quot;#require&quot;&gt;requireと&lt;/a&gt;比較してください。対称的に、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 、あなたが指定したものより古いバージョンのPerlをしたいことを指定することができません。</target>
        </trans-unit>
        <trans-unit id="74d3b7e92857ff92a78ee1a11cb1e6022b249cb3" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">特殊な &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; フォームでは、VERSIONは、5.006などの正の小数であり、 &lt;code&gt;$]&lt;/code&gt; と比較されます。または、フォームv5.6.1のv文字列で、 &lt;code&gt;$^V&lt;/code&gt; （別名$ PERL_VERSION）。 VERSIONが現在のPerlインタープリターのバージョンより大きい場合、例外が発生します。 Perlは残りのファイルの解析を試みません。実行時に同様のチェックを実行できる&lt;a href=&quot;require&quot;&gt;requireと&lt;/a&gt;比較してください。対称的に、 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 、あなたが指定したものより古いバージョンのPerlをしたいことを指定することができません。</target>
        </trans-unit>
        <trans-unit id="a5da666074fc2ec75362b3b68f86858be734f6e9" translate="yes" xml:space="preserve">
          <source>In the presence of multiple classes it can be non-trivial to make sure that every relevant destructor is called for every object. Perl calls the first one it finds on the inheritance tree (if any) and that's it.</source>
          <target state="translated">複数のクラスが存在する場合、すべてのオブジェクトに関連するデストラクタが確実に呼び出されるようにすることは容易ではありません。Perl は継承ツリー上で最初に見つけたものを(もしあれば)呼び出し、それで終わりです。</target>
        </trans-unit>
        <trans-unit id="cd34d34a3c68755abc29d11ed297638bd9fdb29d" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt; ). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt; ). It should also set &lt;code&gt;subcoffset&lt;/code&gt; , the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">存在下で &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; のフラグが、添加と &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 又は &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; （それがまだ存在下で行う必要があるがフラグ、エンジンが完全なバッファをコピーしないことを選択することができ &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; またはに設定されている関連ビット &lt;code&gt;PL_sawampersand&lt;/code&gt; ） 。この場合、 &lt;code&gt;suboffset&lt;/code&gt; を設定して、バッファの論理的開始から物理的開始までのバイト数（つまり、 &lt;code&gt;subbeg&lt;/code&gt; ）を示すことができます。また、オフセットの文字数である &lt;code&gt;subcoffset&lt;/code&gt; も設定する必要があります。後者は、バイトではなく文字で機能する &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; をサポートするために必要です。</target>
        </trans-unit>
        <trans-unit id="b073c0a34c41b3ba5f06418d694ba351020d4acc" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt; , and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">前の例では、1つの関数だけがその参照を記憶しているため、関数プライベート変数を作成しました。変数がスコープ内にある間に複数の関数を定義でき、各関数は「プライベート」変数を共有できます。レキシカル変数がスコープ内にあるときに関数の外でアクセスでき、それへの参照を作成することもできるため、実際には「静的」ではありません。この例では、 &lt;code&gt;increment_count&lt;/code&gt; と &lt;code&gt;return_count&lt;/code&gt; が変数を共有しています。 1つの関数は値に追加し、もう1つの関数は単に値を返します。どちらも &lt;code&gt;$count&lt;/code&gt; にアクセスできます。また、スコープから外れたため、他の方法でアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="d099eddc17fd02123a62f3b5a7b0e3fc3ac46d20" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt; . In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">前の例では、 &lt;code&gt;{}&lt;/code&gt; コードは空の匿名ハッシュへの参照を作成します。次に &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数はその参照を受け取り、ハッシュを &lt;code&gt;$class&lt;/code&gt; クラスに関連付けます。最も単純なケースでは、 &lt;code&gt;$class&lt;/code&gt; 変数には文字列「File」が含まれます。</target>
        </trans-unit>
        <trans-unit id="c1001ba58ff0530a993f349b4836f78782ab43f8" translate="yes" xml:space="preserve">
          <source>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</source>
          <target state="translated">前のセクションでは、実際のメッセージにバイナリメッセージの長さの接頭辞を付けて構築されたネットワークメッセージを見てきました。ヌルバイトがデータの一部である可能性がある場合、ヌルバイトを追加してもうまくいかないので、データの長さの後に何バイトものデータを追加するのは、よく使われる方法だとわかります。ここでは、両方のテクニックを使用した例を示します:送信元と宛先のアドレスを持つ2つのNULL終端文字列の後に、ショートメッセージ(携帯電話への)が長さのバイトの後に送信されます。</target>
        </trans-unit>
        <trans-unit id="4d306b4b58fb980badf24b06473c4af8a30ac12e" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; および &lt;code&gt;V&lt;/code&gt; を使用して、ビッグエンディアンまたはリトルエンディアンのバイト順で整数をパックおよびアンパックする方法を学びました。これはすばらしいことですが、64ビット整数だけでなく、あらゆる種類の符号付き整数が除外されているため、かなり制限があります。たとえば、プラットフォームに依存しない方法で一連の符号付きビッグエンディアン16ビット整数をアンパックする場合は、次のように記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="4bb18f0a7b082417093abe50cb091ae0ce9d7c1a" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt; . If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">特定の定数がこのモジュールを介して宣言されているかどうかを実行時に検出する必要があるまれなケースでは、この関数を使用してハッシュ &lt;code&gt;%constant::declared&lt;/code&gt; を調べることができます。指定された定数名にパッケージ名が含まれていない場合、現在のパッケージが使用されます。</target>
        </trans-unit>
        <trans-unit id="b3168d71bbd1d6362a03e87b3b6357cbc463ee97" translate="yes" xml:space="preserve">
          <source>In the scalar context, returns the modified collator (but it is &lt;b&gt;not&lt;/b&gt; a clone from the original).</source>
          <target state="translated">スカラーコンテキストでは、変更されたコレーターを返します（ただし、元のクローンからのクローンではあり&lt;b&gt;ません&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e123d33b9c36acd15c038a592d06bccf26e5a4c" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; フォームのスコープでは、Perlは &lt;code&gt;LC_CTYPE&lt;/code&gt; ロケール設定に従います。これは、文字がアルファベット、数字、句読点であるというアプリケーションの概念を制御します。</target>
        </trans-unit>
        <trans-unit id="ea3c9a616e33a3cad4631e8af654cde72ce4e1bd" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">Perlは、照合を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; フォームのスコープ内で、 &lt;code&gt;LC_COLLATE&lt;/code&gt; 環境変数を調べて、文字の照合（順序）に関するアプリケーションの概念を決定します。たとえば、「b」はラテンアルファベットで「a」の後に続きますが、「&amp;aacute;」と「&amp;aring;」はどこに属しますか？そして、「色」は英語では「チョコレート」に続きますが、伝統的なスペイン語ではどうですか？</target>
        </trans-unit>
        <trans-unit id="85dc6b4df5881b7609167c49737d8fd061975bdc" translate="yes" xml:space="preserve">
          <source>In the second example, an event driven program, the flow of control will be more like this</source>
          <target state="translated">2 番目の例では、イベント駆動型のプログラムの場合、制御の流れは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0aec5f41df04fa608d73972b5b60d0e21665dd44" translate="yes" xml:space="preserve">
          <source>In the second example, however, we have stored another reference to the tied object in $x. That means that when untie() gets called there will still be a valid reference to the object in existence, so the destructor is not called at that time, and thus the file is not closed. The reason there is no output is because the file buffers have not been flushed to disk.</source>
          <target state="translated">しかし、二番目の例では、紐付けられたオブジェクトへの別の参照を $x に保存しています。つまり、 untie()がコールされたときには、そのオブジェクトへの有効な参照がまだ存在していることになります。出力がないのは、ファイルバッファがディスクにフラッシュされていないからです。</target>
        </trans-unit>
        <trans-unit id="69631891c8053c89e0b6bca3447bddf1c255a6c7" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">2番目の形式では、BLOCK内のコードが1回だけ解析され、同時に &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体を囲むコードが解析され、現在のPerlプログラムのコンテキスト内で実行されます。このフォームは通常、最初の例外（下記参照）よりも効率的に例外をトラップするために使用されますが、コンパイル時にBLOCK内のコードをチェックするという利点もあります。</target>
        </trans-unit>
        <trans-unit id="4a4b1f50ba31b2407de5a923935b79599705457e" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">2番目の形式では、BLOCK内のコードが1回だけ解析され、同時に &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体を囲むコードが解析され、現在のPerlプログラムのコンテキスト内で実行されます。このフォームは通常、最初の例外（下記参照）よりも効率的に例外をトラップするために使用されますが、コンパイル時にBLOCK内のコードをチェックするという利点もあります。</target>
        </trans-unit>
        <trans-unit id="0d9a2ff0446afe648b7cb9385c3e87c463ddf6fa" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second 'the'.</source>
          <target state="translated">2番目の一致では、正規表現が文字列の最初の文字位置で一致して停止したため、 &lt;code&gt;$`&lt;/code&gt; は &lt;code&gt;''&lt;/code&gt; に等しくなります。2番目の「the」を見たことはありません。</target>
        </trans-unit>
        <trans-unit id="37e9c3cdd59dd9ca84f70e11b37a63713067a365" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt; . This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">2番目のステップでは、実装の無料の継承可能性（またはその欠如）が示されます。この目的のために、 &lt;code&gt;Name&lt;/code&gt; の共通サブクラスである &lt;code&gt;NamedFile&lt;/code&gt; というクラスと標準クラス &lt;code&gt;IO::File&lt;/code&gt; 構築します。これは、 &lt;code&gt;IO::File&lt;/code&gt; オブジェクトのため、継承性をテストに入れます。</target>
        </trans-unit>
        <trans-unit id="979450caa584768989298a5e328245eeac253de3" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">厳密には、それを行うことはできません。スクリプトは、開始されたシェルとは異なるプロセスとして実行されます。プロセスへの変更は、その親には反映されません。変更後に作成された子にのみ反映されます。シェルマジックには、シェルのスクリプトの出力を &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; することで偽造できるものがあります。詳しくはcomp.unix.questions FAQをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8d5c6294b971049c13607515864de8d9b4202e94" translate="yes" xml:space="preserve">
          <source>In the symbian subdirectory there is</source>
          <target state="translated">symbian サブディレクトリには</target>
        </trans-unit>
        <trans-unit id="a6664c3e7887f18c07bf996abcbf98da47057e7d" translate="yes" xml:space="preserve">
          <source>In the syntax descriptions that follow, list operators that expect a list (and provide list context for elements of the list) are shown with LIST as an argument. Such a list may consist of any combination of scalar arguments or list values; the list values will be included in the list as if each individual element were interpolated at that point in the list, forming a longer single-dimensional list value. Commas should separate literal elements of the LIST.</source>
          <target state="translated">以下の構文の説明では、リストを期待する(リストの要素にリストコンテキストを提供する)リスト演算子は、LISTを引数として示しています。そのようなリストは、スカラー引数またはリスト値の任意の組み合わせで構成されることができます;リスト値は、各個別の要素がリストのその時点で補間され、より長い一次元のリスト値を形成しているかのようにリストに含まれます。カンマはLISTのリテラル要素を区切るべきである。</target>
        </trans-unit>
        <trans-unit id="fe67245ac84887f626543e24a3e6a624b4a7332b" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt; . (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt; ) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie（）呼び出しで、 &lt;code&gt;VARIABLE&lt;/code&gt; はエンチャントされる変数の名前です。 &lt;code&gt;CLASSNAME&lt;/code&gt; は、正しいタイプのオブジェクトを実装するクラスの名前です。 &lt;code&gt;LIST&lt;/code&gt; 内の追加の引数は、そのクラスの適切なコンストラクタメソッドに渡されます。つまり、TIESCALAR（）、TIEARRAY（）、TIEHASH（）、またはTIEHANDLE（）です。 （通常、これらはCのdbminit（）関数に渡される可能性があるような引数です。）「new」メソッドによって返されるオブジェクトは、tie（）関数によっても返されます。これは、他のメソッドにアクセスしたい場合に役立ちます。で &lt;code&gt;CLASSNAME&lt;/code&gt; 。 （実際に正しい「タイプ」への参照を返す必要はありません（たとえば、HASHまたは &lt;code&gt;CLASSNAME&lt;/code&gt; ）適切に祝福されたオブジェクトである限り。）また、tied（）関数を使用して、基になるオブジェクトへの参照を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="72e605f529d11854bba56a166fe10700b1dd88fb" translate="yes" xml:space="preserve">
          <source>In the two-argument (and one-argument) form, opening &lt;code&gt;&amp;lt;-&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; opens STDIN and opening &lt;code&gt;&amp;gt;-&lt;/code&gt; opens STDOUT.</source>
          <target state="translated">2つの引数（および1つの引数）の形式では、 &lt;code&gt;&amp;lt;-&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; を開くとSTDINが開き、 &lt;code&gt;&amp;gt;-&lt;/code&gt; を開くとSTDOUTが開きます。</target>
        </trans-unit>
        <trans-unit id="305b7a93b43681322f3469e0f0cb84a704ec6817" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt; ) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">より複雑な初期化を必要とするSVのまれなケースでは、newSV（len）を使用して空のSVを作成できます。 &lt;code&gt;len&lt;/code&gt; が0の場合、タイプNULLの空のSVが返されます。それ以外の場合、タイプPVのSVは、SvPVXを介してアクセス可能なlen + 1（ &lt;code&gt;NUL&lt;/code&gt; の場合）バイトのストレージで返されます。どちらの場合も、SVにはundef値があります。</target>
        </trans-unit>
        <trans-unit id="e08f73822da4db28b0244d63be2806e6742a13f9" translate="yes" xml:space="preserve">
          <source>In the words of Chaim Frenkel: &quot;Perl's grammar can not be reduced to BNF. The work of parsing perl is distributed between yacc, the lexer, smoke and mirrors.&quot;</source>
          <target state="translated">Chaim Frenkelの言葉を借りれば、「Perlの文法はBNFに還元することはできない。Perlを解析する作業は、yacc、レキサー、煙と鏡の間に分散されています。&quot;</target>
        </trans-unit>
        <trans-unit id="eea8935b77be896004ea3b86596d8c4b9f389127" translate="yes" xml:space="preserve">
          <source>In the work crew model, several threads are created that do essentially the same thing to different pieces of data. It closely mirrors classical parallel processing and vector processors, where a large array of processors do the exact same thing to many pieces of data.</source>
          <target state="translated">ワーククルーモデルでは、複数のスレッドが作成され、異なるデータに対して本質的に同じことを行います。これは、大規模なプロセッサの配列が多くのデータに対して全く同じことを行う古典的な並列処理やベクトルプロセッサと密接に関係しています。</target>
        </trans-unit>
        <trans-unit id="c55ef95af3c2d0a3702a06238a73d0da82b1e62b" translate="yes" xml:space="preserve">
          <source>In the year 2010 App::cpanminus was launched as a new approach to a cpan shell with a considerably smaller footprint. Very cool stuff.</source>
          <target state="translated">2010年、App::cpanminusは、かなり小さなフットプリントを持つcpanシェルへの新しいアプローチとして発表されました。非常にクールな内容です。</target>
        </trans-unit>
        <trans-unit id="113762dd3316218250364ac4d21aa3eda82fed63" translate="yes" xml:space="preserve">
          <source>In theory &lt;code&gt;Strtol&lt;/code&gt; and &lt;code&gt;Strtoul&lt;/code&gt; may not be defined if the machine perl is built on doesn't actually have strtol and strtoul. But as those 2 functions are part of the 1989 ANSI C spec we suspect you'll find them everywhere by now.</source>
          <target state="translated">理論 &lt;code&gt;Strtol&lt;/code&gt; 、perlが構築されているマシンに実際にstrtolとstrtoulがない場合、Strtolと &lt;code&gt;Strtoul&lt;/code&gt; は定義されない可能性があります。しかし、これらの2つの関数は1989年のANSI C仕様の一部であるため、今ではどこにでも見つかると思います。</target>
        </trans-unit>
        <trans-unit id="d524f396baff67e45d81dc7f8d13d5cf1e77d980" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">理論的には、 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; は-2 ** 63から2 ** 63-1まで信頼できます。ただし、実装での回避策は浮動小数点数を使用するため、時間が長くなると不正確になります。これはバグであり、将来修正される予定です。</target>
        </trans-unit>
        <trans-unit id="cbe5df9e111a076eb83a7b1ca2b907e2c293b988" translate="yes" xml:space="preserve">
          <source>In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined. The defined test avoids problems where the line has a string value that would be treated as false by Perl; for example a &quot;&quot; or a &lt;code&gt;&quot;0&quot;&lt;/code&gt; with no trailing newline. If you really mean for such values to terminate the loop, they should be tested for explicitly:</source>
          <target state="translated">これらのループ構造では、割り当てられた値（割り当てが自動か明示か）がテストされ、定義されているかどうかが確認されます。定義されたテストは、Perlによってfalseとして扱われる文字列値が行に含まれるという問題を回避します。たとえば、末尾に改行がない「」または &lt;code&gt;&quot;0&quot;&lt;/code&gt; 。そのような値がループを終了することを本当に意味している場合は、明示的にテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e44b8059bd25cac80d7a80701ceeb87c0cc485a" translate="yes" xml:space="preserve">
          <source>In this -exec rendering, each opcode is executed in the order shown. The add opcode, marked with '*', is discussed in more detail.</source>
          <target state="translated">この -exec レンダリングでは、各オペコードが表示された順に実行されます。'*' でマークされた add オプコードについては、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="fd1f4af2f36f22296f6e12cb734299d228fd203a" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt; . If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">この代替では、 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 前に &lt;code&gt;'\d+\.'&lt;/code&gt; \ d +」を置くことが重要です。。 &lt;code&gt;'\d+\.'&lt;/code&gt; 場合 最初は、正規表現が喜んでそれに一致し、数値の小数部分を無視します。</target>
        </trans-unit>
        <trans-unit id="c0e19afab75cca33f669db41034484d08b958820" translate="yes" xml:space="preserve">
          <source>In this call,</source>
          <target state="translated">この電話では</target>
        </trans-unit>
        <trans-unit id="6f085ed6c4e3052eb0bb052f156e9a4157a1fe5d" translate="yes" xml:space="preserve">
          <source>In this call, the two arrays will be populated as shown below (for Unicode 6.0):</source>
          <target state="translated">この呼び出しでは、以下のように2つの配列が入力されます(Unicode 6.0の場合)。</target>
        </trans-unit>
        <trans-unit id="9ebdd72fd702032acef9641f741ed417c8e827d9" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;IO::Compress::Zip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields.</source>
          <target state="translated">この場合、 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; は、 &lt;code&gt;$rawdata&lt;/code&gt; が0個以上の適合サブフィールドで構成されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="7445390dec364c96fb636b6c3a3e08bbc004467f" translate="yes" xml:space="preserve">
          <source>In this case a possible way around this problem is to predefine a series of C functions to act as the interface to Perl, thus</source>
          <target state="translated">この場合、この問題を回避する方法としては、Perlへのインターフェースとして動作する一連のC関数を事前に定義しておくことです。</target>
        </trans-unit>
        <trans-unit id="e58eeb1fce65fa0151692bc12dbf74ccd83c8127" translate="yes" xml:space="preserve">
          <source>In this case it is possible to speed up the routine (often quite substantially) by using the lightweight callback API. The idea is that the calling context only needs to be created and destroyed once, and the sub can be called arbitrarily many times in between.</source>
          <target state="translated">この場合、軽量コールバック API を使用することで、ルーチンを高速化することができます (多くの場合、かなり大幅に)。呼び出しコンテキストは一度だけ作成して破棄する必要があり、その間にサブを任意に何度も呼び出すことができるという考え方です。</target>
        </trans-unit>
        <trans-unit id="7a45b342cd0260187347347f25fa6f1ce0fc4500" translate="yes" xml:space="preserve">
          <source>In this case the flow of control can consist of only the repeated sequence</source>
          <target state="translated">この場合、制御の流れは、繰り返しのシーケンスのみで構成することができます。</target>
        </trans-unit>
        <trans-unit id="de52280d051bfe1e84ce26c045f4bd463f4ae0ee" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">この場合、関数 &lt;code&gt;fn1&lt;/code&gt; 、 &lt;code&gt;fn2&lt;/code&gt; 、および &lt;code&gt;fn3&lt;/code&gt; は、呼び出されるPerlサブルーチンを記憶するために使用されます。それぞれの関数は、 &lt;code&gt;Map&lt;/code&gt; 配列にアクセスして実際にPerlサブルーチンを呼び出すために関数 &lt;code&gt;Pcb&lt;/code&gt; で使用される個別のハードワイヤードインデックスを保持します。</target>
        </trans-unit>
        <trans-unit id="4ba717b73fce507fddc399244f240ef5b6f054dd" translate="yes" xml:space="preserve">
          <source>In this case the input fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; will be transformed into this Perl regular expression</source>
          <target state="translated">この場合、入力ファイルglob &lt;code&gt;*.tar.gz&lt;/code&gt; はこのPerl正規表現に変換されます</target>
        </trans-unit>
        <trans-unit id="779676f9752f28e10579e10de2beca329de72fea" translate="yes" xml:space="preserve">
          <source>In this case the main point to note is that only the last item in the list is returned from the subroutine.</source>
          <target state="translated">この場合の注意点は、サブルーチンからリストの最後の項目だけが返ってくることです。</target>
        </trans-unit>
        <trans-unit id="570da359699c43b4bafeef5621d77b9bbf97eae1" translate="yes" xml:space="preserve">
          <source>In this case the program will be run multiple times using each target file.</source>
          <target state="translated">この場合、各ターゲットファイルを使用して複数回実行されます。</target>
        </trans-unit>
        <trans-unit id="2b0f3bc0334984124b9519a2c06691727251a21f" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt; . We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">この場合、文字列には &lt;code&gt;foo&lt;/code&gt; が含まれている必要があり、その後ろに &lt;code&gt;bar&lt;/code&gt; が続く必要があります。これらの文字列の場所を見つけるために、 &lt;code&gt;fbm_instr()&lt;/code&gt; で実装されているFast Boyer-Mooreマッチングを使用できます。それらが存在しない場合は、はるかに高価な正規表現エンジンに頼る必要はありません。さらに良いことに、それらが存在する場合は、それらの位置を使用して、パターン全体が一致するかどうかを判断するために正規表現エンジンがカバーする必要がある検索スペースを減らすことができます。</target>
        </trans-unit>
        <trans-unit id="7adf1e07cf7e2de470c351018728e0b1e6d507de" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">この場合、クローンされるアイテムの代わりに &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が使用されます。ゼロに設定した場合：</target>
        </trans-unit>
        <trans-unit id="6c66364cb0f3415ad0b76d2776349bcfcc95f50e" translate="yes" xml:space="preserve">
          <source>In this case, because the &lt;code&gt;JMPENV&lt;/code&gt; level recorded in the &lt;code&gt;CxEVAL&lt;/code&gt; differs from the current one, &lt;code&gt;docatch&lt;/code&gt; just does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; and the C stack unwinds to:</source>
          <target state="translated">この場合、ため &lt;code&gt;JMPENV&lt;/code&gt; のに記録レベル &lt;code&gt;CxEVAL&lt;/code&gt; の現在のものと異なる、 &lt;code&gt;docatch&lt;/code&gt; はちょうどし &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ：およびCスタック展開を</target>
        </trans-unit>
        <trans-unit id="38ba605349bb20448e174208a445c574b3bbbe89" translate="yes" xml:space="preserve">
          <source>In this case, if</source>
          <target state="translated">この場合、もし</target>
        </trans-unit>
        <trans-unit id="bb541d2c2f3bc8d3faf27ff1a86aae9a349b1c56" translate="yes" xml:space="preserve">
          <source>In this case, it finds a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File&lt;/code&gt; class. Note that the object passed to &lt;code&gt;save()&lt;/code&gt; in this case is still a &lt;code&gt;File::MP3&lt;/code&gt; object, even though the method is found in the &lt;code&gt;File&lt;/code&gt; class.</source>
          <target state="translated">この場合、 &lt;code&gt;File&lt;/code&gt; クラスで &lt;code&gt;save()&lt;/code&gt; メソッドを見つけます。この場合に &lt;code&gt;save()&lt;/code&gt; に渡されるオブジェクトは、メソッドが &lt;code&gt;File&lt;/code&gt; クラスにある場合でも、 &lt;code&gt;File::MP3&lt;/code&gt; オブジェクトであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d9ed12158dee993299753ff9f1084ddd79644a4a" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt; s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">この場合、BEGINへのアクティブな参照がないため、BEGINは実行直後に解放されます &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; サブプロトタイプは、クロージャーではないためCvWEAKOUTSIDEが設定されており、$ aは同じCVを指しているため、BEGINの原因にはなりません。 refcountのどちらか。$ aが実行されると、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; によって &lt;code&gt;CvOUTSIDE&lt;/code&gt; のチェーンが追跡され、解放されたBEGINがアクセスされます。</target>
        </trans-unit>
        <trans-unit id="445e238a2cf161c353789dd6ff6ac3c0dc14cd3f" translate="yes" xml:space="preserve">
          <source>In this case, the data flow from the pipeline can be represented as follows:</source>
          <target state="translated">この場合、パイプラインからのデータフローは以下のように表すことができる。</target>
        </trans-unit>
        <trans-unit id="76ef174320084e5b9df3d70ddc86b3f46c5bccd4" translate="yes" xml:space="preserve">
          <source>In this case, the function will overload both of the three way comparison operators. For all overload operations using non-alpha characters, you must type the parameter without quoting, separating multiple overloads with whitespace. Note that &quot;&quot; (the stringify overload) should be entered as \&quot;\&quot; (i.e. escaped).</source>
          <target state="translated">この場合、この関数は 3 者間比較演算子の両方をオーバーロードします。アルファ文字以外の文字を使用するすべてのオーバーロード操作では、複数のオーバーロードを空白で区切って、クォートせずにパラメータを入力する必要があります。&quot;&quot; (文字列化オーバーロード)は、&quot;&quot;\&quot;\&quot; (つまりエスケープされた)と入力する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d4b7be359855c6b427d300bbc65846d64f8cf9d" translate="yes" xml:space="preserve">
          <source>In this case, the reference count for the variables will never reach 0, and the references will never be garbage-collected. This can lead to memory leaks.</source>
          <target state="translated">この場合、変数の参照カウントが0になることはありませんし、その参照がガーベージコレクションされることもありません。これはメモリリークにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="cc6f51a2de8f8d888eeb99016141d99a3d195bd9" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details.</source>
          <target state="translated">この場合、yes-patternが直接実行されることはなく、no-patternは許可されません。精神的には &lt;code&gt;(?{0})&lt;/code&gt; に似ていますが、より効率的です。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="18c031d44e01689714a7d1be31709243cd683ac5" translate="yes" xml:space="preserve">
          <source>In this case, there's not much to see, but of course normally there's pages of stuff to wade through, and 'l' can be very useful. To reset your view to the line we're about to execute, type a lone period '.':</source>
          <target state="translated">この場合、あまり見るべきものはありませんが、もちろん通常は何ページものページがあり、'l' は非常に便利です。これから実行しようとしている行にビューをリセットするには、ピリオド '.' を入力してください。</target>
        </trans-unit>
        <trans-unit id="d6cf564bd8d8897a564d43efb035ccf8128bfa59" translate="yes" xml:space="preserve">
          <source>In this case, you cannot omit the first</source>
          <target state="translated">この場合、最初の</target>
        </trans-unit>
        <trans-unit id="c6ff251bc24fa4db8e24130b2fd6042c3837352e" translate="yes" xml:space="preserve">
          <source>In this case, you use the &lt;code&gt;detach()&lt;/code&gt; method. Once a thread is detached, it'll run until it's finished; then Perl will clean up after it automatically.</source>
          <target state="translated">この場合、 &lt;code&gt;detach()&lt;/code&gt; メソッドを使用します。スレッドが切り離されると、完了するまで実行されます。その後、Perlはその後自動的にクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="f06a2a722f183edc4aa583848f94d04c7c5ace33" translate="yes" xml:space="preserve">
          <source>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn't do Y, it's against this specification, and should really be fixed. &quot;X should do Y&quot; means that it's recommended, but X may fail to do Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be</source>
          <target state="translated">このドキュメントでは、&quot;must&quot;/&quot;must not&quot;、&quot;should&quot;/&quot;should not&quot;、および &quot;may&quot; は、従来の (RFC 2119 参照)意味を持っています。&quot;X must do Y&quot; は、もし X が Y をしなければ、それはこの仕様に反しており、本当に修正されるべきだということを意味します。&quot;X should do Y &quot;は、それが推奨されているが、正当な理由があれば、XはYをしないかもしれないということを意味します。&quot;X may do Y&quot; は、単に X が自由に Y をすることができるという注意書きに過ぎません (ただし、&quot;and I think it would be the</target>
        </trans-unit>
        <trans-unit id="f65b8f5200f2d0ab93731dfb5d397ad4f5889d0a" translate="yes" xml:space="preserve">
          <source>In this documentation, &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; on the first line of the program will stand in for whatever method works on your system. You are advised to use a specific path if you care about a specific version.</source>
          <target state="translated">このドキュメントでは、プログラムの最初の行の &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; が、システムで機能するすべてのメソッドの代わりになります。特定のバージョンを気にする場合は、特定のパスを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="317bfd052c319e12e1dcc797f6ad498f8171149f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;--all&lt;/code&gt; will</source>
          <target state="translated">この例では、 &lt;code&gt;--all&lt;/code&gt; will</target>
        </trans-unit>
        <trans-unit id="e92bf3ad9ffe37a0d52db0112f7aacb357e3a712" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt; , which can see the new &lt;code&gt;$x&lt;/code&gt; . A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt; .</source>
          <target state="translated">この例では、 &lt;code&gt;whatever&lt;/code&gt; が呼び出されても新しい &lt;code&gt;$x&lt;/code&gt; が作成され、新しい &lt;code&gt;$x&lt;/code&gt; 表示できる新しい &lt;code&gt;inner&lt;/code&gt; も作成されます。「状態」のサブだけで表示されます &lt;code&gt;$x&lt;/code&gt; への最初の呼び出しから &lt;code&gt;whatever&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd205d2b3e2dec6816acf70e5f088db6d1ebf4c2" translate="yes" xml:space="preserve">
          <source>In this example, only the first two assignments will be done immediately; after this, all the changes to the file will be deferred up to the user-specified memory limit.</source>
          <target state="translated">この例では、最初の2つの割り当てだけがすぐに行われ、その後、ファイルへのすべての変更は、ユーザーが指定したメモリ制限まで延期されます。</target>
        </trans-unit>
        <trans-unit id="19c920ce6f8f3e81b20912d17931330182ad0a53" translate="yes" xml:space="preserve">
          <source>In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes. This will demonstrate manipulation of complex Perl data types from an XSUB.</source>
          <target state="translated">この例では、入力パラメータとして配列への参照を受け取り、ハッシュの配列への参照を返します。これは、XSUBから複雑なPerlのデータ型を操作することを実演します。</target>
        </trans-unit>
        <trans-unit id="b22f4e4bd19dab41fd1e0219238248b0317aa35c" translate="yes" xml:space="preserve">
          <source>In this example, we will get the following output:</source>
          <target state="translated">この例では、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="ee2620c9071c60e99d08be588513a407e9d8d25d" translate="yes" xml:space="preserve">
          <source>In this example, we'll do some more work with the argument stack. The previous examples have all returned only a single value. We'll now create an extension that returns an array.</source>
          <target state="translated">この例では、引数スタックを使ってさらにいくつかの作業を行います。これまでの例では、すべて単一の値を返していました。これから配列を返す拡張モジュールを作成します。</target>
        </trans-unit>
        <trans-unit id="bc42a21b3f25368390b359d2c6a1e02f5038d3de" translate="yes" xml:space="preserve">
          <source>In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries. To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us.</source>
          <target state="translated">この例では、あらかじめ定義された C ライブラリと相互作用する XSUB を書き始めます。まず,自分の小さなライブラリを作成し,h2xs に .pm と .xs ファイルを書かせます.</target>
        </trans-unit>
        <trans-unit id="ccfbfd9001b68d4bb9123e9a75f5be994042b170" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt; , so it could be factored out:</source>
          <target state="translated">この形式では、代替を単純化する方法がわかりやすくなります。選択肢1、2、および4はすべて &lt;code&gt;\d+&lt;/code&gt; で始まるため、除外することができます。</target>
        </trans-unit>
        <trans-unit id="5b24fb7d07c9db355f07769493a9de293acc8111" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a category of functions and the value is a short description of that category.</source>
          <target state="translated">このハッシュでは、各キーは関数のカテゴリを表し、値はそのカテゴリの簡単な説明です。</target>
        </trans-unit>
        <trans-unit id="3f56d8b8bdb8c26426f0b6660b2be0710caeb9c2" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is a short description of that function.</source>
          <target state="translated">このハッシュでは、各キーは関数を表し、値はその関数の短い説明です。</target>
        </trans-unit>
        <trans-unit id="4112ec477caea48107dc76ca327ecc26b9559568" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is the category. The category can be a comma separated list.</source>
          <target state="translated">このハッシュでは、各キーは関数を表し、値はカテゴリを表します。カテゴリはカンマ区切りのリストにすることができます。</target>
        </trans-unit>
        <trans-unit id="5b991cc90d42bab8c037a6310ce95c7fd23aada4" translate="yes" xml:space="preserve">
          <source>In this instance the &quot;Store&quot; and &quot;Fetch&quot; methods are encapsulated inside a &quot;Filter&quot; method.</source>
          <target state="translated">この例では、&quot;Store &quot;メソッドと &quot;Fetch &quot;メソッドは &quot;Filter &quot;メソッドの中にカプセル化されています。</target>
        </trans-unit>
        <trans-unit id="d35ad5c2c0618e945079ac0ca929cf4d613d24d9" translate="yes" xml:space="preserve">
          <source>In this library, the numbers are represented in base B = 10**N, where N is the largest possible value that does not cause overflow in the intermediate computations. The base B elements are stored in an array, with the least significant element stored in array element zero. There are no leading zero elements, except a single zero element when the number is zero.</source>
          <target state="translated">このライブラリでは、数値は基底B=10**Nで表され、Nは中間計算でオーバーフローを起こさない最大の値です。ベースBの要素は配列に格納され、最下位の要素は配列要素0に格納されます。数字がゼロのときにゼロ要素が1つあることを除いて、先頭のゼロ要素はありません。</target>
        </trans-unit>
        <trans-unit id="df68cfd3648ab58a91a7f368ccaceffbf7d1f325" translate="yes" xml:space="preserve">
          <source>In this particular case we don't have to call</source>
          <target state="translated">この特定のケースでは</target>
        </trans-unit>
        <trans-unit id="dad6a924b2e38abcfe4b4ffded7acf8266a85c31" translate="yes" xml:space="preserve">
          <source>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</source>
          <target state="translated">このパスでは入力パターンが解析され、各レゴップに必要なスペースを計算します。サイズは、プログラムの中で長いジャンプが必要かどうかを判断するためにも使われます。</target>
        </trans-unit>
        <trans-unit id="41f31a4be766288871cf075eb0ef8be8f75f8e7b" translate="yes" xml:space="preserve">
          <source>In this pod section each line obeys the format</source>
          <target state="translated">このポッドセクションでは、各行はフォーマットに従います。</target>
        </trans-unit>
        <trans-unit id="2a40391b3aa03b91dc32950cbb01e23eafc7a333" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;^&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">この正規表現では、最初の最小量指定子 &lt;code&gt;.*?&lt;/code&gt; 空の文字列に一致します。これは、単語の先頭に一致する &lt;code&gt;^&lt;/code&gt; アンカーによる制約を受けないためです。ただし、ここでは原則0が適用されます。文字列の先頭で正規表現全体が一致する可能性があるため、</target>
        </trans-unit>
        <trans-unit id="1677ca4d68d5b3cd757901e02552a2ca6071fc8c" translate="yes" xml:space="preserve">
          <source>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the &lt;code&gt;/g&lt;/code&gt; flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the &lt;code&gt;\s+&lt;/code&gt;, and the &lt;code&gt;$&lt;/code&gt; anchor can match to the absolute end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the &lt;code&gt;^\s+&lt;/code&gt; would remove all by itself:</source>
          <target state="translated">この正規表現では、アンカーは優先順位よりも優先順位が低いため、文字列の最初または最後のいずれかで交互に一致します。 &lt;code&gt;/g&lt;/code&gt; のそれは両方を取得するためのフラグ、置換は、すべての可能なマッチを行います。末尾の改行は &lt;code&gt;\s+&lt;/code&gt; に一致し、 &lt;code&gt;$&lt;/code&gt; アンカーは文字列の絶対的な末尾に一致する可能性があるため、改行も表示されないことに注意してください。出力に改行を追加するだけで、 &lt;code&gt;^\s+&lt;/code&gt; が単独ですべて削除する「空白」（空白のみで構成される）行を保持するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="77b676e373d337a1558a3681668f6ee37714295f" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. This idea has several variations.</source>
          <target state="translated">このステートメントでは、 &lt;code&gt;World&lt;/code&gt; は正規表現であり、 &lt;code&gt;//&lt;/code&gt; を囲む &lt;code&gt;/World/&lt;/code&gt; は、一致する文字列を検索するようPerlに指示します。演算子 &lt;code&gt;=~&lt;/code&gt; は、文字列を正規表現一致に関連付け、正規表現が一致した場合はtrue値を生成し、正規表現が一致しなかった場合はfalseを生成します。この例では、 &lt;code&gt;World&lt;/code&gt; は &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; の 2番目の単語と一致するため、式はtrueです。このアイデアにはいくつかのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="c818981124c0efd397c772e8c5a5bccf099d60f4" translate="yes" xml:space="preserve">
          <source>In this way (as for perl's scalars) a pointer to a PerlIOBuf can be treated as a pointer to a PerlIOl.</source>
          <target state="translated">このようにして(Perlのスカラーと同様に)PerlIOBufへのポインタはPerlIOlへのポインタとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="47c607bae4c1c842072097188930b7f5e712b730" translate="yes" xml:space="preserve">
          <source>In those 8 cases above, the value of EXPR is used directly as a boolean, so no smartmatching is done. You may think of &lt;code&gt;when&lt;/code&gt; as a smartsmartmatch.</source>
          <target state="translated">上記の8つのケースでは、EXPRの値はブール値として直接使用されるため、スマートマッチングは行われません。あなたは考えるかもしれ &lt;code&gt;when&lt;/code&gt; smartsmartmatchとして。</target>
        </trans-unit>
        <trans-unit id="9186d74e76b80422b13adb44366ed78c8afac4f7" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">そのような場合、次のように、Filtering :: Simpleをロードする &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントに直接、フィルタリングサブルーチンとターミネーター指定を追加する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="95167fe0e36a49f5080da73352ed44710a152f26" translate="yes" xml:space="preserve">
          <source>In those cases, you would turn off &lt;code&gt;strict 'refs'&lt;/code&gt; temporarily so you can play around with the symbol table. For example:</source>
          <target state="translated">そのような場合は、一時的に &lt;code&gt;strict 'refs'&lt;/code&gt; オフにして、シンボルテーブルを操作できるようにします。例えば：</target>
        </trans-unit>
        <trans-unit id="c6200c4c82d6daee49dcd17953c7919b7352b65f" translate="yes" xml:space="preserve">
          <source>In time-critical applications, it is worthwhile to avoid splitting into more fields than necessary. Thus, when assigning to a list, if LIMIT is omitted (or zero), then LIMIT is treated as though it were one larger than the number of variables in the list; for the following, LIMIT is implicitly 3:</source>
          <target state="translated">タイムクリティカルなアプリケーションでは、必要以上に多くのフィールドに分割することを避けることは価値があります。したがって、リストに代入するとき、LIMITが省略されている(またはゼロである)場合、LIMITはリスト内の変数の数よりも1つ大きいものであるかのように扱われます;以下の場合、LIMITは暗黙のうちに3です。</target>
        </trans-unit>
        <trans-unit id="61aec1693f3cca77d878f9993860b197db04ab69" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http://whatever/Foo%3a%3aBar&lt;/a&gt;, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;?&quot;.</source>
          <target state="translated">ターニングで&lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;はFoo ::バー&lt;/a&gt;へ&lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;のhttp：//どんな/ Fooの％3A％3aBar&lt;/a&gt;、 &quot;フー％3A％3aBar&quot;の前に置くために何を。デフォルト値は「&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;？」です。</target>
        </trans-unit>
        <trans-unit id="fe66d5d405c8ef8a7eac08fc91eff0a843fd6e3f" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; into &lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http://whatever/man/1/crontab&lt;/a&gt;, what to put before the &quot;1/crontab&quot;. The default value is &quot;&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; を&lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http：// whatever / man / 1 / crontab&lt;/a&gt;に変える際に、「1 / crontab」の前に何を置くか。デフォルト値は「&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;」です。</target>
        </trans-unit>
        <trans-unit id="43281809d91fd31f1807b9436030386775e6651b" translate="yes" xml:space="preserve">
          <source>In typical VMS style, only the first letter of the value of this logical name is actually checked in a case insensitive mode, and it is considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</source>
          <target state="translated">典型的なVMSのスタイルでは、この論理名の値の最初の文字だけが大文字小文字を区別しないモードで実際にチェックされ、値が &quot;T&quot;,&quot;1&quot;,&quot;E &quot;であれば有効とみなされます。</target>
        </trans-unit>
        <trans-unit id="573e7b50018345b4e76799c05af940dc27c74f2b" translate="yes" xml:space="preserve">
          <source>In ualarm() you tried to use number of microseconds or interval (also in microseconds) more than 1_000_000 and setitimer() is not available in your system to emulate that case.</source>
          <target state="translated">ualarm()で、1_000_000_000 を超えるマイクロ秒数や間隔 (マイクロ秒単位でも可)を使おうとした場合、そのようなケースをエミュレートするための setitimer()がシステムで利用できません。</target>
        </trans-unit>
        <trans-unit id="f02423b74e4b6df478931aa6ac2f4633241db988" translate="yes" xml:space="preserve">
          <source>In verbose mode, a warning is printed if shadows are found (i.e., more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">冗長モードでは、影が見つかった場合に警告が表示されます(つまり、同じPOD名のPODファイルが2つ以上見つかった場合など)。</target>
        </trans-unit>
        <trans-unit id="8a3ebab20ae57eb43347721d9e5a409b1ce17a43" translate="yes" xml:space="preserve">
          <source>In version 2.37 the first argument to the callback function was changed from string to object. This was done to make room for extensions and more detailed control. The object stringifies to the option name so this change should not introduce compatibility problems.</source>
          <target state="translated">バージョン 2.37 では、コールバック関数の最初の引数が文字列からオブジェクトに変更されました。これは、拡張機能やより詳細な制御のためのスペースを確保するために行われました。オブジェクトはオプション名に文字列化されるので、この変更が互換性の問題を引き起こすことはないはずです。</target>
        </trans-unit>
        <trans-unit id="880a8be23ba2ee8779ff63078e49dfc5216b39eb" translate="yes" xml:space="preserve">
          <source>In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:</source>
          <target state="translated">バージョン5.000と5.001では、上記の行を使用する代わりに、以下の行を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc474b32c69cb459158c3dcaef8e4f4b651d874" translate="yes" xml:space="preserve">
          <source>In versions 5.6 and later, Perl won't recompile the regular expression if the variable hasn't changed, so you probably don't need the &lt;code&gt;/o&lt;/code&gt; option. It doesn't hurt, but it doesn't help either. If you want any version of Perl to compile the regular expression only once even if the variable changes (thus, only using its initial value), you still need the &lt;code&gt;/o&lt;/code&gt;.</source>
          <target state="translated">バージョン5.6以降では、変数が変更されていない場合、Perlは正規表現を再コンパイルしないため、 &lt;code&gt;/o&lt;/code&gt; オプションはおそらく必要ありません。害はありませんが、効果もありません。変数が変更されても（したがって、その初期値のみを使用して）、Perlのいずれかのバージョンで正規表現を1回だけコンパイルする場合でも、 &lt;code&gt;/o&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="cb448bdd461c35050663768e40f737fb69d01266" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly. You need to change the &quot;use lib&quot; line to read:</source>
          <target state="translated">5.002より前のバージョンのガンマ版では、例1のテストスクリプトが正しく機能しません。use lib」の行を読み替える必要があります。</target>
        </trans-unit>
        <trans-unit id="47fb4d46b782f60712d6e476480e232acaeda83d" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs. This means that you cannot say &quot;make test&quot; to run the test script. You will need to add the following line before the &quot;use extension&quot; statement:</source>
          <target state="translated">バージョン 5.002 より前のバージョン 5.002b1h では、test.pl ファイルは h2xs によって自動的に作成されませんでした。これは、テストスクリプトを実行するために &quot;make test&quot; と言うことができないことを意味します。use extension&quot; ステートメントの前に以下の行を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac1080be96df0c995d03afc96266140d8a96249c" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt; .</source>
          <target state="translated">5.004より前のバージョンのPerlでは、 &lt;code&gt;I18N::Collate&lt;/code&gt; ライブラリモジュールを使用してロケールごとの照合が可能でした。このモジュールは現在やや時代遅れであり、新しいアプリケーションでは使用しないでください。 &lt;code&gt;LC_COLLATE&lt;/code&gt; の機能は、現在のPerlのコア言語に統合されています。一つは、と完全に正常にロケール固有のスカラーデータを使用することはできません &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 程度のスカラ参照を持つジャグリングする必要はもはやあり、 &lt;code&gt;I18N::Collate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48a813c6d738225545b449a151bcdc156058f932" translate="yes" xml:space="preserve">
          <source>In your XS code, when you define an argument with a C type or when you are using a &lt;code&gt;CODE:&lt;/code&gt; and an &lt;code&gt;OUTPUT:&lt;/code&gt; section together with a C return type of your XSUB, it'll be the typemapping mechanism that makes this easy.</source>
          <target state="translated">XSコードで、Cタイプの引数を定義する場合、または &lt;code&gt;CODE:&lt;/code&gt; と &lt;code&gt;OUTPUT:&lt;/code&gt; セクションをXSUBのC戻り値タイプと一緒に使用する場合、これは、これを簡単にするタイプマッピングメカニズムになります。</target>
        </trans-unit>
        <trans-unit id="9357861451f0b2f036dafa4da40d9ece429bcae6" translate="yes" xml:space="preserve">
          <source>In-line functions that are in headers that are accessible to XS code need to be able to compile without warnings with commonly used extra compilation flags, such as gcc's &lt;code&gt;-Wswitch-default&lt;/code&gt; which warns whenever a switch statement does not have a &quot;default&quot; case. The use of these extra flags is to catch potential problems in legal C code, and is often used by Perl aggregators, such as Linux distributors.</source>
          <target state="translated">XSコードにアクセスできるヘッダーにあるインライン関数は、gccの &lt;code&gt;-Wswitch-default&lt;/code&gt; などの一般的に使用される追加のコンパイルフラグを使用して、switchステートメントに「デフォルト」のケースがない場合に警告する警告なしでコンパイルできる必要があります。 。これらの追加のフラグの使用は、合法的なCコードの潜在的な問題をキャッチするためであり、LinuxディストリビューターなどのPerlアグリゲーターによってよく使用されます。</target>
        </trans-unit>
        <trans-unit id="1fac261b8677bb294fa8e76c7f44d73a02d84ebb" translate="yes" xml:space="preserve">
          <source>In-memory IO, scalar IO</source>
          <target state="translated">インメモリIO、スカラIO</target>
        </trans-unit>
        <trans-unit id="022b1dbe77251c047456c4feb5d0409e122d6848" translate="yes" xml:space="preserve">
          <source>In-place upgrade of the supplied SV to a version object.</source>
          <target state="translated">提供された SV をバージョンオブジェクトにインプレースアップグレードします。</target>
        </trans-unit>
        <trans-unit id="1930e5219f1534978185f9ba376df01339047154" translate="yes" xml:space="preserve">
          <source>Inappropriate documentation</source>
          <target state="translated">不適切な文書</target>
        </trans-unit>
        <trans-unit id="72a5f6c42a6c39ea891ecb24d22128fd281d0e18" translate="yes" xml:space="preserve">
          <source>Inc</source>
          <target state="translated">Inc</target>
        </trans-unit>
        <trans-unit id="70b0bede26554e7ae42316f8d3fd932a7cdc066c" translate="yes" xml:space="preserve">
          <source>Incidentally, note that each class's &lt;code&gt;%Lexicon&lt;/code&gt; inherits-and-extends the lexicons in its superclasses. This is not because these are special hashes</source>
          <target state="translated">ちなみに、各クラスの &lt;code&gt;%Lexicon&lt;/code&gt; はスーパークラスのレキシコンを継承および拡張することに注意してください。これは特別なハッシュだからではありません</target>
        </trans-unit>
        <trans-unit id="56c1bcd0fe0c175606142de66e47a332c19454ad" translate="yes" xml:space="preserve">
          <source>Incidentally, note that there's no easy way to express a data paragraph starting with something that looks like a command. Consider:</source>
          <target state="translated">ちなみに、コマンドのようなものから始まるデータの段落を簡単に表現する方法はないので注意が必要です。考えてみてください。</target>
        </trans-unit>
        <trans-unit id="af23144864617d68a82ad427e6d70d917f0fe977" translate="yes" xml:space="preserve">
          <source>Incidentally, note the variance in the result values between the two examples; this is typical of benchmarking. If this were a real benchmark, you would probably want to run a lot more iterations.</source>
          <target state="translated">ちなみに、2つの例の間の結果値のばらつきに注意してください。これが実際のベンチマークであれば、おそらくもっと多くの繰り返しを実行したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="11c54a59d8a9668fa20146e40c46116f6e7acc35" translate="yes" xml:space="preserve">
          <source>Include</source>
          <target state="translated">Include</target>
        </trans-unit>
        <trans-unit id="7f36757a0ff9e21d096da46852dca59689517203" translate="yes" xml:space="preserve">
          <source>Include /usr/ccs/bin/ in your PATH.</source>
          <target state="translated">/usr/ccs/bin/をPATHに含めてください。</target>
        </trans-unit>
        <trans-unit id="5f7213221d8f17a14d6c7b8882fe3f1c79362499" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile (default behaviour).</source>
          <target state="translated">インファイルにPODエラーがあった場合、アウトファイルに &quot;POD ERRORS &quot;セクションを含める(デフォルトの動作)。</target>
        </trans-unit>
        <trans-unit id="1f63d3adcc78e2a751c9de88b5a592a5d6f05fed" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile. This section is included by default.</source>
          <target state="translated">インファイルにPODエラーがあった場合は、アウトファイルに「POD ERRORS」セクションを含める。このセクションはデフォルトで含まれています。</target>
        </trans-unit>
        <trans-unit id="1be836334b7992bf64bdd66feaf2cdd670e862a6" translate="yes" xml:space="preserve">
          <source>Include a single css source in the header:</source>
          <target state="translated">ヘッダに単一の css ソースを含めます。</target>
        </trans-unit>
        <trans-unit id="82da13ca7b8da7d4d7bd6d25f32b5e4df5ab790d" translate="yes" xml:space="preserve">
          <source>Include a single javascript source:</source>
          <target state="translated">1つのjavascriptのソースを含めます。</target>
        </trans-unit>
        <trans-unit id="dacfcf246f0e94f511558260bbdd933b10ed8af6" translate="yes" xml:space="preserve">
          <source>Include any non-POD text from the input file in the output as well. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">入力ファイルのPOD以外のテキストも出力に含めます。PODがレンダリングされ、コードがそのままの状態でPODブロックで文書化されたコードを表示するのに便利です。</target>
        </trans-unit>
        <trans-unit id="b3aefa9c8a28918cfdeb274cb63c2499f4f13ccf" translate="yes" xml:space="preserve">
          <source>Include code for safely storing static data in the .xs file. Extensions that do no make use of static data can ignore this option.</source>
          <target state="translated">.xs ファイルに静的データを安全に格納するためのコードを含めます。静的データを使用しない拡張機能は、このオプションを無視することができます。</target>
        </trans-unit>
        <trans-unit id="73830e720872f365cfd2f2dbd3697deb29a3d139" translate="yes" xml:space="preserve">
          <source>Include file dirs eg: &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</source>
          <target state="translated">インクルードファイル &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt; ：例：「-I / usr / 5include -I / path / to / inc」</target>
        </trans-unit>
        <trans-unit id="bf7dea1bf3fcc056eca7b649b6605fbf3217e27a" translate="yes" xml:space="preserve">
          <source>Include tests with your module</source>
          <target state="translated">モジュールにテストを含める</target>
        </trans-unit>
        <trans-unit id="44cae264b95e40204b6c9817100d817393044faa" translate="yes" xml:space="preserve">
          <source>Include the `nstore' option to have the &lt;code&gt;Storable&lt;/code&gt; database written in `network order'. (See &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; for more details about this.)</source>
          <target state="translated">&lt;code&gt;Storable&lt;/code&gt; データベースを「ネットワーク順」で書き込むには、「nstore」オプションを含めます。（これについて詳しくは、&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="428c39cb578db360bfc5803c8ec5f4e60b61ea16" translate="yes" xml:space="preserve">
          <source>Include the code from the &lt;b&gt;.h&lt;/b&gt; file as a comment in the &lt;b&gt;.ph&lt;/b&gt; file. This is primarily used for debugging</source>
          <target state="translated">&lt;b&gt;.h&lt;/b&gt;ファイルのコードをコメントとして&lt;b&gt;.ph&lt;/b&gt;ファイルに含めます。これは主にデバッグに使用されます</target>
        </trans-unit>
        <trans-unit id="5318c44a39f5f77944d683ed2f0ae1a7ab04539f" translate="yes" xml:space="preserve">
          <source>Include the following line in the XS section of your XS file: (don't break the line)</source>
          <target state="translated">XSファイルのXSセクションに以下の行を含めてください。(改行しないでください)</target>
        </trans-unit>
        <trans-unit id="eb7645ad7831d7d6fd6181e27396b77155390482" translate="yes" xml:space="preserve">
          <source>Include the main program in the output, even if subroutines were also specified. This rendering is normally suppressed when a subroutine name or reference is given.</source>
          <target state="translated">サブルーチンも指定されていた場合でも、メインプログラムを出力に含めます。このレンダリングは、サブルーチン名や参照が指定されている場合は、通常は抑制されます。</target>
        </trans-unit>
        <trans-unit id="39d690d519d42e4c1222e708f1a7882603060ecf" translate="yes" xml:space="preserve">
          <source>Include verbose configuration data in the report.</source>
          <target state="translated">冗長な構成データをレポートに含めます。</target>
        </trans-unit>
        <trans-unit id="7af107d55e07795d28db937bc5e2e6b3d1acdce5" translate="yes" xml:space="preserve">
          <source>Included in the official Perl distribution, as in a standard module, a standard tool, or a standard Perl &lt;b&gt;manpage&lt;/b&gt;.</source>
          <target state="translated">標準モジュール、標準ツール、または標準Perl &lt;b&gt;マンページのよう&lt;/b&gt;に、公式のPerlディストリビューションに含まれています。</target>
        </trans-unit>
        <trans-unit id="0c36d5529b0434732ae50f5c4cfddc9ab638ebdc" translate="yes" xml:space="preserve">
          <source>Included recommended modules?</source>
          <target state="translated">推奨モジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="2d5cfde693773293f9c93c5da459379d1390e74a" translate="yes" xml:space="preserve">
          <source>Included suggested modules?</source>
          <target state="translated">提案されたモジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="fd1eb7c27a0ef162dc3c74b06bcd124d36810aee" translate="yes" xml:space="preserve">
          <source>Included with the standard Cygwin netrelease is the inetutils package which includes libutil.a.</source>
          <target state="translated">標準のCygwin netreleaseにはlibutil.aを含むinetutilsパッケージが含まれています。</target>
        </trans-unit>
        <trans-unit id="62deb9b6c9960c6cf27bcef72a0cb725d958b5ee" translate="yes" xml:space="preserve">
          <source>Includes the closing tag of &amp;lt;/title&amp;gt; and through the rest of the head till the opening of the body</source>
          <target state="translated">&amp;lt;/ title&amp;gt;の終了タグを含み、本体の開口部まで頭の残りの部分を通過します</target>
        </trans-unit>
        <trans-unit id="9abdbb8c9871ea5d015e2e60e10f71a6f7c5bffa" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">ライブラリモジュールを含めるには、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 演算子を使用する方が適切です。これにより、自動エラーチェックが行われ、問題がある場合は例外が発生します。</target>
        </trans-unit>
        <trans-unit id="fc7468d33bdeb93695da594528f2501435fe4708" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">ライブラリモジュールを含めるには、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 演算子を使用する方が適切です。これにより、自動エラーチェックが行われ、問題がある場合は例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d536a03f0c3143f6e1f810634a3c64f1cee1463a" translate="yes" xml:space="preserve">
          <source>Incompatibility with AIX Toolbox lib gdbm</source>
          <target state="translated">AIX Toolbox lib gdbm との非互換性</target>
        </trans-unit>
        <trans-unit id="e53b7251c10e4fb16639ff0eb74e48d3fdb255f3" translate="yes" xml:space="preserve">
          <source>Increment OBJ by one.</source>
          <target state="translated">OBJを1つ増やす。</target>
        </trans-unit>
        <trans-unit id="a3b00269821fb57d8ea2de1fc824b0f5f9a60902" translate="yes" xml:space="preserve">
          <source>Increment an SV's reference count. Use the &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SVの参照カウントをインクリメントします。代わりに &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; ラッパーを使用してください。</target>
        </trans-unit>
        <trans-unit id="0e74e496959812fcc073992ca705206317cb9544" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; . The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; の参照カウントを増やします。 &lt;code&gt;refcounted_he&lt;/code&gt; へのポインターも返されます。この関数にnullポインターを渡しても安全です。アクションは発生せず、nullポインターが返されます。</target>
        </trans-unit>
        <trans-unit id="e3802b6aa343742e73ae6047c081fca9075a08d1" translate="yes" xml:space="preserve">
          <source>Increment the version number for every change, no matter how small</source>
          <target state="translated">どんなに小さくても、変更があるたびにバージョン番号をインクリメントする</target>
        </trans-unit>
        <trans-unit id="4c98c7bfa60bc9d7d9626649411d920868a3e57d" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt; , which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; を増分します。これにより、すべてのパッケージのメソッドキャッシュが無効になります。</target>
        </trans-unit>
        <trans-unit id="3272c368109726f88d497737f134b46e95de8369" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the given SV, returning the SV.</source>
          <target state="translated">与えられた SV の参照カウントを増加させ、SV を返します。</target>
        </trans-unit>
        <trans-unit id="b3fb59bb686d8260401f92a3aa6f2bbde8cfdc66" translate="yes" xml:space="preserve">
          <source>Indeed, a negative real number can be noted &lt;code&gt;[x,pi]&lt;/code&gt; (the modulus</source>
          <target state="translated">実際、負の実数は &lt;code&gt;[x,pi]&lt;/code&gt; （係数</target>
        </trans-unit>
        <trans-unit id="a04774d4b73d320e20f71b059e1b914a71747c31" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt; ), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">実際、サイクルを終了するには、$ cntがfalseになる必要があります。ただし、偽をチェックするための演算子 &lt;code&gt;bool&lt;/code&gt; はオーバーロードされ（今回はオーバーロードされた &lt;code&gt;&quot;&quot;&lt;/code&gt; を介して）、長い文字列を返すため、 &lt;code&gt;symbolic&lt;/code&gt; タイプのオブジェクトはすべてtrueです。これを克服するには、オブジェクトを0と比較する方法が必要です。実際、数値変換ルーチンを書く方が簡単です。</target>
        </trans-unit>
        <trans-unit id="62ba8e1b3397c92c36fc4b8d835f19b0c882946b" translate="yes" xml:space="preserve">
          <source>Indent lines by multiples of</source>
          <target state="translated">の倍数で行をインデントします。</target>
        </trans-unit>
        <trans-unit id="62114f3245956b96ef644ac166335fb4a4e9a90b" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">ハッシュ関数で使用されるシードに関係なく、 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; ハッシュごとのランダム化された順序でアイテムを返します。挿入によってハッシュを変更すると、そのハッシュの反復順序が変更されます。この動作は、&lt;a href=&quot;hash/util&quot;&gt;Hash :: Utilの&lt;/a&gt; &lt;code&gt;hash_traversal_mask()&lt;/code&gt; を使用するか、PERL_PERTURB_KEYS環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;。perlrunのPERL_PERTURB_KEYSを&lt;/a&gt;参照してください。この機能は、キーの「表示」順序を制御するものであり、実際に格納される順序は制御しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="074fa110a121b41d1fc8547d15dc9f9c647ba94b" translate="yes" xml:space="preserve">
          <source>Independent subexpressions</source>
          <target state="translated">独立した副表現</target>
        </trans-unit>
        <trans-unit id="f095033a2da35066ce69235bfd888bf108da82db" translate="yes" xml:space="preserve">
          <source>Index/Value Array Slices</source>
          <target state="translated">インデックス/値配列スライス</target>
        </trans-unit>
        <trans-unit id="9376bb53130ade1b5bef94ae526efe4afa9ba571" translate="yes" xml:space="preserve">
          <source>India Pale Ale. Also the International Phonetic Alphabet, the standard alphabet used for phonetic notation worldwide. Draws heavily on Unicode, including many combining characters.</source>
          <target state="translated">インディア・ペールエール。また、国際音声アルファベット(International Phonetic Alphabet)、世界の音声表記に使用される標準的なアルファベット。多くの結合文字を含むUnicodeを多用している。</target>
        </trans-unit>
        <trans-unit id="7939b23cc59e5fecb713c284b9570bf5c06bc4a8" translate="yes" xml:space="preserve">
          <source>Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List::Util が C コンパイラでコンパイルされているかどうかを示す</target>
        </trans-unit>
        <trans-unit id="257f1f56edc7d22d13ca3e932a232d7b1ce1cb6a" translate="yes" xml:space="preserve">
          <source>Indicates how many bits are produced by the function used to generate normalized random numbers.</source>
          <target state="translated">正規化乱数の生成に使用される関数で生成されるビット数を示す。</target>
        </trans-unit>
        <trans-unit id="9e61b5d3c6d9951043a7c42ee4ac908615e6dda5" translate="yes" xml:space="preserve">
          <source>Indicates if the test suite is currently passing.</source>
          <target state="translated">テストスイートが現在合格しているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="89c8d4afc13dccaac0824429842e2b3486822df1" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. A single typemap may be specified as a string, or multiple typemaps can be specified in an array reference, with the last typemap having the highest precedence.</source>
          <target state="translated">ユーザが指定したタイプマップをデフォルトのタイプマップよりも優先することを示します。単一のタイプマップを文字列で指定することもできますし、複数のタイプマップを配列参照で指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a07031906aeffe3119baa721e29202522fd91917" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. This option may be used multiple times, with the last typemap having the highest precedence.</source>
          <target state="translated">デフォルトのタイプマップよりもユーザが指定したタイプマップを優先することを示します。このオプションは複数回使用することができ、最後のタイプマップが最も優先されます。</target>
        </trans-unit>
        <trans-unit id="2a6c6be6a26747d93fbb6c3ceadc3f2de48a2c99" translate="yes" xml:space="preserve">
          <source>Indicates that arguments returned from a callback should be discarded. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックから返された引数を破棄する必要があることを示します。&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0527e8a268302f8a5a261750f72fb958d828bf1d" translate="yes" xml:space="preserve">
          <source>Indicates that no arguments are being sent to a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックに引数が送信されていないことを示します。&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a1a4d2b29fe4bc866080992a5b7a34bdbecb2aeb" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">呼び出し元が結果のホスト名に関心がないため、変換する必要がないことを示します。ホスト名として &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b7ec72841bfda828e77f110fabfe3b01a8c116ba" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">呼び出し元が結果のサービス名に関心がないため、変換する必要がないことを示します。 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; はサービス名として返されます。</target>
        </trans-unit>
        <trans-unit id="f532e8b4a0494e58b3d4e84b40bc705bd9387b6c" translate="yes" xml:space="preserve">
          <source>Indicates that the caller will pass a numeric address, rather than a hostname, and that getaddrinfo() must not perform a resolve operation on this name. This flag will prevent a possibly-slow network lookup operation, and instead return an error if a hostname is passed.</source>
          <target state="translated">呼び出し元がホスト名ではなく数値のアドレスを渡すことを示し、 getaddrinfo()がこの名前に対して解決処理を実行してはならないことを示します。このフラグは、ネットワーク検索の処理が遅くなることを防ぎ、 ホスト名が渡された場合にはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="3c8087750e8c32a23d6ccd2949d0b7dadc5ebeea" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt; ) field of the result to be filled in.</source>
          <target state="translated">呼び出し元が、結果の正規ホスト名（ &lt;code&gt;canonname&lt;/code&gt; ）フィールドに入力することを望んでいることを示します。</target>
        </trans-unit>
        <trans-unit id="0a02454d6f3918d6c495eef14a92688abca3837e" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a method. A subroutine so marked will not trigger the &quot;Ambiguous call resolved as CORE::%s&quot; warning.</source>
          <target state="translated">参照されるサブルーチンがメソッドであることを示します。このようにマークされたサブルーチンでは、&quot;Ambiguous call resolved as CORE::%s&quot; 警告は発生しません。</target>
        </trans-unit>
        <trans-unit id="1c805274f5974d7ec81414a21a79ac4005ac17f0" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a valid lvalue and can be assigned to. The subroutine must return a modifiable value such as a scalar variable, as described in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">参照されたサブルーチンが有効な左辺値であり、代入できることを示します。サブルーチンは、&lt;a href=&quot;perlsub&quot;&gt;perlsubで&lt;/a&gt;説明されているように、スカラー変数などの変更可能な値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="945cc6067d92cdd88f1d4d49015ca5f672222998" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">参照される変数は、&lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;および&lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt;モジュールと組み合わせて使用​​すると、異なるスレッド間で共有できることを示します。</target>
        </trans-unit>
        <trans-unit id="f5dc796b3c6e09f2adbe1df261ece3a878874b6e" translate="yes" xml:space="preserve">
          <source>Indicates that the socket address relates to a &lt;code&gt;SOCK_DGRAM&lt;/code&gt; socket, for the services whose name differs between TCP and UDP protocols.</source>
          <target state="translated">ソケットアドレスが、TCPプロトコルとUDPプロトコルで名前が異なるサービスの &lt;code&gt;SOCK_DGRAM&lt;/code&gt; ソケットに関連していることを示します。</target>
        </trans-unit>
        <trans-unit id="d2c743e25365a9bdf3ff9b009f1ca948b97e6afb" translate="yes" xml:space="preserve">
          <source>Indicates that this resolution is for a local bind() for a passive (i.e. listening) socket, rather than an active (i.e. connecting) socket.</source>
          <target state="translated">この解決方法は、アクティブ(接続)ソケットではなく、パッシブ(リスニング)ソケットに対するローカルバインド()であることを示します。</target>
        </trans-unit>
        <trans-unit id="1f10eaccf1b997cf7e5e0f8a8f4fab0ca55e7525" translate="yes" xml:space="preserve">
          <source>Indicates the macro to be used to generate normalized random numbers. Uses randfunc, often divided by (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits)) in order to normalize the result. In C programs, the macro &lt;code&gt;Drand01&lt;/code&gt; is mapped to drand01.</source>
          <target state="translated">正規化された乱数の生成に使用されるマクロを示します。結果を正規化するために、randfuncを使用し、多くの場合（double）（（（unsigned long）1 &amp;lt;&amp;lt; randbits））で除算します。Cプログラムでは、マクロ &lt;code&gt;Drand01&lt;/code&gt; はdrand01にマップされます。</target>
        </trans-unit>
        <trans-unit id="46fbaffe89877f1dd0586f026a063f6bfd1ece0d" translate="yes" xml:space="preserve">
          <source>Indicates the name of the random number function to use. Values include drand48, random, and rand. In C programs, the &lt;code&gt;Drand01&lt;/code&gt; macro is defined to generate uniformly distributed random numbers over the range [0., 1.[ (see drand01 and nrand).</source>
          <target state="translated">使用する乱数関数の名前を示します。値には、drand48、random、およびrandが含まれます。Cプログラムでは、 &lt;code&gt;Drand01&lt;/code&gt; マクロは[0.、1. [の範囲で一様に分布した乱数を生成するように定義されています（drand01とnrandを参照）。</target>
        </trans-unit>
        <trans-unit id="0e9d38aea41337c4a340bd6ff37e0fceaaf530c7" translate="yes" xml:space="preserve">
          <source>Indicates the random number generating seed function. Values include srand48, srandom, and srand.</source>
          <target state="translated">乱数生成シード関数を示す。値には srand48,srandom,srand が含まれます。</target>
        </trans-unit>
        <trans-unit id="90e351cd851905a73031d78312feecb33ffe731a" translate="yes" xml:space="preserve">
          <source>Indicates the type of the argument of the seedfunc.</source>
          <target state="translated">seedfunc の引数の型を示す。</target>
        </trans-unit>
        <trans-unit id="2261f14a4235af1795b8d1185c5372fb55826237" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;に対して、事態が非常に悪化しているため、すべてのテストを終了する必要があることを示します。これには、追加のテストスクリプトの実行が含まれます。</target>
        </trans-unit>
        <trans-unit id="fe441aac507416c2ecf5fefc2720f5a5e7cc6991" translate="yes" xml:space="preserve">
          <source>Indicates to the harness that things are going so badly all testing should terminate. This includes the running of any additional test scripts.</source>
          <target state="translated">状況が悪化しているため、すべてのテストを終了すべきであることをハーネスに示します。これには、追加のテストスクリプトの実行も含まれます。</target>
        </trans-unit>
        <trans-unit id="bdde223b122eaee17c31cfd6ef76f52ec58ce6f0" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current item is a YAML block.</source>
          <target state="translated">現在のアイテムがYAMLブロックであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="2ac3f8f7cb3f69c816245189833fb5047e4be353" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current line could be parsed.</source>
          <target state="translated">現在の行を解析できるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="765249e9b3e3ba66799eb3c3e692065e2ef4bdde" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a SKIP directive.</source>
          <target state="translated">与えられた結果にSKIP指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="1e5feadbfd972a9ef3f2203c437baf1b81be3303" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO directive.</source>
          <target state="translated">与えられた結果にTODO指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="5ae3ac2f7146f745d483818a88c053580ae4ad1e" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO or SKIP directive.</source>
          <target state="translated">与えられた結果にTODO指令やSKIP指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="33c1162df0e994c2dba92771958227447c3c8740" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a TAP version line.</source>
          <target state="translated">これがTAPバージョンの行であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="82a274793f5ee26247829ddf91f4a9bd5a24bbd9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a YAML chunk.</source>
          <target state="translated">これがYAMLチャンクであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="551b037463cdc6d8ee7a155c709c206438a14ea9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment.</source>
          <target state="translated">これがコメントであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="fa47f2a4b95862bdf9eb043bb9b755ecb73bbd6f" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &lt;code&gt;merge&lt;/code&gt; option.</source>
          <target state="translated">これがコメントかどうかを示します。コメントは通常、STDERRがSTDOUTにマージされた場合にのみTAPストリームに表示されます。 &lt;code&gt;merge&lt;/code&gt; オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="5add899043fa2f2909dd47a1020e2ad33a37e66d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a pragma line.</source>
          <target state="translated">これがプラグマ行であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="7023aeaf089510f19833c997992b3c941c8dc92d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a test line.</source>
          <target state="translated">これがテストラインであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="9f9b15b44f69cccc124e6789e9d93a4a06a7d51c" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is bailout line.</source>
          <target state="translated">これがベイルアウトラインであるかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="7a3a5d84e52530eeac47fceba7db01f6e0dcbe22" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is the test plan line.</source>
          <target state="translated">これがテスト計画線であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="9010b0739ea277aa1257ee6d74e58336f2039de7" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">レクサーバッファー内のオクテット（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）をUnicode文字のUTF-8エンコーディングとして解釈する必要があるかどうかを示します。そうでない場合は、Latin-1文字として解釈する必要があります。これは、スカラーの &lt;code&gt;SvUTF8&lt;/code&gt; フラグに似ています。</target>
        </trans-unit>
        <trans-unit id="6add24acec866ad90335d7337161ba97a738a82e" translate="yes" xml:space="preserve">
          <source>Indicating the Film::Rating() method is broken.</source>
          <target state="translated">Film::Rating()メソッドが壊れていることを示します。</target>
        </trans-unit>
        <trans-unit id="065a6d5ea3be3a587038269a904d146bb9a0a3c1" translate="yes" xml:space="preserve">
          <source>Indirect Object Syntax</source>
          <target state="translated">間接オブジェクト構文</target>
        </trans-unit>
        <trans-unit id="3fba9ca2a9139d262136aa9779aba86f7f14b1e8" translate="yes" xml:space="preserve">
          <source>Individual Results</source>
          <target state="translated">個別成績</target>
        </trans-unit>
        <trans-unit id="cb52fbb620cf2997c4aa4b5107c331f4b77d2de2" translate="yes" xml:space="preserve">
          <source>Individual test results.</source>
          <target state="translated">個別の検査結果。</target>
        </trans-unit>
        <trans-unit id="a6118403aceb71cf86308ba3cff213cbc8856dc0" translate="yes" xml:space="preserve">
          <source>Individual test suite results.</source>
          <target state="translated">個々のテストスイートの結果。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="68dcf262960464f7812ef1f6844ea3187d8ab76d" translate="yes" xml:space="preserve">
          <source>Infinity and Not a Number</source>
          <target state="translated">無限大と数ではない</target>
        </trans-unit>
        <trans-unit id="ec4c72e2c7996edd7fe98bac862051d171e8f331" translate="yes" xml:space="preserve">
          <source>Inflate Interface</source>
          <target state="translated">インフレートインターフェース</target>
        </trans-unit>
        <trans-unit id="ae8803342c993280c888b28837c9da6527d39370" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 内容全体を膨らませます。バッファーは、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="beedaffabd6b03c265ffb648f984a13e030e2063" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; . The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 完全なコンテンツを展開し、圧縮されていないデータを &lt;code&gt;$output&lt;/code&gt; 書き込みます。 &lt;code&gt;$input&lt;/code&gt; と &lt;code&gt;$output&lt;/code&gt; パラメータは、いずれかのスカラーまたはスカラー参照することができます。</target>
        </trans-unit>
        <trans-unit id="75ddcc47830d9749b1f6958774d6b7383d928afa" translate="yes" xml:space="preserve">
          <source>Information on installing the Perl documentation in HTML format can be found in the</source>
          <target state="translated">HTML形式のPerlドキュメントをインストールする際の情報は</target>
        </trans-unit>
        <trans-unit id="63a11938f1b7522fad4baac591e5655e30cc1a15" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt; . The variable is a structured string that looks something like this:</source>
          <target state="translated">現在のperlバイナリがコンパイルされたgitコミットに関する情報は、変数 &lt;code&gt;$Config::Git_Data&lt;/code&gt; ます。変数は、次のような構造化文字列です。</target>
        </trans-unit>
        <trans-unit id="4fa18069a4aed5716a8df64d9e082aca15aa5195" translate="yes" xml:space="preserve">
          <source>Informative call that array is likely to grow to have</source>
          <target state="translated">配列が持つように成長する可能性が高いことを知らせる呼び出し</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fdd8dbf1164cff77c53c1fcf6f05a5248f3597e3" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt; :</source>
          <target state="translated">継承により、2つのクラスでコードを共有できます。デフォルトでは、親クラスのすべてのメソッドが子でも使用できます。子は、親のメソッドを明示的に&lt;b&gt;オーバーライドし&lt;/b&gt;て、独自の実装を提供でき&lt;b&gt;ます&lt;/b&gt;。たとえば、 &lt;code&gt;File::MP3&lt;/code&gt; オブジェクトがある場合は、Fileの &lt;code&gt;print_info()&lt;/code&gt; メソッドがあり &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc41c48400edb2d66f46abd2eeeb9f193aa61fe" translate="yes" xml:space="preserve">
          <source>Inheritance and Overloading</source>
          <target state="translated">継承とオーバーロード</target>
        </trans-unit>
        <trans-unit id="b4102e1cbc70e34f207d4b05daf2f7d154eb2cce" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::ExtraHash*</source>
          <target state="translated">Tie::ExtraHash*からの継承</target>
        </trans-unit>
        <trans-unit id="07845e4fa81351b41e3aca0473590f0745f203e3" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::Memoize*</source>
          <target state="translated">Tie::Memoize*からの継承</target>
        </trans-unit>
        <trans-unit id="c5a788b89ced595ecbe83baf444c015d5af4ed62" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::StdHash*</source>
          <target state="translated">Tie::StdHash*からの継承</target>
        </trans-unit>
        <trans-unit id="2af015f1a7a88588d2bedaaf274af7c154500941" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ee435be5e637cbc759b674414f3dfaaeaa6a310" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::Memoize&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: Memoize&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0942164c538c56917cf82fee8d95de867370af98" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::StdHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: StdHash&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="697bba69426638bf8ad3245a38ff2084b17b3805" translate="yes" xml:space="preserve">
          <source>Init methods</source>
          <target state="translated">Initメソッド</target>
        </trans-unit>
        <trans-unit id="469d92ba331e1f193a058b9d59b36d9c2695f1be" translate="yes" xml:space="preserve">
          <source>Init.U</source>
          <target state="translated">Init.U</target>
        </trans-unit>
        <trans-unit id="188fedc6f79203e40eb5a91d186ec6c30916e7f9" translate="yes" xml:space="preserve">
          <source>Initial discussion of the ability to modify IO streams behaviour used the term &quot;discipline&quot; for the entities which were added. This came (I believe) from the use of the term in &quot;sfio&quot;, which in turn borrowed it from &quot;line disciplines&quot; on Unix terminals. However, this document (and the C code) uses the term &quot;layer&quot;.</source>
          <target state="translated">IOストリームの振る舞いを変更する機能の最初の議論では、追加されたエンティティのために &quot;discipline &quot;という用語が使われていました。これは(私は)&quot;sfio &quot;での用語の使用に由来するもので、Unix端末の &quot;line disciplines &quot;から借りてきたものです。しかしながら、このドキュメント(とCコード)では &quot;layer &quot;という用語を使っています。</target>
        </trans-unit>
        <trans-unit id="af26189aae099c8b0074103f2d4d6fbc19c70e2f" translate="yes" xml:space="preserve">
          <source>Initial port of perl to WinCE. It was performed in separate directory named</source>
          <target state="translated">WinCEへのPerlのイニシャルポート。という名前の別のディレクトリで実行されました。</target>
        </trans-unit>
        <trans-unit id="64a1cc8196dec5ffb0b6abf423df9a7b0c6e0219" translate="yes" xml:space="preserve">
          <source>Initial version (GSAR 20-FEB-97)</source>
          <target state="translated">初期バージョン(GSAR 20-FEB-97</target>
        </trans-unit>
        <trans-unit id="681e3458dd2b1a02b6b17850e74b7b6f830be8ea" translate="yes" xml:space="preserve">
          <source>Initialisation in &lt;code&gt;pregcomp()&lt;/code&gt; mostly involves the creation and data-filling of a special structure, &lt;code&gt;RExC_state_t&lt;/code&gt; (defined in</source>
          <target state="translated">&lt;code&gt;pregcomp()&lt;/code&gt; の初期化には、特別な構造体 &lt;code&gt;RExC_state_t&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="c7a9076545ffc08af19383275c9bb0a670aaa64a" translate="yes" xml:space="preserve">
          <source>Initialises a deflation object.</source>
          <target state="translated">デフレーションオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="b36a0f0079e64fa2a033c629779d3f623a057d8c" translate="yes" xml:space="preserve">
          <source>Initialises a deflation stream.</source>
          <target state="translated">デフレの流れを初期化します。</target>
        </trans-unit>
        <trans-unit id="6050c58e3e77b97a8c7a9c2f34e629bf70ca3f1a" translate="yes" xml:space="preserve">
          <source>Initialises an inflation object.</source>
          <target state="translated">インフレーションオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="d6dc7f91e03e45468b8ef5863382d6fe3515a834" translate="yes" xml:space="preserve">
          <source>Initialises an inflation stream.</source>
          <target state="translated">インフレストリームを初期化します。</target>
        </trans-unit>
        <trans-unit id="a08fb78f0ee25d9e540249a9eb4c3ec2aebf86f6" translate="yes" xml:space="preserve">
          <source>Initialization values for some globals</source>
          <target state="translated">一部のグローバルの初期化値</target>
        </trans-unit>
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">MAKEをMAKE環境変数または$Config{make}から初期化します。</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">プラットフォーム固有の使用のためだけのマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">MakeMakerや他のツールのバージョンを表すマクロを初期化する</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">リンクに関係するマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">SigSet オブジェクトを空に初期化します。</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">すべてのシグナルを含むようにSigSetオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">AR、AR_STATIC_ARGS、BASEEXT、CONFIG、DISTNAME、DLBASE、EXE_EXT、FULLEXT、FULLPERL、FULLPERLRUN、FULLPERLRUNINST、INST_*、INSTALL*、INSTALLDIRS、LIB_EXTを初期化します。LIBPERL_A,MAP_TARGET,NAME,OBJ_EXT,PARENT_NAME,PERL,PERL_ARCHLIB,PERL_INC,PERL_LIB,PERL_SRC,PERLRUN,PERLRUNINST,PREFIX,VERSION,VERSION_SYM,XS_VERSION.</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">EXE_FILESのリストからMAN1PODSを初期化します。</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">PMファイルのリストからMAN3PODSを初期化します。</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">PMLIBDIRS と PM を PMLIBDIRS から初期化します。</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">新しいPerlインタープリターを初期化します。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">新しいオブジェクトを初期化します。このメソッドはデフォルトではスタブになっているので、適宜オーバーライドしてください。</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">ファイルパス内のディレクトリとファイル名の間のセパレータであるDIRFILESEPマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">tools_other()で使用するコンパイルとリンクに関わるマクロ定義を初期化し、$MMオブジェクトに配置します。</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">tools_other()で使用するシンプルなマクロ定義を初期化し、 $MM オブジェクトに配置します。これらは、保守的なクロスプラットフォームバージョンを使用しており、パフォーマンスのためにプラットフォーム固有のバージョンでオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">共通の(より高速な)Unixコマンドを使用するためのツールを初期化します。</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">関数パラメータの初期化</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 初期化</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">新規での初期化</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">現在のメッセージからデータの送信を開始します。</target>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">ファイルのインプレース編集 &lt;code&gt;perl -i&lt;/code&gt; は、ウィンドウの制限のため、 &lt;code&gt;perl -i.bak&lt;/code&gt; で編集中のファイルのバックアップを作成しないと機能しません。したがって、バックアップ拡張子を指定せずに &lt;code&gt;perl -i&lt;/code&gt; を使用すると、Perlは自動的に接尾辞 &lt;code&gt;.bak&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">入力ファイルグローバル</target>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">入出力パラメータ</target>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">Perl ファイルハンドルへの入出力パイプがサポートされています。Perl スクリプトの中で開いたパイプを閉じる際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;ファイル&lt;/b&gt;または&lt;b&gt;デバイス&lt;/b&gt;からの入力、または&lt;b&gt;ファイル&lt;/b&gt;または&lt;b&gt;デバイス&lt;/b&gt;への出力。</target>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">入力ライブラリとパスの指定は、Unixリンカーで使用される &lt;code&gt;-l&lt;/code&gt; および &lt;code&gt;-L&lt;/code&gt; プレフィックスの有無にかかわらず受け入れられます。</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">入力ライブラリとパスの指定は、Unixリンカーで使用される &lt;code&gt;-l&lt;/code&gt; および &lt;code&gt;-L&lt;/code&gt; プレフィックスの有無にかかわらず受け入れられます。どちらのプレフィックスも存在しない場合、トークンは、それが実際にディレクトリである場合は検索するディレクトリと見なされ、そうでない場合は検索するライブラリと見なされます。拡張機能をUnixまたはOS / 2に移植できるようにしたい作者は、Unix-OS / 2バージョンのext（）が必要とするため、Unixプレフィックスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">入力文字列は decode()d の後に encode()d となります。ストレートな二段階の実装です。</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">これらのルーチンへの入力は、BigFloatオブジェクト、または以下の4つの形式の文字列のいずれかです。</target>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">これらのルーチンへの入力値は、16進数や2進数を含む、数字のように見えて整数になる任意の文字列にすることができます。</target>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">配列の先頭にLIST要素を挿入し、既存の要素を上に移動してスペースを確保します。</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">配列の先頭にLIST要素を挿入し、既存の要素を上に移動してスペースを確保します。例えば</target>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">字句解析器バッファー（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）の現在の字句解析ポイント（&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;）の直後に文字を挿入し、必要に応じてバッファーを再割り当てします。つまり、後で実行される字句解析コードは、文字が入力に現れたように見えます。通常の解析の一部としてこれを行うことはお勧めできません。この機能を使用すると、挿入された文字が意図しない方法で解釈される危険があります。</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">POD、コメント、Cプリプロセッサディレクティブの挿入</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">以下のようなレコードを挿入します。</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">SV 内に指定されたオフセット/長さの文字列を挿入します。Perl の substr()関数に似ています。取得マジックを扱う。</target>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">ファイルの集合にシャープバングまたは同等のマジックナンバーを挿入します。</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">内部 &lt;code&gt;(?{...})&lt;/code&gt; ブロック、 &lt;code&gt;$_&lt;/code&gt; 正規表現と照合される文字列を指します。また、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; を使用して、この文字列内で一致する現在の位置を知ることもできます。</target>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Perlプログラム内では、&lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt;モジュールを使用して、インストールされているすべてのディストリビューションを表示できますが、その魔法を実行するのに時間がかかる場合があります。Perlに付属する標準ライブラリは、「Perl」として表示されます（ただし、&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;を使用して取得できます）。</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; コードブロック内では、 &lt;code&gt;$?&lt;/code&gt; プログラムが &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; に渡す値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？プログラムの終了値を変更します。 &lt;code&gt;$?&lt;/code&gt; の変更に注意してください。偶然（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; を介して何かを実行することによる）</target>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">インサイド &lt;code&gt;END&lt;/code&gt; のサブルーチン &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; に渡される値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？中 &lt;code&gt;END&lt;/code&gt; のサブルーチンプログラムの終了ステータスを変更します。例えば：</target>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;CHECK&lt;/code&gt; ブロック、の値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;END&lt;/code&gt; ブロックの値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;END&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;INIT&lt;/code&gt; のブロック、の値は &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">そのような中で</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">Perlコア（ &lt;code&gt;PERL_CORE&lt;/code&gt; が定義されている）の内部では、 &lt;code&gt;Perl_&lt;/code&gt; プレフィックスの有無にかかわらず、多数の定義が存在するおかげで関数を取得できます。</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">ブロック内では、 &lt;code&gt;;&lt;/code&gt; を使用できます。 &lt;code&gt;{ ... }&lt;/code&gt; がブロックであり、ハッシュ参照コンストラクタではないことを示す省略記号の前。これで省略記号が機能します。</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">インサイドアウトオブジェクト</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">インサイドアウトクラスは相続の自由を与えてくれますが、いつものように代償があります。</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">明示的なオブジェクトレジストリを使用した &lt;code&gt;id()&lt;/code&gt; 関数に基づくインサイドアウト実装。デストラクタは必要なく、オブジェクトはスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 関数に基づくインサイドアウト実装。 &lt;code&gt;DESTROY&lt;/code&gt; メソッドが必要です。スレッドをサポートするには、 &lt;code&gt;CLONE&lt;/code&gt; メソッド（図には示されていません）も必要です。 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; の代わりに、関数 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; を使用しても、機能上の違いはほとんどありません。これは、裏返しのクラスの基本的なパターンです。</target>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$UTF8{Euro}&lt;/code&gt; を検査すると、&quot;\ xe2 \ x82 \ xac&quot;の3バイトが含まれていることがわかります。ただし、0x20ACの1文字しか含まれていません。往復は &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; で完了できます。</target>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">最初にVisual C++2005をインストールし、次にPlatform SDKをインストールします。以下のように環境を設定します(デフォルトのインストール場所を選択したと仮定して)。</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">Visual C++2008-2013 Express をインストールしてから、例えば、以下のようにして環境を設定します。</target>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">名前付きイベントのコールバックをインストールします。</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">シグナルマスクをインストールし、シグナルが到着するまでプロセスを一時停止します。これは、使用しています &lt;code&gt;POSIX::SigSet&lt;/code&gt; ためにオブジェクト &lt;code&gt;signal_mask&lt;/code&gt; の引数。詳細については、システムの &lt;code&gt;sigsuspend&lt;/code&gt; マンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">正常にテストされたがまだインストールされていないすべてのディストリビューションをインストールします。 &lt;code&gt;is_tested&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">ここからあちこちにファイルをインストールする</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;通常のシグナルの&lt;/b&gt;ハンドラーとしてmy_handler（）をインストールします。</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">通常のシグナルのハンドラとして my_handler()をインストールし、エラーシグナルを受信した際に Perl のスタックトレースを提供します。</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">最初にツールキットをインストールし、次にプラットフォームSDKをインストールし、次に.NET Framework SDKをインストールします。以下のように環境を設定します(デフォルトのインストール場所を選択したと仮定して)。</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">バンドル &lt;code&gt;Bundle::OS2_default&lt;/code&gt; をインストールします</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">最初のステップで作成したバンドルファイルを以下のようなものでインストールします。</target>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">Install は、NetWare Perl がインストールされている Windows マシンにファイルをコピーします。別の方法としては</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">OS/390でのPerlのインストールの異常</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">インストールプレフィックス</target>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">DOSでのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">WindowsへのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">Plan 9 への Perl ドキュメントのインストール</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">OS/400のPASEにPerlをインストールする</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">BS2000へのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">動的拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">ハンドラをUNIVERSALにインストールすると、ユニバーサルになります。例えば</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">静的拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">ビルドされたPerlをAmigaOSにインストールする</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">ビルドされたPerlをインストールする</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">インスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">代わりの &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; 、我々は書くことができる &lt;code&gt;$a[1][2]&lt;/code&gt; 。同じことを意味します。代わりに &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; 、我々は書くことができる &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 同じことを意味します。</target>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;:encoding(UTF-8)&lt;/code&gt; の代わりに、単純に &lt;code&gt;:utf8&lt;/code&gt; を使用できます。これにより、データがすでに内部でUTF8として表現されている場合は、エンコード手順がスキップされます。これは、書き込み時には適切な動作として広く受け入れられていますが、無効なバイトシーケンスがあると内部の不整合が発生するため、読み取り時に危険な場合があります。入力に &lt;code&gt;:utf8&lt;/code&gt; を使用すると、セキュリティ違反が発生する場合があるため、代わりに &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; して &lt;code&gt;encode&lt;/code&gt; 代わりに、 &lt;code&gt;_utf8_on&lt;/code&gt; および &lt;code&gt;_utf8_off&lt;/code&gt; を使用することもできますが、これは悪いスタイルと見なされます。特に &lt;code&gt;_utf8_on&lt;/code&gt; は、同じ理由で、危険なことが &lt;code&gt;:utf8&lt;/code&gt; することができます。</target>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">ファイル名の代わりに、たとえば別のアーカイブから既存の &lt;code&gt;Archive::Tar::File&lt;/code&gt; オブジェクトを渡すこともできます。オブジェクトは複製され、事実上、エイリアスではなく元のコピーになります。</target>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">数字の代わりに、 &lt;code&gt;*&lt;/code&gt; を使用して「残りすべてを消費する」ことを意味できます。</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dTHX&lt;/code&gt; を使用してスレッドコンテキストをフェッチする必要がある実際のC関数の代わりに、同じ名前のマクロを定義してオーバーヘッドを回避できます。また、 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; によって割り当てられたメモリを解放する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">その代わりに、こんな感じで。</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">機能バンドルを名前でロードするのではなく、機能バンドルの暗黙のロードをPerlに任せる方が簡単です。</target>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;$SIG{ALRM}&lt;/code&gt; を設定する代わりに：</target>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">Makefile.PLでVERSIONを指定する代わりに、MakeMakerにファイルを解析させてバージョン番号を決定させることができます。解析ルーチンでは、VERSION_FROMで指定されたファイルに、バージョン番号を計算するための1行が含まれている必要があります。$ VERSION割り当てや &lt;code&gt;package Name VERSION&lt;/code&gt; などを含むファイルの最初の行が使用されます。次の行は問題なく解析されます：</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">上記の処理の代わりに Filter::Simple を使うと、ソースコードフィルタを設定する作業が軽減されます。</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">シェルの &lt;code&gt;expand&lt;/code&gt; コマンドの代わりに、次を使用します。</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">シェルの &lt;code&gt;unexpand -a&lt;/code&gt; コマンドの代わりに、次を使用します。</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">これの代わりに</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; を使用する代わりに、 &lt;code&gt;/m&lt;/code&gt; （およびおそらく &lt;code&gt;/s&lt;/code&gt; ）正規表現修飾子を使用する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;と、レキシカルスコープ（ファイル全体でも &lt;code&gt;/m&lt;/code&gt; に対して/ mを有効にできます。（以前のバージョン： &lt;code&gt;$*&lt;/code&gt; がtrue値に設定されている場合、すべての正規表現は &lt;code&gt;/m&lt;/code&gt; を使用して記述されているかのように動作しました。）</target>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; を使用する代わりに、 &lt;code&gt;foreach()&lt;/code&gt; ループを使用できます。たとえば、配列に特定の文字列が出現する回数をカウントする1つの方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">純粋な Perl を使用してオーバーロードされたインタフェースを書く代わりに、OVERLOAD キーワードを使用して、関数に追加の Perl 名を定義することもできます (上記の ALIAS:キーワードのように)。ただし、オーバーロードされた関数は 3 つのパラメータで定義する必要があります (4 つのパラメータを必要とする nomethod()関数を除く)。いずれかの関数に OVERLOAD:キーワードがある場合、オーバーロードマジックに登録するために、xsubpp によって生成された c ファイルにいくつかの追加行が定義されます。</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">複数の &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; ステートメントを作成する代わりに、定数名の代わりに、キーが定義される定数の名前であるハッシュへの参照を与えることにより、単一のステートメントで複数の定数を定義できます。明らかに、このメソッドを使用して定義されたすべての定数は、単一の値を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_bufを&lt;/a&gt;使用するか、まれに&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchrを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">代わりに、ほぼ確実に&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;または&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">代わりに、 &lt;code&gt;bytes_to_utf8&lt;/code&gt; は文字列引数のUTF-8エンコードされた&lt;b&gt;コピー&lt;/b&gt;を提供します。これは、元のSVを損なうことなく、データを比較などに利用できるようにするのに役立ちます。逆に進むために &lt;code&gt;utf8_to_bytes&lt;/code&gt; もありますが、255を超える1バイトで表現できない文字が文字列に含まれていると、当然これは失敗します。</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">代わりに、Windows上でプレーンテキストファイルを実行するために利用できるすべての方法は、ファイルの「拡張子」に依存しています。これを利用してPerlスクリプトを実行する方法は3つあります。</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">代わりに、こんな感じで。</target>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">その代わりに、以下の解決策はむしろうまく機能します。これの良いところは、1)すぐに使い始めることができること、2)*/*/*/*.c のようなパターンで正しいことをするので、より強力であること、3)これを使うか使わないかを決めることができること、4)メソッドを拡張して、任意のカスタマイズを追加することができることです (あるいは、全く異なる種類のワイルドカード拡張を追加することもできます)。</target>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">代わりに、ブールチェックには &lt;code&gt;blessed&lt;/code&gt; （&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;モジュール内）、特定のクラスチェックには &lt;code&gt;isa&lt;/code&gt; 、型チェックには &lt;code&gt;reftype&lt;/code&gt; （これも&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;から）を使用します。（詳細と &lt;code&gt;blessed/isa&lt;/code&gt; の例については&lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">代わりに、ブールチェックには &lt;code&gt;blessed&lt;/code&gt; （&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;モジュール内）、特定のクラスチェックには &lt;code&gt;isa&lt;/code&gt; 、型チェックには &lt;code&gt;reftype&lt;/code&gt; （これも&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;から）を使用します。（詳細と &lt;code&gt;blessed/isa&lt;/code&gt; の例については&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">代わりに、ダブルクォートにバックスラッシュを1つ入れて使用してください。</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">代わりに、IV、UV、IVSIZE、I32SIZEなどの定義を使用してください。それらがされているため、I32のようなものを避けるため&lt;b&gt;ではない&lt;/b&gt;ことが保証</target>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">モジュールのインストール方法と依存関係の説明。ここに含めるべき情報を提案します。</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">ファイルスペックの一部として現れるコロンとターゲットの区切り文字を区別するために、ターゲットをマークするコロンの前にスペースがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">整数演算</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">整数2進対数 [C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">整数2進対数[C99]。</target>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">整数。オプションのプラスまたはマイナス記号の後に連続した数字が続きます。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">ローカルディレクトリの統合</target>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">インテルヘックス</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEXは、バイナリデータを、主にさまざまなチップをプログラミングするために、テキストファイルとして表すためのファイル形式です。（詳細な説明については&lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt;を、モトローラSレコード形式については&lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/SREC_（file_format）&lt;/a&gt;を参照してください。同じ手法を使用します。）各行はコロン（ '：'）で始まり、その後にバイト数を指定する一連の16進文字が続きます。</target>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">アンインストールされたバージョンのパッケージに対して任意のスクリプトをテストする方法として、&lt;b&gt;-M&lt;/b&gt;オプションを指定してコマンドラインで使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">デジタルコマンド言語(DCL)シェルからPerlを操作するには、Unixシェルとは異なる引用符のセットが必要になることがよくあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">拡張機能との相互作用</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">IO::Socket を使用した対話型クライアント</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">インタラクティブモード。</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">対話型セッションは &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 維持し、デフォルトでは〜/ .cpan /です。ロック。バッチジョブは、ロックファイルなしで実行でき、互いに干渉しません。</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; を使用してインタラクティブに任意の &lt;code&gt;expression&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">興味深いことに、わずかに異なる結果が得られます。これは主に、出力ファイル形式が同一であるとされているにもかかわらず、レポートを生成するアルゴリズムが異なるためです。経過時間、ユーザー時間、システム時間は、 &lt;code&gt;Devel::Profiler&lt;/code&gt; が独自の実行を実行するのにかかった時間を明確に示していますが、列のリストは、以前の &lt;code&gt;Devel::DProf&lt;/code&gt; ものよりも正確に感じられます。たとえば、102％の数値は消えました。これは、私たちが自由にツールを使用し、それらを使用する前に長所と短所を認識しなければならない場所です。興味深いことに、各サブルーチンの呼び出し回数は2つのレポートで同じで、割合が異なります。 &lt;code&gt;Devel::Proviler&lt;/code&gt; 作者は次のように書いています：</target>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">インターフェイス戦略</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm と Kwalify.pm の間のインターフェース</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">バークレーDBへのインターフェース</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">EMXからcwdへのインターフェイス。 &lt;code&gt;Cwd::cwd&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib 圧縮ライブラリへのインタフェース</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">他のプログラミング言語とのインターフェイス/エミュレーション</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">Win32 API 関数へのインターフェイス</target>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">内部フォーマット</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">内部機能</target>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部設定処理</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部デバッグ</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">dl_debugがtrueに設定されていると、内部デバッグメッセージが有効になります。現在のところ、$dl_debugの設定はDynaLoaderのPerl側のみに影響を与えます。これらのメッセージは、アプリケーション開発者がDynaLoaderの使用上の問題を解決するのに役立つはずです。</target>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">内部フォーマット</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">内部関数 Hash::Util::FieldHash::_fieldhash</target>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt;引数タイプに基づいてフィルターを追加する内部関数。</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm の tar アーカイブの内部処理</target>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">エラーや警告を表示するための内部メソッド。オプションが与えられていない場合は、単に &quot;@_&quot; を出力します。以下のオプションが認識され、出力を形成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::gmtimeおよびTime::localtimeが使用する内部オブジェクト</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部キューのサポート</target>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">内部的には &lt;code&gt;%+&lt;/code&gt; と &lt;code&gt;%-&lt;/code&gt; は&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCaptureを&lt;/a&gt;介して実際に結び付けられたインターフェースで実装されます。そのパッケージのメソッドは、これらの関数をコールバックします。ただし、この目的での&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;の使用法は、将来のリリースで変更される可能性があります。たとえば、これは代わりに魔法によって実装される可能性があります（mgvtblへの拡張が必要になります）。</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">内部的に CPAN.pm は UTF-8 文字セットを使用します。端末が ISO-8859-1 の文字セットを期待している場合、設定ファイルで term_is_latin を真の値に設定することでコンバータを有効にすることができます。これを行う一つの方法は以下のようになります</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">内部エンコード-&amp;gt; UnicodeおよびUnicode-&amp;gt;エンコードマップは次のようになります。</target>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">内部的に、Benchmarkオブジェクトはタイミング値を保持します。これについては、以下の&lt;a href=&quot;#NOTES&quot;&gt;注&lt;/a&gt;で説明します。次のメソッドを使用してそれらにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H{regcomp}&lt;/code&gt; でカスタムエンジンが指定されていない限り、内部的にこれは &lt;code&gt;NULL&lt;/code&gt; に設定されます。Perl独自のコールバックのセットには、 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; が指す構造体でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encodeで内部的に使用される</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">内部的には Encode:??::ISO_2022_*で使用されます。</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">内部的には Encode::CN によって使用されます。</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode::JP によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::2022_JP*で内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode::KR によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">内部的には、Perlは現在、プラットフォームのネイティブ8ビット文字セット（たとえば、Latin-1）がデフォルトでUTF-8であるものを使用して、Unicode文字列をエンコードします。特に、文字列内のすべてのコードポイントが &lt;code&gt;0xFF&lt;/code&gt; 以下の場合、Perlはネイティブの8ビット文字セットを使用します。それ以外の場合は、UTF-8を使用します。</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">内部的には、ネイティブの整数演算(C コンパイラで提供されている)が使用されます。これは、Perl 自身の算術演算のセマンティクスが保持されていない可能性があることを意味します。よくあるトラブルの原因は負の数のモジュラスですが、これは Perl が一方的に行いますが、ハードウェアが別の方法で行うことがあります。</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">内部的には、これをクラスPod::Simple::Progressのオブジェクトに設定することがよくあります。このクラスはおそらく文書化されていませんが、そのソースを見てみるといいでしょう。</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">内部的には、コンピュータは浮動小数点数を2進数で表しています。デジタル(2の累乗のように)コンピュータは、すべての数字を正確に保存することはできません。いくつかの実数はその過程で精度を失ってしまいます。これは、コンピュータが数字を格納する方法の問題であり、Perlだけでなく、すべてのコンピュータ言語に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">内部とC言語インタフェース</target>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">国際化（I18N）とローカリゼーション（L10N）は、EBCDICプラットフォームでも少なくとも原則的にはサポートされます。詳細はシステムに依存し、以下の&lt;a href=&quot;#OS-ISSUES&quot;&gt;OSの問題&lt;/a&gt;セクションで説明します。</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">国際化とロケール</target>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">C や POSIX 標準で定義されている国際化は、不完全で、不必要で、粒度が大きすぎると批判されることがあります (ロケールはプロセス全体に適用されます。(ロケールはプロセス全体に適用されますが、単一のスレッドやウィンドウグループなどに適用させる方が議論の余地なく便利です)。また、ロケールは標準グループのように、世界を国に分ける傾向がありますが、世界は銀行員、バイカー、ゲーマーなどにも同じように分けられることがわかっています。</target>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">インターネット回線ターミネーター</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">インターネットプロトコル、または知的財産。</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">インターネットTCPクライアントとサーバー</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">インターネット言語タグは、RFC 3066で定義されているように、人間の言語を表現するための形式主義です。2文字のISO 639-1言語コードはよく知られています(英語では &quot;en &quot;のように)。あまり知られていませんが、任意の長さの非ISOコード(&quot;i-mingo &quot;のようなもの)や、最近(2001年に)導入された3文字のISO-639-2コードがあります。</target>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">補間されたスカラーと配列は、内部的に &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&quot;.&quot;&lt;/code&gt; 変換されます。カテネーション操作。したがって、 &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">配列またはスライスの補間は、 &lt;code&gt;$&quot;&lt;/code&gt; の値で区切られた順序で要素を補間するため、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 補間と同等です。例えば、「句読点」配列 &lt;code&gt;@*&lt;/code&gt; 名前が括弧で囲まれている場合にのみ、通常、補間される &lt;code&gt;@{*}&lt;/code&gt; が、配列 &lt;code&gt;@_&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; 、および &lt;code&gt;@-&lt;/code&gt; さえ括弧なしに補間されます。</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">パターンの補間にはいくつかの癖があります： &lt;code&gt;$|&lt;/code&gt; 、 &lt;code&gt;$(&lt;/code&gt; 、 &lt;code&gt;$)&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; および &lt;code&gt;@-&lt;/code&gt; は補間されず、構成 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; は（いくつかの異なる推定量によって）配列要素または &lt;code&gt;$var&lt;/code&gt; 後にRE代替が続くものとして投票されます。ここで、表記 &lt;code&gt;${arr[$bar]}&lt;/code&gt; が便利です： &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; は、変数 &lt;code&gt;$arr&lt;/code&gt; 後に数字が続く正規表現としてではなく、配列要素 &lt;code&gt;-9&lt;/code&gt; として解釈されます。 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; の解釈になります。異なる推定者の間で投票が行われる可能性があるため、結果は予測できません。</target>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力を 16 進文字列として解釈します。0x」または「x」の接頭辞はオプションです。プレフィックスの直後、または任意の2桁の間にアンダースコア文字を1文字入れることができる。入力が無効な場合、NaN が返される。</target>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">結果を厳密に解釈する。</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力をバイナリ文字列として解釈します。0b」または「b」の接頭辞はオプションである。プレフィックスの直後、または任意の2桁の間にアンダースコア文字を1文字入れることができる。入力が無効な場合、NaN が返される。</target>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力を8進数の文字列として解釈し、対応する値を返します。0&quot; (ゼロ)接頭辞はオプションです。アンダースコア文字がある場合は、接頭辞の直後、または任意の2桁の間に1つのアンダースコア文字を入れることができます。入力が無効な場合は、NaNが返されます。</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; フィールドの解釈はシステムによって異なりますが、従来は、ユーザーのフルネーム、オフィスの場所、勤務先の電話番号、自宅の電話番号を含む4つのコンマ区切りフィールドを保持しています。gecosフィールドの &lt;code&gt;&amp;amp;&lt;/code&gt; は、ユーザーの適切に大文字で書かれたログイン &lt;code&gt;name&lt;/code&gt; 置き換えてください。 &lt;code&gt;shell&lt;/code&gt; フィールドは、空白の場合、であると仮定しなければなりません</target>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">バッファのオクテットの解釈は、少しレベルの高い関数&lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt;と&lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;を使用して抽象化できます。</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPRを16進文字列として解釈し、対応する値を返します。（いずれかで始まる文字列に変換するには &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;0x&lt;/code&gt; 、または &lt;code&gt;0b&lt;/code&gt; 、参照&lt;a href=&quot;#oct&quot;&gt;octの&lt;/a&gt;。）EXPRを省略すると、使用しています &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPRを16進文字列として解釈し、対応する値を返します。（いずれかで始まる文字列に変換するには &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;0x&lt;/code&gt; 、または &lt;code&gt;0b&lt;/code&gt; 、参照&lt;a href=&quot;oct&quot;&gt;octの&lt;/a&gt;。）EXPRを省略すると、使用しています &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">EXPRを8進文字列として解釈し、対応する値を返します。（EXPRが &lt;code&gt;0x&lt;/code&gt; で始まる場合、16進文字列として解釈されます。EXPRが &lt;code&gt;0b&lt;/code&gt; で始まる場合、2進文字列として解釈されます。先頭の空白は、3つのケースすべてで無視されます。）以下は、10進、2進、 8進数、および標準のPerl表記の16進数：</target>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">プロセス間通信(IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">プロセス間通信。</target>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">Intersectionは一般的に、2つ（またはそれ以上）のクラスで一致する共通の文字を取得するために使用されます。最初のセットに &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; を使用しないことを覚えておくことは重要です。それは何とも交差せず、空のセットになります。</target>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">を紹介します。</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">Perl 5.005 で導入</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">Perl 5.10.0 で導入</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">Perl 5.12 で導入</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">Perl 5.14.0 で導入</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0 で導入</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0 で導入</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">Perl 5.6.0 で導入</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">Perl 5.6.1 で導入</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0 で導入</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">Perl 5.9.0 で導入</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">Perl 5.9.2 で導入</target>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">で導入されました。5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">で導入されました。Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">で導入されました。Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">導入されました。Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">で導入されました。Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">perl5.7.0の直後に導入されましたが、これは上記の抽象化を再実装したもので、IOをオペレーティングシステムやCライブラリの選択した方法から切り離し、IOがどのように行われるかをperlがより制御できるようにしています。USE_PERLIOのために、PerlIO *にはポインタからポインタへの追加の層があります。これにより、PerlIO*は既知の値を保持したまま、下の実装をスワップすることができます。</target>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">catchブロックを導入します。&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlgutsでの例外処理を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">(読み取り専用ではない)グローバルの導入</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">読み取り専用（const）グローバルの導入は、たとえば &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; （ &lt;code&gt;nm&lt;/code&gt; にBSDスタイルの出力がある場合）を使用して、追加したデータが実際に読み取られていることを確認する限り、問題ありません。のみ。（そうであれば、そのコマンドの出力には表示されません。）</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">for()の中に変数を導入する</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">入門テキスト</target>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">与えられたスタッシュの子クラスに対するメソッドのキャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">指定されたクラスに依存するクラスのメソッドキャッシュを無効にします。これは通常必要ありません。純粋なperlコードがメソッドキャッシュを混乱させる可能性がある唯一の既知のケースは、&lt;a href=&quot;constant&quot;&gt;定数&lt;/a&gt;の内部のように、読み取り専用のスカラー値を使用して新しい定数サブルーチンを手動でインストールする場合です。別のケースを見つけた場合は、報告してください。修正するか、例外をここに記載します。</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">インストールされたモジュールの在庫管理</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">反転リストは、Unicodeプロパティ値定義をコンパクトに指定する方法です。リ ス ト 内の 0 番目の項目は、 そのプ ロ パテ ィ 値を持つ最下位の コ ー ド 点です。次の項目 (項目 [1])は、 その項目を超えて、そのプロパティ値を持たない最下位のコード点です。そして、その先の次の項目([2])は、プロパティ値を持つその先の最も低いコードポイントであり、そのようにして、プロパティ値を持つその先の最も低いコードポイントである。別の言い方をすれば、リストの各要素は、プロパティ値を持つ範囲(偶数の要素の場合)、またはプロパティ値を持たない範囲(奇数の要素の場合)の始まりを与えます。このデータ構造の名前は、リストの各要素が、対応する範囲がリストにあるかどうかを切り替える(または反転する)ことに由来しています。</target>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">呼び出しには、実行されるコマンド、または coderef とオプションでオプションのハッシュリフが必要です。</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">魔法のメソッド(FETCHのような)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">解析する行がなくなると呼び出されます。付随する&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;オブジェクトがないため、代わりに &lt;code&gt;TAP::Parser&lt;/code&gt; オブジェクトが渡されます。</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">「get」マジックがある場合、SVで &lt;code&gt;mg_get&lt;/code&gt; を呼び出します。たとえば、これはタイ変数で &lt;code&gt;FETCH&lt;/code&gt; を呼び出します。このマクロは、その引数を複数回評価します。</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">「設定」マジックがある場合、SVで &lt;code&gt;mg_set&lt;/code&gt; を呼び出します。 &lt;code&gt;$|&lt;/code&gt; ような魔法の変数である場合、これはスカラーを変更した後に必要です。またはタイ変数（ &lt;code&gt;STORE&lt;/code&gt; を呼び出します）。このマクロは、その引数を複数回評価します。</target>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">VMS デバッガを起動します。(VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">デバッグモードを起動します。主にEncodeハッカーのためのものです。</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">リンカーを呼び出して、オブジェクトファイルからライブラリファイルを生成します。スカラーコンテキストでは、ライブラリファイルの名前が返されます。リストコンテキストでは、ライブラリファイルと作成された一時ファイルが返されます。必須の &lt;code&gt;objects&lt;/code&gt; パラメータには、処理するオブジェクトファイルの名前が文字列（1つのオブジェクトファイルの場合）またはリスト参照（1つ以上のファイルの場合）で含まれています。以下のパラメーターはオプションです。</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">リンカーを呼び出して、オブジェクトファイルから実行可能ファイルを生成します。スカラーコンテキストでは、実行可能ファイルの名前が返されます。リストコンテキストでは、実行可能ファイルと作成された一時ファイルが返されます。必須の &lt;code&gt;objects&lt;/code&gt; パラメータには、処理するオブジェクトファイルの名前が文字列（1つのオブジェクトファイルの場合）またはリスト参照（1つ以上のファイルの場合）で含まれています。オプションのパラメータは、以下を除いて &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">クラスメソッドの呼び出し</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">Perl の呼び出し</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">一度の呼び出しですべてのバージョンのメソッドを呼び出す</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">「 &lt;code&gt;make test&lt;/code&gt; 」を介してテストスクリプトを呼び出すことは、非常に重要なことを行いました。拡張機能の一部であるさまざまなファイルを見つけることができるように、これらすべての &lt;code&gt;-I&lt;/code&gt; 引数を使用してperlを呼び出しました。です</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">McGillicuddy全体のアイルランド人。Perlの文化では、「シャープ」と「強打」の &lt;code&gt;#!&lt;/code&gt; 意味するportmanteau です。インタープリターの検索場所をシステムに指示するシーケンス。</target>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">Irix 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">その配布に関わらず、ここにあるすべてのコード例はパブリックドメインです。あなたは、このコードとその派生物を、あなた自身のプログラムで、あなたが適切と考えるように、楽しみのために、または利益のために使用することが許可され、奨励されています。コードの中で、FAQへのクレジットを示すシンプルなコメントは礼儀正しいものですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">その配布にかかわらず、これらのファイル内のすべてのコード例は、ここにパブリックドメインに置かれます。あなたはこのコードをあなた自身のプログラムに使用することが許可されていますし、あなたが適切と考えるように、楽しみや利益のためにこのコードを使用することが奨励されています。コードの中にクレジットを与える単純なコメントは礼儀正しいものですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">その配布にかかわらず、このファイルのすべてのコード例は、ここにパブリックドメインに置かれます。あなたはこのコードをあなた自身のプログラムに使用することが許可されていますし、あなたが適切と考えるように、楽しみや利益のためにこのコードを使用することが奨励されています。コードの中で簡単なコメントをつけることが礼儀ですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">Perlの学習は難しい?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">書かれている方がいいですね。</target>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">ローカルデータや語彙データへの参照を返すのは安全ですか?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">同じなの?まあ、そうかもしれませんし、そうでないかもしれません。微妙な違いは、何かを角括弧で囲んで代入したときに、それが常に新しい</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">プロセス識別番号が 0 または負の番号の場合はサポートしていません。(VMS)</target>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">機能は一般的なもので十分ですか?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">実装は移植可能なほど汎用的か?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">実装は堅牢なのか?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">実装はテストされていますか?</target>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">Perl用のプリティプリンタ(フォーマッタ)はありますか?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">自動でデコードやエンコードする方法はありますか?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">ps」などのプログラムからperlのコマンドラインを隠す方法はありますか?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">IDEやWindowsのPerlエディタはありますか?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">他にも方法はあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">他に何か知りたいことはありますか?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">ドキュメントは十分にあるのか?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">これは投稿者だけが言語に追加してほしいものなのか、それとも広く有用なものなのか。時には、焦点を絞って機能を追加するのではなく、誰かがより一般化した機能を実装するまで待つことにしてしまうこともあります。</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">これがお目当ての書類ですか?</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">以下のようにコマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">問題 &lt;code&gt;ualarm&lt;/code&gt; 関数呼び出し。 &lt;code&gt;$interval_useconds&lt;/code&gt; オプションで、指定されていない場合、その結果はゼロになり &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 動作様。</target>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">警告を発します。</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 、 &lt;code&gt;http&lt;/code&gt; 、 &lt;code&gt;file&lt;/code&gt; 、 &lt;code&gt;git&lt;/code&gt; 、または &lt;code&gt;rsync&lt;/code&gt; uriが指すファイルをさまざまな方法でフェッチできます。</target>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">テンプレートを使って入力を検証することができます。唯一の要件は、引数に名前を付けなければならないことです。</target>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">また、 &lt;code&gt;$x&lt;/code&gt; 参照を有効にする必要がある可能性がある &lt;code&gt;$$x = 5&lt;/code&gt; など、左辺値コンテキストで特別に動作する必要があるものにフラグを付けます。</target>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">ドキュメントも埋め込まれているので</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">また、たとえば &lt;code&gt;IO::String&lt;/code&gt; ような実際のファイルシステムファイルに関連付けられていないperlファイルハンドルを渡すことができなくなりました。</target>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">また、MMクラスを介して便利なエイリアスを提供してくれます(ExtUtils/以外のMakeMakerモジュールはいらないと思っていました)。</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">また、MYクラスを介して便利なエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">また、必要に応じて、すべてのスタッシュに実効名（ &lt;code&gt;HvENAME&lt;/code&gt; ）を設定します。</target>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">また、EBCDIC は、ASCII/Latin1 の C0 コントロールと DELETE コントロールにほぼ正確な等価物を持っていることがわかりました。(C0 コントロールとは、ASCII コードポイントが 0.0x1F のもので、TAB、ACK、BEL などのようなものです。)これらの ASCII/EBCDIC コントロールの間にマッピングが設定されています。ASCII プラットフォーム上の C1 コントロールと残りの EBCDIC コントロールの間には、このような正確なマッピングはありません。何が行われてきたかというと、これらのコントロールを、ほとんど任意に、他の文字セットの中のマッチしない文字にマッピングすることです。これらのコントロールのほとんどは、最近ではEBCDICではほとんど使われておらず、その名前はあまり文句を言われることなく削除されています。例えば、EO (Eight Ones)EBCDIC コントロール (8 つの 1 ビット=0xFF からなる)は、C1 APC コントロール (0x9F)にマップされており、&quot;EO&quot; という名前を使うことはできません。</target>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">失敗すると &lt;code&gt;croak&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">それは、次のようないくつかの他のルーチン呼び出し &lt;code&gt;fbm_instr()&lt;/code&gt; 高速ボイヤームーアマッチングとし &lt;code&gt;find_byclass()&lt;/code&gt; プログラムの最初の必須regopを使用して開始を見つけるための責任があります。</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">また、アプリケーションからなるように拡張することができる&lt;b&gt;C&lt;/b&gt;に&lt;b&gt;C&lt;/b&gt;への制限しながら、&lt;b&gt;Rは&lt;/b&gt;以下の定義を使用して、上記で定義した通りに動作します。</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">ロングダブルスとダブルスが同じものであることもあります。</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">また、リソースを直接ファイルに格納することもできます。</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">もちろん、オブジェクトやクラスに対して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">保存するオブジェクトへの参照と、画像を書き込むファイル名を指定して、 &lt;code&gt;store&lt;/code&gt; を呼び出すことにより、通常の手順で使用できます。</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">このように簡単に定義することができます。</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">perlの動的な拡張機能をロードしたり、fork()したりすることができます。</target>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">以下のいずれかの形態をとることができる。</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">しかし、他のクラスのスーパークラスとして使用することもできます。これを容易にするために、生成されるコンストラクタメソッドでは 2 つの引数の blessing を使用します。さらに、クラスがハッシュベースの場合は、各要素のキーの前にクラス名が付けられます (</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">の特徴を兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">これは $treewalker coderef を構築して返します。これが呼び出されると、トラバースまたはウォークを行い、与えられた引数の optrees を STDOUT にレンダリングします。これを再利用することができ、毎回使用するレンダリングスタイルを変更することができます。</target>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">レポートに変換できるプロファイル情報のデータベースを作成します。 &lt;code&gt;nytprofhtml&lt;/code&gt; コマンドは次のようにHTMLレポートにデータを回す&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;のDevel ::カバー&lt;/a&gt;レポート：</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">現在のところ</target>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">それはあなたが「エスケープ」によって何を意味するかに依存します。URLエスケープは&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9で&lt;/a&gt;処理されます。バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）文字を含むシェルエスケープは、</target>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">これは、$-[0]と$+[0]に間違ったものを入れるという欠点がありますが、通常はこれを回避することができます。</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">UTS#18のグループ化、交差、結合、除去(減算)構文を完全に実装しています。</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; や &lt;code&gt;@&lt;/code&gt; は保護されないため、変数を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">すべてのC構文を扱うわけではありませんが、evals内の定義を分離しようとしているので、翻訳可能な定義を得ることができます。</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">それらの要素がすでにあるかどうかは関係ありません。必要に応じて、介在する要素を &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定して、喜んでそれらを作成します。</target>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">これは、サブルーチンから制御が戻ってきたときに、サブルーチンから戻ってきたすべての項目にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">これは、サブルーチンから実際には何も返されないことを保証します。</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">これは、実際にはスカラのみがサブルーチンから返されることを保証します。もちろん、このサブルーチンは</target>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">以下の変数をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">言うまでもなく、束ねることは非常に混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">配列を管理するための非常に単純なクラスを実装します。コンストラクタ &lt;code&gt;new&lt;/code&gt; とは別に、1つの静的メソッドと1つの仮想メソッドを宣言します。静的メソッド &lt;code&gt;PrintID&lt;/code&gt; は、クラス名とバージョン番号を出力します。仮想メソッド &lt;code&gt;Display&lt;/code&gt; は、配列の単一の要素を出力します。これは、Perlを使用したAll-Perlの例です。</target>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">TAP::Parser Cookbookが含まれています。</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがリストコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがスカラコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがvoidコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">それは</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">VIOアプリです。</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">つまり、英語圏の人には英語のインターフェイスを、ドイツ語圏の人にはドイツ語のインターフェイスを、といったように、プログラムされたすべての言語に対してローカライズされています。Locale::Maketextはソフトウェア・ローカリゼーションのためのフレームワークであり、ローカリゼーションされたアプリケーションを作成するために必要なテキストやテキスト処理コードを整理してアクセスするためのツールを提供します。</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">ユーザーが出力したい言語を検出したいというのは、よくある問題です。</target>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1950データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1951データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1952データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">リストコンテキスト以外でこの関数を呼び出すのは致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">非参照 $obj を登録するのは致命的なエラーです。以下の引数のうち、ハッシュでないものは無視されます。</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">perlのバージョンでキーが設定されているハッシュです。それぞれの鍵付きハッシュは以下のような鍵を持ちます。</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">をしながら、少しだけ楽になりました。</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">反転リストを展開して、そのプロパティ値を持つすべてのコードポイントの完全なリストにするのは簡単なことです。</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">&lt;code&gt;\N{NAME}&lt;/code&gt; を使用するのは構文エラーで、 &lt;code&gt;NAME&lt;/code&gt; は不明です。</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">複数のモジュールを一度にロードすることもできますし、1つのモジュールがロードできなかった場合は全くロードしないこともできます。また、エラーチェックなども行います。</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">形式名は正規表現 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; 一致することをお勧めします。formatnameの後の空白に続くものはすべて、この領域を処理するときにフォーマッターが使用できるパラメーターです。このパラメーターは、「= end」段落で繰り返すことはできません。実装者は、 &quot;= begin&quot; / &quot;= end&quot; / &quot;= for&quot;への最初のパラメーターのセマンティクスと構文の将来の拡張を予期する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">エンコーディングクラスが基本クラスとして &lt;code&gt;Encode::Encoding&lt;/code&gt; を継承することも非常に望ましいです。これにより、そのクラスはすべてのエンコーディングオブジェクトに対して追加の動作を定義できます。</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">また、インターフェイスがOS / 2、NTなどのニーズをカバーし、疑似動的リンクを可能にする（実行時に &lt;code&gt;ld -A&lt;/code&gt; を使用）ことも期待されます。</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">また、これらはデフォルトの境界定義であり、実装によっては特定の目的やロケールに合わせて結果を調整したい場合があることを理解しておくことも重要です。</target>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">逆のことが起こる可能性もあります： &lt;code&gt;prop_aliases('isc')&lt;/code&gt; はリスト &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; 返します。一方 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 戻る &lt;code&gt;(C, Other)&lt;/code&gt; （後者は意味Perl拡張である &lt;code&gt;General_Category=Other&lt;/code&gt; 。&lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;ユニコードを介してアクセス可能なプロパティ:: UCD perlunipropsの中に&lt;/a&gt;リストものを使用することから推奨される含む利用可能な形態。</target>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">miniperl&quot; と &quot;perl&quot; のための Symbian 実行ファイルを生成することも可能ですが、Symbian には標準的なコマンドラインインターフェイスがないので(デバイスにはフルキーボードもありません)、これらは主にデモンストレーションとして有用です。</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;emake&lt;/code&gt; 、 &lt;code&gt;cplx&lt;/code&gt; 、および &lt;code&gt;cplxe&lt;/code&gt; のいずれかの引数として複素数を指定することもできます。引数の適切なコンポーネントが使用されます。</target>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">代わりに、一致させたくない文字をリストすることもできます。これを行うには、キャレット（ &lt;code&gt;^&lt;/code&gt; ）を文字クラスの最初の文字として使用します。たとえば、 &lt;code&gt;[^a-z]&lt;/code&gt; は小文字のASCII文字ではないすべての文字に一致するため、100万を超えるUnicodeコードポイントが含まれます。クラスは「否定」または「反転」されていると言われます。</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">Math::BigFloatを要求するだけでも可能です。</target>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">ファイル名のパラメータを省略することも可能なので、呼び出しは</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">パラメータリストから直接値を返すことも可能ですが、実際にそれが望ましいかどうかは別問題です。</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">オプションが取る引数の最小数と最大数を指定することもできます。 &lt;code&gt;foo=s{2,4}&lt;/code&gt; は、少なくとも2つ、最大4つの引数を取るオプションを示します。 &lt;code&gt;foo=s{1,}&lt;/code&gt; は1つ以上の値を示します。 &lt;code&gt;foo:s{,}&lt;/code&gt; は0個以上のオプション値を示します。</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">事前定義された警告カテゴリが、 &lt;code&gt;warnings::enabled&lt;/code&gt; 関数を使用して呼び出しモジュールで設定されているかどうかをテストすることもできます。次のコードスニペットを考えてみます。</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">また、他のすべてのPerl演算子は、そのオペランドにコンテキスト(通常は文字列や数値のコンテキスト)を課し、それらのオペランドを課されたコンテキストに自動変換するという点でもユニークです。対照的に、スマートマッチ</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">また、 &lt;code&gt;nextStream&lt;/code&gt; はいつでも呼び出すことができることにも注意してください。次のデータストリームにスキップする前に、圧縮されたデータストリームを使い果たすまで待つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">パターンの前の &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; で定義されていない名前を参照すると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">パターンのどこかで宣言されていない名前を参照するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">をしようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">モジュール名が与えられた場合、その名前がファイル名と一致すると仮定しています。ポッドは 'NAME' エントリをチェックするためには開かれません。</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">この段階で、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; はサイレントに &lt;code&gt;/^/&lt;/code&gt; を最適化して &lt;code&gt;/^/m&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">このステップでは、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 置換テキストで &lt;code&gt;\1&lt;/code&gt; が不本意ながら &lt;code&gt;$1&lt;/code&gt; に変換され、不正解を修正します。</target>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">基本的にはこれに相当します。</target>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">インラインコードがサブルーチンやメソッド呼び出しよりも高速であることは明らかですが、このアプローチは保守性が低く、メモリ使用量が多くなるという欠点があります。リストの要素を探している場合は、例えば grep()を使って配列全体をループするよりも、 ハッシュ構造体にデータを格納して、キーが定義されているかどうかを単純に調べた方が効率的かもしれません。あなたのコードには、実行に0.01秒かかる行が含まれているかもしれません。これを1,000回呼び出すと、例えば中程度のサイズのファイルを解析するプログラムでは、一つのコードの場所だけで10秒の遅延が発生します。</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">&lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; と単純に言うのが一般的であるため、@ INC（wellおよびscriptdir）ディレクトリのみが検索されます。（これは、 &lt;code&gt;inc&lt;/code&gt; 属性がデフォルトでtrueになっているために発生します。）</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">一般的に、システムがライブラリを動的にロードする機能を持っていない場合、XSUBを構築することはできないと考えられています。これは正しくありません。あなたは</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">間接演算子 &lt;code&gt;*&lt;/code&gt; は型の一部と見なし、アドレス演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; は変数の一部と見なす必要があると考えると便利です。C型での修飾子と単項演算子の処理の詳細については、&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">変数名「属性」との類似性を強調するために、レイヤー名をコロン（ &lt;code&gt;:perlio&lt;/code&gt; など）で始めるのが一般的です。ただし、PERLIO環境変数のデコードにも使用されるレイヤー指定文字列を解析するコードは、コロンを区切り文字として扱います。</target>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">将来的には、（（X）HTMLが &lt;code&gt;&amp;amp;infin;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 、または &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; で（X）HTMLがサポートするように）ますます多くのフォーマット（およびフォーマッター）がUnicode文字をサポートし、特異性の必要性を減らすことが切望されています Unicode-to-のマッピング</target>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">コメントがあると見やすいです。</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">サブルーチンがプロトタイプとシグネチャの両方を持つことは完全に可能です。プロトタイプはサブルーチンの呼び出しのコンパイルに影響を与え、シグネチャは実行時に引数の値を辞書変数に格納します。したがって、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">文字や文字列に独自の名前を付けることもできます。詳細については、&lt;a href=&quot;charnames&quot;&gt;charnamesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">明示的に変更されることが想定されていないメソッドの引数は一定であることが期待されています (ただし、これは強制されていません)。</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">厳密に &lt;code&gt;'strict'&lt;/code&gt; ことは、経験を積むにつれて時間とともに進化することが予想されます。つまり、今日のPerlでその下でコンパイルされるプログラムは、将来のPerlではコンパイルされないか、警告の数が増減する可能性があります。それに関して後方互換性の約束はありません。また、それを有効にするための代替構文の提案もすでにあります。これらの理由により、このカテゴリをオフにしない限り、これを使用すると、 &lt;code&gt;experimental::re_strict&lt;/code&gt; クラスの警告が発生します。</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">ご要望に応じてエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">一般に、UTF-8 以外のロケールと Unicode を混在させることはよくない考えであり、この問題はその理由のひとつです。この警告は、Unicode のルールにより、通常はこの操作の結果にロケールで指定された 0 ~ 255 の範囲内の文字が含まれている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">それは保証されています。</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">が保証されています。</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">&lt;code&gt;[A-Z]&lt;/code&gt; 、 &lt;code&gt;[a-z]&lt;/code&gt; 、および &lt;code&gt;[0-9]&lt;/code&gt; のサブセット以外の範囲に正確に一致するものを掘り下げることなく理解することは困難です。正しい原則は、大文字と小文字が等しい（[ae]、[AE]）、または数字（[0-9]）で開始および終了する範囲のみを使用することです。それ以外のものは、安全でないか不明確です。疑問がある場合は、範囲全体を詳しく説明してください。</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">新しいインターフェイスを使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">しかし、バックスラッシュやエスケープシーケンスの後に句読点文字が続くことはないことが保証されています。 現在も、Perl 5 の将来のバージョンでも、バックスラッシュを単語以外の文字の前に置いても安全です。</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">標準のperl TIEHASHインターフェイスを使用して実装されます。詳細については、perlfunc（1）およびperltie（1）の &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">詳細については、特にopname、optags、opsetsの詳細な定義については、&lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt;モジュールのドキュメントを読むことが重要です。</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">サポートされている 'make' プログラムを使い、Config.pm がそれを知っていることを確認することが重要です。nmake を持っていない場合は、前述の場所から dmake を入手するか、古いバージョンの nmake を以下から入手することができます。</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">&lt;code&gt;make dist&lt;/code&gt; をできるだけ早く行うことが重要です。これにより、 &lt;code&gt;.h&lt;/code&gt; ファイルを編集してh2xsを再実行する場合に、変更を自動生成されたファイルに簡単にマージ（1）できます。</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">コマンドラインに特殊文字、特に引用符やバックスラッシュが含まれている場合、これらのCLIの動作が異なる場合があることを知っておくことが重要です。たとえば、Unixシェルでは、一重引用符（ &lt;code&gt;'&lt;/code&gt; ）と二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）を使用して単語をグループ化できます。Unixでは、次の代替案は同等です。</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">変数にスレッド &lt;code&gt;cond_signal&lt;/code&gt; または &lt;code&gt;cond_broadcast&lt;/code&gt; がない場合でも、変数に通知できることに注意することが重要です。したがって、変数の値を確認し、要件が満たされていない場合は待機に戻ることが重要です。たとえば、共有カウンターがゼロになるまで一時停止するには：</target>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">これらの Unicode 境界線を使用する際に重要なことは、Unicode 標準の後のバージョンを含む Perl の将来のバージョンでは、あなたのコードが書かれた時と正確に同じように動作しないリスクを負っているということを認識しておくことです。これらの規則は安定しているとは考えられず、標準規格の他の部分よりも変更されやすいものです。Unicode はこれらを自由に変更する権利を留保し、Perl は Unicode の新しいルールに合わせて実装を更新する権利を留保します。過去には、いくつかの変更は、以前のすべての文字とは異なる特性を持つ新しい文字が標準に追加されたため、それらを扱うための新しい規則が策定されたことに起因しています。これらによって下位互換性の問題が生じることはないはずです。しかし、Unicode技術委員会が何らかの理由で変更が必要だと判断したために、既存の文字の扱いを変更したものもあります。これは、バグを修正するためだったり、新しいルールの方がより良い結果が得られると考えたためだったりします。</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">&lt;code&gt;yield()&lt;/code&gt; はCPUをあきらめるためのヒントにすぎず、実際に何が発生するかはハードウェア、OS、およびスレッド化ライブラリに依存することを覚えておくことが重要です。&lt;b&gt;多くのオペレーティングシステムでは、yield（）は何もしません。&lt;/b&gt;したがって、 &lt;code&gt;yield()&lt;/code&gt; 呼び出しの周りのスレッドのスケジューリングを構築してはならないことに注意することが重要です。お使いのプラットフォームでは動作する可能性がありますが、別のプラットフォームでは動作しません。</target>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">このように呼ばれることを意図しています。</target>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; と &lt;code&gt;gzreadline&lt;/code&gt; の呼び出しを混在させることは合法です。</target>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">結果を完全に計算してから明示的に丸めるか、数学関数に追加のパラメータを使ってこのようにした方が混乱しません。</target>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">たとえば、 &lt;code&gt;foreach&lt;/code&gt; ループで使用するのが最も便利です。</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">PA-RISC 1.1または2.0プラットフォーム上でPA-RISC 1.0の実行ファイルをコンパイルすることができなくなりました。コマンドラインフラグは受け入れられますが、PA-RISC 1.0システムに転送された実行ファイルは実行されません。</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">PA-RISC 1.0の共有ライブラリをリンクすることができなくなりました(コマンドラインフラグが残っているにもかかわらず)。</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;EWOULDBLOCK&lt;/code&gt; （または同等の）条件が原因で失敗した場合に &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; がfalseを返すことは、エラーとは見なされません。これは、 &lt;code&gt;LOCK_NB&lt;/code&gt; オプションを指定して呼び出されたときに、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の戻り値をテストするという一般的な規則を引き続き使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">関数 &lt;code&gt;fieldhash&lt;/code&gt; や &lt;code&gt;fieldhashes&lt;/code&gt; を使用するすべてのクラスにインポートすることは望ましくありません。これらは、クラスのセットアップに1回だけ使用されます。クラスが稼働しているとき、これらの関数はもはや目的を果たしません。</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">既にチェリーピックされている変更に伴うペルデルタエントリのチェリーピックに関する投票が行われる必要はなく、また、メインパンプキングで必要とされる変更に対する投票を得るために</target>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">これらの基準を満たすすべての変更を含める必要はありません。一般に、セキュリティの問題、クラッシュするバグ、リグレッション、および深刻なインストールの問題に対処することに焦点を当てる必要があります。 perlのインストールや実行に影響を及ぼさない多くの小さな変更（たとえば、ドキュメントのスペル修正）を含める誘惑は、何かを見落とす全体的なリスクを減らすために抵抗されるべきです。その目的は、価値があり、ユーザーが安定性に完全に自信を持つことができるメンテナンスリリースを作成することです。 （2番目の懸念は、含まれる変更に投票するmaint-pumpingまたは圧倒的な他のコミッターの燃え尽きを避けることです（以下の&lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;maintブランチへの変更の取得を&lt;/a&gt;参照）。）</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">INCLUDE_EXTを記入する際に、DynaLoaderや現在の拡張機能を指定する必要はありません。INCLUDE_EXTが指定されていても空の場合は、DynaLoaderと現在の拡張機能のみがビルドに含まれます。</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">定数と同じ名前のサブルーチンやキーワードを同じパッケージ内に持つことはできません。これはおそらく良いことだと思います。</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">ビットフィールドをパックまたはアンパックすることはできません。整数バイトのみです。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; は常に次のバイト境界から始まり、必要に応じてゼロビットを追加することにより、次の8の倍数に「切り上げ」ます。（ビットフィールドが必要な場合は&lt;a href=&quot;functions/vec&quot;&gt;vecを使用し&lt;/a&gt;ます。または、アンパックされたビット文字列に対してsplit、substr、および連結を使用して、文字列レベルでビットフィールド処理を実装できます。）</target>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">&lt;code&gt;$^X&lt;/code&gt; 値をファイルのパス名として使用するのは安全ではありません。実行可能ファイルに必須のサフィックスがあるオペレーティングシステムでは、コマンドを呼び出すときにサフィックスを使用する必要がないためです。 &lt;code&gt;$^X&lt;/code&gt; 値をパス名に変換するには、次のステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">ある範囲の文字に一致させたいことは珍しくありません。幸いなことに、範囲内のすべての文字をリストする代わりに、ハイフン（ &lt;code&gt;-&lt;/code&gt; ）を使用できます。括弧で囲まれた文字クラス内に2つの文字がハイフンで区切られている場合、2つの文字の間のすべての文字がクラス内にあるかのように扱われます。たとえば、 &lt;code&gt;[0-9]&lt;/code&gt; は任意のASCII数字に一致し、 &lt;code&gt;[a-m]&lt;/code&gt; はASCIIアルファベットの前半の小文字に一致します。</target>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">現在、Dave Rolsky &amp;lt;autarch@urth.org&amp;gt;によって、Perlコアとは別に保守されています。</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">キーと値のペア間で &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子を使用する方が読みやすいことがよくあります。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子は、ほとんどがカンマのためだけの、より視覚的に独特の同義語であるが、それは法的な単純な識別子となり裸の単語だ場合、それはまた、その左側を手配は、文字列として解釈されるオペランド。 &lt;code&gt;=&amp;gt;&lt;/code&gt; は、二重コロンを含む複合識別子を引用しません。これは、ハッシュの初期化に適しています。</target>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">クラス自体が共有をサポートするように書かれていない限り、オブジェクトを共有することは賢明ではないことが多いです。例えば、オブジェクトのデストラクタが複数回呼ばれ、各スレッドのスコープ終了時に一度だけ呼び出されるかもしれません。もう一つの危険は、ハッシュベースのオブジェクトの内容が上記の制限のために失われてしまうことです。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">CODE:」の行から始まる行はインデントしなくても構いません。しかし、可読性を考慮して、CODE:は 1 レベル、それに続く行はさらに 1 レベルインデントすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">OS/2とWin32でしか使用していません。</target>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">シェルも C ランタイムもコマンドライン引数のワイルドカード展開を行わないことに注意してください(ワイルドカードは引用符で囲む必要はありません)。また、シェルと C ランタイムのクォートの動作は、せいぜい初歩的なものです (標準ではないシェルを使用している場合は、一貫性がないかもしれません)。唯一の(有用な)クォート文字はダブルクォート(&quot;)です。これは、引数に含まれるスペースやその他の特殊文字を保護するために使用できます。</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">呼び出したPerlのサブルーチンが異常終了する可能性があります。</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">完了時に、文字列内のすべての引数が処理されていない可能性があります。 &lt;code&gt;GetOptionsFromString&lt;/code&gt; は、リストコンテキストで呼び出されると、戻りステータスと残りの引数への配列参照の両方を返します。</target>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">適切なコードで&lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt;または&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;を使用すると、&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;ENDブロック&lt;/a&gt;をスレッドに追加できます。これらの &lt;code&gt;END&lt;/code&gt; ブロックは、スレッドのインタープリターが破棄されたときに実行されます（つまり、 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 呼び出し中、またはプログラムの終了時）。</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;プラグマを使用して、異なるメソッド解決順序を要求することができます。</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">標準の Devel::Peek モジュールの mstat()関数を使用して、実行中の任意のポイントでそのような統計量を求めることができます。</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">Solaris上でスレッド化されたバージョンのperlを構築することは可能です。しかし、Perl のスレッドの実装全体はまだ実験的なものなので、注意が必要です。</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">10.30以前のどのバージョンのHP-UXでもスレッド付きPerlをコンパイルすることは可能ですが、少なくともHP-UX 11.00で動作することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">&lt;code&gt;$Text::Wrap::break&lt;/code&gt; 変更することで、どの文字が単語を終了させるかを制御できます。これを &lt;code&gt;'[\s:]'&lt;/code&gt; （スペースまたはコロンの前で区切る）などの文字列、または &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; （スペースまたはアポストロフィの前で区切る）などの事前にコンパイルされた正規表現に設定します。デフォルトは単に &lt;code&gt;'\s'&lt;/code&gt; です。つまり、単語はスペースで終了します。 （これは、とりわけ、フルストップやコンマなどの末尾の句読点は、それらが「付加された」単語にとどまることを意味します。） &lt;code&gt;$Text::Wrap::break&lt;/code&gt; を、文字をまったく使用しない正規表現に設定します（おそらく、先読みのアサーションのみ）は警告を引き起こします。</target>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">Perlでは「循環参照」を作成することが可能で、これがメモリリークにつながる可能性があります。循環参照は、次のように、2つの参照がお互いへの参照を含む場合に発生します。</target>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">操作している文字セットを判別することができます。ただし、最初に、これを実行する必要があることを本当に確認する必要があります。文字セットをテストしてさまざまなことを実行する必要がない場合は、コードはより単純になり、おそらく移植性が同じになります。実際には、すべての文字セットに移植可能な直線的なコードを書くのが容易ではない状況はごくわずかです。文字を移植可能に指定する方法について&lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;は、perluniintroのUnicodeおよびEBCDICを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">子から明示的に親メソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">単独ダッシュに対して特別な扱いを得ることが可能です。これは、例えば空の名前でオプション指定を追加することで実現できます。</target>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">REエンジンに与えられた文字列と結果の有限オートマトンの両方を検査することが可能です。 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;プラグマの引数 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; と、perlrunの&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;コマンドスイッチに&lt;/a&gt;記載されているPerlの&lt;b&gt;-Dr&lt;/b&gt;コマンドラインスイッチを参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">同じ出力チャネルでprint（）とwrite（）を混在させることは可能ですが、 &lt;code&gt;$-&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ）を自分で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; をより要求の厳しい方法で再ディスパッチすることは可能です（つまり、 &lt;code&gt;SUPER&lt;/code&gt; のように）。呼び出す「次の」メソッドが見つからない場合、再ディスパッチは例外をスローします。</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; を手動で設定することは可能であり、古いPerlコードでこれを確認できます。はるかに古いコードでも&lt;a href=&quot;base&quot;&gt;base&lt;/a&gt;プラグマを使用しています。新しいコードの場合は、&lt;a href=&quot;parent&quot;&gt;親&lt;/a&gt;プラグマを使用して親を宣言することをお勧めします。このプラグマは &lt;code&gt;@ISA&lt;/code&gt; の設定を処理します。また、親クラスをロードし、パッケージがそれ自体から継承しないことを確認します。</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; の呼び出しで最後の4つのパラメーターの一部またはすべてを省略して、それらにデフォルト値を使用させることができます。DB_HASHが最も一般的に使用されるファイル形式であるため、次の呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;[ $test, $alias ]&lt;/code&gt; を含む配列への参照としてテストを提供することにより、テスト名の代わりに表示されるエイリアスを提供することができます。</target>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">このような英数字の名前を、適切なタイプへの参照を返す式に置き換えることができます。この説明については、&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">サブルーチンから修正可能な値を返すことができます。そのためには、lvalueを返すサブルーチンを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">複数のhere-docを一列に積み重ねることができます。</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">ビルドプロセスで作成されたEXEとDLLを取り除くことが可能です。結果のバイナリは大幅に小さくなります。バイナリを削除したい場合は、Configureがプロンプトを表示したときに&lt;b&gt;-s&lt;/b&gt;オプションを追加するか、</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">テストに引数を与えることができます。これを行うには、arrisdottle,':::' で prove 自身の引数と分離してください。例えば</target>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">C/XS と Perl の両方で、上記のビルトインレイヤーに加えてカスタムレイヤーを書くことができます。そのような 2 つのレイヤ (および後者を使って Perl で書かれた 1 つの例)が Perl ディストリビューションに付属しています。</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">書くことは可能です。</target>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(?{})&lt;/code&gt; または &lt;code&gt;(??{})&lt;/code&gt; と組み合わせた場合にのみ役立つでしょう。</target>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">Perlの将来のリリースでは、この動作を変更して、Unicodeルールが有効かどうかにかかわらず動作を変更しないようにすることが提案されています。ロケール以外では、POSIXクラスはASCII範囲のクラスのように動作します。この提案にコメントしたい場合は、 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; にメールを送信してください。</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">この使用法では、DEFINEブロックをパターンの最後に置き、その中で定義されたサブパターンに名前を付けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">本当に非標準のZipファイルを作成する必要がない限り、このオプションを有効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">以下のアーカイブには、perlをビルドするのに十分なユーティリティが含まれていると報告されています。</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">小文字の名前はOpcodeモジュールで使用するために予約されているため、Opcodeを使用するアプリケーションでは、タグ名の先頭に大文字を使用することが強く推奨されています。モジュール内でOpcodeを使用する場合は、タグ名の前にモジュールの名前を付けて、独自性を確保し、他のモジュールとの衝突を避けるようにしてください。</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">スクリプトのできるだけ早い段階で、スレッドを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; を有効にすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">Configure を実行する際には、このフラグを使用することを強くお勧めします。これを行わずに、後になって Configure が大きなファイルについての質問に答えた場合、コンパイルできない設定や期待通りに機能しない設定が得られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">Perl で配布されている malloc のバージョンを有効にすることをお勧めします。これは、より迅速に割り当て要求を満たすために、様々なサイズの未割り当てメモリのプールを保持します。しかし、いくつかのプラットフォームでは、これが原因でスプリアス malloc やフリーエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">padname 配列からレキシカル変数の名前を取得する必要がある場合に使用する適切なメソッドです。レキシカル変数名は常にヌルのターミネータで格納され、長さフィールド (CUR)は他の目的のためにオーバーロードされており、ここでは頼りにすることはできません。</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">そのため、これらのマクロは、静的データを利用している全てのXSモジュールで利用することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">これは通常、perlの検索パスにディレクトリを追加するために使用されます。これにより、後で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ステートメントがperlのデフォルトの検索パスにないモジュールを見つけられるようになります。</target>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">レンダリング不能な文字（パーサーが何も解決できなかった（レンダリング可能かどうかに関係なく）不明なE &amp;lt;thing&amp;gt;シーケンスとは異なる）直面したときに適切な判断を表示するかどうかは、個々のPodフォーマッター次第です。アクセント記号付きのラテン文字（ &quot;E &amp;lt;eacute&amp;gt;&quot; / &quot;E &amp;lt;233&amp;gt;&quot;など）を対応するアクセントなしUS-ASCII文字（単純な文字101、 &quot;e&quot;など）にマップすることをお勧めしますが、これは明らかに多くの場合、実行不可能であり、レンダリングできない文字は「？」などとして表されます。 （E &amp;lt;233&amp;gt;から &quot;e&quot;へのように）正常なフォールバックを試行する際、ポッドフォーマッタは、可能であれば&lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt;または&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode&lt;/a&gt;の％Latin1Code_to_fallbackテーブルを使用できます。</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">この情報を使用して、以下の情報を入力するかどうかはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">パラメータを渡す際には、@_ではなくグローバル変数を使用するのが一般的です (通常、パラメータが一つの場合は $_、二つの場合は $a と $b を使用します)。(何をしているかわかっていれば @_の仕組みを使うことも可能ですが、まだサポートされている API はありません。これは本質的に遅くなります)。</target>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは通常の混在に間違いである &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ので、通話 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 内部であなたのシステム上に実装することができる &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは通常の混在に間違いである &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ので、通話 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 内部であなたのシステム上に実装することができる &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">いくつかの既存のプログラムを壊さずにPerlに新しい構文を追加することは通常不可能です。このプラグマは、そのリスクを最小限に抑える方法を提供します。新しい構文構造、または古い構造に対する新しい意味の意味は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用して&lt;/a&gt;有効にでき、適切な機能プラグマがスコープ内にある場合にのみ解析されます。（それにもかかわらず、 &lt;code&gt;CORE::&lt;/code&gt; プレフィックスは、このプラグマに関係なく、すべてのPerlキーワードへのアクセスを提供します。）</target>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">ソースをフィルタリングする際に、コードの文字列以外の部分だけにフィルタを適用したい場合や、代わりに</target>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">この形式のopen（）を使用してプロセスをデッドロックするのは非常に簡単です。実際、複数のサブプロセスでpipe（）を使用する場合も同様です。上記の例は簡単でexec（）を呼び出すため、「安全」です。一般的な安全原則については、&lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;パイプのデッドロックの回避を&lt;/a&gt;参照してください。ただし、安全なパイプを開くには、余分な問題があります。</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">大文字小文字の保存を扱える状態が異なる他のプログラム、外部ユーティリティ、Perlスクリプトが混在していると、非常につまずきやすくなります。例えば、古いバージョンのアーカイブユーティリティや MMK や MMS のようなビルドユーティリティによって作成されたファイルは、ODS-5 ボリューム上であっても、すべて大文字でファイル名を生成することがあります。このファイル名が後に大文字小文字を保存した環境で Perl スクリプトやモジュールによって取得された場合、大文字と小文字が混在した Perl コードの期待値と一致しない可能性があります。最善の策は、大文字小文字の区別を一切つけないアプローチに従うことです。</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">Perlプログラムのソースを復元するのは非常に簡単です。単にプログラムを perl インタプリタに送り、B::階層のモジュールを使用するだけです。B::Deparse モジュールは、ソースを隠そうとするほとんどの試みを打ち破ることができるはずです。繰り返しになりますが、これは Perl に特有のものではありません。</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">このドキュメントは、カジュアルな読者にとってはあまり役に立たない可能性があります。読者は&lt;a href=&quot;../perlguts&quot;&gt;perlgutsの&lt;/a&gt;最初の数セクションの内容を理解することが期待されています。</target>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供された値の予想範囲に特に注意を払う価値があります。月の日の値は実際の日（つまり1..31）であり、月は1月からの月数（0..11）です。これは、 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; から返される値と一致しています。</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; などは、完全な数字や単語ではなく単一の文字と一致することを強調しておく価値があります。数字（数字で構成される）を照合するには、 &lt;code&gt;\d+&lt;/code&gt; 使用します。単語に一致させるには、 &lt;code&gt;\w+&lt;/code&gt; 使用します。ただし、上記のように、セキュリティに関する考慮事項に注意してください。</target>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 不適切に使用すると、無限ループが発生する可能性があることに注意してください。 &lt;code&gt;\G&lt;/code&gt; を含むパターンを交互に使用するときは注意してください。</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">Unicodeには、0〜9に相当し、正規表現の &lt;code&gt;\d&lt;/code&gt; と一致する数字のセットがいくつかあることを強調しておきます。それらが単一の言語でのみ使用されている場合、それらはその言語の &lt;code&gt;Script&lt;/code&gt; および &lt;code&gt;Script_Extension&lt;/code&gt; にあります。それらが複数のスクリプトで使用されている場合、それらは &lt;code&gt;sc=Common&lt;/code&gt; に &lt;code&gt;scx=Common&lt;/code&gt; ますが、多くのスクリプトで使用されている場合のみ、scx = Commonに含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">それは結局のところ、単なる推測に過ぎません。エンコーディングに関しては、常に明示的にする必要があります。しかし、特に日本語の環境によっては推測符号化が必須となる場合があります。このモジュールは注意して使ってください。</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">しかし、これは非常にシンプルで純粋な Perl であり、コアではない依存関係はありません。また、サポートしている機能のために、オンデマンドで &quot;Moe-like&quot; API を提供しています。</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">バックスラッシュ演算子を使用して、IOハンドル（ファイルハンドルまたはディレクトリハンドル）への真の参照を作成することはできません。取得できるのは、実際には完全なシンボルテーブルエントリであるtypeglobへの参照です。ただし、以下の &lt;code&gt;*foo{THING}&lt;/code&gt; 構文の説明を参照してください。ただし、タイプグロブとグロブリファレンスは、IOハンドルであるかのように使用できます。</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; でできます。</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">また、C:\Program Files\Microsoft Visual C++Toolkit 2003 に lib.bat というバッチファイルを作成しておくと便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">また、スペルミスをした定数が裸語として解釈されたことを示すこともあります。</target>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">番号を取得する関数やメソッドを追加しておくと便利かもしれません。モジュール(ModuleName-1.02.tar.Z)をリリースする際に、アナウンスやアーカイブファイル名にこの番号を使用してください。詳細は perldoc ExtUtils::MakeMaker.pm を参照してください。</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">スクリプトI / OがデバッガーI / Oから分離されるように、常にフォークされたデバッガーを使用すると役立つ場合があります。プロセス識別番号ではない論理名&amp;lt;PERLDB_PIDS&amp;gt;に値を割り当てることにより、デバッガーを強制的に分岐させることができます。</target>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">代わりに&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;モジュールを使用する方が移植性が高い場合があります。新しいファイルに新しい名前でコピーし（戻り値を確認）、古いファイルを削除します。これは、パーミッション、タイムスタンプ、inode情報などのメタ情報を保持する &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; と意味的には同じではありません。</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">以下のような簡単な回避策をコード化することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;から入手できる（Perlで書かれた）Entropy Gathering Daemonを使用できる場合があります。</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">当たり前のことを言っているように思えるかもしれませんが、Perlはユーザが簡単に見つけられるようになって初めて便利になります。可能であれば</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">おそらく、chdir（）でディレクトリに戻れず、chdir（）で戻せない可能性があります。fastcwdで問題が発生した場合は、undefが返されますが、別のディレクトリにいる可能性があります。すべてが働いているように見える場合は、余分なセキュリティの対策については、fastcwd（）関数は、それが中に開始したことを同じディレクトリにあなたを残していることを確認します。それがされます変更された場合は &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; メッセージ「不安定なディレクトリパス、現在でディレクトリが予期せず変更されました。」それは決して起こらないはずです。</target>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">強調しておきたいのは、DynaLoaderはそれ自体がPerl以外のライブラリへのアクセスにはほとんど役に立たないということです。例えば、Cライブラリの関数を呼び出したり、引数を与えたりするメカニズムはありません。C::DynaLibモジュールはCPANのサイトから入手可能で、いくつかの一般的なシステムタイプのためにその機能を実行します。また、2000年以降は、PerlのサブルーチンをCで書くことができるモジュールであるInline::Cもあります。</target>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">特に、$ _を割り当てるルーチンで$ _ を &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; することが重要です。 &lt;code&gt;while&lt;/code&gt; 条件付きの暗黙の割り当てに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">以下の動作を行います。</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">印刷されます(改行があまりなくても</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;bdiv()&lt;/code&gt; を呼び出すため、商と剰余の両方を出力します。また、 &lt;code&gt;bdiv()&lt;/code&gt; は$ cを変更するため、注意が必要です。おそらく使いたい</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで動作するので、商と余りの両方を表示します。また、bdiv()は $c を変更しますので、注意してください。おそらく</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;brsft()&lt;/code&gt; を呼び出すため、商と剰余の両方を出力します。また、 &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; は$ cを変更するので注意してください。おそらく使いたい</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; を呼び出しているため、数値と小数部の両方の桁数を出力します。次のようなものを使用してください：</target>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">各サブルーチン呼び出しのシーケンス番号と呼び出されたサブルーチンの名前を出力します。 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; ディレクティブを使用してパッケージ &lt;code&gt;DB&lt;/code&gt; にコンパイルされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">この情報を問い合わせるための多くのメカニズムを提供しています。</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">メソッドのデフォルトの実装を提供します。</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">滅多に起こることではありませんが、ハーネスが「ミッシングテスト」に遭遇することがあります。</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">派生プロパティ Comp_Ex (Full_Composition_Exclusion)のブール値を返します。このプロパティは、Composition Exclusions+Singletons+Non-Starter Decomposition から生成されます。</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">派生プロパティNFC_MAYBE(NFC_Quick_Check=Maybe)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFC_NO(NFC_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">派生プロパティ NFD_NO (NFD_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">派生プロパティNFKC_MAYBE(NFKC_Quick_Check=Maybe)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFKC_NO(NFKC_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFKD_NO(NFKD_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">これは、指定されたコードポイントの文字が、特定の構図(ハングル構図を含むが、構図除外と非スターター構図を除く)の中で前のものと一緒に構図されてもよいかどうかをブール値で返します。</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">コードポイントがNon-Starter Decompositionを持っているかどうかのブール値を返します。</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">コードポイントが合成除外であるかどうかをブール値で返します。</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">コードポイントがシングルトンであるかどうかのブール値を返します。</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$Bzip2Error&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$DeflateError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$GzipError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$RawDeflateError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Zip&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$ZipError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">4つまたは5つのスカラー値の配列を返します。EXTRALIBS,BSLOADLIBS,LDLOADLIBS,LD_RUN_PATH,そしてオプションとして、実際のライブラリのファイル名の配列への参照を返します。これらの中には、Unix 上でなければ何の意味もないものもあります。これらのプラットフォームに関する詳細は以下を参照してください。ファイル名のリストは、 $need_names 引数が真の場合にのみ返されます。</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">&lt;code&gt;PACKAGE&lt;/code&gt; がまだロードされていない場合は、fallが返され、正常にロードされたと言われる場所が返されます。</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">FCCフォーム(「Fast C Contiguous」;cf.UTN #5)を返す。</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">正規化形式C(正準分解に続いて正準合成によって形成される)を返します。</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">正規化形式D(正準分解によって形成された)を返します。</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">正規化形式KCを返します（互換性分解とそれに続く&lt;b&gt;正規&lt;/b&gt;構成によって形成されます）。</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">正規化フォームKD(互換性分解によって形成された)を返します。</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">文字の結合クラス(整数)を返します。</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">文字列の各文字を分解して連結したものを返します。</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; 正規化形式を返します。</target>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">残りの &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; 返します。ここで、 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; です。 &lt;code&gt;$r&lt;/code&gt; 同じ符号有し &lt;code&gt;$x&lt;/code&gt; 未満の大きさ以上と大きさ（絶対値） &lt;code&gt;$y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">分解を適用せずに正準合成の結果を返します。</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">正準順序動作に従って結合文字を並べ替えた結果を返します。</target>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。 &lt;code&gt;NO&lt;/code&gt; の場合はfalse（ &lt;code&gt;empty string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。偽（ &lt;code&gt;empty string&lt;/code&gt; ）であれば &lt;code&gt;NO&lt;/code&gt; 。 &lt;code&gt;MAYBE&lt;/code&gt; の場合は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">すべて問題なければ、trueを返します。それ以外の場合は、DIAGNOSTICSセクションのメッセージの1つで &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">キーが基準にマッチした場合は真、そうでない場合は偽を返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
