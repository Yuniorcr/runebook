<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">サーバーに使用を要求するプロトコルレベルのWebSocket拡張機能を1つ以上指定します。リクエストで複数の &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; ヘッダーを使用することは許可されています。結果は、リストされているすべての拡張機能を1つのヘッダーに含めた場合と同じです。</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing APIの&lt;/a&gt;機能を介して取得された属性の値の表示を許可されるオリジンを指定します。そうでない場合、クロスオリジンの制限によりゼロとして報告されます。</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">ユーザーエージェントが Expect-CT の失敗を報告すべき URI を指定します。</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">クライアントが使用したい WebSocket プロトコルのバージョンを指定します。</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">サーバーのドメイン名 (仮想ホスティングの場合)、および (オプションで)サーバーがリッスンしている TCP ポート番号を指定します。</target>
        </trans-unit>
        <trans-unit id="efd15c591f12965b47534e1779aff0b7120829dc" translate="yes" xml:space="preserve">
          <source>Specifies the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">エンティティをユーザーに安全に転送するために使用するエンコーディングの形式を指定します。</target>
        </trans-unit>
        <trans-unit id="413e001d0b162dbca41b0e7d35c867d5721df5a5" translate="yes" xml:space="preserve">
          <source>Specifies the lifetime of the policy, in seconds (in a similar way to e.g. HSTS policies are time-restricted). The referenced reporting group should have a lifetime at least as long as the NEL policy.</source>
          <target state="translated">ポリシーの有効期間を秒単位で指定します(HSTSポリシーの時間制限と同様の方法で)。参照されるレポートグループは、少なくともNELポリシーと同じ長さの有効期間を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">リソースが新しいと見なされる最大時間を指定します。 &lt;code&gt;Expires&lt;/code&gt; とは異なり、このディレクティブはリクエストの時間に関連しています。</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">プリフライト要求に応答してリソースにアクセスする際に許可される方法または方法を指定します。</target>
        </trans-unit>
        <trans-unit id="495731834481a81b8123951704e2abcb07625db8" translate="yes" xml:space="preserve">
          <source>Specifies the methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">プリフライト要求に応答してリソースにアクセスする際に許可されるメソッドを指定します。</target>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダーフィールドを受信してから、ユーザーエージェントがメッセージの送信元のホストを既知のExpect-CTホストと見なすまでの秒数を指定します。</target>
        </trans-unit>
        <trans-unit id="7f43b9fd51101abb87a0368fc81d197d96a63735" translate="yes" xml:space="preserve">
          <source>Specifies the origin &quot;null&quot;.</source>
          <target state="translated">原点 &quot;null &quot;を指定します。</target>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">エンティティをユーザーに安全に転送するために使用するエンコーディングの形式を指定します。</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">ユーザーエージェントが受け入れたい転送エンコーディングを指定します。</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">クッキーが送られるホストを指定します。指定されない場合は、現在の文書の場所のホスト部分がデフォルトです(サブドメインは含まれません)。以前の仕様に反して、ドメイン名の先頭のドットは無視されます。ドメインが指定されている場合、サブドメインは常に含まれます。</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用してページを埋め込むことができる有効な親を指定します。</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt;接続の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;スクリプトの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="d098bd02b96b2bdcbdaec1bb10a529856955c4ce" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; elements.</target>
        </trans-unit>
        <trans-unit id="3b6311b937bff61b4874ab442d4d9dbb9f3cc22f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript inline event handlers.</source>
          <target state="translated">JavaScriptインラインイベントハンドラの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">JavaScriptの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;を使用してロードされたフォントの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="db33d91daba98ebe85d45f79cd3a62539127fa18" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">個々の DOM 要素に適用されるインラインスタイルの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して、ネストされたブラウジングコンテキストの読み込みに有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="ae55d19529942a4f7114ca5f6d12086fa3126f81" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">アプリケーション マニフェスト ファイルの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">画像やファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">プリフェッチまたはプリレンダする有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="951baad47e3b7bd99fb8056c2485c87379c7b510" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</source>
          <target state="translated">Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</target>
        </trans-unit>
        <trans-unit id="9e61777977f07fdafd61735735d76ae50997e152" translate="yes" xml:space="preserve">
          <source>Specifying a fallback policy</source>
          <target state="translated">フォールバックポリシーの指定</target>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">レガシードキュメントモードの指定</target>
        </trans-unit>
        <trans-unit id="85f30ba6e5f19f51628bda67d9500dab94232f9a" translate="yes" xml:space="preserve">
          <source>Specifying multiple links</source>
          <target state="translated">複数のリンクを指定する</target>
        </trans-unit>
        <trans-unit id="f65d134dfe7e03e4b9a14898c4ef7cc4877bc321" translate="yes" xml:space="preserve">
          <source>Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</source>
          <target state="translated">Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</target>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">あなたのポリシーを指定する</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">クライアントがHTTPリクエストで使用できる標準の &lt;code&gt;Cache-Control&lt;/code&gt; ディレクティブ。</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">サーバーがHTTP応答で使用できる標準の &lt;code&gt;Cache-Control&lt;/code&gt; ディレクティブ。</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">標準化された方法は一般的です。つまり、特定のメディアタイプ、リソースの種類、またはアプリケーションだけでなく、あらゆるリソースに適用できる可能性があります。そのため、直交技術は直交仕様に値するため、単一のアプリケーションまたはデータ形式に固有ではないドキュメントに新しいメソッドを登録することをお勧めします。メッセージ解析以降（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230]のセクション3.3）&lt;/a&gt;）（HEADへの応答は別として）メソッドのセマンティクスから独立している必要があります。新しいメソッドの定義では、解析アルゴリズムを変更したり、要求または応答メッセージのいずれかにメッセージ本文が存在することを禁止したりできません。新しいメソッドの定義では、値が「0」のContent-Lengthヘッダーフィールドを要求することにより、長さゼロのメッセージ本文のみが許可されることを指定できます。新しいメソッド定義は、それが安全（&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt;）、べき等（&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt;）、キャッシュ可能（&lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt;）であるかどうかを示す必要があります。）、リクエストにペイロード本体が存在する場合にペイロード本体に関連付けるセマンティクス、およびヘッダーフィールドまたはステータスコードのセマンティクスに対してメソッドが行う調整。新しいメソッドがキャッシュ可能である場合、その定義は、どのように、どのような条件下で、キャッシュが応答を格納し、後続の要求を満たすためにそれを使用できるかを説明する必要があります。新しいメソッドは、それを条件付きにすることができるかどうか（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）を記述し、条件付きである場合は、条件がfalseの場合にサーバーがどのように応答するかを記述します。同様に、もし新しいメソッドがパーシャルレスポンスセマンティクス（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]）、これも文書化する必要があります。注：「M-」で始まるメソッド名の定義は避けてください。その接頭辞は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ] によってセマンティクスが割り当てられていると誤って解釈される可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">スタートライン</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">Chrome 61 以降、これはフレームのすべての先祖に適用されます。</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">Firefox 59 以降、これはフレームのすべての先祖に適用されます。</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">Opera 48 以降、これはフレームのすべての祖先に適用されます。</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">バージョン 6 からは、GeckoView ベースの Focus for Android を隠れた環境設定で使用することができます。</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">Chrome 52およびFirefox 52以降、安全でないサイト（ &lt;code&gt;http:&lt;/code&gt; ：）は「安全な」ディレクティブでCookieを設定できなくなりました。</target>
        </trans-unit>
        <trans-unit id="2777fe7b39631e05febcca00592a28a86bb5182f" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</source>
          <target state="translated">Starting with Chrome 52 and Firefox 52, insecure sites ( &lt;code&gt;http:&lt;/code&gt; ) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</target>
        </trans-unit>
        <trans-unit id="bb7d21aec22143da2cc4da25c435e7bb29874f8d" translate="yes" xml:space="preserve">
          <source>Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-type&lt;/code&gt;&lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt;. Make sure to set both headers correctly.</source>
          <target state="translated">Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-type&lt;/code&gt; &lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt; . Make sure to set both headers correctly.</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">ステータスコード定義(RFC2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">ステータスライン</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">このメモのステータスこのドキュメントは、インターネットコミュニティ用のインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。 Abstract Atom Publishing Protocol（AtomPub）は、Webリソースを公開および編集するためのアプリケーションレベルのプロトコルです。プロトコルは、Atom形式の表現のHTTP転送に基づいています。 Atomフォーマットは、Atom Syndication Formatで文書化されています。目次 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。はじめに &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。表記規則 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;。 XML関連の規約 &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;。情報項目の参照 &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;。 RELAX NGスキーマ &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;。 「xml：base」と「xml：lang」の使用 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。用語 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。プロトコルモデル &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。アイデンティティとネーミング &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。ドキュメントとリソースの分類 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。制御および公開 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。クライアントの実装に関する考慮事項 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。プロトコル操作 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。サービスドキュメントの取得 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。リストコレクションのメンバー &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;。リソース&lt;a href=&quot;#section-5.4&quot;&gt;5.4の&lt;/a&gt;作成 。リソースの編集 &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;。リソースの取得 &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;。リソースの編集 &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;。リソースの削除 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;。 HTTP応答コードの使用 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。プロトコルドキュメント &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。ドキュメントの種類 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;。ドキュメントの拡張性 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。カテゴリードキュメント &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。例 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。要素の定義 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;。 「app：categories」要素 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。サービスドキュメント &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。ワークスペース &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。例 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;。要素の定義 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。 「app：service」要素 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;。 「app：workspace」要素 &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;。 「app：collection」要素 &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;。 「app：accept」要素 &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;。 Atomフィードドキュメントでの使用 &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;。 「app：categories」要素 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。リソースの作成と編集 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。メンバーURI &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;。 POST &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;を使用したリソースの作成 。例 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。 PUT &lt;a href=&quot;#section-9.4&quot;&gt;9.4を使用した&lt;/a&gt;リソースの編集 。 DELETEによるリソースの削除&lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。キャッシュとエンティティータグ &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;。例................................................ &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;。メディアリソースとメディアリンクエントリ &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。例 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。スラグヘッダー &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。スラッグヘッダー構文 &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。例 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。リストコレクション &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;。コレクションの部分リスト &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。 「app：edited」要素 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。 Atomフォーマットのリンク関係の拡張 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;。 「編集」リンク関係 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 「編集メディア」リンク関係 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 Atomフォーマットタイプパラメータ &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 「タイプ」パラメータ &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;。適合 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。 Atom Publishing Controls &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。 「app：control」要素 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;。 「app：draft」要素 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。 Atom出版プロトコルの保護 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;。セキュリティに関する考慮事項 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;。サービス拒否 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;。リプレイアタック &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;。なりすまし攻撃 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;。リンクされたリソース &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;。デジタル署名と暗号化 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;。 URIとIRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;。コードインジェクションとクロスサイトスクリプティング &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。 IANAの考慮事項 &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;。 'application / atomcat + xml'のコンテンツタイプ登録..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;。 「application / atomsvc​​ + xml」のコンテンツタイプ登録..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;。 「SLUG」のヘッダーフィールド登録 &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;。 Link Relation Registration &quot;edit&quot; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;。 Link Relation Registration &quot;edit-media&quot; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;。 Atomフォーマットメディアタイプパラメータ &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。参考資料 &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;。引用規格 &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;。参考資料 &lt;a href=&quot;#appendix-A&quot;&gt;付録A&lt;/a&gt;。寄稿者 &lt;a href=&quot;#appendix-B&quot;&gt;付録B&lt;/a&gt;。 RELAX NGコンパクトスキーマ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">このメモのステータスこのドキュメントは、インターネットコミュニティ用のインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。 Copyright Notice Copyright（C）IETF Trust（2007）。抽象Web分散オーサリングとバージョン管理（WebDAV）は、リソースプロパティの管理、リソースコレクションの作成と管理、URL名前空間操作、およびリソースロック（衝突）のためのHTTP / 1.1に付随するメソッド、ヘッダー、およびコンテンツタイプのセットで構成されます。回避）。 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;は1999年2月に公開され、この仕様は&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;を廃止し、主に相互運用性の経験によりマイナーな改訂が行われました。目次 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。はじめに &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。表記規則 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。用語 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。リソースプロパティのデータモデル &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。リソースプロパティモデル &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。プロパティとHTTPヘッダー &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。プロパティ値 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;。例-混合コンテンツを持つプロパティ &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。プロパティ名 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;。ソースリソースと出力リソース &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。 Webリソースのコレクション &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。 HTTP URL名前空間モデル &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。コレクションリソース &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。ロック &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。モデル&lt;a href=&quot;#section-6.2&quot;&gt;6.2を&lt;/a&gt;ロックし ます。排他的ロックと共有ロック &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;。必要なサポート &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;。 Lock Creator and Privileges &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;。ロックトークン &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;。ロックタイムアウト &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;。ロック機能ディスカバリー &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;。アクティブロックディスカバリー &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。書き込みロック &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。ロックとプロパティの書き込み &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。失われた更新の回避 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;。ロックとマップされていないURLの書き込み &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;。ロックとコレクションの書き込み &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;。ロックともしリクエストヘッダの書き込み &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1を&lt;/a&gt;。例-書き込みロックとコピー7.5.2ロックされたコレクションのメンバーの削除-例 &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;。書き込みロックとCOPY / MOVE &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;。書き込みロックの更新 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。一般的なリクエストとレスポンスの処理 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。エラー処理の優先順位 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。 XML &lt;a href=&quot;#section-8.3&quot;&gt;8.3の&lt;/a&gt;使用 。 URL処理 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。例-正しいURL処理 &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;。リクエスト&lt;a href=&quot;#section-8.5&quot;&gt;8.5で&lt;/a&gt;必要なボディ 。 WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;で使用するHTTPヘッダー 。 ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;。エラーレスポンスボディを含む &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;。キャッシュバリデーターへの名前空間操作の影響 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。分散オーサリングのためのHTTPメソッド &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。 PROPFINDメソッド &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;。 PROPFINDステータスコード.............................. &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;。 「propstat」要素で使用するステータスコード &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;。例-名前付きプロパティの取得9.1.4。例-'propname'を使用してすべてのプロパティ名を取得する &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;。例-いわゆる「allprop」を使用する &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;。例-'allprop'を 'include' &lt;a href=&quot;#section-9.2&quot;&gt;9.2で使用し&lt;/a&gt;ます。 PROPPATCHメソッド &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;。 「propstat」要素で使用するステータスコード &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;。例- PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。 MKCOLメソッド &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;。 MKCOLステータスコード &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;。例- MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;。 GET、HEAD for Collections &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。コレクション&lt;a href=&quot;#section-9.6&quot;&gt;9.6の&lt;/a&gt; POST 。 DELETE要件 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。コレクション&lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2の&lt;/a&gt; DELETE 。例-DELETE &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。 PUT要件 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。非収集リソースのPUT &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。コレクション&lt;a href=&quot;#section-9.8&quot;&gt;9.8の&lt;/a&gt; PUT 。 COPYメソッド &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;。コレクション以外のリソースの &lt;a href=&quot;#section-9.8.2&quot;&gt;コピー9.8.2&lt;/a&gt;。プロパティのコピー &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;。コレクションのためのCOPY &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;。コピーおよび宛先リソースの上書き &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;。ステータスコード &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;。例-上書きとCOPY &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;。例-ノー上書きしてCOPY &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;。例-コレクションのコピー &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;。 MOVEメソッド &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;。プロパティのMOVE &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;。コレクションのためのMOVE &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;。 MOVEと上書きヘッダー &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;。ステータスコード &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;。例-非コレクションのMOVE &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;。例-コレクションのMOVE &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;。 LOCKメソッド &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;。既存のリソースのロックの作成 &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2を&lt;/a&gt;。ロックの &lt;a href=&quot;#section-9.10.3&quot;&gt;更新9.10.3&lt;/a&gt;。深度とロック &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;。マッピングされていないURL &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5の&lt;/a&gt;ロック 。ロックの互換性表 &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;。 LOCKレスポンス &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;。例-シンプルなロック要求 &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;。例-書き込みロックのリフレッシュ &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9を&lt;/a&gt;。例-マルチリソースロック要求 &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;。 UNLOCKメソッド &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;。ステータスコード...................................... &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;。例-ロック解除 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。分散オーサリング&lt;a href=&quot;#section-10.1&quot;&gt;10.1の&lt;/a&gt; HTTPヘッダー 。 DAVヘッダー &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。深度ヘッダー &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;。宛先ヘッダー &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;。ヘッダーの場合 &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;。目的 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;。構文 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;。リスト評価 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;。一致する状態トークンとETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;。ヘッダーおよび非DAV対応プロキシ &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6の場合&lt;/a&gt;。例-無タグの生産 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;。例-タグなしの生成での「Not」の使用10.4.8。例-常にへの条件を引き起こしては真と評価 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;。例-COPY 10.4.10のヘッダーの場合のタグ付きリスト。コレクションのロックとロックトークンをマッチング-例 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;。例-マッピングされていないURLのETagの一致 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;。 Lock-Tokenヘッダー &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;。ヘッダー&lt;a href=&quot;#section-10.7&quot;&gt;10.7を&lt;/a&gt;上書きし ます。タイムアウトリクエストヘッダー &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。 HTTP / 1.1へのステータスコード拡張 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;。 207マルチステータス &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 422 Unprocessable Entity &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;。 423ロック &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;。 424失敗した依存関係 &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;。 507不十分な保管 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 HTTPステータスコードの使用 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 412前提条件の失敗 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;。 414 Request-URI Too Long &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。マルチステータス応答 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。応答ヘッダー &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;。リダイレクトされた子リソースの処理 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;。内部ステータスコード &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。 XML要素の定義 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;。 XML要素activelock &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;。 allprop XML要素 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;。コレクションXML要素 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;。 depth XML要素 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;。 XML要素のエラー &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;。排他的XML要素 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;。 href XML要素 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;。 XML要素&lt;a href=&quot;#section-14.9&quot;&gt;14.9を&lt;/a&gt;含みます 。場所XML要素 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;。 lockentry XML要素 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;。 lockinfo XML要素 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;。 lockroot XML要素.................................... &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;。 lockscope XML要素 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;。 locktoken XMLエレメント &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;。 locktype XML要素 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;。 multistatus XML Element &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;。所有者XML要素 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;。 prop XML要素 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;。 propertyupdate XMLエレメント &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;。 XML要素PROPFIND &lt;a href=&quot;#section-14.21&quot;&gt;14.21を&lt;/a&gt;。 propname XMLエレメント &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;。 propstat XML要素 &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;。 XML要素&lt;a href=&quot;#section-14.24&quot;&gt;14.24を&lt;/a&gt;削除します 。応答XML要素 &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;。 responsedescription XMLエレメント &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。 XML要素&lt;a href=&quot;#section-14.27&quot;&gt;14.27を&lt;/a&gt;設定します 。 XML要素の共有 &lt;a href=&quot;#section-14.28&quot;&gt;14.28を&lt;/a&gt;。ステータスXML要素 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;。 XML要素タイムアウト &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;。 XML要素&lt;a href=&quot;#section-15&quot;&gt;15を&lt;/a&gt;記述します 。 DAVプロパティ &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。前提条件/事後条件のXML要素 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。 DAV &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;におけるXML拡張性 。 DAVコンプライアンスクラス &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;。クラス1 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;。クラス2 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;。クラス3 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;。国際化に関する考慮事項 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;。セキュリティに関する考慮事項 &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;。クライアントの認証 &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;。サービス拒否 &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;。あいまいさによるセキュリティ &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;。ロック&lt;a href=&quot;#section-20.5&quot;&gt;20.5に関連&lt;/a&gt;するプライバシーの問題 。プロパティに関連するプライバシーの問題 &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;。 XMLエンティティの影響 &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;。ロックトークンに関連するリスク &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;。悪意のあるコンテンツのホスティング &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;。 IANAの考慮事項 &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;。新しいURIスキーム &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;。 XML名前空間 &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;。メッセージヘッダーフィールド &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;。 DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;。深さ &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;。宛先 &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;。&lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5の&lt;/a&gt;場合 。ロックトークン &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;。上書き &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;。タイムアウト &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;。 HTTPステータスコード &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;。謝辞................................................ &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;。この仕様への貢献者 &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;。著者&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;。参考資料 &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;。規範的な参照 &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;。有益な参考資料 &lt;a href=&quot;#appendix-A&quot;&gt;付録A&lt;/a&gt;。 XML要素の処理に関するメモ &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;。空のXML要素についての注意 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;。違法なXML処理に関する注意事項 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;。例- XML構文エラー &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;。例-予期しないXML要素 &lt;a href=&quot;#appendix-B&quot;&gt;付録B&lt;/a&gt;。 HTTPクライアントとの互換性についての注意 &lt;a href=&quot;#appendix-C&quot;&gt;付録C&lt;/a&gt;。 「opaquelocktoken」スキームとURIの &lt;a href=&quot;#appendix-D&quot;&gt;付録D&lt;/a&gt;。&lt;a href=&quot;#appendix-D.1&quot;&gt;ロックヌルの&lt;/a&gt;リソース D.1。リソースを作成するためにロックを使用したクライアントのためのガイダンス &lt;a href=&quot;#appendix-E&quot;&gt;は、付録Eを&lt;/a&gt;。認証を希望するクライアントのためのガイダンス &lt;a href=&quot;#appendix-F&quot;&gt;付録F&lt;/a&gt;。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;からの変更の要約。クライアントとサーバーの両方の実装の変更 &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;。サーバー実装の変更点 &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;。その他の変更............................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">含む、応答のステータス &lt;code&gt;Location&lt;/code&gt; ヘッダ：&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">このメモのステータスこのドキュメントは、インターネットコミュニティ用のインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。 Copyright Notice Copyright（C）The Internet Society（1999）。全著作権所有。要約ハイパーテキスト転送プロトコル（HTTP）は、分散型の協調型ハイパーメディア情報システム用のアプリケーションレベルのプロトコルです。これは、要求メソッドの拡張により、ネームサーバーや分散オブジェクト管理システムなど、ハイパーテキストの使用を超えた多くのタスクに使用できる汎用のステートレスなプロトコルです。エラーコードとヘッダー[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。 HTTPの機能は、データ表現のタイプとネゴシエーションであり、転送されるデータとは無関係にシステムを構築できます。 HTTPは1990年以来、World-Wide Webグローバル情報イニシアチブで使用されています。この仕様は、「HTTP / 1.1」と呼ばれるプロトコルを定義し、&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068の&lt;/a&gt;更新版です[ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。目次 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; はじめに &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; 要件 &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; 用語 &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; 全体的な操作 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; 表記規則と一般的な文法 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 拡張BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 基本ルール &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; プロトコルパラメータ &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTPバージョン &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; ユニフォームリソース識別子 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; 一般的な構文 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; HTTP URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; URIの比較 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 日付/時刻書式 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 完全な日付 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; デルタ秒 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; 文字セット &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; 文字セットがありません &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; コンテンツコーディング &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; 転送コーディング &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt; チャンク転送コーディング &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; メディアタイプ &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; 正規化とテキストのデフォルト &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; マルチパートタイプ &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; 製品トークン &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; 品質値 &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; 言語タグ &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; エンティティタグ &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; 範囲単位 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTPメッセージ &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; メッセージタイプ &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; メッセージヘッダー &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; メッセージ本文 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; メッセージ長 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; 一般ヘッダーフィールド &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; リクエスト &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; リクエスト行 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; メソッド &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; Request-URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; リクエストで識別されるリソース &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; リクエストヘッダーフィールド &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; レスポンス &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; ステータス行 &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; ステータスコードと理由フレーズ &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; レスポンスヘッダーフィールド..................... ................................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; エンティティ &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; エンティティヘッダーフィールド &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; エンティティボディ &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; タイプ &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; エンティティ長 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; 接続 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; 永続的接続 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; 全体的な操作 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 .3&lt;/a&gt; プロキシサーバー &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; 実用的な考慮事項 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; メッセージ送信の要件 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; 永続的な接続とフロー制御 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; エラーステータスメッセージの接続の監視 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; 100（続行）ステータスの使用 &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; サーバーが接続を途中で閉じた場合のクライアントの動作.50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; メソッドの定義 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 安全 なメソッドとべき等メソッド &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;安全なメソッド &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; べき等メソッド &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; オプション &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; GET &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; ステータスコードの定義 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 情報1xx &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100続行 &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101プロトコルの切り替え &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; 成功2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201作成 &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202受け入れ &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203非信頼できる情報 &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204コンテンツなし &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205リセットコンテンツ &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt; 206部分的なコンテンツ &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; リダイレクション3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300複数の選択肢 &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301恒久的に移動 &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302検出 &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303その他を参照 &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304変更されていない &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt; 305プロキシを使用 &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306（未使用）.. ................................................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307一時的なリダイレクト &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; クライアントエラー4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400不正なリクエスト &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401不正な &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402支払いが必要 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403 Forbidden &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404 Not Found &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; 405 Method Not Allowed &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; 406 Not Acceptable &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407 Proxy Authentication Required &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; 408 Request Timeout &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; 409 Conflict &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410 Gone &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411 Length Required &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412前提条件が失敗しました &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413要求エンティティが&lt;a href=&quot;#section-10.4.15&quot;&gt;大き&lt;/a&gt;すぎます 10.4.15 414要求URIが長すぎます &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt; 415サポートされていないメディアタイプ &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416要求された範囲が満足できません &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; 417 Expectation Failed &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; サーバーエラー5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; 500内部サーバーエラー &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501未実装 &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt; 502不正なゲートウェイ &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; 503サービス利用不可 &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt; 504ゲートウェイタイムアウト &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; 505 HTTPバージョンはサポートされていません &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; アクセス認証 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; コンテンツネゴシエーション &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; サーバー駆動型ネゴシエーション &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; エージェント駆動型ネゴシエーション &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; 透過的ネゴシエーション &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; HTTPでのキャッシング &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; キャッシュの &lt;a href=&quot;#section-13.1.2&quot;&gt;正確さ13.1.2&lt;/a&gt; 警告 &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; キャッシュ制御メカニズム &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt; 明示的なユーザーエージェント警告 &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; ルールと警告の例外 &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; クライアント制御の動作 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 有効期限モデル &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; サーバー指定の有効期限 &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; ヒューリスティック有効期限 &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; 年齢計算 &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; 有効期限計算 &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; 有効期限値の &lt;a href=&quot;#section-13.2.6&quot;&gt;明確化13.2.6&lt;/a&gt; 複数の応答の明確化 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; 検証モデル &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; 最終更新日...................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; エンティティタグキャッシュバリ &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 使用するエンティティタグとLast-ModifiedのDates.89のための強弱バリ13.3.4ルール &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt; 非検証を条件文 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; レスポンスのキャッシュ可能 &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; キャッシュからの応答を構築 &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt; エンドツーエンドとホップバイホップヘッダー &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt; 変更&lt;a href=&quot;#section-13.5.3&quot;&gt;不可能&lt;/a&gt;なヘッダー 13.5.3 ヘッダーの 結合&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;バイト範囲の結合 &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; ネゴシエートされた応答のキャッシュ &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt; 共有および非共有キャッシュ &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; エラーや不完全なレスポンスキャッシュの挙動 &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt; 副作用のGETとHEAD &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt; 更新または削除した後に無効 &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt; ライトスルー必須 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; キャッシュ置換 &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; 履歴リスト &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; ヘッダーフィールドの定義は &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; 受け入れ &lt;a href=&quot;#section-14.2&quot;&gt;14.2を&lt;/a&gt; 受け入れ、文字セット &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; なAccept-エンコーディング &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; Accept-Language &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; Accept-Ranges &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; Age &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; Allow &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; 認可 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; キャッシュ制御&lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;キャッシュ 可能 &lt;a href=&quot;#section-14.9.2&quot;&gt;な&lt;/a&gt; もの14.9.2キャッシュに格納できるもの &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 基本的な有効期限メカニズムの &lt;a href=&quot;#section-14.9.4&quot;&gt;変更14.9.4&lt;/a&gt; キャッシュの再検証と再ロードの制御 &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt; 非変換ディレクティブ &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; キャッシュ制御の拡張機能 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; 接続 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; コンテンツエンコーディング &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; コンテンツ言語 &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; コンテンツ長 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; コンテンツ-ロケーション &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; コンテンツ &lt;a href=&quot;#section-14.16&quot;&gt;-MD5 14.16&lt;/a&gt; Content-Range &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; Content-Type &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; Date &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; Clockless Origin Server Operation &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ETag &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; Expect &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; Expires &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; From .......................... ........................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; ホスト &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If-None-Match &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; もし非改変-以来 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; のLast-Modified &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; 所在地 &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; マックスは、フォワード &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt; プラグマ &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt; プロキシ認証 &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt; プロキシ認証 &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; レンジ &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; バイトが範囲 &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; 範囲検索が要求 &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt; リファラー &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt; リトライ後 &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt; サーバー &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt; トレーラー &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; 転送エンコーディング &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt; アップグレード &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt; のUser-Agent &lt;a href=&quot;#section-14.44&quot;&gt;14.44は&lt;/a&gt; ヴァリ &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; 経由 &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; 警告 &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW認証 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;セキュリティの考慮事項を &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; 個人情報 &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; Serverのログ情報の乱用 &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2の&lt;/a&gt; 機密情報の転送 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; URIの中にエンコーディング機密情報 &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; ヘッダーを受け入れるに接続されているプライバシー問題 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; ファイルやパスに基づいて攻撃を名前 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; DNSスプーフィング &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; ロケーションヘッダーとスプーフィング &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; コンテンツ処理の問題 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; 認証資格情報とアイドルクライアント &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; プロキシとキャッシング &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; プロキシに対するサービス拒否攻撃 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; 謝辞 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; 参考文献 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; 作者のアドレス &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; 付録 &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; インターネットメディアタイプメッセージ/ httpおよびアプリケーション/ http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; インターネットメディアタイプマルチパート/バイト範囲 &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; トレラントアプリケーション &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; HTTPエンティティと&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFCの&lt;/a&gt;違い2045のエンティティ.... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME-バージョン &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; 正規のフォームへの変換 &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt; 日付フォーマットの変換 &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; Content-Encodingの導入 &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; Content-Transfer-Encodingの 導入&lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt; Transfer-Encodingの 導入 &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTMLと行長の制限 &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; 追加機能 &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; Content-Disposition &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; 以前のバージョンとの互換性 &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt; HTTP / 1.0からの変更 &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; HTTP / 1.0永続的接続との互換性 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; からの変更&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; インデックス &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; 完全な著作権表記</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">キャッシュ内のレスポンスの保存 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7ff86787ade1bf61ad2e59270f3c9e57589ff5d5" translate="yes" xml:space="preserve">
          <source>Stream priorities are changed using the PRIORITY frame.  Setting a
   dependency causes a stream to become dependent on the identified
   parent stream.

   Dependent streams move with their parent stream if the parent is
   reprioritized.  Setting a dependency with the exclusive flag for a
   reprioritized stream causes all the dependencies of the new parent
   stream to become dependent on the reprioritized stream.

   If a stream is made dependent on one of its own dependencies, the
   formerly dependent stream is first moved to be dependent on the
   reprioritized stream's previous parent.  The moved dependency retains
   its weight.

   For example, consider an original dependency tree where B and C
   depend on A, D and E depend on C, and F depends on D.  If A is made
   dependent on D, then D takes the place of A.  All other dependency
   relationships stay the same, except for F, which becomes dependent on
   A if the reprioritization is exclusive. 

       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==&amp;gt;  F   B   C   ==&amp;gt;    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (intermediate)   (non-exclusive)    (exclusive)

                Figure 5: Example of Dependency Reordering</source>
          <target state="translated">ストリームの優先度は、PRIORITYフレームを使用して変更されます。依存関係を設定すると、ストリームは識別された親ストリームに依存するようになります。親の優先順位が変更されると、依存ストリームは親ストリームとともに移動します。再優先順位付けされたストリームの排他フラグを使用して依存関係を設定すると、新しい親ストリームのすべての依存関係が再優先順位付けされたストリームに依存するようになります。ストリームがそれ自体の依存関係の1つに依存するようになると、以前に依存していたストリームが最初に移動され、優先順位が付け直されたストリームの前の親に依存するようになります。移動された依存関係はその重みを保持します。たとえば、BとCがAに依存し、DとEがCに依存し、FがDに依存する元の依存関係ツリーについて考えてみます。AをDに依存させると、Aの代わりにDが使用されます。他のすべての依存関係は維持されます。 Fを除いて同じ、再優先順位付けが排他的である場合、これはAに依存します。 xxxx | / \ | | ADADD / \ / / \ / \ | BC ==&amp;gt; FBC ==&amp;gt; FAまたはA / \ | / \ / | \ DEEBCBCF | | | FEE（中級）（非排他的）（排他的）図5：依存関係の並べ替えの例</target>
        </trans-unit>
        <trans-unit id="bce8f34f0a23969364026999a31bec5f7b65b0ae" translate="yes" xml:space="preserve">
          <source>Streams are identified with an unsigned 31-bit integer.  Streams
   initiated by a client MUST use odd-numbered stream identifiers; those
   initiated by the server MUST use even-numbered stream identifiers.  A
   stream identifier of zero (0x0) is used for connection control
   messages; the stream identifier of zero cannot be used to establish a
   new stream.

   HTTP/1.1 requests that are upgraded to HTTP/2 (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) are
   responded to with a stream identifier of one (0x1).  After the
   upgrade completes, stream 0x1 is &quot;half-closed (local)&quot; to the client.
   Therefore, stream 0x1 cannot be selected as a new stream identifier
   by a client that upgrades from HTTP/1.1.

   The identifier of a newly established stream MUST be numerically
   greater than all streams that the initiating endpoint has opened or
   reserved.  This governs streams that are opened using a HEADERS frame
   and streams that are reserved using PUSH_PROMISE.  An endpoint that
   receives an unexpected stream identifier MUST respond with a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The first use of a new stream identifier implicitly closes all
   streams in the &quot;idle&quot; state that might have been initiated by that
   peer with a lower-valued stream identifier.  For example, if a client
   sends a HEADERS frame on stream 7 without ever sending a frame on
   stream 5, then stream 5 transitions to the &quot;closed&quot; state when the
   first frame for stream 7 is sent or received.

   Stream identifiers cannot be reused.  Long-lived connections can
   result in an endpoint exhausting the available range of stream
   identifiers.  A client that is unable to establish a new stream
   identifier can establish a new connection for new streams.  A server
   that is unable to establish a new stream identifier can send a GOAWAY
   frame so that the client is forced to open a new connection for new
   streams.</source>
          <target state="translated">ストリームは、符号なし31ビット整数で識別されます。クライアントによって開始されたストリームは、奇数番号のストリーム識別子を使用する必要があります。サーバーによって開始されたものは、偶数のストリーム識別子を使用する必要があります。ゼロ（0x0）のストリーム識別子が接続制御メッセージに使用されます。ゼロのストリーム識別子を使用して、新しいストリームを確立することはできません。 HTTP / 2にアップグレードされたHTTP / 1.1リクエスト（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2を&lt;/a&gt;参照））は、1（0x1）のストリーム識別子で応答されます。アップグレードが完了すると、ストリーム0x1はクライアントに対して「ハーフクローズ（ローカル）」になります。したがって、HTTP / 1.1からアップグレードするクライアントは、ストリーム0x1を新しいストリーム識別子として選択できません。新しく確立されたストリームの識別子は、開始エンドポイントが開いた、または予約したすべてのストリームよりも数値的に大きくなければなりません。これは、HEADERSフレームを使用して開かれるストリームと、PUSH_PROMISEを使用して予約されるストリームを管理します。予期しないストリーム識別子を受信したエンドポイントは、接続エラーで応答する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。新しいストリーム識別子を最初に使用すると、そのピアによって開始された可能性のある「アイドル」状態のすべてのストリームが、より低い値のストリーム識別子で暗黙的に閉じられます。たとえば、クライアントがストリーム5でフレームを送信せずにストリーム7でHEADERSフレームを送信した場合、ストリーム7の最初のフレームが送信または受信されると、ストリーム5は「クローズ」状態に移行します。ストリーム識別子は再利用できません。長期間接続すると、エンドポイントが使用可能なストリーム識別子の範囲を使い果たす可能性があります。新しいストリーム識別子を確立できないクライアントは、新しいストリームの新しい接続を確立できます。新しいストリーム識別子を確立できないサーバーは、GOAWAYフレームを送信して、クライアントが新しいストリームの新しい接続を開くように強制される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">HTTPS を使用して銀行の Web サイトに一度アクセスしたことがあり、銀行の Web サイトが Strict Transport Security を使用している限り、ブラウザは自動的に HTTPS のみを使用することを認識するため、ハッカーがこの種の中間者攻撃を行うのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">強力な検証</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">強力な検証とは、リソースが比較対象のリソースとバイト単位で同一であることを保証することです。これはいくつかの条件付きヘッダでは必須であり、その他のヘッダではデフォルトです。強力な検証は非常に厳しく、サーバレベルでの保証は難しいかもしれませんが、パフォーマンスを犠牲にしてでも、いつでもデータの損失がないことを保証します。</target>
        </trans-unit>
        <trans-unit id="546f797f485e1c93debf33798738f22e2e2c71a9" translate="yes" xml:space="preserve">
          <source>Structure of a MIME type</source>
          <target state="translated">MIME タイプの構造</target>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">サーバのレスポンスの構造</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">サブネットベースの決定</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">サブリソースの完全性</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">サブリソースの整合性&lt;br/&gt;&lt;small&gt;その仕様における「require-sri-for」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">後続の行は HTTP ヘッダを表し、どのタイプのデータが適切か (例えば、どの言語か、どの MIME タイプか)、あるいはその動作を変更する他のデータ (例えば、既にキャッシュされている場合にはアンサーを送信しない)についての情報をサーバに与えます。これらの HTTP ヘッダは、空行で終わるブロックを形成します。</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">それ以降の行は特定の HTTP ヘッダを表し、クライアントに送信されたデータに関する情報 (例:型、データサイズ、使用されている圧縮アルゴリズム、キャッシュに関するヒント)を提供します。クライアントリクエストの HTTP ヘッダのブロックと同様に、これらの HTTP ヘッダは空行で終わるブロックを形成します。</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">以降のセクションでは、使用される HTTP ヘッダの内訳とシナリオについて説明します。</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">遠いリ​​ソースの&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がこのヘッダーにリストされているそれぞれと異なる場合に成功します。デフォルトでは、etagの前に &lt;code&gt;'W/'&lt;/code&gt; がない限り、強力な検証が実行されます。</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">遠いリ​​ソースの&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がこのヘッダーにリストされているものと等しい場合に成功します。デフォルトでは、etagの前に &lt;code&gt;'W/'&lt;/code&gt; がない限り、強力な検証が実行されます。</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">遠隔リソースの&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日付が、このヘッダーで指定されたものよりも新しい場合に成功します。</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">遠隔リソースの&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日付がこのヘッダーで指定された日付よりも古いか同じ場合に成功します。</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">成功した反応には体があります。</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">成功した回答</target>
        </trans-unit>
        <trans-unit id="47bd58ec264925cf6d2934f949144bd5b42d3e5b" translate="yes" xml:space="preserve">
          <source>Successful responses (&lt;code&gt;200&lt;/code&gt;&amp;ndash;&lt;code&gt;299&lt;/code&gt;)</source>
          <target state="translated">Successful responses ( &lt;code&gt;200&lt;/code&gt; &amp;ndash; &lt;code&gt;299&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">取得要求の成功結果：HTMLドキュメント、画像、ファイルなどのリソースを含む&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;要求に対する&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（OK）応答。</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">ウェブページの対応に成功。</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">RFC6454で定義されている &lt;code&gt;Origin&lt;/code&gt; ヘッダーを置き換えます。</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">クライアントとサーバーの両方での &lt;code&gt;Retry-After&lt;/code&gt; ヘッダーのサポートは、まだ一貫性がありません。ただし、Googlebotなどの一部のクローラーとスパイダーは、 &lt;code&gt;Retry-After&lt;/code&gt; ヘッダーを受け入れます。&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt;（Service Unavailable）応答と一緒に送信すると、ダウンタイムが過ぎても検索エンジンがサイトのインデックスを作成し続けるので便利です。</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; の&lt;/a&gt;サポートにより、特定のリソースの識別と場所を分離できるため、よりスマートな&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt;キャッシングメカニズムが可能になります。</target>
        </trans-unit>
        <trans-unit id="5557d57c74c062096ddfe6fcacebab65584a47fd" translate="yes" xml:space="preserve">
          <source>Supported digest algorithms are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;, and include &lt;code&gt;SHA-256&lt;/code&gt; and &lt;code&gt;SHA-512&lt;/code&gt;. Some of the supported algorithms, including &lt;code&gt;unixsum&lt;/code&gt; and &lt;code&gt;MD5&lt;/code&gt; are subject to collisions and are thus not suitable for applications in which collision-resistance is important.</source>
          <target state="translated">サポートされているダイジェストアルゴリズムは、で定義されている&lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt;及び&lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;、および含む &lt;code&gt;SHA-256&lt;/code&gt; および &lt;code&gt;SHA-512&lt;/code&gt; 。 &lt;code&gt;unixsum&lt;/code&gt; や &lt;code&gt;MD5&lt;/code&gt; など、サポートされているアルゴリズムの一部は衝突の影響を受けるため、衝突耐性が重要なアプリケーションには適していません。</target>
        </trans-unit>
        <trans-unit id="9cf8d0d7c981d663797eeaca7523e977bed4ab51" translate="yes" xml:space="preserve">
          <source>Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</source>
          <target state="translated">Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1d598d97e68fd3cf7ac8ec2441b332f10d641fc" translate="yes" xml:space="preserve">
          <source>Switch to a blacklist model for restricted Accept headers in simple CORS requests</source>
          <target state="translated">単純なCORSリクエストの制限付きAcceptヘッダのブラックリストモデルへの切り替え</target>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">スイッチングプロトコルは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSocket&lt;/a&gt;で使用される場合があります。</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">同期式 XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">同期式 XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">同期スクリプト</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">統一リソース識別子(URI)の構文</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b10d92078103e058dd32c50f84517f2c9bcce935" translate="yes" xml:space="preserve">
          <source>TCP connection to the server timed out</source>
          <target state="translated">サーバへのTCP接続がタイムアウト</target>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">サーバがリッスンしている TCP ポート番号。</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">サーバがリッスンしている TCP ポート番号。ポートが指定されていない場合は、要求されたサービスのデフォルトポート (例えば、HTTP URL の場合は &quot;80&quot; など)が暗示されます。</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">TE(RFC2616</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">TRACE (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE:メッセージボディには、サーバが受信したリクエストメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">WebViewのタブレットバージョンはモバイルをミラーリングしますが、 &lt;code&gt;Mobile&lt;/code&gt; トークンは含みません。</target>
        </trans-unit>
        <trans-unit id="e63d48cf86b47f4a2e41a4c2480abd63617e07ff" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format</source>
          <target state="translated">タグ付けされた画像ファイル形式</target>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">タグ付き画像ファイル形式(TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">タグとまとめ</target>
        </trans-unit>
        <trans-unit id="03b91e28fed7956fe56ed8f65fc65fd882bbb491" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Language</source>
          <target state="translated">言語の識別のためのタグ</target>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">&lt;code&gt;max-age&lt;/code&gt; または &lt;code&gt;Expires&lt;/code&gt; ヘッダーよりも優先されますが、共有キャッシュ（プロキシなど）にのみ適用され、プライベートキャッシュでは無視されます。</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">テープアーカイブ(TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">キャッシング運用のターゲット</target>
        </trans-unit>
        <trans-unit id="d9c7795d9a943127c5b4d89543f3db9a1ffaae49" translate="yes" xml:space="preserve">
          <source>Technically a part of Device Memory API, this header represents an approximate amount of RAM client has.</source>
          <target state="translated">技術的にはDevice Memory APIの一部であり、このヘッダーはクライアントが持っているRAMのおおよその量を表しています。</target>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">カノニカルURLのテクニック</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">読み込まれているページが大規模な割り当てを実行したいことをブラウザに伝えます。</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">ユーザー名とパスワードを送信する際に、クライアントにサーバが好むエンコーディング方式を伝えます。許可される値は、大文字小文字を区別しない文字列 &quot;UTF-8 &quot;のみです。これはレルム文字列のエンコーディングには関係ありません。</target>
        </trans-unit>
        <trans-unit id="3e310a9a1efd6f1548ce06a7ac2dc4748669f825" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submitting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">ユーザー名とパスワードを送信する際に、クライアントにサーバが好むエンコーディング方式を伝えます。許可される値は、大文字小文字を区別しない文字列 &quot;UTF-8 &quot;のみです。これはレルム文字列のエンコーディングには関係ありません。</target>
        </trans-unit>
        <trans-unit id="e58df9f49057b700376e3c8d719874a09fcdc736" translate="yes" xml:space="preserve">
          <source>Tells the user-agent to reset the document which sent this request.</source>
          <target state="translated">この要求を送信したドキュメントをリセットするようにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">一時的なリダイレクト</target>
        </trans-unit>
        <trans-unit id="7aefd5b2f288adc48ce6a117e81f357d1eed0b40" translate="yes" xml:space="preserve">
          <source>Temporary redirects during site maintenance or downtime</source>
          <target state="translated">サイトメンテナンスやダウンタイム時の一時的なリダイレクト</target>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">長時間の依頼に対する一時的な対応</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">安全ではない依頼への一時的な対応</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">ポリシーのテスト</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">テキスト、（通常はASCIIまたはISO 8859- &lt;em&gt;n&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="dd0fe1624d9684bcb52e0cccdb484d7e2001e225" translate="yes" xml:space="preserve">
          <source>Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt;, &lt;code&gt;text/csv&lt;/code&gt;, and &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="translated">Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt; , &lt;code&gt;text/csv&lt;/code&gt; , and &lt;code&gt;text/html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">その拡張性のおかげで-新しいヘッダーやメソッドの作成は簡単です-HTTP / 1.1プロトコルが2つの改訂（1999年6月に公開された&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;と一連の&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235が&lt;/a&gt; 2014年6月に公開されたHTTP / 2のリリースでは、このプロトコルは15年以上にわたって非常に安定しています。</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;ヘッダーのおかげで、同じIPアドレスで異なるドメインをホストできるようになり、サーバーのコロケーションが可能になりました。</target>
        </trans-unit>
        <trans-unit id="24cf3eddb29388191b3cd3ec808e71bc6c5fd48a" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</source>
          <target state="translated">Thanks to the &lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</target>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">この方法では、安全なサイトで安全ではない要求をアップグレードしても、監視ポリシーに違反しているだけで、安全ではないリソースをエンドポイントに報告します。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">ユーザーエージェントは「Accept」ヘッダーフィールドを使用して、受け入れ可能な応答メディアタイプを指定できます。 Acceptヘッダーフィールドを使用して、インライン画像のリクエストの場合のように、リクエストが特定の小さなタイプのセットに限定されることを明示できます。 Accept =＃（media-range [accept-params]）media-range =（ &quot;* / *&quot; /（type &quot;/&quot; &quot;*&quot;）/（type &quot;/&quot; subtype））*（OWS &quot;;&quot; OWSパラメータ）accept-params = weight *（accept-ext）accept-ext = OWS &quot;;&quot; OWSトークン[&quot;=&quot;（トークン/ quoted-string）]アスタリスク &quot;*&quot;文字は、メディアタイプを範囲にグループ化するために使用され、 &quot;* / *&quot;はすべてのメディアタイプと &quot;type / *&quot;を示します。そのタイプのすべてのサブタイプを示します。メディア範囲には、その範囲に適用可能なメディアタイプパラメータを含めることができます。各メディア範囲の後には、0個以上の適用可能なメディアタイプパラメーター（たとえば、文字セット）が続きます。これは、相対的な重み（&lt;a href=&quot;#section-5.3.1&quot;&gt;セクション5.3.1&lt;/a&gt;）、ゼロ個以上の拡張パラメーター。 &quot;q&quot;パラメータは、2つのパラメータセット間のセパレータとして機能するため、拡張（accept-ext）が存在する場合に必要です。注：メディアタイプパラメーターをAccept拡張パラメーターから分離するために「q」パラメーター名を使用するのは、歴史的な慣習によるものです。これにより、「q」という名前のメディアタイプパラメータがメディア範囲で使用されなくなりますが、IANAメディアタイプレジストリに「q」パラメータが不足していること、およびメディアタイプがまれにしか使用されないことがこのようなイベントであるとは考えられません。 Acceptのパラメータ。将来のメディアタイプでは、「q」という名前のパラメータを登録しないでください。例Accept：audio / *; q = 0.2、audio / basicは &quot;と解釈されます私はオーディオ/ベーシックを好みますが、80％のマークダウンの品質で利用できるオーディオタイプであれば、どんなオーディオタイプでも送ってください。Acceptヘッダーフィールドのないリクエストは、ユーザーエージェントが応答でメディアタイプを受け入れることを意味します。ヘッダーがフィールドがリクエストに存在し、応答で利用可能な表現のどれにも許容できるものとしてリストされているメディアタイプがない場合、オリジンサーバーは406（Not Acceptable）応答を送信してヘッダーフィールドを受け入れるか、または処理してヘッダーフィールドを無視できます。コンテンツネゴシエーションの対象ではないかのように応答します。より複雑な例はAccept：text / plain; q = 0.5、text / html、text / x-dvi; q = 0.8、text / xc口頭で、これは解釈されます「text / htmlとtext / xcは同じように推奨されるメディアタイプですが、存在しない場合は、次に、text / x-dvi表現を送信します。それが存在しない場合は、text / plain表現を送信してください。 &quot;メディア範囲は、より具体的なメディア範囲または特定のメディアタイプによって上書きできます。複数のメディア範囲が特定のタイプ、最も具体的な参照が優先されます。たとえば、Accept：text / *、text / plain、text / plain; format = flowed、* / *には次の優先順位があります：1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / *特定のタイプに関連付けられたメディアタイプの品質係数は、タイプと一致する最高の優先順位を持つメディア範囲を見つけることによって決定されます。たとえば、Accept：text / *; q = 0.3 、text / html; q = 0.7、text / html; level = 1、text / html; level = 2; q = 0.4、* / *; q = 0.5の場合、次の値が関連付けられます。+ ------------------- + --------------- + |メディアタイプ|品質値| + ------------------- + --------------- + | text / html; level = 1 | 1 | | text / html | 0.7 | |テキスト/プレーン| 0.3 | | image / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注：ユーザーエージェントには、特定のメディア範囲の品質値。ただし、ユーザーエージェントが他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。7 | |テキスト/プレーン| 0.3 | | image / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注：ユーザーエージェントには、特定のメディア範囲の品質値。ただし、ユーザーエージェントが他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。7 | |テキスト/プレーン| 0.3 | | image / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注：ユーザーエージェントには、特定のメディア範囲の品質値。ただし、ユーザーエージェントが他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。ユーザーエージェントが、他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。ユーザーエージェントが、他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">&quot;Accept-Charset&quot;ヘッダーフィールドは、ユーザーエージェントが送信して、テキスト応答コンテンツで許容される文字セットを示すことができます。このフィールドにより、より包括的または特殊な目的の文字セットを理解できるユーザーエージェントは、それらの文字セットで情報を表現できるオリジンサーバーにその機能を通知できます。 Accept-Charset = 1＃（（charset / &quot;*&quot;）[weight]）文字セット名は&lt;a href=&quot;#section-3.1.1.2&quot;&gt;セクション3.1.1.2で&lt;/a&gt;定義されています。ユーザーエージェントは、&lt;a href=&quot;#section-5.3.1&quot;&gt;セクション5.3.1で&lt;/a&gt;定義されているように、各文字セットに品質値を関連付けて、その文字セットに対するユーザーの相対的な好みを示すことができます（MAY）。。例はAccept-Charsetです。iso-8859-5、unicode-1-1; q = 0.8特別な値「*」がAccept-Charsetフィールドに存在する場合、Accept-Charsetの他の場所で言及されていないすべての文字セットに一致します。文字セットフィールド。 Accept-Charsetフィールドに「*」が存在しない場合、フィールドで明示的に言及されていない文字セットは、クライアントには「受け入れられない」と見なされます。 Accept-Charsetヘッダーフィールドのないリクエストは、ユーザーエージェントが応答として任意の文字セットを受け入れることを意味します。サポートされている文字セットの詳細なリストにより、サーバーがユーザーエージェントのリクエスト特性に基づいて個人を識別しやすくなるため、ほとんどの汎用ユーザーエージェントはAccept-Charsetを送信しません（&lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt;）。 Accept-Charsetヘッダーフィールドがリクエストに存在し、レスポンスの利用可能な表現のいずれにも許容可能としてリストされている文字セットがない場合、オリジンサーバーは406（Not Acceptable）レスポンスを送信してヘッダーフィールドを受け入れることができます。または、リソースをコンテンツネゴシエーションの対象外として扱うことにより、ヘッダーフィールドを無視します。</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">ユーザーエージェントは &quot;Accept-Encoding&quot;ヘッダーフィールドを使用して、どの応答コンテンツコーディング（&lt;a href=&quot;#section-3.1.2.1&quot;&gt;セクション3.1.2.1&lt;/a&gt;）が応答で受け入れられるかを示すことができます。 「ID」トークンは、エンコーディングが優先されない場合に通信するために、「エンコーディングなし」の同義語として使用されます。 Accept-Encoding =＃（codings [weight]）codings = content-coding / &quot;identity&quot; / &quot;*&quot;各コーディング値には、&lt;a href=&quot;#section-5.3.1&quot;&gt;セクション5.3.1で&lt;/a&gt;定義されているように、そのエンコーディングの設定を表す関連する品質値を指定できます（MAY）。 。 Accept-Encodingフィールド内のアスタリスク &quot;*&quot;記号は、ヘッダーフィールドに明示的にリストされていない使用可能なコンテンツコーディングと一致します。たとえば、Accept-Encoding：compress、gzip Accept-Encoding：Accept-Encoding：* Accept-Encoding：compress; q = 0.5、gzip; q = 1.0 Accept-Encoding：gzip; q = 1.0、identity; q = 0.5、*; q = 0 Accept-Encodingヘッダーフィールドのないリクエストは、ユーザーエージェントがコンテンツコーディングに関する設定を持たないことを意味します。これにより、サーバーは応答でコンテンツコーディングを使用できますが、ユーザーエージェントがすべてのエンコーディングを正しく処理できることを意味するものではありません。サーバーは、次のルールを使用して、特定の表現のコンテンツコーディングが許容可能かどうかをテストします。1.リクエストにAccept-Encodingフィールドがない場合、コンテンツコーディングはすべて、ユーザーエージェントによって受け入れ可能と見なされます。 2.表現にコンテンツコーディングがない場合、「identity; q = 0」または「*; q = 0」のいずれかを「Accept-Encoding」フィールドで明確に除外しない限り、「身元&quot;。 3.表現のコンテンツコーディングがAccept-Encodingフィールドにリストされているコンテンツコーディングの1つである場合、qvalueが0でない限り、それは許容されます。「アイデンティティ」のより具体的なエントリなし。 3.表現のコンテンツコーディングがAccept-Encodingフィールドにリストされているコンテンツコーディングの1つである場合、qvalueが0でない限り、それは許容されます。「アイデンティティ」のより具体的なエントリなし。 3.表現のコンテンツコーディングがAccept-Encodingフィールドにリストされているコンテンツコーディングの1つである場合、qvalueが0でない限り、それは許容されます。&lt;a href=&quot;#section-5.3.1&quot;&gt;セクション5.3.1&lt;/a&gt;、qvalue 0は「受け入れられない」を意味します。）4.複数のコンテンツコーディングが受け入れられる場合、ゼロ以外のqvalueが最も高い受け入れ可能なコンテンツコーディングが優先されます。空のフィールド値を組み合わせたAccept-Encodingヘッダーフィールドは、ユーザーエージェントがコンテンツコーディングの応答を望まないことを意味します。 Accept-Encodingヘッダーフィールドがリクエストに存在し、応答の利用可能な表現のどれにも許容可能としてリストされているコンテンツコーディングがない場合、オリジンサーバーはコンテンツコーディングなしで応答を送信する必要があります（SHOULD）。注：ほとんどのHTTP / 1.0アプリケーションは、コンテンツコーディングに関連付けられたqvalueを認識または従いません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">「Accept-Language」ヘッダーフィールドは、ユーザーエージェントが応答で優先される一連の自然言語を示すために使用できます。言語タグは&lt;a href=&quot;#section-3.1.3.1&quot;&gt;セクション3.1.3.1で&lt;/a&gt;定義されています。 Accept-Language = 1＃（language-range [weight]）language-range = &amp;lt;language-range、see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647]、Section 2.1&lt;/a&gt; &amp;gt;各言語範囲には、ユーザーの好みの推定を表す関連する品質値を与えることができます&lt;a href=&quot;#section-5.3.1&quot;&gt;セクション5.3.1で&lt;/a&gt;定義されている、その範囲で指定された言語。たとえば、Accept-Language：da、en-gb; q = 0.8、en; q = 0.7は、「デンマーク語が好きですが、イギリス英語と他のタイプの英語は受け入れます」という意味になります。 Accept-Languageヘッダーフィールドのないリクエストは、ユーザーエージェントが応答で任意の言語を受け入れることを意味します。ヘッダーフィールドがリクエストに存在し、応答の利用可能な表現のいずれにも一致する言語タグがない場合、オリジンサーバーは、コンテンツネゴシエーションの対象ではないかのように応答を処理することによってヘッダーフィールドを無視するか、ヘッダーを受け入れることができます。フィールドに406（Not Acceptable）応答を送信します。ただし、後者の場合、ユーザーが（たとえば、翻訳ソフトウェアを使用して）使用できるコンテンツにアクセスできなくなる可能性があるため、推奨されません。一部の受信者は、特に等しい品質値（q = 1と同じ値がない）が割り当てられているタグの場合、言語タグがリストされている順序を優先順位の降順の指示として扱います。ただし、この動作は信頼できません。一貫性を保ち、相互運用性を最大化するために、多くのユーザーエージェントは各言語タグに一意の品質値を割り当て、品質の低い順にリストします。言語優先リストの追加の議論はで見つけることができます多くのユーザーエージェントは、各言語タグに一意の品質値を割り当て、品質の低い順にリストします。言語優先リストの追加の議論はで見つけることができます多くのユーザーエージェントは、各言語タグに一意の品質値を割り当て、品質の低い順にリストします。言語優先リストの追加の議論はで見つけることができます&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;[RFC4647]のセクション2.3&lt;/a&gt;。マッチングについて&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;は、[RFC4647]のセクション3で&lt;/a&gt;いくつかのマッチングスキームを定義しています。実装は、要件に最も適したマッチングスキームを提供できます。 「基本的なフィルタリング」スキーム（&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647]、セクション3.3.1&lt;/a&gt;）は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;、[RFC2616]のセクション14.4で&lt;/a&gt; HTTPに対して以前に定義されたマッチングスキームと同じです。 Accept-Languageヘッダーフィールドを、すべてのリクエストでユーザーの完全な言語設定で送信することは、ユーザーのプライバシーの期待に反する場合があります（&lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt;）。了解度は個々のユーザーに大きく依存するため、ユーザーエージェントは言語プリファレンスをユーザーが制御できるようにする必要があります（ユーザーエージェント自体の設定またはデフォルトでユーザー制御可能なシステム設定を使用）。このような制御をユーザーに提供しないユーザーエージェントは、Accept-Languageヘッダーフィールドを送信してはなりません（MUST NOT）。注：ユーザーエージェントは、設定を行うときにユーザーにガイダンスを提供する必要があります。これは、ユーザーが上記の言語マッチングの詳細に精通していることはめったにないためです。たとえば、ユーザーが「en-gb」を選択すると、イギリス英語が利用できない場合は、あらゆる種類の英語のドキュメントが提供されると想定します。このような場合、ユーザーエージェントは、一致動作を改善するためにリストに「en」を追加することを提案する場合があります。</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">「Accept-Ranges」ヘッダーフィールドを使用すると、サーバーはターゲットリソースの範囲リクエストをサポートしていることを示すことができます。 Accept-Ranges = acceptable-rangesacceptable-ranges = 1＃range-unit / &quot;none&quot;特定のターゲットリソースに対するバイト範囲リクエストをサポートするオリジンサーバーは、サポートされる範囲単位を示すAccept-Ranges：バイトを送信する場合があります。クライアントは、関連するリソースのこのヘッダーフィールドを受信せずに範囲要求を生成できます（MAY）。範囲の単位は&lt;a href=&quot;#section-2&quot;&gt;セクション2で&lt;/a&gt;定義されています。ターゲットリソースに対するいかなる種類の範囲要求もサポートしていないサーバーは、クライアントに範囲要求を試行しないように通知するAccept-Ranges：noneを送信する場合があります。</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">「Age」ヘッダーフィールドは、送信元のサーバーで応答が生成または検証されてからの送信者の推定時間を伝えます。年齢の値は、&lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3の&lt;/a&gt;指定に従って計算されます 。 Age = delta-seconds Ageフィールド値は、秒単位の時間を表す負でない整数です（&lt;a href=&quot;#section-1.2.1&quot;&gt;セクション1.2.1を&lt;/a&gt;参照）。 Ageヘッダーフィールドが存在するということは、この要求に対してオリジンサーバーによって応答が生成または検証されなかったことを意味します。ただし、Ageを実装していないHTTP / 1.0キャッシュから応答が受信された可能性があるため、Ageヘッダーフィールドがなくても、発信元にアクセスしたことを意味するわけではありません。</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">Allow」ヘッダーフィールドは、ターゲットリソースがサポートするとアドバタイズされたメソッ ドのセットをリストアップする。このフィールドの目的は、リソースに関連付けられた有効なリクエストメソッドを受信者に通知することにあります。Allow=#method 使用例。Allow。使用例:Allow:GET,HEAD,PUT 実際に許可されるメソッドのセットは、各リクエストの時にオリジンサー バーによって定義される。オリジンサーバーは405(Method Not Allowed)応答でAllowフィールドを生成しなければならず[MUST]、他の応答でも生成してもよい[MAY]。空のAllowフィールド値は、リソースがメソッドを許可していないことを 示す。これは、リソースが設定によって一時的に無効化されている場合に 405応答で発生するかもしれない。プロキシはAllowヘッダーフィールドを修正してはならない[MUST NOT]。プロキシは、一般的なメッセージ処理ルールに従ってそれらを処理するために、示されたメ ソッドのすべてを理解する必要はない。</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">「Authorization」ヘッダーフィールドを使用すると、ユーザーエージェントはオリジンサーバーで自身を認証できます。通常、401（Unauthorized）応答を受け取った後、必ずしもそうとは限りません。その値は、要求されているリソースのレルムのユーザーエージェントの認証情報を含む資格情報で構成されます。承認=資格情報リクエストが認証され、レルムが指定されている場合、同じ資格情報がこのレルム内の他のすべてのリクエストに対して有効であると想定されます（チャレンジ値に応じて変化する資格情報など、認証スキーム自体はそれ以外を必要としない場合）または同期クロックを使用して）。リクエストを転送するプロキシは、そのリクエストのAuthorizationフィールドを変更してはなりません（MUST NOT）。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;[RFC7234]のセクション3.2を&lt;/a&gt;参照してください HTTPキャッシュによるAuthorizationフィールドの処理に関する詳細と要件については、</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">「基本」HTTP認証方式は&lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;で定義されており、資格情報をbase64を使用してエンコードされたユーザーID /パスワードのペアとして送信します。</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">「Cache-Control」ヘッダーフィールドは、要求/応答チェーンに沿ったキャッシュのディレクティブを指定するために使用されます。このようなキャッシュディレクティブは、要求内にディレクティブが存在しても、応答で同じディレクティブが指定されることを意味しないという点で、単一方向です。キャッシュは、このセクションで定義されているCache-Controlディレクティブの要件に従う必要があります。&lt;a href=&quot;#section-5.2.3&quot;&gt;セクション5.2.3を&lt;/a&gt;参照他の場所で定義されたCache-Controlディレクティブの処理方法については、注：一部のHTTP / 1.0キャッシュは、Cache-Controlを実装しない場合があります。ディレクティブは要求/応答チェーンに沿ったすべての受信者に適用できるため、プロキシは、キャッシュを実装するかどうかに関係なく、そのアプリケーションに対する重要性に関係なく、転送されたメッセージでキャッシュディレクティブを渡す必要があります。ディレクティブを特定のキャッシュにターゲティングすることはできません。キャッシュディレクティブは、大文字と小文字を区別せずに比較されるトークンによって識別され、トークンと引用符付き文字列構文の両方を使用できるオプションの引数があります。引数を定義する以下に定義されたディレクティブの場合、受信者は、一方が優先されることが文書化されている場合でも、両方の形式を受け入れる必要があります。この仕様で定義されていないディレクティブについては、受信者は両方のフォームを受け入れる必要があります。 Cache-Control = 1＃cache-directive cache-directive = token [&quot;=&quot;（token / quoted-string）]以下で定義されているキャッシュディレクティブの場合、特に明記されていない限り、引数は定義されません（許可されません）。</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">「接続」ヘッダーフィールドを使用すると、送信者は現在の接続に必要な制御オプションを指定できます。ダウンストリーム受信者の混乱を避けるために、プロキシまたはゲートウェイは、メッセージを転送する前に、受信した接続オプションを削除または置き換える必要があります。 Connection以外のヘッダーフィールドを使用して現在の接続の制御情報を提供する場合、送信者は、Connectionヘッダーフィールド内に対応するフィールド名をリストする必要があります。プロキシまたはゲートウェイは、メッセージが転送される前に受信したConnectionヘッダーフィールドを解析する必要があり、このフィールドの各接続オプションについて、接続オプションと同じ名前のメッセージからヘッダーフィールドを削除してから削除しますConnectionヘッダーフィールド自体（またはそれを仲介者に置き換える）転送されたメッセージ用の独自の接続オプション）。したがって、接続ヘッダーフィールドは、直接の受信者のみを対象とするヘッダーフィールド（「ホップバイホップ」）を、チェーン上のすべての受信者を対象とするフィールド（「エンドツーエンド」）と区別する宣言的な方法を提供します。 &quot;）、メッセージが自己記述的になることを可能にし、将来の接続固有の拡張が古い仲介者によって盲目的に転送されることを恐れずに展開できるようにします。 Connectionヘッダーフィールドの値の文法は次のとおりです。Connection = 1＃connection-option connection-option = token接続オプションでは大文字と小文字が区別されません。送信者は、ペイロードのすべての受信者を対象とするヘッダーフィールドに対応する接続​​オプションを送信してはなりません（MUST NOT）。たとえば、Cache-Controlは接続オプション（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2&lt;/a&gt;）。接続オプションに関連付けられたパラメーターがない場合、接続固有のヘッダーフィールドは必要ない場合があるため、接続オプションは、常にメッセージ内に存在するヘッダーフィールドに対応するとは限りません。対照的に、対応する接続​​オプションなしで受信された接続固有のヘッダーフィールドは、通常、フィールドが仲介者によって不適切に転送され、受信者によって無視されるべきであることを示します。新しい接続オプションを定義するとき、仕様の作成者は既存のヘッダーフィールド名を調査し、新しい接続オプションが既に展開されているヘッダーフィールドと同じ名前を共有しないことを確認する必要があります。新しい接続オプションを定義すると、基本的に、その接続オプションに関連する追加情報を伝送するための潜在的なフィールド名が予約されます。送信者が他の目的でそのフィールド名を使用することは賢明ではないためです。 「クローズ」接続オプションは、送信者が応答の完了後にこの接続がクローズされることを通知するために定義されています。たとえば、接続：リクエストまたはレスポンスヘッダーフィールドのいずれかで閉じると、現在のリクエスト/レスポンスが完了した後に送信者が接続を閉じることを示します（リクエストまたはレスポンスヘッダーフィールドのいずれかを閉じると、現在のリクエスト/レスポンスが完了した後に送信者が接続を閉じることを示します（リクエストまたはレスポンスヘッダーフィールドのいずれかを閉じると、現在のリクエスト/レスポンスが完了した後に送信者が接続を閉じることを示します（&lt;a href=&quot;#section-6.6&quot;&gt;セクション6.6&lt;/a&gt;）。永続的な接続をサポートしないクライアントは、すべての要求メッセージで「閉じる」接続オプションを送信する必要があります。持続的接続をサポートしないサーバーは、1xx（情報）ステータスコードを持たないすべての応答メッセージで「閉じる」接続オプションを送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">「Content-Encoding」ヘッダーフィールドは、メディアタイプに固有のものを超えて、どのコンテンツコーディングが表現に適用されているか、したがってContent-によって参照されるメディアタイプのデータを取得するために適用する必要があるデコードメカニズムを示します。タイプヘッダーフィールド。 Content-Encodingは主に、基になるメディアタイプのIDを失うことなく、表現のデータを圧縮できるようにするために使用されます。 Content-Encoding = 1＃content-codingその使用例はContent-Encodingです：gzip 1つ以上のエンコーディングが表現に適用されている場合、エンコーディングを適用した送信者はコンテンツをリストするContent-Encodingヘッダーフィールドを生成する必要があります適用された順序でコーディング。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のヘッダーフィールドから提供できます。 Transfer-Encoding（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]のセクション3.3.1&lt;/a&gt;）、Content-Encodingにリストされているコーディングは、表現の特性です。表現はコード化された形式で定義され、表現に関する他のすべてのメタデータは、メタデータ定義で特に明記されていない限り、コード化された形式に関するものです。通常、表現は、レンダリングまたは類似の使用の直前にのみデコードされます。メディアタイプに、常に圧縮されるデータ形式などの固有のエンコーディングが含まれている場合、たとえコンテンツコーディングの1つと同じアルゴリズムであっても、そのエンコーディングはContent-Encodingで再表現されません。このようなコンテンツコーディングは、何らかの奇妙な理由により、2回目に適用されて表現を形成する場合にのみリストされます。同様に、配信元サーバーは、コーディングがContent-TypeまたはContent-Encodingの一部として定義されているかどうかのみが異なる複数の表現として同じデータを公開することを選択する場合があります。コンテンツの自動解凍とレンダリングの代わりに「名前を付けて保存」ダイアログ）。オリジンサーバーは、リクエストメッセージの表現に受け入れられないコンテンツコーディングがある場合、ステータスコード415（サポートされていないメディアタイプ）で応答してもよい（MAY）。オリジンサーバーは、リクエストメッセージの表現に受け入れられないコンテンツコーディングがある場合、ステータスコード415（サポートされていないメディアタイプ）で応答してもよい（MAY）。オリジンサーバーは、リクエストメッセージの表現に受け入れられないコンテンツコーディングがある場合、ステータスコード415（サポートされていないメディアタイプ）で応答してもよい（MAY）。</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">「Content-Language」ヘッダーフィールドは、表現の対象読者の自然言語を記述します。これは、表現内で使用されるすべての言語と同等ではない場合があることに注意してください。 Content-Language = 1＃language-tag言語タグは&lt;a href=&quot;#section-3.1.3.1&quot;&gt;セクション3.1.3.1で&lt;/a&gt;定義されています。 Content-Languageの主な目的は、ユーザーが自分の好みの言語に従って表現を識別および区別できるようにすることです。したがって、コンテンツがデンマーク語の読み手のみを対象としている場合、適切なフィールドはContent-Languageです。da Content-Languageが指定されていない場合、デフォルトでは、コンテンツはすべての言語の対象者を対象としています。これは、送信者がそれを自然言語に固有であると見なしていないこと、または送信者が意図する言語がわからないことを意味している可能性があります。複数の視聴者を対象とするコンテンツには、複数の言語がリストされる場合があります。たとえば、オリジナルのマオリ語と英語のバージョンで同時に提示された「ワイタンギの条約」の表現は、Content-Language：mi、ただし、表現内に複数の言語が存在するからといって、それが複数の言語聴衆を対象としていることを意味するものではありません。例としては、「ラテン語の最初のレッスン」などの英語初心者向けの入門書が挙げられます。これは、明らかに英語の知識のある聴衆による使用を目的としています。この場合、Content-Languageには「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。この場合、Content-Languageには「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。この場合、Content-Languageには「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">「Content-Location」ヘッダーフィールドは、このメッセージのペイロードの表現に対応する特定のリソースの識別子として使用できるURIを参照します。つまり、このメッセージの生成時にこのURIでGET要求を実行した場合、200（OK）応答には、このメッセージのペイロードとして囲まれたものと同じ表現が含まれます。 Content-Location = absolute-URI / partial-URI Content-Location値は、有効なリクエストURIの代わりにはなりません（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]のセクション5.5&lt;/a&gt;）。表現メタデータです。&lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;[RFC2557]のセクション4で&lt;/a&gt; MIMEボディパーツに対して定義された同じ名前のヘッダーフィールドと同じ構文とセマンティクスを持っています。ただし、HTTPメッセージに表示されることは、HTTP受信者にとって特別な意味を持ちます。 Content-Locationが2xx（成功）応答メッセージに含まれていて、その値が（絶対形式への変換後に）有効な要求URIと同じURIを参照している場合、受信者はペイロードを現在の表現と見なしてもよい（MAY）メッセージの作成日で示される時刻におけるそのリソースの。 GET（&lt;a href=&quot;#section-4.3.1&quot;&gt;セクション4.3.1&lt;/a&gt;）またはHEAD（&lt;a href=&quot;#section-4.3.2&quot;&gt;セクション4.3.2&lt;/a&gt;）リクエストの場合、これはサーバーからContent-Locationが提供されない場合のデフォルトのセマンティクスと同じです。 PUT（&lt;a href=&quot;#section-4.3.4&quot;&gt;セクション4.3.4&lt;/a&gt;）またはPOST（&lt;a href=&quot;#section-4.3.3&quot;&gt;セクション4.3.3&lt;/a&gt;）のような状態変更リクエストの場合）、それはサーバーの応答にそのリソースの新しい表現が含まれていることを意味し、それによってアクションのみを報告する可能性のある表現と区別します（たとえば、「うまくいった！」）。これにより、オーサリングアプリケーションは、後続のGETリクエストを必要とせずにローカルコピーを更新できます。 Content-Locationが2xx（Successful）応答メッセージに含まれており、そのフィールド値が有効な要求URIとは異なるURIを参照している場合、オリジンサーバーは、URIが囲まれているに対応する別のリソースの識別子であると主張します。表現。このような要求は、両方の識別子が同じリソース所有者を共有している場合にのみ信頼できます。これは、HTTPを介してプログラムで決定することはできません。 o GETまたはHEADリクエストへの応答の場合、これは、有効な要求URIがコンテンツネゴシエーションの対象となるリソースを参照しており、Content-Locationフィールド値が選択した表現のより具体的な識別子であることを示しています。 o状態変更メソッドに対する201（Created）応答の場合、Location-valueと同じContent-Locationフィールド値は、このペイロードが新しく作成されたリソースの現在の表現であることを示します。 oそれ以外の場合、このようなContent-Locationは、このペイロードが要求されたアクションのステータスについて報告する表現であり、同じレポートが特定のURIで（GETによる将来のアクセスのために）利用可能であることを示します。例えば、POST要求を介して行われた購入トランザクションには、200（OK）応答のペイロードとして受領書が含まれる場合があります。 Content-Locationフィールド値は、将来同じレシートのコピーを取得するための識別子を提供します。リクエストメッセージでContent-Locationを送信するユーザーエージェントは、その値がユーザーエージェントが最初に囲まれた表現のコンテンツを取得した場所を参照していると述べています（そのユーザーエージェントによる変更の前）。つまり、ユーザーエージェントは、元の表現のソースへのバックリンクを提供しています。リクエストメッセージのContent-Locationフィールドを受け取るオリジンサーバーは、情報を表現の一部として逐語的に保存されるメタデータとしてではなく、一時的なリクエストコンテキストとして扱う必要があります。オリジンサーバーは、そのコンテキストを使用して、リクエストの処理をガイドしたり、ソースリンクやバージョン管理メタデータ内などの他の用途のために保存したりできます。ただし、オリジンサーバーは、要求のセマンティクスを変更するためにそのようなコンテキスト情報を使用してはなりません（MUST NOT）。たとえば、クライアントがネゴシエートされたリソースでPUT要求を行い、オリジンサーバーがそのPUTを（リダイレクトせずに）受け入れる場合、そのリソースの新しい状態は、そのPUTで提供される1つの表現と一致すると予想されます。 Content-Locationは、ネゴシエートされた表現の1つだけを更新するための逆コンテンツ選択識別子の形式として使用できません。ユーザーエージェントが後者のセマンティクスを必要としていた場合、PUTをContent-Location URIに直接適用します。</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">「Content-Range」ヘッダーフィールドは、メッセージペイロードとして囲まれた選択された表現の部分的な範囲を示すために単一の部分206（部分的なコンテンツ）応答で送信され、マルチパート206応答の各部分で送信されて、各ボディパーツ、および選択された表現に関する情報を提供するために416（Range Not Satisfiable）応答で送信されます。コンテンツ範囲=バイトコンテンツ範囲/その他のコンテンツ範囲バイトコンテンツ範囲=バイト単位SP（バイト範囲応答/不満足範囲）バイト範囲応答=バイト範囲 &quot;/&quot;（完全-length / &quot;*&quot;）byte-range = first-byte-pos &quot;-&quot; last-byte-pos unsatisfied-range = &quot;* /&quot;complete-length complete-length = 1 * DIGIT other-content-range = other-range-unit SP other-range-resp other-range-resp = * CHAR 206（Partial Content）応答にContent-Rangeヘッダーフィールドが含まれている場合レンジ単位（&lt;a href=&quot;#section-2&quot;&gt;第2節&lt;/a&gt;）受信者が理解していないこと、受信者はそれを格納された表現と再結合しようとしてはなりません。そのようなメッセージを受信するプロキシは、それをダウンストリームに転送する必要があります（SHOULD）。バイト範囲の場合、完全な長さが不明または判別が困難でない限り、送信者は範囲が抽出された表現の完全な長さを示す必要があります（SHOULD）。完全長の代わりにアスタリスク文字（ &quot;*&quot;）は、ヘッダーフィールドが生成されたときに表現の長さが不明であることを示します。次の例は、選択した表現の完全な長さが送信者に1234バイトであるとわかっている場合を示しています。Content-Range：bytes 42-1233 / 1234と、この2番目の例は、完全な長さが不明な場合を示しています。Content-Range：バイト42-1233 / *最初のバイトのpos値より小さいlast-byte-pos値、またはそれより小さい完全な長さ値を持つbyte-range-respが含まれている場合、Content-Rangeフィールド値は無効です。またはそのlast-byte-pos値と等しい。無効なContent-Rangeの受信者は、受信したコンテンツを格納された表現と再結合してはなりません（MUST NOT）。次の例のように、バイト範囲要求に対する416（範囲が満たされない）応答を生成するサーバーは、範囲が満たされていない値を含むContent-Rangeヘッダーフィールドを送信する必要があります（SHOULD）。Content-Range：bytes * / 1234 complete-length 416の応答は、選択された表現の現在の長さを示します。 Content-Rangeヘッダーフィールドは、その意味を明示的に記述しないステータスコードには意味がありません。この仕様では、Content-Rangeの意味を説明するのは、206（部分的なコンテンツ）および416（範囲が満たされない）ステータスコードのみです。以下は、選択された表現が合計1234バイトを含むContent-Range値の例です：o最初の500バイト：Content-Range：バイト0-499 / 1234 o 2番目の500バイト：Content-Range：バイト500- 999/1234 o最初の500バイトを除くすべて：Content-Range：bytes 500-1233 / 1234 o最後の500バイト：Content-Range：bytes 734-1233 / 1234バイト0-499 / 1234 o 2番目の500バイト：Content-Range：バイト500-999 / 1234 o最初の500バイトを除くすべて：Content-Range：バイト500-1233 / 1234 o最後の500バイト：Content-Range ：バイト734-1233 / 1234バイト0-499 / 1234 o 2番目の500バイト：Content-Range：バイト500-999 / 1234 o最初の500バイトを除くすべて：Content-Range：バイト500-1233 / 1234 o最後の500バイト：Content-Range ：バイト734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">「Content-Type」ヘッダーフィールドは、関連する表現のメディアタイプを示します。メッセージのペイロードで囲まれた表現か、メッセージのセマンティクスによって決定された選択された表現のどちらかです。示されたメディアタイプは、Content-Encodingで示されたコンテンツコーディングがデコードされた後、受信したメッセージセマンティクスの範囲内で、データ形式と受信者によるデータの処理方法の両方を定義します。 Content-Type = media-typeメディアタイプは&lt;a href=&quot;#section-3.1.1.1&quot;&gt;セクション3.1.1.1で&lt;/a&gt;定義されています。フィールドの例はContent-Type：text / htmlです。 charset = ISO-8859-4ペイロード本体を含むメッセージを生成する送信者は、囲まれた表現の意図されたメディアタイプが送信者にとって不明でない限り、そのメッセージにContent-Typeヘッダーフィールドを生成する必要があります（SHOULD）。 Content-Typeヘッダーフィールドが存在しない場合、受信者は「application / octet-stream」（&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046]、セクション4.5.1）の&lt;/a&gt;メディアタイプを想定することができます（MAY）。）または、データを調べてそのタイプを判別します。実際には、リソースの所有者は常に特定の表現に対して正しいContent-Typeを提供するように元のサーバーを適切に構成するわけではありません。その結果、一部のクライアントはペイロードのコンテンツを調べ、指定されたタイプをオーバーライドします。これを行うクライアントは、誤った結論を導き出すリスクがあり、追加のセキュリティリスク（「特権昇格」など）を露呈する可能性があります。さらに、データ形式を調べることによって送信者の意図を判断することは不可能です。多くのデータ形式は、処理のセマンティクスのみが異なる複数のメディアタイプと一致します。実装者は、このような「コンテンツスニッフィング」を使用するときに無効にする手段を提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">「日付」ヘッダーフィールドは、メッセージが発信された日付と時刻を表し、&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;[RFC5322]のセクション3.6.1で&lt;/a&gt;定義されている発信日付フィールド（orig-date）と同じセマンティクスを持っています。フィールド値は、&lt;a href=&quot;#section-7.1.1.1&quot;&gt;セクション7.1.1.1で&lt;/a&gt;定義されているHTTP日付です。。日付= HTTP-date例は日付です：火、1994年11月15日08:12:31 GMT日付ヘッダーフィールドが生成されるとき、送信者はメッセージ生成の日付と時刻の利用可能な最適な近似としてフィールド値を生成する必要があります（SHOULD）。理論的には、日付はペイロードが生成される直前を表す必要があります。実際には、日付はメッセージの発信中にいつでも生成できます。起点サーバーは、協定世界時での現在のインスタンスの適切な概算を提供できるクロックがない場合、日付ヘッダーフィールドを送信してはなりません（MUST NOT）。応答がステータスコードの1xx（情報）または5xx（サーバーエラー）クラスにある場合、オリジンサーバーは日付ヘッダーフィールドを送信できます（MAY）。オリジンサーバーは、他のすべての場合にDateヘッダーフィールドを送信する必要があります。Dateヘッダーフィールドのない応答メッセージを受信するクロックを持つ受信者は、受信した時刻を記録し、対応するDateヘッダーフィールドがキャッシュされているか、ダウンストリームに転送されている場合は、メッセージのヘッダーセクションに追加する必要があります。ユーザーエージェントはリクエストで日付ヘッダーフィールドを送信できますが、サーバーに有用な情報を伝えると考えられていない限り、通常は送信しません。たとえば、HTTPのカスタムアプリケーションは、サーバーがユーザーエージェントとサーバーのクロックの違いに基づいてユーザーの要求の解釈を調整することが予想される場合、日付を伝達します。■ヘッダーセクション（キャッシュされているか、ダウンストリームに転送されている場合）。ユーザーエージェントはリクエストで日付ヘッダーフィールドを送信できますが、サーバーに有用な情報を伝えると考えられていない限り、通常は送信しません。たとえば、HTTPのカスタムアプリケーションは、サーバーがユーザーエージェントとサーバーのクロックの違いに基づいてユーザーの要求の解釈を調整することが予想される場合、日付を伝達します。■ヘッダーセクション（キャッシュされているか、ダウンストリームに転送されている場合）。ユーザーエージェントはリクエストで日付ヘッダーフィールドを送信できますが、サーバーに有用な情報を伝えると考えられていない限り、通常は送信しません。たとえば、HTTPのカスタムアプリケーションは、サーバーがユーザーエージェントとサーバーのクロックの違いに基づいてユーザーの要求の解釈を調整することが予想される場合、日付を伝達します。</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">応答の「ETag」ヘッダーフィールドは、要求の処理の終了時に決定された、選択された表現の現在のエンティティタグを提供します。エンティティタグは、それらの複数の表現が時間の経過に伴うリソース状態の変化によるものか、複数の表現が同時に有効になるコンテンツネゴシエーションによるものか、またはその両方に関係なく、同じリソースの複数の表現を区別するための不透明なバリデーターです。エンティティタグは、不透明の引用符付き文字列で構成され、弱点インジケータが前に付いている可能性があります。 ETag = entity-tag entity-tag = [weak] opaque-tag weak =％x57.2F; &quot;W /&quot;、大文字と小文字を区別する不透明タグ= DQUOTE * etagc DQUOTE etagc =％x21 /％x23-7E / obs-text;二重引用符を除くVCHAR、plus obs-text注：以前は、不透明タグは引用符付き文字列（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]、セクション3.11&lt;/a&gt;）;したがって、一部の受信者はエスケープ解除のバックスラッシュを実行する場合があります。したがって、サーバーはエンティティタグ内のバックスラッシュ文字を回避する必要があります。エンティティータグは、HTTP日付値の1秒の解決では不十分な場合、または変更日が一貫して維持されていない場合、変更日を格納するのに不便な状況では、変更日よりも検証の信頼性が高くなります。例：ETag： &quot;xyzzy&quot; ETag：W / &quot;xyzzy&quot; ETag： &quot;&quot; entity-tagは、弱いまたは強いバリデーターのいずれかであり、強いがデフォルトです。オリジンサーバーが表現にエンティティタグを提供し、そのエンティティタグの生成が強力なバリデーターのすべての特性を満たさない場合（ &lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1&lt;/a&gt;）、次に、オリジンサーバーは、その不透明な値の前に「W /」（大文字と小文字を区別）を付けて、エンティティタグを弱いものとしてマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">リクエストの「Expect」ヘッダーフィールドは、このリクエストを適切に処理するためにサーバーでサポートする必要がある特定の一連の動作（期待）を示します。この仕様で定義されているそのような期待値は100-continueだけです。 Expect = &quot;100-continue&quot; Expectフィールド値は大文字と小文字を区別しません。 100-continue以外のExpectフィールド値を受信したサーバーは、417（Expectation Failed）ステータスコードで応答して、予期しない期待に応えられないことを示す場合があります。 100継続期待値は、クライアントがこのリクエストで（おそらく大きな）メッセージ本文を送信しようとしていることを受信者に通知し、リクエストラインとヘッダーフィールドが即時に発生するのに十分でない場合、100（継続）中間応答の受信を希望します。成功、リダイレクト、またはエラー応答。これにより、クライアントは、実際に送信する前にメッセージ本文を送信する価値があるという指示を待つことができます。これにより、メッセージ本文が巨大な場合、またはエラーが発生する可能性が高いとクライアントが予想する場合（たとえば、状態を送信する場合）に効率を向上できます。 -以前に検証された認証資格情報なしで、初めてメソッドを変更する）。たとえば、PUT / somewhere / fun HTTP / 1.1ホストで始まるリクエスト：origin.example.com Content-Type：video / h264 Content-Length：1234567890987 Expect：100-continueは、配信元サーバーがエラーですぐに応答できるようにしますクライアントが不必要なデータ転送でパイプを埋め始める前に、401（許可されていない）または405（メソッドが許可されていない）などのメッセージ。クライアントの要件：oクライアントは、メッセージ本文を含まないリクエストで100-continue期待値を生成してはなりません（MUST NOT）。 oリクエストメッセージ本文を送信する前に100（Continue）応答を待つクライアントは、100-continue期待値を含むExpectヘッダーフィールドを送信する必要があります。 o 100継続期待値を送信するクライアントは、特定の時間待機する必要はありません。そのようなクライアントは、まだ応答を受け取っていなくても、メッセージ本文の送信を続行できます（MAY）。さらに、100（Continue）応答はHTTP / 1.0の中間手段を介して送信できないため、そのようなクライアントは、メッセージ本文を送信する前に無期限に待機してはなりません（SHOULD NOT）。o 417応答は応答チェーンが期待をサポートしていないことを示すだけなので、100継続期待を含む要求に応答して417（期待失敗）ステータスコードを受信するクライアントは、100継続期待なしでその要求を繰り返す必要があります（たとえば、HTTP / 1.0サーバーを通過します）。サーバーの要件：o HTTP / 1.0リクエストで100-continue期待を受信するサーバーは、その期待を無視する必要があります。 o対応する要求のメッセージ本文の一部またはすべてをすでに受信している場合、またはフレーミングがメッセージ本文がないことを示している場合、サーバーは100（Continue）応答の送信を省略できます。 o 100（Continue）応答を送信するサーバーは、最終的に最終ステータスコードを送信する必要があります。メッセージ本文が受信されて処理されると、接続が時期尚早に閉じられない限り。 oメッセージ本文全体を読み取る前に最終ステータスコードで応答するサーバーは、その応答で、接続を閉じるか、要求メッセージの読み取りと破棄を続行するかどうかを示す必要があります（を参照）。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230]のセクション6.6&lt;/a&gt;）。オリジンサーバーは、HTTP / 1.1（またはそれ以降）のリクエストラインと、100-continue期待値を含み、リクエストメッセージ本文が続くことを示す完全なヘッダーセクションを受信すると、最終ステータスコードを含む即時応答を送信する必要があります。 request-lineフィールドとheaderフィールドだけを調べてそのステータスを判別できる場合、またはクライアントにリクエストのメッセージ本文を送信するように促すために即時100（Continue）応答を送信する場合。オリジンサーバーは、100（Continue）応答を送信する前にメッセージ本文を待機してはなりません（MUST NOT）。プロキシは、HTTP / 1.1（またはそれ以降）の要求行と、100継続の期待値を含み、要求メッセージ本文が続くことを示す完全なヘッダーセクションを受信すると、最終ステータスコードを含む即時応答を送信する必要があります。リクエストラインとヘッダーフィールドだけを調べてそのステータスを判別できる場合、または対応するリクエストラインとヘッダーセクションを次のインバウンドサーバーに送信して、オリジンサーバーに向けてリクエストの転送を開始する場合。プロキシが次の受信サーバーがHTTP / 1.0のみをサポートしていると（構成または過去の対話から）信じている場合、プロキシはクライアントにメッセージ本文の送信を開始するように促す即時100（Continue）応答を生成できます（MAY）。注：Expectヘッダーフィールドは、HTTP / 1.1 [プロキシが次の受信サーバーがHTTP / 1.0のみをサポートしていると（構成または過去の対話から）信じている場合、プロキシはクライアントにメッセージ本文の送信を開始するように促す即時100（Continue）応答を生成できます（MAY）。注：Expectヘッダーフィールドは、HTTP / 1.1 [プロキシが次の受信サーバーがHTTP / 1.0のみをサポートしていると（構成または過去の対話から）信じている場合、プロキシはクライアントにメッセージ本文の送信を開始するように促す即時100（Continue）応答を生成できます（MAY）。注：Expectヘッダーフィールドは、HTTP / 1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ]は、暫定100（Continue）応答を要求する手段と、理解しなければならない拡張を示す一般的なメカニズムの両方として。ただし、拡張メカニズムはクライアントで使用されておらず、理解しなければならない要件が多くのサーバーで実装されていないため、拡張メカニズムは役に立たなくなります。この仕様では、100-continueの定義と処理を簡略化するために、拡張メカニズムが削除されています。</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">「Expires」ヘッダーフィールドには、応答が古くなったと見なされるまでの日時が示されます。鮮度モデルの詳細については、&lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt;を参照してください。 Expiresフィールドの存在は、元のリソースがその時点で、前に、または後に変更または存在しなくなることを意味しません。 Expires値は、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;セクション&lt;/a&gt;7.1.1.1で定義されているHTTP日付のタイムスタンプです。 Expires = HTTP-dateたとえばExpires：Thu、01 Dec 1994 16:00:00 GMT ）。応答にmax-ageディレクティブを含むCache-Controlフィールドが含まれている場合（&lt;a href=&quot;#section-5.2.2.8&quot;&gt;セクション5.2.2.8&lt;/a&gt;）、受信者はExpiresフィールドを無視する必要があります。同様に、応答にs-maxageディレクティブが含まれている場合（&lt;a href=&quot;#section-5.2.2.9&quot;&gt;セクション5.2.2.9&lt;/a&gt;）、共有キャッシュの受信者はExpiresフィールドを無視する必要があります。これらのどちらの場合でも、Expiresの値は、Cache-Controlフィールドをまだ実装していない受信者のみを対象としています。クロックのないオリジンサーバーは、その値が過去の固定時間（常に期限切れ）を表すか、その値が信頼できるクロックを持つシステムまたはユーザーによってリソースに関連付けられていない限り、Expiresフィールドを生成してはなりません（MUST NOT）。歴史的に、HTTPではExpiresフィールドの値を1年以内にする必要がありました。鮮度の寿命を長くすることはもはや禁止されていませんが、非常に大きな値は問題を引き起こすことが実証されており（たとえば、時間値に32ビット整数を使用することによるクロックオーバーフロー）、多くのキャッシュはそれよりはるかに早く応答を追い出します。</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">「From」ヘッダーフィールドには、要求元のユーザーエージェントを制御する人間のユーザーのインターネット電子メールアドレスが含まれています。&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]のセクション3.4の&lt;/a&gt;「メールボックス」で定義されているように、アドレスはマシンで使用可能である必要があります：送信元=メールボックスメールボックス= &amp;lt;メールボックス、&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]のセクション3.4を&lt;/a&gt;参照&amp;gt;例は次のとおりです。From：webmaster@example.org Fromヘッダーフィールドは、非ロボットユーザーエージェントによってめったに送信されません。ユーザーエージェントは、ユーザーのプライバシーに関する関心やサイトのセキュリティポリシーと競合する可能性があるため、ユーザーによる明示的な構成なしにFromヘッダーフィールドを送信しないでください。ロボットユーザーエージェントは有効なFromヘッダーフィールドを送信する必要があります（SHOULD）。ロボットが過剰な、望ましくない、または無効なリクエストを送信している場合など、サーバーで問題が発生した場合にロボットの実行責任者に連絡できるようにする必要があります。ほとんどの受信者はフィールド値が公開情報であると想定するため、サーバーはアクセス制御または認証にFromヘッダーフィールドを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「HTTPコンテンツコーディングレジストリ」は、コンテンツコーディング名の名前空間を定義します（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]のセクション4.2&lt;/a&gt;）。コンテンツコーディングレジストリは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;で管理されています。</target>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">「HTTPコンテンツコーディングレジストリ」は、以下の登録で更新されています。+ ---------- + ----------------------- ----------------- + --------------- + | 名前| 説明| リファレンス| + ---------- + -------------------------------------- -+ --------------- + | アイデンティティ| 予約済み（&lt;a href=&quot;#section-5.3.4&quot;&gt;セクション5.3.4の&lt;/a&gt;「エンコーディングなし」の同義語| | | Accept-Encoding）| | + ---------- + -------------------------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「HTTPレンジユニットレジストリ」は、レンジユニット名の名前空間を定義し、対応する仕様を参照します。レジストリが作成され、現在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;で維持されています。</target>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「HTTP転送コーディングレジストリ」は、転送コーディング名の名前空間を定義します。&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;で管理されています。</target>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">&quot;HTTP Transfer Coding Registry&quot;は、以下の登録で更新されました：+ ------------ + --------------------- ----------------- + --------------- + |名前|説明|リファレンス| + ------------ + ------------------------------------ -+ --------------- + |チャンク|一連のチャンクで転送| &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; | |圧縮| UNIXの「圧縮」データ形式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | |しぼむ|圧縮データを「デフレート」する| &lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）「zlib」データ内| | | |形式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIPファイル形式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | | x-compress |非推奨（圧縮のエイリアス）| &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | | x-gzip |非推奨（gzipのエイリアス）| &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">アップグレードトークンレジストリの「HTTP」エントリは、以下の登録で更新されました：+ ------- + ---------------------- + ---------------------- + ------------- + |値|説明|期待されるバージョン|リファレンス| | | |トークン| | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP |ハイパーテキスト転送| DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;セクション2.6&lt;/a&gt; | | |プロトコル| （例：「2.0」）| | + ------- + ---------------------- + ------------------ ---- + ------------- +責任者は、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">リクエストの「Host」ヘッダーフィールドは、ターゲットURIからのホストとポートの情報を提供し、単一のIPアドレスで複数のホスト名のリクエストを処理しながら、起点サーバーがリソースを区別できるようにします。 Host = uri-host [&quot;：&quot;ポート]; &lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt; クライアントは、すべてのHTTP / 1.1要求メッセージでホストヘッダーフィールドを送信する必要があります。ターゲットURIにオーソリティコンポーネントが含まれている場合、クライアントは、userinfoサブコンポーネントとその「@」区切り文字を除いて、そのオーソリティコンポーネントと同一のHostのフィールド値を送信する必要があります（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）。権限コンポーネントが見つからないか、ターゲットURIに対して定義されていない場合、クライアントは空のフィールド値を持つホストヘッダーフィールドを送信する必要があります。 Hostフィールド値はリクエストを処理するための重要な情報であるため、ユーザーエージェントは、リクエスト行に続く最初のヘッダーフィールドとしてホストを生成する必要があります（SHOULD）。たとえば、&amp;lt;http://www.example.org/pub/WWW/&amp;gt;のオリジンサーバーへのGETリクエストは、次のように始まります：GET / pub / WWW / HTTP / 1.1ホスト：www.example.orgクライアントは、リクエストターゲットが絶対形式であっても、ホストヘッダーフィールドをHTTP / 1.1リクエストで送信します。これにより、ホストを実装していない可能性のある古いHTTP / 1.0プロキシを通じてホスト情報を転送できるようになります。プロキシがrequest-targetの絶対形式のリクエストを受信すると、プロキシは受信したホストヘッダーフィールド（存在する場合）を無視し、代わりにリクエストターゲットのホスト情報で置き換える必要があります（MUST）。このようなリクエストを転送するプロキシは、受信したホストフィールド値を転送するのではなく、受信したリクエストターゲットに基づいて新しいホストフィールド値を生成する必要があります。 Hostヘッダーフィールドはアプリケーションレベルのルーティングメカニズムとして機能するため、共有キャッシュを汚染したり、要求を意図しないサーバーにリダイレクトしたりしようとするマルウェアの頻繁なターゲットになります。インターセプトされた接続がそのホストの有効なIPアドレスをターゲットにしていることを最初に確認せずに、内部サーバーにリクエストをリダイレクトするため、または共有キャッシュのキャッシュキーとして使用するためにHostフィールド値に依存している場合、インターセプトプロキシは特に脆弱です。サーバーは、ホストヘッダーフィールドがないHTTP / 1.1リクエストメッセージ、および複数のホストヘッダーフィールドまたは無効なフィールド値を持つホストヘッダーフィールドを含むリクエストメッセージに対して、400（不良リクエスト）ステータスコードで応答する必要があります。 。</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「Hypertext Transfer Protocol（HTTP）Authentication Scheme Registry」は、チャレンジおよび資格情報の認証スキームの名前空間を定義します。これは作成され、現在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt;で維持されています。</target>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）キャッシュディレクティブレジストリ」は、キャッシュディレクティブの名前空間を定義します。作成され、現在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt;で維持されています。</target>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」は、リクエストメソッドトークンの名前空間を定義します（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）。メソッドレジストリが作成され、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt;で維持されるようになりました。</target>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」には、以下の登録が含まれています。+ --------- + ------ + ------------ + --------------- + |メソッド|安全|べき等|リファレンス| + --------- + ------ + ------------ + --------------- + |接続|いいえ|いいえ| &lt;a href=&quot;#section-4.3.6&quot;&gt;セクション4.3.6&lt;/a&gt; | |削除|いいえ|はい| &lt;a href=&quot;#section-4.3.5&quot;&gt;セクション4.3.5&lt;/a&gt; | | GET |はい|はい| &lt;a href=&quot;#section-4.3.1&quot;&gt;セクション4.3.1&lt;/a&gt; | |ヘッド|はい|はい| &lt;a href=&quot;#section-4.3.2&quot;&gt;セクション4.3.2&lt;/a&gt; | |オプション|はい|はい| &lt;a href=&quot;#section-4.3.7&quot;&gt;セクション4.3.7&lt;/a&gt; | |投稿|いいえ|いいえ| &lt;a href=&quot;#section-4.3.3&quot;&gt;セクション4.3.3&lt;/a&gt; | | PUT |いいえ|はい| &lt;a href=&quot;#section-4.3.4&quot;&gt;セクション4.3.4&lt;/a&gt; | | TRACE |はい|はい|&lt;a href=&quot;#section-4.3.8&quot;&gt;セクション4.3.8&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）ステータスコードレジストリ」は、応答ステータスコードトークンの名前空間を定義します（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）。ステータスコードレジストリは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;で管理されています。このセクションは、以前&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;に[RFC2817]のセクション7.1で&lt;/a&gt;定義されたHTTPステータスコードの登録手順を置き換えます。</target>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;にある「ハイパーテキスト転送プロトコル（HTTP）ステータスコードレジストリ」が更新され、以下の登録が追加されました。+ ------- + ----------------------- + ------------- + |値|説明|リファレンス| + ------- + ----------------------- + ------------- + | 206 |部分的なコンテンツ| &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; | | 416 |範囲が満足できません| &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;にある「ハイパーテキスト転送プロトコル（HTTP）ステータスコードレジストリ」は、以下の登録で更新されています。+ ------- + --------------------- + ------------- + |値|説明|リファレンス| + ------- + --------------------- + ------------- + | 304 |変更されていません| &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; | | 412 |前提条件が失敗しました| &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;にある「ハイパーテキスト転送プロトコル（HTTP）ステータスコードレジストリ」は、以下の登録で更新されています。+ ------- + ------------------------------- + ------------- + |値|説明|リファレンス| + ------- + ------------------------------- + --------- ---- + | 401 |無許可| &lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt; | | 407 |プロキシ認証が必要です| &lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）アップグレードトークンレジストリ」は、アップグレードヘッダーフィールドでプロトコルを識別するために使用されるプロトコル名トークンの名前空間を定義します。レジストリは&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;で管理されています。</target>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">「ハイパーテキスト転送プロトコル（HTTP）警告コード」レジストリは、警告コードの名前空間を定義します。これは作成され、現在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt;で維持されています。</target>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">「If-Match」ヘッダーフィールドは、フィールド値が「*」の場合、ターゲットリソースの現在の表現を少なくとも1つ持つか、またはfield-valueで提供されるエンティティタグのリストのメンバーと一致するエンティティタグがあります。オリジンサーバーは、If-Matchのエンティティタグを比較するときに強力な比較関数を使用する必要があります（&lt;a href=&quot;#section-2.3.2&quot;&gt;セクション2.3.2）。&lt;/a&gt;）、クライアントがこの前提条件を意図しているのは、表現データに変更があった場合にメソッドが適用されないようにするためです。 If-Match = &quot;*&quot; / 1＃entity-tag例：If-Match： &quot;xyzzy&quot; If-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot;、 &quot;c3piozzzz&quot; If-Match：* If-Matchは、状態変更メソッド（POST、PUT、DELETEなど）。複数のユーザーエージェントが同じリソースで並行して動作している可能性がある場合に誤って上書きされるのを防ぎます（つまり、「失われた更新」の問題を防ぎます）。また、選択した表現が前の要求からすでに格納されている（または部分的に格納されている）表現と一致しない場合に、要求を中止する安全なメソッドと共に使用することもできます。If-Matchヘッダーフィールドを受信するオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。フィールド値が「*」の場合、オリジンサーバーにターゲットリソースの現在の表現がない場合、条件はfalseです。フィールド値がエンティティタグのリストである場合、リストされたタグのいずれも選択した表現のエンティティタグと一致しない場合、条件はfalseです。受信したIf-Match条件がfalseと評価された場合、オリジンサーバーは要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、オリジンサーバーは、a）412（Precondition Failed）ステータスコードまたはb）2xx（Successful）ステータスコードのいずれかで応答する必要があります。ターゲットリソースの現在の状態に反映されます（つまり、ユーザーエージェントによって要求された変更はすでに成功しています。しかし、おそらく前の応答が失われたか、互換性のある変更が他のユーザーエージェントによって行われたために、ユーザーエージェントはそれを認識しない可能性があります。後者の場合、元のサーバーは、リクエストが同じユーザーエージェントによって行われた直前の変更の複製であることを確認できない限り、応答でバリデーターヘッダーフィールドを送信してはなりません（MUST NOT）。 If-Matchヘッダーフィールドは、格納された応答には適用されないため、キャッシュおよび中間者によって無視されます。If-Matchヘッダーフィールドは、格納された応答には適用されないため、キャッシュおよび中間者によって無視されます。If-Matchヘッダーフィールドは、格納された応答には適用されないため、キャッシュおよび中間者によって無視されます。</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">「If-Modified-Since」ヘッダーフィールドは、選択された表現の変更日付がフィールド値で提供された日付よりも新しいことを条件として、GETまたはHEADリクエストメソッドを作成します。選択した表現のデータが変更されていない場合、そのデータの転送は回避されます。 If-Modified-Since = HTTP-dateこのフィールドの例は次のとおりです。 -ヘッダーフィールドを一致させます。 If-None-Matchの条件は、If-Modified-Sinceの条件のより正確な置き換えと見なされ、2つは、If-None-Matchを実装しない可能性のある古い仲介者と相互運用するためにのみ結合されます。受信したフィールド値が有効なHTTP日付でない場合、または要求メソッドがGETでもHEADでもない場合、受信者はIf-Modified-Sinceヘッダーフィールドを無視する必要があります。受信者は、起点サーバーのクロックに関して、If-Modified-Sinceフィールド値のタイムスタンプを解釈する必要があります。 If-Modified-Sinceは通常、2つの異なる目的で使用されます。1）エンティティタグを持たないキャッシュされた表現を効率的に更新できるようにすること、2）Webトラバーサルの範囲を最近変更されたリソースに制限することです。キャッシュの更新に使用される場合、キャッシュは通常、キャッシュされたメッセージのLast-Modifiedフィールドの値を使用して、If-Modified-Sinceのフィールド値を生成します。この動作は、クロックが十分に同期されていない場合、またはサーバーがタイムスタンプの正確な一致のみを尊重することを選択した場合に最も相互運用可能です（元のサーバーのクロックが修正されたときに「過去に遡る」ように見えるLast-Modified日付の問題が原因です）または、表現がアーカイブされたバックアップから復元されます）。ただし、キャッシュは、特にキャッシュされたメッセージにLast-Modifiedフィールドが含まれていない場合、キャッシュされたメッセージのDateヘッダーフィールドやメッセージが受信されたローカルクロック時間など、他のデータに基づいてフィールド値を生成することがあります。検索の範囲を最近の時間枠に制限するために使用される場合、ユーザーエージェントは、独自のローカルクロックまたは以前の応答でサーバーから受信した日付ヘッダーフィールドのいずれかに基づいて、If-Modified-Sinceフィールド値を生成します。選択された表現のLast-Modifiedフィールドに基づいて正確なタイムスタンプの一致を選択するオリジンサーバーは、ユーザーエージェントがデータ転送を指定されたウィンドウ中に変更されたもののみに制限することを支援できません。 If-Modified-Sinceヘッダーフィールドを受け取るオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（SHOULD）。If-Modified-Sinceヘッダーフィールドを受け取るオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（SHOULD）。If-Modified-Sinceヘッダーフィールドを受信するオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（SHOULD）。&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。オリジンサーバーは、選択された表現の最終変更日付がフィールド値で提供された日付以前の場合、要求されたメソッドを実行してはなりません。代わりに、オリジンサーバーは、以前にキャッシュされた応答の識別または更新に役立つメタデータのみを含めて、304（Not Modified）応答を生成する必要があります（SHOULD）。受信したIf-Modified-Sinceヘッダーフィールドのキャッシュ処理に関する要件は&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;、[RFC7234]のセクション4.3.2で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">「If-None-Match」ヘッダーフィールドは、フィールド値が「*」の場合、ターゲットリソースの現在の表現がないか、または選択された表現を持つfield-valueにリストされているものと一致しないエンティティタグ。受信者は、If-None-Matchのエンティティタグを比較するときに、弱い比較関数を使用する必要があります（&lt;a href=&quot;#section-2.3.2&quot;&gt;セクション2.3.2）。&lt;/a&gt;）、表現データに変更があった場合でも、弱いエンティティタグをキャッシュの検証に使用できるため。 If-None-Match = &quot;*&quot; / 1＃entity-tag例：If-None-Match： &quot;xyzzy&quot; If-None-Match：W / &quot;xyzzy&quot; If-None-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot; 、 &quot;c3piozzzz&quot; If-None-Match：W / &quot;xyzzy&quot;、W / &quot;r2d2xxxx&quot;、W / &quot;c3piozzzz&quot; If-None-Match：* If-None-Matchは主に条件付きGETリクエストで使用され、効率的な更新を可能にします最小限のトランザクションオーバーヘッドでキャッシュされた情報の。クライアントがエンティティタグを持つ1つ以上の保存された応答を更新することを望む場合、クライアントはGETリクエストを行うときにそれらのエンティティタグのリストを含むIf-None-Matchヘッダーフィールドを生成する必要があります。これにより、受信側サーバーは304（Not Modified）応答を送信して、保存された応答の1つが選択された表現と一致することを示すことができます。 If-None-Matchを「*」の値と共に使用して、クライアントがリソースに現在の表現がないと信じているときに、安全でないリクエストメソッド（PUTなど）がターゲットリソースの既存の表現を誤って変更するのを防ぐこともできます。 （PUT）リソースに現在の表現がないとクライアントが信じている場合に、ターゲットリソースの既存の表現を誤って変更することから（PUT）リソースに現在の表現がないとクライアントが信じている場合に、ターゲットリソースの既存の表現を誤って変更することから（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]のセクション4.2.1&lt;/a&gt;）。これは、複数のクライアントがターゲットリソースの初期表現を作成しようとした場合に発生する可能性のある「失われた更新」問題のバリエーションです。 If-None-Matchヘッダーフィールドを受信するオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。フィールド値が &quot;*&quot;の場合、オリジンサーバーにターゲットリソースの現在の表現がある場合、条件はfalseです。 field-valueがエンティティタグのリストである場合、リストされたタグのいずれかが選択した表現のエンティティタグと一致すると、条件はfalseになります。オリジンサーバーは、条件がfalseと評価された場合、要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、オリジンサーバーは、a）リクエストメソッドがGETまたはHEADの場合は304（Not Modified）ステータスコード、またはb）他のすべてのリクエストメソッドの場合は412（Precondition Failed）ステータスコードのいずれかで応答する必要があります。受信したIf-None-Matchヘッダーフィールドのキャッシュ処理に関する要件は&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;、[RFC7234]のセクション4.3.2で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">「If-Range」ヘッダーフィールドは、If-MatchおよびIf-Unmodified-Sinceヘッダーフィールドと同様の特別な条件付きリクエストメカニズムを提供しますが、バリデーターが一致しない場合、結果としてRangeヘッダーフィールドを無視するように受信者に指示します。 412（Precondition Failed）応答ではなく、新しく選択された表現の転送。 If-Rangeは&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]のセクション3.2で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">「If-Unmodified-Since」ヘッダーフィールドは、選択された表現の最終変更日がfield-valueで指定された日付より前か等しいことを条件として、リクエストメソッドを作成します。このフィールドは、ユーザーエージェントが表現のエンティティタグを持たない場合のIf-Matchと同じ目的を果たします。 If-Unmodified-Since = HTTP-dateフィールドの例は次のとおりです：If-Unmodified-Since：Sat、29 Oct 1994 19:43:31 GMTリクエストにIf-Matchが含まれている場合、受信者はIf-Unmodified-Sinceを無視する必要がありますヘッダーフィールド。 If-Matchの条件は、If-Unmodified-Sinceの条件のより正確な置き換えと見なされ、2つは、If-Matchを実装しない可能性のある古い仲介者と相互運用するためにのみ結合されます。受信したフィールド値が有効なHTTP日付でない場合、受信者はIf-Unmodified-Sinceヘッダーフィールドを無視する必要があります。受信者は、起点サーバーのクロックに関して、If-Unmodified-Sinceフィールド値のタイムスタンプを解釈する必要があります。 If-Unmodified-Sinceは、多くの場合、状態を変更するメソッド（POST、PUT、DELETEなど）で使用され、複数のユーザーエージェントがエンティティタグとその表現を提供しないリソースで並行して動作している可能性がある場合の偶発的な上書きを防止します（つまり、「失われた更新」の問題を防ぐためです）。また、選択した表現が前の要求からすでに格納されている（または部分的に格納されている）表現と一致しない場合に、要求を中止する安全なメソッドと共に使用することもできます。If-Unmodified-Sinceヘッダーフィールドを受け取るオリジンサーバーは、メソッドを実行する前に条件を評価する必要があります（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。オリジンサーバーは、選択された表現の最終変更日付がフィールド値で提供された日付よりも新しい場合、要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、オリジンサーバーは、a）412（Precondition Failed）ステータスコードまたはb）2xx（Successful）ステータスコードのいずれかで応答する必要があります。ターゲットリソースの現在の状態（つまり、ユーザーエージェントによって要求された変更は既に成功していますが、前の応答メッセージが失われたか、互換性のある変更が他のユーザーエージェントによって行われたため、ユーザーエージェントはそのことに気付かない場合があります）。後者の場合、オリジンサーバーは、リクエストが同じユーザーエージェントによって行われた直前の変更の複製であることを確認できない限り、応答でバリデーターヘッダーフィールドを送信してはいけません。 If-Unmodified-Sinceヘッダーフィールドは、格納された応答には適用されないため、キャッシュおよび仲介者によって無視できます。</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">応答の「Last-Modified」ヘッダーフィールドは、オリジンサーバーが選択した表現が最後に修正 されたと考える日時を示すタイムスタンプを提供する(リクエストの処理が終了した時点で 決定される)。Last-Modified=HTTP-date その使用例は Last-Modified です。Tue,15 Nov 1994 12:45:26 GMT</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">「Location」ヘッダーフィールドは、応答に関連して特定のリソースを参照するために一部の応答で使用されます。関係のタイプは、リクエストメソッドとステータスコードのセマンティクスの組み合わせによって定義されます。 Location = URI-referenceフィールド値は、単一のURI-referenceで構成されています。相対参照（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]、セクション4.2&lt;/a&gt;）の形式の場合、最終的な値は、有効なリクエストURI（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986]、セクション5）&lt;/a&gt;に対して解決することによって計算されます。）。 201（Created）応答の場合、Location値は、要求によって作成されたプライマリリソースを指します。 3xx（リダイレクト）応答の場合、ロケーション値は、要求を自動的にリダイレクトするための優先ターゲットリソースを指します。 3xx（リダイレクト）応答で提供されるLocation値にフラグメントコンポーネントがない場合、ユーザーエージェントは、値がリクエストターゲットの生成に使用されるURI参照のフラグメントコンポーネントを継承する（つまり、リダイレクトが継承する）かのようにリダイレクトを処理する必要があります。元の参照のフラグメント（存在する場合））。たとえば、URI参照 &quot;http://www.example.org/~tim&quot;に対して生成されたGETリクエストは、ヘッダーフィールドLocation：/ Peopleを含む303（その他を参照）レスポンスになる可能性があります。ユーザーエージェントが「http://www.example.org/People.html#tim」にリダイレクトすることを示唆するhtml＃tim同様に、URI参照「http://www.example.org/index」に対して生成されたGETリクエスト.html＃larry &quot;は、ヘッダーフィールドを含む301（Moved Permanently）レスポンスになる可能性があります：場所：http://www.example.net/index.htmlこれは、ユーザーエージェントが&quot; http：// www。 example.net/index.html#larry &quot;、元のフラグメント識別子を保持します。 Location値のフラグメント識別子が適切でない状況があります。たとえば、201（Created）応答のLocationヘッダーフィールドは、作成されたリソースに固有のURIを提供することになっています。注意：一部の受信者は、有効なURI参照ではない場所フィールドからの回復を試みます。この仕様は、そのような処理を義務付けたり定義したりするものではありませんが、堅牢性のためにそれを許可しています。注：Content-Locationヘッダーフィールド（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション3.1.4.2&lt;/a&gt;）は、Content-Locationが囲まれた表現に対応する最も具体的なリソースを参照するという点でLocationとは異なります。したがって、応答にLocationヘッダーフィールドとContent-Locationヘッダーフィールドの両方を含めることができます。</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">「Max-Forwards」ヘッダーフィールドは、TRACE（&lt;a href=&quot;#section-4.3.8&quot;&gt;セクション4.3.8&lt;/a&gt;）およびOPTIONS（&lt;a href=&quot;#section-4.3.7&quot;&gt;セクション4.3.7&lt;/a&gt;）を備えたメカニズムを提供します。）リクエストメソッドは、リクエストがプロキシによって転送される回数を制限します。これは、クライアントが中間チェーンで失敗またはループしているように見える要求をトレースしようとしている場合に役立ちます。 Max-Forwards = 1 * DIGIT Max-Forwards値は、この要求メッセージを転送できる残りの回数を示す10進整数です。 Max-Forwardsヘッダーフィールドを含むTRACEまたはOPTIONSリクエストを受信する各仲介者は、リクエストを転送する前にその値をチェックして更新する必要があります。受信した値がゼロ（0）の場合、仲介者はリクエストを転送してはなりません（MUST NOT）。代わりに、仲介者は最終受信者として応答する必要があります。受信したMax-Forwards値がゼロより大きい場合、仲介者は、転送されたメッセージ内の更新されたMax-Forwardsフィールドを、a）1だけ減少した受信値、またはb）Max-Forwardsの受信者のサポートされている最大値の小さい方のフィールド値で生成する必要があります。受信者は、他のリクエストメソッドで受信したMax-Forwardsヘッダーフィールドを無視してもよい（MAY）。</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">「メッセージヘッダー」レジストリは、次の永続的な登録で更新されました：+ ------------------- + ---------- + --- ------- + ----------------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ---------- + |同意する| http |標準| &lt;a href=&quot;#section-5.3.2&quot;&gt;セクション5.3.2&lt;/a&gt; | | Accept-Charset | http |標準| &lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt; | | Accept-Encoding | http |標準| &lt;a href=&quot;#section-5.3.4&quot;&gt;セクション5.3.4&lt;/a&gt; | | Accept-Language | http |標準| &lt;a href=&quot;#section-5.3.5&quot;&gt;セクション5.3.5&lt;/a&gt; | |許可| http |標準| &lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt; | |コンテンツのエンコード| http |標準| &lt;a href=&quot;#section-3.1.2.2&quot;&gt;セクション3.1.2.2&lt;/a&gt;| |コンテンツ言語| http |標準| &lt;a href=&quot;#section-3.1.3.2&quot;&gt;セクション3.1.3.2&lt;/a&gt; | |コンテンツの場所| http |標準| &lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション3.1.4.2&lt;/a&gt; | | Content-Type | http |標準| &lt;a href=&quot;#section-3.1.1.5&quot;&gt;セクション3.1.1.5&lt;/a&gt; | |日付| http |標準| &lt;a href=&quot;#section-7.1.1.2&quot;&gt;セクション7.1.1.2&lt;/a&gt; | |期待する| http |標準| &lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt; | |から| http |標準| &lt;a href=&quot;#section-5.5.1&quot;&gt;セクション5.5.1&lt;/a&gt; | |ロケーション| http |標準| &lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt; | | Max-Forwards | http |標準| &lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt; | | MIMEバージョン| http |標準| &lt;a href=&quot;#appendix-A.1&quot;&gt;付録A.1&lt;/a&gt; | |リファラー| http |標準| &lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt; | |再試行後| http |標準| &lt;a href=&quot;#section-7.1.3&quot;&gt;セクション7.1.3&lt;/a&gt; | |サーバー| http |標準| &lt;a href=&quot;#section-7.4.2&quot;&gt;セクション7.4.2&lt;/a&gt; | |ユーザーエージェント| http |標準| &lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt; | |変化する| http |標準| &lt;a href=&quot;#section-7.1.4&quot;&gt;セクション7.1.4&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- +上記の登録の変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">「プラグマ」ヘッダーフィールドは、HTTP / 1.0キャッシュとの下位互換性を可能にし、クライアントが理解できる「キャッシュなし」リクエストを指定できるようにします（Cache-ControlはHTTP / 1.1まで定義されていなかったため）。 Cache-Controlヘッダーフィールドもリクエストに存在し、理解されている場合、プラグマは無視されます。 HTTP / 1.0では、プラグマは、受信者向けの実装指定のディレクティブ用の拡張可能なフィールドとして定義されていました。この仕様では、相互運用性を向上させるために、このような拡張機能を廃止しています。 Pragma = 1＃pragma-directive pragma-directive = &quot;no-cache&quot; / extension-pragma extension-pragma = token [&quot;=&quot;（token / quoted-string）] Cache-Controlヘッダーフィールドがリクエストに存在しない場合、キャッシュは、no-cacheリクエストプラグマディレクティブが、「Cache-Control：no-cache」が存在する場合と同じ効果があると見なす必要があります（参照 &lt;a href=&quot;#section-5.2.1&quot;&gt;セクション5.2.1&lt;/a&gt;）。キャッシュなしリクエストを送信するとき、クライアントはプラグマディレクティブとキャッシュコントロールディレクティブの両方を含める必要があります。ただし、Cache-Control：no-cacheは、HTTP / 1.1キャッシュで他のキャッシュコントロールレスポンスディレクティブをターゲットにするために意図的に省略されています。例：GET / HTTP / 1.1ホスト：www.example.com Cache-Control：max-age = 30プラグマ：no-cacheは、30秒以内の応答を提供するようにHTTP / 1.1キャッシュを制約します。 Cache-Controlがキャッシュされた応答を提供することを理解できません。注：応答での「プラグマ：no-cache」の意味は指定されていないため、それらの「Cache-Control：no-cache」の信頼できる代替は提供されません。</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">「Proxy-Authenticate」ヘッダーフィールドは、この有効なリクエストURIのプロキシに適用可能な認証スキームとパラメータを示す少なくとも1つのチャレンジで構成されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]のセクション5.5&lt;/a&gt;）。プロキシは、生成する407（Proxy Authentication Required）応答ごとに少なくとも1つのProxy-Authenticateヘッダーフィールドを送信する必要があります。 Proxy-Authenticate = 1＃challenge WWW-Authenticateとは異なり、Proxy-Authenticateヘッダーフィールドは、応答チェーンの次の送信クライアントにのみ適用されます。これは、特定のプロキシを選択したクライアントのみが、認証に必要な資格情報を持つ可能性があるためです。ただし、大規模な企業ネットワーク内のオフィスやリージョナルキャッシングプロキシなど、同じ管理ドメイン内で複数のプロキシが使用されている場合、認証情報はユーザーエージェントによって生成され、消費されるまで階層を通過するのが一般的です。したがって、このような構成では、各プロキシは同じチャレンジセットを送信するため、Proxy-Authenticateが転送されているように見えます。 WWW-Authenticateの解析に関する考慮事項は、このヘッダーフィールドにも適用されることに注意してください。見る&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;詳細については、セクション4.1。</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorization」ヘッダーフィールドは、クライアントが認証を必要とするプロキシに 対して自分自身(またはそのユーザー)を識別することを可能にする。その値は、リクエストされたリソースのプロキシおよび/またはレル ムに対するクライアントの認証情報を含む信用証明書で構成される。Proxy-Authorization=credentials Authorizationとは異なり、Proxy-Authorizationヘッダーフィー ルドは、Proxy-Authenticateフィールドを使用して認証を要求した次のインバウンドプロキシ にのみ適用される。複数のプロキシがチェーンで使用されるとき、Proxy-Authorizationヘッダー フィールドは、信用証明書を受け取ることを期待していた最初のインバウンドプロキシに よって消費される。プロキシが与えられたリクエストをプロキシが協調して認証する仕組みであれば、プロキシ はクライアントリクエストからの信用証明書を次のプロキシにリレーしてもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">GETリクエストの「範囲」ヘッダーフィールドは、メソッドのセマンティクスを変更して、選択された表現データ全体ではなく、選択された表現データの1つ以上のサブ範囲のみの転送を要求します。 Range = byte-ranges-specifier / other-ranges-specifier other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set other-range-set = 1 * VCHARサーバーはRangeヘッダーフィールドを無視してもかまいません。ただし、範囲は部分的に失敗した転送からの効率的な回復と大きな​​表現の部分的な取得をサポートするため、オリジンサーバーと中間キャッシュは可能な限りバイト範囲をサポートする必要があります。サーバーは、GET以外のリクエストメソッドで受信したRangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、理解できない範囲の単位を含むRangeヘッダーフィールドを無視する必要があります。プロキシは、理解できない範囲の単位を含むRangeヘッダーフィールドを破棄してもよい（MAY）。範囲リクエストをサポートするサーバーは、2つ以上の重複する範囲、または昇順でリストされていない多数の小さな範囲のセットで構成されるRangeヘッダーフィールドを無視または拒否する場合があります。どちらもクライアントまたは意図的な破損の兆候であるためです。サービス拒否攻撃（どちらも、クライアントの破損または意図的なサービス拒否攻撃（どちらも、クライアントの破損または意図的なサービス拒否攻撃（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）。クライアントは、同じデータを含む単一の範囲よりも本質的に処理と転送の効率が悪い複数の範囲を要求しないでください。複数の範囲を要求しているクライアントは、後の部分を前に要求する特定の必要がない限り、それらの範囲を昇順（通常は完全な表現で受信される順序）でリストする必要があります（SHOULD）。たとえば、パーツの内部カタログで大きな表現を処理するユーザーエージェントは、特に表現が逆順で保存されたページで構成され、ユーザーエージェントが一度に1つのページを転送したい場合は、最初に後のパーツを要求する必要があります。 Rangeヘッダーフィールドは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232で&lt;/a&gt;定義されている前提条件ヘッダーフィールドを評価した後に評価されます。]、およびRangeヘッダーフィールドがない場合の結果が200（OK）応答の場合のみ。つまり、条件付きGETが304（Not Modified）応答を返す場合、Rangeは無視されます。 If-Rangeヘッダーフィールド（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）は、Rangeヘッダーフィールドを適用するための前提条件として使用できます。すべての前提条件が真であり、サーバーがターゲットリソースのRangeヘッダーフィールドをサポートし、指定された範囲が有効かつ充足可能である場合（&lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1で&lt;/a&gt;定義）、サーバーは206（部分的コンテンツ）応答を送信する必要があります（SHOULD）&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;定義されているように、要求された充足可能範囲に対応する1つ以上の部分表現を含むペイロード。すべての前提条件がtrueであり、サーバーがターゲットリソースのRangeヘッダーフィールドをサポートしており、指定された範囲が無効または満足できない場合、サーバーは416（Range Not Satisfiable）応答を送信する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">「Referer」[sic]ヘッダーフィールドを使用すると、ユーザーエージェントは、ターゲットURIの取得元のリソースのURI参照を指定できます（つまり、フィールド名のスペルが間違っていても「referrer」）。ユーザーエージェントは、URI参照のフラグメントおよびuserinfoコンポーネントを含めてはなりません[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]（存在する場合）、Refererフィールド値を生成するとき。 Referer = absolute-URI / partial-URI Refererヘッダーフィールドにより、サーバーは他のリソースへのバックリンクを生成して、単純な分析、ロギング、最適化されたキャッシングなどを行うことができます。また、メンテナンスのために古いリンクやタイプミスしたリンクを見つけることもできます。一部のサーバーは、他のサイトからのリンクを拒否する手段（いわゆる「ディープリンク」）またはクロスサイトリクエストフォージェリ（CSRF）を制限する手段としてリファラーヘッダーフィールドを使用しますが、すべてのリクエストに含まれるわけではありません。例：リファラー：http://www.example.org/hypertext/Overview.htmlターゲットURIが独自のURIを持たないソースから取得された場合（たとえば、ユーザーのキーボードからの入力、またはユーザーの内部のエントリ）ブックマーク/お気に入り）、ユーザーエージェントは、Refererフィールドを除外するか、「about：blank」の値を指定して送信する必要があります。リファラーフィールドは、ユーザーのリクエストコンテキストまたは閲覧履歴に関する情報を明らかにする可能性があります。これは、参照リソースの識別子が個人情報（アカウント名など）または機密であるはずのリソース（リソースなど）を明らかにした場合のプライバシーの問題です。ファイアウォールの内側やセキュリティで保護されたサービスの内部など）。参照リソースがローカルの「ファイル」または「データ」URIの場合、ほとんどの汎用ユーザーエージェントは、Refererヘッダーフィールドを送信しません。安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見るリファラーフィールドは、ユーザーのリクエストコンテキストまたは閲覧履歴に関する情報を明らかにする可能性があります。これは、参照リソースの識別子が個人情報（アカウント名など）または機密であるはずのリソース（リソースなど）を明らかにした場合のプライバシーの問題です。ファイアウォールの内側や安全なサービスの内部など）。参照リソースがローカルの「ファイル」または「データ」URIである場合、ほとんどの汎用ユーザーエージェントは、Refererヘッダーフィールドを送信しません。安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見るリファラーフィールドは、ユーザーのリクエストコンテキストまたは閲覧履歴に関する情報を明らかにする可能性があります。これは、参照リソースの識別子が個人情報（アカウント名など）または機密であるはずのリソース（リソースなど）を明らかにした場合のプライバシーの問題です。ファイアウォールの内側や安全なサービスの内部など）。参照リソースがローカルの「ファイル」または「データ」URIである場合、ほとんどの汎用ユーザーエージェントは、Refererヘッダーフィールドを送信しません。安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見るs識別子は、個人情報（アカウント名など）または機密であるはずのリソース（ファイアウォールの背後や保護されたサービスの内部など）を明らかにします。参照リソースがローカルの「ファイル」または「データ」URIである場合、ほとんどの汎用ユーザーエージェントは、Refererヘッダーフィールドを送信しません。安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見るs識別子は、個人情報（アカウント名など）または機密であるはずのリソース（ファイアウォールの背後や保護されたサービスの内部など）を明らかにします。参照リソースがローカルの「ファイル」または「データ」URIである場合、ほとんどの汎用ユーザーエージェントは、Refererヘッダーフィールドを送信しません。安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見る安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見る安全なプロトコルで参照ページを受信した場合、ユーザーエージェントは、安全でないHTTPリクエストでRefererヘッダーフィールドを送信してはなりません（MUST NOT）。見る&lt;a href=&quot;#section-9.4&quot;&gt;&lt;/a&gt;セキュリティに関するその他の考慮事項については、セクション9.4。一部の仲介者は、発信要求から無差別にリファラーヘッダーフィールドを削除することが知られています。これには、残念なことに、CSRF攻撃に対する保護を妨害するという副作用があります。これは、ユーザーにとってはるかに有害な場合があります。リファラーでの情報開示を制限したい仲介者とユーザーエージェント拡張機能は、内部ドメイン名を仮名で置き換えたり、クエリやパスコンポーネントを切り捨てたりするなど、変更を特定の編集に制限する必要があります。中間値は、フィールド値が要求ターゲットと同じスキームとホストを共有する場合、Refererヘッダーフィールドを変更または削除してはなりません（SHOULD NOT）。</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">&quot;Server&quot;ヘッダーフィールドには、要求を処理するためにオリジンサーバーが使用するソフトウェアに関する情報が含まれます。これは、報告された相互運用性の問題の範囲を特定し、特定のサーバーの制限を回避するために要求を回避または調整するためにクライアントがよく使用します。サーバーまたはオペレーティングシステムの使用に関する分析用。オリジンサーバーはその応答でサーバーフィールドを生成してもよい（MAY）。 Server = product *（RWS（product / comment））Serverフィールド値は、1つ以上の製品識別子で構成され、それぞれに0個以上のコメントが続きます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2&lt;/a&gt;）、これらは一緒にオリジンサーバーソフトウェアとその重要なサブ製品を識別します。慣例により、製品IDは、起点サーバーソフトウェアを識別するための重要度の降順でリストされています。各製品識別子は、&lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3で&lt;/a&gt;定義されているように、名前とオプションのバージョンで構成されています。例：サーバー：CERN / 3.0 libwww / 2.17オリジンサーバーは、不必要に細かい詳細を含むサーバーフィールドを生成してはならず（SHOULD NOT）、第三者によるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なサーバーフィールド値は、応答の待ち時間を増やし、潜在的なセキュリティホールを攻撃者が見つけて悪用することを（わずかに）容易にする可能性のある内部実装の詳細を明らかにする可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">リクエストの「TE」ヘッダーフィールドは、チャンク以外の転送コーディング、クライアントが応答として受け入れる用意があるかどうか、およびクライアントがチャンクされた転送コーディングのトレーラーフィールドを受け入れるかどうかを示します。 TEフィールド値は、転送コーディング名のコンマ区切りリストで構成され、それぞれがオプションのパラメーターを許可します（&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;説明）。 ）、および/またはキーワード「予告編」。クライアントは、TEでチャンク転送コーディング名を送信してはなりません（MUST NOT）。チャンクは、HTTP / 1.1受信者には常に許容されます。 TE =＃t-codings t-codings = &quot;予告編&quot; /（transfer-coding [t-ranking]）t-ranking = OWS &quot;;&quot; OWS &quot;q =&quot;ランクランク=（ &quot;0&quot; [&quot;。&quot; 0 * 3DIGIT]）/（ &quot;1&quot; [&quot;。&quot; 0 * 3（ &quot;0&quot;）]）TEの使用例は3つあります。 TE：deflate TE：TE：trailers、deflate; q = 0.5キーワード「trailers」の存在は、&lt;a href=&quot;#section-4.1.2&quot;&gt;セクション4.1.2で&lt;/a&gt;定義されているように、クライアントがチャンク転送コーディングのトレーラーフィールドを受け入れる用意があることを示します。自分自身と下流のクライアントに代わって。仲介者からの要求の場合、これは次のいずれかを意味します。（a）すべてのダウンストリームクライアントが転送された応答のトレーラーフィールドを受け入れる用意がある。または、（b）仲介者がダウンストリームの受信者に代わって応答をバッファしようとします。 HTTP / 1.1は、中間体が応答全体を確実にバッファリングできるように、チャンク化された応答のサイズを制限する手段を定義していないことに注意してください。複数の転送コーディングが受け入れられる場合、クライアントは、大文字と小文字を区別しない「q」パラメーターを使用して、優先的にコーディングをランク付けできます（コンテンツネゴシエーションフィールドで使用されるqvalueと同様、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231の&lt;/a&gt;セクション5.3.1]）。ランク値は0から1の範囲の実数で、0.001が最も優先されず、1が最も優先されます。値0は「受け入れられない」ことを意味します。 TEフィールド値が空の場合、またはTEフィールドが存在しない場合、受け入れ可能な転送コーディングのみがチャンク化されます。転送コーディングのないメッセージは常に受け入れられます。 TEヘッダーフィールドは即時接続にのみ適用されるため、TEの送信者は、TEフィールドがサポートしていない仲介者によって転送されないようにするために、接続ヘッダーフィールド（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）内で「TE」接続オプションも送信する必要があります。そのセマンティクス。</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">「アップグレード」ヘッダーフィールドは、同じ接続でHTTP / 1.1から他のプロトコルに移行するための簡単なメカニズムを提供することを目的としています。クライアントは、リクエストのUpgradeヘッダーフィールドにプロトコルのリストを送信して、最終的な応答を送信する前に、サーバーをそれらのプロトコルの1つ以上に切り替えるように招待することができます（降順）。サーバーは、その接続で現在のプロトコルを引き続き使用したい場合は、受信したアップグレードヘッダーフィールドを無視できます。プロトコルの変更を主張するためにアップグレードを使用することはできません。アップグレード= 1＃protocol protocol = protocol-name [&quot;/&quot;protocol-version] protocol-name = token protocol-version = token 101（Switching Protocols）応答を送信するサーバーは、接続の切り替え先の新しいプロトコルを示すためにUpgradeヘッダーフィールドを送信する必要があります。複数のプロトコル層が切り替えられる場合、送信者は層昇順でプロトコルをリストしなければなりません（MUST）。サーバーは、対応する要求のUpgradeヘッダーフィールドでクライアントによって示されていないプロトコルに切り替えてはなりません（MUST NOT）。サーバーは、クライアントによって示された優先順位を無視し、要求の性質やサーバーの現在の負荷などの他の要因に基づいて新しいプロトコルを選択することを選択できます（MAY）。 426（Upgrade Required）応答を送信するサーバーは、受け入れ可能なプロトコルを示すためにUpgradeヘッダーフィールドを送信する必要があります。優先順位の高い順に。サーバーは、他の応答でUpgradeヘッダーフィールドを送信して、将来のリクエストに適切な場合、降順の優先順で、リストされているプロトコルへのアップグレードのサポートを実装していることをアドバタイズできます（MAY）。以下は、クライアントから送信された架空の例です。GET/hello.txt HTTP / 1.1ホスト：www.example.com接続：アップグレードアップグレード：HTTP / 2.0、SHTTP / 1.3、IRC / 6.9、RTA / x11機能と性質プロトコル変更後のアプリケーションレベルの通信の割合は、選択した新しいプロトコルに完全に依存します。ただし、101（Switching Protocols）応答を送信した直後、サーバーは、新しいプロトコル内で同等のものを受信したかのように、元の要求に応答し続けることが期待されます（つまり、プロトコルが変更された後も、サーバーにはまだ未解決の要求を満たす必要があり、要求を繰り返す必要なくそうすることが期待されています）。たとえば、GETリクエストでUpgradeヘッダーフィールドが受信され、サーバーがプロトコルを切り替えることを決定した場合、最初にHTTP / 1.1の101（Switching Protocols）メッセージで応答し、その後すぐに新しいプロトコルに相当する応答で応答します。ターゲットリソースのGETに。これにより、接続をHTTPと同じセマンティクスを持つプロトコルにアップグレードして、追加のラウンドトリップの遅延コストを発生させることがなくなります。受信したメッセージのセマンティクスが新しいプロトコルで受け入れられない限り、サーバーはプロトコルを切り替えてはなりません（MUST NOT）。 OPTIONS要求は、どのプロトコルでも受け入れることができます。以下は、上記の架空の要求に対する応答の例です。HTTP / 1.1 101プロトコル切り替え接続：アップグレードアップグレード：HTTP / 2.0 [...データストリームは、適切な応答（新しいプロトコルで定義）を使用してHTTP / 2.0に切り替わります。 「GET /hello.txt」リクエスト...]アップグレードが送信されるとき、送信者は接続ヘッダーフィールド（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）には、「アップグレード」接続オプションが含まれています。これは、リストされているプロトコルを実装していない可能性のある仲介者によって誤ってアップグレードが転送されるのを防ぐためです。サーバーは、HTTP / 1.0リクエストで受信したUpgradeヘッダーフィールドを無視する必要があります。クライアントは、要求メッセージを完全に送信するまで、接続でアップグレードされたプロトコルの使用を開始できません（つまり、クライアントは、メッセージの途中で送信しているプロトコルを変更できません）。サーバーが &quot;100-continue&quot;期待値（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;[RFC7231]のセクション5.1.1）で&lt;/a&gt; UpgradeおよびExpectヘッダーフィールドの両方を受信した場合）、サーバーは101（スイッチングプロトコル）応答を送信する前に100（続行）応答を送信する必要があります。 Upgradeヘッダーフィールドは、既存の接続上のスイッチングプロトコルにのみ適用されます。基になる接続（トランスポート）プロトコルの切り替えや、既存の通信の別の接続への切り替えには使用できません。そのためには、3xx（リダイレクト）応答を使用する方が適切です（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;[RFC7231]のセクション6.4&lt;/a&gt;）。この仕様では、&lt;a href=&quot;#section-2.6&quot;&gt;セクション2.6の&lt;/a&gt; HTTPバージョンルールとこの仕様の将来の更新で定義されているように、ハイパーテキスト転送プロトコルのファミリで使用するプロトコル名「HTTP」のみを定義しています。追加のトークンは、で定義された登録手順を使用してIANAに登録する必要があります。&lt;a href=&quot;#section-8.6&quot;&gt;セクション8.6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">&quot;User-Agent&quot;ヘッダーフィールドには、リクエストを発信したユーザーエージェントに関する情報が含まれます。これは、サーバーによって報告された相互運用性の問題の範囲の特定、特定のユーザーエージェントの制限を回避するための応答の回避または調整、および分析のためによく使用されます。ブラウザまたはオペレーティングシステムの使用に関して。ユーザーエージェントは、特に設定しない限り、各リクエストでUser-Agentフィールドを送信する必要があります（SHOULD）。User-Agent = product *（RWS（product / comment））User-Agentフィールド値は、1つ以上の製品識別子で構成され、それぞれに0個以上のコメントが続きます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2）&lt;/a&gt;）、ユーザーエージェントソフトウェアとその重要なサブ製品をまとめて識別します。慣例により、製品識別子は、ユーザーエージェントソフトウェアを識別するための重要度の降順でリストされています。各製品IDは、名前とオプションのバージョンで構成されています。 product = token [&quot;/&quot; product-version] product-version = token送信者は、生成された製品識別子を製品を識別するために必要なものに制限する必要があります（SHOULD）。送信者は、製品識別子内に広告またはその他の重要でない情報を生成してはいけません。送信者は、バージョン識別子ではない製品バージョンで情報を生成してはなりません（つまり、同じ製品名の連続するバージョンは、製品識別子の製品バージョン部分のみが異なる必要があります）。例：ユーザーエージェント：CERN-LineMode / 2.15 libwww / 2.17b3ユーザーエージェントは、不必要に細かい詳細を含むユーザーエージェントフィールドを生成してはならず（SHOULD NOT）、サードパーティによるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なUser-Agentフィールド値は、リクエストのレイテンシを増加させ、ユーザーが希望に反して識別されるリスク（「フィンガープリント」）を引き起こします。同様に、実装は、他の実装との互換性を宣言するために他の実装の製品トークンを使用しないことをお勧めします。これにより、フィールドの目的が回避されます。ユーザーエージェントが別のユーザーエージェントになりすましている場合、受信者は、実際に使用されているユーザーエージェントに対してうまく機能しない場合でも、ユーザーが意図的に、その識別されたユーザーエージェントに合わせた応答を表示したいと思っていると想定できます。CERN-LineMode / 2.15 libwww / 2.17b3ユーザーエージェントは、不必要に細かい詳細を含むユーザーエージェントフィールドを生成してはならず（SHOULD NOT）、サードパーティによるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なUser-Agentフィールド値は、リクエストのレイテンシを増加させ、ユーザーが希望に反して識別されるリスク（「フィンガープリント」）を引き起こします。同様に、実装は、他の実装との互換性を宣言するために他の実装の製品トークンを使用しないことをお勧めします。これにより、フィールドの目的が回避されます。ユーザーエージェントが別のユーザーエージェントになりすましている場合、受信者は、実際に使用されているユーザーエージェントに対してうまく機能しない場合でも、ユーザーが意図的に、その識別されたユーザーエージェントに合わせた応答を表示したいと思っていると想定できます。CERN-LineMode / 2.15 libwww / 2.17b3ユーザーエージェントは、不必要に細かい詳細を含むユーザーエージェントフィールドを生成してはならず（SHOULD NOT）、サードパーティによるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なUser-Agentフィールド値は、リクエストのレイテンシを増加させ、ユーザーが希望に反して識別されるリスク（「フィンガープリント」）を引き起こします。同様に、実装は、他の実装との互換性を宣言するために他の実装の製品トークンを使用しないことをお勧めします。これにより、フィールドの目的が回避されます。ユーザーエージェントが別のユーザーエージェントになりすましている場合、受信者は、実際に使用されているユーザーエージェントに対してうまく機能しない場合でも、ユーザーが意図的に、その識別されたユーザーエージェントに合わせた応答を表示したいと思っていると想定できます。17b3ユーザーエージェントは、不必要に細かい詳細を含むユーザーエージェントフィールドを生成してはならず（SHOULD NOT）、サードパーティによるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なUser-Agentフィールド値は、リクエストのレイテンシを増加させ、ユーザーが希望に反して識別されるリスク（「フィンガープリント」）を引き起こします。同様に、実装は、他の実装との互換性を宣言するために他の実装の製品トークンを使用しないことをお勧めします。これにより、フィールドの目的が回避されます。ユーザーエージェントが別のユーザーエージェントになりすましている場合、受信者は、実際に使用されているユーザーエージェントに対してうまく機能しない場合でも、ユーザーが意図的に、その識別されたユーザーエージェントに合わせた応答を表示したいと思っていると想定できます。17b3ユーザーエージェントは、不必要に細かい詳細を含むユーザーエージェントフィールドを生成してはならず（SHOULD NOT）、サードパーティによるサブプロダクトの追加を制限する必要があります（SHOULD）。過度に長く詳細なUser-Agentフィールド値は、リクエストのレイテンシを増加させ、ユーザーが希望に反して識別されるリスク（「フィンガープリント」）を引き起こします。同様に、実装は、他の実装との互換性を宣言するために他の実装の製品トークンを使用しないことをお勧めします。これにより、フィールドの目的が回避されます。ユーザーエージェントが別のユーザーエージェントになりすましている場合、受信者は、実際に使用されているユーザーエージェントに対してうまく機能しない場合でも、ユーザーが意図的に、その識別されたユーザーエージェントに合わせた応答を表示したいと思っていると想定できます。</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">応答の &quot;Vary&quot;ヘッダーフィールドは、メソッド、Hostヘッダーフィールド、および要求ターゲットを除いて、要求メッセージのどの部分が、この応答を選択して表すための起点サーバーのプロセスに影響を与える可能性があるかを示します。値は、単一のアスタリスク（ &quot;*&quot;）またはヘッダーフィールド名のリスト（大文字と小文字を区別しない）で構成されます。 Vary = &quot;*&quot; / 1＃field-name &quot;*&quot;のVaryフィールド値は、リクエストに関するあらゆるものが、メッセージ構文の外の要素（クライアントのネットワークアドレスなど）を含む可能性がある応答表現の選択に役割を果たす可能性があることを示します。受信者は、要求をオリジンサーバーに転送しないと、この応答が後の要求に適しているかどうかを判断できません。プロキシは、「*」値を持つVaryフィールドを生成してはなりません（MUST NOT）。名前のコンマ区切りリストで構成されるVaryフィールド値は、選択ヘッダーフィールドと呼ばれる名前付きリクエストヘッダーフィールドが、表現の選択に役割を果たす可能性があることを示します。潜在的な選択ヘッダーフィールドは、この仕様で定義されているフィールドに限定されません。たとえば、Vary：accept-encoding、accept-languageを含むレスポンスは、オリジンサーバーがリクエストのAccept-EncodingフィールドとAccept-Languageフィールド（またはその欠如）を、このレスポンスのコンテンツを選択する際の決定要因として使用した可能性があることを示します。オリジンサーバーは、2つの目的でフィールドのリストを含むVaryを送信する場合があります.1。キャッシュ受信者に、後のリクエストにリストされたフィールドの元のリクエストと同じ値がない限り、後のリクエストを満たすためにこの応答を使用してはならないことを通知するには（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;[RFC7234]のセクション4.1&lt;/a&gt;）。つまり、Varyは、新しい要求を格納されたキャッシュエントリに一致させるために必要なキャッシュキーを拡張します。 2.この応答がコンテンツネゴシエーションの対象であることをユーザーエージェントの受信者に通知する（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）、リストされたヘッダーフィールドに追加のパラメータが提供されている場合（プロアクティブネゴシエーション）、後続のリクエストで異なる表現が送信される可能性があることを確認します。分散を越えられないか、キャッシュの透過性を防ぐようにオリジンサーバーが意図的に構成されていない限り、表現を選択するアルゴリズムがメソッドとリクエストターゲット以外のリクエストメッセージの側面に基づいて変化する場合、オリジンサーバーはVaryヘッダーフィールドを送信する必要があります（SHOULD）。 。たとえば、ユーザー間での再利用はフィールド定義によって制約されるため（&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]のセクション4.2&lt;/a&gt;）、VaryでAuthorizationフィールド名を送信する必要はありません。同様に、オリジンサーバーはCache-Controlディレクティブを使用する場合があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2）。&lt;/a&gt;）Varyがキャッシングに及ぼす影響のパフォーマンスコストよりも分散の重要性が低いと見なされる場合は、Varyに取って代わる。</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">&quot;Via&quot;ヘッダーフィールドは、電子メールの &quot;Received&quot;ヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;セクション&lt;/a&gt;）と同様に、ユーザーエージェントとサーバーの間（要求時）、または起点サーバーとクライアントの間（応答時）の中間プロトコルと受信者の存在を示します。[RFC5322]の3.6.7）。viaは、メッセージ転送の追跡、要求ループの回避、および要求/応答チェーンに沿った送信者のプロトコル機能の識別に使用できます。Via = 1＃（received-protocol RWS received-by [RWS comment]）received-protocol = [protocol-name &quot;/&quot;] protocol-version; &lt;a href=&quot;#section-6.7&quot;&gt;セクション6.7を&lt;/a&gt;参照 received-by =（uri-host [&quot;：&quot; port]）/ pseudonym pseudonym = token複数のViaフィールド値は、メッセージを転送した各プロキシまたはゲートウェイを表します。各中間者はメッセージの受信方法に関する独自の情報を追加し、最終的な結果は転送する受信者のシーケンスに従って順序付けられます。プロキシは、転送する各メッセージで、以下に説明するように、適切なViaヘッダーフィールドを送信する必要があります。 HTTP-to-HTTPゲートウェイは、各インバウンド要求メッセージで適切なViaヘッダーフィールドを送信しなければならず、転送された応答メッセージでViaヘッダーフィールドを送信してもよい（MAY）。中間体ごとに、received-protocolは、メッセージのアップストリーム送信者が使用したプロトコルとプロトコルバージョンを示します。したがって、Viaフィールド値は、要求/応答チェーンのアドバタイズされたプロトコル機能を記録し、ダウンストリームの受信者から見える状態を維持します。これは、後方互換性のない機能が応答で、または後の要求内で安全に使用できるかどうかを判断するのに役立ちます。&lt;a href=&quot;#section-2.6&quot;&gt;セクション2.6&lt;/a&gt;。簡潔にするために、受信したプロトコルがHTTPの場合、プロトコル名は省略されます。フィールド値のreceived-byの部分は通常、その後メッセージを転送した受信側サーバーまたはクライアントのホストおよびオプションのポート番号です。ただし、実際のホストが機密情報であると見なされる場合、送信者はそれを仮名に置き換えることができます（MAY）。ポートが提供されていない場合、受信者は、それが受信されたプロトコルのデフォルトのTCPポート（ある場合）で受信されたことを意味すると解釈してもよい（MAY）。送信者は、User-AgentおよびServerヘッダーフィールドと同様に、Viaヘッダーフィールドにコメントを生成して、各受信者のソフトウェアを識別できます。ただし、[経由]フィールドのすべてのコメントはオプションであり、受信者はメッセージを転送する前にコメントを削除できます（MAY）。例えば、要求メッセージは、HTTP / 1.0ユーザーエージェントから、コード名が「fred」である内部プロキシに送信できます。これは、HTTP / 1.1を使用して、要求をp.example.netのパブリックプロキシに転送し、転送によって要求を完了します。 www.example.comのオリジンサーバーに送信します。 www.example.comが受信したリクエストには、次のViaヘッダーフィールドがあります。Via：1.0 fred、1.1 p.example.netネットワークファイアウォールを介してポータルとして使用される仲介者は、ホスト内のホストの名前とポートを転送してはなりません（SHOULD NOT）明示的に有効にしない限り、ファイアウォールリージョン。有効化されていない場合、そのような中間のSHOULDは、ファイアウォールの背後にある任意のホストの各受信ホストを、そのホストの適切な仮名に置き換える必要があります（SHOULD）。エントリが同一の受信プロトコル値を持っている場合、仲介者は、Viaヘッダーフィールドエントリの順序付けられたサブシーケンスを単一のそのようなエントリに結合してもよい（MAY）。たとえば、Via：1.0 ricky、1.1 ethel、1.1 fred、1.0 lucyはVia：1.0 ricky、1.1 mertz、1.0 lucyに折りたたむことができます。送信者は、すべてが同じ組織の制御下にあり、ホストがすでに仮名に置き換えられています。送信者は、異なる受信プロトコル値を持つエントリを組み合わせてはなりません（MUST NOT）。0 lucy送信者は、すべてが同じ組織の制御下にあり、ホストが仮名に既に置き換えられていない限り、複数のエントリを結合するべきではありません（SHOULD NOT）。送信者は、異なる受信プロトコル値を持つエントリを組み合わせてはなりません（MUST NOT）。0 lucy送信者は、すべてが同じ組織の制御下にあり、ホストが仮名に既に置き換えられていない限り、複数のエントリを結合するべきではありません（SHOULD NOT）。送信者は、異なる受信プロトコル値を持つエントリを組み合わせてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">WWW-Authenticate」ヘッダーフィールドは、ターゲットリソースに適用される認証スキームとパラメータを示す。WWW-Authenticate=1#challenge 401(Unauthorized)応答を生成するサーバーは、少なくとも1つのチャレンジを含むWWW-Authenticateヘッダー フィールドを送らなければならない[MUST]。サーバは、信用証明書(または異なる信用証明書)の供給が応答に影響を与える可能性があることを 示すために、他の応答メッセージ中にWWW-Authenticateヘッダーフィールドを生成してもよい[MAY]。応答を転送するプロキシは、その応答中のいかなるWWW-Authenticate フィールドも修正してはならない[MUST NOT]。ユーザーエージェントは、フィールド値を解析する際に特別な注意を払うように アドバイスされる。なぜなら、フィールド値は複数のチャレンジを含むかもしれないし、 各チャレンジはカンマで区切られた認証パラメータのリストを含むことが できるからである。さらに、ヘッダフィールド自体が複数回出現する可能性がある。例えば、以下のようになります。WWW-Authenticate.1つは、realm値が「apps」で、2つの追加パラメータ「type」と「title」を持つ「Newauth」スキーム用のもので、もう1つはrealm値が「simple」である「Basic」スキーム用のものである。注:チャレンジ文法の制作では、リスト構文も使用しています。したがって、カンマ、空白、カンマの連続は、先行する課題に適用されるか、課題リストの空の項目であるとみなすことができる。実際には、この曖昧さはヘッダフィールド値のセマンティクスに影響を与えないので、無害です。</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">「警告」ヘッダーフィールドは、ステータスコードに反映されない可能性があるメッセージのステータスまたは変換に関する追加情報を伝えるために使用されます。この情報は通常、メッセージのペイロードに適用されるキャッシング操作または変換によって導入される可能性のある不正確さについて警告するために使用されます。警告は、キャッシュ関連とそれ以外の両方の目的で使用できます。エラーステータスコードではなく警告を使用することで、これらの応答を実際の障害と区別します。警告ヘッダーフィールドは一般にどのメッセージにも適用できますが、一部の警告コードはキャッシュに固有であり、応答メッセージにのみ適用できます。警告= 1＃warning-value警告値= warn-code SP warn-agent SP warn-text [SP warn-date] warn-code = 3DIGIT warn-agent =（uri-host [&quot;：&quot; port]）/ pseudonym ;追加するサーバーの名前または仮名。デバッグで使用する警告ヘッダーフィールド。エージェントが不明な場合は、単一の「-」が推奨されますwarn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE複数の警告が（オリジンサーバーまたはキャッシュのいずれかによって）応答で生成されます。 warn-textのみが異なる同じwarn-code番号。 1つ以上の警告ヘッダーフィールドを受け取るユーザーエージェントは、それらをできるだけ多くユーザーに通知する必要があります。応答に現れる順序で。複数の警告ヘッダーフィールドを生成する送信者は、このユーザーエージェントの動作を考慮してそれらを注文することをお勧めします。新しい警告ヘッダーフィールドを生成する送信者は、既存の警告ヘッダーフィールドの後にそれらを追加する必要があります。警告には3桁の警告コードが割り当てられています。最初の数字は、検証後に保存された応答から警告を削除する必要があるかどうかを示します。o 1xx warn-codesは、応答の鮮度または検証ステータスを記述します。したがって、検証後にキャッシュによって削除する必要があります。これらは、キャッシュされたエントリを検証するときにのみキャッシュによって生成でき、他の状況では生成してはいけません。o 2xx warn-codesは、検証によって修正されない表現のいくつかの側面（たとえば、表現の不可逆圧縮）を記述し、完全な応答が送信されない限り、検証後にキャッシュによって削除されてはなりません（MUST）。場合があります。送信者がHTTP / 1.0のみを実装することがわかっている受信者に送信されるメッセージに1つ以上の1xx警告コードを生成する場合、送信者は、対応する各警告値に、日付ヘッダーフィールドに一致する警告日付を含める必要があります。メッセージ。例：HTTP / 1.1 200 OK日付：2012年8月25日土曜日23:34:45 GMT警告：112-「ネットワークダウン」「2012年8月25日土曜日23:34:45 GMT」警告には、ロギングなどのエラー。これは助言のみです。また、その内容は警告コードの解釈には影響しません。 Warningヘッダーフィールドを使用、評価、または表示する受信者が同じメッセージの日付値とは異なるwarn-dateを受け取った場合、受信者は、保存、転送、または使用する前に、そのwarn-dateを含む警告値を除外する必要があります。メッセージ。これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、Warningヘッダーフィールドを使用、評価、または表示する受信者が同じメッセージの日付値とは異なるwarn-dateを受け取った場合、受信者は、保存、転送、または使用する前に、そのwarn-dateを含む警告値を除外する必要があります。メッセージ。これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、Warningヘッダーフィールドを使用、評価、または表示する受信者が同じメッセージの日付値とは異なるwarn-dateを受け取った場合、受信者は、保存、転送、または使用する前に、そのwarn-dateを含む警告値を除外する必要があります。メッセージ。これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、または、警告ヘッダーフィールドが同じメッセージの日付値とは異なる警告日付を受け取った場合、受信者は、メッセージを保存、転送、または使用する前に、その警告日付を含む警告値を除外する必要があります。これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、または、警告ヘッダーフィールドが同じメッセージの日付値とは異なる警告日付を受け取った場合、受信者は、メッセージを保存、転送、または使用する前に、その警告日付を含む警告値を除外する必要があります。これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、これにより、受信者は、キャッシュの検証後に不適切に保持された警告値を除外できます。すべての警告値を除外する場合、受信者は警告ヘッダーフィールドも除外する必要があります。次の警告コードはこの仕様で定義されており、それぞれに推奨される英語の警告テキストとその意味の説明があります。追加の警告コードを定義する手順は、 &lt;a href=&quot;#section-7.2.1&quot;&gt;セクション7.2.1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">「app：categories」要素は、コレクションのメンバーに適用できるカテゴリのリストを提供します。app：categoriesの詳細な定義については、&lt;a href=&quot;#section-7.2.1&quot;&gt;セクション7.2.1&lt;/a&gt;を参照してください。サーバーは、カテゴリーがそのカテゴリー・リストに存在しないメンバーを作成または保管する試みを拒否してもよい（MAY）。カテゴリセットが開いていることを示すコレクションは、カテゴリリストにないカテゴリの受け入れ可能なメンバーを拒否しないでください。app：categories要素がないことは、コレクションのカテゴリ処理が指定されていないことを意味します。カテゴリが0の「固定」カテゴリリストは、コレクションがカテゴリデータを受け入れないことを示します。</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">「app：collection」要素はコレクションを記述します。 app：コレクション要素には、1つのatom：title要素を含める必要があります。 app：collection要素には、任意の数のapp：accept要素を含めることができます。これは、コレクションが受け入れる表現のタイプを示します。そのような要素の順序は重要ではありません。 app：collection要素には、任意の数のapp：categories要素を含めることができます。 appCollection = element app：collection {appCommonAttributes、attribute href {atomURI}、（atomTitle＆appAccept *＆appCategories *＆extensionSansTitleElement *）}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">「app：edited」要素は（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]で定義されている）日付構成要素であり、その内容はエントリが最後に編集された時刻を示します。エントリがまだ編集されていない場合、コンテンツは作成された時刻を示します。コレクションドキュメントのAtom Entry要素には1つのapp：edited要素を含める必要があり、複数を含めることはできません。appEdited = element app：edited（atomDateConstruct）サーバーは、エントリリソースまたは関連するメディアリソースが編集されるたびに、この要素の値を変更する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">&quot;atom：title&quot;要素は[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]で定義され、人間が読めるコレクションのタイトルを提供します。</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">&quot;compress&quot;コーディングは、UNIXファイル圧縮プログラム &quot;compress&quot;によって一般的に生成される適応型Lempel-Ziv-Welch（LZW）コーディング[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ]です。受信者は、「x-compress」を「compress」と同等であると見なすべきです。</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">データ」のURLスキーム</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">「deflate」コーディングは、Lempel-Ziv（LZ77）圧縮アルゴリズムとハフマンコーディングの組み合わせを使用する「deflate」圧縮データストリーム[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]を含む「zlib」データフォーマット[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ] です。注：一部の非準拠の実装は、zlibラッパーなしで「deflate」圧縮データを送信します。</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">「gzip」コーディングは、32ビットの巡回冗長検査（CRC）を備えたLZ77コーディングであり、gzipファイル圧縮プログラム[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] によって一般的に生成されます。受信者は、「x-gzip」を「gzip」と同等であると見なすべきです。</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">「http」URIスキームは、特定のポートでTCP（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt; ]）接続をリッスンする潜在的なHTTPオリジンサーバーによって管理される階層的な名前空間との関連付けに従って識別子を作成する目的で定義されています。 http-URI = &quot;http：&quot; &quot;//&quot; Authority path-abempty [&quot;？&quot; query] [&quot;＃&quot;フラグメント] &quot;http&quot; URIのオリジンサーバーは、ホスト識別子とオプションのTCPポートを含む機関コンポーネントによって識別されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]、セクション3.2.2&lt;/a&gt;）。階層パスコンポーネントとオプションのクエリコンポーネントは、そのオリジンサーバーの名前空間内の潜在的なターゲットリソースの識別子として機能します。オプションのフラグメントコンポーネントを使用すると&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;、[RFC3986]のセクション3.5で&lt;/a&gt;定義されているように、URIスキームに関係なく、セカンダリリソースを間接的に識別できます。。送信者は、ホスト識別子が空の &quot;http&quot; URIを生成してはなりません（MUST NOT）。このようなURI参照を処理する受信者は、それを無効として拒否する必要があります。ホストIDがIPアドレスとして提供されている場合、オリジンサーバーは、そのIPアドレスで示されたTCPポートのリスナー（存在する場合）です。ホストが登録名である場合、登録名は、DNSなどの名前解決サービスでそのオリジンサーバーのアドレスを検索するために使用する間接的な識別子です。ポートサブコンポーネントが空または指定されていない場合、TCPポート80（WWWサービス用に予約されているポート）がデフォルトです。特定の権限コンポーネントを持つURIの存在は、そのホストとポートで接続をリッスンしているHTTPサーバーが常に存在することを意味するわけではないことに注意してください。誰でもURIを作成できます。権限コンポーネントが決定するのは、識別されたリソースを対象とする要求に正式に応答する権利を持つ人です。登録された名前とIPアドレスの委任された性質により、HTTPサーバーが存在するかどうかに関係なく、指定されたホストとポートの制御に基づいてフェデレーテッドネームスペースが作成されます。見る&lt;a href=&quot;#section-9.1&quot;&gt;&lt;/a&gt;権限の確立に関連するセキュリティの考慮事項については、セクション9.1。指定されたリソースへのアクセスを要求するコンテキスト内で「http」URIが使用される場合、クライアントはホストをIPアドレスに解決し、指定されたポートでそのアドレスへのTCP接続を確立し、HTTPを送信することでアクセスを試行できます（MAY）。サーバーへのURIの識別データ（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）を含む要求メッセージ（&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）。&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]のセクション6で&lt;/a&gt;説明されているように、サーバーがその要求に非中間HTTP応答メッセージで応答する場合の場合、その応答はクライアントの要求に対する信頼できる応答と見なされます。 HTTPはトランスポートプロトコルから独立していますが、名前の委任プロセスは権限を確立するためにTCPに依存するため、「http」スキームはTCPベースのサービスに固有です。エンドツーエンドのセキュリティで保護された接続を必要とするリソースに「https」スキーム（以下）が使用されるのと同じように、他の基本的な接続プロトコルに基づくHTTPサービスは、おそらく別のURIスキームを使用して識別されます。 「http」で識別されたリソースへのアクセスを提供するために、他のプロトコルも使用される場合があります。TCPに固有ののは、信頼できるインターフェイスのみです。権限のURI汎用構文には、非推奨のuserinfoサブコンポーネントも含まれています（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986]、セクション3.2。1&lt;/a&gt;）URIにユーザー認証情報を含めるため。一部の実装では、コマンド呼び出しオプション、構成ファイル、ブックマークリスト内などの認証情報の内部構成にuserinfoコンポーネントを使用しますが、そのような使用法ではユーザー識別子またはパスワードが公開される可能性があります。メッセージ内で「http」URI参照が要求ターゲットまたはヘッダーフィールド値として生成される場合、送信者はuserinfoサブコンポーネント（およびその「@」区切り文字）を生成してはなりません（MUST NOT）。信頼できないソースから受け取った「http」URI参照を利用する前に、受信者はuserinfoを解析して、その存在をエラーとして扱う必要があります（SHOULD）。フィッシング攻撃のために権限を隠すために使用されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">「http」スキームは、HTTPプロトコルを介してネットワークリソースを見つけるために使用されます。このセクションでは、http URLのスキーマ固有の構文とセマンティクスを定義します。 http_URL = &quot;http：&quot; &quot;//&quot; host [&quot;：&quot; port] [abs_path [&quot;？&quot; query]]ポートが空または指定されていない場合、ポート80が想定されます。意味は、識別されたリソースがそのホストのそのポートでTCP接続をリッスンしているサーバーにあり、リソースのRequest-URIがabs_pathであるということです（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）。 URLでのIPアドレスの使用は、可能な限り避けてください（&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ]を参照）。 abs_pathがURLに存在しない場合、リソースのRequest-URIとして使用する場合は「/」として指定する必要があります（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1。2&lt;/a&gt;）。プロキシが完全修飾ドメイン名ではないホスト名を受け取った場合、受け取ったホスト名にそのドメインを追加してもよい（MAY）。プロキシが完全修飾ドメイン名を受け取った場合、プロキシはホスト名を変更してはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">「https」URIスキームは、TLSで保護された接続用の特定のTCPポートをリッスンする潜在的なHTTPオリジンサーバーによって管理される階層的な名前空間との関連付けに従って識別子を作成する目的で定義されています（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]）。上記の「http」スキームのすべての要件は、「https」スキームの要件でもあります。ただし、ポートサブコンポーネントが空であるか指定されていない場合、TCPポート443がデフォルトであり、ユーザーエージェントは、元のサーバーは、最初のHTTPリクエストを送信する前に、エンドツーエンドで強力な暗号化を使用して保護されます。 https-URI = &quot;https：&quot; &quot;//&quot; Authority path-abempty [&quot;？&quot; query] [&quot;＃&quot; fragment] &quot;https&quot; URIスキームは、権限を確立するためにTLSとTCPの両方に依存することに注意してください。 「https」スキームを介して利用可能にされたリソースには、「http」との共有IDがありませんそれらのリソース識別子が同じ権限を示す場合でも同じスキーム（同じTCPポートをリッスンする同じホスト）。それらは別個の名前空間であり、別個の起点サーバーと見なされます。ただし、Cookieプロトコルなど、ホストドメイン全体に適用するように定義されているHTTPの拡張[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]は、1つのサービスによって設定された情報が、ホストドメインの一致するグループ内の他のサービスとの通信に影響を与えることを可能にします。「https」で識別されたリソースへの権限のあるアクセスのプロセスは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]で定義されています。</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">must-revalidate&quot; レスポンスディレクティブは、一度陳腐化してしまうと、キャッシュはオリジンサーバでの検証が成功しない限り、後続のリクエストを満たすために レスポンスを使用してはならない[MUST NOT]ことを示しています。must-revalidate ディレクティブは特定のプロトコル機能のための信頼性の高い動作をサポートするために必要です。どのような状況でもキャッシュは must-revalidate ディレクティブに従わなければなりません[MUST]。特に、キャッシュが何らかの理由でオリジンサーバに到達できない場合、504 (Gateway Timeout)レスポンスを生成しなければなりません[MUST]。must-revalidate ディレクティブは、表現上のリクエストの検証に失敗した場合に、 沈黙して実行されない金融トランザクションのような不正な操作になる可能性がある場合にのみ、 サーバによって使用されるべきです。</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">no-cache&quot; リクエストディレクティブは、キャッシュがオリジンサーバでの検証が成功しない限り、 リクエストを満たすために保存された応答を使ってはならない[MUST NOT]ことを示します。</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">no-store&quot; リクエストディレクティブは、キャッシュがこのリクエストやレスポンスのいかなる部分も保存してはならない (MUST NOT)ことを示します。このディレクティブはプライベートキャッシュと共有キャッシュの両方に適用されます。この文脈での &quot;MUST NOT store&quot; は、キャッシュが意図的に情報を不揮発性ストレージに保存してはならず[MUST NOT]、情報を転送した後に可能な限り速やかに揮発性ストレージから情報を削除するように最善の努力をしなければならない[MUST]ことを意味します。このディレクティブはプライバシーを確保するための信頼できる十分なメカニズムではありません。特に、悪意のあるキャッシュや危殆化したキャッシュはこのディレクティブを認識したり、 従ったりしないかもしれませんし、通信ネットワークは盗聴されやすいかもしれません。このディレクティブを含むリクエストがキャッシュから満たされた場合、既に保存されているレスポンスには no-store リクエストディレクティブは適用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">no-store&quot; レスポンスディレクティブは、キャッシュが即時のリクエストやレスポンスのいかなる部分も保存してはならない (MUST NOT)ことを示します。このディレクティブはプライベートキャッシュと共有キャッシュの両方に適用されます。この文脈での &quot;MUST NOT store&quot; は、キャッシュが意図的に情報を不揮発性のストレージに保存してはならず[MUST NOT]、情報を転送した後に可能な限り速やかに揮発性のストレージから情報を削除するように最善の努力をしなければならない[MUST]ことを意味します。このディレクティブはプライバシーを確保するための信頼できる十分なメカニズムではありません。特に、悪意のあるキャッシュや危殆化したキャッシュはこのディレクティブを認識したり、 従ったりしないかもしれませんし、通信ネットワークは盗聴に対して脆弱かもしれません。</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">[no-transform]リクエストディレクティブは&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;、[RFC7230]のセクション5.7.2で&lt;/a&gt;定義されているように、中間（キャッシュを実装しているかどうかにかかわらず）がペイロードを変換してはならないことを示します。</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">[no-transform]応答ディレクティブは&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;、[RFC7230]のセクション5.7.2で&lt;/a&gt;定義されているように、中間（キャッシュを実装しているかどうかに関係なく）がペイロードを変換してはならないことを示します。</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">only-if-cached&quot; リクエストディレクティブは、クライアントが保存された応答の取得のみを 望んでいることを示します。このディレクティブを受信した場合、キャッシュはリクエストの他の制約と一致する保存された応答を使用して応答するか、504(Gateway Timeout)ステータスコードで応答するべきである[SHOULD]。キャッシュのグループが内部接続性の良い統一されたシステムとして運営されている場合、メンバーキャッシュはそのグループ内でそのようなリクエストを転送してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">proxy-revalidate&quot; レスポンスディレクティブは、プライベートキャッシュには適用されないことを除けば、 must-revalidate レスポンスディレクティブと同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="f75c67cbc215fa2c33b29aa7195f38b3d21101a2" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful if pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">public&quot; ディレクティブは、レスポンスがどのキャッシュでもキャッシュされることを 示します。これは、HTTP 認証のあるページや、通常はキャッシュできない レスポンスのステータスコードをキャッシュしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">public&quot; ディレクティブは、レスポンスがどのキャッシュでもキャッシュされることを 示します。これは、通常はキャッシュできない HTTP 認証やレスポンスのステータスコードを持つページが キャッシュされるようになった場合に便利です。</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">&quot;public&quot;応答ディレクティブは、応答が通常はキャッシュ不可またはプライベートキャッシュ内でのみキャッシュ可能であっても、キャッシュが応答を格納してもよいことを示します。 （承認を含むリクエストに対するパブリックの使用に関する追加の詳細については&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;を参照し、ステータスコードがデフォルトでキャッシュ可能として定義されていないために通常は保存されないレスポンスにパブリックがどのように影響するかの詳細については&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;を参照してください; &lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2を&lt;/a&gt;参照してください 。）</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">「レルム」認証パラメータは、保護の範囲を示したい認証スキームで使用するために予約されています。保護スペースは、正規のルートURI（有効な要求URIのスキームおよび権限コンポーネント）によって定義されます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;セクション&lt;/a&gt;5.5を参照してください）アクセスされているサーバーの、存在する場合はレルム値と組み合わせて。これらのレルムを使用すると、サーバー上の保護されたリソースを、それぞれ独自の認証スキームや承認データベースを持つ一連の保護スペースに分割できます。レルム値は文字列であり、通常はオリジンサーバーによって割り当てられ、認証スキームに固有の追加のセマンティクスを持つことができます。応答には、同じauth-schemeで異なるレルムを持つ複数のチャレンジが含まれる可能性があることに注意してください。保護スペースは、資格情報を自動的に適用できるドメインを決定します。以前のリクエストが承認されている場合、ユーザーエージェントは、認証スキーム、パラメーター、および/またはユーザー設定（構成可能な無活動タイムアウトなど）。認証スキームで特に許可されていない限り、単一の保護スペースがサーバーの範囲外に拡張することはできません。歴史的な理由により、送信者は引用文字列構文のみを生成する必要があります。受信者は、長い間両方の表記法を受け入れてきた既存のクライアントとの相互運用性を最大にするために、トークンと引用符付き文字列の両方の構文をサポートする必要がある場合があります。受信者は、長い間両方の表記法を受け入れてきた既存のクライアントとの相互運用性を最大にするために、トークンと引用符付き文字列の両方の構文をサポートする必要がある場合があります。受信者は、長い間両方の表記法を受け入れてきた既存のクライアントとの相互運用性を最大にするために、トークンと引用符付き文字列の両方の構文をサポートする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">基本的な」HTTP認証スキーム</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">'opaquelocktoken' URIスキームは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]で定義され（IANAによって登録されました）、UUIDから構文的に正しく簡単に生成できるURIを作成します。これは、ロックトークンとして使用し、いつも。 opaquelocktoken URIは、「opaquelocktoken」スキームをUUIDとオプションの拡張子とともに連結することによって構築されます。サーバーは、新しいロックトークンごとに新しいUUIDを作成できます。サーバーがUUIDの再利用を希望する場合、サーバーは拡張を追加する必要があり、拡張を生成するアルゴリズムは、同じ拡張が関連付けられたUUIDで2回使用されないことを保証する必要があります。 OpaqueLockToken-URI = &quot;opaquelocktoken：&quot; UUID [拡張]; UUIDは&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;[RFC4122]のセクション3で&lt;/a&gt;定義されています。 LWSに注意してください。の要素間では許可されません。この生産。拡張子=パス;パスは&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]のセクション3.3で&lt;/a&gt;定義されています</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">100（続行）ステータスコードは、リクエストの最初の部分が受信され、サーバーによってまだ拒否されていないことを示します。サーバーは、リクエストが完全に受信されて処理された後に最終応答を送信する予定です。リクエストに100-continue期待値を含むExpectヘッダーフィールドが含まれている場合、&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1で&lt;/a&gt;説明されているように、100応答はサーバーがリクエストペイロードの本文の受信を希望していることを示します 。クライアントはリクエストの送信を続行し、100応答を破棄する必要があります。リクエストに100-continue期待値を含むExpectヘッダーフィールドが含まれていない場合、クライアントはこの暫定応答を単に破棄できます。</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">101（Switching Protocols）ステータスコードは、この接続で使用されているアプリケーションプロトコルの変更について、サーバーがUpgradeヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]のSection 6.7）を&lt;/a&gt;介してクライアントの要求を理解し、クライアントの要求に応じる意思があることを示します。サーバーは、101応答を終了する空の行の直後にどのプロトコルに切り替えるかを示す応答にUpgradeヘッダーフィールドを生成する必要があります。サーバーは、プロトコルの切り替えが有利な場合にのみプロトコルの切り替えに同意するものと想定されています。たとえば、HTTPの新しいバージョンへの切り替えは古いバージョンよりも有利であり、リアルタイムの同期プロトコルへの切り替えは、そのような機能を使用するリソースを配信する場合に有利です。</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101のステータスコード</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">ステータスコードの1xx(Informational)クラスは、リクエストされたアクションを完了して最終応答を送信する前に、接続ステータスまたはリクエストの進行状況を伝えるための暫定応答を示す。1xx レスポンスは、ステータス行の後の最初の空行 (ヘッダセクションの終了を示す空行)で終了します。HTTP/1.0は1xxステータスコードを定義しなかったので、サーバーはHTTP/1.0クライアントに1xx応答を送ってはならない[MUST NOT]。クライアントは、たとえクライアントが1つを期待していなくても、最終応答の前に 受け取った1つ以上の1xx応答を解析できなければならない[MUST]。ユーザーエージェントは予期しない1xx応答を無視してもよい[MAY]。プロキシは、プロキシ自身が1xx応答の生成をリクエストしない限り、 1xx応答を転送しなければならない[MUST]。例えば、プロキシがリクエストを転送(forward)するときに「Expect:100-continue」フィールドを追加する場合、プロキシは対応する100(Continue)応答を 転送(forward)する必要はない。</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">200（OK）ステータスコードは、リクエストが成功したことを示します。 200応答で送信されるペイロードは、要求メソッドによって異なります。この仕様で定義されているメソッドの場合、ペイロードの意図する意味は次のように要約できます。ターゲットリソースの表現を取得します。 HEADはGETと同じ表現ですが、表現データはありません。アクションのステータスまたはアクションから取得した結果の表現をPOSTします。 PUT、DELETE、アクションのステータスの表現。 OPTIONSは、通信オプションの表現です。エンドサーバーが受信した要求メッセージの表現をトレースします。 CONNECTへの応答とは別に、200応答には常にペイロードがありますが、起点サーバーは長さ0のペイロード本体を生成できます（MAY）。ペイロードが必要ない場合は、オリジンサーバーは代わりに204（コンテンツなし）を送信する必要があります。 CONNECTの場合、成功した結果はトンネルであり、200応答ヘッダーセクションの直後から始まるトンネルであるため、ペイロードは許可されません。 200応答はデフォルトでキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御で特に示されていない限り、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">201（Created）ステータスコードは、リクエストが満たされ、1つ以上の新しいリソースが作成されたことを示します。リクエストによって作成されたプライマリリソースは、レスポンスのLocationヘッダーフィールドによって識別されます。Locationフィールドが受信されない場合は、有効なリクエストURIによって識別されます。201応答ペイロードは、通常、作成されたリソースを記述してリンクします。201応答のETagやLast-Modifiedなどのバリデーターヘッダーフィールドの意味と目的については、&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">202(Accepted)ステータスコードは、リクエストが処理のために受け入れられたが、 処理が完了していないことを示す。リクエストは実際に処理が行われたときには拒否されるかもしれないので、最終的には処理されるかもしれないし、されないかもしれない。HTTPには、非同期操作からステータスコードを再送する機能はありません。202応答は意図的に非committalです。その目的は、サーバーが他のプロセス(おそらく1日に1回しか実行されないバッチ指向のプロセス)への リクエストを、プロセスが完了するまでユーザーエージェントのサーバーへの接続が持続することを要求せずに受け 入れることを可能にすることである。この応答と共に送られる表現は、リクエストの現在のステータスを記述し、 リクエストがいつ実現されるかの見積もりをユーザーに提供できるステー タスモニタを指し示す(または埋め込む)べきである。</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">203（Non-Authoritative Information）ステータスコードは、リクエストは成功したが、囲まれたペイロードが変換プロキシ（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]のセクション5.7.2&lt;/a&gt;）によって、オリジンサーバーの200（OK）応答のペイロードから変更されたことを示します。このステータスコードを使用すると、変換が適用されたときにプロキシが受信者に通知できるようになります。その知識は、コンテンツに関する後の決定に影響を与える可能性があるためです。たとえば、コンテンツの今後のキャッシュ検証リクエストは、同じリクエストパス（同じプロキシ経由）にのみ適用される可能性があります。 203応答は、214 Transformation Appliedの警告コードに似ています（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]のセクション5.5）。&lt;/a&gt;）。ステータスコードを含む応答に適用できるという利点があります。 203応答はデフォルトでキャッシュ可能です。つまり、メソッドの定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照 ）。</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">204（コンテンツなし）ステータスコードは、サーバーがリクエストを正常に処理したこと、および応答ペイロードの本文で送信する追加のコンテンツがないことを示します。応答ヘッダーフィールドのメタデータは、要求されたアクションが適用された後のターゲットリソースとその選択された表現を参照します。たとえば、PUTリクエストへの応答としてステータスコード204が受信され、そのレスポンスにETagヘッダーフィールドが含まれている場合、PUTは成功し、ETagフィールド値にはそのターゲットリソースの新しい表現のエンティティタグが含まれます。 204レスポンスにより、サーバーはアクションがターゲットリソースに正常に適用されたことを示すことができ、ユーザーエージェントは現在の「ドキュメントビュー」（存在する場合）からトラバースする必要がないことを意味します。サーバーは、ユーザーエージェントが自身のインターフェースに従ってユーザーに成功の兆候を提供し、アクティブまたはアクティブな表現への応答に新しいメタデータまたは更新されたメタデータを適用すると想定しています。たとえば、204ステータスコードは、「保存」アクションに対応するドキュメント編集インターフェイスで一般的に使用されます。これにより、保存中のドキュメントは、ユーザーが編集のために引き続き利用できます。また、分散バージョン管理システム内など、自動化されたデータ転送が普及することを期待するインターフェースで頻繁に使用されます。メッセージ本文を含めることができないため、204応答はヘッダーフィールドの後の最初の空行で終了します。デフォルトでは、204応答はキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御で特に示されていない限り（ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">205(Reset Content)ステータスコードは、サーバーがリクエストを満たし、ユーザーエージェントがリクエストを送信する原因となった「ドキュメントビュー」を、元のサーバーから受信した元の状態にリセットすることを望むことを示している。この応答は、ユーザがデータ入力をサポートするコンテンツ(フォーム、メモ帳、キャンバスなど)を受け取り、その空間にデータを入力または操作し、入力されたデータをリクエストで送信させ、その後、ユーザが別の入力アクションを容易に開始できるように、次の入力のためにデータ入力機構がリセットされるような、一般的なデータ入力の使用ケースをサポートすることを意図している。205ステータスコードは、追加コンテンツが提供されないことを暗示するので、 サーバーは205応答でペイロードを生成してはならない[MUST NOT]。言い換えれば、サーバーは205応答に対して次のいずれかを行わなければならない[MUST]。 a)値0を持つContent-Lengthヘッダーフィールドを含むことで応答のための ゼロ長ボディを示す;b)値chunkedを持つTransfer-Encodingヘッダーフィールドとゼロ長の単一チャンクからなる メッセージボディを含むことで応答のためのゼロ長ペイロードを示す;c)ヘッダーセクションを終了する空白行を送信した直後に接続を閉じる。</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">206（Partial Content）ステータスコードは、リクエストのRangeヘッダーフィールド（&lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt;）。単一のパーツが転送されている場合、206応答を生成するサーバーは、選択された表現のどの範囲が囲まれているかを示すContent-Rangeヘッダーフィールドと、その範囲で構成されるペイロードを生成する必要があります。例：HTTP / 1.1 206部分的なコンテンツの日付：水曜日、1995年11月15日06:25:24 GMT最終変更日：水曜日、1995年11月15日04:58:08 GMTコンテンツ範囲：バイト21010-47021 / 47022コンテンツ長：26012 Content-Type：image / gif ... 26012バイトの部分画像データ複数のパーツが転送されている場合、206応答を生成するサーバーは、&lt;a href=&quot;#appendix-A&quot;&gt;付録Aで&lt;/a&gt;定義されているように、「multipart / byteranges」ペイロードを生成する必要があります。、およびmultipart / byterangesメディアタイプとその必須の境界パラメータを含むContent-Typeヘッダーフィールド。シングルパートレスポンスとの混同を避けるために、サーバーは複数パートレスポンスのHTTPヘッダーセクションにContent-Rangeヘッダーフィールドを生成してはなりません（このフィールドは各パートで送信されます）。サーバーは、マルチパートペイロードの各ボディパーツのヘッダー領域内で、そのボディパーツで囲まれている範囲に対応するContent-Rangeヘッダーフィールドを生成する必要があります。選択された表現が200（OK）応答にContent-Typeヘッダーフィールドを持つ場合、サーバーは各ボディパーツのヘッダー領域に同じContent-Typeフィールドを生成する必要があります（SHOULD）。例：HTTP / 1.1 206部分コンテンツの日付：水、1995年11月15日06:25:24 GMT最終変更：水、1995年11月15日04:58:08 GMT Content-Length：1741 Content-Type：multipart / byteranges; border = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES Content-Type：application / pdf Content-Range：bytes 500-999 / 8000 ...最初の範囲--THIS_STRING_SEPARATES Content-Type：application / pdf Content-Range：bytes 7000-7999 / 8000。 ..2番目の範囲--THIS_STRING_SEPARATES--複数の範囲が要求された場合、サーバーは、重複する範囲、または複数のパーツを送信するオーバーヘッドよりも小さいギャップで区切られている範囲を、対応するbyte-range-specが受信したRangeヘッダーフィールドに表示されます。 multipart / byterangesペイロードのパーツ間の一般的なオーバーヘッドは約80バイトであるため、選択した表現のメディアタイプと選択した境界パラメーターの長さによっては、選択した表現全体を転送するよりも、多くの小さなばらばらのパーツを転送する方が効率が悪い場合があります。複数のパートをリクエストしないクライアントはマルチパートのレスポンスをサポートしない可能性があるため、サーバーは単一の範囲のリクエストに対するマルチパートのレスポンスを生成してはいけません（MUST NOT）。ただし、複数の範囲が要求され、1つの範囲のみが充足可能であることが判明した場合、または結合後に1つの範囲のみが残った場合、サーバーは単一のボディパーツのみでmultipart / byterangesペイロードを生成できます（MAY）。 multipart / byteranges応答を処理できないクライアントは、複数の範囲を要求する要求を生成してはなりません（MUST NOT）。マルチパート応答ペイロードが生成されると、サーバーは、対応するbyte-range-specが受信したRangeヘッダーフィールドに表示されたのと同じ順序でパーツを送信する必要があります（満足できないと見なされた範囲、または他の範囲に合体された範囲を除く）。マルチパート応答を受信するクライアントは、各ボディパーツに含まれるContent-Rangeヘッダーフィールドを検査して、そのボディパーツに含まれる範囲を判別する必要があります。クライアントは、要求したのと同じ範囲、または要求したのと同じ順序の受信に依存することはできません。 206応答が生成されるとき、同じ要求に対してフィールドが200（OK）応答で送信された場合、サーバーは上記の必須フィールドに加えて、次のヘッダーフィールドを生成する必要があります：Date、Cache-Control、ETag、 Expires、Content-Location、およびVary。If-Rangeヘッダーフィールドのあるリクエストに応答して206が生成される場合、クライアントはそれらのヘッダーフィールドを含む以前の応答をすでに持っていると理解されているため、送信者は上記の必要なフィールド以外の他の表現ヘッダーフィールドを生成してはなりません（SHOULD NOT）。それ以外の場合、送信者は、同じ要求に対する200（OK）応答で送信されるすべての表現ヘッダーフィールドを生成する必要があります。 206応答はデフォルトでキャッシュ可能です。つまり、明示的なキャッシュ制御で特に示されていない限り（送信者は、同じリクエストに対する200（OK）応答で送信されるすべての表現ヘッダーフィールドを生成する必要があります。 206応答はデフォルトでキャッシュ可能です。つまり、明示的なキャッシュ制御で特に示されていない限り（送信者は、同じリクエストに対する200（OK）応答で送信されるすべての表現ヘッダーフィールドを生成する必要があります。 206応答はデフォルトでキャッシュ可能です。つまり、明示的なキャッシュ制御で特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">207（マルチステータス）ステータスコードは、複数の独立した操作のステータスを提供します（詳細については、&lt;a href=&quot;#section-13&quot;&gt;セクション13&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">ステータスコードの2xx(Successful)クラスは、クライアントのリクエストが正常に受信され、理解され、受け入れられたことを示します。</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">300（Multiple Choices）ステータスコードは、ターゲットリソースに複数の表現があり、それぞれに固有のより具体的な識別子があることを示し、ユーザー（またはユーザーエージェント）が優先表現を選択できるように、代替に関する情報が提供されますリクエストをこれらの識別子の1つ以上にリダイレクトします。言い換えると、サーバーは、ユーザーエージェントがそのニーズに最適な表現を選択するために反応的な交渉を行うことを望んでいます（&lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4&lt;/a&gt;）。サーバーに優先選択がある場合、サーバーは優先選択のURI参照を含むLocationヘッダーフィールドを生成する必要があります（SHOULD）。ユーザーエージェントは、自動リダイレクトにLocationフィールドの値を使用できます。 HEAD以外のリクエストメソッドの場合、サーバーは、ユーザーまたはユーザーエージェントが最も好ましいものを選択できる表現メタデータとURI参照のリストを含む300応答でペイロードを生成する必要があります（SHOULD）。ユーザーエージェントは、提供されたメディアタイプを理解している場合、そのリストから自動的に選択を行うことができます。 HTTPはペイロードの定義と直交関係を維持しようとするため、自動選択の特定の形式はこの仕様では定義されていません。実際には、表現は、共有設計またはコンテンツネゴシエーションによって決定される、ユーザーエージェントに受け入れられると考えられるいくつかの簡単に解析できる形式、または一般的に受け入れられているハイパーテキスト形式で提供されます。 300応答はデフォルトでキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御で特に示されていない限り、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。注：300ステータスコードの最初の提案では、URIヘッダーフィールドを代替表現のリストを提供するものとして定義し、200、300、および406応答で使用でき、HEADメソッドへの応答で転送されるようにしました。ただし、展開の欠如と構文の不一致により、URIと代替案（以降の提案）の両方がこの仕様から除外されました。リンクヘッダーフィールドのセット[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt; ] を使用してリストを通信することは可能であり、それぞれが「代替」の関係にありますが、展開は鶏と卵の問題です。</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">301（永久に移動）ステータスコードは、ターゲットリソースに新しい永続URIが割り当てられており、このリソースへの今後の参照では、囲まれたURIの1つを使用する必要があることを示します。リンク編集機能を備えたクライアントは、有効なリクエストURIへの参照を、可能な場合はサーバーから送信された1つ以上の新しい参照に自動的に再リンクする必要があります。サーバーは、新しい永続URIの優先URI参照を含む応答にLocationヘッダーフィールドを生成する必要があります（SHOULD）。ユーザーエージェントは、自動リダイレクトにLocationフィールドの値を使用できます。サーバーの応答ペイロードには、通常、新しいURIへのハイパーリンクを含む短いハイパーテキストノートが含まれています。注：歴史的な理由により、ユーザーエージェントは、後続のリクエストのリクエストメソッドをPOSTからGETに変更する場合があります。この動作が望ましくない場合は、代わりに307（一時的なリダイレクト）ステータスコードを使用できます。デフォルトでは、301応答はキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御で特に示されていない限り、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">302(Found)ステータスコードは、ターゲットリソースが一時的に別のURIの下に存在することを示しています。リダイレクトは時々変更されるかもしれないので、クライアントは今後のリクエ ストに有効なリクエストURIを使い続けるべきである。サーバーは、異なるURIに対するURI参照を含む応答中にLocationヘッダー フィールドを生成するべきである[SHOULD]。ユーザーエージェントは自動リダイレクションのためにLocationフィールド値を 使用してもよい[MAY]。サーバーの応答ペイロードは通常、異なるURIへのハイパーリンクを持つ短いハイパーテキス トノートを含む。注意:歴史的な理由から、ユーザーエージェントは、後続のリクエストのために リクエストメソッドをPOSTからGETに変更してもよい[MAY]。この動作が望ましくない場合、代わりに307(Temporary Redirect)ステータスコードを使用することができる。</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">303(See Other)ステータスコードは、LocationヘッダーフィールドのURIによって示されるように、サーバがユーザーエージェントを別のリソースにリダイレクトしていることを示し、それはオリジナルリクエストに対する間接的な応答を提供することを意図している。ユーザエージェントは、そのURIをターゲットとした検索リクエスト(HTTPを使用している場合はGETまたはHEADリクエスト)を実行することができ、それもリダイレクトされる可能性があり、最終的な結果を元のリクエストへの応答として提示することができる。Locationヘッダーフィールドの新しいURIは、有効なリクエストURIと同等とは考えられないことに注意してください。このステータスコードはどのHTTPメソッドにも適用可能である。これは主に、ユーザーエージェントを選択されたリソースにリダイレクトするためのPOSTアクションの出力を可能にするために使用される。なぜなら、そうすることで、POST応答に対応する情報が、元のリクエストとは独立して、個別に識別、ブックマーク、およびキャッシュできる形で提供されるからである。GETリクエストに対する303応答は、オリジンサーバが、サーバによってHTTTP上で転送され得るターゲットリソースの表現を持っていないことを示す。しかし、Locationフィールド値は、元のターゲットリソースを表すことを意味することなく、その他のリソースに対して検索要求を行うことで、受信者にとって有用な表現が得られるかもしれないような、ターゲットリソースの記述的なリソースを参照しています。何が表現できるのか、どのような表現が適切なのか、何が有用な記述なのかという質問に対する答えは HTTP の範囲外であることに注意してください。HEADリクエストへの応答を除いて、303応答の表現は、Locationヘッダフィールドで提供されているのと同じURI参照へのハイパーリンクを持つ短いハイパーテキストノートを含むべきである。</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">304（Not Modified）ステータスコードは、条件付きのGETまたはHEADリクエストが受信され、条件がfalseと評価されたという事実がなければ200（OK）応答を返すことを示しています。つまり、リクエストは条件付きリクエストを作成したクライアントがすでに有効な表現を持っていることをリクエストが示しているため、サーバーがターゲットリソースの表現を転送する必要はありません。したがって、サーバーはクライアントをリダイレクトして、格納されている表現を200（OK）応答のペイロードであるかのように利用します。 304応答を生成するサーバーは、同じ要求に対する200（OK）応答で送信されるヘッダーフィールド（Cache-Control、Content-Location、Date、ETag、Expires、およびVary）のいずれかを生成する必要があります。304応答の目的は、受信者が既に1つ以上のキャッシュされた表現を持っている場合の情報転送を最小限に抑えることであるため、キャッシュの更新をガイドする目的でメタデータが存在しない限り（例えば、 Last-Modifiedは、応答にETagフィールドがない場合に便利です。 304応答を受信するキャッシュの要件は、304応答を受信するキャッシュの要件は、304応答を受信するキャッシュの要件は、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;[RFC7234]のセクション4.3.4&lt;/a&gt;。条件付き要求が発信クライアント、たとえば独自のキャッシュを持つユーザーエージェントが条件付きGETを共有プロキシに送信することで発生した場合、プロキシはそのクライアントに304応答を転送する必要があります（SHOULD）。 304応答にメッセージ本文を含めることはできません。ヘッダーフィールドの後の最初の空行で常に終了します。</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">305(Use Proxy)ステータスコードは、この仕様の以前のバージョンで定義されており、現在は非推奨となっている(付録B)。</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306 ステータスコードは、この仕様の以前のバージョンで定義されたもので、もはや使用されておらず、コードは予約されています。</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306のステータスコードは、以前のバージョンの仕様で使用されていたもので、現在は使用されておらず、コードは予約されています。</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">307（Temporary Redirect）ステータスコードは、ターゲットリソースが一時的に別のURIに存在し、ユーザーエージェントがそのURIへの自動リダイレクトを実行する場合、リクエストメソッドを変更してはならないことを示します。リダイレクションは時間の経過とともに変化する可能性があるため、クライアントは将来のリクエストに元の有効なリクエストURIを引き続き使用する必要があります。サーバーは、異なるURIのURI参照を含む応答にLocationヘッダーフィールドを生成する必要があります（SHOULD）。ユーザーエージェントは、自動リダイレクトにLocationフィールドの値を使用できます。サーバーの応答ペイロードには、通常、異なるURIへのハイパーリンクを含む短いハイパーテキストノートが含まれています。注：このステータスコードは、リクエストメソッドをPOSTからGETに変更できないことを除いて、302（Found）に似ています。この仕様では、301（永久に移動）（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;&lt;/a&gt;ただし、RFC7238 ]は、この目的のためにステータスコード308（Permanent Redirect）を定義しています。</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">ステータスコードの3xx（リダイレクト）クラスは、要求を満たすためにユーザーエージェントがさらにアクションを実行する必要があることを示します。Locationヘッダーフィールド（&lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt;）が提供されている場合、ユーザーエージェントは、特定のステータスコードが理解されていなくても、要求をLocationフィールド値によって参照されるURIに自動的にリダイレクトできます（MAY）。自動リダイレクトは、&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1で&lt;/a&gt;定義されているように、安全であることがわかっていないメソッドに注意して行う必要があります。、ユーザーが安全でないリクエストをリダイレクトしたくない場合があるため。リダイレクトにはいくつかの種類があります。1.ステータスコード301（永久に移動）、302（見つかりました）、および307（一時的なリダイレクト）のように、場所フィールドで提供される別のURIでリソースが利用できる可能性があることを示すリダイレクト）。 2. 300（Multiple Choices）ステータスコードのように、それぞれが元の要求ターゲットを表すことができる一致するリソースの選択肢を提供するリダイレクト。 3. 303（その他を参照）ステータスコードのように、要求に対する間接的な応答を表すことができる、[場所]フィールドで識別される別のリソースへのリダイレクト。 4. 304（Not Modified）ステータスコードのように、以前にキャッシュされた結果へのリダイレクト。注：HTTP / 1.0では、ステータスコード301（永久に移動）および302（見つかりました）は、最初のタイプのリダイレクト（&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945]、セクション9.3&lt;/a&gt;）。初期のユーザーエージェントは、リダイレクトターゲットに適用されるメソッドが元のリクエストと同じであるか、GETとして書き換えられるかで分かれていました。 HTTPは当初、301と302の前のセマンティクスを（CERNでの元の実装と一致するように）定義し、303（その他を参照）を後者のセマンティクスと一致するように定義しましたが、一般的な慣習は、301と302の後者のセマンティクスにも徐々に収束しました。 HTTP / 1.1の最初のリビジョンでは、307（一時的なリダイレクト）が追加され、従来のセマンティクスが分岐の影響を受けないことが示されました。 10年以上経過した後も、ほとんどのユーザーエージェントはまだ301と302のメソッドを書き換えています。したがって、この仕様では、元の要求がPOSTの場合にその動作を適合させます。クライアントは、周期的なリダイレクト（つまり、「無限」のリダイレクトループ）を検出して介入する必要があります（SHOULD）。注：この仕様の以前のバージョンでは、最大5つのリダイレクト（&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068]、セクション10.3&lt;/a&gt;）。コンテンツ開発者は、一部のクライアントがこのような固定された制限を実装する可能性があることを認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">400(Bad Request)ステータスコードは、クライアントエラーと認識される何か(例:不正なリクエスト構文、無効なリクエストメッセージフレーミング、または欺瞞的なリクエストルーティン グ)のために、サーバーがリクエストを処理できないか、または処理しないことを示す。</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">401（無許可）ステータスコードは、ターゲットリソースの有効な認証資格情報がないため、要求が適用されなかったことを示します。401応答を生成するサーバーは、ターゲットリソースに適用可能なチャレンジを少なくとも1つ含むWWW-Authenticateヘッダーフィールド（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）を送信する必要があります。要求に認証資格情報が含まれている場合、401応答は、それらの資格情報の承認が拒否されたことを示します。ユーザーエージェントは、新しいまたは置き換えられたAuthorizationヘッダーフィールド（&lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt;）。 401応答に前の応答と同じチャレンジが含まれていて、ユーザーエージェントが少なくとも1回認証を試みている場合、ユーザーエージェントは通常、関連する診断情報を含んでいるため、囲まれた表現をユーザーに提示する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">402(支払いが必要)のステータスコードは、今後の使用のために予約されています。</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">403(Forbidden)ステータスコードは、サーバーがリクエストを理解したが、それを承認することを 拒否したことを示す。リクエストが禁止された理由を公開したいサーバーは、その理由を(もしあれば)応答のペイロードに記述することができる。リクエストで認証の認証情報が提供された場合、サーバーはそれがアクセスを許可するには 不十分であると考える。クライアントは自動的に同じ信用証明書でリクエストを繰り返すべきではない [SHOULD NOT]。クライアントは新しいまたは異なる信用証明書でリクエストを繰り返してもよい[MAY]。しかしながら、リクエストはクレデンシャルとは無関係な理由で禁止されるかもしれない。禁じられたターゲットリソースの現在の存在を「隠す」ことを望むオリジンサーバー は、代わりに404(Not Found)というステータスコードで応答してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">404（見つかりません）ステータスコードは、オリジンサーバーがターゲットリソースの現在の表現を見つけられなかったか、存在することを開示する意思がないことを示します。 404ステータスコードは、この表現の欠如が一時的なものか永続的なものかを示しません。おそらくいくつかの構成可能な手段を通じて、起点サーバーが状態が永続的である可能性が高いことを知っている場合、410（存在しない）状況コードが404よりも優先されます。 404応答はデフォルトでキャッシュ可能です。つまり、メソッドの定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照 ）。</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">405（Method Not Allowed）ステータスコードは、request-lineで受信されたメソッドがオリジンサーバーで認識されているが、ターゲットリソースではサポートされていないことを示します。オリジンサーバーは、ターゲットリソースの現在サポートされているメソッドのリストを含む405応答にAllowヘッダーフィールドを生成する必要があります。 405応答はデフォルトでキャッシュ可能です。つまり、メソッドの定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照 ）。</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">406（Not Acceptable）ステータスコードは、リクエストで受信したプロアクティブネゴシエーションヘッダーフィールド（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）に従って、ターゲットリソースがユーザーエージェントに受け入れられる現在の表現を持たず、サーバーがデフォルトの表現を指定します。サーバーは、ユーザーまたはユーザーエージェントが最も適切なものを選択できる、利用可能な表現特性と対応するリソース識別子のリストを含むペイロードを生成する必要があります（SHOULD）。ユーザーエージェントは、そのリストから最も適切な選択肢を自動的に選択してもよい（MAY）。ただし、この仕様では、&lt;a href=&quot;#section-6.4.1&quot;&gt;セクション6.4.1で&lt;/a&gt;説明されているように、このような自動選択の標準を定義していません 。</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">407（Proxy Authentication Required）ステータスコードは401（Unauthorized）に似ていますが、プロキシを使用するためにクライアントが自身を認証する必要があることを示しています。プロキシは、ターゲットリソースのそのプロキシに適用可能なチャレンジを含むProxy-Authenticateヘッダーフィールド（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）を送信する必要があります。クライアントは、新しいまたは置き換えられたProxy-Authorizationヘッダーフィールド（&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）を使用して要求を繰り返すことができます（MAY ）。</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">408（リクエストタイムアウト）ステータスコードは、サーバーが待機する準備ができている時間内に完全なリクエストメッセージを受信しなかったことを示します。408は、サーバーが待機を続けるのではなく、接続を閉じることを決定したので、サーバーは応答で「閉じる」接続オプション（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]のセクション6.1）を&lt;/a&gt;送信する必要があります（SHOULD ）。クライアントに転送中の未処理の要求がある場合、クライアントは新しい接続でその要求を繰り返すことができます（MAY）。</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">409 (競合)ステータスコードは、ターゲットリソースの現在の状態との競合のためにリクエストを完了できなかったことを示します。このコードは、ユーザーが競合を解決してリクエストを再送信できるかもしれない 状況で使用される。サーバーは、ユーザーがコンフリクトのソースを認識するのに十分な情報を 含むペイロードを生成するべきである[SHOULD]。コンフリクトはPUTリクエストに応答して起こる可能性が高い。例えば、バージョニングが使用されていて、PUTされる表現が以前の(サードパーティの)リクエス トで行われたものと競合するリソースへの変更を含んでいた場合、オリジンサーバー はリクエストを完了できないことを示すために409応答を使用するかもしれない。この場合、応答表現は、リビジョン履歴に基づいて差分をマージするのに有用な 情報を含む可能性が高い。</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">410（Gone）ステータスコードは、ターゲットリソースへのアクセスがオリジンサーバーで利用できなくなったこと、およびこの状態が永続的である可能性が高いことを示しています。オリジンサーバーが状態が永続的であるかどうかを判断できない、または判断する機能がない場合は、代わりにステータスコード404（Not Found）を使用する必要があります。 410応答は主に、リソースが意図的に使用不可であること、およびサーバー所有者がそのリソースへのリモートリンクを削除することを望んでいることを受信者に通知することにより、Webメンテナンスのタスクを支援することを目的としています。このようなイベントは、期間限定のプロモーションサービスや、元のサーバーのサイトに関連付けられなくなった個人が所有するリソースに共通です。永久に利用できないリソースをすべて「」としてマークする必要はありませんまたは、マークを任意の期間保持します。これは、サーバーの所有者の裁量に任されます。410応答は、デフォルトでキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュコントロールで特に指定されていない限り（ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">411（Length Required）ステータスコードは、サーバーが定義されたContent-Length（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]のセクション3.3.2&lt;/a&gt;）なしでリクエストを受け入れることを拒否することを示します。クライアントは、リクエストメッセージのメッセージ本文の長さを含む有効なContent-Lengthヘッダーフィールドを追加した場合、リクエストを繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">412(Precondition Failed)ステータスコードは、リクエストヘッダーフィールドで与えられた1つ以上の条件が、サーバー上でテストされたときにfalseと評価されたことを示します。この応答コードにより、クライアントは現在のリソースの状態(その現在の表現とメタデータ)に前提条件を置くことができ、したがって、ターゲットリソースが予期しない状態にある場合にリクエストメソッドが適用されるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">413(Payload Too Large)ステータスコードは、リクエストのペイロードがサー バーが処理する意思があるか、または処理できるサイズよりも大きいため、サー バーがリクエストの処理を拒否していることを示す。サーバーは、クライアントがリクエストを継続できないようにするために 接続を閉じてもよい[MAY]。その状態が一時的なものである場合、サーバーはそれが一時的なものであり、何時までにクライア ントが再試行してもよい[MAY]ことを示すために、Retry-Afterヘッダー フィールドを生成するべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">414（URI Too Long）ステータスコードは、リクエストターゲット（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;セクション&lt;/a&gt;5.3）がサーバーが解釈するよりも長いため、サーバーがリクエストへのサービスを拒否していることを示します。このまれな状態が発生する可能性が高いのは、クライアントがPOSTリクエストを長いクエリ情報を含むGETリクエストに不適切に変換した場合、クライアントがリダイレクトの「ブラックホール」（たとえば、自体のサフィックス）、または潜在的なセキュリティホールを悪用しようとするクライアントによる攻撃を受けている場合。 414応答はデフォルトでキャッシュ可能です。つまり、メソッドの定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照 ）。</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">415(Unsupported Media Type)ステータスコードは、ペイロードがターゲットリソー ス上でこのメソッドがサポートしていない形式であるため、オリジンサーバーが リクエストのサービスを拒否していることを示す。フォーマットの問題は、リクエストが指定したContent-TypeまたはContent-Encodingに起因するか、 データを直接検査した結果である可能性がある。</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">416（Range Not Satisfiable）ステータスコードは、リクエストのRangeヘッダーフィールド（&lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt;）のどの範囲も選択されたリソースの現在の範囲と重複していないこと、またはリクエストされた一連の範囲が無効な範囲または過剰なために拒否されたことを示します小さい範囲または重複する範囲の要求。バイト範囲の場合、現在のエクステントとのオーバーラップに失敗すると、すべてのbyte-range-spec値のfirst-byte-posが、選択された表現の現在の長さよりも長くなります。このステータスコードがバイト範囲リクエストに応答して生成されると、送信者は、選択された表現の現在の長さを指定するContent-Rangeヘッダーフィールドを生成する必要があります（&lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2）。&lt;/a&gt;）。例：HTTP / 1.1 416 Range Not Satisfiable Date：Fri、20 Jan 2012 15:41:54 GMT Content-Range：bytes * / 47022 Note：サーバーは自由に範囲を無視できるため、多くの実装は選択された全体で単純に応答します200（OK）応答での表現。これは、ほとんどのクライアントがタスクを完了するために200（OK）を受け取る準備ができているためです（効率は落ちますが）。また、完全な表現を受け取るまでクライアントが無効な部分的なリクエストを停止しない場合もあります。したがって、クライアントは、最も適切な場合でも、416（範囲が満たされない）応答の受信に依存することはできません。</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">417（期待値失敗）ステータスコードは、リクエストのExpectヘッダーフィールド（&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）で指定された期待値が、少なくとも1つの受信サーバーで満たされなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="3e7e0d5b09bdf010782a5ab49b88e3ef27b80255" translate="yes" xml:space="preserve">
          <source>The 421 (Misdirected Request) status code indicates that the request
   was directed at a server that is not able to produce a response.
   This can be sent by a server that is not configured to produce
   responses for the combination of scheme and authority that are
   included in the request URI. 

   Clients receiving a 421 (Misdirected Request) response from a server
   MAY retry the request -- whether the request method is idempotent or
   not -- over a different connection.  This is possible if a connection
   is reused (&lt;a href=&quot;#section-9.1.1&quot;&gt;Section 9.1.1&lt;/a&gt;) or if an alternative service is selected
   [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;].

   This status code MUST NOT be generated by proxies.

   A 421 response is cacheable by default, i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">421（Misdirected Request）ステータスコードは、要求が応答を生成できないサーバーに向けられたことを示します。これは、要求URIに含まれているスキームと権限の組み合わせに対する応答を生成するように構成されていないサーバーによって送信される可能性があります。サーバーから421（Misdirected Request）応答を受信したクライアントは、別の接続を介して要求を再試行できます（要求方法がべき等であるかどうかに関係なく）。これは、接続が再利用されている場合（&lt;a href=&quot;#section-9.1.1&quot;&gt;セクション9.1.1&lt;/a&gt;）、または代替サービスが選択されている場合[ &lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt; ]に可能です。このステータスコードは、プロキシによって生成されてはなりません（MUSTNOT）。421応答は、デフォルトでキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照）。）。</target>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">422(Unprocessable Entity)ステータスコードは、サーバーがリクエストエンティティのコンテン ツタイプを理解していることを意味し(そのため、415(Unsupported Media Type)ステータスコードは不適切である)、リクエストエンティティの構文は正しいが(そのため、400(Bad Request)ステータスコードは不適切である)、含まれている命令を処理できなかったことを意味する。例えば、このエラー状態は、XMLリクエストボディが整形式(すなわち、構文的には正しい)ではあるが、意味的には誤ったXML命令を含んでいる場合に発生する可能性がある。</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">423(LOCKED)ステータスコードは、メソッドのソースまたはデスティネーションリソー スがロックされていることを意味する。この応答は、「lock-token-submitted」や「no-conflicting-lock」などの適切な前提条件または事後条件コードを含むべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">424(Failed Dependency)ステータスコードは、要求されたアクションが他のアクションに依存しており、そのアクションが失敗したため、そのメソッドをリソース上で実行できなかったことを意味します。例えば、PROPPATCH メソッドのコマンドが失敗した場合、最低でも残りのコマンドも 424 (Failed Dependency)で失敗します。</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">426（アップグレードが必要）ステータスコードは、サーバーが現在のプロトコルを使用して要求を実行することを拒否したが、クライアントが別のプロトコルにアップグレードした後に実行する可能性があることを示します。サーバーは、426応答でUpgradeヘッダーフィールドを送信して、必要なプロトコルを示す必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]のセクション6.7&lt;/a&gt;）。例：HTTP / 1.1 426アップグレードが必要ですアップグレード：HTTP / 3.0接続：アップグレードContent-Length：53 Content-Type：text / plainこのサービスは、HTTP / 3.0プロトコルの使用を必要とします。</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">ステータスコードの4xx(Client Error)クラスは、クライアントがエラーを起こしたようであることを 示す。HEADリクエストに応答する場合を除いて、サーバーはエラーの状況と、それが一時的なものか恒久的なものかの 説明を含む表現を送るべきである[SHOULD]。これらのステータスコードはどのようなリクエストメソッドにも適用可能である。ユーザーエージェントは、含まれる表現をユーザーに表示するべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">4xxクラスのステータスコードは、クライアントがエラーを起こしたと思われる 場合のために意図されている。HEADリクエストに応答する場合を除いて、サーバーはエラーの状況の説明と、それが 一時的な状態なのか永続的な状態なのかを含む実体を含むべきである[SHOULD]。これらのステータスコードはどのようなリクエストメソッドにも適用可能である。ユーザーエージェントは、含まれるエンティティをユーザーに表示するべきである [SHOULD]。クライアントがデータを送っている場合、TCPを使用するサーバーの実装は、サーバーが 入力接続を閉じる前に、応答を含むパケットの受信をクライアントが確認することを 確実にするように注意するべきである[SHOULD]。終了後にクライアントがサーバにデータを送信し続ける場合、サーバのTCPスタックはクライアントにリセットパケットを送信し、HTTPアプリケーションが読み取って解釈できるようになる前に、クライアントの未認識の入力バッファを消去する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">500 (内部サーバーエラー)ステータスコードは、サーバーが予期しない状態に遭遇したためにリクエストの実行が妨げられたことを示しています。</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">501（未実装）ステータスコードは、サーバーが要求を満たすために必要な機能をサポートしていないことを示します。これは、サーバーが要求メソッドを認識せず、どのリソースに対してもそれをサポートできない場合の適切な応答です。 501応答はデフォルトでキャッシュ可能です。つまり、メソッド定義または明示的なキャッシュ制御によって特に示されていない限り（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]のセクション4.2.2を&lt;/a&gt;参照 ）。</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">502 (Bad Gateway)ステータスコードは、サーバーがゲートウェイまたはプロキシとして動作している間に、リクエストを満たすためにアクセスしたインバウンドサーバーから無効な応答を受信したことを示しています。</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">503（Service Unavailable）ステータスコードは、一時的な過負荷または定期的なメンテナンスが原因で、サーバーが現在要求を処理できないことを示しています。サーバーはRetry-Afterヘッダーフィールド（&lt;a href=&quot;#section-7.1.3&quot;&gt;セクション7.1.3&lt;/a&gt;）を送信して、リクエストを再試行する前にクライアントが待機する適切な時間を提案する場合があります。注：503ステータスコードの存在は、サーバーが過負荷になったときにそれを使用する必要があることを意味しません。一部のサーバーは、接続を単に拒否する場合があります。</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="translated">504(ゲートウェイタイムアウト)ステータスコードは、サーバーがゲートウェイまたはプロキシとして動作している間に、リクエストを完了するためにアクセスする必要があるアップストリームサーバーからタイムリーな応答を受信しなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">505（HTTPバージョンはサポートされていません）ステータスコードは、サーバーが要求メッセージで使用されたHTTPのメジャーバージョンをサポートしていないか、サポートを拒否していることを示します。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;[RFC7230]のセクション2.6で&lt;/a&gt;説明されているように、サーバーは、クライアントと同じメジャーバージョンを使用して、このエラーメッセージ以外でリクエストを完了できないか、または実行したくないことを示しています。サーバーは、そのバージョンがサポートされていない理由と、そのサーバーでサポートされている他のプロトコルを説明する505応答の表現を生成する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="translated">507(Insufficient Storage)ステータスコードは、サーバーがリクエストを正常に完了するために必要な表現を保存できないため、そのリソースでメソッドを実行できなかったことを意味します。この状態は一時的なものと考えられる。このステータスコードを受け取ったリクエストがユーザーアクションの結果であった 場合、そのリクエストは別のユーザーアクションでリクエストされるまで 繰り返されてはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">511ステータスコードは、クライアントがネットワークアクセスを得るために認証が必要であることを示しています。</target>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">ステータスコードの5xx(Server Error)クラスは、サーバがエラーを起こしたことを認識しているか、 要求されたメソッドを実行できないことを示す。HEADリクエストに応答する場合を除いて、サーバーはエラー状況の説明と、それが一時的な 状態なのか永続的な状態なのかを含む表現を送るべきである[SHOULD]。ユーザーエージェントは、含まれる表現をユーザーに表示するべきである [SHOULD]。これらの応答コードはどのようなリクエストメソッドにも適用可能である。</target>
        </trans-unit>
        <trans-unit id="eff8921ecde9859824b0aa4a316363853f77725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</target>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">リソースまたはデータの&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="476cfd9f7f7d09d394f8e2d140063c4110e761fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="translated">The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</target>
        </trans-unit>
        <trans-unit id="11aa0c02b1fe58d03a5cb415bbf783776721cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request method.</source>
          <target state="translated">The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; request method.</target>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTPヘッダー。</target>
        </trans-unit>
        <trans-unit id="1495070845bb0ae9175f95e2e4b9163ee31037e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; URL is too long</source>
          <target state="translated">The &lt;a href=&quot;../headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; URL is too long</target>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーは完全に省略されるであろう。リファラー情報はリクエストとともに送信されません。</target>
        </trans-unit>
        <trans-unit id="e873c7c4f23e96331a7b10f6fab0e72d0c3815f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</source>
          <target state="translated">The &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</target>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダは、「キープアライブ」どんな意味を持っているために、このヘッダーのために設定する必要があります。また、HTTP / 2 では&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;は無視されます。接続管理はそこで他のメカニズムによって処理されます。</target>
        </trans-unit>
        <trans-unit id="28e20ae8f53246c900d9de361122fb549b4a54cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header with type &lt;code&gt;upgrade&lt;/code&gt; must &lt;em&gt;always&lt;/em&gt; be sent with the &lt;code&gt;Upgrade&lt;/code&gt; header (as shown above).</source>
          <target state="translated">タイプ &lt;code&gt;upgrade&lt;/code&gt; の&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーは、&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーと一緒に送信する必要&lt;em&gt;があり&lt;/em&gt;ます（上記を参照）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; の&lt;/a&gt;マルチボディの境界を定義します。</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;ヘッダがブラウザ、または他の任意のユーザエージェントによって定義され、文脈に応じて変えることができる、HTMLページまたは画像、ビデオ、またはスクリプトを取り出すように：で入力されたドキュメントをフェッチするときに異なっています&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 、&lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を介してリンクされたアドレスバーまたは要素。ブラウザは、最も適切であると考えるヘッダーの値を自由に使用できます。&lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;一般的なブラウザのデフォルト値の&lt;/a&gt;完全なリストが利用可能です。</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;エージェントがプロセスに喜んであることを見出し一覧にメディアリソースのMIMEタイプを。これは、カンマで区切られたMIMEタイプのリストであり、それぞれがさまざまなMIMEタイプ間の相対的な優先度を示すパラメータである品質係数と組み合わされています。</target>
        </trans-unit>
        <trans-unit id="47c1d1550663e7b9840b652f6ba1f6059d00bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</target>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;ヘッダは、ユーザエージェントによって理解されている文字コードの種類をサーバに指示します。従来は、ブラウザのロケールごとに異なる値に設定されていました（西ヨーロッパのロケールの場合は &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダは、許容可能なコンテンツコード（サポート圧迫）を定義します。値は、エンコード値の優先順位を示す &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; 係数リスト（例：br、gzip; q = 0.8）です。デフォルト値の &lt;code&gt;identity&lt;/code&gt; は、（特に宣言されていない限り）最も低い優先度です。</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;ヘッダは、ユーザの言語嗜好を示すために使用されます。これは、品質係数を持つ値のリストです（例： &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &quot;）。デフォルト値は、ユーザーエージェントのグラフィカルインターフェースの言語に応じて設定されることがよくありますが、ほとんどのブラウザーでは、異なる言語設定を設定できます。</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;ヘッダーが場合、要求に対する応答を露出させることができるかどうかを示し &lt;code&gt;credentials&lt;/code&gt; フラグが真です。プリフライト要求への応答の一部として使用される場合、これは、資格情報を使用して実際の要求を行うことができるかどうかを示します。単純な &lt;code&gt;GET&lt;/code&gt; リクエストはプリフライトされないため、資格情報付きのリソースに対してリクエストが行われた場合、このヘッダーがリソースとともに返されない場合、応答はブラウザーによって無視され、Webコンテンツには返されません。</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;ヘッダは、に応じて使用される&lt;a href=&quot;#Preflighted_requests&quot;&gt;プリフライト要求&lt;/a&gt;実際の要求を行う際に使用することができるHTTPヘッダーを示すために。</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;ヘッダは、リソースにアクセスする際に許可される方法または方法を指定します。これはプリフライトリクエストへの応答で使用されます。リクエストがプリフライトされる条件については、上記で説明しています。</target>
        </trans-unit>
        <trans-unit id="4527c593b9686c403ce7ee6942811c00a0260ae5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt;&lt;code&gt;getResponseHeader()&lt;/code&gt;&lt;/a&gt;) in browsers are allowed to access.</source>
          <target state="translated">The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt; &lt;code&gt;getResponseHeader()&lt;/code&gt; &lt;/a&gt;) in browsers are allowed to access.</target>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt;ヘッダは、ブラウザがアクセスを許可されていることをホワイトリストヘッダーのサーバーをすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt;ヘッダーは、プリフライトリクエストの結果をキャッシュすることができる時間の長さを示しています。プリフライトリクエストの例については、上記の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;実際の要求が行われたときに使用されるどのようなHTTPヘッダのサーバを知ることができるようにプリフライトリクエストを発行する際にヘッダが使用されています。</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;ヘッダは、実際の要求が送信されるとき、それはして送信されることをプリフライトリクエストの一部としてサーバに通知 &lt;code&gt;POST&lt;/code&gt; のリクエスト方法。&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;の実際の要求が送られたとき、それはして送信されることを見出し通知サーバー &lt;code&gt;X-PINGOTHER&lt;/code&gt; と &lt;code&gt;Content-Type&lt;/code&gt; カスタムヘッダ。サーバーは、これらの状況下で要求を受け入れたいかどうかを判断する機会を得ました。</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;実際の要求が行われたときに使用されるどのようなHTTPメソッドサーバーを知ることができるようにプリフライトリクエストを発行する際に使用されています。</target>
        </trans-unit>
        <trans-unit id="7fbe0c67984080abcf5fba23225ff8d88603f4f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">The &lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</target>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;リクエストヘッダは、（プロキシ）サーバとユーザエージェントを認証するための認証情報が含まれています。ここでは、タイプが再び必要であり、資格情報が続きます。資格情報は、使用する認証スキームに応じてエンコードまたは暗号化できます。</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1一般ヘッダフィールドは、要求と応答の両方でのメカニズムをキャッシュするためのディレクティブを指定するために使用されます。このヘッダーを使用して、提供するさまざまなディレクティブでキャッシュポリシーを定義します。</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダは、現在要求された範囲（としない画像のフルサイズ）の大きさを示しています。&lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;この部分的なメッセージが属する場所フルリソースのレスポンスヘッダが示します。</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;レスポンスヘッダフィールドは、ユーザエージェントは、特定のページのロードを許可されている制御リソースへのWebサイトの管理者を可能にします。いくつかの例外はありますが、ポリシーには主にサーバーの起点とスクリプトのエンドポイントの指定が含まれます。</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;レスポンスヘッダは&lt;em&gt;不透明ツー・ユーザエージェント&lt;/em&gt;強いバリデータとして使用することができる値。つまり、ブラウザなどのHTTPユーザーエージェントは、この文字列が何を表しているのかを認識しておらず、その値がどうなるかを予測できません。場合 &lt;code&gt;ETag&lt;/code&gt; ヘッダーがリソースに対する応答の一部であった、クライアントが発行できる&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;キャッシュされたリソースを検証するために-今後のリクエストのヘッダーに。</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTPヘッダー。</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; HTTPリクエストヘッダには、範囲の要求条件になり：条件が満たされた場合、範囲の要求が発行され、サーバが送り返す&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; の適切なボディとの回答を。条件が満たされない場合、リソース全体が&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ステータスで返送されます。このヘッダーは、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;バリデーターまたは&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; の&lt;/a&gt;いずれかで使用できますが、両方では使用できません。</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; の&lt;/a&gt;応答ヘッダが弱いバリデータとして使用することができます。1秒の解像度しかないため、弱いと見なされます。場合 &lt;code&gt;Last-Modified&lt;/code&gt; ヘッダが応答に存在している場合、クライアントが発行できる&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;リクエストヘッダはキャッシュされたドキュメントを検証します。</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; の&lt;/a&gt;ヘッダには、クロスサイトアクセス要求またはプリフライト要求の起源を示します。</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダには、マルチパート文書で一度に複数の範囲を取得することができます。範囲はコンマで区切られます。</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTPレスポンスヘッダには、ユーザエージェントにサーバーからのCookieを送信します。シンプルなクッキーは次のように設定されています：</target>
        </trans-unit>
        <trans-unit id="af75cb2c0da0fe81a5535d484eb290c4bd4d639e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">The &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</target>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダは、大量のデータがクライアントに送信され、要求が完全に処理されるまでの応答の合計サイズが不明な有用チャンクエンコーディングを可能にします。サーバーは、応答をバッファリングしたり、正確な長さを決定したりせずに、すぐにクライアントにデータを送信します。これにより、遅延が改善されます。範囲リクエストとチャンキングは互換性があり、相互に使用してもしなくても使用できます。</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;ヘッダは、要求を送信し、ブラウザを識別する。この文字列には、スペースで区切られた&lt;em&gt;製品トークン&lt;/em&gt;と&lt;em&gt;コメントの&lt;/em&gt;リストを含めることができます。</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTPレスポンスヘッダは、キャッシュされた応答は、オリジンサーバからの新鮮なものを要求するのではなく使用することができるかどうかを決定するために、将来のリクエストヘッダを一致させる方法を決定します。</target>
        </trans-unit>
        <trans-unit id="b1d4a413436104711d19f9e2f2ce3b22dd6fa9fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</source>
          <target state="translated">The &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</target>
        </trans-unit>
        <trans-unit id="8f8e8fc45b5f4468eb6609ffd5ad8cb0e64e2e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</source>
          <target state="translated">The &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</target>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダは、リソースにアクセスするために使用されるべき認証方法を定義します。使用する認証方式を指定する必要があるため、認証を希望するクライアントは、資格情報を提供する方法を認識できます。これらのヘッダーの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;プロキシによって受信されるリクエストヘッダフィールド。</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;モジュールはまた、リダイレクトを作成するために使用することができます。より柔軟ですが、使用するのが少し複雑です。</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org&lt;/a&gt;のHTTP警告コードレジストリは、警告コードの名前空間を定義します。</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">MicrosoftによるX-Content-Type-Options の&lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;元の定義&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6bb44a38f57a4a24a21a54355c1172f452d3808" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</source>
          <target state="translated">The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</target>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;要求を実行できませんでしたプリフライト、プリフライトが必要です。プリフライトが失敗する理由はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;要求は、サーバーが資格情報の使用を許可することを必要としますが、サーバの&lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;ヘッダの値がに設定されていない &lt;code&gt;true&lt;/code&gt; の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;要求は、資格証明書フラグを設定して実行しようとしましたが、サーバーは、ワイルドカード（使用して構成されている &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）の値として、&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;の資格情報を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;リクエストは、CORS要求時に許可されていない元の要求とは異なる起源にURLにHTTPリダイレクトでサーバーによって応答されました。</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTPの&lt;/a&gt; HTTP接続は、ネットワークまたはプロトコルレベルのいずれかで失敗したため、CORSを利用する要求が失敗しました。このエラーはCORSに直接関連しているわけではありませんが、何らかの基本的なネットワークエラーです。</target>
        </trans-unit>
        <trans-unit id="77ebeb340729beee4023ffdb21e08feae0d716a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; to apply to that option.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;品質値は、&lt;/a&gt;そのオプションに適用します。</target>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;単純なヘッダー&lt;/a&gt;、&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;（のみのいずれかのパラメータを無視し、その解析された値（）のMIMEタイプの &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 、 &lt;code&gt;multipart/form-data&lt;/code&gt; 、または &lt;code&gt;text/plain&lt;/code&gt; ）は常に使用可能であり、このヘッダーでリストする必要はありません。</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザエージェントは、&lt;/a&gt;必要に追加することができませんでした&lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;にヘッダを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTPの&lt;/a&gt;リクエスト。すべてのCORSリクエストには、 &lt;code&gt;Origin&lt;/code&gt; ヘッダーが必要です。</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; &lt;/a&gt;インターフェースはで使用するためにフォームデータを操作するために使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; の&lt;/a&gt; API。</target>
        </trans-unit>
        <trans-unit id="7537c29a754763b348491b7f0dbd96e605a4a484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;reporting API&lt;/a&gt; group to send network error reports to (see below).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;報告のAPI&lt;/a&gt;（下記参照）にネットワークエラー報告を送信するグループ。</target>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt;コンストラクタは、あなたのためにハンドシェイクし、アップグレードプロセスを扱う最初のHTTP / 1.1接続を作成するためのすべての作業を行います。</target>
        </trans-unit>
        <trans-unit id="d45717eba61ad3d5a426950cb644c8f2dd47e3a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; for WebXR Device API instead.</source>
          <target state="translated">The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt; &lt;code&gt;xr-spatial-tracking&lt;/code&gt; &lt;/a&gt; for WebXR Device API instead.</target>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">iframe の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;許可&lt;/a&gt;の属性&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; の&lt;/a&gt;秒。</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt;ヘッダが一緒に使用される &lt;code&gt;Device-Memory&lt;/code&gt; の値 &lt;code&gt;Accept-CH&lt;/code&gt; ヘッダ及び装置がオプトインでなければならないサーバとデバイスメモリの量を共有する時間の量を示します。値はミリ秒単位で指定され、その使用はオプションです。</target>
        </trans-unit>
        <trans-unit id="feae0b21dc6047c955761cda1dd45a586e339677" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</source>
          <target state="translated">The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</target>
        </trans-unit>
        <trans-unit id="102f0a3635d954f2ea429dc9612327a656cc4b1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</source>
          <target state="translated">The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</target>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTPプロトコルは&lt;/a&gt;、すでに確立された接続が新しい、互換性のない、プロトコルにアップグレードすることができ、特別なメカニズムを提供します。このガイドは、これがどのように機能するかをカバーし、それが使用されるシナリオの例を提供します。</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;クロスオリジン資源ポリシー&lt;/a&gt;ヘッダは、リソースをロードするから他のドメインを防止します。</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;モジュールを有し、 &lt;code&gt;Redirect&lt;/code&gt; と &lt;code&gt;RedirectMatch&lt;/code&gt; 設定することを指示&lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;（デフォルト）応答。</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">&lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozillaの天文台の&lt;/a&gt;安全性とセキュリティのためのWebサイトの（このヘッダーを含む）の構成をテストツール</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64urlの&lt;/a&gt;フォーマットは、標準のBase64エンコードと同じではありません。これは標準のBase64とほとんど同じですが、まったく同じではありません。唯一の違い：結果の文字列がURLとファイル名の両方で安全に使用できるようにするために、アルファベットの62番目と63番目の文字が &lt;code&gt;&quot;+&quot;&lt;/code&gt; と &lt;code&gt;&quot;/&quot;&lt;/code&gt; から &lt;code&gt;&quot;-&quot;&lt;/code&gt; （マイナス）と &lt;code&gt;&quot;_&quot;&lt;/code&gt; 」に変更されています。&quot;（アンダースコア）、それぞれ。</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/&quot;&gt;IANA（Internet Assigned Numbers Authority）は&lt;/a&gt;、すべての公式のMIMEタイプを担当し、あなたは彼らので最新かつ完全なリストを見つけることができます&lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;メディアタイプの&lt;/a&gt;ページを。</target>
        </trans-unit>
        <trans-unit id="a0ea81494b8105f6717337ab7d95f01a45c084f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; header field.</target>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; の&lt;/a&gt;方法は、指定されたリソースのデータ表現を要求します。 &lt;code&gt;GET&lt;/code&gt; を使用したリクエストは、データのみを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;それはその状態を変化させることができるので、この方法は、データをサーバーに送信します。これは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTMLフォームで&lt;/a&gt;よく使用される方法です。</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーは完全に省略されるであろう。リファラー情報はリクエストとともに送信されません。</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; の&lt;/a&gt;ステータスコードを含むリクエストへの応答として送信される &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; リクエストの受信者は、所望のプロトコルのいずれかにアップグレードする意思があることを知らせるためのヘッダ。場合 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; ステータスコードが返され、ヘッダも含んでいなければならない &lt;code&gt;Connection&lt;/code&gt; し、 &lt;code&gt;Upgrade&lt;/code&gt; 選択されたプロトコルを記述するためにヘッダを。&lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;この仕組みの&lt;/a&gt;詳細については、このメカニズムの一般的な使用法の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（複数の選択肢）または&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（許容できない）&lt;a href=&quot;status&quot;&gt;HTTP応答コード&lt;/a&gt;サーバ（によって&lt;em&gt;エージェント駆動型ネゴシエーション&lt;/em&gt;または&lt;em&gt;反応ネゴシエーション&lt;/em&gt;フォールバックメカニズムとして使用されます）。</target>
        </trans-unit>
        <trans-unit id="7a2ea4621d5db4a0643b172c60b9729d03740461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">The &lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt; &lt;code&gt;415&lt;/code&gt; &lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</target>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; の&lt;/a&gt;リクエストヘッダは、トレーラーのフィールドを許可するように、「トレーラー」に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;ディレクティブの前に評価された &lt;code&gt;block-all-mixed-content&lt;/code&gt; と前者が設定されている場合、後者は、効果的に何もしません。HTTPへのリダイレクト後にそれを強制しない古いブラウザーでHTTPSを強制したい場合を除いて、どちらか一方のディレクティブを設定することをお勧めします。両方ではありません。</target>
        </trans-unit>
        <trans-unit id="5a51eef50de25b01cedd4928f3f99c9fae3d5200" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt;. If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; . If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</target>
        </trans-unit>
        <trans-unit id="0f16849e96b723097d3105369f7d2ec73a2c9b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header ensures that the content is cached properly (for instance ensuring that the user is not served a lower-quality image from the cache when &lt;code&gt;Save-Data&lt;/code&gt; header is no longer present [&lt;em&gt;e.g.&lt;/em&gt; after having switched from cellular to Wi-Fi]).</source>
          <target state="translated">&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;（ときにユーザがキャッシュから低品質の画像が配信されないことを確実にする、例えばコンテンツが適切にキャッシュされていることを見出し性を保証 &lt;code&gt;Save-Data&lt;/code&gt; [ヘッダがもはや存在しないが&lt;em&gt;、例えば&lt;/em&gt;のWi-Fiに細胞から切り替わった後]） 。</target>
        </trans-unit>
        <trans-unit id="ce5a0a42af328d6549a6884a0d4203b5b8180652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt;&lt;code&gt;allowlist&lt;/code&gt; value.</source>
          <target state="translated">The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt; &lt;code&gt;allowlist&lt;/code&gt; value.</target>
        </trans-unit>
        <trans-unit id="a1e69a4edf06fe574fa80e88285f8fb7d88da970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt; , but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</target>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">&lt;code&gt;'strict-dynamic&lt;/code&gt; 信頼関係が明示的にマークアップでスクリプト存在に与えられたことを」ソース式の指定は、ナンスやハッシュとそれに付随することで、そのルートスクリプトによってロードされたすべてのスクリプトに伝播されなければなりません。同時に、 &lt;code&gt;'self'&lt;/code&gt; や &lt;code&gt;'unsafe-inline'&lt;/code&gt; などのホワイトリストまたはソース式は無視されます。たとえば、 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; などのポリシーでは、 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; を使用してルートスクリプトをロードできます。 example.com/loader.js &quot;&amp;gt;そして、その信頼を &lt;code&gt;loader.js&lt;/code&gt; によってロードされたすべてのスクリプトに伝播しますが、 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; からのスクリプトのロードは許可しません。//whitelisted.com/ nonceを伴うか、信頼できるスクリプトからロードされない限り。</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; ソース発現制御文字列からコードを作成するいくつかのスクリプトの実行方法。場合は &lt;code&gt;'unsafe-eval'&lt;/code&gt; で指定されていない &lt;code&gt;script-src&lt;/code&gt; ディレクティブは、以下のような方法がブロックされ、何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; ソース発現制御文字列からスタイル宣言を作成し、いくつかのスタイルの方法。場合は &lt;code&gt;'unsafe-eval'&lt;/code&gt; で指定されていない &lt;code&gt;style-src&lt;/code&gt; ディレクティブは、以下のような方法がブロックされ、何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="c3028d259a6399103c9ce4edc7dfac31909edc67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon (&lt;code&gt;:&lt;/code&gt;). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon ( &lt;code&gt;:&lt;/code&gt; ). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</target>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; ファイル参照 &lt;code&gt;.htpasswd&lt;/code&gt; 各行は、ユーザー名とパスワードを含有しているファイルをコロン（「：」）で区切られています。&lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;暗号化さ&lt;/a&gt;れているため、実際のパスワードは確認できません（この場合はmd5）。必要に &lt;code&gt;.htpasswd&lt;/code&gt; て.htpasswdファイルに別の名前を付けることができますが、このファイルには誰もアクセスできないようにしてください。（Apacheは通常、 &lt;code&gt;.ht*&lt;/code&gt; ファイルへのアクセスを防ぐように構成されています）。</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; ファイルは通常、次のようになります。</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">&lt;code&gt;203&lt;/code&gt; 応答の値と同様である &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; を意味し、 &lt;code&gt;Transformation Applied&lt;/code&gt; の、&lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt;任意のステータスコードで応答に適用可能であるという付加的な利点を有するヘッダコードを、。</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;416&lt;/code&gt; 応答メッセージが含ま&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;（ある不満足範囲を示す &lt;code&gt;'*'&lt;/code&gt; が続く） &lt;code&gt;'/'&lt;/code&gt; とリソースの現在の長さ。例 &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc6eca35190b0a85bc179efcd6440ff5e420f987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</source>
          <target state="translated">The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt; ) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="000250a8c920d71a596d42e3ba222cb0c276eb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</target>
        </trans-unit>
        <trans-unit id="d74ebb54bf35188baf88fab6ddfb03450100af2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;s.</target>
        </trans-unit>
        <trans-unit id="678867190bea86d25ddd4c42f7e5d5945a9962ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</target>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 属性は、ブラウザが特定のURLにリダイレクトする前に待機する秒数を示す数字で始まります。アクセシビリティを向上させるために、常に &lt;code&gt;0&lt;/code&gt; に設定してください。</target>
        </trans-unit>
        <trans-unit id="df94992d56f1ec3780068eef1f291a2bd6528445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d9f882bdef0f2fbd9c820397fd3355193604e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8570429a0850dacdf55e905b24382087aa950397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; redirects by default:</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; redirects by default:</target>
        </trans-unit>
        <trans-unit id="1a33077bdfc87f84fa941dba1652820231ca50a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; element.</target>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; エンティティヘッダフィールドは、HTTPヘッダー内の1つまたは複数のリンクを直列化するための手段を提供します。意味的には、HTMLの &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; 要素と同等です。</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; ヘッダフィールドは、交換の権限を決定し、その署名を更新する方法についての情報を伴うそれぞれのための署名のリストを伝えます。</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; ヘッダフィールドは、署名に含めるレスポンスヘッダフィールドの順序付きリストを識別する。</target>
        </trans-unit>
        <trans-unit id="f3c5f0394e6c797409337c3ba59ac4660eea6b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify the persistence of &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; header value that specifies for which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers client should include in subsequent requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; ヘッダはの持続指定するためにサーバによって設定され&lt;a href=&quot;accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;れることを指定したヘッダ値を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;クライアントヒント&lt;/a&gt;ヘッダークライアントはその後の要求に含めるべきです。</target>
        </trans-unit>
        <trans-unit id="1fc84160c5460da89ca680071c3cd21f91aa02e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers a client should include in subsequent requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; ヘッダを指定するためにサーバによって設定された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;クライアントヒント&lt;/a&gt;クライアントは、後続の要求に含めるべきであるヘッダ。</target>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; レスポンスHTTPヘッダーは、部分的な要求への支援を宣伝するためにサーバーによって使用されるマーカーです。このフィールドの値は、範囲を定義するために使用できる単位を示します。</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; レスポンスヘッダは、応答が所定のコードを要求すると共有できるかどうかを示す&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;原点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; ヘッダは、オブジェクトが、プロキシキャッシュにあった時間を秒単位で含まれています。</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; ヘッダは、リソースによって方法のサポートのセットを示しています。</target>
        </trans-unit>
        <trans-unit id="c95653d764bb42232e9cbd3888e86cd3686754bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</source>
          <target state="translated">The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</target>
        </trans-unit>
        <trans-unit id="acc0cc776eb12ee2c880638b893d5b55050e39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; response HTTP header provides a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; 応答HTTPヘッダーが提供&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;ダイジェスト&lt;/a&gt;要求されたリソースのを。</target>
        </trans-unit>
        <trans-unit id="2e78b75471626ac2160cc198bfd26d8ad9f80eb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediary to indicate that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and also indicates that the intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; ヘッダは、要求がで搬送されたことを示すために、仲介によって設定されている&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS初期データを&lt;/a&gt;、また中間に理解していることを示し&lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt;ステータスコード。</target>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; ヘッダは、中間にすることによって設定される要求に搬送されたことを示す&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS初期データを&lt;/a&gt;、さらに中間が理解ことを示す&lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt;ステータスコード。 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; ヘッダ（すなわち、ブラウザ）要求の発信者によって設定されていません。</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; ヘッダは応答が古くなったとみなされた後の日付/時刻を含みます。</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; のリクエストヘッダには、要求元のユーザエージェントを制御し、人間のユーザのためのインターネット電子メールアドレスが含まれています。</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; リクエストヘッダは、サーバーが受信しているTCPポート番号を（仮想ホスティング用）サーバーのドメイン名を指定し、（任意で）。</target>
        </trans-unit>
        <trans-unit id="1d90ed71aec05b79116744d2cf8473e3277dfbc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the host and port number of the server to which the request is being sent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 要求ヘッダーは、要求が送信されているサーバのホストとポート番号を指定します。</target>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 一般的なヘッダは、送信者がどのように接続し、タイムアウトと要求の最大量を設定するために使用することができるに関するヒントを可能にします。</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 一般的なヘッダは、送信者は、接続がタイムアウトし、要求の最大量を設定するために使用することができる方法に関するヒントを可能にします。</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP / 1.0一般的なヘッダは、要求-応答チェーンに沿って様々な効果を有することができる実装固有のヘッダです。 &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1ヘッダーがまだ存在しないHTTP / 1.0キャッシュとの下位互換性のために使用されます。</target>
        </trans-unit>
        <trans-unit id="df9c97c4ad9d61f0d260427224fcdc949c7f1596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the page making the request. When following a link, this would be the url of the page containing the link. When making AJAX requests to another domain, this would be your page's url. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; リクエストヘッダには、要求を行ったページのアドレスが含まれています。リンクをたどる場合、これはリンクを含むページのURLになります。別のドメインにAJAXリクエストを行う場合、これはページのURLになります。 &lt;code&gt;Referer&lt;/code&gt; ヘッダーには、サーバは、人々がからそれらを訪問している場所を特定し、例えば、分析、ロギング、または最適化されたキャッシュのためにそのデータを使用することができます。</target>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; リクエストヘッダは、現在、要求されたページへのリンクが続いたから、前のウェブページのアドレスが含まれています。 &lt;code&gt;Referer&lt;/code&gt; ヘッダーには、サーバは、人々がからそれらを訪問している場所を特定し、例えば、分析、ロギング、または最適化されたキャッシュのためにそのデータを使用することができます。</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; ヘッダーは、リクエストを処理するためにオリジンサーバによって使用されているソフトウェアに関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="d1b3c683e4cd677dc3be26bd03213dd34909bab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header describes the software used by the origin server that handled the request &amp;mdash; that is, the server that generated the response.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; は、応答を生成したサーバである-ヘッダは、要求を処理し、オリジンサーバが使用するソフトウェアを記述する。</target>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; のリクエストヘッダは、ユーザエージェントが受け入れても構わないと思っている転送エンコーディングを指定します。（非公式に&lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt;と呼ぶこともできます。より直感的です）。</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; の機能を介して検索された属性の値を参照することが許可されているレスポンスヘッダ指定起源&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;リソースタイミングAPI&lt;/a&gt;さもなければによるクロスオリジン制限をゼロとして報告されます。</target>
        </trans-unit>
        <trans-unit id="459b5cbc88f2c6244c84b2b7cf57687d4fed7e90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; status code indicates an internal server configuration error in which the chosen variant is itself configured to engage in content negotiation, so is not a proper negotiation endpoint.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 状態コードので、選択された変異体は、それ自体がコンテンツネゴシエーションに係合するように構成された内部サーバー構成エラーを示す適切な交渉エンドポイントではありません。</target>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; 一般的なヘッダは両方フォワードおよびリバースプロキシは、プロキシによって追加され、要求ヘッダーと応答ヘッダーに表示されることができます。これは、メッセージ転送の追跡、要求ループの回避、および要求/応答チェーンに沿った送信者のプロトコル機能の識別に使用されます。</target>
        </trans-unit>
        <trans-unit id="519d7e47665e940480525b25780c7db7b6681325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP header is primarily used in a HTTP request, to ask the responder to provide a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource using the &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; response header.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTPヘッダは、主に提供するために、応答者に依頼する、HTTPリクエストで使用されている&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;ダイジェスト&lt;/a&gt;使用して要求されたリソースの &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; レスポンスヘッダを。</target>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; 応答HTTPヘッダーことを示すためにサーバによって使用されるマーカーである&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;でアドバタイズ&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;ヘッダは変更されるべきではないと続くこと。これにより、&lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIMEタイプのスニッフィング&lt;/a&gt;をオプトアウトできます。つまり、Webマスターが何をしていたかを知っていたと言えます。</target>
        </trans-unit>
        <trans-unit id="cd7aecd4c1fd5dec57a2c138b3e5a8c117d9036d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This is a way to opt out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, to say that the MIME types are deliberately configured.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; 応答HTTPヘッダーことを示すためにサーバによって使用されるマーカーである&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;でアドバタイズ&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;ヘッダは変更されるべきではないと続くこと。これは、&lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIMEタイプのスニッフィング&lt;/a&gt;をオプトアウトする方法、つまり、MIMEタイプが意図的に構成されていることを示す方法です。</target>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">UA文字列の &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分は、Firefoxが携帯電話サイズまたはタブレットデバイスで実行されているかどうかを示します。Firefoxが電話のフォームファクターを備えたデバイスで実行されている場合、 &lt;code&gt;Mobile;&lt;/code&gt; が存在します。UA文字列の &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分のトークン。Firefoxがタブレットデバイスで実行されている場合、 &lt;code&gt;Tablet;&lt;/code&gt; 代わりに、UA文字列の &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分のトークン。例えば：</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="2cb1ca877d3eb1b0f248f74c9ec40232997e5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;character encodings&lt;/a&gt; the client understands. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the encodings, uses it, and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header, usually in a &lt;code&gt;charset=&lt;/code&gt; parameter. Browsers usually don't send this header, as the default value for each resource is usually correct and transmitting it would allow &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;fingerprinting&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; 要求HTTPヘッダアドバタイズ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;文字が符号化方式において&lt;/a&gt;、クライアントが理解しています。使用し&lt;a href=&quot;../content_negotiation&quot;&gt;たコンテンツの交渉&lt;/a&gt;では、エンコーディングのサーバーを一つ選択を使用し、内部にその選択肢のクライアントに通知&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;通常Aで、レスポンスヘッダ &lt;code&gt;charset=&lt;/code&gt; パラメータ。各リソースのデフォルト値は通常正しく、送信すると&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;フィンガープリント&lt;/a&gt;が許可されるため、ブラウザは通常このヘッダーを送信しません。</target>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; HTTPヘッダーアドバタイズクライアントが理解することができますどの文字セットを要求します。次に、サーバーは&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;を使用して提案の1つを選択し、それを使用して、クライアントに&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;応答ヘッダー内の選択を通知します。各コンテンツタイプのデフォルト値は通常正しいため、ブラウザは通常このヘッダーを設定しません。送信するとフィンガープリントが容易になります。</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; HTTPヘッダアドバタイズコンテンツ符号化要求は、通常の圧縮アルゴリズムは、クライアントが理解することができます。&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;を使用して、サーバーは提案の1つを選択し、それを使用して、&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;応答ヘッダーでその選択をクライアントに通知します。</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; HTTPヘッダアドバタイズどの言語クライアントが理解することができ、そしてどのロケールバリアントが好ましい要求。（言語とは、プログラミング言語ではなく、英語などの自然言語を意味します。）次に、サーバーは&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;を使用して提案の1つを選択し、それを使用して、クライアントに&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;応答ヘッダーでその選択を通知します。ブラウザは、ユーザーインターフェースの言語に応じてこのヘッダーに適切な値を設定します。ユーザーがヘッダーを変更できる場合でも、まれにしか発生しません（フィンガープリントの作成につながるため、不快になります）。</target>
        </trans-unit>
        <trans-unit id="f1d16f67263a6c86cf3fcdfef1e4b190e49a0296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Patch&lt;/code&gt; response HTTP header advertises which media-type the server is able to understand in a PATCH request.</source>
          <target state="translated">&lt;code&gt;Accept-Patch&lt;/code&gt; サーバパッチ要求に理解することができるメディアタイプ応答HTTPヘッダ広告します。</target>
        </trans-unit>
        <trans-unit id="6003efca5251790ce42906144c5dccf2f87ad99b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Post&lt;/code&gt; response HTTP header advertises which &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;media types&lt;/a&gt; are accepted by the server for HTTP post requests.</source>
          <target state="translated">&lt;code&gt;Accept-Post&lt;/code&gt; レスポンスHTTPヘッダーアドバタイズ&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;メディアタイプは、&lt;/a&gt; HTTP POSTリクエストのためにサーバーによって受け入れられています。</target>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; ように表さコンテンツタイプ、要求HTTPヘッダアドバタイズ&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIMEタイプは&lt;/a&gt;、クライアントが理解することができます。次に、サーバーは&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;を使用して提案の1つを選択し、それを使用して、&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;応答ヘッダーでその選択をクライアントに通知します。ブラウザは、リクエストが行われるコンテキストに応じて、このヘッダーに適切な値を設定します。CSSスタイルシートをフェッチするとき、画像、ビデオ、またはスクリプトをフェッチするときとは異なる値がリクエストに設定されます。</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; と連携して動作し、ヘッダ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; の&lt;/a&gt;プロパティまたはで &lt;code&gt;credentials&lt;/code&gt; 中にオプション&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt;取得APIのコンストラクタを。資格情報を含むCORSリクエストの場合、ブラウザーがフロントエンドJavaScriptコードに応答を公開するには、サーバー（ &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; ヘッダーを使用）とクライアント（XHR、Fetch、またはAjaxリクエスト）は、資格情報を含めることを選択していることを示す必要があります。</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; レスポンスヘッダは、要求に対する応答がページに露出させることができるか否かを示します。 &lt;code&gt;true&lt;/code&gt; 値が返されたときに公開できます。</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; のレスポンスヘッダには、要求の資格情報モード（ときJavaScriptコードをフロントエンドに応答を公開するかどうかをブラウザ伝え&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; が&lt;/a&gt;）「である &lt;code&gt;include&lt;/code&gt; 」。</target>
        </trans-unit>
        <trans-unit id="f12c8be59963d49889bc73472fd35b514c851a07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; のレスポンスヘッダには、要求の資格情報モード（ときJavaScriptコードをフロントエンドに応答を公開するかどうかをブラウザ伝え&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; が&lt;/a&gt;）である &lt;code&gt;include&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダは、に応答してサーバによって送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求&lt;/a&gt;。CORSリクエストで許可されている&lt;a href=&quot;../../headers&quot;&gt;HTTPヘッダーを&lt;/a&gt;クライアントに通知します。クライアント&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;が、ヘッダーによって提供されるコンマ区切りの値の中で、認識できないヘッダー名を見つけた場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="0864906322164b5b88f217b19f6a18996814ca0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &quot;&lt;code&gt;X-Custom-Information&lt;/code&gt;&quot; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダは、それがためにサポートしているヘッダのクライアントに知らせるために、サーバによって送信される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;要求を。 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; の値は、「 &lt;code&gt;X-Custom-Information&lt;/code&gt; 」などのヘッダー名のコンマで区切られたリスト、または標準であるが基本的ではないヘッダー名（常に許可されている）である必要があります。</target>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダは、それがためにサポートしているヘッダのクライアントに知らせるために、サーバによって送信される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORSの&lt;/a&gt;要求を。 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; の値は、 &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; などのヘッダー名のコンマ区切りのリスト、または標準であるが基本ではないヘッダー名（常に許可されている）である必要があります。</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 応答ヘッダはに応じて使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求&lt;/a&gt;含む&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; HTTPヘッダが実際の要求の間に使用することができるかを示すために。</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; ヘッダはどのクライアントに知らせるために、サーバによって送信された&lt;a href=&quot;../../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;、それはCORS要求をサポートしています。ヘッダーの値は、&lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;など、HTTPメソッド名のコンマ区切りの文字列です。指定された値のいずれかがクライアント&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;によって認識されない場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; に応答してリソースにアクセスするときの方法または方法が許可レスポンスヘッダ指定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 応答ヘッダはヘッダが自分の名前をリストすることによって、応答の一部として公開することができるかを示します。</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; レスポンスヘッダは、どのくらいの結果を示し&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;、プリフライト要求&lt;/a&gt;（に含まれる情報であり、&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;キャッシュできるヘッダー）。</target>
        </trans-unit>
        <trans-unit id="d911724c3b9a4293a98fa691e196743b5241679f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; the client might send when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 発行時にリクエストヘッダは、ブラウザで使用された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライトリクエストを&lt;/a&gt;サーバ知っているように、&lt;a href=&quot;../headers&quot;&gt;HTTPヘッダーの&lt;/a&gt;実際の要求が行われたときに、クライアントが送信することがありますが。</target>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 発行時に要求ヘッダが使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求&lt;/a&gt;サーバ知らせるために&lt;a href=&quot;../headers&quot;&gt;HTTPヘッダの&lt;/a&gt;実際の要求が行われたときに使用されるが。</target>
        </trans-unit>
        <trans-unit id="da80f865ca3264cb02c6582db1c71f9050cac42c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 発行する際、要求ヘッダーがブラウザによって使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求を&lt;/a&gt;サーバ知っているように、&lt;a href=&quot;../methods&quot;&gt;HTTPメソッド&lt;/a&gt;実際の要求が行われたときに使用されるが。プリフライトリクエストは常に&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; で&lt;/a&gt;あり、実際のリクエストと同じメソッドを使用しないため、このヘッダーが必要です。</target>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 発行時要求ヘッダが使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;プリフライト要求&lt;/a&gt;サーバ知らせるために&lt;a href=&quot;../methods&quot;&gt;HTTPメソッド&lt;/a&gt;実際の要求が行われたときに使用されるが。プリフライトリクエストは常に&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;あり、実際のリクエストと同じメソッドを使用しないため、このヘッダーは必須です。</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">&lt;code&gt;Age&lt;/code&gt; ヘッダーは通常ゼロに近いです。 &lt;code&gt;Age: 0&lt;/code&gt; 場合、おそらく元のサーバーからフェッチされただけです。それ以外の場合は、通常、プロキシの現在の日付とHTTP応答に含まれている&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;汎用ヘッダーとの差として計算されます。</target>
        </trans-unit>
        <trans-unit id="86a92479e304493df13e1947522f656380ef064d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; HTTPレスポンスヘッダは、同じリソースに到達できる代替サービスを宣伝するために使用されます。代替サービスは、プロトコル/ホスト/ポートの組み合わせによって定義されます。</target>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; ヘッダは、このウェブサイトに到達するために、リストの代替の方法に使用されています。</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; の方法は、対象リソースによって識別されるサーバにトンネルを確立します。</target>
        </trans-unit>
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; の方法は、要求されたリソースとの双方向通信を開始します。トンネルを開くために使用できます。</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; は、要求されたリソースとの双方向通信を開始します。トンネルを開くために使用できます。</target>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; HTTPヘッダは、保持&lt;em&gt;指令&lt;/em&gt;のため（命令）&lt;a href=&quot;../caching&quot;&gt;キャッシュ&lt;/a&gt;要求と応答の両方です。リクエスト内の特定のディレクティブは、同じディレクティブがレスポンス内にある必要があることを意味するものではありません。</target>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 一般ヘッダフィールドは、要求と応答の両方でのメカニズムをキャッシュするためのディレクティブを指定するために使用されます。キャッシュディレクティブは単方向です。つまり、要求内の特定のディレクティブは、応答で同じディレクティブが提供されることを意味していません。</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-control&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダには、一の以上のディレクティブを受け付けます。すべてのタイプのデータをクリアする必要がある場合は、ワイルドカードディレクティブ（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダには、要求元のウェブサイトに関連したデータ（クッキー、ストレージ、キャッシュ）を閲覧クリア。これにより、Web開発者は、ブラウザによってローカルに保存されたデータを、その出所についてより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; ネットワーク接続ステーは、現在のトランザクションが終了した後に開くかどうか、一般的なヘッダコントロール。送信された値が &lt;code&gt;keep-alive&lt;/code&gt; の場合、接続は永続的で閉じられないため、同じサーバーへの後続の要求を実行できます。</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; ヘッダに設定されている &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; のアップグレードが要求されていることを示します。</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; ヘッダーは、電子メールのMIMEメッセージのより大きなコンテキストに定義されているが、可能なパラメータのサブセットだけがHTTP形式とに適用される&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;リクエスト。値 &lt;code&gt;form-data&lt;/code&gt; 、およびオプションのディレクティブ &lt;code&gt;name&lt;/code&gt; と &lt;code&gt;filename&lt;/code&gt; HTTPコンテキストで使用できるのです。</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; エンティティヘッダは、メディアタイプを圧縮するために使用されます。存在する場合、その値はエンティティ本体に適用されたエンコーディングを示します。これにより、クライアントは、 &lt;code&gt;Content-Type&lt;/code&gt; ヘッダーによって参照されるメディアタイプを取得するためにデコードする方法を知ることができます。</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; ヘッダを指定するために使用されている&lt;strong&gt;ページの対象読者を&lt;/strong&gt;、そしてこれは、複数の言語であることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;エンティティヘッダを&lt;/a&gt;するために使用される&lt;strong&gt;言語（複数可）を記述聴衆のために意図され&lt;/strong&gt;、それは、ユーザがユーザ自身の言語に応じて区別することを可能にするように、。</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;エンティティヘッダは&lt;/a&gt;、ユーザがユーザ自身の言語に応じて区別することを可能にするように、視聴者のために意図される言語（複数可）を記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; エンティティヘッダは、受信者に送信された、バイト単位で、エンティティボディのサイズを示します。</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; ヘッダは、返されたデータのために別の場所を示しています。主な用途は、&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーションの&lt;/a&gt;結果として送信されるリソースのURLを示すことです。</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; 全身メッセージに部分的メッセージが属するところ応答HTTPヘッダが示します。</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;strong&gt;&lt;dfn&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/dfn&gt;&lt;/strong&gt;HTTPレスポンスヘッダフィールドは、原点のためのエンドポイントを報告ストアにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; エンティティヘッダを示すために使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;メディアタイプ&lt;/a&gt;のリソースを。</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; HTTPリクエストヘッダが格納されている含ま&lt;a href=&quot;../cookies&quot;&gt;HTTPクッキー&lt;/a&gt;以前とサーバーによって送信された&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;ヘッダを。</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; ヘッダは任意であり、例えば、ブラウザのプライバシー設定がクッキーをブロックし、あれば省略してもよいです。</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; は、指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; メソッドは、指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; （&lt;strong&gt;D&lt;/strong&gt; O &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt;リクエストヘッダラック）は、ユーザの追跡嗜好を示しています。ユーザーは、パーソナライズされたコンテンツではなくプライバシーを好むかどうかを指定できます。</target>
        </trans-unit>
        <trans-unit id="1cd717754d93b6be80da07e08c9fb1185b7e6942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DPR&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers which represents the client device pixel ratio (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;), which is the the number of physical device pixels corresponding to every CSS pixel.</source>
          <target state="translated">&lt;code&gt;DPR&lt;/code&gt; のヘッダは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;クライアントヒント&lt;/a&gt;クライアント装置画素比率（表しヘッダ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;毎CSSピクセルに対応する物理デバイスの画素数です）。</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 一般的なHTTPヘッダは、メッセージが発信された日時を含んでいます。</target>
        </trans-unit>
        <trans-unit id="2eebea2d9e6a6d288555a242f73a9f9b00abe276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Device-Memory&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;Device Memory API&lt;/a&gt; header that works like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; header which represents the approximate amount of RAM client device has.</source>
          <target state="translated">&lt;code&gt;Device-Memory&lt;/code&gt; ヘッダは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;デバイスメモリAPIの&lt;/a&gt;様に動作することをヘッダ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;クライアントヒント&lt;/a&gt;RAMクライアントデバイスの概算を表すヘッダを有します。</target>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; と &lt;code&gt;Path&lt;/code&gt; 属性が定義&lt;em&gt;スコープ&lt;/em&gt;クッキーが送信されるべきかのURL：クッキーのを。</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; と &lt;code&gt;Path&lt;/code&gt; のディレクティブは定義&lt;em&gt;スコープ&lt;/em&gt;クッキーが送信されるべきかのURL：クッキーのを。</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; ホストがクッキーの受信を許可されている属性を指定します。指定しない場合、&lt;em&gt;サブドメインを除い&lt;/em&gt;て、デフォルトでCookieを設定したのと同じ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;オリジンに&lt;/a&gt;なります。場合は &lt;code&gt;Domain&lt;/code&gt; &lt;em&gt;されて&lt;/em&gt;指定された場合、サブドメインが常に含まれています。したがって、 &lt;code&gt;Domain&lt;/code&gt; 指定は、それを省略するよりも制限が少なくなります。ただし、サブドメインがユーザーに関する情報を共有する必要がある場合に役立ちます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; を HTTPレスポンスヘッダは、リソースの特定のバージョンの識別子です。コンテンツが変更されていない場合、Webサーバーは完全な応答を送信する必要がないため、キャッシュの効率が向上し、帯域幅が節約されます。一方、コンテンツが変更された場合、etagはリソースの同時更新が互いに上書きすることを防ぐのに役立ちます（「空中衝突」）。</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; をHTTPレスポンスヘッダは、リソースの特定のバージョンの識別子です。コンテンツが変更されていない場合、Webサーバーは完全な応答を再送信する必要がないため、キャッシュの効率が向上し、帯域幅が節約されます。さらに、etagは、リソースの同時更新が相互に上書きするのを防ぐのに役立ちます（&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;「空中衝突」&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;Early-Data&lt;/code&gt; ヘッダはされ&lt;strong&gt;ていない&lt;/strong&gt;（すなわち、ブラウザ）要求の発信者によって設定されました。</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、報告および/または見過ごさ行くから、そのサイトのmisissued証明書の使用を防止証明書の透明性要件の施行にオプトインにサイトを可能にします。</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、報告および/または見過ごさ行くから、そのサイトのmisissued証明書の使用を防止証明書の透明性要件の施行にオプトインにサイトを可能にします。サイトが &lt;code&gt;Expect-CT&lt;/code&gt; ヘッダーを有効にすると、サイトの証明書がパブリックCTログに表示されることをブラウザーが確認するように要求されます。</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、サイトが報告および/またはの施行に選ぶことができます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;気付かないだろうから、そのサイトのmisissued証明書の使用を防ぐために、要件。</target>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; おそらく新しい証明書がデフォルトでのSCTをサポートすることが期待される2018年5月以来6月2021で廃止となります。2018年3月より前の証明書の有効期間は39か月でしたが、これらはすべて2021年6月に期限切れになります。</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; HTTPリクエストヘッダが必要にリクエストを適切に処理するために、サーバーによって果たされることを期待を示しています。</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">&lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーが今に改名された &lt;code&gt;Permissions-Policy&lt;/code&gt; 仕様で、この記事では、最終的にその変更を反映するために更新されます。</target>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; ヘッダからの情報が含まれている&lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;リバースプロキシサーバ&lt;/a&gt;プロキシが要求の経路に関与しているときに変更または失われます。</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; ヘッダは、プロキシが要求の経路に関与しているときに変更または失われたプロキシサーバのクライアントに面する側からの情報を含みます。</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; の方法は、指定されたリソースの表現を要求します。 &lt;code&gt;GET&lt;/code&gt; を使用したリクエストは、データのみを取得します。</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; は、指定されたリソースの表現を要求します。 &lt;code&gt;GET&lt;/code&gt; を使用したリクエストは、データのみを取得します。</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; の方法は、と同一の応答を要求する &lt;code&gt;GET&lt;/code&gt; の要求が、応答本体はありません。</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; は、要求&lt;a href=&quot;../headers&quot;&gt;のヘッダー&lt;/a&gt;場合に返される &lt;code&gt;HEAD&lt;/code&gt; リクエストのURLが代わりにHTTPで要求された&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドを。たとえば、URLが大量のダウンロードを生成する可能性がある場合、 &lt;code&gt;HEAD&lt;/code&gt; リクエストは、実際にファイルをダウンロードせずに、&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダーを読み取ってファイルサイズを確認できます。</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; は、指定されたリソースがHTTPで要求されるかどう返されるヘッダーを要求&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドを。このような要求は、たとえば、帯域幅を節約するために大きなリソースをダウンロードすることを決定する前に行うことができます。</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; の Cookieの属性では、JavaScriptによるCookieの値へのアクセスを防止することによって、この攻撃を軽減することができます。</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; HTTPリクエストヘッダは、要求条件になります。以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッドは、サーバは、それが記載されているのいずれかと一致する場合にのみ、要求されたリソースを送り返します &lt;code&gt;ETags&lt;/code&gt; 。以下のために&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;や他の非安全な方法で、それだけで、この場合にリソースをアップロードします。</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;If-Modified-Since&lt;/code&gt; リクエストHTTPヘッダー要求条件を作る：サーバーはと、要求されたリソースを送り返します&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;それが最後の指定した日付以降に変更された場合にのみ、ステータスが表示されます。それ以降にリクエストが変更されていない場合、レスポンスは本文なしの&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt;になります。前のリクエストの&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;レスポンスヘッダーには、最終変更日が含まれます。&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;If-Modified-Since&lt;/code&gt; は&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; HTTPリクエストヘッダは、要求条件になります。以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッドは、サーバーはと、要求されたリソースを送り返します&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;それは持っていない場合にのみ、ステータス&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与えられたものに一致します。他のメソッドの場合、要求は、最終的に存在するリソースの&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がリストされている値のいずれとも一致しない場合にのみ処理されます。</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; HTTPリクエストヘッダには、範囲の要求条件になり：条件が満たされた場合、範囲の要求が発行され、サーバが送り返す&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; の適切なボディとの回答を。条件が満たされない場合、リソース全体が&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ステータスで返送されます。</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 要求のHTTPヘッダは、要求条件になり：サーバは、要求されたリソースを送り返し、またはの場合にはそれを受け入れる&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;または別の非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;、与えられた後に最後に変更されていない場合にのみ、方法日付。指定した日付以降にリクエストが変更された場合、レスポンスは&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（Precondition Failed）エラーになります。</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 要求のHTTPヘッダは、要求条件になり：サーバは、要求されたリソースを送り返し、またはの場合にはそれを受け入れる&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;または別の非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;、与えられた後に最後に変更されていない場合にのみ、方法日付。指定された日付以降にリソースが変更された場合、レスポンスは&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（Precondition Failed）エラーになります。</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 誤って使用した場合、ヘッダは、警告またはエラーメッセージをスロー。それらは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;Webコンソール&lt;/a&gt;で発生します。</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; の応答HTTPヘッダーは、オリジンサーバがリソースが最後に変更されたと考えていた日付と時刻が含まれています。これは、受信または保存されたリソースが同じであるかどうかを判断するバリデーターとして使用されます。&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ヘッダーよりも精度が低く、フォールバックメカニズムです。&lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;ヘッダーを含む条件付きリクエストは、このフィールドを利用します。</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; レスポンスヘッダがにページをリダイレクトするURLを示します。これは、 &lt;code&gt;3xx&lt;/code&gt; （リダイレクト）または &lt;code&gt;201&lt;/code&gt; （作成済み）ステータス応答が提供されたときにのみ意味を提供します。</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; は、ターゲット・リソースのための通信オプションを記述するために使用されます。クライアントは、OPTIONSメソッドのURL、またはサーバー全体を参照するアスタリスク（*）を指定できます。</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; の方法は、ターゲット・リソースの通信オプションを記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; の要求が与えられたURLやサーバーの通信オプションを可能にしました。クライアントは、このメソッドを使用してURLを指定するか、サーバー全体を参照するためにアスタリスク（ &lt;code&gt;*&lt;/code&gt; ）を指定できます。</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; 由来フェッチ場所要求ヘッダが示します。パス情報は含まれず、サーバー名のみが含まれます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;リクエストと&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストで送信されます。これは、&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーに似ていますが、このヘッダーとは異なり、パス全体を開示しません。</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; は、リソースへの部分的な修正を適用します。</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; の方法は、リソースへの部分的な変更を適用するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; の方法は、多くの場合、サーバー上の状態または副作用の変化を引き起こして、指定されたリソースへのエンティティを提出するために使用されます。</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; は、サーバーにデータを送信します。リクエストの&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;は、Content-Typeヘッダーで示されます。</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; は、新しいリソースを作成したり、要求ペイロードを持つターゲット・リソースの表現に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; の方法は、要求ペイロードを持つ対象リソースの現在のすべての表現を置き換えます。</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 属性は、送信するために要求されたURLに存在している必要がありますURLパスを示している &lt;code&gt;Cookie&lt;/code&gt; ヘッダを。 &lt;code&gt;%x2F&lt;/code&gt; （「/」）文字は、ディレクトリセパレータとみなされ、サブディレクトリも一致しています。</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; ヘッダは一緒に送信される&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTPリクエストヘッダは、サーバが返すべきであることを文書の一部を示しています。 1つの &lt;code&gt;Range&lt;/code&gt; ヘッダーで一度に複数の部分を要求でき、サーバーはこれらの範囲をマルチパートドキュメントで送り返すことができます。サーバーが範囲を送り返す場合、サーバーは応答に&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; を使用します。範囲が無効な場合、サーバーは&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Range Not Satisfiable&lt;/code&gt; エラーを返します。サーバーは、 &lt;code&gt;Range&lt;/code&gt; ヘッダーを無視して、&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;ステータスコードを含むドキュメント全体を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTPリクエストヘッダは、サーバが返すべきであることを文書の一部を示しています。一度に1つの &lt;code&gt;Range&lt;/code&gt; ヘッダーで複数のパートを要求でき、サーバーはこれらの範囲をマルチパートドキュメントで送り返すことができます。サーバーが範囲を返送する場合、サーバーはレスポンスに&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; を使用します。範囲が無効な場合、サーバーは&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; エラーを返します。サーバーは &lt;code&gt;Range&lt;/code&gt; ヘッダーを無視して、ステータスコード&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;ドキュメント全体を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; に送信されたHTTPヘッダ支配リファラ情報、&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーは、行われた要求に含まれるべきです。</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTPヘッダー&lt;/a&gt;コントロールがどのくらいの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;リファラ情報&lt;/a&gt;（経由して送信された&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダ）リクエストに含まれるべきです。</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; 応答HTTPヘッダーには、ユーザエージェントはフォローアップ要求を行う前に待機する時間を示しています。このヘッダーが使用される主なケースは3つあります。</target>
        </trans-unit>
        <trans-unit id="cd701418d7c6bf62926c6ad09e3776653cf803d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute accepts three values:</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 属性には、三つの値を受け付けます。</target>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; の属性は、サーバがクッキーを（クロスオリジン・リクエストを送信しないことを要求することができます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;サイトは&lt;/a&gt;、クロスサイトリクエストフォージェリ攻撃に対する何らかの保護（提供登録できるドメインによって定義される）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRFを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c183288b7bfb9b7d64e4bb9f606b605293a750ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute of the &lt;a href=&quot;../set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header allows you to declare if your cookie should be restricted to a first-party or same-site context.</source>
          <target state="translated">&lt;a href=&quot;../set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTP応答ヘッダーの &lt;code&gt;SameSite&lt;/code&gt; 属性を使用すると、Cookieをファーストパーティまたは同じサイトのコンテキストに制限する必要があるかどうかを宣言できます。</target>
        </trans-unit>
        <trans-unit id="ff9a7daddb986f8f3e9947219b02e125a02e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Save-Data&lt;/code&gt; header field is a boolean which, in requests, indicates the client's preference for reduced data usage. This could be for reasons such as high transfer costs, slow connection speeds, etc.</source>
          <target state="translated">&lt;code&gt;Save-Data&lt;/code&gt; ヘッダフィールドは、リクエストに、減少したデータを使用するため、クライアントの好みを示し、ブール値です。これは、転送コストが高い、接続速度が遅いなどの理由である可能性があります。</target>
        </trans-unit>
        <trans-unit id="c5c50e0dbd49e9be339d0014ff98de27f5af6b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; fetch metadata header indicates the request's destination, that is how the fetched data will be used.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; メタデータヘッダがフェッチされたデータが使用される方法であり、リクエストの宛先を示すフェッチ。</target>
        </trans-unit>
        <trans-unit id="31f9900ebfdde4aa1830afd97db024c6b3f830be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; fetch metadata header indicates the request's mode.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; メタデータヘッダは、要求のモードを示すフェッチ。</target>
        </trans-unit>
        <trans-unit id="25babdcd9266b9b2ebf26be60ebc0d7bfea878a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Site&lt;/code&gt; fetch metadata header indicates the relationship between a request initiator's origin and the origin of the resource.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Site&lt;/code&gt; メタデータヘッダは、要求イニシエータの起源と資源の起源との関係を示すフェッチ。</target>
        </trans-unit>
        <trans-unit id="ea3db281f732bb94a4a366b08b7f44ee831dbefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-User&lt;/code&gt; fetch metadata header indicates whether or not a navigation request was triggered by a user activation.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-User&lt;/code&gt; メタデータヘッダは、ナビゲーション要求は、ユーザの活性化によってトリガされたか否かを示すフェッチ。</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">&lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; のヘッダを指定しますが、優先順に、使用したいことを一の以上のWebSocketプロトコル。サーバーによってサポートされる最初の1つが選択され、サーバーは応答に含まれる &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; ヘッダーでそれを返します。ヘッダーでもこれを複数回使用できます。結果は、単一のヘッダーでサブプロトコル識別子のコンマ区切りのリストを使用した場合と同じです。</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダは、与えられた要求応答サイクルのための1つ以上のメトリックおよび説明を通信します。これは、ユーザーのブラウザーまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;インターフェイスの開発者ツールで、バックエンドサーバーのタイミングメトリック（データベースの読み取り/書き込み、CPU時間、ファイルシステムアクセスなど）を表示するために使用されます。</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダは、潜在的に敏感なアプリケーションとインフラ情報を公開することができます。サーバー側でいつどのユーザーにどのメトリックを返すかを制御することを検討してください。たとえば、認証されたユーザーにのみ指標を表示し、一般には公開しないことができます。</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTPレスポンスヘッダは、ユーザエージェントが後でサーバに送信できるように、ユーザーエージェントにサーバからクッキーを送信するために使用されます。複数のCookieを送信するには、同じ応答で複数の &lt;code&gt;Set-Cookie&lt;/code&gt; ヘッダーを送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTPレスポンスヘッダは、ユーザエージェントにサーバーからのCookieを送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; と &lt;code&gt;Cookie&lt;/code&gt; のヘッダー</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">&lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;レスポンスヘッダは、生成したコードをリンクする&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;ソースマップ&lt;/a&gt;元のソースを復元し、デバッガで再構成された原稿を提示するためにブラウザを可能にします。</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; （多くの場合と略記レスポンスヘッダ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTSは&lt;/a&gt;）は、WebサイトがHTTPSを使用して、代わりにHTTPを使用して、それがのみアクセスする必要があることをブラウザに伝えることができます。</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; の方法は、ターゲットリソースへの経路に沿ってメッセージループバックテストを行います。</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; は、有用なデバッグ機構を提供する、ターゲットリソースへの経路に沿ってメッセージループバックテストを行います。</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; のレスポンスヘッダは、対応する要求に適用されるトラッキング状態を示しています。</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; ヘッダ指定安全に転送するために使用される符号化の形&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;エンティティを&lt;/a&gt;ユーザに。</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; ヘッダ指定安全に転送するために使用される符号化の形&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;ペイロード本体を&lt;/a&gt;ユーザに。</target>
        </trans-unit>
        <trans-unit id="4e4d1816f1bb2e8b52d94106ccb83a944a14eca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header field may be used by clients to invite a server to switch to one (or more) of the listed protocols, in descending preference order.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; ヘッダフィールドは、優先順位の降順でリストされているプロトコルの1つ（または複数）に切り替えるサーバーを招待するためにクライアントによって使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; 優先順にヘッダ指定一つ以上のカンマで区切られたプロトコル名、。</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; HTTPレスポンスヘッダは、キャッシュされた応答は、オリジンサーバからの新鮮なものを要求するのではなく使用することができるかどうかを決定するために、将来のリクエストヘッダを一致させる方法を決定します。これはサーバーによって使用され、&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;アルゴリズムでリソースの表現を選択するときに使用したヘッダーを示します。</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダは、デスクトップおよびモバイルユーザーに異なるコンテンツを提供するために有用であることができ、または検索エンジンがページのモバイル版を発見（そしておそらくも何のことを伝えできるようにするために&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;クローキングが&lt;/a&gt;意図されていません）。これは通常、 &lt;code&gt;Vary: User-Agent&lt;/code&gt; ヘッダーで実現され、&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;ヘッダーの値がモバイルクライアントとデスクトップクライアントで異なるために機能します。</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダーが上で設定する必要があります&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 、それは同等に設定されているとまったく同じように応答&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 応答。</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダはHTTPのバージョン1.1に加え、キャッシュが適切に動作させるために必要であるしました。キャッシュは、サーバー主導のコンテンツネゴシエーションで機能するために、送信されたコンテンツを選択するためにサーバーが使用した基準を知る必要があります。このようにして、キャッシュはアルゴリズムを再生でき、サーバーへの要求を増やすことなく、許容可能なコンテンツを直接提供できます。明らかに、ワイルドカード ' &lt;code&gt;*&lt;/code&gt; 'は、キャッシュが背後にある要素を認識できないため、キャッシュの発生を防ぎます。</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダはHTTPのバージョン1.1に加え、キャッシュが適切に動作させるために必要であるしました。キャッシュは、サーバー主導のコンテンツネゴシエーションを処理するために、送信されたコンテンツを選択するためにサーバーがどの基準を使用したかを知る必要があります。このようにして、キャッシュはアルゴリズムを再生でき、サーバーへの追加の要求なしに、受け入れ可能なコンテンツを直接提供できます。明らかに、ワイルドカード ' &lt;code&gt;*&lt;/code&gt; 'は、キャッシュが背後にある要素を認識できないため、キャッシュの発生を防ぎます。詳細については、&lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTPキャッシング&amp;gt;さまざまな応答&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; ヘッダを一緒に送信される&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 応答。</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; 一般的なHTTPヘッダは、メッセージのステータスを持つ可能性のある問題についての情報を含みます。応答に複数の &lt;code&gt;Warning&lt;/code&gt; ヘッダーが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="translated">&lt;code&gt;Width&lt;/code&gt; 要求ヘッダーフィールドは、物理ピクセルで所望のリソース幅（画像のすなわち固有サイズ）を示す番号です。提供されるピクセル値は、次の最小の整数に丸められた数値（つまり、上限値）です。</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; DNSはプリフェッチHTTPレスポンスヘッダコントロール、ブラウザは積極的にユーザが従うだけでなく、画像、CSSを含むドキュメントによって参照される項目のためのURLを選択することが両方のリンク上のドメイン名の解決を実行していることによって特徴、JavaScriptなど。</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; （XFF）ヘッダがHTTPプロキシまたはロードバランサを介してWebサーバに接続するクライアントの発信元IPアドレスを識別するための事実上の標準ヘッダです。クライアントとサーバーの間でトラフィックがインターセプトされると、サーバーアクセスログにはプロキシまたはロードバランサーのIPアドレスのみが含まれます。クライアントの元のIPアドレスを確認するには、 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 要求ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; （XFH）ヘッダは、クライアントによって要求元のホスト識別するための事実上の標準ヘッダで&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP要求ヘッダーを。</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; （XFP）ヘッダは、クライアントがプロキシまたはロードバランサに接続するために使用するプロトコル（HTTPまたはHTTPS）を識別するための事実上の標準ヘッダです。サーバーアクセスログには、サーバーとロードバランサー間で使用されるプロトコルが含まれますが、クライアントとロードバランサー間で使用されるプロトコルは含まれません。クライアントとロードバランサー間で使用されるプロトコルを決定するには、 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; リクエストヘッダーを使用できます。</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;応答ヘッダーは、ブラウザーがページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;のHTTP&lt;/a&gt;レスポンスヘッダは、ブラウザは、ページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;のHTTP&lt;/a&gt;レスポンスヘッダは、ブラウザは、ページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">&lt;code&gt;delta-seconds&lt;/code&gt; パラメータは、結果をキャッシュできる秒数を示します。</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; ディレクティブの構文は、他のディレクティブ（例えばのソースリストに類似している&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;）が、許可しない &lt;code&gt;'unsafe-eval'&lt;/code&gt; または &lt;code&gt;'unsafe-inline'&lt;/code&gt; たとえば。また、 &lt;code&gt;default-src&lt;/code&gt; 設定にフォールバックしません。以下にリストされているソースのみが許可されます。</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; ディレクティブの構文は、他のディレクティブのソースリスト（例えばに似ている&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;が、許可しない &lt;code&gt;'unsafe-eval'&lt;/code&gt; または &lt;code&gt;'unsafe-inline'&lt;/code&gt; たとえば。また、バックに落ちることはありません &lt;code&gt;default-src&lt;/code&gt; 設定。以下にリストされているソースのみが許可されます。</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="translated">&lt;code&gt;https://foo.example&lt;/code&gt; 原点が要求するために許可されている &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; 次を経由してURLを：</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; それ大文字小文字を区別しない、となります &lt;code&gt;mobi&lt;/code&gt; は一致するすべてのモバイルブラウザ。</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; パラメータを使用すると、Base64形式にエンコードしたいファイルの名前であり、そして &lt;code&gt;remotename&lt;/code&gt; 、実際に使用されていないファイルのためのリモート名である &lt;code&gt;data&lt;/code&gt; のURL。</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; ある&lt;a href=&quot;mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;のような文字列を、 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG画像ファイルのため。省略した場合、デフォルトは &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt; になります</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; のようなMIMEタイプ文字列であり、 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG画像ファイルのため。省略した場合のデフォルトは &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; MIMEタイプがブラウザに部分的な応答を送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 完了の値の送信時にタイプが使用可能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;なHTMLフォームを&lt;/a&gt;ブラウザからサーバに。</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 完了の値の送信時にタイプが使用可能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;なHTMLフォームを&lt;/a&gt;ブラウザからサーバに。</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="translated">&lt;code&gt;no-store&lt;/code&gt; ディレクティブはキャッシュされる新しいリソースを防ぐことができますが、それは以前の要求の結果として、キャッシュされた非古いリソースで応答からキャッシュを防ぐことはできません。 &lt;code&gt;max-age=0&lt;/code&gt; を設定すると、キャッシュが強制的に再検証されます（キャッシュがクリアされます）。</target>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payment&lt;/code&gt; 機能のデフォルトallowlist値は &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; な信頼を明示的にノンスまたはハッシュとそれに付随することで、マークアップ内のスクリプトの存在に与えられたことをソース式の指定は、そのルートスクリプトによってロードされたすべてのスクリプトに伝播されなければなりません。同時に、 &lt;code&gt;'self'&lt;/code&gt; や &lt;code&gt;'unsafe-inline'&lt;/code&gt; などの許可リストまたはソース式は無視されます。例については、&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; な信頼を明示的にノンスまたはハッシュとそれに付随することで、マークアップ内のスクリプトの存在に与えられたことをソース式の指定は、そのルートスクリプトによってロードされたすべてのスクリプトに伝播されなければなりません。同時に、 &lt;code&gt;'self'&lt;/code&gt; や &lt;code&gt;'unsafe-inline'&lt;/code&gt; などのホワイトリストまたはソース式は無視されます。例については、&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; ディレクティブの前に評価された&lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt;とそれが設定されている場合は、後者が効果的に何もしません。HTTPへのリダイレクト後に強制しないHTTPSを古いブラウザーで強制したい場合を除き、どちらか一方のディレクティブを設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; ディレクティブは、サードパーティのサイトにリンクを介してあなたのサイトを訪問するユーザーがトップレベルナビゲーションのためにHTTPSにアップグレードされますので、置き換えないことを保証しません&lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）ヘッダを、どのユーザーがSSLストリッピング攻撃を受けないようにするには、適切な &lt;code&gt;max-age&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">&lt;em&gt;HTTPバージョン&lt;/em&gt;応答に使用する予想バージョンの指標として作用する、残りのメッセージの構造を定義します。</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">&lt;em&gt;アスタリスク形状&lt;/em&gt;、単純なアスタリスク（ &lt;code&gt;'*'&lt;/code&gt; ）と一緒に使用される &lt;code&gt;OPTIONS&lt;/code&gt; 全体としてサーバを表します。</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;プロトコルのバージョン&lt;/em&gt;、通常は &lt;code&gt;HTTP/1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">&lt;em&gt;要求対象&lt;/em&gt;、通常&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;、またはプロトコル、ポート、およびドメインの絶対パスは、通常、リクエストコンテキストによって特徴付けられます。このリクエストターゲットの形式は、HTTPメソッドによって異なります。かもね</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;ユーザーエージェントは、&lt;/em&gt;ユーザーの代わりに作用する任意のツールです。この役割は主にWebブラウザによって実行されます。いくつかの例外は、エンジニアとWeb開発者がアプリケーションをデバッグするために使用するプログラムです。</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;ユーザーエージェントは、&lt;/em&gt;ユーザーの代わりに作用する任意のツールです。この役割は主にWebブラウザによって実行されます。他の可能性は、エンジニアやWeb開発者がアプリケーションをデバッグするために使用するプログラムです。</target>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="translated">&lt;strong&gt; &lt;var&gt;type&lt;/var&gt; &lt;/strong&gt;データタイプのような、落下先の一般的なカテゴリ表す &lt;code&gt;video&lt;/code&gt; または &lt;code&gt;text&lt;/code&gt; 。&lt;strong&gt; &lt;var&gt;subtype&lt;/var&gt; &lt;/strong&gt;の正確な種類MIMEタイプが表す指定されたタイプのデータの識別。たとえば、MIMEタイプの &lt;code&gt;text&lt;/code&gt; 場合、サブタイプは &lt;code&gt;plain&lt;/code&gt; （プレーンテキスト）、 &lt;code&gt;html&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt;ソースコード）、または &lt;code&gt;calendar&lt;/code&gt; （iCalendar / &lt;code&gt;.ics&lt;/code&gt; の場合）ファイルの場合があります。</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Altキー-SVCの&lt;/strong&gt;ヘッダは、このウェブサイトに到達するために、リストの代替の方法に使用されています。</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">&lt;strong&gt;HTTP DELETEリクエストメソッドは、&lt;/strong&gt;指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;strong&gt;HTTP PATCHリクエストメソッドは&lt;/strong&gt;リソースに対する部分的変更を適用します。</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;strong&gt;HTTPのPUTリクエストメソッドは、&lt;/strong&gt;新しいリソースを作成したり、要求ペイロードを持つターゲット・リソースの表現に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;秒-のWebSocketは、受け入れ&lt;/strong&gt;ヘッダがWebSocketの開口ハンドシェークに使用されます。応答ヘッダーに表示されます。つまり、これはヘッダーがサーバーからクライアントに送信され、サーバーがWebSocket接続を開始する用意があることを通知します。</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;トレーラー&lt;/strong&gt;レスポンスヘッダは、送信者がメッセージ本文を、メッセージ整合性チェック、デジタル署名、または後処理状態として、送信されている間、動的に生成されるかもしれない供給メタデータのためにチャンクメッセージの終わりに追加フィールドを含めることができます。</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;ユーザエージェント&lt;/strong&gt;要求ヘッダは、ネットワーク・プロトコル・ピアは、アプリケーションタイプ、オペレーティングシステム、ソフトウェアベンダまたは要求するソフトウェアのユーザエージェントのソフトウェアバージョンを識別することを可能にする特性文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ユーザエージェント&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;要求ヘッダは、&lt;/a&gt;サーバとネットワークピアが要求するアプリケーション、オペレーティングシステム、ベンダ、および/またはバージョンを識別することができ特性文字列である&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザエージェント&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="translated">Accept ヘッダ</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">Accept request-headerフィールドを使用して、応答に受け入れられる特定のメディアタイプを指定できます。 Acceptヘッダーを使用して、インライン画像のリクエストの場合と同様に、リクエストが特定のタイプの小さなセットに限定されていることを示すことができます。 Accept = &quot;Accept&quot; &quot;：&quot;＃（media-range [accept-params]）media-range =（ &quot;* / *&quot; |（type &quot;/&quot; &quot;*&quot;）|（type &quot;/&quot; subtype））*（ &quot;;&quot;パラメータ）accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *（accept-extension）accept-extension = &quot;;&quot;トークン[&quot;=&quot;（トークン|引用文字列）]アスタリスク &quot;*&quot;文字は、メディアタイプを範囲にグループ化するために使用されます。「* / *」はすべてのメディアタイプを示し、「type / *」はそのタイプのすべてのサブタイプを示します。メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（&lt;a href=&quot;#section-3.9&quot;&gt;セクション3.9&lt;/a&gt;）。デフォルト値はq = 1です。注：メディアタイプパラメーターをAccept拡張パラメーターから分離するために「q」パラメーター名を使用するのは、歴史的な慣習によるものです。これにより、「q」という名前のメディアタイプパラメータがメディア範囲で使用されなくなりますが、IANAメディアタイプレジストリに「q」パラメータが不足していること、およびメディアタイプがまれにしか使用されないことがこのようなイベントであるとは考えられません。 Acceptのパラメータ。将来のメディアタイプでは、「q」という名前のパラメータを登録しないでください。例Accept：audio / *; q = 0.2、音声/基本は「音声/基本を好みますが、品質が80％値下げされた後に最高の音声タイプが得られれば、どんな音声タイプでも送ってください」と解釈する必要があります。 Acceptヘッダーフィールドが存在しない場合、次に、クライアントがすべてのメディアタイプを受け入れると想定されます。 Acceptヘッダーフィールドが存在し、サーバーが結合されたAcceptフィールド値に従って受け入れ可能な応答を送信できない場合、サーバーは406（受け入れられない）応答を送信する必要があります（SHOULD）。より複雑な例はAccept：text / plain;です。 q = 0.5、text / html、text / x-dvi; q = 0.8、text / xc口頭で、これは「text / htmlとtext / xcが推奨されるメディアタイプであると解釈されますが、存在しない場合は、text / x-dviエンティティを送信し、存在しない場合は存在する場合は、text / plainエンティティを送信してください。」メディア範囲は、より具体的なメディア範囲または特定のメディアタイプによってオーバーライドできます。特定のタイプに複数のメディア範囲が適用される場合、最も具体的な参照が優先されます。たとえば、Accept：text / *、text / html、text / html; level = 1、* / *には次の優先順位があります：1）text / html; level = 1 2）text / html 3）text / * 4）* / *メディア特定のタイプに関連付けられているタイプクオリティファクターは、そのタイプに一致する優先順位が最も高いメディア範囲を見つけることによって決定されます。たとえば、Accept：text / *; q = 0.3、text / html; q = 0.7、text / html; level = 1、text / html; level = 2; q = 0.4、* / *; q = 0.5は、関連付けられる次の値：text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7注：ユーザーエージェントには、特定のメディア範囲の品質値のデフォルトセットが提供される場合があります。ただし、ユーザーエージェントが他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="translated">Accept-CH ヘッダ</target>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="translated">Accept-CH-Lifeetime ヘッダ</target>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="translated">Accept-Charset ヘッダ</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charsetリクエストヘッダーフィールドを使用して、どの文字セットが応答に受け入れられるかを示すことができます。このフィールドを使用すると、クライアントは、より包括的または特殊目的の文字セットを理解でき、その文字セットでドキュメントを表現できるサーバーにその機能を通知できます。 Accept-Charset = &quot;Accept-Charset&quot; &quot;：&quot; 1＃（（charset | &quot;*&quot;）[&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）文字セット値については、&lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4で&lt;/a&gt;。各文字セットには、その文字セットに対するユーザーの好みを表す関連する品質値を与えることができます（MAY）。デフォルト値はq = 1です。例はAccept-Charsetです：iso-8859-5、unicode-1-1; q = 0.8特別な値 &quot;*&quot;がAccept-Charsetフィールドに存在する場合、すべての文字セット（ISO-8859-1を含む）に一致しますAccept-Charsetフィールドのどこにも記載されていません。 Accept-Charsetフィールドに「*」が存在しない場合、明示的に指定されていない場合に品質値1を取得するISO-8859-1を除いて、明示的に指定されていないすべての文字セットの品質値は0になります。 Accept-Charsetヘッダーが存在しない場合、デフォルトでは、任意の文字セットが受け入れられます。 Accept-Charsetヘッダーが存在する場合、また、サーバーがAccept-Charsetヘッダーに従って受け入れ可能な応答を送信できない場合、サーバーは406（受け入れられない）ステータスコードを含むエラー応答を送信する必要がありますが、受け入れられない応答の送信も許可されます。</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="translated">Accept-Encoding ヘッダ</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-EncodingリクエストヘッダーフィールドはAcceptに似ていますが、コンテンツコーディングを制限します（&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）応答で許容できるもの。 Accept-Encoding = &quot;Accept-Encoding&quot; &quot;：&quot; 1＃（codings [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）codings =（content-coding | &quot;*&quot;）使用例：Accept-Encoding：圧縮、gzip Accept-Encoding：Accept-Encoding：* Accept-Encoding：compress; q = 0.5、gzip; q = 1.0 Accept-Encoding：gzip; q = 1.0、identity; q = 0.5、*; q = 0サーバーは、次のルールを使用して、Accept-Encodingフィールドに従ってコンテンツコーディングが許容可能かどうかをテストします。1.コンテンツコーディングがAcceptにリストされているコンテンツコーディングの1つである場合-エンコードフィールド、qvalueが0を伴わない限り、それは受け入れられます（（&lt;a href=&quot;#section-3.9&quot;&gt;ますセクション3.9で&lt;/a&gt;、0のqvalueは「受け入れられない」を意味します。）2. Accept-Encodingフィールドの特別な「*」記号は、ヘッダーフィールドに明示的にリストされていない使用可能なcontent-codingと一致します。 3.複数のコンテンツコーディングが許容できる場合、ゼロ以外のqvalueが最も高い許容可能なコンテンツコーディングが優先されます。 4. Accept-Encodingフィールドに &quot;identity; q = 0&quot;が含まれているため、またはフィールドに &quot;*; q = 0&quot;が含まれ、明示的に &quot;アイデンティティ」コンテンツコーディング。 Accept-Encodingフィールド値が空の場合、「ID」エンコーディングのみが受け入れられます。Accept-Encodingフィールドがリクエストに存在し、サーバーがAccept-Encodingヘッダーに従って受け入れ可能な応答を送信できない場合、サーバーは406（Not Acceptable）ステータスコードを含むエラー応答を送信する必要があります（SHOULD）。 Accept-Encodingフィールドがリクエストに存在しない場合、サーバーはクライアントがコンテンツコーディングを受け入れると想定してもよい（MAY）。この場合、「アイデンティティ」が利用可能なコンテンツコーディングの1つである場合、サーバーは、別のコンテンツコーディングがクライアントにとって意味があるという追加情報がない限り、「アイデンティティ」コンテンツコーディングを使用する必要があります。注：リクエストにAccept-Encodingフィールドが含まれておらず、「identity」コンテンツコーディングが利用できない場合、HTTP / 1.0クライアント（つまり、「gzip」および「compress」が推奨されます。古いクライアントの中には、他のコンテンツコーディングで送信されたメッセージを正しく表示しないものがあります。サーバーは、特定のユーザーエージェントまたはクライアントに関する情報に基づいてこの決定を行うこともあります。注：ほとんどのHTTP / 1.0アプリケーションは、コンテンツコーディングに関連付けられたqvalueを認識または従いません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="translated">Accept-Language ヘッダ</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-LanguageリクエストヘッダーフィールドはAcceptに似ていますが、リクエストへの応答として優先される自然言語のセットを制限します。言語タグはで定義されています&lt;a href=&quot;#section-3.10&quot;&gt;セクション3.10で&lt;/a&gt;。 Accept-Language = &quot;Accept-Language&quot; &quot;：&quot; 1＃（language-range [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）language-range =（（1 * 8ALPHA *（ &quot;-&quot; 1 * 8ALPHA）） | &quot;*&quot;）各言語範囲には、その範囲で指定された言語に対するユーザーの好みの推定値を表す関連する品質値を指定できます（MAY）。品質値のデフォルトは「q = 1」です。たとえば、Accept-Language：da、en-gb; q = 0.8、en; q = 0.7は、「デンマーク語が好きですが、イギリス英語と他のタイプの英語は受け入れます」を意味します。言語範囲は、タグと完全に等しい場合、またはプレフィックスに続く最初のタグ文字が「-」になるようにタグのプレフィックスと正確に等しい場合、言語タグと一致します。Accept-Languageフィールドに存在する場合、特別な範囲「*」は、Accept-Languageフィールドに存在する他のどの範囲とも一致しないすべてのタグに一致します。注：このプレフィックス一致ルールの使用は、言語タグが言語に割り当てられていることを意味するものではなく、ユーザーが特定のタグを持つ言語を理解している場合、このユーザーはタグを持つすべての言語も理解するということが常に当てはまります。このタグがプレフィックスであるもの。この場合、接頭辞ルールは接頭辞タグの使用を許可するだけです。 Accept-Languageフィールドによって言語タグに割り当てられた言語品質係数は、言語タグと一致するフィールドの最も長い言語範囲の品質値です。タグに一致するフィールドの言語範囲がない場合、割り当てられる言語品質係数は0です。Accept-Languageヘッダーがリクエストに存在しない場合、サーバーはすべての言語が同等に受け入れ可能であると想定する必要があります（SHOULD）。 Accept-Languageヘッダーが存在する場合、0より大きい品質係数が割り当てられているすべての言語が受け入れ可能です。すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、 &lt;a href=&quot;#section-15.1.4&quot;&gt;セクション15.1.4&lt;/a&gt;。了解度は個々のユーザーに大きく依存するため、クライアントアプリケーションでユーザーが使用できる言語設定を選択できるようにすることをお勧めします。選択が利用可能にならない場合、リクエストでAccept-Languageヘッダーフィールドを指定してはなりません（MUST NOT）。注：言語設定の選択をユーザーが利用できるようにする場合、ユーザーは上記の言語マッチングの詳細に精通していないことを実装者に思い出させ、適切なガイダンスを提供する必要があります。例として、ユーザーは &quot;en-gb&quot;を選択すると、英国英語が利用できない場合にあらゆる種類の英語のドキュメントが提供されると想定する場合があります。このような場合、ユーザーエージェントは、「en」を追加して最適な一致動作を得るよう提案する場合があります。</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Rangesレスポンスヘッダーフィールドを使用すると、サーバーはリソースの範囲リクエストの受け入れを示すことができます。Accept-Ranges = &quot;Accept-Ranges&quot; &quot;：&quot;バイト範囲のリクエストを受け入れる「なし」のオリジンサーバーはAccept-Ranges：バイトを送信できますが、必須ではありません。クライアントは、関連するリソースのこのヘッダーを受信せずに、バイト範囲のリクエストを生成できます（MAY）。範囲の単位は&lt;a href=&quot;#section-3.12&quot;&gt;セクション3.12で&lt;/a&gt;定義されています。リソースに対するいかなる種類の範囲要求も受け入れないサーバーは、範囲要求を試みないようにクライアントに通知するためにAccept-Ranges：noneを送信してもよい（MAY）。</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Ageヘッダーフィールドは、キャッシュから取得した応答メッセージの推定経過時間を伝えるために使用されます。 Ageフィールドの値は、応答がオリジンサーバーによって生成または検証されてからのキャッシュの推定秒数です。本質的に、Age値は、応答がオリジンサーバーからのパスに沿って各キャッシュに常駐していた時間と、ネットワークパスに沿って転送されていた時間の合計です。次のデータは、年齢の計算に使用されます。age_value「age_value」という用語は、Ageヘッダーフィールドの値を示します（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）、算術演算に適した形式。利用できない場合は0。 date_value「date_value」という用語は、算術演算に適した形式で、Dateヘッダーフィールドの値を示します。Dateヘッダーフィールドの定義、およびそれなしの応答に関する要件について&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;は、[RFC7231]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;セクション&lt;/a&gt;7.1.1.2を参照してください。 now「今」という用語は、「計算を実行しているホストでのクロックの現在の値」を意味します。ホストはNTP（[&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt; RFC5905&lt;/a&gt;]）またはそのクロックを協定世界時に同期させるための類似のプロトコル。 request_time保存された応答をもたらす要求が行われたときのホストのクロックの現在の値。 response_time応答が受信されたときのホストのクロックの現在の値。応答の経過時間は、2つの完全に独立した方法で計算できます。1.「apparent_age」：ローカルクロックが元のサーバーのクロックに適切に同期されている場合は、response_timeからdate_valueを引いた値。結果が負の場合、結果はゼロに置き換えられます。 2.応答パスに沿ったすべてのキャッシュがHTTP / 1.1を実装している場合、「corrected_age_value」。キャッシュは、応答が受信された時間ではなく、要求が開始された時間に関連してこの値を解釈する必要があります。 Appearance_age = max（0、response_time-date_value）; response_delay = response_time-request_time; corrected_age_value = age_value + response_delay;これらは、次のように組み合わされます。キャッシュがAgeヘッダーフィールドの値に自信がない場合（たとえば、ViaヘッダーフィールドにHTTP / 1.0ホップがないため）。この場合、corrected_age_valueはcorrected_initial_ageとして使用できます（MAY）。保存された応答のcurrent_ageは、保存された応答が起点サーバーによって最後に検証されてからの時間（秒単位）をcorrected_initial_ageに追加することで計算できます。resident_time = now-response_time; current_age = corrected_initial_age + resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Age応答ヘッダーフィールドは、応答（またはその再検証）がオリジンサーバーで生成されてからの送信者の推定時間を伝えます。キャッシュされた応答は、その存続期間がその存続期間を超えない場合、「新鮮」です。年齢の値は、&lt;a href=&quot;#section-13.2.3&quot;&gt;セクション13.2.3で&lt;/a&gt;。 Age = &quot;Age&quot; &quot;：&quot; age-value age-value = delta-seconds Age値は、秒単位の時間を表す、負でない10進整数です。キャッシュが表すことができる最大の正の整数より大きい値を受信する場合、またはキャッシュの経過時間の計算のいずれかがオーバーフローする場合、キャッシュは2147483648（2 ^ 31）の値を持つ経過時間ヘッダーを送信する必要があります。キャッシュを含むHTTP / 1.1サーバーは、自身のキャッシュから生成されるすべての応答にAgeヘッダーフィールドを含める必要があります。キャッシュは、少なくとも31ビットの範囲の算術型を使用する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">Allow entity-header フィールドには、Request-URI で識別されたリソースがサポートするメソッドのセットが一覧表示されます。このフィールドの目的は、リソースに関連付けられた有効なメソッドを受信者に通知することです。Allowヘッダーフィールドは405(Method Not Allowed)応答に存在しなければならない[MUST]。Allow=&quot;Allow&quot; &quot;:&quot; Allow=&quot;Allow&quot; &quot;:&quot; #Method 使用例。Allow。使用例:Allow:GET,HEAD,PUT このフィールドは、クライアントが他のメソッドを試すのを防ぐことはできません。しかし、Allowヘッダーフィールド値によって与えられた指示に従うべきである[SHOULD]。実際に許可されるメソッドのセットは、各リクエスト時にオリジンサーバーが定義する。Allowヘッダーフィールドは、新規または修正されたリソースがサポートするメ ソッドを推奨するPUTリクエストで提供してもよい[MAY]。サーバーはこれらのメソッドをサポートすることを要求されず、実際にサポートされるメ ソッドを与える応答にAllowヘッダーを含めるべきである[SHOULD]。プロキシは、たとえ指定されたすべてのメソッドを理解していなくても、 Allowヘッダーフィールドを修正してはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atomプロトコルは、サーバーのアクションにほとんど制限を課しません。ここで制約が指定されていない限り、サーバーは、特にクライアントから送信されたAtomエントリーの操作に関して、動作が異なることが予想されます。たとえば、この仕様はGETとPOSTに関してコレクションの予想される動作のみを定義していますが、これは、PUT、DELETE、PROPPATCHなどがコレクションリソースで禁止されていることを意味するわけではありません。これらのメソッドに対する応答になります。同様に、一部のHTTPステータスコードが明示的に言及されていますが、クライアントはサーバーからのステータスコードを処理する準備をする必要があります。サーバーは、受け入れ、拒否、遅延、モデレート、検閲、再フォーマット、翻訳、再配置を選択できます。または、提出されたコンテンツを再分類します。これらの選択肢の一部だけが、クライアント要求への応答としてすぐにクライアントに中継されます。他の選択肢は、フィードまたは公開されたエントリで後でのみ明らかになる場合があります。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更フィードまたは公開されたエントリ内。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更フィードまたは公開されたエントリ内。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更この仕様またはHTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;したがって、RFC2616 ]が許可されます。</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom プロトコルは、HTTP を使用してリソースを公開および編集するための操作を規定しています。Atom形式の表現を使用して、リソースの状態とメタデータを記述します。また、リソースのコレクションをどのように編成するかを定義し、リソースの発見、グループ化、および分類をサポートするためのフォーマットを規定しています。</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atomプロトコルは、HTTPで定義された応答ステータスコードを使用して、操作の成功または失敗を示します。各ステータスコードの詳細な定義については、HTTP仕様[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]を参照してください。実装者は、HTTP仕様に従って、HTTP 4xxおよび5xx応答エンティティに、人間が読める形式のエラーの説明を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">アトムパブリッシングプロトコル</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom Publishing Protocolは、HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]およびXML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] を使用してWebリソースを公開および編集するためのアプリケーションレベルのプロトコルです。このプロトコルは、Webリソースの作成をサポートし、次の機能を提供します。oコレクション：リソースのセット。全体または一部を取得できます。 oサービス：コレクションの発見と説明。 o編集：リソースの作成、編集、削除。 Atom Publishing Protocolは、サーバーがクライアントからの要求を処理する際に広い自由度を与えられているという点で、現在の多くのプロトコルとは異なります。詳細については、&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom Publishing ProtocolはHTTPに基づいているため、&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]のセクション15&lt;/a&gt;にあるセキュリティ上の考慮事項に従います。このセクションに記載されている脅威は、HTTPで実行される多くのプロトコルに適用されます。 Atompubワーキンググループは、TLSで認証済みのHTTPを実行することによって提供される保護（&lt;a href=&quot;#section-14&quot;&gt;セクション14で&lt;/a&gt;説明）が、このセクションに記載されている攻撃によって提示される問題の多くを軽減するのに十分であると判断しました 。</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom Publishing ProtocolはHTTPに基づいています。 HTTPの認証要件は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;、[RFC2616]のセクション11で説明されています&lt;/a&gt;。認証メカニズムを使用して、不明または無許可のクライアントによるPOSTや編集を防止することをお勧めしますが、必須ではありません。認証が使用されていない場合、クライアントとサーバーは、ささいなスプーフィング、サービス拒否攻撃、および改ざん攻撃に対して脆弱です。ただし、状況によっては、これは許容可能なリスクです。展開される認証の種類は、サーバーオペレーターによって行われるローカルな決定です。クライアントは、サーバーの配置によって異なる認証スキームに直面する可能性があります。少なくとも、クライアントとサーバーの実装は、HTTP基本認証を使用するように構成できる必要があります[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt; RFC2617&lt;/a&gt;] TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ]または後続の標準トラックバージョンのTLS（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]など）で作成された接続と組み合わせて、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818で&lt;/a&gt;説明されているHTTP over TLSを使用するための規則をサポート]。認証メカニズムの選択は、相互運用性に影響を与えます。上記で参照されている最低レベルのセキュリティ（TLSを使用した基本認証）は、この仕様の公開時点ではインターネットアプリケーションの優れたプラクティスと見なされており、相互運用性のベースラインを確立するには十分です。実装者は、展開時に同等またはそれ以上に優れていると見なされる代替メカニズムを調査して使用することをお勧めします。新しい認証スキームを展開できるようにクライアントを実装することをお勧めします。このプロトコルは、リクエストの結果を報告する主要な手段としてHTTPレスポンスステータスコードを使用するため、サーバーは、適切な4xx HTTPレスポンスコードを使用して、未承認または未認証のリクエストに応答することをお勧めします（たとえば、401「無許可」または403「禁止」）に従って[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom Publishing Protocolは、HTTPメソッドを使用して、次のようにメンバーリソースを作成します。o GETは、既知のリソースの表現を取得するために使用されます。 o POSTは、動的に名前が付けられた新しいリソースを作成するために使用されます。クライアントが非Atomエントリ表現をコレクションに送信して作成すると、常に2つのリソースが作成されます。要求されたリソースのメディアエントリと、コレクションに表示されるリソースに関するメタデータのメディアリンクエントリです。 o PUTは、既知のリソースを編集するために使用されます。リソースの作成には使用されません。 o DELETEは、既知のリソースを削除するために使用されます。 Atomプロトコルは、エントリおよびメディアリソースの作成、編集、削除のみを対象としています。コレクションを操作した結果、他のリソースが作成、編集、削除される可能性があります。ただし、それらのリソースの数、メディアタイプ、およびそれらに対するAtomプロトコル操作の影響は、この仕様の範囲外です。クライアントとサーバーの相互作用のすべての側面はHTTPに関して定義されるため、[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;この仕様でカバーされていない領域については、RFC2616を参照してください。</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;配信&lt;/a&gt;フォーマット[ RFC4287 ]では、「application / atom + xml」メディアタイプを定義して、AtomフィードとAtomエントリードキュメントの両方を識別します。実装の経験から、At​​omフィードとエントリードキュメントは異なる処理モデルを持つことができ、それらを区別する必要がある状況があることが実証されています。この仕様は、2つのタイプのAtom文書を区別するために使用される「タイプ」パラメーターを定義します。</target>
        </trans-unit>
        <trans-unit id="d54dec6d4ad6caa6017041a8dbe37766ea30ecca" translate="yes" xml:space="preserve">
          <source>The CONNECT method can be used to create disproportionate load on an
   proxy, since stream creation is relatively inexpensive when compared
   to the creation and maintenance of a TCP connection.  A proxy might
   also maintain some resources for a TCP connection beyond the closing
   of the stream that carries the CONNECT request, since the outgoing
   TCP connection remains in the TIME_WAIT state.  Therefore, a proxy
   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the
   resources consumed by CONNECT requests.</source>
          <target state="translated">ストリームの生成はTCP接続の生成と維持に比べて比較的安価であるため、 CONNECTメソッドはプロキシに不釣り合いな負荷を与えるために使用され ることがある。プロキシはまた、発信するTCP接続がTIME_WAITステートのままなので、 CONNECTリクエストを運ぶストリームの終了を超えて、 TCP接続のためのいくつかのリソースを維持するかもしれない。したがって、プロキシはCONNECTリクエストによって消費されるリソー スを制限するためにSETTINGS_MAX_CONCURRENT_STREAMSだけに頼ることはできない。</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECTメソッドは、受信者がrequest-targetで識別された宛先オリジンサーバーへのトンネルを確立することを要求し、成功した場合は、トンネルが閉じるまで、その動作を双方向のパケットのブラインド転送に制限します。トンネルは一般に、1つ以上のプロキシを介してエンドツーエンドの仮想接続を作成するために使用され、TLS（Transport Layer Security、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt; RFC5246&lt;/a&gt;]）を使用して保護できます。 CONNECTは、プロキシへのリクエストでの使用のみを目的としています。自身のCONNECT要求を受信したオリジンサーバーは、2xx（成功）ステータスコードで応答して、接続が確立されたことを示すことができます。ただし、ほとんどのオリジンサーバーはCONNECTを実装していません。 CONNECTリクエストを送信するクライアントは、request-target（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt; [RFC7230]のセクション5.3）。&lt;/a&gt;）;つまり、request-targetは、コロンで区切られたトンネル宛先のホスト名とポート番号のみで構成されます。たとえば、CONNECT server.example.com:80 HTTP / 1.1 Host：server.example.com:80受信プロキシは、リクエストターゲットに直接接続するか、別のプロキシを使用するように構成されている場合は転送することにより、トンネルを確立できます。次のインバウンドプロキシへのCONNECTリクエスト。 2xx（成功）応答は、送信者（およびすべての受信プロキシ）が、成功応答のヘッダーセクションの最後の空白行の直後にトンネルモードに切り替わることを示します。その空白行の後に受信されたデータは、request-targetによって識別されたサーバーからのものです。成功した応答以外の応答は、トンネルがまだ形成されておらず、接続がHTTPによって管理されたままであることを示します。トンネルは、トンネルの仲介者がいずれかの側が接続を閉じたことを検出すると閉じられます。仲介者は、閉じられた側から来た未処理のデータを反対側に送信し、両方の接続を閉じて、未送信の残りのデータを破棄する必要があります。プロキシ認証は、トンネルを作成する権限を確立するために使用される場合があります。たとえば、CONNECT server.example.com:80 HTTP / 1.1 Host：server.example.com:80 Proxy-Authorization：basic aGVsbG86d29ybGQ =任意のサーバーへのトンネルを確立することには重大なリスクがあり、特に、宛先がWebトラフィック用ではない既知または予約済みのTCPポートである場合。たとえば、「example.com:25」のリクエストターゲットへのCONNECTは、プロキシがSMTPトラフィック用に予約されたポートに接続することを示唆します。許可されていれば、プロキシをだましてスパムメールをリレーさせることができます。 CONNECTをサポートするプロキシは、その使用を既知のポートの限定されたセットまたは安全な要求ターゲットの構成可能なホワイトリストに制限する必要があります（SHOULD）。サーバーは、CONNECTへの2xx（成功）応答でTransfer-EncodingまたはContent-Lengthヘッダーフィールドを送信してはなりません（MUST NOT）。クライアントは、CONNECTへの正常な応答で受信したContent-LengthまたはTransfer-Encodingヘッダーフィールドをすべて無視する必要があります。 CONNECTリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。CONNECTリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する場合があります。 CONNECTメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="44e2ab9943f4c0dd2becd2a23e49a2cb8c91d927" translate="yes" xml:space="preserve">
          <source>The CONTINUATION frame (type=0x9) is used to continue a sequence of
   header block fragments (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Any number of CONTINUATION
   frames can be sent, as long as the preceding frame is on the same
   stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without
   the END_HEADERS flag set.

    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload

   The CONTINUATION frame payload contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;). 

   The CONTINUATION frame defines the following flag:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame ends a
      header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

      If the END_HEADERS bit is not set, this frame MUST be followed by
      another CONTINUATION frame.  A receiver MUST treat the receipt of
      any other type of frame or a frame on a different stream as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The CONTINUATION frame changes the connection state as defined in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   CONTINUATION frames MUST be associated with a stream.  If a
   CONTINUATION frame is received whose stream identifier field is 0x0,
   the recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or
   CONTINUATION frame without the END_HEADERS flag set.  A recipient
   that observes violation of this rule MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.</source>
          <target state="translated">CONTINUATIONフレーム（type = 0x9）は、ヘッダーブロックフラグメントのシーケンスを継続するために使用されます（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。前のフレームが同じストリーム上にあり、END_HEADERSフラグが設定されていないHEADERS、PUSH_PROMISE、またはCONTINUATIONフレームである限り、任意の数のCONTINUATIONフレームを送信できます。 + ------------------------------------------------- -------------- + |ヘッダーブロックフラグメント（*）+ ------------------------------------------- -------------------- +図15：CONTINUATIONフレームペイロードCONTINUATIONフレームペイロードには、ヘッダーブロックフラグメントが含まれています（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。 CONTINUATIONフレームは、次のフラグを定義します。END_HEADERS（0x4）：設定されると、ビット2は、このフレームがヘッダーブロックを終了することを示します（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。 END_HEADERSビットが設定されていない場合、このフレームの後に別のCONTINUATIONフレームが続く必要があります。受信者は、他のタイプのフレームまたは別のストリーム上のフレームの受信を、タイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として処理する必要があります。 CONTINUATIONフレームは、&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3で&lt;/a&gt;定義されているように接続状態を変更します。 CONTINUATIONフレームは、ストリームに関連付ける必要があります。ストリーム識別子フィールドが0x0であるCONTINUATIONフレームを受信した場合、受信者はタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）で応答する必要があります。 CONTINUATIONフレームの前には、END_HEADERSフラグが設定されていないHEADERS、PUSH_PROMISE、またはCONTINUATIONフレームが必要です。このルールの違反を観察した受信者は、接続エラーで応答する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;タイプPROTOCOL_ERRORのセクション5.4.1）。</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPYメソッドは、DestinationヘッダーのURIで識別される宛先リソースに、Request-URIで識別されるソースリソースの複製を作成します。 Destinationヘッダーが存在する必要があります。 COPYメソッドの正確な動作は、ソースリソースのタイプによって異なります。すべてのWebDAV準拠リソースは、COPYメソッドをサポートする必要があります。ただし、COPYメソッドのサポートは、リソースをコピーする機能を保証するものではありません。たとえば、別々のプログラムが同じサーバー上のリソースを制御する場合があります。その結果、同じサーバー上にあるように見える場所にリソースをコピーできない場合があります。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等ですが、安全ではありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">DepthヘッダーのないコレクションのCOPYメソッドは、値 &quot;infinity&quot;のDepthヘッダーが含まれているかのように動作する必要があります。クライアントは、 &quot;0&quot;または &quot;infinity&quot;の値を持つコレクションのCOPYでDepthヘッダーを送信できます。サーバーは、WebDAV準拠のリソースで「0」および「無限」の深度ヘッダー動作をサポートする必要があります。無限の深さのCOPYは、Request-URIで識別されるコレクションリソースをDestinationヘッダーのURIで識別される場所にコピーし、そのすべての内部メンバーリソースを、それに関連する場所に再帰的にコピーするように指示しますコレクション階層のすべてのレベルを通して。 / A /から/ A / B /への無限深度のCOPYは、正しく処理されない場合、無限再帰を引き起こす可能性があることに注意してください。 「深さのコピー：0は、コレクションとそのプロパティをコピーすることを指示するだけで、内部メンバーURLによって識別されるリソースはコピーしないことを指示します。COPYに含まれるヘッダーは、Destinationヘッダーを除いて、コピーするすべてのリソースの処理に適用する必要があります。 Destinationヘッダーは、Request-URIの宛先URIのみを指定します。Request-URIで識別されるコレクションのメンバーに適用される場合、Destinationの値は、階層内の現在の場所を反映するように変更されます。したがって、リクエスト-URIは/ a /で、ホストヘッダー値はhttp://example.com/で、宛先はhttp://example.com/b/であり、http：//example.com/a/c/dが処理されるとき、http：//example.com/b/c/dの宛先を使用する必要があります。COPYメソッドが処理を完了すると、宛先で一貫したURL名前空間を作成している必要があります（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;名前空間の一貫性の定義については）。ただし、内部コレクションのコピー中にエラーが発生した場合、サーバーはこのコレクションのメンバーによって識別されるリソースをコピーしてはなりません（つまり、サーバーはこのサブツリーをスキップする必要があります）。これにより、一貫性のない名前空間が作成されます。エラーを検出した後、COPY操作は可能な限り多くの元のコピー操作を終了しようとする必要があります（つまり、サーバーは、エラーの原因となるコレクションの子孫ではない他のサブツリーとそのメンバーを引き続きコピーする必要があります）。したがって、たとえば、コレクション/ a / b /および/ a / c /を含むコレクション/ a /に対して無限深度コピー操作が実行され、/ a / b /のコピー中にエラーが発生した場合でも、 / a / c /をコピーします。同様に、無限深度コピーの一部として非コレクションリソースをコピーしているときにエラーが発生した後、サーバーは、元のコピー操作を可能な限り終了しようとする必要があります（SHOULD）。 COPYメソッドの実行中にエラーがRequest-URIで識別されたリソース以外のリソースで発生した場合、応答は207（マルチステータス）でなければならず、失敗の原因となったリソースのURLは特定のエラー。 COPYメソッドからの207（マルチステータス）レスポンスでは、424（失敗した依存関係）ステータスコードを返すべきではありません（SHOULD NOT）。クライアントは親のエラーを受け取ったときにリソースの子孫をコピーできなかったことをクライアントが知っているので、これらの応答は安全に省略できます。さらに、201（作成済み）/ 204（コンテンツなし）ステータスコードは、COPYメソッドからの207（マルチステータス）レスポンスの値として返されるべきではありません（SHOULD NOT）。これらもデフォルトの成功コードであるため、省略しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORSメカニズムは、ブラウザとサーバー間の安全なクロスオリジンリクエストとデータ転送をサポートします。最新のブラウザは、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;などのAPIでCORSを使用して、クロスオリジンHTTPリクエストのリスクを軽減します。</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORSメカニズムは、ブラウザーとWebサーバー間の安全なクロスオリジン要求とデータ転送をサポートします。最近のブラウザーは、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;などのAPIコンテナーでCORSを使用して、クロスオリジンHTTPリクエストのリスクを軽減します。</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORSプロトコルは元々その動作を必要としていました&lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;が、その後&lt;/a&gt;、その動作を必要としないように変更されました。ただし、すべてのブラウザーが変更を実装しているわけではないため、元々必要だった動作がまだ行われています。</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSPの&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;ディレクティブは、このヘッダーと共に使用する必要があります。そうしないと、このヘッダーは高価な何もしないマシンになります。</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSPメカニズムでは、 &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダー、&lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダー、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素などを介して、リソースに複数のポリシーを指定できます。</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-headerフィールドは、要求/応答チェーンに沿ったすべてのキャッシングメカニズムに従う必要があるディレクティブを指定するために使用されます。ディレクティブは、キャッシュが要求または応答に悪影響を与えることを防ぐための動作を指定します。これらのディレクティブは通常、デフォルトのキャッシュアルゴリズムをオーバーライドします。リクエストにディレクティブが存在しても、応答で同じディレクティブが指定されることを意味しないという点で、キャッシュディレクティブは単方向です。 HTTP / 1.0キャッシュはCache-Controlを実装せず、Pragma：no-cacheのみを実装する場合があることに注意してください（&lt;a href=&quot;#section-14.32&quot;&gt;セクション14.32を&lt;/a&gt;参照）。）。ディレクティブは要求/応答チェーン上のすべての受信者に適用できるため、キャッシュディレクティブは、そのアプリケーションに対する重要性に関係なく、プロキシまたはゲートウェイアプリケーションによってパススルーされる必要があります。特定のキャッシュにcache-ディレクティブを指定することはできません。 Cache-Control = &quot;Cache-Control&quot; &quot;：&quot; 1＃cache-directive cache-directive = cache-request-directive | cache-response-directive cache-request-directive = &quot;no-cache&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | 「ストアなし」; &lt;a href=&quot;#section-14.9.2&quot;&gt;セクション14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3、14.9.4&lt;/a&gt; | 「max-stale」[&quot;=&quot;デルタ秒];&lt;a href=&quot;#section-14.9.3&quot;&gt;[&quot;=&quot;デルタ秒]; セクション14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; | &quot;変換なし&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;セクション14.9.5&lt;/a&gt; | &quot;キャッシュのみ&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; |キャッシュ拡張; &lt;a href=&quot;#section-14.9.6&quot;&gt;セクション14.9.6&lt;/a&gt; cache-response-directive = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | &quot;プライベート&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1＃フィールド名&amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | &quot;no-cache&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1＃field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | 「ストアなし」;&lt;a href=&quot;#section-14.9.2&quot;&gt;セクション14.9.2&lt;/a&gt; | &quot;変換なし&quot;;&lt;a href=&quot;#section-14.9.5&quot;&gt;セクション14.9.5&lt;/a&gt; | 「再検証が必要」; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; | &quot;プロキシ再検証&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; |キャッシュ拡張;&lt;a href=&quot;#section-14.9.6&quot;&gt;セクション14.9.6&lt;/a&gt; cache-extension = token [&quot;=&quot;（token | quoted-string）]ディレクティブが1＃field-nameパラメータなしで表示される場合、ディレクティブはリクエストまたはレスポンス全体に適用されます。そのようなディレクティブが1＃field-nameパラメーターと共に表示される場合、それは名前付きフィールドにのみ適用され、残りの要求または応答には適用されません。このメカニズムは拡張性をサポートします。 HTTPプロトコルの将来のバージョンの実装では、これらのディレクティブをHTTP / 1.1で定義されていないヘッダーフィールドに適用する可能性があります。キャッシュ制御ディレクティブは、次の一般的なカテゴリに分類できます。-キャッシュ可能なものに関する制限。これらは、オリジンサーバーによってのみ課される場合があります。 -キャッシュに保存できるものに関する制限。これらは、起点サーバーまたはユーザーエージェントによって課せられる場合があります。-基本的な有効期限メカニズムの変更。これらは、起点サーバーまたはユーザーエージェントによって課せられる場合があります。 -キャッシュの再検証とリロードの制御。これらは、ユーザーエージェントによってのみ課される場合があります。 -エンティティの変換を制御します。 -キャッシングシステムの拡張。</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control ヘッダ・フィールドは、オプションで割り当てられた値を持つ 1 つ以上の cache-extension トークンを使用して拡張できます。情報拡張 (キャッシュの動作の変更を必要としないもの)は、他のディレクティブのセマンティクスを変更せずに追加してもよい[MAY]。挙動拡張は、既存のキャッシュディレクティブのベースの修飾子として動作するように設計されています。新しいディレクティブと標準ディレクティブの両方が提供され、新しいディレクティブを理解していないアプリケーションは標準ディレクティブで指定された動作をデフォルトとし、新しいディレクティブを理解しているアプリケーションは標準ディレクティブに関連した要求を修正したものとして認識します。このようにして、キャッシュ制御ディレクティブへの拡張は、基本プロトコルへの変更を必要とせずに行うことができます。この拡張メカニズムは、HTTP キャッシュがそのネイティブ HTTP バージョン用に定義されたすべてのキャッシュ制御ディレクティブに従うこと、特定の拡張に従うこと、そして理解できないすべてのディレクティブを無視することに依存します。例えば、private ディレクティブの修飾子として動作する community と呼ばれる仮定の新しいレスポンスディレクティブを考えてみましょう。この新しいディレクティブを定義すると、非共有キャッシュに加えて、その値の中で指定されたコミュニティのメンバーだけが 共有するキャッシュが応答をキャッシュすることができることを意味します。UCI コミュニティがプライベートなレスポンスを共有キャッシュで使用することを許可したいオリジンサーバは、 Cache-Control:private,community=&quot;UCI&quot; と記述することで、このヘッダフィールドを見たキャッシュは、たとえキャッシュがコミュニティのキャッシュ拡張を理解していなくても正しく動作します。認識されないキャッシュディレクティブは無視されなければなりません(MUST)。HTTP/1.1 キャッシュで認識されない可能性のあるキャッシュディレクティブは、キャッシュが拡張機能を理解していなくてもキャッシュの挙動が最小限正しいままになるように、標準ディレクティブ(あるいはレスポンスのデフォルトのキャッシュ可能性)と結合されると仮定されています。</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control ヘッダフィールドは、オプションの値を持つ 1 つ以上の cache-extension トークンを使用して拡張できます。キャッシュは認識されないキャッシュディレクティブを無視しなければならない[MUST]。情報拡張 (キャッシュの動作の変更を必要としないもの)は他のディレクティブのセマンティクスを変更することなく追加することができます。挙動拡張は既存のキャッシュディレクティブのベースの修飾子として動作するように設計されています。新しいディレクティブと古いディレクティブの両方が提供され、新しいディレクティブを理解していないアプリケーションは古いディレクティブで指定された動作をデフォルトとし、新しいディレクティブを理解しているアプリケーションは古いディレクティブに関連した要求を修正したものとして認識します。このようにして、既存のキャッシュ制御ディレクティブの拡張を、配備されたキャッシュを壊すことなく行うことができます。例えば、private ディレクティブの修飾子として動作する &quot;community&quot; と呼ばれる仮定の新しいレスポンスディレクティブを考えてみましょう。プライベートキャッシュに加えて、指定されたコミュニティのメンバーだけが共有するキャッシュは、応答をキャッシュすることを許可します。 UCI コミュニティがプライベートな応答を共有キャッシュで使用することを許可したいオリジンサーバは、Cache-Control:private,community=&quot;UCI&quot; を含めることでそれができます。コミュニティキャッシュ拡張を認識しないキャッシュは、それを無視して private ディレクティブに従います。</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="translated">カリフォルニア州消費者プライバシー法</target>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="translated">Chrome（またはChromium / Blinkベースのエンジン）のユーザーエージェント文字列は、Firefoxのものと似ています。互換性のために、 &lt;code&gt;KHTML, like Gecko&lt;/code&gt; や &lt;code&gt;Safari&lt;/code&gt; などのKHTMLなどの文字列を追加します。</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome(またはChromium/blinkベースのエンジン)のユーザーエージェント文字列は、Firefoxのフォーマットに似ています。互換性のために、「GeckoのようなKHTML」や「Safari」のような文字列を追加しています。</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">接続の一般ヘッダーフィールドを使用すると、送信者は、特定の接続に必要なオプションを指定できます。また、プロキシは、他の接続を介して通信してはいけません。 Connectionヘッダーの文法は次のとおりです。Connection = &quot;Connection&quot; &quot;：&quot; 1＃（connection-token）connection-token = token HTTP / 1.1プロキシは、メッセージが転送される前に、および各connection-tokenについて、Connectionヘッダーフィールドを解析する必要がありますこのフィールドで、接続トークンと同じ名前のメッセージからヘッダーフィールドを削除します。接続オプションは、対応する追加のヘッダーフィールドではなく、接続ヘッダーフィールドに接続トークンが存在することで通知されます。その接続オプションに関連付けられたパラメーターがない場合、追加のヘッダーフィールドが送信されない可能性があるためです。 Connectionヘッダーにリストされているメッセージヘッダーには、Cache-Controlなどのエンドツーエンドヘッダーを含めることはできません。 HTTP / 1.1は、送信者が応答の完了後に接続が閉じられることを通知する「閉じる」接続オプションを定義します。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（応答の完了後に接続が閉じられることを送信者が通知するための接続オプション。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（応答の完了後に接続が閉じられることを送信者が通知するための接続オプション。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;）現在の要求/応答が完了した後。永続的な接続をサポートしないHTTP / 1.1アプリケーションは、すべてのメッセージに「閉じる」接続オプションを含める必要があります。接続ヘッダーを含むHTTP / 1.0（またはそれよりも低いバージョン）メッセージを受信するシステムは、このフィールドの各接続トークンについて、接続と同じ名前のメッセージからヘッダーフィールドを削除して無視する必要があります。トークン。これにより、HTTP / 1.1より前のプロキシによるこのようなヘッダーフィールドの誤った転送から保護されます。&lt;a href=&quot;#section-19.6.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">接続ヘッダーフィールド（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）は、現在の要求/応答ペアの後に接続を閉じたい場合に送信者が送信する必要がある「閉じる」接続オプションを提供します。 「閉じる」接続オプションを送信するクライアントは、その接続で（「閉じる」を含むものの後に）さらなる要求を送信してはならず（MUST）、この要求に対応する最終応答メッセージを読んだ後に接続を閉じなければなりません（MUST）。 「クローズ」接続オプションを受信したサーバーは、「クローズ」を含むリクエストへの最終応答を送信した後、接続のクローズ（下記参照）を開始する必要があります。サーバーは、その接続の最終応答で「クローズ」接続オプションを送信する必要があります（SHOULD）。サーバーは、その接続で受信したそれ以上の要求を処理してはなりません（MUST NOT）。 「を送信するサーバーclose &quot;接続オプションは、&quot; close &quot;を含む応答を送信した後、接続のクローズを開始する必要があります（以下を参照）。サーバーは、その接続で受信したそれ以上の要求を処理してはなりません。&quot; close &quot;接続オプションを受信するクライアントは停止する必要がありますその接続で要求を送信し、 &quot;close&quot;を含む応答メッセージを読み取った後、接続を閉じます。追加のパイプライン化された要求が接続で送信された場合、クライアントはそれらがサーバーで処理されることを想定してはなりません（SHOULD NOT）。 TCP接続をすぐに閉じると、クライアントが最後のHTTP応答を読み取ることができないという重大なリスクがあります。サーバーが完全に閉じた接続でクライアントから追加のデータを受信した場合、サーバーの応答を受信する前にクライアントによって送信された別の要求など、サーバーのTCPスタックはリセットパケットをクライアントに送信します。残念ながら、リセットパケットは、クライアントのHTTPパーサーによって読み取られ解釈される前に、クライアントの未確認の入力バッファーを消去する可能性があります。 TCPリセットの問題を回避するために、サーバーは通常、段階的に接続を閉じます。まず、サーバーは読み取り/書き込み接続の書き込み側のみを閉じることにより、ハーフクローズを実行します。次に、サーバーは、クライアントによる対応するクローズを受信するまで、またはサーバーが自身のTCPスタックがサーバーの最後の応答を含むパケットのクライアントの確認応答を受信したことを合理的に確信するまで、接続からの読み取りを続けます。最後に、サーバーは接続を完全に閉じます。リセットの問題がTCPに限定されているのか、それとも他のトランスポート接続プロトコルに見られるのかは不明です。</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">Content-Disposition応答ヘッダーフィールドは、ユーザーがコンテンツをファイルに保存することを要求した場合に、オリジンサーバーがデフォルトのファイル名を提案する手段として提案されています。この使用法は、Content-Dispositionのセキュリティ問題に関する&lt;a href=&quot;#section-15.5&quot;&gt;セクション15.5の&lt;/a&gt; Content-Dispositionの定義から派生しています。&lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt; RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt; 35の&lt;/a&gt;]。 content-disposition = &quot;Content-Disposition&quot; &quot;：&quot; disposition-type *（ &quot;;&quot; disposition-parm）disposition-type = &quot;attachment&quot; | disp-extension-token disposition-parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string disp-extension-token = token disp-extension-parm = token &quot;=&quot;（token | quoted-string）例はContent-Disposition：attachmentです; filename = &quot;fname.ext&quot;受信側のユーザーエージェントは、filename-parmパラメータに存在するディレクトリパス情報を考慮すべきではありません。これは、現時点でHTTP実装に適用されると考えられる唯一のパラメータです。ファイル名は端末コンポーネントとしてのみ扱われる必要があります（SHOULD）。このヘッダーがapplication / octet-stream content-typeの応答で使用される場合、暗黙の提案は、ユーザーエージェントが応答を表示するのではなく、「save response as ...」ダイアログに直接入力することです。見る</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">Content-Encodingエンティティヘッダーフィールドは、メディアタイプの修飾子として使用されます。存在する場合、その値は、エンティティ本体に適用されている追加のコンテンツコーディングを示します。したがって、Content-Typeヘッダーフィールドで参照されるメディアタイプを取得するために適用する必要があるデコードメカニズムを示します。Content-Encodingは主に、基になるメディアタイプのIDを失うことなくドキュメントを圧縮できるようにするために使用されます。Content-Encoding = &quot;Content-Encoding&quot; &quot;：&quot; 1＃content-codingコンテンツコーディングは、&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5でます&lt;/a&gt;。その使用例は、Content-Encoding：gzipです。content-codingは、Request-URIによって識別されるエンティティの特性です。通常、エンティティ本体はこのエンコーディングで格納され、レンダリングまたは類似の使用の前にのみデコードされます。ただし、「no-transform」キャッシュ制御ディレクティブがメッセージに存在しない限り、新しいコーディングが受信者に受け入れられることがわかっている場合、非透過プロキシはコンテンツコーディングを変更してもよい（MAY）。エンティティのコンテンツコーディングが「アイデンティティ」ではない場合、応答にはContent-Encodingエンティティヘッダー（&lt;a href=&quot;#section-14.11&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt; 14.11&lt;/a&gt;）使用される非アイデンティティコンテンツコーディングをリストします。リクエストメッセージ内のエンティティのコンテンツコーディングが配信元サーバーに受け入れられない場合、サーバーはステータスコード415（サポートされていないメディアタイプ）で応答する必要があります（SHOULD）。エンティティに複数のエンコーディングが適用されている場合、コンテンツコーディングは、それらが適用された順にリストされている必要があります。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のエンティティヘッダーフィールドによって提供される場合があります。</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Languageエンティティヘッダーフィールドは、囲まれたエンティティの対象読者の自然言語を記述します。これは、エンティティ本体で使用されるすべての言語と同等ではない場合があることに注意してください。Content-Language = &quot;Content-Language&quot; &quot;：&quot; 1＃language-tag言語タグは、&lt;a href=&quot;#section-3.10&quot;&gt;セクション3.10でます&lt;/a&gt;。 Content-Languageの主な目的は、ユーザーが自分の優先言語に従ってエンティティを識別および区別できるようにすることです。したがって、本文のコンテンツがデンマーク語の読み書きの対象者のみを対象としている場合、適切なフィールドはContent-Languageです。da Content-Languageが指定されていない場合、デフォルトではコンテンツはすべての言語の対象者を対象としています。これは、送信者がそれを自然言語に固有であると見なしていないこと、または送信者が意図する言語がわからないことを意味している可能性があります。複数の視聴者を対象とするコンテンツには、複数の言語がリストされる場合があります。たとえば、オリジナルのマオリ語と英語のバージョンで同時に提示された「ワイタンギの条約」の表現では、Content-Language：mi、ただし、エンティティ内に複数の言語が存在するからといって、それが複数の言語の対象者を対象としていることを意味するわけではありません。例としては、「ラテン語での最初のレッスン」などの初心者向けの言語入門があります。これは、明らかに英語の知識のある読者が使用することを目的としています。この場合、Content-Languageには「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。Content-Languageには、「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。Content-Languageには、「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Lengthエンティティヘッダーフィールドは、10進数のOCTETで受信者に送信されたエンティティボディのサイズを示します。または、HEADメソッドの場合、送信されたはずのエンティティボディのサイズを示します。リクエストはGETでした。 Content-Length = &quot;Content-Length&quot; &quot;：&quot; 1 * DIGIT例はContent-Length：3495です。これは、&lt;a href=&quot;#section-4.4&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4の&lt;/a&gt;ルールで禁止されている場合を除き、このフィールドを使用してメッセージ本文の転送長を示す必要があります（SHOULD）。。ゼロ以上のContent-Lengthは有効な値です。 &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;Content-Lengthが指定されていない場合にメッセージ本文の長さを決定する方法について説明します。このフィールドの意味は、MIMEの対応する定義とは大きく異なります。MIMEでは、「message / external-body」コンテンツタイプ内で使用されるオプションのフィールドです。 HTTPでは、&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4の&lt;/a&gt;ルールで禁止されていない限り、転送前にメッセージの長さを決定できる場合は常に送信する必要があります 。</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Content-Locationエンティティヘッダーフィールドは、要求されたリソースのURIとは別の場所からエンティティにアクセスできる場合、メッセージに含まれるエンティティのリソースの場所を提供するために使用できます。サーバーは、応答エンティティに対応するバリアントのContent-Locationを提供する必要があります（SHOULD）。特に、リソースに複数のエンティティが関連付けられていて、それらのエンティティが実際に個別にアクセスできる個別の場所を持っている場合、サーバーは、返される特定のバリアントのContent-Locationを提供する必要があります（SHOULD）。 Content-Location = &quot;Content-Location&quot; &quot;：&quot;（absoluteURI | relativeURI）Content-Locationの値は、エンティティのベースURIも定義します。Content-Location値は、要求された元のURIの代わりにはなりません。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つのリクエストされたリソースから取得した複数のエンティティを区別できます。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つのリクエストされたリソースから取得した複数のエンティティを区別できます。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。&lt;a href=&quot;#section-13.6&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;。Content-Locationが相対URIの場合、相対URIはRequest-URIに関連して解釈されます。PUTまたはPOSTリクエストのContent-Locationヘッダーの意味は定義されていません。これらの場合、サーバーは自由に無視できます。</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]で定義されている Content-MD5エンティティヘッダーフィールドは、エンティティボディのエンドツーエンドのメッセージ整合性チェック（MIC）を提供するためのエンティティボディのMD5ダイジェストです。（注：MICは、転送中のエンティティ本体の偶発的な変更を検出するのに適していますが、悪意のある攻撃に対する証拠ではありません。）Content-MD5 = &quot;Content-MD5&quot; &quot;：&quot; md5-digest md5-digest = &amp;lt;base64 of &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864に&lt;/a&gt;基づく128ビットMD5ダイジェスト&amp;gt; Content-MD5ヘッダーフィールドは、エンティティボディの整合性チェックとして機能するために、オリジンサーバーまたはクライアントによって生成される場合があります。起点サーバーまたはクライアントのみがContent-MD5ヘッダーフィールドを生成できます。プロキシとゲートウェイはそれを生成してはなりません。これは、エンドツーエンドの整合性チェックとしてその値を無効にするためです。ゲートウェイやプロキシを含むエンティティ本体の受信者は、このヘッダーフィールドのダイジェスト値が受信したエンティティ本体のダイジェスト値と一致することを確認できます（MAY）。 MD5ダイジェストは、エンティティ本体のコンテンツに基づいて計算されます。これには、適用されたコンテンツコーディングは含まれますが、メッセージ本体に適用された転送エンコーディングは含まれません。メッセージがtransfer-encodingで受信された場合、Content-MD5値を受信エンティティと照合する前に、そのエンコーディングを削除する必要があります。これは、ダイジェストがエンティティボディのオクテットで正確に計算され、転送エンコーディングが適用されていなかった場合に送信されるという結果になります。 HTTP拡張&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;MIMEコンポジットメディアタイプ（例：multipart / *およびmessage / rfc822）のダイジェストを計算できるようにしますが、前の段落で定義したようにダイジェストの計算方法は変わりません。これにはいくつかの影響があります。複合型のエンティティボディには、それぞれが独自のMIMEおよびHTTPヘッダー（Content-MD5、Content-Transfer-Encoding、およびContent-Encodingヘッダーを含む）を持つ多くのボディパーツを含めることができます（MAY）。 body-partにContent-Transfer- EncodingまたはContent-Encodingヘッダーがある場合、body-partのコンテンツにはエンコードが適用されていると見なされ、body-partはそのままContent-MD5ダイジェストに含まれます-つまり、アプリケーションの後。 Transfer-Encodingヘッダーフィールドは、body-parts内では許可されていません。すべての改行のCRLFへの変換は、ダイジェストを計算またはチェックする前に行わないでください。実際に送信されるテキストで使用される改行規則は、ダイジェストを計算するときに変更しないでください。注：Content-MD5の定義は、HTTPの場合とまったく同じです。&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;MIMEエンティティボディのRFC 1864では、Content-MD5のHTTPエンティティボディへの適用と、MIMEエンティティボディへの適用が異なるいくつかの方法があります。 1つは、MIMEとは異なり、HTTPはContent-Transfer-Encodingを使用せず、Transfer-EncodingとContent-Encodingを使用することです。もう1つは、HTTPがMIMEよりもバイナリコンテンツタイプをより頻繁に使用することです。そのため、そのような場合、ダイジェストの計算に使用されるバイトオーダーは、タイプに定義された送信バイトオーダーです。最後に、HTTPでは、CRLFを使用した標準形式だけでなく、いくつかの改行規則のいずれかを使用してテキストタイプを送信できます。</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Rangeエンティティヘッダーは、エンティティボディの一部とともに送信され、エンティティボディ全体のどこに部分ボディを適用するかを指定します。範囲の単位は&lt;a href=&quot;#section-3.12&quot;&gt;セクション3.12で&lt;/a&gt;定義されています。 Content-Range = &quot;Content-Range&quot; &quot;：&quot; content-range-spec content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec &quot; / &quot;（instance-length |&quot; * &quot;）byte-range-resp-spec =（first-byte-pos&quot;-&quot;last-byte-pos）| &quot;*&quot; instance-length = 1 * DIGITヘッダーは、この長さが不明であるか判別が困難でない限り、エンティティ本体全体の全長を示す必要があります（SHOULD）。アスタリスク「*」文字は、応答が生成された時点ではインスタンスの長さが不明であることを意味します。バイト範囲指定子の値とは異なり（&lt;a href=&quot;#section-14.35.1&quot;&gt;セクション14.35.1を&lt;/a&gt;参照））、byte-range-resp-specは1つの範囲のみを指定する必要があり、範囲の最初と最後の両方のバイトの絶対バイト位置を含める必要があります。 last-byte-posの値がfirst-byte-posの値よりも小さいか、instance-lengthの値が最後のバイト以下のbyte-range-resp-specを持つbyte-content-range-specバイト位置の値が無効です。無効なbyte-content-range- specの受信者は、それとそれとともに転送されるすべてのコンテンツを無視する必要があります。ステータスコード416（要求された範囲を満たしていない）で応答を送信するサーバーは、バイト範囲のresp-specが「*」のContent-Rangeフィールドを含める必要があります（SHOULD）。 instance-lengthは、選択されたリソースの現在の長さを指定します。ステータスコード206（部分的なコンテンツ）の応答には、byte-range- resp-specが &quot;*&quot;のContent-Rangeフィールドを含めてはなりません（MUST NOT）。エンティティに合計1234バイトが含まれていると仮定した場合の、byte-content-range-spec値の例：最初の500バイト：バイト0-499 / 1234。 2番目の500バイト：バイト500-999 / 1234。最初の500バイトを除くすべて：バイト500-1233 / 1234。最後の500バイト：バイト734-1233 / 1234 HTTPメッセージに単一の範囲のコンテンツが含まれている場合（たとえば、単一の範囲の要求への応答、または穴のない重複する一連の範囲の要求への応答） ）、このコンテンツはContent-Rangeヘッダー、および実際に転送されたバイト数を示すContent-Lengthヘッダーとともに送信されます。たとえば、HTTP / 1です。1 206部分的なコンテンツ日付：1995年11月15日水曜日06:25:24 GMT最終更新日：1995年11月15日水曜日04:58:08 GMTコンテンツ範囲：バイト21010-47021 / 47022コンテンツ長：26012コンテンツタイプ：image / gif HTTPメッセージに複数の範囲のコンテンツ（たとえば、重複しない複数の範囲に対する要求への応答）が含まれている場合、これらはマルチパートメッセージとして送信されます。この目的で使用されるマルチパートメディアタイプは、付録19.2で定義されている「multipart / byteranges」です。互換性の問題については、付録19.6.3を参照してください。単一の範囲の要求に対する応答は、multipart / byterangesメディアタイプを使用して送信してはなりません（MUST NOT）。結果が単一の範囲である複数の範囲に対する要求への応答は、1つの部分を持つmultipart / byterangesメディアタイプとして送信される場合があります。multipart / byterangesメッセージをデコードできないクライアントは、単一のリクエストで複数のバイト範囲を要求してはなりません（MUST NOT）。クライアントが1つの要求で複数のバイト範囲を要求すると、サーバーは、要求に現れた順序でそれらを返す必要があります（SHOULD）。構文的に無効であるためにサーバーがbyte-range-specを無視する場合、サーバーはリクエストを無効なRangeヘッダーフィールドが存在しないかのように処理する必要があります（SHOULD）。 （通常、これはエンティティ全体を含む200応答を返すことを意味します）。サーバーが要求（If- Range request-headerフィールドを含むものを除く）を、満たされないRange request-ヘッダーフィールド（つまり、すべてのbyte-range-spec値のfirst-byte-pos値が大きい）で受信した場合選択したリソースの現在の長さよりも）、応答コード416（要求された範囲を満足できない）を返す必要があります（&lt;a href=&quot;#section-10.4.17&quot;&gt;セクション10.4.17&lt;/a&gt;）。注：すべてのサーバーがこのリクエストヘッダーを実装しているわけではないため、クライアントはサーバーに依存して、満足できない範囲のリクエストヘッダーに対して200（OK）応答の代わりに416（要求された範囲が満足できない）応答を送信することはできません。</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Typeエンティティヘッダーフィールドは、受信者に送信されたエンティティボディのメディアタイプを示します。HEADメソッドの場合は、リクエストがGETであった場合に送信されるメディアタイプを示します。 Content-Type = &quot;Content-Type&quot; &quot;：&quot; media-typeメディアタイプは&lt;a href=&quot;#section-3.7&quot;&gt;セクション3.7で&lt;/a&gt;定義されています。フィールドの例はContent-Type：text / htmlです。 charset = ISO-8859-4エンティティのメディアタイプを識別する方法の詳細については、&lt;a href=&quot;#section-7.2.1&quot;&gt;セクション7.2.1を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d09adc4e47017807bd60018491b4e8efd7bba713" translate="yes" xml:space="preserve">
          <source>The Cookie header field [&lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;] uses a semi-colon (&quot;;&quot;) to delimit
   cookie-pairs (or &quot;crumbs&quot;).  This header field doesn't follow the
   list construction rules in HTTP (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.2&lt;/a&gt;), which
   prevents cookie-pairs from being separated into different name-value
   pairs.  This can significantly reduce compression efficiency as
   individual cookie-pairs are updated.

   To allow for better compression efficiency, the Cookie header field
   MAY be split into separate header fields, each with one or more
   cookie-pairs.  If there are multiple Cookie header fields after
   decompression, these MUST be concatenated into a single octet string
   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string &quot;; &quot;)
   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
   connection, or a generic HTTP server application.

   Therefore, the following two lists of Cookie header fields are
   semantically equivalent.

     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f</source>
          <target state="translated">Cookieヘッダーフィールド[ &lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt; ]は、セミコロン（ &quot;;&quot;）を使用してCookieペア（または &quot;クラム&quot;）を区切ります。このヘッダーフィールドは、HTTPのリスト構築ルールに準拠していません（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230]、セクション3.2.2を&lt;/a&gt;参照）。）。これにより、Cookieペアが異なる名前と値のペアに分離されるのを防ぎます。これにより、個々のCookieペアが更新されるため、圧縮効率が大幅に低下する可能性があります。圧縮効率を高めるために、Cookieヘッダーフィールドを個別のヘッダーフィールドに分割し、それぞれに1つ以上のCookieペアを含めることができます。解凍後に複数のCookieヘッダーフィールドがある場合、HTTP / 2以外のコンテキストに渡される前に、0x3B、0x20（ASCII文字列 &quot;;&quot;）の2オクテット区切り文字を使用してこれらを1つのオクテット文字列に連結する必要があります。 HTTP / 1.1接続、または汎用HTTPサーバーアプリケーションとして。したがって、次の2つのCookieヘッダーフィールドのリストは意味的に同等です。クッキー：a = b; c = d; e = f cookie：a = b cookie：c = d cookie：e = f</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Cross-Origin Resource Sharing標準は、サーバーがWebブラウザーを使用してその情報を読み取ることが許可されているオリジンのセットを記述できるようにする新しい&lt;a href=&quot;headers&quot;&gt;HTTPヘッダー&lt;/a&gt;を追加することで機能します。さらに、サーバーのデータに副作用を引き起こす可能性のあるHTTP要求メソッド（特に、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外のHTTPメソッド、または特定の&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;での&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;使用）の場合、仕様はブラウザーが要求を「プリフライト」し、サポートされているメソッドを要求することを義務付けています。 HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;要求メソッドを使用してサーバーから送信し、サーバーからの「承認」時に、実際のHTTP要求メソッドを使用して実際の要求を送信します。サーバーは、「資格情報」かどうかをクライアントに通知することもできます（ &lt;a href=&quot;cookies&quot;&gt;クッキーを含む&lt;/a&gt;HTTP認証データ）はリクエストとともに送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="translated">クロスオリジンリソースシェアリング標準は、サーバーがWebブラウザーからその情報を読み取ることを許可されているオリジンを記述できるようにする新しい&lt;a href=&quot;headers&quot;&gt;HTTPヘッダー&lt;/a&gt;を追加することによって機能します。さらに、サーバーデータに副作用を引き起こす可能性のあるHTTPリクエストメソッド（特に、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外のHTTPメソッド、または特定の&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIMEタイプの&lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;）の場合、仕様では、ブラウザーがリクエストを「プリフライト」し、サーバーからサポートされているメソッドを要求することを義務付けています。 HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;リクエストメソッドを使用し、サーバーからの「承認」時に実際のリクエストを送信します。サーバーは、「資格情報」（&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;や&lt;a href=&quot;authentication&quot;&gt;HTTP認証&lt;/a&gt;など）かどうかをクライアントに通知することもできます。）リクエストとともに送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">コレクション上のDELETEメソッドは、&quot;Depth:infinity &quot;ヘッダが使用されたかのように動作しなければならない[MUST]。クライアントは、無限大以外の値を持つコレクションに対してDELETEでDepthヘッダーを提出してはならない[MUST NOT]。DELETEは、Request-URIで指定されたコレクションと、その内部のメンバURLで識別されるすべてのリソー スを削除することを指示する。メンバーの URL で識別されるリソースを削除できない場合は、URL 名前空間の一貫性を維持するために、そのメンバーのすべての祖先を削除してはなりません[MUST NOT]。DELETE に含まれるヘッダは、削除されるすべてのリソースの処理に適用されなければなりません(MUST)。DELETE メソッドが処理を完了したとき、一貫性のある URL 名前空間が得られなければなりません[MUST]。メンバーリソース(Request-URI で識別されたリソース以外のリソース)の削除でエラーが発生した場合、レスポンスは 207 (Multi-Status)になります。Multi-Status は、どの内部リソースが削除できなかったかをエラーコードを含めて示すために使用され、クライアントはどのリソースが失敗の原因となったのかを理解するのに役立つ。例えば、内部リソースがロックされていた場合、Multi-Status ボディにはステータス 423 (Locked)の応答を含めることができる。リクエストが完全に失敗した場合、サーバーは 207ではなく4xxというステータス応答を返してもよい[MAY]。424 (Failed Dependency)のステータスコードは、DELETE の 207 (Multi-Status)応答に含めるべきではない[SHOULD NOT]。なぜなら、クライアントが祖先の子孫に対するエラーを受け取ったときに、クライアントはリソースの祖先が削除できなかったことを知ることになるからである。さらに、204 (No Content)エラーは 207 (Multi-Status)で返されるべきではない[SHOULD NOT]。この禁止の理由は、204 (No Content)がデフォルトの成功コードであるためである。</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETEメソッドは、オリジンサーバーにRequest-URIで特定されたリソースの削除を要求します。このメソッドはオリジンサーバーの人間の介入(または他の手段)によって上書きしてもよい[MAY]。オリジンサーバーから返されるステータスコードがアクションが正常に完了したことを 示していたとしても、クライアントは操作が実行されたことを保証できない。しかしながら、応答が与えられた時点で、サーバーがリソースを削除するか、 アクセスできない場所に移動することを意図しない限り、サーバーは成功を示すべきでは ない[SHOULD NOT]。成功した応答は、応答がステータスを記述するエンティティを含む場合は200 (OK)、アクションがまだ実行されていない場合は202(Accepted)、アクションが 実行されているが応答がエンティティを含まない場合は204(No Content)であるべきである[SHOULD]。リクエストがキャッシュを通過し、Request-URIが現在キャッシュされている1つ以上の エンティティを識別する場合、それらのエントリは古いものとして扱われるべきである [SHOULD]。このメソッドに対する応答はキャッシュできない。</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETEメソッドは、オリジンサーバーがターゲットリソースとその現在の機能の間の関連付けを削除することを要求します。実際、このメソッドはUNIXのrmコマンドに似ています。以前関連付けられていた情報が削除されるという期待ではなく、オリジンサーバーのURIマッピングに対する削除操作を表します。ターゲットリソースに1つまたは複数の現在の表現がある場合、リソースの性質とオリジンサーバーによる実装に完全に依存して、それらはオリジンサーバーによって破棄される場合とされない場合があり、関連するストレージが再利用される場合とされない場合があります（この仕様の範囲外です）。同様に、DELETEの結果として、リソースの他の実装の側面を非アクティブ化またはアーカイブする必要がある場合があります。データベースやゲートウェイ接続など。一般に、元のサーバーは、削除を実行するための所定のメカニズムを持つリソースに対してのみDELETEを許可すると想定されています。比較的少数のリソースでDELETEメソッドを使用できます。その主な用途は、ユーザーがその効果について何らかの指示を与えるリモートオーサリング環境です。たとえば、以前にPUTリクエストを使用して作成されたリソース、またはPOSTリクエストに対する201（Created）レスポンスの後にLocationヘッダーフィールドで識別されたリソースは、対応するDELETEリクエストでそれらのアクションを取り消すことができます。同様に、リモート操作にHTTPを使用するリビジョンコントロールクライアントなどのオーサリング機能を実装するカスタムユーザーエージェントの実装では、サーバーが■URIスペースは、バージョンリポジトリに対応するように作成されています。 DELETEメソッドが正常に適用された場合、オリジンサーバーは、アクションが成功する可能性が高いがまだ制定されていない場合は202（Accepted）ステータスコードを送信し、アクションが制定されている場合は204（No Content）ステータスコードを送信します。情報が提供されます。アクションが実行され、応答メッセージにステータスを表す表現が含まれている場合は、200（OK）ステータスコード。 DELETEリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。 DELETEリクエストでペイロード本体を送信すると、一部の既存の実装がリクエストを拒否する可能性があります。 DELETEメソッドへの応答はキャッシュできません。 DELETE要求が、有効な要求URIに対する1つ以上の応答が格納されているキャッシュを通過する場合、これらの保存された応答は無効になります（参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]のセクション4.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">Date general-headerフィールドは、メッセージが発信された日時を表し、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822の&lt;/a&gt; orig-dateと同じセマンティクスを持ってい ます。&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1で&lt;/a&gt;説明されているように、フィールド値はHTTP日付です。それを送らなければなりません&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-日付形式。日付= &quot;日付&quot; &quot;：&quot; HTTP-date例は日付：火、1994年11月15日08:12:31 GMTオリジンサーバーは、以下の場合を除いて、すべての応答に日付ヘッダーフィールドを含める必要があります。1.応答ステータスの場合コードが100（続行）または101（スイッチングプロトコル）の場合、サーバーのオプションで、応答に日付ヘッダーフィールドを含めることができます（MAY）。 2.応答ステータスコードが500（内部サーバーエラー）や503（サービス利用不可）などのサーバーエラーを伝え、有効な日付を生成することが不便または不可能である場合。 3.サーバーが現在の時刻の妥当な概算を提供できるクロックを備えていない場合、その応答に日付ヘッダーフィールドを含めてはなりません（MUST NOT）。この場合、&lt;a href=&quot;#section-14.18.1&quot;&gt;セクション14.18.1のルール&lt;/a&gt;従わなければなりません。メッセージがその受信者によってキャッシュされるか、または日付を必要とするプロトコルを介してゲートウェイ処理される場合は、Dateヘッダーフィールドを持たない受信メッセージに受信者が割り当てる必要があります。クロックのないHTTP実装は、使用するたびに再検証せずに応答をキャッシュしてはなりません（MUST NOT）。 HTTPキャッシュ、特に共有キャッシュでは、NTPなどのメカニズムを使用する必要があります[ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;]、そのクロックを信頼できる外部標準と同期させます。クライアントは、PUTおよびPOSTリクエストの場合のように、エンティティボディを含むメッセージで日付ヘッダーフィールドのみを送信する必要があります（SHOULD）。それでもオプションです。クロックのないクライアントは、リクエストで日付ヘッダーフィールドを送信してはなりません（MUST NOT）。 Dateヘッダーで送信されるHTTP日付は、メッセージの生成後の日付と時刻を表すべきではありません（SHOULD NOT）。これは、実装が合理的に正確な日付と時刻を生成する手段を持っていない場合を除き、メッセージ生成の日付と時刻の利用可能な最良の概算を表す必要があります。理論的には、日付はエンティティが生成される直前の瞬間を表す必要があります。実際には、日付は、メッセージのセマンティック値に影響を与えることなく、メッセージの発信中にいつでも生成できます。</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">Depth ヘッダは LOCK メソッドで使用できる。0 または無限大以外の値は、LOCK メ ソッドのDepth ヘッダーで使用してはならない[MUST NOT]。LOCK メソッドをサポートするすべてのリソースは、Depth ヘッダをサポートしなければならない[MUST]。値0のDepthヘッダーは、Request-URIで指定されたリソースを単にロックすることを意味する。Depthヘッダーが無限大に設定されている場合、Request-URIで指定されたリソー スとそのすべてのメンバ(階層の下のすべての階層)がロックされる。結果が成功した場合、1つのロックトークンを返さなければならない[MUST]。同様に、このトークンに対してUNLOCKが成功した場合、関連するすべてのリソースはロック解除されます。したがって、LOCK や UNLOCK には部分的な成功は許されない。階層全体がロックされているか、リソースがロックされていないかのどちらかになります。すべてのリソースに対してロックを付与できなかった場合、サーバは、ロックが付与されなかった少なくとも 1 つのリソースの「response」要素を含む Multi-Status レスポンスを、その失敗に適したステータスコード (403 (Forbidden)や 423 (Locked)など)とともに返さなければならない[MUST]。さらに、失敗の原因となったリソースがリクエストされたリソースではない場合、 サーバーはRequest-URIに対しても同様に、Failed Dependencyを含む「status」要素を含む「response」 要素を含めるべきである[SHOULD]。LOCKリクエストでDepthヘッダーがサブミットされない場合、リクエストは 「Depth:infinity」がサブミットされたかのように動作しなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Destinationリクエストヘッダーは、2つのURIをパラメーターとして受け取るCOPYやMOVEなどのメソッドの宛先リソースを識別するURIを指定します。 Destination = &quot;Destination&quot; &quot;：&quot; Simple-ref Destinationの値が絶対URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]のセクション4.3&lt;/a&gt;）の場合、別のサーバー（または別のポートやスキーム）を指定する場合があります。ソースサーバーがリモートサーバーへのコピーを試行できない場合、要求は失敗する必要があります。リソースをリモートサーバーにコピーおよび移動することは、この仕様では完全には定義されていません（たとえば、特定のエラー条件）。 Destination値が長すぎるか、それ以外の場合は受け入れられない場合、サーバーはエラー本文に役立つ情報を含めて、理想的には400（Bad Request）を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETagレスポンスヘッダーフィールドは、リクエストされたバリアントのエンティティタグの現在の値を提供します。エンティティタグと共に使用されるヘッダはセクションに記載されており&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;、&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;及び&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。エンティティタグは、同じリソースの他のエンティティとの比較に使用できます（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を&lt;/a&gt;参照）。 ETag = &quot;ETag&quot; &quot;：&quot;エンティティタグ例：ETag： &quot;xyzzy&quot; ETag：W / &quot;xyzzy&quot; ETag： &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">ETag応答ヘッダーフィールドの値であるエンティティタグは、「不透明な」キャッシュバリデーターを提供します。これにより、HTTP日付値の1秒の解決では不十分な場合、または元のサーバーが変更日付の使用から生じる可能性がある特定のパラドックスを回避したい場合に、変更日付を保存するのが不便な状況で、より信頼できる検証が可能になります。 。エンティティタグについては、&lt;a href=&quot;#section-3.11&quot;&gt;セクション3.11で&lt;/a&gt;説明しています。エンティティタグと共に使用されるヘッダはセクションに記載されており&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;、&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;、&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;及び&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expectリクエストヘッダーフィールドは、特定のサーバー動作がクライアントに必要であることを示すために使用されます。 Expect = &quot;Expect&quot; &quot;：&quot; 1＃expectation expectation = &quot;100-continue&quot; | expectation-extension expectation-extension = token [&quot;=&quot;（token | quoted-string）* expect-params] expect-params = &quot;;&quot;トークン[&quot;=&quot;（トークン| quoted-string）]リクエストのExpectフィールドの期待値を理解できないか、またはそれらに準拠できないサーバーは、適切なエラーステータスで応答する必要があります。サーバーは、期待値のいずれかが満たされない場合、または要求に他の問題がある場合、他の4xxステータスがある場合、417（期待値失敗）ステータスで応答する必要があります。このヘッダーフィールドは、将来の拡張に備えて拡張可能な構文で定義されています。サーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る見る見る見る見る見る見るサーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見るサーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る見る見る期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る1つのプロキシは、満たすことができないという期待のある要求を受け取った場合、417（期待失敗）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る1つのプロキシは、満たすことができないという期待のある要求を受け取った場合、417（期待失敗）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る&lt;a href=&quot;#section-8.2.3&quot;&gt;&lt;/a&gt;100（継続）ステータスの使用については、セクション8.2.3。</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expiresエンティティヘッダーフィールドは、応答が古くなったと見なされるまでの日時を示します。古いキャッシュエントリは通常、最初にオリジンサーバー（またはエンティティの新しいコピーを持つ中間キャッシュ）で検証されない限り、キャッシュ（プロキシキャッシュまたはユーザーエージェントキャッシュ）によって返されない場合があります。有効期限モデルの詳細については、&lt;a href=&quot;#section-13.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;を参照してください。Expiresフィールドの存在は、元のリソースがその時点で、前に、または後に変更または存在しなくなることを意味しません。形式は、&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1の&lt;/a&gt; HTTP-dateで定義されている絶対日時 です。&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;にある必要があります日付形式：Expires = &quot;Expires&quot; &quot;：&quot; HTTP-date使用例はExpires：Thu、01 Dec 1994 16:00:00 GMT注：応答にmax-ageディレクティブのCache-Controlフィールドが含まれている場合（&lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3を&lt;/a&gt;参照）、そのディレクティブはExpiresフィールドをオーバーライドします。 HTTP / 1.1クライアントとキャッシュは、他の無効な日付形式、特に過去のように値「0」を含む（つまり、「期限切れ」）を扱わなければなりません（MUST）。応答を「期限切れ」としてマークするために、オリジンサーバーはDateヘッダー値と等しいExpires日付を送信します。 （&lt;a href=&quot;#section-13.2.4&quot;&gt;セクション13.2.4の&lt;/a&gt;有効期限計算のルールを参照してください。）応答に「有効期限なし」のマークを付けるために、オリジンサーバーは、応答が送信されてから約1年後にExpires日付を送信します。 HTTP / 1.1サーバーは、1年以上先のExpires日付を送信してはなりません（SHOULD NOT）。そうでなければデフォルトでキャッシュ不可になるであろう応答の将来の日付の値を持つExpiresヘッダーフィールドが存在することは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;）で特に示されていない限り、応答がキャッシュ可能であることを示します。。</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="translated">&lt;code&gt;allowlist&lt;/code&gt; を適用する機能ポリシーディレクティブ。許可されるディレクティブ名のリストについては、以下の&lt;a href=&quot;#Directives&quot;&gt;ディレクティブを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">Feature-Policy HTTP ヘッダ</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">From request-headerフィールドが指定されている場合、SHOULDには、要求しているユーザーエージェントを制御する人間のユーザーのインターネット電子メールアドレスが含まれている必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8で&lt;/a&gt;更新された&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]の「メールボックス」で定義されているように、アドレスはマシンで使用できる必要があります（SHOULD）。]：From = &quot;From&quot; &quot;：&quot;メールボックス例は次のとおりです。From：webmaster@w3.orgこのヘッダーフィールドは、ログ記録の目的で、無効なリクエストや不要なリクエストのソースを特定する手段として使用できます。安全でない形式のアクセス保護として使用しないでください。このフィールドの解釈は、実行されたメソッドの責任を受け入れる、指定された人に代わってリクエストが実行されているということです。特に、ロボットエージェントには、受信側で問題が発生した場合にロボットの実行責任者に連絡できるように、このヘッダーを含める必要があります（SHOULD）。このフィールドのインターネット電子メールアドレスは、要求を発行したインターネットホストとは別の場合があります。たとえば、リクエストがプロキシを介して渡されると、元の発行者の■アドレスを使用する必要があります。クライアントは、ユーザーのプライバシー上の関心やサイトのセキュリティポリシーと競合する可能性があるため、ユーザーの承認なしにFromヘッダーフィールドを送信しないでください。ユーザーがリクエストの前にいつでもこのフィールドの値を無効化、有効化、および変更できるようにすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GETメソッドは、Request-URIで識別される情報（エンティティーの形式）を取得します。 Request-URIがデータ生成プロセスを参照する場合、そのテキストがたまたまプロセスの出力でない限り、プロセスのソーステキストではなく、応答のエンティティとして返されるのは生成されたデータです。リクエストメッセージにIf-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match、またはIf-Rangeヘッダーフィールドが含まれている場合、GETメソッドのセマンティクスは「条件付きGET」に変わります。条件付きGETメソッドは、条件付きヘッダーフィールドで記述された状況でのみエンティティを転送するよう要求します。条件付きGETメソッドは、複数のリクエストを要求したり、クライアントがすでに保持しているデータを転送したりせずに、キャッシュされたエンティティを更新できるようにすることで、不要なネットワーク使用量を減らすことを目的としています。リクエストメッセージにRangeヘッダーフィールドが含まれている場合、GETメソッドのセマンティクスは「部分的なGET」に変わります。部分的なGETは、エンティティの一部のみを転送するように要求します。&lt;a href=&quot;#section-14.35&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;。部分的なGETメソッドは、クライアントがすでに保持しているデータを転送せずに部分的に取得されたエンティティを完了できるようにすることで、不要なネットワーク使用量を減らすことを目的としています。 GET要求への応答は、&lt;a href=&quot;#section-13&quot;&gt;セクション13で&lt;/a&gt;説明されているHTTPキャッシングの要件を満たしている場合にのみキャッシュ可能です。フォームに使用する場合のセキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GETメソッドは、ターゲットリソースの現在選択されている表現の転送を要求します。 GETは情報検索の主要なメカニズムであり、ほとんどすべてのパフォーマンス最適化の焦点です。したがって、人々がHTTPを介して特定の情報を取得することについて話すとき、彼らは一般にGETリクエストを行うことを指します。リソース識別子をリモートファイルシステムのパス名として、表現をそのようなファイルの内容のコピーとして考えるのは魅力的です。実際、これが実装されているリソースの数です（&lt;a href=&quot;#section-9.1&quot;&gt;9.1項を&lt;/a&gt;参照）。 関連するセキュリティ上の考慮事項について）。ただし、実際にはそのような制限はありません。リソースのHTTPインターフェースは、コンテンツオブジェクトのツリー、さまざまなデータベースレコードのプログラムビュー、または他の情報システムへのゲートウェイとして実装される可能性が高いです。 URIマッピングメカニズムがファイルシステムに関連付けられている場合でも、ファイルを直接転送するのではなく、要求を入力としてファイルを実行し、表現として出力を送信するようにオリジンサーバーが構成されている場合があります。いずれにせよ、オリジンサーバーだけが、そのリソース識別子が実装にどのように対応するか、および各実装がGETへの応答でターゲットリソースの現在の表現を選択して送信する方法を知る必要があります。クライアントは、GETのセマンティクスを「」に変更できますリクエストでRangeヘッダーフィールドを送信して、選択された表現の一部のみの転送をリクエストします。&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]）。GETリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。GETリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する場合があります。GET要求への応答はキャッシュ可能です。キャッシュは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2）で&lt;/a&gt;特に示されていない限り、後続のGETおよびHEAD要求を満たすためにそれを使用できます（MAY ）。</target>
        </trans-unit>
        <trans-unit id="7d2462324b684ba6bb0e708d0480d884f24bd586" translate="yes" xml:space="preserve">
          <source>The GOAWAY frame (type=0x7) is used to initiate shutdown of a
   connection or to signal serious error conditions.  GOAWAY allows an
   endpoint to gracefully stop accepting new streams while still
   finishing processing of previously established streams.  This enables
   administrative actions, like server maintenance.

   There is an inherent race condition between an endpoint starting new
   streams and the remote sending a GOAWAY frame.  To deal with this
   case, the GOAWAY contains the stream identifier of the last peer-
   initiated stream that was or might be processed on the sending
   endpoint in this connection.  For instance, if the server sends a
   GOAWAY frame, the identified stream is the highest-numbered stream
   initiated by the client.

   Once sent, the sender will ignore frames sent on streams initiated by
   the receiver if the stream has an identifier higher than the included
   last stream identifier.  Receivers of a GOAWAY frame MUST NOT open
   additional streams on the connection, although a new connection can
   be established for new streams.

   If the receiver of the GOAWAY has sent data on streams with a higher
   stream identifier than what is indicated in the GOAWAY frame, those
   streams are not or will not be processed.  The receiver of the GOAWAY
   frame can treat the streams as though they had never been created at
   all, thereby allowing those streams to be retried later on a new
   connection.

   Endpoints SHOULD always send a GOAWAY frame before closing a
   connection so that the remote peer can know whether a stream has been
   partially processed or not.  For example, if an HTTP client sends a
   POST at the same time that a server closes a connection, the client
   cannot know if the server started to process that POST request if the
   server does not send a GOAWAY frame to indicate what streams it might
   have acted on.

   An endpoint might choose to close a connection without sending a
   GOAWAY for misbehaving peers. 

   A GOAWAY frame might not immediately precede closing of the
   connection; a receiver of a GOAWAY that has no more use for the
   connection SHOULD still send a GOAWAY frame before terminating the
   connection.

    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     Figure 13: GOAWAY Payload Format

   The GOAWAY frame does not define any flags.

   The GOAWAY frame applies to the connection, not a specific stream.
   An endpoint MUST treat a GOAWAY frame with a stream identifier other
   than 0x0 as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The last stream identifier in the GOAWAY frame contains the highest-
   numbered stream identifier for which the sender of the GOAWAY frame
   might have taken some action on or might yet take action on.  All
   streams up to and including the identified stream might have been
   processed in some way.  The last stream identifier can be set to 0 if
   no streams were processed.

      Note: In this context, &quot;processed&quot; means that some data from the
      stream was passed to some higher layer of software that might have
      taken some action as a result.

   If a connection terminates without a GOAWAY frame, the last stream
   identifier is effectively the highest possible stream identifier.

   On streams with lower- or equal-numbered identifiers that were not
   closed completely prior to the connection being closed, reattempting
   requests, transactions, or any protocol activity is not possible,
   with the exception of idempotent actions like HTTP GET, PUT, or
   DELETE.  Any protocol activity that uses higher-numbered streams can
   be safely retried using a new connection.

   Activity on streams numbered lower or equal to the last stream
   identifier might still complete successfully.  The sender of a GOAWAY
   frame might gracefully shut down a connection by sending a GOAWAY
   frame, maintaining the connection in an &quot;open&quot; state until all in-
   progress streams complete. 

   An endpoint MAY send multiple GOAWAY frames if circumstances change.
   For instance, an endpoint that sends GOAWAY with NO_ERROR during
   graceful shutdown could subsequently encounter a condition that
   requires immediate termination of the connection.  The last stream
   identifier from the last GOAWAY frame received indicates which
   streams could have been acted upon.  Endpoints MUST NOT increase the
   value they send in the last stream identifier, since the peers might
   already have retried unprocessed requests on another connection.

   A client that is unable to retry requests loses all requests that are
   in flight when the server closes the connection.  This is especially
   true for intermediaries that might not be serving clients using
   HTTP/2.  A server that is attempting to gracefully shut down a
   connection SHOULD send an initial GOAWAY frame with the last stream
   identifier set to 2^31-1 and a NO_ERROR code.  This signals to the
   client that a shutdown is imminent and that initiating further
   requests is prohibited.  After allowing time for any in-flight stream
   creation (at least one round-trip time), the server can send another
   GOAWAY frame with an updated last stream identifier.  This ensures
   that a connection can be cleanly shut down without losing requests.

   After sending a GOAWAY frame, the sender can discard frames for
   streams initiated by the receiver with identifiers higher than the
   identified last stream.  However, any frames that alter connection
   state cannot be completely ignored.  For instance, HEADERS,
   PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to
   ensure the state maintained for header compression is consistent (see
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); similarly, DATA frames MUST be counted toward the
   connection flow-control window.  Failure to process these frames can
   cause flow control or header compression state to become
   unsynchronized.

   The GOAWAY frame also contains a 32-bit error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) that
   contains the reason for closing the connection.

   Endpoints MAY append opaque data to the payload of any GOAWAY frame.
   Additional debug data is intended for diagnostic purposes only and
   carries no semantic value.  Debug information could contain security-
   or privacy-sensitive data.  Logged or otherwise persistently stored
   debug data MUST have adequate safeguards to prevent unauthorized
   access.</source>
          <target state="translated">GOAWAYフレーム（type = 0x7）は、接続のシャットダウンを開始するため、または重大なエラー状態を通知するために使用されます。 GOAWAYを使用すると、エンドポイントは、以前に確立されたストリームの処理を終了しながら、新しいストリームの受け入れを正常に停止できます。これにより、サーバーのメンテナンスなどの管理アクションが可能になります。新しいストリームを開始するエンドポイントとGOAWAYフレームを送信するリモートの間には固有の競合状態があります。このケースに対処するために、GOAWAYには、この接続の送信エンドポイントで処理された、または処理される可能性のある最後のピア開始ストリームのストリーム識別子が含まれています。たとえば、サーバーがGOAWAYフレームを送信する場合、識別されたストリームは、クライアントによって開始された最大番号のストリームです。送信したら、ストリームに含まれている最後のストリーム識別子よりも高い識別子がある場合、送信者は受信者によって開始されたストリームで送信されたフレームを無視します。 GOAWAYフレームの受信者は、接続で追加のストリームを開いてはなりませんが、新しいストリームに対して新しい接続を確立できます。 GOAWAYの受信者が、GOAWAYフレームに示されているものよりも高いストリーム識別子を持つストリームでデータを送信した場合、それらのストリームは処理されないか、処理されません。 GOAWAYフレームの受信者は、ストリームをまったく作成されていないかのように扱うことができるため、後で新しい接続でこれらのストリームを再試行できます。エンドポイントは、接続を閉じる前に常にGOAWAYフレームを送信して、リモートピアがストリームが部分的に処理されたかどうかを認識できるようにする必要があります。例えば、サーバーが接続を閉じると同時にHTTPクライアントがPOSTを送信する場合、サーバーがどのストリームに作用したかを示すGOAWAYフレームを送信しないと、クライアントはサーバーがそのPOST要求の処理を開始したかどうかを知ることができません。エンドポイントは、誤動作しているピアに対してGOAWAYを送信せずに接続を閉じることを選択する場合があります。 GOAWAYフレームは、接続が閉じる直前ではない場合があります。接続を使用しなくなったGOAWAYの受信者は、接続を終了する前にGOAWAYフレームを送信する必要があります。+-+ ----------------------------------------------- -------------- + | R | Last-Stream-ID（31）| +-+ ----------------------------------------------- -------------- + |エラーコード（32）| + ------------------------------------------------- -------------- + |追加のデバッグデータ（*）| + -------------------------------------------------- -------------- +図13：GOAWAYペイロード形式GOAWAYフレームはフラグを定義しません。 GOAWAYフレームは、特定のストリームではなく、接続に適用されます。エンドポイントは、0x0以外のストリーム識別子を持つGOAWAYフレームを接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。 GOAWAYフレームの最後のストリーム識別子には、GOAWAYフレームの送信者が何らかのアクションを実行したか、まだアクションを実行していない可能性のある最大番号のストリーム識別子が含まれています。識別されたストリームまでのすべてのストリームは、何らかの方法で処理された可能性があります。ストリームが処理されなかった場合は、最後のストリーム識別子を0に設定できます。注：このコンテキストでは、「処理済み」とは、ストリームからの一部のデータが、結果として何らかのアクションを実行した可能性のあるソフトウェアの上位層に渡されたことを意味します。接続がGOAWAYフレームなしで終了する場合、最後のストリーム識別子は事実上可能な限り高いストリーム識別子です。接続が閉じられる前に完全に閉じられなかった、より少ない番号または同じ番号の識別子を持つストリームで、要求、トランザクションを再試行し、または、HTTP GET、PUT、またはDELETEなどのべき等アクションを除いて、プロトコルアクティビティは不可能です。番号の大きいストリームを使用するプロトコルアクティビティは、新しい接続を使用して安全に再試行できます。最後のストリーム識別子以下の番号のストリームでのアクティビティは、引き続き正常に完了する可能性があります。 GOAWAYフレームの送信者は、GOAWAYフレームを送信して接続を正常にシャットダウンし、進行中のすべてのストリームが完了するまで接続を「オープン」状態に維持する場合があります。状況が変化した場合、エンドポイントは複数のGOAWAYフレームを送信してもよい[MAY]。たとえば、正常なシャットダウン中にNO_ERRORを指定してGOAWAYを送信するエンドポイントは、その後、接続の即時終了を必要とする状態に遭遇する可能性があります。受信した最後のGOAWAYフレームからの最後のストリーム識別子は、どのストリームが処理された可能性があるかを示します。ピアは別の接続で未処理のリクエストをすでに再試行している可能性があるため、エンドポイントは最後のストリーム識別子で送信する値を増やしてはなりません（MUSTNOT）。リクエストを再試行できないクライアントは、サーバーが接続を閉じると、処理中のすべてのリクエストを失います。これは、HTTP / 2を使用してクライアントにサービスを提供していない可能性のある仲介者に特に当てはまります。接続を正常にシャットダウンしようとしているサーバーは、最後のストリーム識別子が2 ^ 31-1に設定された最初のGOAWAYフレームとNO_ERRORコードを送信する必要があります。これは、シャットダウンが差し迫っていること、およびそれ以上の要求の開始が禁止されていることをクライアントに通知します。飛行中のストリーム作成のための時間（少なくとも1回のラウンドトリップ時間）を許可した後、サーバーは、更新された最後のストリーム識別子を使用して別のGOAWAYフレームを送信できます。これにより、リクエストを失うことなく接続を正常にシャットダウンできます。 GOAWAYフレームを送信した後、送信者は、識別された最後のストリームよりも高い識別子を持つ、受信者によって開始されたストリームのフレームを破棄できます。ただし、接続状態を変更するフレームは完全に無視できません。たとえば、HEADERS、PUSH_PROMISE、およびCONTINUATIONフレームは、ヘッダー圧縮のために維持される状態が一貫していることを保証するために、最小限に処理する必要があります（を参照）。送信者は、識別された最後のストリームよりも高い識別子を持つ受信者によって開始されたストリームのフレームを破棄できます。ただし、接続状態を変更するフレームは完全に無視できません。たとえば、HEADERS、PUSH_PROMISE、およびCONTINUATIONフレームは、ヘッダー圧縮のために維持される状態が一貫していることを保証するために、最小限に処理する必要があります（を参照）。送信者は、識別された最後のストリームよりも高い識別子を持つ受信者によって開始されたストリームのフレームを破棄できます。ただし、接続状態を変更するフレームは完全に無視できません。たとえば、HEADERS、PUSH_PROMISE、およびCONTINUATIONフレームは、ヘッダー圧縮のために維持される状態が一貫していることを保証するために、最小限に処理する必要があります（を参照）。&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）; 同様に、DATAフレームは接続フロー制御ウィンドウにカウントされる必要があります。これらのフレームの処理に失敗すると、フロー制御またはヘッダー圧縮状態が非同期になる可能性があります。GOAWAYフレームには、接続を閉じる理由を含む32ビットエラーコード（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）も含まれています。エンドポイントは、GOAWAYフレームのペイロードに不透明（OPAQUE）データを追加できます（MAY）。追加のデバッグデータは診断のみを目的としており、セマンティック値はありません。デバッグ情報には、セキュリティまたはプライバシーに配慮したデータが含まれている可能性があります。ログに記録された、または永続的に保存されたデバッグデータには、不正アクセスを防ぐための適切な保護手段が必要です。</target>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="translated">欧州連合における一般データプライバシー規制(GDPR)について</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEADメソッドはGETと同じであるが、サーバは応答中にメッセージボディを返してはならない[MUST NOT]。HEADリクエストに対する応答のHTTPヘッダーに含まれるメタ情報は、 GETリクエストに対する応答で送られた情報と同じであるべきである[SHOULD]。このメソッドは、エンティティボディ自体を転送することなく、リクエストが暗示する エンティティに関するメタ情報を取得するために使用できる。この方法は、ハイパーテキストリンクの有効性、アクセシビリティ、最近の変更のテストによく使われる。HEADリクエストに対する応答は、応答に含まれる情報をそのリソースから以前にキャッシュされた エンティティを更新するために使用してもよい[MAY]という意味で、キャッシュ可能であってもよい[MAY]。新しいフィールド値がキャッシュされたエンティティが現在のエンティティと異なることを示す場合(Content-Length、Content-MD5、ETag、Last-Modifiedの変更によって示されるような)、キャッシュはキャッシュエントリをstaleとして扱わなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEADメソッドは、サーバーが応答でメッセージ本文を送信してはならないこと（つまり、応答がヘッダーセクションの終わりで終了すること）を除いて、GETと同じです。サーバーは、リクエストがGETであった場合に送信されたのと同じヘッダーフィールドを、ペイロードヘッダーフィールド（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;）省略してもかまいません。このメソッドは、表現データを転送せずに選択した表現に関するメタデータを取得するために使用でき、有効性、アクセシビリティ、および最近の変更についてハイパーテキストリンクをテストするためによく使用されます。 HEADリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。 HEADリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する可能性があります。 HEAD要求への応答はキャッシュ可能です。キャッシュは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2）で&lt;/a&gt;特に示されていない限り、後続のHEAD要求を満たすためにそれを使用できます（MAY ）。 HEAD応答は、以前にキャッシュされたGETへの応答にも影響を与える可能性があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]のセクション4.3.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9b66172e68b0534fed4eb909af19fada53af1789" translate="yes" xml:space="preserve">
          <source>The HEADERS frame (type=0x1) is used to open a stream (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   and additionally carries a header block fragment.  HEADERS frames can
   be sent on a stream in the &quot;idle&quot;, &quot;reserved (local)&quot;, &quot;open&quot;, or
   &quot;half-closed (remote)&quot; state. 

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                      Figure 7: HEADERS Frame Payload

   The HEADERS frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only present if the
      PRIORITY flag is set.

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only
      present if the PRIORITY flag is set.

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.  This field is only present if the
      PRIORITY flag is set.

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Padding:  Padding octets.

   The HEADERS frame defines the following flags:

   END_STREAM (0x1):  When set, bit 0 indicates that the header block
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) is the last that the endpoint will send for the
      identified stream.

      A HEADERS frame carries the END_STREAM flag that signals the end
      of a stream.  However, a HEADERS frame with the END_STREAM flag
      set can be followed by CONTINUATION frames on the same stream.
      Logically, the CONTINUATION frames are part of the HEADERS frame. 

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A HEADERS frame without the END_HEADERS flag set MUST be followed
      by a CONTINUATION frame for the same stream.  A receiver MUST
      treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PRIORITY (0x20):  When set, bit 5 indicates that the Exclusive Flag
      (E), Stream Dependency, and Weight fields are present; see
      &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   The payload of a HEADERS frame contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  A header block that does not fit within a HEADERS
   frame is continued in a CONTINUATION frame (&lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt;).

   HEADERS frames MUST be associated with a stream.  If a HEADERS frame
   is received whose stream identifier field is 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The HEADERS frame changes the connection state as described in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   The HEADERS frame can include padding.  Padding fields and flags are
   identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  Padding
   that exceeds the size remaining for the header block fragment MUST be
   treated as a PROTOCOL_ERROR.

   Prioritization information in a HEADERS frame is logically equivalent
   to a separate PRIORITY frame, but inclusion in HEADERS avoids the
   potential for churn in stream prioritization when new streams are
   created.  Prioritization fields in HEADERS frames subsequent to the
   first on a stream reprioritize the stream (&lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;).</source>
          <target state="translated">HEADERSフレーム（type = 0x1）は、ストリームを開くために使用されます（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）、さらにヘッダーブロックフラグメントを伝送します。 HEADERSフレームは、「アイドル」、「予約済み（ローカル）」、「オープン」、または「ハーフクローズ（リモート）」状態のストリームで送信できます。 + --------------- + |パッドの長さ？ （8）| +-+ ------------- + --------------------------------- -------------- + | E |ストリームの依存関係？ （31）| +-+ ------------- + --------------------------------- -------------- + |重量？ （8）| +-+ ------------- + --------------------------------- -------------- + |ヘッダーブロックフラグメント（*）+ ------------------------------------------- -------------------- + |パディング（*）+ --------------------------------------------- ------------------ +図7：HEADERSフレームペイロードHEADERSフレームペイロードには、次のフィールドがあります。パッドの長さ：フレームのパディングの長さを含む8ビットのフィールドオクテットの単位。このフィールドは、PADDEDフラグが設定されている場合にのみ表示されます。 E：ストリームの依存関係が排他的であることを示すシングルビットフラグ（を参照）&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）。このフィールドは、PRIORITYフラグが設定されている場合にのみ存在します。ストリームの依存関係：このストリームが依存するストリームの31ビットのストリーム識別子（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3を&lt;/a&gt;参照）。このフィールドは、PRIORITYフラグが設定されている場合にのみ存在します。重み：ストリームの優先順位の重みを表す符号なし8ビット整数（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3を&lt;/a&gt;参照）。値に1を加算して、1〜256の重みを取得します。このフィールドは、PRIORITYフラグが設定されている場合にのみ表示されます。ヘッダーブロックフラグメント：ヘッダーブロックフラグメント（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。パディング：オクテットのパディング。 HEADERSフレームは、次のフラグを定義します。END_STREAM（0x1）：設定されている場合、ビット0はヘッダーブロックを示します（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）は、エンドポイントが識別されたストリームに対して送信する最後の値です。 HEADERSフレームには、ストリームの終了を通知するEND_STREAMフラグがあります。ただし、END_STREAMフラグが設定されたHEADERSフレームの後に、同じストリーム上のCONTINUATIONフレームを続けることができます。論理的には、CONTINUATIONフレームはHEADERSフレームの一部です。 END_HEADERS（0x4）：設定されている場合、ビット2は、このフレームにヘッダーブロック全体が含まれ（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）、その後にCONTINUATIONフレームが続かないことを示します。 END_HEADERSフラグが設定されていないHEADERSフレームの後には、同じストリームのCONTINUATIONフレームが続く必要があります。受信者は、他のタイプのフレームまたは別のストリーム上のフレームの受信を接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。 PADDED（0x8）：設定されている場合、ビット3は、PadLengthフィールドとそれが記述するすべてのパディングが存在することを示します。 PRIORITY（0x20）：設定されている場合、ビット5は、Exclusive Flag（E）、Stream Dependency、およびWeightフィールドが存在することを示します。&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3を&lt;/a&gt;参照してください。 HEADERSフレームのペイロードには、ヘッダーブロックフラグメントが含まれています（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。 HEADERSフレーム内に収まらないヘッダーブロックは、CONTINUATIONフレーム（&lt;a href=&quot;#section-6.10&quot;&gt;セクション6.10&lt;/a&gt;）で継続されます。 HEADERSフレームはストリームに関連付ける必要があります。ストリーム識別子フィールドが0x0であるHEADERSフレームを受信した場合、受信者はタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）で応答する必要があります。 HEADERSフレームは、説明されているように接続状態を変更します&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;。 HEADERSフレームにはパディングを含めることができます。パディングフィールドとフラグは、DATAフレーム（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）に定義されているものと同じです。ヘッダーブロックフラグメントの残りのサイズを超えるパディングは、PROTOCOL_ERRORとして処理する必要があります。 HEADERSフレームの優先順位付け情報は、論理的には別のPRIORITYフレームと同等ですが、HEADERSに含めることで、新しいストリームが作成されたときにストリームの優先順位付けがチャーンする可能性を回避できます。ストリームの最初のフレームに続くHEADERSフレームの優先順位付けフィールドは、ストリームの優先順位を付け直します（&lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; のHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7de3d21abd96bd4beb67ffb6ec818595df38d03d" translate="yes" xml:space="preserve">
          <source>The HTTP 1.1 (only) &lt;code&gt;Upgrade&lt;/code&gt; header can be used to upgrade an already established client/server connection to a different protocol (over the same transport protocol). For example, it can be used by a client to upgrade a connection from HTTP 1.1 to HTTP 2.0, or an HTTP or HTTPS connection into a WebSocket.</source>
          <target state="translated">HTTP 1.1（のみ） &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーを使用して、すでに確立されているクライアント/サーバー接続を別のプロトコルにアップグレードできます（同じトランスポートプロトコルを介して）。たとえば、クライアントが接続をHTTP1.1からHTTP2.0にアップグレードしたり、HTTPまたはHTTPS接続をWebSocketにアップグレードしたりするために使用できます。</target>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページがHTTPSを使用している場合に、HTTPを介したアセットの読み込みを防ぎます。</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、HTTPSを使用してページが読み込まれるときに、HTTPを使用してアセットが読み込まれないようにします。</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、他のCSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下の各ディレクティブについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;を使用してロードされたフォントの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ディレクティブは、特定のコンテキストからのフォーム送信のターゲットとして使用できるURLを制限します。</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用してページを埋め込むことができる有効な親を指定します。</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれるネストされたブラウジングコンテキストの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="a5cc0adb408b4a8f77493eae319c581cf4526353" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-to&lt;/code&gt; directive restricts the URLs to which a document can initiate navigations by any means including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc. This is an enforcement on what navigations this document initiates &lt;strong&gt;not&lt;/strong&gt; on what this document is allowed to navigate to.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-to&lt;/code&gt; ディレクティブは、ドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;form-action&quot;&gt; &lt;code&gt;form-action&lt;/code&gt; &lt;/a&gt;が指定されていない場合）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open&lt;/code&gt; &lt;/a&gt;などの手段でナビゲーションを開始できるURLを制限します。.openなど。これは、このドキュメントがナビゲートすることを許可されているものでは&lt;strong&gt;なく&lt;/strong&gt;、このドキュメントが開始するナビゲーションに対する強制です。</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ロードできるリソースのタイプを制限することにより、ドキュメントに埋め込むことができるプラグインのセットを制限します。</target>
        </trans-unit>
        <trans-unit id="f6e050006d74c56b081d711041cc2a29932e1bfd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid resources that may be prefetched or prerendered.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、プリフェッチまたはプリレンダリングされる可能性のある有効なリソースを指定します。</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTPの&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; ディレクティブの情報を指定するために使用さ&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;（シングルとヘッダ &lt;code&gt;r&lt;/code&gt; のページからのリンクについては、これはオリジナルの仕様でタイプミスだったように）。このAPIは廃止され、ブラウザから削除されました。</target>
        </trans-unit>
        <trans-unit id="871ccac3ab2ff9b3690d358a4ea40b08884840e9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to control the data passed to DOM XSS sink functions, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt;セッターなどのDOMXSSシンク関数に渡されるデータを制御するようにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性と同様に、要求されたリソースのサンドボックスを有効にします。ポップアップの防止、プラグインとスクリプトの実行の防止、同じ生成元のポリシーの適用など、ページのアクションに制限を適用します。</target>
        </trans-unit>
        <trans-unit id="a54e3f9dc9e10d181fcc5b9d14de91d2158ed49a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript inline event handlers. This includes only inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;, but not URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; ディレクティブは、JavaScriptインラインイベントハンドラーの有効なソースを指定します。これには、 &lt;code&gt;onclick&lt;/code&gt; などのインラインスクリプトイベントハンドラーのみが含まれ、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に直接読み込まれるURLは含まれません。</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、JavaScriptの有効なソースを指定します。これには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に直接読み込まれたURLだけでなく、インラインスクリプトイベントハンドラー（ &lt;code&gt;onclick&lt;/code&gt; ）やスクリプトの実行をトリガーできる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLTスタイルシート&lt;/a&gt;なども含まれます。</target>
        </trans-unit>
        <trans-unit id="ae949c0f5a7694445f0b27c386a8832b1c5e94b2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-attr&lt;/code&gt; directive specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-attr&lt;/code&gt; ディレクティブは、個々のDOM要素に適用されるインラインスタイルの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="4e52836f01982774b986b243c0c4f29e000b612f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-elem&lt;/code&gt; directive specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-elem&lt;/code&gt; ディレクティブは、スタイルシートの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; で指定します。</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="7b3e13bcd5d8d9f7bcf64acc3459db7ca20c7578" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to restrict the creation of Trusted Types policies - functions that build non-spoofable, typed values intended to be passed to DOM XSS sinks in place of strings.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ユーザーエージェントにTrustedTypesポリシーの作成を制限するように指示します。これは文字列の代わりにDOMXSSシンクに渡されることを目的としたスプーフィング不可能な型付き値を構築する関数です。</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; ディレクティブは、サイトのすべての安全でないURL（HTTP経由で提供される）が安全なURL（HTTPS経由で提供される）に置き換えられたかのように扱うようにユーザーエージェントに指示します。このディレクティブは、書き換えが必要な安全でないレガシーURLが多数あるWebサイトを対象としています。</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;スクリプトの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求は、ユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;default-src&lt;/code&gt; ディレクティブは、他のCSP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下のディレクティブのそれぞれについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="9204eef966021c11aedbb0e9fb96b1228c1de8f2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;script-src-elem&lt;/code&gt; directive specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but not inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;script-src-elem&lt;/code&gt; ディレクティブは、JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定しますが、 &lt;code&gt;onclick&lt;/code&gt; のようなインラインスクリプトイベントハンドラーは指定しません。</target>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;style-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページ上のスクリプトまたはスタイルに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;サブリソース整合性&lt;/a&gt;の使用を要求するようにクライアントに指示します。</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ディレクティブは、ドキュメントの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素で使用できるURLを制限します。この値がない場合、任意のURIが許可されます。このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の値を使用します。</target>
        </trans-unit>
        <trans-unit id="e0361bbd3e19dd4db920260e46f1803df2efaa1a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;accelerometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the acceleration of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt;&lt;code&gt;Accelerometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;accelerometer&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt; &lt;code&gt;Accelerometer&lt;/code&gt; &lt;/a&gt;インターフェースを介してデバイスの加速度に関する情報を収集できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="92c66228b38d0470e96db98a40225a18c2d3231a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;ambient-light-sensor&lt;/code&gt; directive controls whether the current document is allowed to gather information about the amount of light in the environment around the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt;&lt;code&gt;AmbientLightSensor&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;ambient-light-sensor&lt;/code&gt; ディレクティブは、現在のドキュメントが、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt; &lt;code&gt;AmbientLightSensor&lt;/code&gt; &lt;/a&gt;インターフェイスを介してデバイス周辺の環境の光の量に関する情報を収集できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアの自動再生を許可されるかどうかを制御します。このポリシーが有効で、ユーザージェスチャがない場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素の &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアを自動再生できるかどうかを制御します。このポリシーが有効で、ユーザージェスチャーがなかった場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の &lt;code&gt;autoplay&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="9bd2e515d62f7d6ede21b6f102d6e75bcfdc2806" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;battery&lt;/code&gt; directive controls whether the current document is allowed to gather information about the battery of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; interface obtained via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt;&lt;code&gt;Navigator.getBattery()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;battery&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt; &lt;code&gt;Navigator.getBattery()&lt;/code&gt; を&lt;/a&gt;介して取得した&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt;インターフェイスを介してデバイスのバッテリーに関する情報を収集できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;で返さ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;を拒否します&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt; &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="a38d3aba5839b81049ae1c111db31f4dd2359f9e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;display-capture&lt;/code&gt; directive controls whether or not the document is permitted to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;, i.e.,&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt;&lt;code&gt;getDisplayMedia()&lt;/code&gt;&lt;/a&gt; to capture the screen's contents.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;display-capture&lt;/code&gt; ディレクティブは、ドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;、つまり&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt; &lt;code&gt;getDisplayMedia()&lt;/code&gt; &lt;/a&gt;を使用して画面のコンテンツをキャプチャすることを許可するかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;document-domain&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;を設定できるかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;を設定しようとすると失敗し、 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）の使用を許可するかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;fullscreen&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;geolocation&lt;/code&gt; 、現在の文書が使用を許可されているかどうかを指示コントロール&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;インタフェース。このポリシーが有効な場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt;を呼び出すと、これらの関数のコールバックが &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;コードで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d1aa24dbbd3715af81f21828a56fabf5ec110953" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;gyroscope&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt;&lt;code&gt;Gyroscope&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;gyroscope&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt; &lt;code&gt;Gyroscope&lt;/code&gt; &lt;/a&gt;インターフェイスを介してデバイスの向きに関する情報を収集できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="85ff5966dce2b9c7b7600a4d4c06b6e4b170f277" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;layout-animations&lt;/code&gt; directive controls whether the current document is allowed to show layout animations.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;layout-animations&lt;/code&gt; ディレクティブは、現在のドキュメントにレイアウトアニメーションの表示を許可するかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="79581f7e39deb619df4e34954f818f674b43f16f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;legacy-image-formats&lt;/code&gt; directive controls whether the current document is allowed to display images in legacy formats.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;legacy-image-formats&lt;/code&gt; ディレクティブは、現在のドキュメントがレガシー形式で画像を表示できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="dcb5ebff50a1c299f3cfff78c80e0f15d5569925" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;magnetometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt;&lt;code&gt;Magnetometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;magnetometer&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt; &lt;code&gt;Magnetometer&lt;/code&gt; &lt;/a&gt;インターフェイスを介してデバイスの向きに関する情報を収集できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;microphone&lt;/code&gt; ディレクティブは、現在のドキュメントがオーディオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;midi&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="7143f5b43341ab71af365409875146a8699bd3ea" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;oversized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display large images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;oversized-images&lt;/code&gt; ディレクティブは、現在のドキュメントが大きな画像のダウンロードと表示を許可されるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターが &lt;code&gt;SecurityError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="1bf49ec28a205e1ed0b001dfbdb9aa642280ff0c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;picture-in-picture&lt;/code&gt; directive controls whether the current document is allowed to play a video in a Picture-in-Picture mode via the corresponding API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;picture-in-picture&lt;/code&gt; ディレクティブは、現在のドキュメントが対応するAPIを介してPicture-in-Pictureモードでビデオを再生できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="2ebcad6e4fbff3f317a76c00d82e77cbe034d342" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;publickey-credentials-get&lt;/code&gt; directive controls whether the current document is allowed to access &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web Authentcation API&lt;/a&gt; to create new public-key credentials, i.e, via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt;&lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;publickey-credentials-get&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web Authentcation API&lt;/a&gt;にアクセスして、新しい公開鍵資格情報を作成できるかどうかを制御します。つまり、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt; &lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f5bf4e9f3fed1765343fd59a9718f4cd6d7d27d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;screen-wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt; to indicate that device should not dim or turn off the screen.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;screen-wake-lock&lt;/code&gt; ディレクティブは、現在のドキュメントで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt;を使用して、デバイスを暗くしたり画面をオフにしたりしないことを許可するかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="d480f24830d984d0930580ca8ddada9de45700d1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;sync-xhr&lt;/code&gt; directive controls whether the current document is allowed to make synchronous &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; requests.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;sync-xhr&lt;/code&gt; ディレクティブは、現在のドキュメントが同期&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;リクエストを実行できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="2a58ad5a409b3b1c3a41e1e839795597dc6204dc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unoptimized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display unoptimized images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;unoptimized-images&lt;/code&gt; ディレクティブは、現在のドキュメントが最適化されていない画像のダウンロードと表示を許可されるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="d80682ef1147e80bdbff00f43c45c04f77992134" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unsized-media&lt;/code&gt; directive controls whether the current document is allowed to change the size of media elements after the initial layout is complete.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;unsized-media&lt;/code&gt; ディレクティブは、初期レイアウトの完了後に現在のドキュメントでメディア要素のサイズを変更できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="3ad639cf0153cfd80980b0affb3cc2e1e990de76" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vibrate&lt;/code&gt;  directive controls whether the current document is allowed to trigger device vibrations via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt;&lt;code&gt;Navigator.vibrate()&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;vibrate&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration APIの&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt; &lt;code&gt;Navigator.vibrate()&lt;/code&gt; &lt;/a&gt;メソッドを介して現在のドキュメントがデバイスのバイブレーションをトリガーできるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVRAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="15c0f9c5a8e9e08ad03923f24381554ed8b9ab1c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use Wake Lock API to indicate that device should not enter power-saving mode.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;wake-lock&lt;/code&gt; ディレクティブは、現在のドキュメントでWake Lock APIを使用して、デバイスが省電力モードに入らないようにするかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="269d13c10993281fbc573c770f836b44bc5f308a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;web-share&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;&lt;code&gt;Navigator.share()&lt;/code&gt;&lt;/a&gt; method of the Web Share API to share text, links, images, and other content to arbitrary destinations of the user's choice.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;web-share&lt;/code&gt; ディレクティブは、現在のドキュメントがWeb Share APIの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt; &lt;code&gt;Navigator.share()&lt;/code&gt; &lt;/a&gt;メソッドを使用して、テキスト、リンク、画像、およびその他のコンテンツをユーザーが選択した任意の宛先に共有できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="62dced3e4a986bc5373d1a7961ad28c776d2c977" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;xr-spatial-tracking&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt;. This policy controls whether &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt;&lt;code&gt;navigator.xr.requestSession()&lt;/code&gt;&lt;/a&gt; can return &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt;&lt;code&gt;XRSession&lt;/code&gt;&lt;/a&gt; that requires spatial tracking and whether user agent can indicate support for sessions supporting spatial tracking via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt;&lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; event on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt;&lt;code&gt;navigator.xr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;xr-spatial-tracking&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR DeviceAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt; &lt;code&gt;navigator.xr.requestSession()&lt;/code&gt; &lt;/a&gt;が空間追跡を必要とする&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt; &lt;code&gt;XRSession&lt;/code&gt; &lt;/a&gt;を返すことができるかどうか、およびユーザーエージェントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt; &lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt; &lt;code&gt;navigator.xr&lt;/code&gt; &lt;/a&gt;オブジェクトの &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; イベントを介して空間追跡をサポートするセッションのサポートを示すことができるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーフィールドの &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;支払い要求APIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーが無効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターはSyntaxErrorをスローし&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="085032760c08ad9b9fdf7e3304ad0c84d9aeabf7" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header usb directive controls whether the current document is allowed to use the WebUSB API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーのusbディレクティブは、現在のドキュメントがWebUSBAPIの使用を許可されるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、HTTPSを使用してページが読み込まれるときに、HTTPを使用してアセットが読み込まれないようにします。</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、他のCSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下の各ディレクティブについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;を使用してロードされたフォントの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ディレクティブは、特定のコンテキストからのフォーム送信のターゲットとして使用できるURLを制限します。</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用してページを埋め込むことができる有効な親を指定します。</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれるネストされたブラウジングコンテキストの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ロードできるリソースのタイプを制限することにより、ドキュメントに埋め込むことができるプラグインのセットを制限します。</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTPの&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; ディレクティブの情報を指定するために使用さ&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;（シングルとヘッダ &lt;code&gt;r&lt;/code&gt; のページからのリンクについては、これはオリジナルの仕様でタイプミスだったように）。このAPIは廃止され、ブラウザから削除されました。</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性と同様に、要求されたリソースのサンドボックスを有効にします。ポップアップの防止、プラグインとスクリプトの実行の防止、同じ生成元のポリシーの適用など、ページのアクションに制限を適用します。</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、JavaScriptの有効なソースを指定します。これには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に直接読み込まれたURLだけでなく、インラインスクリプトイベントハンドラー（ &lt;code&gt;onclick&lt;/code&gt; ）やスクリプトの実行をトリガーできる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLTスタイルシート&lt;/a&gt;なども含まれます。</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートのソースの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; ディレクティブは、サイトのすべての安全でないURL（HTTP経由で提供される）が安全なURL（HTTPS経由で提供される）に置き換えられたかのように扱うようにユーザーエージェントに指示します。このディレクティブは、書き換えが必要な安全でないレガシーURLが多数あるWebサイトを対象としています。</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;スクリプトの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページ上のスクリプトまたはスタイルに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;サブリソース整合性&lt;/a&gt;の使用を要求するようにクライアントに指示します。</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ディレクティブは、ドキュメントの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素で使用できるURLを制限します。この値がない場合、任意のURIが許可されます。このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の値を使用します。</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアの自動再生を許可されるかどうかを制御します。このポリシーが有効で、ユーザージェスチャがない場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素の &lt;code&gt;autoplay&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;で返さ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;を拒否します &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;document-domain&lt;/code&gt; ディレクティブは、現在のドキュメントでdocument.domainの設定を許可するかどうかを制御し&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;。このポリシーが有効になっている場合は、設定しようとし&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; をすることは&lt;/a&gt;できないと発生します &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;スローされます。</target>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）の使用を許可するかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;fullscreen&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;geolocation&lt;/code&gt; 、現在の文書が使用を許可されているかどうかを指示コントロール&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;インタフェース。このポリシーが有効な場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt;を呼び出すと、これらの関数のコールバックが &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;コードで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;microphone&lt;/code&gt; ディレクティブは、現在のドキュメントがオーディオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;midi&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDIAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment RequestAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターは &lt;code&gt;SecurityError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVRAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;メソッドは、ドキュメントの完全な置換のみを許可します。 &lt;code&gt;PUT&lt;/code&gt; とは異なり、 &lt;code&gt;PATCH&lt;/code&gt; はべき等ではありません。つまり、連続する同一のパッチリクエストは異なる効果を持つ&lt;em&gt;可能性&lt;/em&gt;があります。ただし、べき等になるように &lt;code&gt;PATCH&lt;/code&gt; リクエストを発行することは可能です。</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 情報ステータス応答コードは、これまでのところすべてが問題なく、クライアントが要求を続行するか、すでに完了している場合は無視する必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="7fbaadcda1376e28783b5f635687be50467a1933" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; information response status code is primarily intended to be used with the &lt;a href=&quot;../headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header to allow the user agent to start preloading resources while the server is still preparing a response.</source>
          <target state="translated">HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; 情報応答ステータスコードは、主に&lt;a href=&quot;../headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt;ヘッダーとともに使用して、サーバーが応答を準備している間にユーザーエージェントがリソースのプリロードを開始できるようにすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 成功ステータス応答コードは、リクエストが成功したことを示します。200応答はデフォルトでキャッシュ可能です。</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 成功ステータスレスポンスコードは、リクエストが成功し、リソースが作成されたことを示します。新しいリソースは、この応答が返送される前に効果的に作成され、メッセージの本文で新しいリソースが返されます。その場所は、リクエストのURLまたは&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーのコンテンツです。</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 応答ステータスは、要求は成功したが、囲まれたペイロードが、オリジンサーバーの&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;から変換プロキシによって変更されたことを示します。</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 応答ステータスは、リクエストは成功したが、囲まれたペイロードが、変換&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;によって元のサーバーの&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答のペイロードから変更されたことを示します。</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 成功ステータス応答コードは、リクエストは成功したが、クライアントが現在のページから離れる必要がないことを示します。デフォルトでは、204応答はキャッシュ可能です。AN &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ヘッダは、Aの応答に含まれています。</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 応答ステータスは、クライアントにドキュメントビューをリセットするように指示します。たとえば、フォームのコンテンツをクリアしたり、キャンバスの状態をリセットしたり、UIを更新したりします。</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 成功ステータス応答コードは、リクエストが成功し、リクエストの&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーで説明されているように、リクエストされたデータの範囲が本文に含まれていることを示します。</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; クライアントエラーステータス応答コードは、ターゲットリソースの有効な認証資格情報がないため、要求が適用されなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="29e296a48560f66dbcc3ec52c233f4fdb267b76e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; is a nonstandard client error status response code that is reserved for future use.</source>
          <target state="translated">HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; は、将来の使用のために予約されている非標準のクライアントエラーステータス応答コードです。</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; クライアントエラーステータス応答コードは、サーバーが要求を理解したが、承認を拒否したことを示しています。</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; クライアントエラーステータス応答コードは、要求されたリソースにアクセスできるブラウザーとサーバーの間にある&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;プロキシサーバーの&lt;/a&gt;有効な認証資格情報がないため、要求が適用されなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; クライアントエラー応答コードは、リクエストの&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt;ヘッダーで指定された期待に応えられなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error応答コードは、サーバーがティーポットであるため、サーバーがコーヒーの淹れ方を拒否することを示しています。このエラーは、1998年にエイプリルフールのジョークであったハイパーテキストコーヒーポットコントロールプロトコルの参照です。</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; clientエラー応答コードは、サーバーが永続的にティーポットであるため、コーヒーの淹れ方を拒否したことを示しています。一時的にコーヒーがなくなったコーヒーとティーポットを組み合わせると、代わりに503が返されます。このエラーは、1998年と2014年のエイプリルフールのジョークで定義されたハイパーテキストコーヒーポットコントロールプロトコルへの参照です。</target>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 応答コードは、&lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;要求ヘッダーを含むメッセージを送信したクライアントからの要求に応じて、サーバーが切り替えているプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 応答コードは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;リクエストヘッダーを含むメッセージを送信したクライアントからの要求に応じて、サーバーが切り替えるプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、リクエストに複数の可能な応答があることを示しています。ユーザーエージェントまたはユーザーは、それらのいずれかを選択する必要があります。応答の1つを選択する標準化された方法がないため、この応答コードはほとんど使用されません。</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; クライアントリダイレクト応答コードは、要求されたリソースを再送信する必要がないことを示しています。これは、キャッシュされたリソースへの暗黙的なリダイレクトです。これは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;リクエストのようにリクエストメソッドが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全&lt;/a&gt;である場合、またはリクエストが条件付きで&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;ヘッダーを使用している場合に発生します。</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求されたリソースを見つけることができないことを示しています。404ページにつながるリンクは、多くの場合、壊れたのか死んでリンクと呼ばれ、対象とすることができ&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;リンク切れ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求されたリソースを見つけられないことを示します。404ページにつながるリンクは、多くの場合、リンク切れまたはデッドリンクと呼ばれ、&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;リンクの腐敗の&lt;/a&gt;影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、リクエストがサーバーの現在の状態と競合していることを示します。</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求がターゲットリソースの現在の状態と競合していることを示します。</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求エンティティがサーバーによって定義された制限よりも大きいことを示します。サーバーが接続を閉じるか、&lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt;ヘッダーフィールドを返す場合があります。</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントがリクエストしたURIが、サーバーが解釈するよりも長いことを示しています。</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">ペイロード形式がサポートされていない形式であるため、HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求の受け入れを拒否したことを示します。</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; クライアントエラーレスポンスコードは、サーバーが現在のプロトコルを使用してリクエストを実行することを拒否しているが、クライアントが別のプロトコルにアップグレードした後に実行する可能性があることを示します。</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、サーバーがリクエストを&lt;a href=&quot;../conditional_requests&quot;&gt;条件付きに&lt;/a&gt;する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、ユーザーが指定された時間内に送信したリクエストが多すぎることを示します（「レート制限」）。</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; が大きすぎますレスポンスステータスコードは、ヘッダーフィールドが大きすぎるため、サーバーがリクエストを処理したくないことを示します。リクエストヘッダーフィールドのサイズを小さくした後、リクエストを再送信できます。</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; が大きすぎる応答ステータスコードは、要求の&lt;a href=&quot;../headers&quot;&gt;HTTPヘッダー&lt;/a&gt;が長すぎるため、サーバーが要求の処理を拒否したことを示します。要求が&lt;em&gt;よい&lt;/em&gt;リクエストヘッダのサイズを小さくした後に再送信されます。</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントがネットワークアクセスを得るために認証する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーは、ピン留め違反の &lt;code&gt;report-uri&lt;/code&gt; ヘッダーで指定されたreport-uriに送信しますが、&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;とは異なり、ピン留めに違反した場合でもブラウザーはサーバーに接続できます。</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーを使用して、ピンニング違反の &lt;code&gt;report-uri&lt;/code&gt; ヘッダーで指定されたreport-uriに送信しましたが、&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;とは異なり、ピンニングが違反しました。HPKPのサポートが削除されたため、最近のブラウザーではヘッダーは黙って無視されます。代わりに、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;と&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してください。</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーは、特定の暗号化公開&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;鍵&lt;/a&gt;を特定のWebサーバーに関連付け、偽造された証明書による&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻撃のリスクを軽減します。1つまたは複数のキーが固定されていて、それらのいずれもサーバーで使用されていない場合、ブラウザは正当なものとして応答を受け入れず、表示しません。</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">特定の暗号化公開&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;鍵&lt;/a&gt;を特定のWebサーバーに関連付けて、偽造された証明書による&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻撃のリスクを軽減するために使用される、HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 応答ヘッダー。ただし、最新のブラウザーから削除され、サポートされなくなりました。代わりに、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;と&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してください。</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; リクエストヘッダーには、サーバーでユーザーエージェントを認証するための認証情報が含まれています。通常、サーバーが&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ステータスと&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後です。</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 要求ヘッダーには、サーバーが&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ステータスと&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後、通常はサーバーでユーザーエージェントを認証するための資格情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 応答ヘッダーを使用すると、Web開発者はポリシーの効果を監視する（ただし強制しない）ことでポリシーを試すことができます。これらの違反レポートは、HTTP &lt;code&gt;POST&lt;/code&gt; リクエストを介して指定されたURIに送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;ドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 応答ヘッダーを使用すると、Webサイト管理者は、ユーザーエージェントが特定のページに対してロードできるリソースを制御できます。いくつかの例外はありますが、ポリシーには主にサーバーの起点とスクリプトのエンドポイントの指定が含まれます。これは、クロスサイトスクリプティング攻撃（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）を防ぐのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="e9a358c2e37bd97387c345bc97d49f2b9964bebc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; (COEP) response header prevents a document from loading any cross-origin resources that don't explicitly grant the document permission (using &lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt; or &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; （COEP）応答ヘッダーは、（&lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt;または&lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;を使用して）ドキュメントのアクセス許可を明示的に付与しないクロスオリジンリソースをドキュメントがロードするのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="bd12a715eb3e020beaec19eacef98180f3c03eb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; (COOP) response header allows you to ensure a top-level document does not share a browsing context group with cross-origin documents.</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; （COOP）応答ヘッダーを使用すると、トップレベルのドキュメントがクロスオリジンドキュメントとブラウジングコンテキストグループを共有しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="532f81dfa15429527706f99b56516bbbb7103920" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource.</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; 応答ヘッダーは、ブラウザーが特定のリソースへのクロスオリジン/クロスサイトリクエストをブロックするという要望を伝えます。</target>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーは、独自のフレーム、およびドキュメント内の任意の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;要素内のコンテンツでのブラウザー機能の使用を許可および拒否するメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーは、独自のフレーム、およびそれが埋め込むiframeでのブラウザー機能の使用を許可および拒否するメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="ffce3b68f1b8be8fa0ab126f01ab7dcd1167232b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Link&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;code&gt;Link&lt;/code&gt; entity-headerフィールドは、HTTPヘッダー内の1つ以上のリンクをシリアル化するための手段を提供します。これは、意味的にはHTMLの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と同等です。</target>
        </trans-unit>
        <trans-unit id="15bba15c0e7df46ed2a8a40b2e760da5664fad96" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;NEL&lt;/code&gt; response header is used to configure network request logging.</source>
          <target state="translated">HTTP &lt;code&gt;NEL&lt;/code&gt; 応答ヘッダーは、ネットワーク要求ログを構成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 応答ヘッダーは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;プロキシサーバーの&lt;/a&gt;背後にあるリソースにアクセスするために使用する認証方法を定義します。プロキシサーバーに対して要求を認証し、要求をさらに送信できるようにします。</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; リクエストヘッダーには、プロキシサーバーに対してユーザーエージェントを認証するための認証情報が含まれています。通常、サーバーが&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; ステータスと&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後です。</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 要求ヘッダーは、暗号化および認証された応答に対するクライアントの設定を表す信号をサーバーに送信し、&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt;ディレクティブを正常に処理できることを示します。</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 応答ヘッダーは、リソースへのアクセスを取得するために使用される認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 応答ヘッダーは、Internet Explorer、Chrome、およびSafariの機能であり、反射されたクロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻撃を検出すると、ページの読み込みを停止します。インラインJavaScript（ &lt;code&gt;'unsafe-inline'&lt;/code&gt; ）の使用を無効にする強力な&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;をサイトが実装している場合、これらの保護は現代のブラウザーではほとんど不要ですが、まだまだ使用していない古いWebブラウザーのユーザーに保護を提供できます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSPを&lt;/a&gt;サポートします。</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP Strict Transport Security ヘッダは、HTTP を使用してサイトを決してロードしてはならず、HTTP を使用してサイトにアクセスしようとするすべての試みを、代わりに HTTPS リクエストに自動的に変換すべきであることをブラウザに通知します。</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URLネームスペースは、「/」文字で区切られた階層ネームスペースです。 HTTP URL名前空間は、次の条件を満たす場合に整合性があると見なされます。HTTP階層内のすべてのURLに対して、そのURLを内部メンバーURLとして含むコレクションが存在します。ルート、つまり検討中のネームスペースのトップレベルコレクションは、前のルールから除外されます。検討中のネームスペースの最上位のコレクションは、絶対パス「/」で識別されるコレクションであるとは限りません。1つ以上のパスセグメントで識別される場合があります（例：/ servlets / webdav / ...）どちらのHTTP / 1.1でもWebDAVでは、HTTP URLネームスペース全体が一貫している必要はありません。WebDAV互換リソースには親コレクションがない場合があります。しかしながら、特定のWebDAVメソッドは、名前空間の不整合を引き起こす結果を生成することが禁止されています。 [で暗黙的であるように&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]と[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]、コレクションリソースを含むすべてのリソースは、複数のURIで識別される場合があります。たとえば、リソースは複数のHTTP URLで識別できます。</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP認証フレームワークは、資格情報の機密性を維持するための単一のメカニズムを定義していません。代わりに、各認証スキームは、送信前に資格情報をエンコードする方法を定義します。これは、将来の認証スキームの開発に柔軟性を提供しますが、それ自体では機密性を提供しない、またはリプレイ攻撃から十分に保護しない既存のスキームの保護には不十分です。さらに、サーバーが個々のユーザーに固有の資格情報を期待している場合、それらの資格情報を交換すると、資格情報内のコンテンツが機密のままであっても、そのユーザーを識別する効果があります。HTTPは、ヘッダーフィールドの機密送信を提供するために、基になるトランスポートレベルまたはセッションレベルの接続のセキュリティプロパティに依存しています。つまり、サーバーがこのフレームワークを使用して認証されたユーザーへのアクセスを制限する場合、サーバーは、使用される認証スキームの性質に従って、接続が適切に保護されていることを確認する必要があります。たとえば、個々のユーザー認証に依存するサービスでは、TLS（「トランスポート層セキュリティ」、[個々のユーザー認証に依存するサービスでは、TLS（ &quot;Transport Layer Security&quot;、[個々のユーザー認証に依存するサービスでは、TLS（ &quot;Transport Layer Security&quot;、[&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）資格情報を交換する前。</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP条件付きリクエストヘッダーフィールド[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]を使用すると、クライアントはターゲットリソースの状態に事前条件を設定できるため、事前条件がfalseと評価された場合、メソッドのセマンティクスに対応するアクションは適用されません。この仕様で定義されている各前提条件は、ターゲットリソースの以前の表現から取得した一連のバリデータと、選択した表現のバリデータの現在の状態との比較で構成されています（&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）。したがって、これらの前提条件は、クライアントが既知の特定の状態以降にターゲットリソースの状態が変化したかどうかを評価します。このような評価の効果は、メソッドのセマンティクスと条件付きの選択に依存します。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232]のセクション5&lt;/a&gt;。 + --------------------- + -------------------------- + |ヘッダーフィールド名|で定義されています... | + --------------------- + -------------------------- + |イフマッチ| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232]のセクション3.1&lt;/a&gt; | | If-None-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]のセクション3.2&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]のセクション3.3&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232]のセクション3.4&lt;/a&gt; | | If-Range | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]のセクション3.2&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求で使用されているHTTPメソッドは、応答の&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたメソッドのリストに含まれていません。このヘッダーは、リクエストで指定されたURLにCORSを使用してアクセスするときに使用できるHTTPメソッドのコンマ区切りリストを指定します。要求が他の方法を使用している場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTPプロトコルは、要求/応答プロトコルです。クライアントは、リクエストメソッド、URI、プロトコルバージョンの形式でリクエストをサーバーに送信し、続いて、サーバーとの接続を介して、リクエスト修飾子、クライアント情報、および可能なボディコンテンツを含むMIMEのようなメッセージを送信します。サーバーは、メッセージのプロトコルバージョンと成功またはエラーコードを含むステータス行で応答し、その後にサーバー情報、エンティティメタ情報、および可能性のあるエンティティ本体コンテンツを含むMIMEのようなメッセージが続きます。 HTTPとMIMEの関係については、付録19.4で説明しています。ほとんどのHTTP通信はユーザーエージェントによって開始され、いくつかのオリジンサーバー上のリソースに適用される要求で構成されます。最も単純なケースでは、これは、ユーザーエージェント（UA）とオリジンサーバー（O）の間の単一の接続（v）を介して実現できます。リクエストチェーン------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;-----------------------応答チェーンより複雑な状況が発生すると1つ以上の仲介者が要求/応答チェーンに存在します。仲介には、プロキシ、ゲートウェイ、トンネルの3つの一般的な形式があります。プロキシは転送エージェントであり、絶対形式でURIの要求を受け取り、メッセージのすべてまたは一部を書き換え、URIで識別されるサーバーに向けて再フォーマットされた要求を転送します。ゲートウェイは受信エージェントであり、他のサーバーの上位層として機能し、必要に応じて、要求を基盤となるサーバーのプロトコルに変換します。トンネルは、メッセージを変更せずに2つの接続間の中継点として機能します。トンネルは、仲介者がメッセージの内容を理解できない場合でも、通信が仲介者（ファイアウォールなど）を通過する必要がある場合に使用されます。リクエストチェーン--------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ----------------------------レスポンスチェーン上の図は、ユーザーエージェントとオリジン間の3つの仲介者（A、B、C）を示していますサーバ。チェーン全体を移動する要求または応答メッセージは、4つの個別の接続を通過します。一部のHTTP通信オプションは最も近い非トンネルネイバーとの接続にのみ適用される場合があるため、この区別は重要です。チェーンのエンドポイントのみ、またはチェーンに沿ったすべての接続に。図は直線的ですが、各参加者は複数の同時通信に従事する場合があります。たとえば、Bは、A以外の多くのクライアントからの要求を受信して​​いる場合や、C以外のサーバーに要求を転送しているときに、Aの要求を処理している場合があります。トンネルとして機能していない通信の当事者は、要求を処理するために内部キャッシュを使用できます。キャッシュの効果は、チェーン上の参加者の1人がその要求に適用可能なキャッシュされた応答を持っている場合、要求/応答チェーンが短縮されることです。以下は、UAまたはAによってキャッシュされていないリクエストに対して、BがOからの（Cを介した）以前の応答のキャッシュされたコピーを持っている場合の結果のチェーンを示しています。リクエストチェーン----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;---------応答チェーンすべての応答が有効にキャッシュできるわけではなく、一部の要求には、キャッシュの動作に特別な要件を課す修飾子が含まれる場合があります。キャッシュ動作とキャッシュ可能な応答のHTTP要件は、&lt;a href=&quot;#section-13&quot;&gt;セクション13&lt;/a&gt;。実際、キャッシュとプロキシのさまざまなアーキテクチャと構成があり、現在World Wide Webで実験または配備されています。これらのシステムには、大洋横断の帯域幅を節約するプロキシキャッシュの全国階層、キャッシュエントリをブロードキャストまたはマルチキャストするシステム、CD-ROMを介してキャッシュデータのサブセットを配布する組織などが含まれます。 HTTPシステムは、高帯域幅リンク上の企業イントラネットで使用され、低電力の無線リンクと断続的な接続を備えたPDA経由のアクセスに使用されます。 HTTP / 1.1の目標は、高い信頼性を必要とするWebアプリケーションを構築する人のニーズを満たすプロトコルコンストラクトを導入しながら、すでに導入された幅広い構成をサポートし、少なくとも信頼性の高い失敗の兆候に失敗することです。HTTP通信は通常、TCP / IP接続を介して行われます。デフォルトのポートはTCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]ですが、他のポートを使用できます。これは、HTTPがインターネットまたは他のネットワーク上の他のプロトコルの上に実装されることを排除するものではありません。 HTTPは信頼できるトランスポートのみを前提としています。そのような保証を提供する任意のプロトコルを使用できます。問題のプロトコルのトランスポートデータユニットへのHTTP / 1.1要求および応答構造のマッピングは、この仕様の範囲外です。 HTTP / 1.0では、ほとんどの実装で、要求/応答交換ごとに新しい接続が使用されていました。 HTTP / 1.1では、接続は1つ以上の要求/応答交換に使用できますが、接続はさまざまな理由で閉じられる場合があります（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTPプロトコルは、&lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt;と呼ばれる要求メソッドを指定します。要求されたリソースとの双方向通信を開始し、トンネルを開くために使用できます。これは、HTTPプロキシの背後にあるクライアントがSSL（つまり、HTTPS、ポート443）を使用してWebサイトにアクセスする方法です。ただし、すべてのプロキシサーバーが &lt;code&gt;CONNECT&lt;/code&gt; メソッドをサポートしたり、ポート443のみに制限したりするわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">初期の段階で使用されていた HTTP プロトコルは非常にシンプルで、後に HTTP/0.9 と呼ばれるようになり、時には 1 行プロトコルとして使用されることもありました。</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">グローバル オブジェクトがインスタンス化されたリソースの HTTP ステータス コード。</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">リクエストで使用されているHTTPバージョンは、サーバーがサポートしていません。</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1標準は、サーバー主導のネゴシエーションを開始する標準ヘッダー（&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;）のリストを定義しています。厳密には&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;はこのリストに含まれていませんが、要求されたリソースの特定の表現を送信するために使用されることもありますが、これは良い習慣とは見なされていません。サーバーは&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、コンテンツネゴシエーションに実際に使用したヘッダー（正確には関連する応答ヘッダー）を示すため、&lt;a href=&quot;caching&quot;&gt;キャッシュ&lt;/a&gt;は最適に機能します。</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP/2のバイナリフレーム機構は、適用されたAPIや設定ファイルの変更を必要としないように設計されています。</target>
        </trans-unit>
        <trans-unit id="eab0e3a9f6070e36846c5fd400fcb4bef4e35044" translate="yes" xml:space="preserve">
          <source>The HTTP/2 header field encoding allows the expression of names that
   are not valid field names in the Internet Message Syntax used by
   HTTP/1.1.  Requests or responses containing invalid header field
   names MUST be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  An
   intermediary therefore cannot translate an HTTP/2 request or response
   containing an invalid field name into an HTTP/1.1 message.

   Similarly, HTTP/2 allows header field values that are not valid.
   While most of the values that can be encoded will not alter header
   field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII
   0xa), and the zero character (NUL, ASCII 0x0) might be exploited by
   an attacker if they are translated verbatim.  Any request or response
   that contains a character not permitted in a header field value MUST
   be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  Valid characters are
   defined by the &quot;field-content&quot; ABNF rule in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2ヘッダーフィールドエンコーディングでは、HTTP /1.1で使用されるインターネットメッセージ構文で有効なフィールド名ではない名前を表現できます。無効なヘッダーフィールド名を含むリクエストまたはレスポンスは、不正な形式として扱われる必要があります（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;セクション8.1.2.6&lt;/a&gt;）。したがって、仲介者は、無効なフィールド名を含むHTTP / 2要求または応答をHTTP / 1.1メッセージに変換できません。同様に、HTTP / 2は、無効なヘッダーフィールド値を許可します。エンコードできる値のほとんどはヘッダーフィールドの解析を変更しませんが、キャリッジリターン（CR、ASCII 0xd）、改行（LF、ASCII 0xa）、およびゼロ文字（NUL、ASCII 0x0）が攻撃者によって悪用される可能性がありますそれらが逐語的に翻訳されている場合。ヘッダーフィールド値で許可されていない文字を含む要求または応答は、不正な形式として扱われる必要があります（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;セクション8.1.2.6&lt;/a&gt;）。有効な文字は&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;、[RFC7230]のセクション3.2の&lt;/a&gt;「field-content」ABNFルールによって定義されています。</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP/2プロトコルは、HTTP/1.1バージョンといくつかの主要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="5ab1960130a01b920907a6e30a6c6e0c01c3afed" translate="yes" xml:space="preserve">
          <source>The HTTP/2 specification is split into four parts:

   o  Starting HTTP/2 (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) covers how an HTTP/2 connection is
      initiated.

   o  The frame (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and stream (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) layers describe the
      way HTTP/2 frames are structured and formed into multiplexed
      streams.

   o  Frame (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) and error (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) definitions include
      details of the frame and error types used in HTTP/2.

   o  HTTP mappings (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) and additional requirements (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;)
      describe how HTTP semantics are expressed using frames and
      streams.

   While some of the frame and stream layer concepts are isolated from
   HTTP, this specification does not define a completely generic frame
   layer.  The frame and stream layers are tailored to the needs of the
   HTTP protocol and server push.</source>
          <target state="translated">HTTP / 2仕様は、次の4つの部分に分かれています。oHTTP/ 2の開始（&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）では、HTTP / 2接続の開始方法について説明します。oフレーム（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）およびストリーム（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）レイヤーは、HTTP / 2フレームが構造化され、多重化されたストリームに形成される方法を説明します。oフレーム（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）とエラー（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）の定義には、HTTP / 2で使用されるフレームとエラータイプの詳細が含まれます。o HTTPマッピング（&lt;a href=&quot;#section-8&quot;&gt;セクション8&lt;/a&gt;）および追加要件（&lt;a href=&quot;#section-9&quot;&gt;セクション9&lt;/a&gt;）フレームとストリームを使用してHTTPセマンティクスがどのように表現されるかを説明します。フレームおよびストリームレイヤーの概念の一部はHTTPから分離されていますが、この仕様では完全に汎用的なフレームレイヤーを定義していません。フレームレイヤーとストリームレイヤーは、HTTPプロトコルとサーバープッシュのニーズに合わせて調整されています。</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Host request-headerフィールドは、ユーザーまたは参照リソース（&lt;a href=&quot;#section-3.2.2&quot;&gt;セクション3.2.2で&lt;/a&gt;説明されているように、通常はHTTP URL）によって与えられた元のURIから取得した、要求されているリソースのインターネットホストとポート番号を指定します。 Hostフィールドの値は、元のURLで指定されたオリジンサーバーまたはゲートウェイの命名機関を表す必要があります。これにより、起点サーバーまたはゲートウェイは、単一のIPアドレス上の複数のホスト名のサーバーのルート「/」URLなど、内部的にあいまいなURLを区別できます。 Host = &quot;Host&quot; &quot;：&quot; host [&quot;：&quot; port]; &lt;a href=&quot;#section-3.2.2&quot;&gt;セクション3.2.2&lt;/a&gt; 後続のポート情報のない「ホスト」は、要求されたサービスのデフォルトポートを意味します（たとえば、HTTP URLの場合は「80」）。たとえば、&amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;に対するオリジンサーバーでのリクエスト&amp;gt; GET / pub / WWW / HTTP / 1.1 Host：www.w3.orgクライアントはすべてのHTTP / 1.1リクエストメッセージにHostヘッダーフィールドを含める必要があります。要求されたURIに、要求されているサービスのインターネットホスト名が含まれていない場合は、Hostヘッダーフィールドに空の値を指定する必要があります。 HTTP / 1.1プロキシは、転送するすべての要求メッセージに、プロキシによって要求されているサービスを識別する適切なホストヘッダーフィールドが含まれていることを確認する必要があります。すべてのインターネットベースのHTTP / 1.1サーバーは、ホストヘッダーフィールドがないHTTP / 1.1リクエストメッセージに対して400（Bad Request）ステータスコードで応答する必要があります。ホストに関連するその他の要件については、セクション&lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;および&lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="translated">Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances(HTCPCP-TEA)。レスポンスコード</target>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; responseステータスコードは、要求が処理のために受け入れられたが、処理が完了していないことを示します。実際、処理はまだ開始されていない可能性があります。リクエストは、実際に処理が行われるときに許可されない可能性があるため、最終的に処理される場合とされない場合があります。</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求が受信されたがまだ処理されていないことを示します。これは非コミットです。つまり、HTTPが要求の処理結果を示す非同期応答を後で送信する方法はありません。これは、別のプロセスまたはサーバーが要求を処理する場合、またはバッチ処理を目的としています。</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに確実に移動されたことを示します。ブラウザがこのページにリダイレクトし、検索エンジンがリソースへのリンクを更新します（ 'SEO-speak'では、 'link-juice'が新しいURLに送信されると言われています）。</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに一時的に移動されたことを示します。ブラウザはこのページにリダイレクトしますが、検索エンジンはリソースへのリンクを更新しません（ 'SEO-speak'では、 'link-juice'は新しいURLに送信されないと言われています）。</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、リダイレクトが新しくアップロードされたリソースではなく、確認ページやアップロードの進行状況ページなどの別のページにリンクされていることを示します。この応答コードは通常、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;結果として返送されます。このリダイレクトされたページを表示するために使用されるメソッドは常に&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コード&lt;strong&gt;」を参照してください。&lt;/strong&gt;リダイレクトは、新しくアップロードされたリソースではなく、別のページ（確認ページやアップロードの進行状況ページなど）にリンクします。この応答コードは通常、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;結果として返送されます。このリダイレクトされたページを表示するために使用されるメソッドは、常に&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに確実に移動されたことを示します。ブラウザがこのページにリダイレクトし、検索エンジンがリソースへのリンクを更新します（ 'SEO-speak'では、 'link-juice'が新しいURLに送信されると言われています）。</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントエラーと見なされるもの（たとえば、不正な形式の要求構文、無効な要求メッセージフレーミング、または欺瞞的な要求）が原因で、サーバーが要求を処理できない、または処理しないことを示します。ルーティング）。</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、無効な構文のためにサーバーが要求を理解できなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、リクエストメソッドがサーバーで認識されているが、ターゲットリソースではサポートされていないことを示します。</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーがリクエストの事前対応型&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;ヘッダーで定義された許容値のリストと一致する応答を生成できず、サーバーがデフォルトの表現を提供することを望まないことを示します。</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、サーバーがこの未使用の接続をシャットダウンしたいことを意味します。&lt;em&gt;クライアントからの以前の要求がない場合でも&lt;/em&gt;、一部のサーバーによってアイドル接続で&lt;em&gt;送信されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; clientエラー応答コードは、ターゲットリソースへのアクセスがオリジンサーバーで利用できなくなったこと、およびこの状態が永続的である可能性が高いことを示しています。</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが、定義された&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダーなしで要求を受け入れることを拒否することを示します。</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、ターゲットリソースへのアクセスが拒否されたことを示します。これは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;以外のメソッドの条件付きリクエストで、&lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;ヘッダーによって定義された条件が満たされない場合に発生します。その場合、リクエスト（通常はリソースのアップロードまたは変更）を行うことができず、このエラー応答が返されます。</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; エラー応答コードは、サーバーが要求された範囲を処理できないことを示します。最も可能性の高い理由は、ドキュメントにそのような範囲が含まれていないか、&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーの値が構文的には正しいものの、意味がないことです。</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、サーバーが要求エンティティのコンテンツタイプを理解し、要求エンティティの構文は正しいが、含まれている指示を処理できなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、サーバーが再生される可能性のある要求を処理するリスクを負わないことを示し、再生攻撃の可能性を生み出します。</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; クライアントエラーレスポンスコードは、法的措置がとられたWebページなど、法的理由により利用できないリソースをユーザーが要求したことを示します。</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; サーバーエラーの応答コードは、サーバーが予期しない状態に遭遇し、要求の処理を妨げたことを示しています。</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、要求メソッドがサーバーでサポートされておらず、処理できないことを示します。サーバーがサポートする必要がある（したがって、このコードを返してはならない）唯一のメソッドは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは&lt;strong&gt;、サーバーが要求を満たすために必要な機能をサポートしていない&lt;/strong&gt;ことを意味し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; サーバーのエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、上流サーバーから無効な応答を受信したことを示します。</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーが要求を処理する準備ができていないことを示します。</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、時間内に応答を取得できないことを示します。</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、要求を完了するために必要なアップストリームサーバーからの応答を時間内に取得しなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; サポートされていないHTTPバージョンレスポンスステータスコードは、リクエストで使用されているHTTPバージョンがサーバーでサポートされていないことを示します。</target>
        </trans-unit>
        <trans-unit id="49ce1d6f6a8be4676edf766aee4540297f25f76a" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of Transparent Content Negotiation (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;). This protocol enables a client to retrieve the best variant of a given resource, where the server supports multiple variants.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、透過的コンテンツネゴシエーションのコンテキストで指定できます（&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295を&lt;/a&gt;参照）。このプロトコルにより、クライアントは特定のリソースの最適なバリアントを取得できます。サーバーは複数のバリアントをサポートしています。</target>
        </trans-unit>
        <trans-unit id="820e5cef7a998998b0849eeb24e0fff1b6649bae" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;).</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、Web分散オーサリングおよびバージョン管理（WebDAV）プロトコルのコンテキストで指定される場合があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="76d88c87ab8a315a60aa9543690290ffbfbdb653" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、Web分散オーサリングおよびバージョン管理（WebDAV）プロトコルのコンテキストで指定できます。</target>
        </trans-unit>
        <trans-unit id="81aa286d5750f499d27f8f17321bc45f7f2ca1f1" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; response status code is sent in the context of the HTTP Extension Framework, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;で定義されているHTTPExtensionFrameworkのコンテキストで送信されます。</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP）はステートレスなアプリケーションレベルの要求/応答プロトコルであり、拡張可能なセマンティクスと自己記述的なメッセージペイロードを使用して、ネットワークベースのハイパーテキスト情報システムと柔軟に対話します。このドキュメントは、HTTP / 1.1仕様をまとめて形成する一連のドキュメントの最初のものです。1.「メッセージの構文とルーティング」（このドキュメント）2.「セマンティクスとコンテンツ」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3.「条件付きリクエスト」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4.「範囲要求」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5.「キャッシング」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6.「認証」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]このHTTP / 1。1仕様は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145を廃止&lt;/a&gt;（HTTPバージョン管理上）。この仕様はまた、以前に&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;で定義されたトンネルを確立するためのCONNECTの使用を更新し、&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818で&lt;/a&gt;非公式に説明された「https」URIスキームを定義します。 HTTPは、情報システムの汎用インターフェースプロトコルです。提供されるリソースのタイプに依存しない均一なインターフェースをクライアントに提示することにより、サービスの実装方法の詳細を隠すように設計されています。同様に、サーバーは各クライアントの目的を認識する必要はありません。HTTP要求は、特定のタイプのクライアントや事前に定義された一連のアプリケーションステップに関連付けられるのではなく、単独で考慮されます。その結果、多くの異なるコンテキストで効果的に使用でき、実装が時間の経過とともに独立して進化できるプロトコルが得られます。 HTTPは、非HTTP情報システムとの間の通信を変換するための仲介プロトコルとして使用するためにも設計されています。HTTPプロキシとゲートウェイは、HTTPサービスと同じ方法でクライアントが表示および操作できるハイパーテキスト形式に多様なプロトコルを変換することにより、代替情報サービスへのアクセスを提供できます。この柔軟性の結果として、インターフェースの背後で何が発生するかに関してプロトコルを定義できなくなります。代わりに、通信の構文、受信した通信の意図、および受信者の予想される動作の定義に限定されます。通信が単独で考慮される場合、成功したアクションは、サーバーによって提供される監視可能なインターフェースへの対応する変更に反映されるべきです。ただし、複数のクライアントが並行して、おそらくはクロスパーパスで動作する可能性があるため、そのような変更が単一の応答の範囲を超えて観察可能であることを要求することはできません。このドキュメントでは、HTTPで使用または参照されるアーキテクチャ要素について説明し、「http」および「https」URIスキームを定義し、ネットワーク操作と接続管理全体を説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。全体的なネットワーク操作と接続管理について説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。全体的なネットワーク操作と接続管理について説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。</target>
        </trans-unit>
        <trans-unit id="265e7d56ba5f2b7320f23766ef7d78d6049d252e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a wildly successful
   protocol.  However, the way HTTP/1.1 uses the underlying transport
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230], Section&amp;nbsp;6&lt;/a&gt;) has several characteristics that have a
   negative overall effect on application performance today.

   In particular, HTTP/1.0 allowed only one request to be outstanding at
   a time on a given TCP connection.  HTTP/1.1 added request pipelining,
   but this only partially addressed request concurrency and still
   suffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1
   clients that need to make many requests use multiple connections to a
   server in order to achieve concurrency and thereby reduce latency.

   Furthermore, HTTP header fields are often repetitive and verbose,
   causing unnecessary network traffic as well as causing the initial
   TCP [&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] congestion window to quickly fill.  This can result in
   excessive latency when multiple requests are made on a new TCP
   connection.

   HTTP/2 addresses these issues by defining an optimized mapping of
   HTTP's semantics to an underlying connection.  Specifically, it
   allows interleaving of request and response messages on the same
   connection and uses an efficient coding for HTTP header fields.  It
   also allows prioritization of requests, letting more important
   requests complete more quickly, further improving performance. 

   The resulting protocol is more friendly to the network because fewer
   TCP connections can be used in comparison to HTTP/1.x.  This means
   less competition with other flows and longer-lived connections, which
   in turn lead to better utilization of available network capacity.

   Finally, HTTP/2 also enables more efficient processing of messages
   through use of binary message framing.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP）は、大成功を収めているプロトコルです。ただし、HTTP / 1.1が基盤となるトランスポート（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230]、セクション6&lt;/a&gt;）を使用する方法には、今日のアプリケーションのパフォーマンスに全体的に悪影響を与えるいくつかの特性があります。特に、HTTP / 1.0では、特定のTCP接続で一度に1つの要求のみを未処理にすることができました。 HTTP / 1.1はリクエストのパイプライン化を追加しましたが、これはリクエストの同時実行性に部分的にしか対処しておらず、依然としてヘッドオブラインブロッキングの問題があります。したがって、多くの要求を行う必要があるHTTP /1.0およびHTTP / 1.1クライアントは、同時実行性を実現して遅延を減らすために、サーバーへの複数の接続を使用します。さらに、HTTPヘッダーフィールドは反復的で冗長であることが多く、不要なネットワークトラフィックが発生するだけでなく、最初のTCP [ &lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;]すぐにいっぱいになる輻輳ウィンドウ。これにより、新しいTCP接続で複数の要求が行われたときに、過度の遅延が発生する可能性があります。 HTTP / 2は、HTTPのセマンティクスの基礎となる接続への最適化されたマッピングを定義することにより、これらの問題に対処します。具体的には、同じ接続での要求メッセージと応答メッセージのインターリーブを可能にし、HTTPヘッダーフィールドの効率的なコーディングを使用します。また、リクエストの優先順位付けが可能になり、より重要なリクエストをより迅速に完了できるようになり、パフォーマンスがさらに向上します。結果として得られるプロトコルは、HTTP / 1.xと比較して使用できるTCP接続が少ないため、ネットワークにとってより使いやすいものになります。これは、他のフローとの競合が少なくなり、接続の寿命が長くなることを意味します。これにより、利用可能なネットワーク容量の利用率が向上します。最後に、HTTP / 2は、バイナリメッセージフレーミングを使用してメッセージをより効率的に処理することもできます。</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP）は、分散型の協調型ハイパーメディア情報システム用のアプリケーションレベルのプロトコルです。 HTTPは、1990年以来、World-Wide Webグローバル情報イニシアチブで使用されています。HTTP/ 0.9と呼ばれるHTTPの最初のバージョンは、インターネットを介した生データ転送用のシンプルなプロトコルでした。&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6で&lt;/a&gt;定義されている HTTP / 1.0]、メッセージをMIMEのようなメッセージの形式にできるようにすることでプロトコルを改善しました。これには、転送されたデータに関するメタ情報と、要求/応答セマンティクスの修飾子が含まれています。ただし、HTTP / 1.0では、階層プロキシ、キャッシュ、永続的な接続の必要性、または仮想ホストの影響を十分に考慮していません。さらに、「HTTP / 1.0」と呼ばれる不完全に実装されたアプリケーションの急増により、2つの通信アプリケーションが互いの真の機能を判別するために、プロトコルバージョンの変更が必要になりました。この仕様は、「HTTP / 1.1」と呼ばれるプロトコルを定義しています。このプロトコルには、その機能の信頼できる実装を保証するために、HTTP / 1.0よりも厳しい要件が含まれています。実用的な情報システムには、検索、フロントエンドの更新、注釈など、単純な検索よりも多くの機能が必要です。 HTTPは、リクエストの目的を示すメソッドとヘッダーの制限のないセットを許可します[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。メソッドが適用されるリソースを示すために、場所（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]または名前（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ] として、Uniform Resource Identifier（URI）[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ] によって提供される参照の規律に基づいて構築されています。メッセージは、多目的インターネットメール拡張機能（MIME）[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]で定義されているインターネットメール[ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] で使用されているものと同様の形式で渡されます。 HTTPは、SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ]、NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ]、FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ]、Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ]、およびWAIS [でサポートされているものを含む、他のインターネットシステムへのユーザーエージェントとプロキシ/ゲートウェイ間の通信の汎用プロトコルとしても使用されます。&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ]プロトコル。このように、HTTPは、さまざまなアプリケーションから利用可能なリソースへの基本的なハイパーメディアアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">ハイパーテキスト転送プロトコル ステータスコード 308 (恒久的リダイレクト)</target>
        </trans-unit>
        <trans-unit id="7c3eef52124b6a04770da43e5780935c839f5a5d" translate="yes" xml:space="preserve">
          <source>The IP address is invalid</source>
          <target state="translated">IPアドレスが無効です</target>
        </trans-unit>
        <trans-unit id="6eeb9098fe0eb68f08e0d43612ff763509c93784" translate="yes" xml:space="preserve">
          <source>The IP address is unreachable</source>
          <target state="translated">IPアドレスが届かない</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">Ifヘッダーには2つの異なる目的があります。o最初の目的は、特定のリソースにトークンおよびETagと一致する条件を含む一連の状態リストを提供することにより、要求を条件付きにすることです。このヘッダーが評価され、すべての状態リストが失敗した場合、リクエストは412（Precondition Failed）ステータスで失敗する必要があります。一方、要求は、記述された状態リストの1つが成功した場合にのみ成功できます。状態リストと一致する関数の成功基準は、セクション&lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;および&lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4で&lt;/a&gt;定義されています。。 oさらに、状態トークンがIfヘッダーに表示されるという単なる事実は、要求とともに「送信」されたことを意味します。一般に、これは、クライアントがその状態トークンを知っていることを示すために使用されます。状態トークンを送信するためのセマンティクスは、そのタイプによって異なります（ロックトークンについては、&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;を参照してください）。これら2つの目的は明確に扱う必要があることに注意してください。状態トークンは、サーバーが実際に出現する状態リストを評価したかどうかに関係なく、また、表現された条件がtrueであることが判明したかどうかに関係なく、送信されたものとしてカウントされます。</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">Ifリクエストヘッダーは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;、[RFC2616]のセクション14.24で&lt;/a&gt;定義されているIf-Matchヘッダーと同様の機能を持つことを目的としています。ただし、Ifヘッダーは、ETagsだけでなくすべての状態トークンを処理します。状態トークンの典型的な例はロックトークンであり、この仕様で定義されている状態トークンはロックトークンだけです。</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Matchリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。以前にリソースから取得した1つ以上のエンティティを持つクライアントは、関連するエンティティタグのリストをIf-Matchヘッダーフィールドに含めることにより、それらのエンティティの1つが最新であることを確認できます。エンティティタグは&lt;a href=&quot;#section-3.11&quot;&gt;セクション3.11で&lt;/a&gt;定義されています。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。また、リクエストの更新時に、誤ったバージョンのリソースが誤って変更されるのを防ぐためにも使用されます。特殊なケースとして、値「*」はリソースの現在のエンティティと一致します。 If-Match = &quot;If-Match&quot; &quot;：&quot;（ &quot;*&quot; | 1＃entity-tag）いずれかのエンティティタグが、類似のGETリクエストへの応答で返されるエンティティのエンティティタグと一致する場合（そのリソースにIf-Matchヘッダーがない場合）、または「*」が指定されていて、そのリソースに現在のエンティティが存在する場合、サーバーは、If-Matchヘッダーフィールドが存在しないかのように、要求されたメソッドを実行できます。サーバーは強力な比較関数を使用する必要があります（ &lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を参照）&lt;/a&gt;）If-Matchのエンティティタグを比較します。一致するエンティティタグがない場合、または「*」が指定されていて、現在のエンティティが存在しない場合、サーバーは要求されたメソッドを実行してはならず、412（前提条件失敗）応答を返さなければなりません（MUST）。この動作は、クライアントが最後にリソースを取得してから変更されたリソースをPUTなどの更新メソッドが変更できないようにする場合に最も役立ちます。リクエストが、If-Matchヘッダーフィールドなしで、2xxまたは412ステータス以外の結果になる場合は、If-Matchヘッダーを無視する必要があります。 &quot;If-Match：*&quot;の意味は、オリジンサーバー（またはキャッシュ、おそらくVaryメカニズムを使用）によって表現が選択された場合にメソッドを実行する必要があることです。&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44を&lt;/a&gt;参照してください。）存在し、表現が存在しない場合は実行してはならない（MUST NOT）。リソース（PUTなど）を更新することを目的としたリクエストには、If-Match値に対応するエンティティ（単一のエンティティタグ）がもはや存在しない場合、リクエストメソッドを適用してはならないことを示すIf-Matchヘッダーフィールドを含めることができます（MAY）。そのリソースの表現。これにより、ユーザーが知らないうちにリソースが変更された場合に、リクエストが成功しないことをユーザーが示すことができます。例：If-Match： &quot;xyzzy&quot; If-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot;、 &quot;c3piozzzz&quot; If-Match：* If-MatchヘッダーフィールドとIf-None-Matchの両方を持つリクエストの結果または、If-Modified-Sinceヘッダーフィールドはこの仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Sinceリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。要求されたバリアントがこのフィールドで指定された時間以降に変更されていない場合、エンティティはサーバーから返されません。代わりに、メッセージ本文なしで304（変更されていない）応答が返されます。 If-Modified-Since = &quot;If-Modified-Since&quot; &quot;：&quot; HTTP-dateフィールドの例は次のとおりです：If-Modified-Since：Sat、29 Oct 1994 19:43:31 GMT A GET method with a If- Modified-Sinceヘッダーがあり、Rangeヘッダーがない場合は、識別されたエンティティを、If-Modified-Sinceヘッダーで指定された日付以降に変更されている場合にのみ転送するように要求します。これを決定するためのアルゴリズムには、以下のケースが含まれます。a）リクエストが通常200（OK）ステータス以外になる場合、または渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るまたは、渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るまたは、渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るサーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るサーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るc）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るc）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見る&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;詳細については。注：If-Modified-Since時刻はサーバーによって解釈され、その時刻はクライアントと同期されていない可能性があります。注：一部のサーバーは、If-Modified-Sinceヘッダーフィールドを処理するときに、小なり関数ではなく正確な日付比較関数を使用して、304（未変更）応答を送信するかどうかを決定します。キャッシュ検証のためにIf-Modified-Sinceヘッダーフィールドを送信するときに最良の結果を得るには、可能な限り、前回のLast-Modifiedヘッダーフィールドで受信した正確な日付文字列を使用することをお勧めします。注：クライアントが、同じリクエストのLast-Modifiedヘッダーから取得した日付ではなく、If-Modified-Sinceヘッダーで任意の日付を使用する場合、クライアントは、この日付がサーバーの時間の理解で解釈されるという事実を認識する必要があります。クライアントは、クライアントとサーバー間の時間のエンコーディングが異なるため、非同期のクロックと丸めの問題を考慮する必要があります。これには、ドキュメントが最初に要求された時刻と後続の要求のIf-Modified-Since日付の間にドキュメントが変更された場合の競合状態の可能性、およびIf-Modified-Since日付の場合のクロックスキュー関連の問題の可能性が含まれます。サーバーのクロックを修正せずに、クライアントのクロックから導出されます。クライアントとサーバー間の異なるタイムベースの修正は、ネットワークのレイテンシのため、せいぜい概算です。If-Modified-Sinceヘッダーフィールドと、If-MatchまたはIf-Unmodified-Sinceヘッダーフィールドの両方を持つリクエストの結果は、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Matchリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。リソースから以前に取得した1つ以上のエンティティを持つクライアントは、関連するエンティティタグのリストをIf-None-Matchヘッダーフィールドに含めることにより、それらのエンティティが現在のものでないことを確認できます。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。また、リソースが存在しないとクライアントが判断したときに、メソッド（PUTなど）が既存のリソースを誤って変更しないようにするためにも使用されます。特殊なケースとして、値「*」はリソースの現在のエンティティと一致します。 If-None-Match = &quot;If-None-Match&quot; &quot;：&quot;（ &quot;*&quot;| 1＃entity-tag）エンティティタグのいずれかが、そのリソースに対する同様のGETリクエスト（If-None-Matchヘッダーなし）への応答で返されるエンティティのエンティティタグと一致する場合、または &quot;* &quot;が指定されており、そのリソースに現在のエンティティが存在する場合、リソースの変更日がリクエストのIf-Modified-Sinceヘッダーフィールドで指定されたものと一致しないため、サーバーは必要に応じて、要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る見る見る見る見る次に、リソースの変更日付が要求のIf-Modified-Sinceヘッダーフィールドで指定された日付と一致しないため、サーバーは要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る次に、リソースの変更日付が要求のIf-Modified-Sinceヘッダーフィールドで指定された日付と一致しないため、サーバーは要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見るサーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含む304（Not Modified）応答で応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見るサーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含む304（Not Modified）応答で応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;2つのエンティティタグが一致するかどうかを判断する方法については、セクション13.3.3を参照してください。弱比較関数は、GETまたはHEADリクエストでのみ使用できます。一致するエンティティタグがない場合、サーバーは、If-None-Matchヘッダーフィールドが存在しない場合と同様に、リクエストされたメソッドを実行できますが、リクエスト内のすべてのIf-Modified-Sinceヘッダーフィールドも無視する必要があります。つまり、一致するエンティティタグがない場合、サーバーは304（Not Modified）応答を返してはなりません（MUST NOT）。リクエストが、If-None-Matchヘッダーフィールドなしで、2xxまたは304ステータス以外の結果になる場合、If-None-Matchヘッダーは無視される必要があります。 （&lt;a href=&quot;#section-13.3.4&quot;&gt;セクション13.3.4を&lt;/a&gt;参照If-Modified-SinceとIf-None-Matchの両方が同じリクエストに含まれる場合のサーバーの動作については、「If-None-Match：*」の意味は、表現が選択されている場合はメソッドを実行してはならないことです。オリジンサーバー（またはキャッシュ、おそらくVaryメカニズムを使用）、&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44を&lt;/a&gt;参照）が存在し、表現が存在しない場合は実行する必要があります（SHOULD）。この機能は、PUT操作間の競合を防ぐのに役立つことを目的としています。例：If-None-Match： &quot;xyzzy&quot; If-None-Match：W / &quot;xyzzy&quot; If-None-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot;、 &quot;c3piozzzz&quot; If-None-Match：W / &quot;xyzzy&quot; 、W / &quot;r2d2xxxx&quot;、W / &quot;c3piozzzz&quot; If-None-Match：* If-None-Matchヘッダーフィールドと、If-MatchまたはIf-Unmodified-Sinceヘッダーフィールドの両方を持つリクエストの結果は、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Sinceリクエストヘッダーフィールドは、条件付きにするためのメソッドと共に使用される。リクエストされたリソースがこのフィールドで指定された時間以降に変更されていない場合、 サーバーはIf-Unmodified-Sinceヘッダーが存在しないかのようにリクエストされた 操作を実行するべきである[SHOULD]。要求された variant が指定された時間以降に変更されている場合、サーバーは要求された操作を実行してはならず[MUST NOT]、412(Precondition Failed)を返さなければならない[MUST]。If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date フィールドの例は以下の通りである。 If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT 通常のリクエスト(すなわち、If-Unmodified-Sinceヘッダーがない場合)が2xxまたは 412ステータス以外の結果になる場合、If-Unmodified-Sinceヘッダーは無視されるべきである[SHOULD]。指定された日付が無効な場合、ヘッダーは無視される。If-Unmodified-SinceヘッダーフィールドとIf-None-MatchまたはIf-Modified-Sinceヘッダー フィールドの両方を持つリクエストの結果は、この仕様では未定義である。</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">JavaScript関数は1つの文字列を返します。</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScriptの関数は常にそれ自体でファイルに保存されるべきであり、HTMLに埋め込まれるべきではありません。</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="translated">JavaScriptの機能は常に単独でファイルに保存しておく必要がありますが、HTMLファイルなどに埋め込んではいけません。</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">これらのセクションに含まれるJavaScriptスニペット（およびこれらのクロスサイトリクエストを正しく処理するサーバーコードの実行中のインスタンス）は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http：//arunranga.com/examples/access-control/&lt;/a&gt;で「動作中」にあり、クロスサイト &lt;code&gt;XMLHttpRequest&lt;/code&gt; をサポートするブラウザで動作します。</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">キープアライブヘッダー(実験仕様</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified エンティティヘッダフィールドは、オリジンサーバが variant が最後に変更されたと考える日時を示します。Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date 使用例は Last-Modified です。Tue,15 Nov 1994 12:45:26 GMT このヘッダフィールドの正確な意味は、オリジンサーバの実装と元のリソースの性質に依存します。ファイルの場合は、ファイルシステムの最終更新時刻になります。動的に含まれる部品を持つエンティティの場合は、その部品の最終更新時刻のセットの中で最も新しい時刻になります。データベース・ゲートウェイの場合は、レコードの最終更新時刻であるかもしれません。仮想オブジェクトの場合は、内部状態が最後に変更された時間かもしれません。送信元のサーバは、メッセージの送信元のサーバの時刻よりも遅いLast-Modifiedの日付を送信してはなりません[MUST NOT]。このような場合、リソースの最終変更が将来のある時点を示している場合、サーバーはその日付を メッセージの生成日に置き換えなければならない[MUST]。送信元サーバーは、エンティティのLast-Modified値を、それが応答のDate値を生成 する時間にできるだけ近い時間で取得するべきである[SHOULD]。これにより、特に応答が生成された時刻の近くでエンティティが変更された場合、受信者は エンティティの修正時刻を正確に評価することができる。HTTP/1.1サーバは可能な限りLast-Modifiedを送るべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified エンティティヘッダフィールド値はキャッシュバリデータとしてよく使用されます。簡単に言えば、キャッシュエントリは Last-Modified 値以降にエンティティが変更されていない場合に有効であると考えられます。</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Location応答ヘッダーフィールドは、要求の完了または新しいリソースの識別のために、受信者をRequest-URI以外の場所にリダイレクトするために使用されます。 201（Created）応答の場合、Locationは、要求によって作成された新しいリソースの場所です。 3xx応答の場合、ロケーションは、リソースへの自動リダイレクトのためのサーバーの優先URIを示す必要があります（SHOULD）。フィールド値は、単一の絶対URIで構成されています。 Location = &quot;Location&quot; &quot;：&quot; absoluteURI例：Location：&lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/pub/WWW/People.html 注：Content-Locationヘッダーフィールド（&lt;a href=&quot;#section-14.14&quot;&gt;セクション14.14&lt;/a&gt;）Locationとは異なります。Content-Locationは、リクエストに含まれるエンティティの元の場所を識別します。したがって、応答にLocationとContent-Locationの両方のヘッダーフィールドを含めることができます。一部のメソッドのキャッシュ要件については、&lt;a href=&quot;#section-13.10&quot;&gt;セクション13.10&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">視聴覚ファイルのMIMEタイプは、主にコンテナのフォーマットを示す。ウェブ上で最も一般的なものは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">非コレクションリソースに対するMOVE操作は、コピー（COPY）に論理的に相当し、一貫性の維持処理が続き、その後にソースの削除が続きます。3つのアクションすべてが1つの操作で実行されます。一貫性の維持ステップにより、サーバーは、移動元のリソースを識別するRequest-URI以外のすべてのURLを更新するなど、移動によって発生した更新を実行して、新しい移動先のリソースを指すことができます。 DestinationヘッダーはすべてのMOVEメソッドに存在する必要があり、MOVEメソッドのCOPY部分のすべてのCOPY要件に従う必要があります。すべてのWebDAV準拠リソースはMOVEメソッドをサポートする必要があります。 MOVEメソッドのサポートは、リソースを特定の宛先に移動する機能を保証するものではありません。例えば、別々のプログラムが実際に同じサーバー上の異なるリソースのセットを制御する場合があります。したがって、同じサーバーに属しているように見えるネームスペース内のリソースを移動できない場合があります。リソースが宛先に存在する場合、Overwriteヘッダーの制限に従い、MOVE操作の副作用として宛先リソースが削除されます。この方法はべき等ですが、安全ではありません（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwardsリクエストヘッダーフィールドは、TRACE（&lt;a href=&quot;#section-9.8&quot;&gt;セクション9.8&lt;/a&gt;）およびOPTIONS（&lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2&lt;/a&gt;）を備えたメカニズムを提供します。）リクエストを次の受信サーバーに転送できるプロキシまたはゲートウェイの数を制限するメソッド。これは、クライアントが途中のチェーンで失敗またはループしているように見えるリクエストチェーンをトレースしようとしている場合に役立ちます。 Max-Forwards = &quot;Max-Forwards&quot; &quot;：&quot; 1 * DIGIT Max-Forwards値は、この要求メッセージが転送される残りの回数を示す10進整数です。 Max-Forwardsヘッダーフィールドを含むTRACEまたはOPTIONSリクエストの各プロキシまたはゲートウェイ受信者は、リクエストを転送する前にその値を確認および更新する必要があります。受信した値がゼロ（0）の場合、受信者はリクエストを転送してはなりません（MUST NOT）。代わりに、最終的な受信者として応答する必要があります。受信したMax-Forwards値がゼロより大きい場合、次に、転送されたメッセージには、値が1減少した更新済みのMax-Forwardsフィールドが含まれている必要があります。 Max-Forwardsヘッダーフィールドは、この仕様で定義されている他のすべてのメソッド、およびそのメソッド定義の一部として明示的に参照されていない拡張メソッドでは無視される場合があります。</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">メンバーURIを使用すると、クライアントはHTTPのGET、PUT、およびDELETEメソッドを使用してメンバーリソースを取得、編集、および削除できます。エントリーリソースは、Atomエントリードキュメントとして表されます。メンバーURIは2つの場所に表示されます。以下の&lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2で&lt;/a&gt;説明するように、POSTを使用してリソースが正常に作成された後、それらはLocationヘッダーで返され ます。また、コレクションフィードのエントリに、リンク関係が「編集」のatom：link要素として表示される場合もあります。メンバーエントリには、メンバーURIを示す &quot;edit&quot;のリンク関係を持つ、atom：link要素を含める必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">Methodトークンは、Request-URIで識別されるリソースで実行されるメソッドを示します。このメソッドでは大文字と小文字が区別されます。メソッド= &quot;OPTIONS&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2&lt;/a&gt; | &quot;取得する&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;セクション9.3&lt;/a&gt; | &quot;頭&quot; ; &lt;a href=&quot;#section-9.4&quot;&gt;セクション9.4&lt;/a&gt; | &quot;役職&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt; | &quot;PUT&quot;; &lt;a href=&quot;#section-9.6&quot;&gt;セクション9.6&lt;/a&gt; | &quot;削除&quot;; &lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt; | &quot;痕跡&quot; ; &lt;a href=&quot;#section-9.8&quot;&gt;セクション9.8&lt;/a&gt; | 「接続」; &lt;a href=&quot;#section-9.9&quot;&gt;セクション9.9&lt;/a&gt; | extension-method extension-method = tokenリソースによって許可されるメソッドのリストは、Allowヘッダーフィールドで指定できます（&lt;a href=&quot;#section-14.7&quot;&gt;セクション14.7&lt;/a&gt;）。許可されたメソッドのセットは動的に変更できるため、リソースのメソッドが現在許可されているかどうか、応答の戻りコードは常にクライアントに通知します。オリジンサーバーは、メソッドがオリジンサーバーによって認識されているが要求されたリソースに対して許可されていない場合はステータスコード405（メソッドが許可されていない）を返し、メソッドがオリジンサーバーによって認識されていないか実装されていない場合は501（実装されていない）を返す必要があります。メソッドGETおよびHEADは、すべての汎用サーバーでサポートされている必要があります。他のすべての方法はオプションです。ただし、上記のメソッドが実装されている場合は、&lt;a href=&quot;#section-9&quot;&gt;セクション9で&lt;/a&gt;指定されているものと同じセマンティクスで実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONSメソッドは、Request-URIによって識別されるリクエスト/レスポンスチェイン上で利用可能な通信オプションに関する情報のリクエストを表す。このメソッドにより、クライアントは、リソースのアクションを暗示したり、リソースの検索を開始したりすることなく、リソースに関連付けられたオプションや要件、またはサーバの能力を決定することができる。このメソッドに対する応答はキャッシュ可能ではない。OPTIONSリクエストが(Content-LengthまたはTransfer-Encodingの存在で示されるように)エンティティボディを含む場合、メディアタイプはContent-Typeフィールドで示されな ければならない[MUST]。この仕様ではそのようなボディの使用法は定義されていないが、HTTPの将来の拡張はOPTIONSボディを使用して サーバー上でより詳細な問い合わせを行うかもしれない。そのような拡張をサポートしないサーバーはリクエストボディを破棄してもよい[MAY]。Request-URIがアスタリスク(&quot;*&quot;)の場合、OPTIONSリクエストは特定のリソー スではなく、一般的にサーバーに適用されることを意図している。サーバの通信オプションは通常リソースに依存するので、&quot;*&quot;リクエストは &quot;ping &quot;や &quot;no-op &quot;タイプのメソッドとしてのみ有用である。例えば、これはHTTP/1.1に準拠しているか(あるいは準拠していないか)のプロキシをテストするために 使うことができる。Request-URIがアスタリスクでない場合、OPTIONSリクエストはそのリソース と通信するときに利用可能なオプションにのみ適用される。200応答は、サーバーによって実装され、そのリソースに適用可能なオプション機能(例:Allow)を示すすべてのヘッダーフィールドを含むべきである[SHOULD]。応答ボディは、もしあれば、通信オプションに関する情報も含むべきである [SHOULD]。そのようなボディのためのフォーマットはこの仕様では定義されていないが、 HTTPの将来の拡張によって定義されるかもしれない。適切な応答フォーマットを選択するためにコンテントネゴシエーションを 使用してもよい[MAY]。応答ボディを含まない場合、応答はフィールド値が「0」のContent-Lengthフィールドを 含めなければならない[MUST]。Max-Forwardsリクエストヘッダーフィールドは、リクエストチェー ンの特定のプロキシをターゲットにするために使用してもよい[MAY]。プロキシがリクエスト転送が許可されるabsoluteURI上のOPTIONSリクエストを受け取るとき、プロキシは Max-Forwardsフィールドをチェックしなければならない[MUST]。Max-Forwardsフィールド値がゼロ(「0」)の場合、プロキシはメッセージを転送しては ならない[MUST NOT]。その代わりに、プロキシはそれ自身の通信オプションで応答す るべきである[SHOULD]。Max-Forwardsフィールド値がゼロよりも大きい整数である場合、プロキシはリク エストを転送するときにフィールド値をデクリメントしな ければならない[MUST]。リクエスト中にMax-Forwardsフィールドが存在しない場合、転送されたリクエス トはMax-Forwardsフィールドを含んではならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONSメソッドは、起点サーバーまたは介在する中間サーバーのいずれかで、ターゲットリソースに使用可能な通信オプションに関する情報を要求します。このメソッドを使用すると、クライアントは、リソースアクションを示唆することなく、リソースに関連するオプションや要件、またはサーバーの機能を決定できます。アスタリスク（ &quot;*&quot;）をリクエストターゲットとして持つOPTIONSリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]のセクション5.3）&lt;/a&gt;）は、特定のリソースではなくサーバー全般に適用されます。サーバーの通信オプションは通常リソースに依存するため、「*」リクエストは「ping」または「no-op」タイプのメソッドとしてのみ役立ちます。クライアントがサーバーの機能をテストできるようにするだけです。たとえば、HTTP / 1.1への準拠（またはその欠如）についてプロキシをテストするために使用できます。 request-targetがアスタリスクでない場合、OPTIONS要求は、ターゲットリソースとの通信時に使用可能なオプションに適用されます。 OPTIONSへの正常な応答を生成するサーバーは、サーバーによって実装され、ターゲットリソースに適用可能なオプション機能（許可など）を示す可能性のあるヘッダーフィールドを送信する必要があります（SHOULD）。この仕様で定義されていない潜在的な拡張機能を含みます。応答ペイロードは、存在する場合、マシンまたは人間が読める形式で通信オプションを記述することもあります。このような表現の標準形式はこの仕様では定義されていませんが、HTTPの将来の拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。ただし、将来のHTTPの拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。ただし、将来のHTTPの拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。 &lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）。プロキシは、リクエストがMax-Forwardsフィールドで受信されない限り、リクエストの転送中にMax-Forwardsヘッダーフィールドを生成してはなりません（MUST NOT）。ペイロード本体を含むOPTIONSリクエストを生成するクライアントは、表現メディアタイプを説明する有効なContent-Typeヘッダーフィールドを送信する必要があります。この仕様では、このようなペイロードの使用を定義していませんが、HTTPの将来の拡張では、OPTIONSボディを使用してターゲットリソースに関するより詳細なクエリを作成する可能性があります。OPTIONSメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">OperaブラウザもBlinkエンジンに基づいているため、ほとんど同じように見えますが、 &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt; が追加されています。</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Operaブラウザーもまばたきエンジンに基づいているため、ほとんど同じに見えますが、「OPR / &amp;lt;version&amp;gt;」が追加されています。</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">OSはほとんどのUser Agentの文字列で与えられますが(Firefox OSのようなWebに特化したプラットフォームでは与えられませんが)、形式は様々です。これは、ユーザーエージェントのコメント部分で、2つのセミコロンの間に固定された文字列です。これらの文字列は各ブラウザに固有のものです。これらの文字列は OS を示しますが、多くの場合、そのバージョンや依存するハードウェア (32 ビットまたは 64 ビット、Mac の場合は Intel/PPC)の情報も示します。</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="translated">PACファイルの名前は &lt;code&gt;proxy.pac&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC ファイルは proxy.pac という名前です。</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以降のセクションのPHPスニペット（およびサーバーへのJavaScript呼び出し）は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここに投稿された実際のコードサンプル&lt;/a&gt;から取得されます。これらは、クロスサイト&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;を実装するブラウザーで機能します。</target>
        </trans-unit>
        <trans-unit id="68bd99f90bb560cf24ee3bfb0650ff1043f9b961" translate="yes" xml:space="preserve">
          <source>The PING frame (type=0x6) is a mechanism for measuring a minimal
   round-trip time from the sender, as well as determining whether an
   idle connection is still functional.  PING frames can be sent from
   any endpoint.

    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 12: PING Payload Format

   In addition to the frame header, PING frames MUST contain 8 octets of
   opaque data in the payload.  A sender can include any value it
   chooses and use those octets in any fashion.

   Receivers of a PING frame that does not include an ACK flag MUST send
   a PING frame with the ACK flag set in response, with an identical
   payload.  PING responses SHOULD be given higher priority than any
   other frame.

   The PING frame defines the following flags:

   ACK (0x1):  When set, bit 0 indicates that this PING frame is a PING
      response.  An endpoint MUST set this flag in PING responses.  An
      endpoint MUST NOT respond to PING frames containing this flag. 

   PING frames are not associated with any individual stream.  If a PING
   frame is received with a stream identifier field value other than
   0x0, the recipient MUST respond with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   Receipt of a PING frame with a length field value other than 8 MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">PINGフレーム（type = 0x6）は、送信側からの最小ラウンドトリップ時間を測定し、アイドル接続がまだ機能しているかどうかを判断するためのメカニズムです。 PINGフレームは、任意のエンドポイントから送信できます。 + ------------------------------------------------- -------------- + | | |不透明（OPAQUE）データ（64）| | | + -------------------------------------------------- -------------- +図12：PINGペイロード形式フレームヘッダーに加えて、PINGフレームはペイロードに8オクテットの不透明なデータを含まなければなりません。送信者は、選択した任意の値を含めて、それらのオクテットを任意の方法で使用できます。 ACKフラグを含まないPINGフレームの受信者は、同じペイロードで、応答としてACKフラグが設定されたPINGフレームを送信する必要があります。 PING応答には、他のどのフレームよりも高い優先度を与える必要があります。 PINGフレームは、次のフラグを定義します。ACK（0x1）：設定されると、ビット0は、このPINGフレームがPING応答であることを示します。エンドポイントは、PING応答でこのフラグを設定する必要があります。エンドポイントは、このフラグを含むPINGフレームに応答してはなりません（MUSTNOT）。 PINGフレームは、個々のストリームに関連付けられていません。 PINGフレームが0x0以外のストリーム識別子フィールド値で受信された場合、受信者は接続エラーで応答する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;タイプPROTOCOL_ERRORのセクション5.4.1）。長さフィールド値が8以外のPINGフレームの受信は、タイプFRAME_SIZE_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POSTメソッドを使用して、オリジンサーバーがリクエストに含まれるエンティティを、Request-LineのRequest-URIで識別されるリソースの新しい下位として受け入れることをリクエストします。 POSTは、次の機能をカバーする統一メソッドを許可するように設計されています。-既存のリソースの注釈。 -掲示板、ニュースグループ、メーリングリスト、または同様の記事グループにメッセージを投稿する。 -フォームの送信結果などのデータブロックをデータ処理プロセスに提供する。 -追加操作によるデータベースの拡張。 POSTメソッドによって実行される実際の機能はサーバーによって決定され、通常はRequest-URIに依存します。投稿されたエンティティは、ファイルがそれを含むディレクトリに従属するのと同じように、そのURIに従属します。ニュース記事は、それが投稿されたニュースグループに従属するか、レコードがデータベースに従属します。 POSTメソッドによって実行されるアクションは、URIで識別できるリソースにならない場合があります。この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）であり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、ロケーションヘッダーを含む必要があります（を参照）。この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）である必要があり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、Locationヘッダー（「この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）である必要があり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、Locationヘッダー（「&lt;a href=&quot;#section-14.30&quot;&gt;セクション14.30&lt;/a&gt;）。このメソッドへの応答は、適切なCache-ControlまたはExpiresヘッダーフィールドが応答に含まれていない限り、キャッシュできません。ただし、303（その他を参照）応答を使用して、ユーザーエージェントにキャッシュ可能なリソースを取得するように指示できます。 POSTリクエストは、&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2に&lt;/a&gt;記載されているメッセージ送信要件に従う必要があります。セキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">POSTメソッドは、リソース自体の特定のセマンティクスに従って、ターゲットリソースがリクエストに含まれる表現を処理することをリクエストします。たとえば、POSTは（特に）次の機能に使用されます。o HTMLフォームに入力されたフィールドなどのデータブロックをデータ処理プロセスに提供します。 o掲示板、ニュースグループ、メーリングリスト、ブログ、または同様の記事グループにメッセージを投稿する。 oオリジンサーバーによってまだ識別されていない新しいリソースを作成します。 oリソースの既存の表現にデータを追加する。オリジンサーバーは、POSTリクエストの処理結果に応じて適切なステータスコードを選択することにより、応答セマンティクスを示します。この仕様で定義されているほとんどすべてのステータスコードは、POSTに対する応答で受信される可能性があります（例外は206（部分的なコンテンツ）、304（変更されていない）、および416（範囲が満たされていません）です）。 POSTリクエストを正常に処理した結果、1つ以上のリソースがオリジンサーバーで作成された場合、オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。&lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt;）と、新しいリソースを参照しながらリクエストのステータスを説明する表現。 POST要求への応答は、明示的な鮮度情報が含まれている場合にのみキャッシュできます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]のセクション4.2.1を&lt;/a&gt;参照）。ただし、POSTキャッシングは広く実装されていません。オリジンサーバーがクライアントがPOSTの結果を後のGETで再利用できる方法でキャッシュできるようにしたい場合、オリジンサーバーは結果とContent-Locationを含む200（OK）応答を送信できます（MAY）。 POSTの有効なリクエストURIと同じ値を持つヘッダーフィールド（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション3.1.4.2&lt;/a&gt;）。 POSTの処理結果が既存のリソースの表現と同等である場合、オリジンサーバーは、Locationフィールドに既存のリソースの識別子を含む303（その他を参照）応答を送信することにより、ユーザーエージェントをそのリソースにリダイレクトできます（MAY）。これには、ユーザーエージェントにリソース識別子を提供し、共有キャッシュをより適用しやすい方法で表現を転送するという利点がありますが、ユーザーエージェントが表現をまだキャッシュしていない場合は追加の要求が発生します。</target>
        </trans-unit>
        <trans-unit id="009ae6509d491675faf3db2c6925c60d8bb4838c" translate="yes" xml:space="preserve">
          <source>The PRIORITY frame (type=0x2) specifies the sender-advised priority
   of a stream (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  It can be sent in any stream state,
   including idle or closed streams. 

    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     Figure 8: PRIORITY Frame Payload

   The payload of a PRIORITY frame contains the following fields:

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.

   The PRIORITY frame does not define any flags.

   The PRIORITY frame always identifies a stream.  If a PRIORITY frame
   is received with a stream identifier of 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The PRIORITY frame can be sent on a stream in any state, though it
   cannot be sent between consecutive frames that comprise a single
   header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Note that this frame could arrive after
   processing or frame sending has completed, which would cause it to
   have no effect on the identified stream.  For a stream that is in the
   &quot;half-closed (remote)&quot; or &quot;closed&quot; state, this frame can only affect
   processing of the identified stream and its dependent streams; it
   does not affect frame transmission on that stream.

   The PRIORITY frame can be sent for a stream in the &quot;idle&quot; or &quot;closed&quot;
   state.  This allows for the reprioritization of a group of dependent
   streams by altering the priority of an unused or closed parent
   stream.

   A PRIORITY frame with a length other than 5 octets MUST be treated as
   a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">PRIORITYフレーム（type = 0x2）は、ストリームの送信者が通知する優先度を指定します（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）。アイドルストリームまたはクローズドストリームを含む、任意のストリーム状態で送信できます。 +-+ ----------------------------------------------- -------------- + | E |ストリームの依存関係（31）| +-+ ------------- + --------------------------------- -------------- + |重量（8）| +-+ ------------- +図8：PRIORITYフレームのペイロードPRIORITYフレームのペイロードには、次のフィールドが含まれます。E：ストリームの依存関係が排他的であることを示すシングルビットフラグ（を参照）&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）。ストリームの依存関係：このストリームが依存するストリームの31ビットのストリーム識別子（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3を&lt;/a&gt;参照）。重み：ストリームの優先順位の重みを表す符号なし8ビット整数（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3を&lt;/a&gt;参照））。値に1を加算して、1〜256の重みを取得します。PRIORITYフレームはフラグを定義しません。 PRIORITYフレームは、常にストリームを識別します。 PRIORITYフレームが0x0のストリーム識別子で受信された場合、受信者はタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）で応答する必要があります。 PRIORITYフレームは、単一のヘッダーブロックを構成する連続するフレーム間で送信することはできませんが、任意の状態のストリームで送信できます（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。このフレームは、処理またはフレーム送信の完了後に到着する可能性があるため、識別されたストリームに影響を与えないことに注意してください。 「ハーフクローズ（リモート）」または「クローズ」状態のストリームの場合、このフレームは、識別されたストリームとその依存ストリームの処理にのみ影響を与える可能性があります。そのストリームでのフレーム送信には影響しません。 PRIORITYフレームは、「アイドル」または「クローズ」状態のストリームに送信できます。これにより、未使用または閉じた親ストリームの優先度を変更することにより、依存ストリームのグループの優先順位を変更できます。 5オクテット以外の長さのPRIORITYフレームは、タイプFRAME_SIZE_ERRORのストリームエラー（&lt;a href=&quot;#section-5.4.2&quot;&gt;セクション5.4.2&lt;/a&gt;）として扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">PROPFINDメソッドは、リソースに内部メンバーがない場合、Request-URIで識別されるリソースで定義されたプロパティを取得します。または、リソースが内部メンバーURL。すべてのDAV準拠リソースは、PROPFINDメソッドとpropfind XML要素をサポートする必要があります（&lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt;）その要素で使用するために定義されたすべてのXML要素とともに。クライアントは、PROPFINDリクエストで「0」、「1」、または「無限大」の値を持つDepthヘッダーを送信する必要があります。サーバーはWebDAV準拠のリソースで「0」と「1」の深さ要求をサポートする必要があり、「無限」要求をサポートする必要があります（SHOULD）。実際には、この動作に関連するパフォーマンスとセキュリティの問題により、無制限のリクエストのサポートは無効になる場合があります。サーバーは、Depthヘッダーのないリクエストを、「Depth：infinity」ヘッダーが含まれているかのように処理する必要があります（SHOULD）。クライアントは、リクエストされている情報を記述するリクエストメソッドの本文で「propfind」XML要素を送信できます。次のことが可能です。o特定のプロパティ値を要求する、'prop'要素内で必要なプロパティに名前を付けることにより（ここではプロパティの順序はサーバーで無視される可能性があります）、oこの仕様で定義されたプロパティのプロパティ値を要求しますallprop '要素（' include '要素を' allprop 'と共に使用して、サーバーに、他の方法では返されない可能性がある追加のライブプロパティも含めるように指示できます）、oリソースで定義されているすべてのプロパティの名前のリストを要求します。 'propname'要素を使用する。クライアントは、リクエスト本文を送信しないことを選択できます。空のPROPFINDリクエストボディは、 'allprop'リクエストであるかのように処理する必要があります。 「allprop」がすべてのライブプロパティの値を返すわけではないことに注意してください。WebDAVサーバーは、ますます高価な計算された、または長いプロパティを持っています（[&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]および[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]）とすべてのプロパティをまだ返しません。代わりに、WebDAVクライアントは、propname要求を使用して、存在するライブプロパティを検出し、値を取得するときに名前付きプロパティを要求できます。他の場所で定義されたライブプロパティの場合、その定義は、そのライブプロパティが「allprop」リクエストで返されるかどうかを指定できます。すべてのサーバーは、さまざまなプロパティを取得する試みの結果を説明するマルチステータスXML要素を含む、コンテンツタイプtext / xmlまたはapplication / xmlの応答を返すことをサポートする必要があります。プロパティの取得中にエラーが発生した場合は、適切なエラー結果を応答に含める必要があります。存在しないプロパティの値を取得する要求はエラーであり、「応答」で注記する必要があります404（見つかりません）ステータス値を含むXML要素。したがって、コレクションリソースの「マルチステータス」XML要素には、コレクションの各メンバーURLの「応答」XML要素を、要求された深さまで含める必要があります。 WebDAVに準拠していないリソースの「応答」要素は含めないでください。各 'response'要素には、prop XML要素のプロパティが定義されているリソースのURLを含む 'href'要素を含める必要があります。コレクションリソースに対するPROPFINDの結果は、エントリの順序が重要ではないフラットリストとして返されます。リソースは特定の名前のプロパティに対して1つの値しか持つことができないため、プロパティはPROPFIND応答で1回しか表示されない場合があることに注意してください。プロパティはアクセス制御の対象となる場合があります。 'allprop'および 'propname'リクエストの場合、プリンシパルが特定のプロパティが存在するかどうかを知る権利を持っていない場合、そのプロパティは黙って応答から除外される場合があります。ほとんどのプロパティにはキャッシュ検証メカニズムがないため、一部のPROPFIND結果は注意してキャッシュできます。この方法は安全であり、べき等です（参照&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCHメソッドは、リクエスト本文で指定された命令を処理して、Request-URIで識別されるリソースで定義されたプロパティを設定または削除します。すべてのDAV準拠リソースは、PROPPATCHメソッドをサポートする必要があり、propertyupdate、set、およびXML要素を使用して指定された命令を処理する必要があります。もちろん、このメソッドでのディレクティブの実行は、アクセス制御の制約に従います。 DAV準拠のリソースは、任意のデッドプロパティの設定をサポートする必要があります（SHOULD）。 PROPPATCHメソッドの要求メッセージ本文には、propertyupdate XML要素が含まれている必要があります。サーバーは、PROPPATCH命令をドキュメントの順序で処理する必要があります（順序は無関係であるという通常の規則の例外）。命令はすべて実行されるか、何も実行されないかのいずれかでなければなりません。したがって、処理中にエラーが発生した場合、実行されたすべての命令を元に戻して、適切なエラー結果を返す必要があります。命令処理の詳細は、セクションのセットおよび削除命令の定義にあります。&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;および&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。サーバーがPROPPATCHリクエストのプロパティを変更しようとする場合（つまり、本文を処理する前に、リクエストが高レベルのエラーのために拒否されない場合）、&lt;a href=&quot;#section-9.2.1&quot;&gt;セクション9.2.1で&lt;/a&gt;説明されているように、応答はマルチステータス応答でなければなりません。。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等ですが、安全ではありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="601421813323ca4f0788af9d830329726cc8945b" translate="yes" xml:space="preserve">
          <source>The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint
   in advance of streams the sender intends to initiate.  The
   PUSH_PROMISE frame includes the unsigned 31-bit identifier of the
   stream the endpoint plans to create along with a set of headers that
   provide additional context for the stream.  &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; contains a
   thorough description of the use of PUSH_PROMISE frames.

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                  Figure 11: PUSH_PROMISE Payload Format

   The PUSH_PROMISE frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   R: A single reserved bit.

   Promised Stream ID:  An unsigned 31-bit integer that identifies the
      stream that is reserved by the PUSH_PROMISE.  The promised stream
      identifier MUST be a valid choice for the next stream sent by the
      sender (see &quot;new stream identifier&quot; in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)
      containing request header fields.

   Padding:  Padding octets. 

   The PUSH_PROMISE frame defines the following flags:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A PUSH_PROMISE frame without the END_HEADERS flag set MUST be
      followed by a CONTINUATION frame for the same stream.  A receiver
      MUST treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
   is in either the &quot;open&quot; or &quot;half-closed (remote)&quot; state.  The stream
   identifier of a PUSH_PROMISE frame indicates the stream it is
   associated with.  If the stream identifier field specifies the value
   0x0, a recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type PROTOCOL_ERROR.

   Promised streams are not required to be used in the order they are
   promised.  The PUSH_PROMISE only reserves stream identifiers for
   later use.

   PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of
   the peer endpoint is set to 0.  An endpoint that has set this setting
   and has received acknowledgement MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   Recipients of PUSH_PROMISE frames can choose to reject promised
   streams by returning a RST_STREAM referencing the promised stream
   identifier back to the sender of the PUSH_PROMISE.

   A PUSH_PROMISE frame modifies the connection state in two ways.
   First, the inclusion of a header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) potentially
   modifies the state maintained for header compression.  Second,
   PUSH_PROMISE also reserves a stream for later use, causing the
   promised stream to enter the &quot;reserved&quot; state.  A sender MUST NOT
   send a PUSH_PROMISE on a stream unless that stream is either &quot;open&quot;
   or &quot;half-closed (remote)&quot;; the sender MUST ensure that the promised
   stream is a valid choice for a new stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)
   (that is, the promised stream MUST be in the &quot;idle&quot; state). 

   Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame
   causes the stream state to become indeterminate.  A receiver MUST
   treat the receipt of a PUSH_PROMISE on a stream that is neither
   &quot;open&quot; nor &quot;half-closed (local)&quot; as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  However, an endpoint that
   has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE
   frames that might have been created before the RST_STREAM frame is
   received and processed.

   A receiver MUST treat the receipt of a PUSH_PROMISE that promises an
   illegal stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that an illegal stream
   identifier is an identifier for a stream that is not currently in the
   &quot;idle&quot; state.

   The PUSH_PROMISE frame can include padding.  Padding fields and flags
   are identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).</source>
          <target state="translated">PUSH_PROMISEフレーム（type = 0x5）は、送信者が開始しようとしているストリームの前にピアエンドポイントに通知するために使用されます。 PUSH_PROMISEフレームには、エンドポイントが作成する予定のストリームの符号なし31ビット識別子と、ストリームに追加のコンテキストを提供するヘッダーのセットが含まれます。&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;PUSH_PROMISEフレームの使用に関する詳細な説明が含まれています。 + --------------- + |パッドの長さ？ （8）| +-+ ------------- + --------------------------------- -------------- + | R |約束されたストリームID（31）| +-+ ----------------------------- + ----------------- -------------- + |ヘッダーブロックフラグメント（*）+ ------------------------------------------- -------------------- + |パディング（*）+ --------------------------------------------- ------------------ +図11：PUSH_PROMISEペイロード形式PUSH_PROMISEフレームペイロードには、次のフィールドがあります。パッドの長さ：フレームのパディングの長さを含む8ビットのフィールドオクテットの単位。このフィールドは、PADDEDフラグが設定されている場合にのみ表示されます。 R：単一の予約済みビット。約束されたストリームID：PUSH_PROMISEによって予約されているストリームを識別する符号なし31ビット整数。約束されたストリーム識別子は、送信者によって送信される次のストリームの有効な選択である必要があります（の「新しいストリーム識別子」を参照）。&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）。ヘッダーブロックフラグメント：リクエストヘッダーフィールドを含むヘッダーブロックフラグメント（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）。パディング：オクテットのパディング。 PUSH_PROMISEフレームは、次のフラグを定義します。END_HEADERS（0x4）：設定されると、ビット2は、このフレームにヘッダーブロック全体が含まれ（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）、その後にCONTINUATIONフレームが続かないことを示します。 END_HEADERSフラグが設定されていないPUSH_PROMISEフレームの後には、同じストリームのCONTINUATIONフレームが続く必要があります。受信者は、他のタイプのフレームまたは別のストリーム上のフレームの受信を接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。 PADDED（0x8）：設定されている場合、ビット3は、PadLengthフィールドとそれが記述するすべてのパディングが存在することを示します。 PUSH_PROMISEフレームは、「オープン」または「ハーフクローズ（リモート）」状態のピア開始ストリームでのみ送信する必要があります。 PUSH_PROMISEフレームのストリーム識別子は、関連付けられているストリームを示します。ストリーム識別子フィールドで値0x0が指定されている場合、受信者は接続エラーで応答する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。約束されたストリームは、約束された順序で使用する必要はありません。 PUSH_PROMISEは、後で使用するためにストリーム識別子のみを予約します。ピアエンドポイントのSETTINGS_ENABLE_PUSH設定が0に設定されている場合、PUSH_PROMISEを送信してはなりません。この設定を設定して確認応答を受信したエンドポイントは、PUSH_PROMISEフレームの受信をタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として処理する必要があります。。 PUSH_PROMISEフレームの受信者は、約束されたストリーム識別子を参照するRST_STREAMをPUSH_PROMISEの送信者に返すことにより、約束されたストリームを拒否することを選択できます。 PUSH_PROMISEフレームは、2つの方法で接続状態を変更します。まず、ヘッダーブロックを含める（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）ヘッダー圧縮用に維持されている状態を変更する可能性があります。次に、PUSH_PROMISEは後で使用するためにストリームを予約し、約束されたストリームを「予約済み」状態にします。送信者は、ストリームが「オープン」または「ハーフクローズ（リモート）」でない限り、ストリームでPUSH_PROMISEを送信してはなりません。送信者は、約束されたストリームが新しいストリーム識別子の有効な選択であることを確認する必要があります（&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）（つまり、約束されたストリームは「アイドル」状態でなければなりません）。 PUSH_PROMISEはストリームを予約するため、PUSH_PROMISEフレームを無視すると、ストリームの状態が不確定になります。受信者は、「オープン」でも「ハーフクローズ（ローカル）」でもないストリームでのPUSH_PROMISEの受信を、接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。ただし、関連付けられたストリームでRST_STREAMを送信したエンドポイントは、RST_STREAMフレームが受信および処理される前に作成された可能性のあるPUSH_PROMISEフレームを処理する必要があります。受信者は、不正なストリーム識別子（&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）を約束するPUSH_PROMISEの受信を、タイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として処理する必要があります。不正なストリーム識別子は、現在「アイドル」状態にないストリームの識別子であることに注意してください。 PUSH_PROMISEフレームにはパディングを含めることができます。パディングフィールドとフラグは、DATAフレーム（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）に定義されているものと同じです。</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUTメソッドは、囲まれたエンティティが指定されたRequest-URIに格納されることを要求します。 Request-URIが既存のリソースを参照している場合、囲まれたエンティティは、起点サーバーにあるエンティティの変更バージョンと見なされるべきです（SHOULD）。 Request-URIが既存のリソースを指さず、そのURIが要求元のユーザーエージェントによって新しいリソースとして定義できる場合、オリジンサーバーはそのURIでリソースを作成できます。新しいリソースが作成された場合、オリジンサーバーは201（Created）応答を介してユーザーエージェントに通知する必要があります。既存のリソースが変更された場合、200（OK）または204（No Content）応答コードのいずれかを送信して、リクエストが正常に完了したことを示す必要があります。 Request-URIでリソースを作成または変更できなかった場合、問題の性質を反映する適切なエラー応答を与える必要があります。エンティティの受信者は、理解または実装していないContent- *（Content-Rangeなど）ヘッダーを無視してはならず（MUST）、そのような場合は501（Not Implemented）応答を返さなければなりません（MUST）。リクエストがキャッシュを通過し、Request-URIが現在キャッシュされている1つ以上のエンティティを識別する場合、それらのエントリは古いものとして扱われる必要があります（SHOULD）。このメソッドへの応答はキャッシュできません。 POST要求とPUT要求の基本的な違いは、Request-URIの異なる意味に反映されています。 POSTリクエストのURIは、囲まれたエンティティを処理するリソースを識別します。そのリソースは、データを受け入れるプロセス、他のプロトコルへのゲートウェイ、または注釈を受け入れる個別のエンティティである可能性があります。対照的に、PUTリクエストのURIは、リクエストに含まれるエンティティを識別します。ユーザーエージェントは意図されているURIを認識しており、サーバーは他のリソースへのリクエストの適用を試みてはいけません。サーバーが要求を別のURIに適用することを望む場合、サーバーは301（永久に移動）応答を送信する必要があります。次に、ユーザーエージェントは、リクエストをリダイレクトするかどうかに関して独自の決定を行うことができます。単一のリソースは、多くの異なるURIによって識別される場合があります。たとえば、記事には、特定の各バージョンを識別するURIとは別の「現在のバージョン」を識別するためのURIがある場合があります。この場合、一般的なURIに対するPUT要求により、他のいくつかのURIがオリジンサーバーによって定義される可能性があります。 HTTP / 1。1は、PUTメソッドがオリジンサーバーの状態にどのように影響するかを定義していません。 PUTリクエストは、で設定されたメッセージ送信要件に従う必要があります&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;。特定のエンティティヘッダーに特に指定されていない限り、PUTリクエストのエンティティヘッダーは、PUTによって作成または変更されたリソースに適用する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUTメソッドは、ターゲットリソースの状態を作成するか、要求メッセージのペイロードで囲まれた表現で定義された状態に置き換えることを要求します。特定の表現のPUTが成功した場合、その同じターゲットリソースで後続のGETを実行すると、同等の表現が200（OK）応答で送信されることになります。ただし、後続のGETを受信する前に、ターゲットリソースが他のユーザーエージェントによって並行して処理されたり、元のサーバーによる動的処理の対象となる可能性があるため、このような状態変化が観察可能である保証はありません。成功した応答は、元のサーバーによる処理時にユーザーエージェントの意図が達成されたことを意味します。ターゲットリソースに現在の表現がなく、PUTがそれを正常に作成した場合、オリジンサーバーは201（Created）応答を送信してユーザーエージェントに通知する必要があります。ターゲットリソースに現在の表現があり、その表現が囲まれた表現の状態に従って正常に変更された場合、オリジンサーバーは200（OK）または204（No Content）応答のいずれかを送信して、正常に完了したことを示す必要があります。リクエスト。オリジンサーバーは、PUTリクエストで受信した認識されないヘッダーフィールドを無視する必要があります（つまり、リソース状態の一部として保存しないでください）。オリジンサーバーは、PUT表現が、PUTによって変更できない、または変更されないターゲットリソースに対するサーバーの制約と整合していることを確認する必要があります（SHOULD）。オリジンサーバーがURIに関連する内部構成情報を使用してGET応答の表現メタデータの値を設定する場合、これは特に重要です。 PUT表現がターゲットリソースと矛盾している場合、オリジンサーバーは、表現を変換するかリソース構成を変更してそれらを一貫させるか、表現が不適切である理由を説明する十分な情報を含む適切なエラーメッセージで応答する必要があります。 409（競合）または415（サポートされていないメディアタイプ）ステータスコードが推奨されますが、後者はContent-Type値の制約に固有のものです。たとえば、ターゲットリソースが常に &quot;text / html&quot;のコンテンツタイプを持つように構成されている場合そして、PUTで​​ある表現は &quot;image / jpeg&quot;のContent-Typeを持ち、オリジンサーバーは次のいずれかを実行する必要があります。新しいメディアタイプを反映するようにターゲットリソースを再構成します。 b。新しいリソース状態として保存する前に、PUT表現をリソースの形式と一致する形式に変換します。または、c。ターゲットリソースが「text / html」に制限されていることを示す415（Unsupported Media Type）応答でリクエストを拒否します。おそらく、新しい表現の適切なターゲットとなる別のリソースへのリンクが含まれます。 HTTPは、PUTメソッドがオリジンサーバーの状態にどのように影響するかを、ユーザーエージェント要求の意図とオリジンサーバーの応答のセマンティクスを超えて正確に定義していません。HTTPを介して提供されるインターフェースを超えて、その言葉の意味でのリソースが何であるかを定義しません。リソースの状態が「格納」される方法や、リソースの状態の変化の結果としてそのようなストレージがどのように変化するかも定義されていません。また、オリジンサーバーがリソースの状態を表現に変換する方法も定義していません。一般的に言って、リソースインターフェースの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（リソースインターフェイスの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（リソースインターフェイスの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）（ETagやLast-Modifiedフィールドなど）。リクエストの表現データが本体に変換を適用せずに保存された場合（つまり、リソースの新しい表現データが、 PUTリクエスト）とバリデーターフィールドの値は新しい表現を反映します。この要件により、ユーザーエージェントは、PUTの結果としてメモリ内にあるリプレゼンテーションボディが最新のままであるため、オリジンサーバーから再度取得する必要がなく、新しいバリデータが応答で受信されたことを知ることができます。偶発的な上書きを防止するために、将来の条件付きリクエストに使用できます（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）。 POSTメソッドとPUTメソッドの基本的な違いは、囲まれた表現の異なる意図によって強調されています。 POSTリクエストのターゲットリソースは、リソース自体のセマンティクスに従って囲まれた表現を処理するためのものですが、PUTリクエストの囲まれた表現は、ターゲットリソースの状態を置き換えるものとして定義されます。したがって、正確な効果がオリジンサーバーによってのみ認識されている場合でも、PUTの意図はべき等であり、仲介者に可視です。 PUTリクエストの適切な解釈は、ユーザーエージェントがどのターゲットリソースが必要かを知っていることを前提としています。クライアントに代わって適切なURIを選択するサービスは、状態変更要求を受け取った後、PUTで​​はなくPOSTメソッドを使用して実装する必要があります（SHOULD）。オリジンサーバーが要求されたPUT状態をターゲットリソースに変更せず、代わりに、リソースが別のURIに移動された場合など、別のリソースに適用したい場合、オリジンサーバーは適切な3xxを送信する必要があります。 （リダイレクト）応答;次に、ユーザーエージェントは、リクエストをリダイレクトするかどうかに関して独自の決定を行うことができます。ターゲットリソースに適用されたPUTリクエストは、他のリソースに悪影響を与える可能性があります。たとえば、記事には、特定の各バージョンを識別するURI（ある時点で現在のバージョンのリソースと同じ状態を共有するさまざまなリソース）とは別の「現在のバージョン」（リソース）を識別するためのURIがある場合があります。 「現在のバージョン」で成功したPUTリクエストしたがって、URIは、ターゲットリソースの状態を変更することに加えて、新しいバージョンのリソースを作成し、関連するリソース間にリンクを追加する可能性があります。特定のターゲットリソースでPUTを許可するオリジンサーバーは、Content-Rangeヘッダーフィールドを含むPUTリクエストに400（Bad Request）応答を送信する必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233]のセクション4.2&lt;/a&gt;）。ペイロードは、誤って完全な表現としてPUTされた部分的なコンテンツである可能性が高いため。部分的なコンテンツの更新は、より大きなリソースの一部と重複する状態を持つ個別に識別されたリソースをターゲットにするか、部分的な更新用に特別に定義された別の方法（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]で定義されたPATCHメソッドなど）を使用することで可能です。 PUTメソッドへの応答はキャッシュできません。成功したPUT要求が、有効な要求URIに対する1つ以上の格納された応答を持つキャッシュを通過する場合、それらの格納された応答は無効になります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]のセクション4.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma general-headerフィールドは、要求/応答チェーンに沿って任意の受信者に適用される可能性がある実装固有のディレクティブを含めるために使用されます。すべてのプラグマディレクティブは、プロトコルの観点からオプションの動作を指定します。ただし、一部のシステムでは、動作がディレクティブと一致している必要がある場合があります。プラグマ= &quot;プラグマ&quot; &quot;：&quot; 1＃pragma-directiveプラグマディレクティブ= &quot;no-cache&quot; | extension-pragma extension-pragma = token [&quot;=&quot;（token | quoted-string）] no-cacheディレクティブがリクエストメッセージに存在する場合、アプリケーションは、キャッシュされたコピーがある場合でも、リクエストをオリジンサーバーに転送する必要があります（SHOULD）。要求されているものの。 このプラグマディレクティブは、no-cache cache-directiveと同じセマンティクスを持っています（ &lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9を参照）。&lt;/a&gt;）、HTTP / 1.0との下位互換性のためにここで定義されています。 HTTP / 1.1に準拠していないことがわかっているサーバーにキャッシュなしのリクエストが送信される場合、クライアントは両方のヘッダーフィールドを含める必要があります（SHOULD）。ディレクティブは要求/応答チェーンに沿ったすべての受信者に適用できるため、プラグマディレクティブは、そのアプリケーションにとっての重要性に関係なく、プロキシまたはゲートウェイアプリケーションによってパススルーされる必要があります。特定の受信者にプラグマを指定することはできません。ただし、受信者に関連しないプラグマディレクティブは、その受信者によって無視される必要があります（SHOULD）。 HTTP / 1.1キャッシュは、「プラグマ：no-cache」を、クライアントが「Cache-Control：no-cache」を送信したかのように扱う必要があります（SHOULD）。新しいプラグマディレクティブはHTTPで定義されません。注：「プラグマ：応答ヘッダーフィールドとしてのno-cacheは実際には指定されていません。応答内の「Cache-Control：no-cache」の信頼できる代替にはなりません。</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">Proxy-Authenticate応答ヘッダーフィールドは、407（Proxy Authentication Required）応答の一部として含まれている必要があります。フィールド値は、このリクエストURIのプロキシに適用可能な認証スキームとパラメータを示すチャレンジで構成されます。 Proxy-Authenticate = &quot;Proxy-Authenticate&quot; &quot;：&quot; 1＃challenge HTTPアクセス認証プロセスについては、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。 WWW-Authenticateとは異なり、Proxy-Authenticateヘッダーフィールドは現在の接続にのみ適用され、ダウンストリームクライアントに渡すべきではありません（SHOULD NOT）。ただし、中間プロキシは、ダウンストリームクライアントに要求することで独自の資格情報を取得する必要がある場合があります。これは、プロキシがProxy-Authenticateヘッダーフィールドを転送しているように見える場合があります。</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorizationリクエストヘッダーフィールドを使用すると、認証を必要とするプロキシに対してクライアント（またはそのユーザー）を識別できます。 Proxy-Authorizationフィールドの値は、要求されているリソースのプロキシまたはレルム、あるいはその両方のユーザーエージェントの認証情報を含む資格情報で構成されています。 Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;：&quot;資格情報HTTPアクセス認証プロセスについては、「HTTP認証：基本認証とダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。承認とは異なり、Proxy-Authorizationヘッダーフィールドは、Proxy-Authenticateフィールドを使用して認証を要求した次の送信プロキシにのみ適用されます。複数のプロキシがチェーンで使用されている場合、Proxy-Authorizationヘッダーフィールドは、資格情報を受信することを期待していた最初の送信プロキシによって消費されます。プロキシーが所定の要求を協調的に認証するメカニズムである場合、プロキシーは資格情報をクライアント要求から次のプロキシーに中継することができます（MAY）。</target>
        </trans-unit>
        <trans-unit id="3fb25443f99d4a6f4c3661e5265360468e08d470" translate="yes" xml:space="preserve">
          <source>The RST_STREAM frame (type=0x3) allows for immediate termination of a
   stream.  RST_STREAM is sent to request cancellation of a stream or to
   indicate that an error condition has occurred.

    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    Figure 9: RST_STREAM Frame Payload

   The RST_STREAM frame contains a single unsigned, 32-bit integer
   identifying the error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).  The error code indicates why
   the stream is being terminated.

   The RST_STREAM frame does not define any flags.

   The RST_STREAM frame fully terminates the referenced stream and
   causes it to enter the &quot;closed&quot; state.  After receiving a RST_STREAM
   on a stream, the receiver MUST NOT send additional frames for that
   stream, with the exception of PRIORITY.  However, after sending the
   RST_STREAM, the sending endpoint MUST be prepared to receive and
   process additional frames sent on the stream that might have been
   sent by the peer prior to the arrival of the RST_STREAM.

   RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM
   frame is received with a stream identifier of 0x0, the recipient MUST
   treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   RST_STREAM frames MUST NOT be sent for a stream in the &quot;idle&quot; state.
   If a RST_STREAM frame identifying an idle stream is received, the
   recipient MUST treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A RST_STREAM frame with a length other than 4 octets MUST be treated
   as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">RST_STREAMフレーム（type = 0x3）を使用すると、ストリームを即座に終了できます。 RST_STREAMは、ストリームのキャンセルを要求するため、またはエラー状態が発生したことを示すために送信されます。 + ------------------------------------------------- -------------- + |エラーコード（32）| + -------------------------------------------------- -------------- +図9：RST_STREAMフレームのペイロードRST_STREAMフレームには、エラーコードを識別する単一の符号なし32ビット整数が含まれています（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）。エラーコードは、ストリームが終了している理由を示しています。 RST_STREAMフレームはフラグを定義しません。 RST_STREAMフレームは、参照されたストリームを完全に終了し、「閉じた」状態にします。ストリームでRST_STREAMを受信した後、受信者はPRIORITYを除いて、そのストリームに追加のフレームを送信してはなりません（MUSTNOT）。ただし、RST_STREAMを送信した後、送信エンドポイントは、RST_STREAMの到着前にピアによって送信された可能性のあるストリームで送信された追加のフレームを受信して​​処理する準備をしなければなりません。 RST_STREAMフレームはストリームに関連付けられている必要があります。 RST_STREAMフレームが0x0のストリーム識別子で受信された場合、受信者はこれを接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。 RST_STREAMフレームは、「アイドル」状態のストリームに送信してはなりません（MUSTNOT）。アイドルストリームを識別するRST_STREAMフレームが受信された場合、受信者はこれをタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱わなければなりません（MUST ）。 4オクテット以外の長さのRST_STREAMフレームは、タイプFRAME_SIZE_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">クライアントは、Referer [sic] request-headerフィールドを使用して、サーバーの利益のために、Request-URIの取得元であるリソースのアドレス（URI）を指定できます（ヘッダーフィールドのスペルが間違っていますが、「referrer」）。サーバーは、Refererリクエストヘッダーを使用して、関心のあるリソースへのバックリンク、ロギング、最適化されたキャッシュなどのリストを生成できます。また、メンテナンスのために古いリンクやタイプミスしたリンクを追跡できます。ユーザーキーボードからの入力など、独自のURIを持たないソースからRequest-URIを取得した場合は、Refererフィールドを送信してはなりません（MUST NOT）。 Referer = &quot;Referer&quot; &quot;：&quot;（absoluteURI | relativeURI）例：リファラー：&lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/hypertext/DataSources/Overview.html フィールド値が相対URIの場合は、Request-URIを基準にして解釈する必要があります（SHOULD）。URIにフラグメントを含めることはできません。セキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください 。</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Request-Lineはメソッドトークンで始まり、Request-URIとプロトコルバージョンが続き、CRLFで終わる。要素はSP文字で区切られる。最後のCRLFシーケンス以外では、CRやLFは許されない。Request-Line=Method SP Request-URI SP HTTP-Version CRLF</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URIはUniform Resource Identifier（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、リクエストを適用するリソースを識別します。 Request-URI = &quot;*&quot; |絶対URI | abs_path |権限Request-URIの4つのオプションは、要求の性質によって異なります。アスタリスク「*」は、リクエストが特定のリソースではなくサーバー自体に適用されることを意味し、使用されるメソッドが必ずしもリソースに適用されない場合にのみ許可されます。 1つの例はOPTIONS * HTTP / 1.1です。absoluteURI形式は、リクエストがプロキシに対して行われている場合に必須です。プロキシは、要求を転送するか、有効なキャッシュからサービスを提供し、応答を返すように要求されます。プロキシは、リクエストを別のプロキシに転送することも、absoluteURIで指定されたサーバーに直接転送することもできます。リクエストループを回避するために、プロキシは、エイリアス、ローカルバリエーション、および数値IPアドレスを含む、そのサーバー名のすべてを認識できる必要があります。 Request-Lineの例：GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1今後のバージョンのHTTPですべてのリクエストのabsoluteURIへの移行を可能にするため、すべてのHTTP / 1.1サーバーはリクエストのabsoluteURIフォームを受け入れる必要があります。 HTTP / 1.1クライアントは、プロキシへのリクエストでのみそれらを生成します。権限フォームは、CONNECTメソッドでのみ使用されます（&lt;a href=&quot;#section-9.9&quot;&gt;セクション9.9&lt;/a&gt;）。 Request-URIの最も一般的な形式は、オリジンサーバーまたはゲートウェイ上のリソースを識別するために使用される形式です。この場合、URIの絶対パスを送信する必要があります（&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション3.2.1を&lt;/a&gt;参照）。、abs_path）をリクエストURIとして、URIのネットワークロケーション（権限）をホストヘッダーフィールドで送信する必要があります。たとえば、上記のリソースをオリジンサーバーから直接取得するクライアントは、ホスト &quot;www.w3.org&quot;のポート80へのTCP接続を作成し、次の行を送信します。GET /pub/WWW/TheProject.html HTTP / 1.1ホスト：www.w3.orgとそれに続くリクエストの残り。絶対パスを空にすることはできません。元のURIに何も存在しない場合は、 &quot;/&quot;（サーバールート）として指定する必要があります。 Request-URIは、&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1で&lt;/a&gt;指定された形式で送信されます。 Request-URIが「％HEX HEX」エンコーディング[ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]、オリジンサーバーは、リクエストを適切に解釈するためにリクエストURIをデコードする必要があります。サーバーは、無効なリクエストURIに適切なステータスコードで応答する必要があります（SHOULD）。透過プロキシは、次の受信サーバーに転送するときに、受信したRequest-URIの「abs_path」の部分を書き換えてはなりません（ただし、上記のnull abs_pathを「/」に置き換える場合を除く）。注：「リライトなし」ルールは、オリジンサーバーが予約された目的で予約されていないURI文字を不適切に使用している場合に、プロキシがリクエストの意味を変更しないようにします。実装者は、HTTP / 1.1より前のプロキシの一部がRequest-URIを書き換えることがわかっていることを認識しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After応答ヘッダーフィールドは、503(Service Unavailable)応答と一緒に使用して、リクエストするクライアントがサービスを利用できないことが予想される時間を示すことができる。このフィールドは、リダイレクトされたリクエストを発行する前にユーザーエージェントが 要求される最小の待ち時間を示すために、3xx(Redirection)応答と一緒に使用してもよい[MAY]。このフィールドの値は、HTTPの日付か、応答の時間の後の秒数(10進数)の整数である。Retry-After=&quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds)2つの使用例があります。Fri,31 Dec 1999 23:59:59 GMT Retry-After.120 後者の例では、遅延は2分です。</target>
        </trans-unit>
        <trans-unit id="818c17cd76fd87b90da17d6a18fd82be94517b9c" translate="yes" xml:space="preserve">
          <source>The SETTINGS frame (type=0x4) conveys configuration parameters that
   affect how endpoints communicate, such as preferences and constraints
   on peer behavior.  The SETTINGS frame is also used to acknowledge the
   receipt of those parameters.  Individually, a SETTINGS parameter can
   also be referred to as a &quot;setting&quot;. 

   SETTINGS parameters are not negotiated; they describe characteristics
   of the sending peer, which are used by the receiving peer.  Different
   values for the same parameter can be advertised by each peer.  For
   example, a client might set a high initial flow-control window,
   whereas a server might set a lower value to conserve resources.

   A SETTINGS frame MUST be sent by both endpoints at the start of a
   connection and MAY be sent at any other time by either endpoint over
   the lifetime of the connection.  Implementations MUST support all of
   the parameters defined by this specification.

   Each parameter in a SETTINGS frame replaces any existing value for
   that parameter.  Parameters are processed in the order in which they
   appear, and a receiver of a SETTINGS frame does not need to maintain
   any state other than the current value of its parameters.  Therefore,
   the value of a SETTINGS parameter is the last value that is seen by a
   receiver.

   SETTINGS parameters are acknowledged by the receiving peer.  To
   enable this, the SETTINGS frame defines the following flag:

   ACK (0x1):  When set, bit 0 indicates that this frame acknowledges
      receipt and application of the peer's SETTINGS frame.  When this
      bit is set, the payload of the SETTINGS frame MUST be empty.
      Receipt of a SETTINGS frame with the ACK flag set and a length
      field value other than 0 MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.  For more information,
      see &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt; (&quot;Settings Synchronization&quot;).

   SETTINGS frames always apply to a connection, never a single stream.
   The stream identifier for a SETTINGS frame MUST be zero (0x0).  If an
   endpoint receives a SETTINGS frame whose stream identifier field is
   anything other than 0x0, the endpoint MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The SETTINGS frame affects connection state.  A badly formed or
   incomplete SETTINGS frame MUST be treated as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   A SETTINGS frame with a length other than a multiple of 6 octets MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">SETTINGSフレーム（type = 0x4）は、ピアの動作の設定や制約など、エンドポイントの通信方法に影響を与える構成パラメーターを伝達します。 SETTINGSフレームは、これらのパラメーターの受信を確認するためにも使用されます。個別に、SETTINGSパラメーターは「設定」と呼ばれることもあります。 SETTINGSパラメーターはネゴシエートされません。これらは、受信ピアによって使用される送信ピアの特性を記述します。同じパラメータの異なる値を各ピアでアドバタイズできます。たとえば、クライアントは高い初期フロー制御ウィンドウを設定し、サーバーはリソースを節約するために低い値を設定する場合があります。 SETTINGSフレームは、接続の開始時に両方のエンドポイントによって送信される必要があり、接続の存続期間中、いずれかのエンドポイントによって他の任意の時点で送信される場合があります。実装は、この仕様で定義されているすべてのパラメーターをサポートする必要があります。 SETTINGSフレームの各パラメーターは、そのパラメーターの既存の値を置き換えます。パラメータは表示された順序で処理され、SETTINGSフレームの受信者は、パラメータの現在の値以外の状態を維持する必要はありません。したがって、SETTINGSパラメーターの値は、受信者に表示される最後の値です。 SETTINGSパラメータは、受信ピアによって確認応答されます。これを有効にするために、SETTINGSフレームは次のフラグを定義します。ACK（0x1）：設定されると、ビット0は、このフレームがピアのSETTINGSフレームの受信と適用を確認することを示します。このビットが設定されている場合、SETTINGSフレームのペイロードは空でなければなりません。ACKフラグが設定され、長さフィールドの値が0以外のSETTINGSフレームを受信すると、接続エラーとして扱われる必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;タイプFRAME_SIZE_ERRORのセクション5.4.1）。詳細については、&lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3項&lt;/a&gt;（「設定の同期」）を参照してください。SETTINGSフレームは常に接続に適用され、単一のストリームには適用されません。SETTINGSフレームのストリーム識別子はゼロ（0x0）でなければなりません。エンドポイントがストリーム識別子フィールドが0x0以外のSETTINGSフレームを受信した場合、エンドポイントはタイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）で応答する必要があります。SETTINGSフレームは、接続状態に影響します。不正に形成された、または不完全なSETTINGSフレームは、タイプPROTOCOL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱われる必要があります。6オクテットの倍数以外の長さのSETTINGSフレームは、接続エラーとして扱われる必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプFRAME_SIZE_ERROR。</target>
        </trans-unit>
        <trans-unit id="9f8174334dfb42409bd14d344357a61e0522761d" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Dest HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Dest HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="089fba56f3ba935817b0ee0ba0d50c6c7250a452" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Mode HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Mode HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="0922dedc70e7039f73de5afb1791c6af1cadc728" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Site HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Site HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="8e9ebb888b481c6982054f06f45605ddc268b5db" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-User HTTP Request Header</source>
          <target state="translated">Sec-Fetch-User HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">サーバーの応答ヘッダーフィールドには、要求を処理するためにオリジンサーバーが使用するソフトウェアに関する情報が含まれています。このフィールドには、複数の製品トークン（&lt;a href=&quot;#section-3.8&quot;&gt;セクション3.8&lt;/a&gt;）およびサーバーと重要なサブ製品を識別するコメントを含めることができます。製品トークンは、アプリケーションを識別するために重要度の高い順にリストされています。 Server = &quot;Server&quot; &quot;：&quot; 1 *（product | comment）例：サーバー：CERN / 3.0 libwww / 2.17応答がプロキシを介して転送されている場合、プロキシアプリケーションはサーバーの応答ヘッダーを変更してはなりません（MUST NOT）。代わりに、Viaフィールドを含める必要があります（&lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt;を参照）。）。注：サーバーの特定のソフトウェアバージョンを明らかにすると、サーバーマシンがセキュリティホールを含むことがわかっているソフトウェアに対する攻撃に対してより脆弱になる可能性があります。サーバーの実装者は、このフィールドを構成可能なオプションにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code要素は、要求を理解して満足する試みの3桁の整数の結果コードです。これらのコードは&lt;a href=&quot;#section-10&quot;&gt;セクション10で&lt;/a&gt;完全に定義されています。 Reason-Phraseは、Status-Codeの短いテキストによる説明を提供することを目的としています。 Status-Codeはオートマトンによる使用を意図しており、Reason-Phraseは人間のユーザーを対象としています。クライアントは、Reason-Phraseを調べたり表示したりする必要はありません。ステータスコードの最初の桁は、応答のクラスを定義します。下2桁には分類の役割はありません。最初の桁には5つの値があります。-1xx：情報-要求を受信し、プロセスを続行します-2xx：成功-アクションは正常に受信、理解、および受け入れられました-3xx：リダイレクト-要求を完了するには、さらにアクションを実行する必要があります-4xx：クライアントエラー-リクエストに不正な構文が含まれているか、実行できない-5xx：サーバーエラー-サーバーは明らかに有効なリクエストを実行できませんでしたHTTP / 1.1に定義された数値ステータスコードの個々の値、および対応する理由フレーズのサンプルセットを以下に示します。ここに記載されている理由フレーズは推奨事項にすぎません。プロトコルに影響を与えることなく、ローカルの同等のものに置き換えることができます。ステータスコード= &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;セクション10.1.1&lt;/a&gt;：続行| &quot;101&quot;; &lt;a href=&quot;#section-10.1.2&quot;&gt;セクション10.1.2&lt;/a&gt;：プロトコルの切り替え| &quot;200&quot;; &lt;a href=&quot;#section-10.2.1&quot;&gt;セクション10.2.1&lt;/a&gt;：OK | &quot;201&quot;; &lt;a href=&quot;#section-10.2.2&quot;&gt;セクション10.2.2&lt;/a&gt;：作成| &quot;202&quot;; &lt;a href=&quot;#section-10.2.3&quot;&gt;セクション10.2.3&lt;/a&gt;：承認済み| &quot;203&quot;; &lt;a href=&quot;#section-10.2.4&quot;&gt;セクション10.2.4&lt;/a&gt;：信頼できない情報| &quot;204&quot;; &lt;a href=&quot;#section-10.2.5&quot;&gt;セクション10.2.5&lt;/a&gt;：コンテンツなし| &quot;205&quot;; &lt;a href=&quot;#section-10.2.6&quot;&gt;セクション10.2.6&lt;/a&gt;：コンテンツのリセット| &quot;206&quot;; &lt;a href=&quot;#section-10.2.7&quot;&gt;セクション10.2.7&lt;/a&gt;：部分的なコンテンツ| &quot;300&quot;; &lt;a href=&quot;#section-10.3.1&quot;&gt;セクション10.3.1&lt;/a&gt;：複数の選択肢| &quot;301&quot;; &lt;a href=&quot;#section-10.3.2&quot;&gt;セクション10.3&lt;/a&gt;2 ：永久に移動しました| &quot;302&quot;;&lt;a href=&quot;#section-10.3.3&quot;&gt;セクション10.3.3&lt;/a&gt;：見つかりました| &quot;303&quot;; &lt;a href=&quot;#section-10.3.4&quot;&gt;セクション10.3.4&lt;/a&gt;：その他を参照| &quot;304&quot;; &lt;a href=&quot;#section-10.3.5&quot;&gt;セクション10.3.5&lt;/a&gt;：変更なし| &quot;305&quot;; &lt;a href=&quot;#section-10.3.6&quot;&gt;セクション10.3.6&lt;/a&gt;：プロキシの使用| &quot;307&quot;; &lt;a href=&quot;#section-10.3.8&quot;&gt;セクション10.3.8&lt;/a&gt;：一時的なリダイレクト| &quot;400&quot;; &lt;a href=&quot;#section-10.4.1&quot;&gt;セクション10.4.1&lt;/a&gt;：不正な要求| &quot;401&quot;; &lt;a href=&quot;#section-10.4.2&quot;&gt;セクション10.4.2&lt;/a&gt;：不正| &quot;402&quot;; &lt;a href=&quot;#section-10.4.3&quot;&gt;セクション10.4.3&lt;/a&gt;：支払いが必要| &quot;403&quot;; &lt;a href=&quot;#section-10.4.4&quot;&gt;セクション10.4.4&lt;/a&gt;：禁止| &quot;404&quot;; &lt;a href=&quot;#section-10.4.5&quot;&gt;セクション10.4.5&lt;/a&gt;：見つかりません| &quot;405&quot;; &lt;a href=&quot;#section-10.4.6&quot;&gt;セクション10.4.6&lt;/a&gt;：メソッドは許可されていません| &quot;406&quot;; &lt;a href=&quot;#section-10.4.7&quot;&gt;セクション10.4.7&lt;/a&gt;：不可| &quot;407&quot;; &lt;a href=&quot;#section-10.4.8&quot;&gt;セクション10.4.8&lt;/a&gt;：プロキシ認証が必要| &quot;408&quot;; &lt;a href=&quot;#section-10.4.9&quot;&gt;セクション10.4.9&lt;/a&gt;：リクエストのタイムアウト| &quot;409&quot;; &lt;a href=&quot;#section-10.4.10&quot;&gt;セクション10.4.10&lt;/a&gt;：競合| &quot;410&quot;; &lt;a href=&quot;#section-10.4.11&quot;&gt;セクション10.4.11&lt;/a&gt;：終了| &quot;411&quot;; &lt;a href=&quot;#section-10.4.12&quot;&gt;セクション10.4.12&lt;/a&gt;：必要な長さ| &quot;412&quot;; &lt;a href=&quot;#section-10.4.13&quot;&gt;セクション10.4.13&lt;/a&gt;：前提条件が失敗しました| &quot;413&quot;; &lt;a href=&quot;#section-10.4.14&quot;&gt;セクション10.4.14&lt;/a&gt;：要求エンティティが大きすぎます| &quot;414&quot;; &lt;a href=&quot;#section-10.4.15&quot;&gt;セクション10.4.15&lt;/a&gt;：Request-URIが大きすぎる| &quot;415&quot;; &lt;a href=&quot;#section-10.4.16&quot;&gt;セクション10.4.16&lt;/a&gt;：サポートされていないメディアタイプ| &quot;416&quot;;&lt;a href=&quot;#section-10.4.17&quot;&gt;セクション10.4.17&lt;/a&gt;：要求された範囲は満足できません| &quot;417&quot;; &lt;a href=&quot;#section-10.4.18&quot;&gt;セクション10.4.18&lt;/a&gt;：期待に失敗しました| &quot;500&quot;; &lt;a href=&quot;#section-10.5.1&quot;&gt;セクション10.5.1&lt;/a&gt;：内部サーバーエラー| &quot;501&quot;; &lt;a href=&quot;#section-10.5.2&quot;&gt;セクション10.5.2&lt;/a&gt;：未実装| &quot;502&quot;; &lt;a href=&quot;#section-10.5.3&quot;&gt;セクション10.5.3&lt;/a&gt;：不正なゲートウェイ| &quot;503&quot;; &lt;a href=&quot;#section-10.5.4&quot;&gt;セクション10.5.4&lt;/a&gt;：サービスを利用できません| &quot;504&quot;; &lt;a href=&quot;#section-10.5.5&quot;&gt;セクション10.5.5&lt;/a&gt;：ゲートウェイのタイムアウト| &quot;505&quot;; &lt;a href=&quot;#section-10.5.6&quot;&gt;セクション10.5.6&lt;/a&gt;：HTTPバージョンはサポートされていません| extension-code extension-code = 3DIGIT Reason-Phrase = * &amp;lt;CR、LFを除くテキスト&amp;gt; HTTPステータスコードは拡張可能です。 HTTPアプリケーションは、登録されたすべてのステータスコードの意味を理解する必要はありませんが、そのような理解が明らかに望ましいです。ただし、アプリケーションは、最初の桁で示されるように、ステータスコードのクラスを理解しなければならず、認識されない応答はキャッシュされてはならないことを除いて、認識されない応答をそのクラスのx00ステータスコードと同等のものとして扱う必要があります。たとえば、認識されないステータスコード431をクライアントが受信した場合、リクエストに問題があると想定して、400ステータスコードを受信したかのように応答を処理できます。そのような場合、エンティティは異常なステータスを説明する人間が読み取れる情報を含む可能性が高いため、ユーザーエージェントはユーザーにレスポンスとともに返されたエンティティを提示する必要があります。</target>
        </trans-unit>
        <trans-unit id="b8418e17a41aec97d3c590fcc65fedf33be9a1c2" translate="yes" xml:space="preserve">
          <source>The TCP connection failed due to reasons not covered by previous errors</source>
          <target state="translated">以前のエラーでカバーされていない理由により、TCP 接続に失敗しました。</target>
        </trans-unit>
        <trans-unit id="a63d3da83f08f3589783fd322c14eb384668776f" translate="yes" xml:space="preserve">
          <source>The TCP connection was aborted</source>
          <target state="translated">TCP 接続が中断されました。</target>
        </trans-unit>
        <trans-unit id="ece1a07cee60e2c0d379acd1235868c7480c2fcb" translate="yes" xml:space="preserve">
          <source>The TCP connection was closed by the server</source>
          <target state="translated">TCP接続はサーバによって閉じられました。</target>
        </trans-unit>
        <trans-unit id="796733a0ab45ac90906d6f198849475b13814e44" translate="yes" xml:space="preserve">
          <source>The TCP connection was refused by the server</source>
          <target state="translated">TCP 接続はサーバによって拒否されました。</target>
        </trans-unit>
        <trans-unit id="44cef75a8f9ea523ffedd880063709751f6702f3" translate="yes" xml:space="preserve">
          <source>The TCP connection was reset</source>
          <target state="translated">TCP 接続がリセットされました。</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP ハンドシェイク自体には時間がかかりますが、TCP 接続は負荷に適応し、持続的な(またはウォームな)接続が多いほど効率的になります。短命の接続では、TCP のこの効率性の特徴を利用しておらず、新しいコールド・コネクションでの送信を継続することで、パフォーマンスが最適から低下します。</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE要求ヘッダーフィールドは、応答で受け入れることができる拡張転送コーディングと、チャンク転送コーディングでトレーラーフィールドを受け入れるかどうかを示します。その値は、キーワード「予告編」および/またはオプションの受け入れパラメーター（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;説明）を備えた拡張転送コーディング名のコンマ区切りリストで構成されます。 TE = &quot;TE&quot; &quot;：&quot;＃（t-codings）t-codings = &quot;trailers&quot; | （transfer-extension [accept-params]）キーワード「trailers」の存在は、&lt;a href=&quot;#section-3.6.1&quot;&gt;セクション3.6.1で&lt;/a&gt;定義されているように、クライアントがチャンク転送コーディングのトレーラーフィールドを受け入れる用意があることを示します。。このキーワードはそれ自体が転送コーディングを表していない場合でも、転送コーディング値で使用するために予約されています。その使用例は次のとおりです。TE：deflate TE：TE：トレーラー、deflate; q = 0.5 TEヘッダーフィールドは、即時接続にのみ適用されます。したがって、キーワードはConnectionヘッダーフィールド内に指定する必要があります（&lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt;）TEがHTTP / 1.1メッセージに存在する場合。サーバーは、TEフィールドに従って、次のルールを使用して、転送コーディングが受け入れ可能かどうかをテストします。1.「チャンクされた」転送コーディングは常に受け入れ可能です。キーワード「予告編」がリストされている場合、クライアントは、自分自身とダウンストリームクライアントに代わってチャンクされた応答の予告フィールドを受け入れる用意があることを示します。つまり、クライアントは、指定された場合、すべてのダウンストリームクライアントが転送された応答のトレーラーフィールドを受け入れる用意があるか、またはダウンストリームの受信者に代わって応答をバッファリングしようとすることを示しています。注：HTTP / 1。1は、チャンクされた応答のサイズを制限してクライアントが応答全体を確実にバッファリングできるようにする手段を定義していません。 2.テストされる転送コーディングがTEフィールドにリストされている転送コーディングの1つである場合、qvalueが0を伴わない限り許容されます（（&lt;a href=&quot;#section-3.9&quot;&gt;セクション3.9&lt;/a&gt;、qvalue 0は「受け入れられない」を意味します。）3.複数の転送コーディングが受け入れられる場合、ゼロ以外のqvalueが最も高い受け入れ可能な転送コーディングが優先されます。 「チャンク」転送コーディングのqvalueは常に1です。TEフィールド値が空の場合、またはTEフィールドが存在しない場合、唯一の転送コーディングは「チャンク」されます。 transfer-codingのないメッセージは常に受け入れられます。</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACEメソッドは、要求メッセージのリモートのアプリケーション層ループバックを呼び出すために使用されます。リクエストの最後の受信者は、クライアントに返されたメッセージを200（OK）応答のエンティティ本体として反映する必要があります（SHOULD）。最終受信者は、起点サーバー、またはリクエストでゼロ（0）のMax-Forwards値を受信する最初のプロキシまたはゲートウェイです（&lt;a href=&quot;#section-14.31&quot;&gt;セクション14.31を&lt;/a&gt;参照）。 TRACEリクエストにエンティティを含めることはできません。 TRACEを使用すると、クライアントは要求チェーンの反対側で受信されているものを確認し、そのデータをテストまたは診断情報に使用できます。 Viaヘッダーフィールドの値（&lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt;）は、リクエストチェーンのトレースとして機能するため、特に重要です。 Max-Forwardsヘッダーフィールドを使用すると、クライアントはリクエストチェーンの長さを制限できます。これは、無限ループでメッセージを転送するプロキシのチェーンをテストするのに役立ちます。リクエストが有効な場合、レスポンスには、リクエストメッセージ全体がエンティティ本体に含まれ、Content-Typeは「message / http」になります。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACEメソッドは、要求メッセージのリモートのアプリケーションレベルのループバックを要求します。リクエストの最後の受信者は、以下に説明するいくつかのフィールドを除いて、受信したメッセージを、「メッセージ/ http」のContent-Typeを持つ200（OK）応答のメッセージ本文としてクライアントに反映する必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;セクション8.3.1の[RFC7230]&lt;/a&gt;）。最終受信者は、起点サーバーか、リクエストでMax-Forwards値ゼロ（0）を受信する最初のサーバーです（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）。クライアントは、応答によって開示される可能性のある機密データを含むTRACE要求でヘッダーフィールドを生成してはなりません（MUST NOT）。たとえば、ユーザーエージェントが保存されたユーザー資格情報[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]またはCookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;を送信するのはばかげています。] TRACEリクエスト内。リクエストの最後の受信者は、その受信者が応答本文を生成するときに機密データを含む可能性のあるリクエストヘッダーフィールドを除外する必要があります（SHOULD）。 TRACEを使用すると、クライアントは要求チェーンの反対側で受信されているものを確認し、そのデータをテストまたは診断情報に使用できます。 Viaヘッダーフィールドの値（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]のセクション5.7.1&lt;/a&gt;）は、リクエストチェーンのトレースとして機能するため、特に重要です。 Max-Forwardsヘッダーフィールドを使用すると、クライアントはリクエストチェーンの長さを制限できます。これは、無限ループでメッセージを転送するプロキシのチェーンをテストするのに役立ちます。クライアントは、TRACEリクエストでメッセージ本文を送信してはいけません。 TRACEメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Trailerの一般的なフィールドの値は、指定されたヘッダーフィールドのセットが、チャンク転送コーディングでエンコードされたメッセージのトレーラーに存在することを示しています。 Trailer = &quot;Trailer&quot; &quot;：&quot; 1＃field-name HTTP / 1.1メッセージは、空でないトレーラーでチャンク転送コーディングを使用して、メッセージにトレーラーヘッダーフィールドを含める必要があります（SHOULD）。そうすることで、受信者はトレーラーで予期されるヘッダーフィールドを知ることができます。トレーラーヘッダーフィールドが存在しない場合、トレーラーにはヘッダーフィールドを含めないでください。「チャンク」転送コーディングでのトレーラフィールドの使用に関する制限については、&lt;a href=&quot;#section-3.6.1&quot;&gt;セクション3.6.1&lt;/a&gt;を参照してください。 Trailerヘッダーフィールドにリストされているメッセージヘッダーフィールドには、次のヘッダーフィールドを含めることはできません。 Transfer-Encoding。 Content-Length。トレーラー</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Transfer-EncodingのGeneral-Headerフィールドは、送信者と受信者の間でメッセージを安全に転送するために、メッセージの本文に適用された変換のタイプ（存在する場合）を示します。これは、転送コーディングがエンティティではなくメッセージのプロパティである点で、コンテンツコーディングとは異なります。 Transfer-Encoding = &quot;Transfer-Encoding&quot; &quot;：&quot; 1＃transfer-coding Transfer-codingsは&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;定義されています。例は次のとおりです。Transfer-Encoding：chunked複数のエンコーディングがエンティティに適用されている場合、それらが適用された順序でtransfer-codingsをリストする必要があります。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のエンティティヘッダーフィールドによって提供される場合があります。古いHTTP / 1.0アプリケーションの多くは、Transfer-Encodingヘッダーを理解していません。</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encodingヘッダーフィールドには、メッセージ本文を形成するためにペイロード本文に適用された（または今後適用される）転送コーディングのシーケンスに対応する転送コーディング名がリストされます。転送コーディングは&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;定義されています。 Transfer-Encoding = 1＃transfer-coding Transfer-Encodingは、MIMEのContent-Transfer-Encodingフィールドに類似しています。これは、7ビットのトランスポートサービス（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045]、セクション6&lt;/a&gt;でバイナリデータを安全にトランスポートできるように設計されています。）。ただし、安全な転送では、8ビットのクリーンな転送プロトコルに対して別の焦点があります。 HTTPの場合、Transfer-Encodingは主に、動的に生成されたペイロードを正確に区切り、転送効率またはセキュリティにのみ適用されるペイロードエンコーディングを、選択されたリソースの特性と区別することを目的としています。受信者はチャンク転送コーディングを解析できなければなりません（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1）。&lt;/a&gt;）ペイロードの本体サイズが事前にわからない場合、メッセージのフレーミングに重要な役割を果たすからです。送信者は、チャンクをメッセージ本文に複数回適用してはなりません（つまり、すでにチャンクされたメッセージのチャンクは許可されていません）。チャンク以外の転送コーディングが要求ペイロード本体に適用される場合、送信者はメッセージが適切にフレーム化されることを保証するために、チャンクを最終転送コーディングとして適用する必要があります。チャンク以外の転送コーディングが応答ペイロード本体に適用される場合、送信者はチャンクを最終的な転送コーディングとして適用するか、接続を閉じることによってメッセージを終了する必要があります。たとえば、Transfer-Encoding：gzip、chunkedは、ペイロード本文がgzipコーディングを使用して圧縮され、メッセージ本文の作成中にチャンクコーディングを使用してチャンク化されたことを示します。Content-Encoding（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]のセクション3.1.2.1&lt;/a&gt;））、Transfer-Encodingは表現ではなくメッセージのプロパティであり、要求/応答チェーンに沿った受信者は、受信した転送コーディングをデコードするか、追加の転送コーディングを適用することができます（MAY） ）メッセージ本文に、対応する変更がTransfer-Encodingフィールド値に加えられたと仮定して。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のヘッダーフィールドから提供できます。 Transfer-Encodingは、HEAD要求への応答または304（変更されていない）応答で送信できます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]のセクション4.1&lt;/a&gt;）。）GETリクエスト（いずれもメッセージ本文が含まれていない）に送信します。これは、リクエストが無条件GETであった場合に、オリジンサーバーがメッセージ本文に転送コーディングを適用したことを示します。ただし、応答チェーン（オリジンサーバーを含む）の受信者は、不要な転送コーディングを削除できるため、この指示は必要ありません。サーバーは、ステータスコード1xx（情報）または204（コンテンツなし）の応答でTransfer-Encodingヘッダーフィールドを送信してはなりません（MUST NOT）。サーバーは、CONNECTリクエストに対する2xx（成功）応答でTransfer-Encodingヘッダーフィールドを送信してはなりません（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6）。&lt;/a&gt;）。 Transfer-EncodingはHTTP / 1.1で追加されました。一般に、HTTP / 1.0サポートのみをアドバタイズする実装は、転送エンコードされたペイロードの処理方法を理解しないと想定されています。クライアントが、サーバーがHTTP / 1.1（またはそれ以降）の要求を処理することを認識していない限り、Transfer-Encodingを含む要求を送信してはなりません（MUST NOT）。そのような知識は、特定のユーザー構成の形で、または以前に受け取った応答のバージョンを記憶することである場合があります。対応する要求がHTTP / 1.1（またはそれ以降）を示さない限り、サーバーはTransfer-Encodingを含む応答を送信してはなりません（MUST NOT）。転送コーディングを含む要求メッセージを受信したサーバーは、501（実装されていません）で応答する必要があることを理解していません。</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">トランスポートレイヤセキュリティ(TLS)プロトコルバージョン1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">トランスポートレイヤセキュリティ(TLS)プロトコルバージョン1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">FirefoxのUA文字列自体は4つのコンポーネントに分解されています。</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCKメソッドは、Lock-Tokenリクエストヘッダーのロックトークンによって識別されるロックを削除します。 Request-URIは、ロックのスコープ内のリソースを識別しなければなりません（MUST）。 Lock-Tokenヘッダーを使用してロックトークンを提供することは、他の状態変更メソッドと一貫していないことに注意してください。これらのメソッドはすべて、ロックトークンを持つIfヘッダーを必要とします。したがって、ロックトークンを提供するためにIfヘッダーは必要ありません。当然、Ifヘッダーが存在する場合、条件付きヘッダーとしての通常の意味があります。このメソッドに正常に応答するには、サーバーはロックを完全に削除する必要があります。送信されたロックトークンでロックされているすべてのリソースをロック解除できない場合、UNLO​​CKリクエストは失敗する必要があります。 UNLOCKメソッドへの正常な応答は、リソースが必ずしもロック解除されていることを意味しません。これは、指定されたトークンに対応する特定のロックが存在しないことを意味します。 LOCKメソッドをサポートするDAV準拠のリソースは、UNLO​​CKメソッドをサポートする必要があります。この方法はべき等ですが、安全ではありません（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="b0025b4b69a4ce00bf003d08c44025493d147db8" translate="yes" xml:space="preserve">
          <source>The URI (absolute or relative) must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">URI（絶対または相対）は &lt;code&gt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; で囲む必要があります：</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">違反が発生した文書のURI。</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">コンテンツセキュリティポリシーによってロードがブロックされたリソースのURI。ブロックされたURIが &lt;code&gt;document-uri&lt;/code&gt; とは異なるオリジンからのものである場合、ブロックされたURIは切り捨てられ、スキーム、ホスト、およびポートのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">コンテンツセキュリティポリシーによって読み込みがブロックされたリソースの URI。ブロックされたURIがdocument-uriとは異なる起源からのものである場合、ブロックされたURIは、スキーム、ホスト、ポートだけを含むように切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="20d9b67c973fb9378d4e9a9893dce633fc72be6a" translate="yes" xml:space="preserve">
          <source>The URI reference, must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">URI参照は、 &lt;code&gt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">クライアントが要求したURIは、サーバーが解釈したいと思っているよりも長い。</target>
        </trans-unit>
        <trans-unit id="3c5fb5f7c661d221d889ac05db6f82fe9c0205e8" translate="yes" xml:space="preserve">
          <source>The URI where the user agent should report &lt;code&gt;Expect-CT&lt;/code&gt; failures.</source>
          <target state="translated">ユーザーエージェントが &lt;code&gt;Expect-CT&lt;/code&gt; の失敗を報告する必要があるURI 。</target>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;http://example.com/&lt;/code&gt; は &lt;code&gt;http://www.example.com/&lt;/code&gt; にリダイレクトされ、その下にあるファイルやディレクトリもすべてリダイレクトされます（ &lt;code&gt;http://example.com/index.html&lt;/code&gt; は &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; にリダイレクトされます） ：//www.example.com/index.html）</target>
        </trans-unit>
        <trans-unit id="5efef24fc6384dd41fb192a1bf80a33651bde15a" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;https://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;https://example.com/some-page&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/some-page&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;https://example.com/&lt;/code&gt; はにリダイレクトされます &lt;code&gt;https://www.example.com/&lt;/code&gt; その下に任意のファイルやディレクトリが（うとして、 &lt;code&gt;https://example.com/some-page&lt;/code&gt; はにリダイレクトされます &lt;code&gt;https://www.example.com/some-page&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab68e1cdf6b3b2fc5d165ae5d131fcb809d37323" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome (versions 52 to 73), you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in policy or by launching with the &lt;code&gt;--unsafe-pac-url&lt;/code&gt; command-line flag (in Chrome 74, only the flag works, and from 75 onward, there is no way to disable path-stripping; as of Chrome 81, path-stripping does not apply to HTTP URLs, but there is interest in changing this behavior to match HTTPS); in Firefox, the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">アクセスされているURL。 &lt;code&gt;https://&lt;/code&gt; URLのパスおよびクエリコンポーネントが削除されます。Chrome（バージョン52から73）では、ポリシーで &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定するか、 &lt;code&gt;--unsafe-pac-url&lt;/code&gt; コマンドラインフラグを使用して起動することでこれを無効にできます（Chrome 74では、フラグのみが機能し、75以降、パスストリッピングを無効にする方法はありません。Chrome81の時点では、パスストリッピングはHTTP URLには適用されませんが、HTTPSに一致するようにこの動作を変更することに関心があります。Firefoxでは、設定は &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">アクセスされているURL。 &lt;code&gt;https://&lt;/code&gt; URL のパスおよびクエリコンポーネントは削除されます。Chromeでは、これを無効にするには、 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定します。Firefoxでは、プリファレンスは &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1aac5516d3c0193c8b37aa0f0d853eb420d0c8fa" translate="yes" xml:space="preserve">
          <source>The URL of the requested resource has been changed permanently. The new URL is given in the response.</source>
          <target state="translated">要求されたリソースの URL が永久に変更されました。新しいURLはレスポンスで与えられます。</target>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">Upgrade汎用ヘッダーを使用すると、クライアントは、サポートする追加の通信プロトコルを指定でき、サーバーがプロトコルの切り替えに適切であると判断した場合に使用します。サーバーは、101（Switching Protocols）応答内のUpgradeヘッダーフィールドを使用して、切り替えられるプロトコルを示す必要があります。 Upgrade = &quot;Upgrade&quot; &quot;：&quot; 1＃productたとえば、Upgrade：HTTP / 2.0、SHTTP / 1.3、IRC / 6.9、RTA / x11 Upgradeヘッダーフィールドは、HTTP / 1.1から一部に移行するための簡単なメカニズムを提供することを目的としていますその他、互換性のないプロトコル。これは、現在の要求がHTTP / 1.1を使用して行われた場合でも、クライアントが別のプロトコル（メジャーバージョン番号が大きい新しいバージョンのHTTPなど）を使用したいという希望を宣伝できるようにすることで実現します。これにより、クライアントがより一般的にサポートされているプロトコルで要求を開始できるようにし、利用可能な場合は「より良い」プロトコルを使用することをサーバーに示します（「より良い」はサーバーによって決定されます）。 、おそらくメソッドやリソースのリクエストに応じて）。 Upgradeヘッダーフィールドは、既存のトランスポート層接続でのアプリケーション層プロトコルの切り替えにのみ適用されます。アップグレードを使用してプロトコルの変更を要求することはできません。サーバーによるその受け入れと使用はオプションです。プロトコル変更後のアプリケーション層通信の機能と性質は、選択した新しいプロトコルに完全に依存しています。ただし、プロトコル変更後の最初のアクションは、Upgradeヘッダーフィールドを含む最初のHTTPリクエストへの応答でなければなりません。 Upgradeヘッダーフィールドは、直接接続にのみ適用されます。したがって、アップグレードキーワードはConnectionヘッダーフィールド（&lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt;）アップグレードがHTTP / 1.1メッセージに存在する場合は常に。 Upgradeヘッダーフィールドを使用して、別の接続上のプロトコルへの切り替えを示すことはできません。そのためには、301、302、303、または305リダイレクト応答を使用する方が適切です。この仕様では、&lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1の&lt;/a&gt; HTTPバージョンルールおよびこの仕様の将来の更新で定義されているように、ハイパーテキスト転送プロトコルのファミリで使用するプロトコル名「HTTP」のみを定義しています。任意のトークンをプロトコル名として使用できます。ただし、クライアントとサーバーの両方が名前を同じプロトコルに関連付ける場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">User-Agent（&lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt;）、Via（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]のセクション5.7.1&lt;/a&gt;）、およびServer（&lt;a href=&quot;#section-7.4.2&quot;&gt;セクション7.4.2&lt;/a&gt;）ヘッダーフィールドは、それぞれの送信者のソフトウェアシステムに関する情報を明らかにします。理論的には、これにより攻撃者は既知のセキュリティホールを簡単に悪用することができます。実際には、攻撃者は使用されているソフトウェアのバージョンに関係なく、すべての潜在的なホールを試す傾向があります。ネットワークファイアウォールを介してポータルとして機能するプロキシは、ファイアウォールの背後にあるホストを識別する可能性があるヘッダー情報の転送に関して、特別な予防策を講じる必要があります。 Viaヘッダーフィールドを使用すると、仲介者が機密のマシン名を仮名に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="d9bc48b6946945b170102521a95dcc585d202997" translate="yes" xml:space="preserve">
          <source>The User-Agent header</source>
          <target state="translated">ユーザーエージェントヘッダー</target>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">User-Agentリクエストヘッダーフィールドには、リクエストを発信したユーザーエージェントに関する情報が含まれます。これは統計的な目的、プロトコル違反の追跡、特定のユーザーエージェントの制限を回避するために応答を調整するためのユーザーエージェントの自動認識のためのものです。ユーザーエージェントは、リクエストにこのフィールドを含める必要があります。このフィールドには、複数の製品トークン（&lt;a href=&quot;#section-3.8&quot;&gt;セクション3.8&lt;/a&gt;）と、ユーザーエージェントの重要な部分を形成するエージェントおよびサブ製品を識別するコメントを含めることができます。慣例により、製品トークンは、アプリケーションを識別するために重要度の高い順にリストされています。 User-Agent = &quot;User-Agent&quot; &quot;：&quot; 1 *（product | comment）例：User-Agent：CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Varyフィールド値は、応答が新しい間、キャッシュが再検証なしで後続の要求に応答するために応答を使用することを許可されるかどうかを完全に決定する要求ヘッダーフィールドのセットを示します。キャッシュ不可または古い応答の場合、Varyフィールドの値は、表現の選択に使用された基準についてユーザーエージェントに通知します。 「*」のVaryフィールド値は、キャッシュが後続の要求の要求ヘッダーから、この応答が適切な表現であるかどうかを判断できないことを意味します。&lt;a href=&quot;#section-13.6&quot;&gt;セクション13.6を&lt;/a&gt;参照 キャッシュによるVaryヘッダーフィールドの使用。 Vary = &quot;Vary&quot; &quot;：&quot;（ &quot;*&quot; | 1＃field-name）HTTP / 1.1サーバーは、サーバー主導のネゴシエーションの対象となるキャッシュ可能な応答を持つVaryヘッダーフィールドを含める必要があります（SHOULD）。そうすることで、キャッシュはそのリソースに対する将来の要求を適切に解釈し、そのリソースでのネゴシエーションの存在についてユーザーエージェントに通知できます。サーバーは、サーバー主導のネゴシエーションの対象となる、キャッシュできない応答を持つVaryヘッダーフィールドを含めることができます。これは、ユーザーエージェントに、応答時に応答が変化するディメンションに関する有用な情報を提供するためです。フィールド名のリストで構成されるVaryフィールド値は、応答に対して選択された表現が、最も適切な表現を選択する際にリストされたリクエストヘッダーフィールド値のみを考慮する選択アルゴリズムに基づいていることを通知します。キャッシュは、応答が新しい間、リストされたフィールド名に同じ値を持つ将来のリクエストに対して同じ選択が行われると想定する場合があります。指定されたフィールド名は、この仕様で定義されている一連の標準リクエストヘッダーフィールドに限定されません。フィールド名は大文字と小文字を区別しません。 「*」のVaryフィールド値は、要求ヘッダー（クライアントのネットワークアドレスなど）に限定されない未指定のパラメーターが、応答表現の選択に役割を果たすことを示します。 「* &quot;値はプロキシサーバーで生成してはなりません（MUST NOT）。値はオリジンサーバーでのみ生成できます。</target>
        </trans-unit>
        <trans-unit id="c4eba333151816238416f3ddeba94021b6342f57" translate="yes" xml:space="preserve">
          <source>The Vary response header</source>
          <target state="translated">Vary レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">Via general-headerフィールドは、リクエストでユーザーエージェントとサーバーの間、および応答でオリジンサーバーとクライアントの間の中間プロトコルと受信者を示すために、ゲートウェイとプロキシで使用する必要があります。これは、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9の&lt;/a&gt;「受信」フィールドに類似してい ます。]メッセージ転送の追跡、要求ループの回避、および要求/応答チェーンに沿ったすべての送信者のプロトコル機能の識別に使用することを目的としています。 Via = &quot;Via&quot; &quot;：&quot; 1＃（received-protocol received-by [comment]）received-protocol = [protocol-name &quot;/&quot;] protocol-version protocol-name = token protocol-version = token received-by = （ホスト[&quot;：&quot;ポート]）| pseudonym pseudonym = token received-protocolは、要求/応答チェーンの各セグメントに沿ってサーバーまたはクライアントが受信したメッセージのプロトコルバージョンを示します。受信プロトコルバージョンは、メッセージが転送されるときにViaフィールド値に追加されるため、アップストリームアプリケーションのプロトコル機能に関する情報はすべての受信者に表示されたままになります。 protocol-nameは、 &quot;HTTP&quot;の場合のみオプションです。 received-byフィールドは通常、後でメッセージを転送した受信者サーバーまたはクライアントのホストおよびオプションのポート番号です。ただし、実際のホストが機密情報であると見なされる場合は、仮名に置き換えることができます。ポートが指定されていない場合、それは受信プロトコルのデフォルトポートであると見なされる場合があります。複数のViaフィールド値は、メッセージを転送した各プロキシまたはゲートウェイを表します。各受信者は、転送アプリケーションのシーケンスに従って最終結果が順序付けられるように、情報を追加する必要があります。 User-AgentおよびServerヘッダーフィールドと同様に、Viaヘッダーフィールドでコメントを使用して、受信者プロキシまたはゲートウェイのソフトウェアを識別できます。ただし、[Via]フィールドのすべてのコメントはオプションであり、メッセージを転送する前に受信者が削除する場合があります。たとえば、要求メッセージはHTTP / 1.0ユーザーエージェントから &quot;fred&quot;という名前の内部プロキシコードに送信され、HTTP / 1.1を使用して、要求をnowhere.comのパブリックプロキシに転送します。 www.ics.uci.eduのオリジンサーバーに転送します。 www.ics.uci.eduが受け取ったリクエストには、次のViaヘッダーフィールドがあります。Via：1.0 fred、1。1 nowhere.com（Apache / 1.1）ネットワークファイアウォールを介してポータルとして使用されるプロキシとゲートウェイは、デフォルトでは、ファイアウォールリージョン内のホストの名前とポートを転送すべきではありません。この情報は、明示的に有効にされている場合にのみ伝達されるべきです（SHOULD）。有効化されていない場合、ファイアウォールの背後にあるホストの受信ホストは、そのホストの適切な仮名に置き換えられる必要があります（SHOULD）。内部構造を非表示にするための強力なプライバシー要件がある組織の場合、プロキシは、Viaヘッダーフィールドエントリの順序付けられたサブシーケンスを、同一の受信プロトコル値と組み合わせて、そのような1つのエントリにしてもよい（MAY）。たとえば、Via：1.0 ricky、1.1 ethel、1.1 fred、1.0 lucyは、Via：1.0 ricky、1.1 mertz、1に折りたたむことができます。0 lucyアプリケーションは、それらがすべて同じ組織的制御下にあり、ホストがすでに仮名で置き換えられている場合を除き、複数のエントリを組み合わせるべきではありません（SHOULD NOT）。アプリケーションは、異なる受信プロトコル値を持つエントリを組み合わせてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="324e73fe5f7adaaf8050e5c44d8fcd8a74dfca98" translate="yes" xml:space="preserve">
          <source>The WINDOW_UPDATE frame (type=0x8) is used to implement flow control;
   see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; for an overview.

   Flow control operates at two levels: on each individual stream and on
   the entire connection.

   Both types of flow control are hop by hop, that is, only between the
   two endpoints.  Intermediaries do not forward WINDOW_UPDATE frames
   between dependent connections.  However, throttling of data transfer
   by any receiver can indirectly cause the propagation of flow-control
   information toward the original sender.

   Flow control only applies to frames that are identified as being
   subject to flow control.  Of the frame types defined in this
   document, this includes only DATA frames.  Frames that are exempt
   from flow control MUST be accepted and processed, unless the receiver
   is unable to assign resources to handling the frame.  A receiver MAY
   respond with a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) or connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FLOW_CONTROL_ERROR if it is unable to accept
   a frame.

    +-+-------------------------------------------------------------+
    |R|              Window Size Increment (31)                     |
    +-+-------------------------------------------------------------+

                  Figure 14: WINDOW_UPDATE Payload Format

   The payload of a WINDOW_UPDATE frame is one reserved bit plus an
   unsigned 31-bit integer indicating the number of octets that the
   sender can transmit in addition to the existing flow-control window.
   The legal range for the increment to the flow-control window is 1 to
   2^31-1 (2,147,483,647) octets.

   The WINDOW_UPDATE frame does not define any flags.

   The WINDOW_UPDATE frame can be specific to a stream or to the entire
   connection.  In the former case, the frame's stream identifier
   indicates the affected stream; in the latter, the value &quot;0&quot; indicates
   that the entire connection is the subject of the frame.

   A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an
   flow-control window increment of 0 as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;)
   of type PROTOCOL_ERROR; errors on the connection flow-control window
   MUST be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;). 

   WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the
   END_STREAM flag.  This means that a receiver could receive a
   WINDOW_UPDATE frame on a &quot;half-closed (remote)&quot; or &quot;closed&quot; stream.
   A receiver MUST NOT treat this as an error (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;).

   A receiver that receives a flow-controlled frame MUST always account
   for its contribution against the connection flow-control window,
   unless the receiver treats this as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;).  This is necessary even if the frame is in error.
   The sender counts the frame toward the flow-control window, but if
   the receiver does not, the flow-control window at the sender and
   receiver can become different.

   A WINDOW_UPDATE frame with a length other than 4 octets MUST be
   treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">WINDOW_UPDATEフレーム（type = 0x8）は、フロー制御を実装するために使用されます。&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2を&lt;/a&gt;参照してください概要については。フロー制御は、個々のストリームと接続全体の2つのレベルで動作します。どちらのタイプのフロー制御もホップバイホップ、つまり2つのエンドポイント間のみです。仲介者は、依存する接続間でWINDOW_UPDATEフレームを転送しません。ただし、受信者によるデータ転送の調整により、元の送信者に向けてフロー制御情報が間接的に伝播される可能性があります。フロー制御は、フロー制御の対象として識別されたフレームにのみ適用されます。このドキュメントで定義されているフレームタイプのうち、これにはDATAフレームのみが含まれます。受信者がフレームの処理にリソースを割り当てることができない場合を除き、フロー制御が免除されているフレームは受け入れて処理する必要があります。受信者は、ストリームエラー（&lt;a href=&quot;#section-5.4.2&quot;&gt;セクション5.4.2&lt;/a&gt;）または接続エラー（セクション5.4.2）で応答する場合があります。&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）フレームを受け入れることができない場合は、タイプFLOW_CONTROL_ERROR。 +-+ ----------------------------------------------- -------------- + | R |ウィンドウサイズの増分（31）| +-+ ----------------------------------------------- -------------- +図14：WINDOW_UPDATEペイロード形式WINDOW_UPDATEフレームのペイロードは、1つの予約済みビットと、送信者が追加で送信できるオクテットの数を示す符号なし31ビット整数です。既存のフロー制御ウィンドウに移動します。フロー制御ウィンドウへの増分の有効な範囲は、1〜2 ^ 31-1（2,147,483,647）オクテットです。 WINDOW_UPDATEフレームは、フラグを定義しません。 WINDOW_UPDATEフレームは、ストリームまたは接続全体に固有にすることができます。前者の場合、フレームのストリーム識別子は影響を受けるストリームを示します。後者では、値「0」接続全体がフレームの対象であることを示します。受信者は、フロー制御ウィンドウの増分が0のWINDOW_UPDATEフレームの受信をストリームエラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.2&quot;&gt;&lt;/a&gt;タイプPROTOCOL_ERRORのセクション5.4.2）。接続フロー制御ウィンドウのエラーは、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）。 WINDOW_UPDATEは、END_STREAMフラグが設定されたフレームを送信したピアから送信できます。これは、受信者が「ハーフクローズ（リモート）」または「クローズ」ストリームでWINDOW_UPDATEフレームを受信できることを意味します。受信者はこれをエラーとして扱ってはなりません（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1を&lt;/a&gt;参照）。フロー制御フレームを受信する受信者は、受信者がこれを接続エラーとして扱わない限り、接続フロー制御ウィンドウに対するその寄与を常に考慮しなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）。これは、フレームにエラーがある場合でも必要です。送信側はフレームをフロー制御ウィンドウに向かってカウントしますが、受信側がカウントしない場合、送信側と受信側のフロー制御ウィンドウが異なる可能性があります。4オクテット以外の長さのWINDOW_UPDATEフレームは、タイプFRAME_SIZE_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">WWW-Authenticate応答ヘッダーフィールドは、401（無許可）応答メッセージに含まれている必要があります。フィールド値は、Request-URIに適用可能な認証スキームとパラメータを示す少なくとも1つのチャレンジで構成されます。 WWW-Authenticate = &quot;WWW-Authenticate&quot; &quot;：&quot; 1＃challenge HTTPアクセス認証プロセスについては、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で説明しています。ユーザーエージェントは、WWW-Authenticateフィールドの値を解析する際に特別な注意を払うことをお勧めします。複数のチャレンジが含まれている可能性があります。または、複数のWWW-Authenticateヘッダーフィールドが提供されている場合、チャレンジ自体の内容にカンマ区切りを含めることができます。認証パラメータのリスト。</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">警告の一般ヘッダーフィールドは、メッセージに反映されない可能性があるメッセージのステータスまたは変換に関する追加情報を伝えるために使用されます。この情報は、通常、メッセージのエンティティ本体に適用されるキャッシング操作または変換による意味の透過性の欠如の可能性について警告するために使用されます。警告ヘッダーは、次を使用して応答とともに送信されます：警告= &quot;警告&quot; &quot;：&quot; 1＃warning-value警告値= warn-code SP warn-agent SP warn-text [SP warn-date] warn-code = 3DIGIT warn-agent =（host [&quot;：&quot; port]）|仮名;追加するサーバーの名前または仮名。警告ヘッダーデバッグで使用する場合warn-text = quoted-string warn-date = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;応答には、複数の警告ヘッダーが含まれる場合があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。応答のContent-Languageフィールドなど。デフォルトの言語は英語で、デフォルトの文字セットはISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。応答のContent-Languageフィールドなど。デフォルトの言語は英語で、デフォルトの文字セットはISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]。警告ヘッダーは一般にどのメッセージにも適用できますが、一部の特定の警告コードはキャッシュに固有であり、応答メッセージにのみ適用できます。新しい警告ヘッダーは、既存の警告ヘッダーの後に追加する必要があります。キャッシュは、メッセージとともに受信した警告ヘッダーを削除してはなりません（MUST NOT）。ただし、キャッシュがキャッシュエントリの検証に成功した場合、特定の警告コードに指定されている場合を除き、そのエントリに以前に付加された警告ヘッダーを削除する必要があります（SHOULD）。次に、検証応答で受信した警告ヘッダーを追加する必要があります。つまり、警告ヘッダーは、最新の関連する応答に添付されるヘッダーです。応答に複数の警告ヘッダーが添付されている場合、ユーザーエージェントは、それらをできるだけ多くユーザーに通知する必要があります。応答に現れる順序で。すべての警告をユーザーに通知することが不可能な場合、ユーザーエージェントは次のヒューリスティックに従います。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、-応答の早い段階で表示される警告は、応答の後で表示される警告よりも優先されます。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、-応答の早い段階で表示される警告は、応答の後で表示される警告よりも優先されます。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、警告に関するキャッシュの動作の要件は、警告に関するキャッシュの動作の要件は、&lt;a href=&quot;#section-13.1.2&quot;&gt;セクション13.1.2&lt;/a&gt;。これは、現在定義されている警告コードのリストであり、それぞれに英語の推奨警告テキストとその意味の説明が含まれています。 110 Response is staleは、返された応答が古くなっている場合は必ず含める必要があります。 111サーバーに到達できないために応答の再検証に失敗したため、キャッシュが失効した応答を返す場合、111再検証の失敗を含める必要があります。 112切断された操作は、キャッシュが一定期間ネットワークの残りの部分から意図的に切断されている場合に含める必要があります。 113キャッシュがヒューリスティックに24時間を超えるフレッシュネスライフタイムを選択し、応答の経過時間が24時間を超える場合は、ヒューリスティックな有効期限を含める必要があります。199その他の警告警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受け取ったシステムは、ユーザーに警告を表示する以外に、自動化されたアクションを実行してはなりません。 214適用さ​​れた変換は、応答のコンテンツコーディング（Content-Encodingヘッダーで指定）またはメディアタイプ（Content-Typeヘッダーで指定）を変更する変換を適用する場合、中間キャッシュまたはプロキシによって追加する必要があります。または、この警告コードがすでに応答に表示されていない限り、応答のエンティティ本体。 299その他の永続的な警告警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受け取ったシステムは、自動化されたアクションを実行してはなりません。実装がHTTP / 1.0以下のバージョンの1つ以上の警告ヘッダーを持つメッセージを送信する場合、送信者は各警告値に応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。次に、送信者は、各警告値に、応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。次に、送信者は、各警告値に、応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。（これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。（これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">Web APIには、base64にエンコードまたはデコードするネイティブメソッドがあります：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64エンコードおよびデコード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">ウェブオリジンのコンセプト</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">Web ランタイムは、デスクトップ Firefox と同じユーザーエージェント文字列を使用します。</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">予期せぬ理由でWebページが一時的に利用できなくなる。そうすることで、検索エンジンはリンクを更新しなくなります。</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">このWebページは、予期せぬ理由により一時的に利用できなくなっています。そうすれば、検索エンジンはリンクを更新しません。GET以外のリンク/操作がサイトで利用可能な場合は &lt;code&gt;302&lt;/code&gt; より優れています。</target>
        </trans-unit>
        <trans-unit id="d6e1f00a886091957899f1d426a1a907509a4636" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons.</source>
          <target state="translated">予期せぬ理由でWebページが一時的に利用できない状態になっています。</target>
        </trans-unit>
        <trans-unit id="d83272b4a920a61a8fef1340e4de8c385bd7ee81" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons. Better than &lt;code&gt;302&lt;/code&gt; when non-&lt;code&gt;GET&lt;/code&gt; operations are available on the site.</source>
          <target state="translated">不測の事態により、一時的にウェブページをご利用いただけません。サイトで非 &lt;code&gt;GET&lt;/code&gt; 操作が利用可能な場合は &lt;code&gt;302&lt;/code&gt; よりも優れています。</target>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">ウェブサーバー</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">WebSocketプロトコル</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">クライアントがサーバーと通信するときに使用するWebSocketプロトコルのバージョン。この番号は、&lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocketバージョン番号レジストリに&lt;/a&gt;リストされている可能な限り最新のバージョンである必要があります。WebSocketプロトコルの最新の最終バージョンはバージョン13です。</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">XML名前空間拡張（[ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]）は、他の要素名との衝突を恐れずに新しいXML要素を追加できるようにするために、この仕様で使用されています。 WebDAVの要求と応答の本文は任意のXML要素で拡張できますが、メッセージの受信者は無視できますが、「DAV：」名前空間のXML要素は、そのXML要素が明示的に定義されていない限り、要求または応答の本文では使用しないでください。 WebDAVワーキンググループによってレビューされたIETF RFCで。 WebDAVを拡張可能かつ下位互換性のあるものにするためには、クライアントとサーバーの両方が、予期しないまたは認識されないコマンド拡張を受信したときの動作方法を知る必要があります。 XML処理の場合、つまり、クライアントとサーバーは、予期しない要素と属性（および認識されない要素のすべての子）が存在しないかのように、受信したXMLドキュメントを処理する必要があります。予期しない要素または属性には、別のコンテキストで使用される可能性があるものの、ここでは予期されないものが含まれます。処理の目的でこのようなアイテムを無視することは、もちろん、すべての情報をログに記録したり、デバッグ用に提示したりすることと一致します。この制限は、DAVプロパティ値のクライアントによる処理にも適用されます。プロパティのスキーマで特に宣言されていない限り、予期しないXML要素を無視する必要があります（SHOULD）。この制限は、サーバーがすべてのXML要素を記録する必要があるサーバーでのデッドDAVプロパティの設定には適用されません。さらに、この制限は、XMLの使用には適用されません。たとえば、XMLがエンティティ本体のコンテンツタイプである場合（たとえば、PUTの本体として使用される場合）です。受信者はXMLの処理命令を無視する必要があります（SHOULD）。したがって、WebDAVを拡張する仕様では、規範的な動作を定義するために処理命令を使用しないでください。 XML DTDフラグメントは、この仕様で定義されているすべてのXML要素に含まれています。ただし、正しいXMLは、名前空間の使用法と拡張ルールにより、DTDに従って有効になりません。特に：oこの仕様の要素は「DAV：」名前空間にあります。o特に明記しない限り、要素の順序は関係ありません。o拡張属性を追加できます。o「ANY」の要素タイプ定義の場合、その要素の規範的なテキスト定義は、その中に何があり得るか、そしてそれが何を意味するかを定義します。 o「#PCDATA」の要素タイプ定義の場合、拡張要素を追加してはなりません。 o「EMPTY」を含む他の要素タイプ定義の場合、拡張要素が追加される場合があります。これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、 &lt;a href=&quot;#appendix-A&quot;&gt;付録A&lt;/a&gt;）。XMLボディを含むWebDAVメッセージの受信者は、ハードコードされた、または動的に宣言されたDTDに従ってXMLドキュメントを検証してはなりません。このセクションでは、下位互換性のある拡張性ルールについて説明しています。また、拡張機能が下位互換性がないように設計されている場合もあります。たとえば、このドキュメントで定義されているXML要素を再利用する拡張機能を定義し、この仕様のDTDで必要な子要素の1つを省略している場合があります。</target>
        </trans-unit>
        <trans-unit id="5abb61434aba6cac3c3255f0777b6e4ab04de6f1" translate="yes" xml:space="preserve">
          <source>The abbreviation for each format links to a longer description of the format, its capabilities, and detailed browser compatibility information; including which versions introduced support and specific special features that may have been introduced later.</source>
          <target state="translated">各フォーマットの略語は、フォーマットのより長い説明、その機能、ブラウザの互換性に関する詳細な情報へのリンクとなっています。</target>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">リソースをロックする機能は、そのリソースへのアクセスを直列化するメカニズムを提供します。ロックを使用することで、オーサリングクライアントは、編集中に別のプリンシパルがリソースを変更しないという合理的な保証を提供することができます。このようにして、クライアントは「更新が失われる」問題を防ぐことができる。この仕様では、クライアントが指定した2つのパラメータ、関係するプリンシパルの数(排他的か共有か)、および付与されるアクセスの種類に応じて、ロックを変化させることができるようにしています。この文書では、書き込みという1つのアクセスタイプのロックのみを定義しています。しかし、この構文は拡張可能であり、他のアクセスタイプのロックの仕様も可能にしています。</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">上記のコンテンツセキュリティポリシーは、インラインの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を許可します</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">上記のコンテンツセキュリティポリシーでは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;要素などのインラインスタイル、および任意の要素の &lt;code&gt;style&lt;/code&gt; 属性を許可します。</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">上記は、ブラウザーから送信された&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダー（$ _SERVER ['HTTP_ORIGIN']から取得）が ' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; 'と一致するかどうかを確認します。存在する場合は、&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.comを返します。この例は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここで実行されています&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ded9ed730bf997dd582fce073e6812fd63d3ebf3" translate="yes" xml:space="preserve">
          <source>The above code would have made several incorrect assumptions:</source>
          <target state="translated">上記のコードでは、いくつかの間違った仮定をしていたでしょう。</target>
        </trans-unit>
        <trans-unit id="ced1ab96d2e07e89bba3cc71ef4220a4d87bd67e" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts &lt;code&gt;www.mozilla.org&lt;/code&gt; and &lt;code&gt;merchant.mozilla.org&lt;/code&gt; will go through the proxy.</source>
          <target state="translated">上記の例では、ホスト &lt;code&gt;www.mozilla.org&lt;/code&gt; と &lt;code&gt;merchant.mozilla.org&lt;/code&gt; がプロキシを経由することを除いて、mozilla.orgドメインのローカルホストを除くすべてにプロキシを使用します。</target>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">上記の例では、mozilla.orgドメイン内のローカルホスト以外の全てのホストにプロキシを使用しますが、ホスト www.mozilla.org と merchant.mozilla.org はプロキシを経由します。</target>
        </trans-unit>
        <trans-unit id="7aeeb6c5396c82b22fb67dae5cbdfb5d930395d8" translate="yes" xml:space="preserve">
          <source>The above permissions may be cached for 86,400 seconds (1 day).</source>
          <target state="translated">上記のパーミッションは86,400秒(1日)キャッシュされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">上記では毎回DNSを参照する必要がありますが、他のルールで結果が出ない場合にのみDNSが参照されるように、他のルールとインテリジェントにグループ化することができます。</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">追加されたセキュリティは、ドキュメントにアクセスするユーザーが &lt;code&gt;X-Frame-Options&lt;/code&gt; をサポートするブラウザーを使用している場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="442c6996e10d8c8b2aa1a7ff243ac87908709eb2" translate="yes" xml:space="preserve">
          <source>The added security is provided only if the user accessing the document is using a browser that supports &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">追加のセキュリティは、ドキュメントにアクセスするユーザーが &lt;code&gt;X-Frame-Options&lt;/code&gt; をサポートするブラウザを使用している場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">現在要求されているページへのリンクが張られている前のウェブページのアドレス。</target>
        </trans-unit>
        <trans-unit id="b7f363462ba0e835d6efe5f6a4a754557a175395" translate="yes" xml:space="preserve">
          <source>The allow list is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">許可リストは &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">allowlistは、以下の値のいずれかを取るオリジンのリストです。</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">このヘッダーの代替および事実上の標準バージョンは、&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt;ヘッダーです。</target>
        </trans-unit>
        <trans-unit id="87766695ac6340c40537ef09e93a85866ad2734b" translate="yes" xml:space="preserve">
          <source>The amount of device RAM can be used as a fingerprinting variable, so values for the header are intentionally coarse to reduce the potential for its misuse. The header takes on the following values: &lt;code&gt;0.25&lt;/code&gt;, &lt;code&gt;0.5&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">デバイスRAMの量はフィンガープリント変数として使用できるため、ヘッダーの値は意図的に粗くして、誤用の可能性を減らしています。ヘッダは、次の値をとる： &lt;code&gt;0.25&lt;/code&gt; 、 &lt;code&gt;0.5&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 、 &lt;code&gt;4&lt;/code&gt; 、 &lt;code&gt;8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">app:categories要素は、カテゴリのリストが固定かオープンセットかを示す &quot;yes &quot;または &quot;no &quot;の値を持つ &quot;fixed &quot;属性を含むことができます。fixed」属性がない場合は、値が「no」の「fixed」属性があることと同じです。代わりに、app:categories要素は「href」属性を含んでもよい[MAY]。その値は、Category Documentを識別するIRI参照でなければならない[MUST]。href」属性が提供された場合、app:categories要素は空でなければならず[MUST]、「fixed」または「scheme」属性を持ってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">app：collection要素は、Atomフィードドキュメントのatom：feedまたはatom：source要素の子として表示される場合があります。そのコンテンツは、フィードに表示するために新しいエントリを追加できるコレクションを識別します。アトム：フィードまたはアトム：ソース要素に現れる場合&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;、[RFC4287]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;セクション&lt;/a&gt;6で定義されているように、app：コレクション要素は外部マークアップと見なされます。</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">app:collection要素は、コレクションのIRIを与える &quot;href &quot;属性を含まなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">app：workspace要素は、1つの &quot;atom：title&quot;要素（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]で定義されている）を含み、人間が読めるワークスペースのタイトルを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">application / httpタイプは、1つ以上のHTTP要求または応答メッセージ（混合されていない）のパイプラインを囲むために使用できます。タイプ名：アプリケーションサブタイプ名：http必須パラメーター：N / Aオプションパラメーター：バージョン、msgtypeバージョン：囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信する場合は、適切なContent-Transfer-Encodingを使用する必要があります。セキュリティに関する考慮事項：&lt;a href=&quot;#section-9&quot;&gt;セクション9を参照&lt;/a&gt; 相互運用性に関する考慮事項：N / A公開された仕様：この仕様（&lt;a href=&quot;#section-8.3.2&quot;&gt;セクション8.3.2を&lt;/a&gt;参照）。このメディアタイプを使用するアプリケーション：該当なしフラグメント識別子の考慮事項：該当なし追加情報：このタイプの廃止されたエイリアス名：該当なしマジック番号：該当なしファイル拡張子：該当なしMacintoshファイルタイプコード：該当なし詳細については、連絡先の人物と電子メールアドレス：作成者のアドレスセクションを参照してください。使用目的：共通使用上の制限：なし作成者：「作成者のアドレス」セクションを参照してください。コントローラーの変更：IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">&lt;a href=&quot;cors&quot;&gt;クライアントとサーバーの両方で使用されるHTTPヘッダー&lt;/a&gt;に関する記事はこちらにあり、前提条件として読む必要があります。</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">アスタリスクはリソースを表す特別な値です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
