<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; の方法は、要求されたリソースとの双方向通信を開始します。トンネルを開くために使用できます。</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; は、要求されたリソースとの双方向通信を開始します。トンネルを開くために使用できます。</target>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; HTTPヘッダは、保持&lt;em&gt;指令&lt;/em&gt;のため（命令）&lt;a href=&quot;../caching&quot;&gt;キャッシュ&lt;/a&gt;要求と応答の両方です。リクエスト内の特定のディレクティブは、同じディレクティブがレスポンス内にある必要があることを意味するものではありません。</target>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 一般ヘッダフィールドは、要求と応答の両方でのメカニズムをキャッシュするためのディレクティブを指定するために使用されます。キャッシュディレクティブは単方向です。つまり、要求内の特定のディレクティブは、応答で同じディレクティブが提供されることを意味していません。</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-control&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダには、一の以上のディレクティブを受け付けます。すべてのタイプのデータをクリアする必要がある場合は、ワイルドカードディレクティブ（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダには、要求元のウェブサイトに関連したデータ（クッキー、ストレージ、キャッシュ）を閲覧クリア。これにより、Web開発者は、ブラウザによってローカルに保存されたデータを、その出所についてより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; ネットワーク接続ステーは、現在のトランザクションが終了した後に開くかどうか、一般的なヘッダコントロール。送信された値が &lt;code&gt;keep-alive&lt;/code&gt; の場合、接続は永続的で閉じられないため、同じサーバーへの後続の要求を実行できます。</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; ヘッダに設定されている &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; のアップグレードが要求されていることを示します。</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; ヘッダーは、電子メールのMIMEメッセージのより大きなコンテキストに定義されているが、可能なパラメータのサブセットだけがHTTP形式とに適用される&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;リクエスト。値 &lt;code&gt;form-data&lt;/code&gt; 、およびオプションのディレクティブ &lt;code&gt;name&lt;/code&gt; と &lt;code&gt;filename&lt;/code&gt; HTTPコンテキストで使用できるのです。</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; エンティティヘッダは、メディアタイプを圧縮するために使用されます。存在する場合、その値はエンティティ本体に適用されたエンコーディングを示します。これにより、クライアントは、 &lt;code&gt;Content-Type&lt;/code&gt; ヘッダーによって参照されるメディアタイプを取得するためにデコードする方法を知ることができます。</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; ヘッダを指定するために使用されている&lt;strong&gt;ページの対象読者を&lt;/strong&gt;、そしてこれは、複数の言語であることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;エンティティヘッダを&lt;/a&gt;するために使用される&lt;strong&gt;言語（複数可）を記述聴衆のために意図され&lt;/strong&gt;、それは、ユーザがユーザ自身の言語に応じて区別することを可能にするように、。</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;エンティティヘッダは&lt;/a&gt;、ユーザがユーザ自身の言語に応じて区別することを可能にするように、視聴者のために意図される言語（複数可）を記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; エンティティヘッダは、受信者に送信された、バイト単位で、エンティティボディのサイズを示します。</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; ヘッダは、返されたデータのために別の場所を示しています。主な用途は、&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーションの&lt;/a&gt;結果として送信されるリソースのURLを示すことです。</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; 全身メッセージに部分的メッセージが属するところ応答HTTPヘッダが示します。</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;strong&gt;&lt;dfn&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/dfn&gt;&lt;/strong&gt;HTTPレスポンスヘッダフィールドは、原点のためのエンドポイントを報告ストアにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; エンティティヘッダを示すために使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;メディアタイプ&lt;/a&gt;のリソースを。</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; HTTPリクエストヘッダが格納されている含ま&lt;a href=&quot;../cookies&quot;&gt;HTTPクッキー&lt;/a&gt;以前とサーバーによって送信された&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;ヘッダを。</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; ヘッダは任意であり、例えば、ブラウザのプライバシー設定がクッキーをブロックし、あれば省略してもよいです。</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; は、指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; メソッドは、指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; （&lt;strong&gt;D&lt;/strong&gt; O &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt;リクエストヘッダラック）は、ユーザの追跡嗜好を示しています。ユーザーは、パーソナライズされたコンテンツではなくプライバシーを好むかどうかを指定できます。</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 一般的なHTTPヘッダは、メッセージが発信された日時を含んでいます。</target>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; と &lt;code&gt;Path&lt;/code&gt; 属性が定義&lt;em&gt;スコープ&lt;/em&gt;クッキーが送信されるべきかのURL：クッキーのを。</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; と &lt;code&gt;Path&lt;/code&gt; のディレクティブは定義&lt;em&gt;スコープ&lt;/em&gt;クッキーが送信されるべきかのURL：クッキーのを。</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; ホストがクッキーの受信を許可されている属性を指定します。指定しない場合、&lt;em&gt;サブドメインを除い&lt;/em&gt;て、デフォルトでCookieを設定したのと同じ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;オリジンに&lt;/a&gt;なります。場合は &lt;code&gt;Domain&lt;/code&gt; &lt;em&gt;されて&lt;/em&gt;指定された場合、サブドメインが常に含まれています。したがって、 &lt;code&gt;Domain&lt;/code&gt; 指定は、それを省略するよりも制限が少なくなります。ただし、サブドメインがユーザーに関する情報を共有する必要がある場合に役立ちます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; を HTTPレスポンスヘッダは、リソースの特定のバージョンの識別子です。コンテンツが変更されていない場合、Webサーバーは完全な応答を送信する必要がないため、キャッシュの効率が向上し、帯域幅が節約されます。一方、コンテンツが変更された場合、etagはリソースの同時更新が互いに上書きすることを防ぐのに役立ちます（「空中衝突」）。</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; をHTTPレスポンスヘッダは、リソースの特定のバージョンの識別子です。コンテンツが変更されていない場合、Webサーバーは完全な応答を再送信する必要がないため、キャッシュの効率が向上し、帯域幅が節約されます。さらに、etagは、リソースの同時更新が相互に上書きするのを防ぐのに役立ちます（&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;「空中衝突」&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;Early-Data&lt;/code&gt; ヘッダはされ&lt;strong&gt;ていない&lt;/strong&gt;（すなわち、ブラウザ）要求の発信者によって設定されました。</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、報告および/または見過ごさ行くから、そのサイトのmisissued証明書の使用を防止証明書の透明性要件の施行にオプトインにサイトを可能にします。</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、報告および/または見過ごさ行くから、そのサイトのmisissued証明書の使用を防止証明書の透明性要件の施行にオプトインにサイトを可能にします。サイトが &lt;code&gt;Expect-CT&lt;/code&gt; ヘッダーを有効にすると、サイトの証明書がパブリックCTログに表示されることをブラウザーが確認するように要求されます。</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダは、サイトが報告および/またはの施行に選ぶことができます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;気付かないだろうから、そのサイトのmisissued証明書の使用を防ぐために、要件。</target>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; おそらく新しい証明書がデフォルトでのSCTをサポートすることが期待される2018年5月以来6月2021で廃止となります。2018年3月より前の証明書の有効期間は39か月でしたが、これらはすべて2021年6月に期限切れになります。</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; HTTPリクエストヘッダが必要にリクエストを適切に処理するために、サーバーによって果たされることを期待を示しています。</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">&lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーが今に改名された &lt;code&gt;Permissions-Policy&lt;/code&gt; 仕様で、この記事では、最終的にその変更を反映するために更新されます。</target>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; ヘッダからの情報が含まれている&lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;リバースプロキシサーバ&lt;/a&gt;プロキシが要求の経路に関与しているときに変更または失われます。</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; ヘッダは、プロキシが要求の経路に関与しているときに変更または失われたプロキシサーバのクライアントに面する側からの情報を含みます。</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; の方法は、指定されたリソースの表現を要求します。 &lt;code&gt;GET&lt;/code&gt; を使用したリクエストは、データのみを取得します。</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; は、指定されたリソースの表現を要求します。 &lt;code&gt;GET&lt;/code&gt; を使用したリクエストは、データのみを取得します。</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; の方法は、と同一の応答を要求する &lt;code&gt;GET&lt;/code&gt; の要求が、応答本体はありません。</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; は、要求&lt;a href=&quot;../headers&quot;&gt;のヘッダー&lt;/a&gt;場合に返される &lt;code&gt;HEAD&lt;/code&gt; リクエストのURLが代わりにHTTPで要求された&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドを。たとえば、URLが大量のダウンロードを生成する可能性がある場合、 &lt;code&gt;HEAD&lt;/code&gt; リクエストは、実際にファイルをダウンロードせずに、&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダーを読み取ってファイルサイズを確認できます。</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; は、指定されたリソースがHTTPで要求されるかどう返されるヘッダーを要求&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドを。このような要求は、たとえば、帯域幅を節約するために大きなリソースをダウンロードすることを決定する前に行うことができます。</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; の Cookieの属性では、JavaScriptによるCookieの値へのアクセスを防止することによって、この攻撃を軽減することができます。</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; HTTPリクエストヘッダは、要求条件になります。以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッドは、サーバは、それが記載されているのいずれかと一致する場合にのみ、要求されたリソースを送り返します &lt;code&gt;ETags&lt;/code&gt; 。以下のために&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;や他の非安全な方法で、それだけで、この場合にリソースをアップロードします。</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;If-Modified-Since&lt;/code&gt; リクエストHTTPヘッダー要求条件を作る：サーバーはと、要求されたリソースを送り返します&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;それが最後の指定した日付以降に変更された場合にのみ、ステータスが表示されます。それ以降にリクエストが変更されていない場合、レスポンスは本文なしの&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt;になります。前のリクエストの&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;レスポンスヘッダーには、最終変更日が含まれます。&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;If-Modified-Since&lt;/code&gt; は&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; HTTPリクエストヘッダは、要求条件になります。以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッドは、サーバーはと、要求されたリソースを送り返します&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;それは持っていない場合にのみ、ステータス&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与えられたものに一致します。他のメソッドの場合、要求は、最終的に存在するリソースの&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がリストされている値のいずれとも一致しない場合にのみ処理されます。</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; HTTPリクエストヘッダには、範囲の要求条件になり：条件が満たされた場合、範囲の要求が発行され、サーバが送り返す&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; の適切なボディとの回答を。条件が満たされない場合、リソース全体が&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ステータスで返送されます。</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 要求のHTTPヘッダは、要求条件になり：サーバは、要求されたリソースを送り返し、またはの場合にはそれを受け入れる&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;または別の非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;、与えられた後に最後に変更されていない場合にのみ、方法日付。指定した日付以降にリクエストが変更された場合、レスポンスは&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（Precondition Failed）エラーになります。</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 要求のHTTPヘッダは、要求条件になり：サーバは、要求されたリソースを送り返し、またはの場合にはそれを受け入れる&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;または別の非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;、与えられた後に最後に変更されていない場合にのみ、方法日付。指定された日付以降にリソースが変更された場合、レスポンスは&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（Precondition Failed）エラーになります。</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 誤って使用した場合、ヘッダは、警告またはエラーメッセージをスロー。それらは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;Webコンソール&lt;/a&gt;で発生します。</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; の応答HTTPヘッダーは、オリジンサーバがリソースが最後に変更されたと考えていた日付と時刻が含まれています。これは、受信または保存されたリソースが同じであるかどうかを判断するバリデーターとして使用されます。&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ヘッダーよりも精度が低く、フォールバックメカニズムです。&lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;ヘッダーを含む条件付きリクエストは、このフィールドを利用します。</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; レスポンスヘッダがにページをリダイレクトするURLを示します。これは、 &lt;code&gt;3xx&lt;/code&gt; （リダイレクト）または &lt;code&gt;201&lt;/code&gt; （作成済み）ステータス応答が提供されたときにのみ意味を提供します。</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; は、ターゲット・リソースのための通信オプションを記述するために使用されます。クライアントは、OPTIONSメソッドのURL、またはサーバー全体を参照するアスタリスク（*）を指定できます。</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; の方法は、ターゲット・リソースの通信オプションを記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; の要求が与えられたURLやサーバーの通信オプションを可能にしました。クライアントは、このメソッドを使用してURLを指定するか、サーバー全体を参照するためにアスタリスク（ &lt;code&gt;*&lt;/code&gt; ）を指定できます。</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; 由来フェッチ場所要求ヘッダが示します。パス情報は含まれず、サーバー名のみが含まれます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;リクエストと&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストで送信されます。これは、&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーに似ていますが、このヘッダーとは異なり、パス全体を開示しません。</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; は、リソースへの部分的な修正を適用します。</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; の方法は、リソースへの部分的な変更を適用するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; の方法は、多くの場合、サーバー上の状態または副作用の変化を引き起こして、指定されたリソースへのエンティティを提出するために使用されます。</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; は、サーバーにデータを送信します。リクエストの&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;は、Content-Typeヘッダーで示されます。</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; は、新しいリソースを作成したり、要求ペイロードを持つターゲット・リソースの表現に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; の方法は、要求ペイロードを持つ対象リソースの現在のすべての表現を置き換えます。</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 属性は、送信するために要求されたURLに存在している必要がありますURLパスを示している &lt;code&gt;Cookie&lt;/code&gt; ヘッダを。 &lt;code&gt;%x2F&lt;/code&gt; （「/」）文字は、ディレクトリセパレータとみなされ、サブディレクトリも一致しています。</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; ヘッダは一緒に送信される&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTPリクエストヘッダは、サーバが返すべきであることを文書の一部を示しています。 1つの &lt;code&gt;Range&lt;/code&gt; ヘッダーで一度に複数の部分を要求でき、サーバーはこれらの範囲をマルチパートドキュメントで送り返すことができます。サーバーが範囲を送り返す場合、サーバーは応答に&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; を使用します。範囲が無効な場合、サーバーは&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Range Not Satisfiable&lt;/code&gt; エラーを返します。サーバーは、 &lt;code&gt;Range&lt;/code&gt; ヘッダーを無視して、&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;ステータスコードを含むドキュメント全体を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTPリクエストヘッダは、サーバが返すべきであることを文書の一部を示しています。一度に1つの &lt;code&gt;Range&lt;/code&gt; ヘッダーで複数のパートを要求でき、サーバーはこれらの範囲をマルチパートドキュメントで送り返すことができます。サーバーが範囲を返送する場合、サーバーはレスポンスに&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; を使用します。範囲が無効な場合、サーバーは&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; エラーを返します。サーバーは &lt;code&gt;Range&lt;/code&gt; ヘッダーを無視して、ステータスコード&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; の&lt;/a&gt;ドキュメント全体を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; に送信されたHTTPヘッダ支配リファラ情報、&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーは、行われた要求に含まれるべきです。</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTPヘッダー&lt;/a&gt;コントロールがどのくらいの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;リファラ情報&lt;/a&gt;（経由して送信された&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダ）リクエストに含まれるべきです。</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; 応答HTTPヘッダーには、ユーザエージェントはフォローアップ要求を行う前に待機する時間を示しています。このヘッダーが使用される主なケースは3つあります。</target>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; の属性は、サーバがクッキーを（クロスオリジン・リクエストを送信しないことを要求することができます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;サイトは&lt;/a&gt;、クロスサイトリクエストフォージェリ攻撃に対する何らかの保護（提供登録できるドメインによって定義される）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRFを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">&lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; のヘッダを指定しますが、優先順に、使用したいことを一の以上のWebSocketプロトコル。サーバーによってサポートされる最初の1つが選択され、サーバーは応答に含まれる &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; ヘッダーでそれを返します。ヘッダーでもこれを複数回使用できます。結果は、単一のヘッダーでサブプロトコル識別子のコンマ区切りのリストを使用した場合と同じです。</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダは、与えられた要求応答サイクルのための1つ以上のメトリックおよび説明を通信します。これは、ユーザーのブラウザーまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;インターフェイスの開発者ツールで、バックエンドサーバーのタイミングメトリック（データベースの読み取り/書き込み、CPU時間、ファイルシステムアクセスなど）を表示するために使用されます。</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダは、潜在的に敏感なアプリケーションとインフラ情報を公開することができます。サーバー側でいつどのユーザーにどのメトリックを返すかを制御することを検討してください。たとえば、認証されたユーザーにのみ指標を表示し、一般には公開しないことができます。</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTPレスポンスヘッダは、ユーザエージェントが後でサーバに送信できるように、ユーザーエージェントにサーバからクッキーを送信するために使用されます。複数のCookieを送信するには、同じ応答で複数の &lt;code&gt;Set-Cookie&lt;/code&gt; ヘッダーを送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTPレスポンスヘッダは、ユーザエージェントにサーバーからのCookieを送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; と &lt;code&gt;Cookie&lt;/code&gt; のヘッダー</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">&lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;レスポンスヘッダは、生成したコードをリンクする&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;ソースマップ&lt;/a&gt;元のソースを復元し、デバッガで再構成された原稿を提示するためにブラウザを可能にします。</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; （多くの場合と略記レスポンスヘッダ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTSは&lt;/a&gt;）は、WebサイトがHTTPSを使用して、代わりにHTTPを使用して、それがのみアクセスする必要があることをブラウザに伝えることができます。</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; の方法は、ターゲットリソースへの経路に沿ってメッセージループバックテストを行います。</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; は、有用なデバッグ機構を提供する、ターゲットリソースへの経路に沿ってメッセージループバックテストを行います。</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; のレスポンスヘッダは、対応する要求に適用されるトラッキング状態を示しています。</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; ヘッダ指定安全に転送するために使用される符号化の形&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;エンティティを&lt;/a&gt;ユーザに。</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; ヘッダ指定安全に転送するために使用される符号化の形&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;ペイロード本体を&lt;/a&gt;ユーザに。</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; 優先順にヘッダ指定一つ以上のカンマで区切られたプロトコル名、。</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; ヘッダ</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; HTTPレスポンスヘッダは、キャッシュされた応答は、オリジンサーバからの新鮮なものを要求するのではなく使用することができるかどうかを決定するために、将来のリクエストヘッダを一致させる方法を決定します。これはサーバーによって使用され、&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;アルゴリズムでリソースの表現を選択するときに使用したヘッダーを示します。</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダは、デスクトップおよびモバイルユーザーに異なるコンテンツを提供するために有用であることができ、または検索エンジンがページのモバイル版を発見（そしておそらくも何のことを伝えできるようにするために&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;クローキングが&lt;/a&gt;意図されていません）。これは通常、 &lt;code&gt;Vary: User-Agent&lt;/code&gt; ヘッダーで実現され、&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;ヘッダーの値がモバイルクライアントとデスクトップクライアントで異なるために機能します。</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダーが上で設定する必要があります&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 、それは同等に設定されているとまったく同じように応答&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 応答。</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダはHTTPのバージョン1.1に加え、キャッシュが適切に動作させるために必要であるしました。キャッシュは、サーバー主導のコンテンツネゴシエーションで機能するために、送信されたコンテンツを選択するためにサーバーが使用した基準を知る必要があります。このようにして、キャッシュはアルゴリズムを再生でき、サーバーへの要求を増やすことなく、許容可能なコンテンツを直接提供できます。明らかに、ワイルドカード ' &lt;code&gt;*&lt;/code&gt; 'は、キャッシュが背後にある要素を認識できないため、キャッシュの発生を防ぎます。</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; ヘッダはHTTPのバージョン1.1に加え、キャッシュが適切に動作させるために必要であるしました。キャッシュは、サーバー主導のコンテンツネゴシエーションを処理するために、送信されたコンテンツを選択するためにサーバーがどの基準を使用したかを知る必要があります。このようにして、キャッシュはアルゴリズムを再生でき、サーバーへの追加の要求なしに、受け入れ可能なコンテンツを直接提供できます。明らかに、ワイルドカード ' &lt;code&gt;*&lt;/code&gt; 'は、キャッシュが背後にある要素を認識できないため、キャッシュの発生を防ぎます。詳細については、&lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTPキャッシング&amp;gt;さまざまな応答&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; ヘッダを一緒に送信される&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 応答。</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; 一般的なHTTPヘッダは、メッセージのステータスを持つ可能性のある問題についての情報を含みます。応答に複数の &lt;code&gt;Warning&lt;/code&gt; ヘッダーが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="translated">&lt;code&gt;Width&lt;/code&gt; 要求ヘッダーフィールドは、物理ピクセルで所望のリソース幅（画像のすなわち固有サイズ）を示す番号です。提供されるピクセル値は、次の最小の整数に丸められた数値（つまり、上限値）です。</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; DNSはプリフェッチHTTPレスポンスヘッダコントロール、ブラウザは積極的にユーザが従うだけでなく、画像、CSSを含むドキュメントによって参照される項目のためのURLを選択することが両方のリンク上のドメイン名の解決を実行していることによって特徴、JavaScriptなど。</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; （XFF）ヘッダがHTTPプロキシまたはロードバランサを介してWebサーバに接続するクライアントの発信元IPアドレスを識別するための事実上の標準ヘッダです。クライアントとサーバーの間でトラフィックがインターセプトされると、サーバーアクセスログにはプロキシまたはロードバランサーのIPアドレスのみが含まれます。クライアントの元のIPアドレスを確認するには、 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 要求ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; （XFH）ヘッダは、クライアントによって要求元のホスト識別するための事実上の標準ヘッダで&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP要求ヘッダーを。</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; （XFP）ヘッダは、クライアントがプロキシまたはロードバランサに接続するために使用するプロトコル（HTTPまたはHTTPS）を識別するための事実上の標準ヘッダです。サーバーアクセスログには、サーバーとロードバランサー間で使用されるプロトコルが含まれますが、クライアントとロードバランサー間で使用されるプロトコルは含まれません。クライアントとロードバランサー間で使用されるプロトコルを決定するには、 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; リクエストヘッダーを使用できます。</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;応答ヘッダーは、ブラウザーがページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;のHTTP&lt;/a&gt;レスポンスヘッダは、ブラウザは、ページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;のHTTP&lt;/a&gt;レスポンスヘッダは、ブラウザは、ページをレンダリングするために許可されるべきかどうかを示すために使用することができる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。サイトはこれを使用して、コンテンツが他のサイトに埋め込まれないようにすることで、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;クリックジャッキング&lt;/a&gt;攻撃を回避できます。</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">&lt;code&gt;delta-seconds&lt;/code&gt; パラメータは、結果をキャッシュできる秒数を示します。</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; ディレクティブの構文は、他のディレクティブ（例えばのソースリストに類似している&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;）が、許可しない &lt;code&gt;'unsafe-eval'&lt;/code&gt; または &lt;code&gt;'unsafe-inline'&lt;/code&gt; たとえば。また、 &lt;code&gt;default-src&lt;/code&gt; 設定にフォールバックしません。以下にリストされているソースのみが許可されます。</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; ディレクティブの構文は、他のディレクティブのソースリスト（例えばに似ている&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;が、許可しない &lt;code&gt;'unsafe-eval'&lt;/code&gt; または &lt;code&gt;'unsafe-inline'&lt;/code&gt; たとえば。また、バックに落ちることはありません &lt;code&gt;default-src&lt;/code&gt; 設定。以下にリストされているソースのみが許可されます。</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="translated">&lt;code&gt;https://foo.example&lt;/code&gt; 原点が要求するために許可されている &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; 次を経由してURLを：</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; それ大文字小文字を区別しない、となります &lt;code&gt;mobi&lt;/code&gt; は一致するすべてのモバイルブラウザ。</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; パラメータを使用すると、Base64形式にエンコードしたいファイルの名前であり、そして &lt;code&gt;remotename&lt;/code&gt; 、実際に使用されていないファイルのためのリモート名である &lt;code&gt;data&lt;/code&gt; のURL。</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; ある&lt;a href=&quot;mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;のような文字列を、 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG画像ファイルのため。省略した場合、デフォルトは &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt; になります</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; のようなMIMEタイプ文字列であり、 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG画像ファイルのため。省略した場合のデフォルトは &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; MIMEタイプがブラウザに部分的な応答を送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 完了の値の送信時にタイプが使用可能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;なHTMLフォームを&lt;/a&gt;ブラウザからサーバに。</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 完了の値の送信時にタイプが使用可能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;なHTMLフォームを&lt;/a&gt;ブラウザからサーバに。</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="translated">&lt;code&gt;no-store&lt;/code&gt; ディレクティブはキャッシュされる新しいリソースを防ぐことができますが、それは以前の要求の結果として、キャッシュされた非古いリソースで応答からキャッシュを防ぐことはできません。 &lt;code&gt;max-age=0&lt;/code&gt; を設定すると、キャッシュが強制的に再検証されます（キャッシュがクリアされます）。</target>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payment&lt;/code&gt; 機能のデフォルトallowlist値は &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; な信頼を明示的にノンスまたはハッシュとそれに付随することで、マークアップ内のスクリプトの存在に与えられたことをソース式の指定は、そのルートスクリプトによってロードされたすべてのスクリプトに伝播されなければなりません。同時に、 &lt;code&gt;'self'&lt;/code&gt; や &lt;code&gt;'unsafe-inline'&lt;/code&gt; などの許可リストまたはソース式は無視されます。例については、&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; な信頼を明示的にノンスまたはハッシュとそれに付随することで、マークアップ内のスクリプトの存在に与えられたことをソース式の指定は、そのルートスクリプトによってロードされたすべてのスクリプトに伝播されなければなりません。同時に、 &lt;code&gt;'self'&lt;/code&gt; や &lt;code&gt;'unsafe-inline'&lt;/code&gt; などのホワイトリストまたはソース式は無視されます。例については、&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; ディレクティブの前に評価された&lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt;とそれが設定されている場合は、後者が効果的に何もしません。HTTPへのリダイレクト後に強制しないHTTPSを古いブラウザーで強制したい場合を除き、どちらか一方のディレクティブを設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; ディレクティブは、サードパーティのサイトにリンクを介してあなたのサイトを訪問するユーザーがトップレベルナビゲーションのためにHTTPSにアップグレードされますので、置き換えないことを保証しません&lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）ヘッダを、どのユーザーがSSLストリッピング攻撃を受けないようにするには、適切な &lt;code&gt;max-age&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">&lt;em&gt;HTTPバージョン&lt;/em&gt;応答に使用する予想バージョンの指標として作用する、残りのメッセージの構造を定義します。</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">&lt;em&gt;アスタリスク形状&lt;/em&gt;、単純なアスタリスク（ &lt;code&gt;'*'&lt;/code&gt; ）と一緒に使用される &lt;code&gt;OPTIONS&lt;/code&gt; 全体としてサーバを表します。</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;プロトコルのバージョン&lt;/em&gt;、通常は &lt;code&gt;HTTP/1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">&lt;em&gt;要求対象&lt;/em&gt;、通常&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;、またはプロトコル、ポート、およびドメインの絶対パスは、通常、リクエストコンテキストによって特徴付けられます。このリクエストターゲットの形式は、HTTPメソッドによって異なります。かもね</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;ユーザーエージェントは、&lt;/em&gt;ユーザーの代わりに作用する任意のツールです。この役割は主にWebブラウザによって実行されます。いくつかの例外は、エンジニアとWeb開発者がアプリケーションをデバッグするために使用するプログラムです。</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;ユーザーエージェントは、&lt;/em&gt;ユーザーの代わりに作用する任意のツールです。この役割は主にWebブラウザによって実行されます。他の可能性は、エンジニアやWeb開発者がアプリケーションをデバッグするために使用するプログラムです。</target>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="translated">&lt;strong&gt; &lt;var&gt;type&lt;/var&gt; &lt;/strong&gt;データタイプのような、落下先の一般的なカテゴリ表す &lt;code&gt;video&lt;/code&gt; または &lt;code&gt;text&lt;/code&gt; 。&lt;strong&gt; &lt;var&gt;subtype&lt;/var&gt; &lt;/strong&gt;の正確な種類MIMEタイプが表す指定されたタイプのデータの識別。たとえば、MIMEタイプの &lt;code&gt;text&lt;/code&gt; 場合、サブタイプは &lt;code&gt;plain&lt;/code&gt; （プレーンテキスト）、 &lt;code&gt;html&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt;ソースコード）、または &lt;code&gt;calendar&lt;/code&gt; （iCalendar / &lt;code&gt;.ics&lt;/code&gt; の場合）ファイルの場合があります。</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Altキー-SVCの&lt;/strong&gt;ヘッダは、このウェブサイトに到達するために、リストの代替の方法に使用されています。</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">&lt;strong&gt;HTTP DELETEリクエストメソッドは、&lt;/strong&gt;指定されたリソースを削除します。</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;strong&gt;HTTP PATCHリクエストメソッドは&lt;/strong&gt;リソースに対する部分的変更を適用します。</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;strong&gt;HTTPのPUTリクエストメソッドは、&lt;/strong&gt;新しいリソースを作成したり、要求ペイロードを持つターゲット・リソースの表現に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;秒-のWebSocketは、受け入れ&lt;/strong&gt;ヘッダがWebSocketの開口ハンドシェークに使用されます。応答ヘッダーに表示されます。つまり、これはヘッダーがサーバーからクライアントに送信され、サーバーがWebSocket接続を開始する用意があることを通知します。</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;トレーラー&lt;/strong&gt;レスポンスヘッダは、送信者がメッセージ本文を、メッセージ整合性チェック、デジタル署名、または後処理状態として、送信されている間、動的に生成されるかもしれない供給メタデータのためにチャンクメッセージの終わりに追加フィールドを含めることができます。</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;ユーザエージェント&lt;/strong&gt;要求ヘッダは、ネットワーク・プロトコル・ピアは、アプリケーションタイプ、オペレーティングシステム、ソフトウェアベンダまたは要求するソフトウェアのユーザエージェントのソフトウェアバージョンを識別することを可能にする特性文字列を含みます。</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ユーザエージェント&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;要求ヘッダは、&lt;/a&gt;サーバとネットワークピアが要求するアプリケーション、オペレーティングシステム、ベンダ、および/またはバージョンを識別することができ特性文字列である&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザエージェント&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="translated">Accept ヘッダ</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">Accept request-headerフィールドを使用して、応答に受け入れられる特定のメディアタイプを指定できます。 Acceptヘッダーを使用して、インライン画像のリクエストの場合と同様に、リクエストが特定のタイプの小さなセットに限定されていることを示すことができます。 Accept = &quot;Accept&quot; &quot;：&quot;＃（media-range [accept-params]）media-range =（ &quot;* / *&quot; |（type &quot;/&quot; &quot;*&quot;）|（type &quot;/&quot; subtype））*（ &quot;;&quot;パラメータ）accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *（accept-extension）accept-extension = &quot;;&quot;トークン[&quot;=&quot;（トークン|引用文字列）]アスタリスク &quot;*&quot;文字は、メディアタイプを範囲にグループ化するために使用されます。「* / *」はすべてのメディアタイプを示し、「type / *」はそのタイプのすべてのサブタイプを示します。メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（メディア範囲には、その範囲に適用可能なメディアタイプパラメータが含まれる場合があります。各メディア範囲の後には、1つ以上のaccept-paramsが続く場合があり、相対的な品質係数を示す「q」パラメータで始まります。最初の「q」パラメーター（存在する場合）は、メディア範囲パラメーターをAccept-paramsから分離します。品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（品質係数により、ユーザーまたはユーザーエージェントは、0から1までのqvalueスケールを使用して、そのメディア範囲の相対的な優先度を示すことができます（&lt;a href=&quot;#section-3.9&quot;&gt;セクション3.9&lt;/a&gt;）。デフォルト値はq = 1です。注：メディアタイプパラメーターをAccept拡張パラメーターから分離するために「q」パラメーター名を使用するのは、歴史的な慣習によるものです。これにより、「q」という名前のメディアタイプパラメータがメディア範囲で使用されなくなりますが、IANAメディアタイプレジストリに「q」パラメータが不足していること、およびメディアタイプがまれにしか使用されないことがこのようなイベントであるとは考えられません。 Acceptのパラメータ。将来のメディアタイプでは、「q」という名前のパラメータを登録しないでください。例Accept：audio / *; q = 0.2、音声/基本は「音声/基本を好みますが、品質が80％値下げされた後に最高の音声タイプが得られれば、どんな音声タイプでも送ってください」と解釈する必要があります。 Acceptヘッダーフィールドが存在しない場合、次に、クライアントがすべてのメディアタイプを受け入れると想定されます。 Acceptヘッダーフィールドが存在し、サーバーが結合されたAcceptフィールド値に従って受け入れ可能な応答を送信できない場合、サーバーは406（受け入れられない）応答を送信する必要があります（SHOULD）。より複雑な例はAccept：text / plain;です。 q = 0.5、text / html、text / x-dvi; q = 0.8、text / xc口頭で、これは「text / htmlとtext / xcが推奨されるメディアタイプであると解釈されますが、存在しない場合は、text / x-dviエンティティを送信し、存在しない場合は存在する場合は、text / plainエンティティを送信してください。」メディア範囲は、より具体的なメディア範囲または特定のメディアタイプによってオーバーライドできます。特定のタイプに複数のメディア範囲が適用される場合、最も具体的な参照が優先されます。たとえば、Accept：text / *、text / html、text / html; level = 1、* / *には次の優先順位があります：1）text / html; level = 1 2）text / html 3）text / * 4）* / *メディア特定のタイプに関連付けられているタイプクオリティファクターは、そのタイプに一致する優先順位が最も高いメディア範囲を見つけることによって決定されます。たとえば、Accept：text / *; q = 0.3、text / html; q = 0.7、text / html; level = 1、text / html; level = 2; q = 0.4、* / *; q = 0.5は、関連付けられる次の値：text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7注：ユーザーエージェントには、特定のメディア範囲の品質値のデフォルトセットが提供される場合があります。ただし、ユーザーエージェントが他のレンダリングエージェントと対話できないクローズドシステムでない限り、このデフォルトセットはユーザーが設定できる必要があります。</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="translated">Accept-CH ヘッダ</target>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="translated">Accept-CH-Lifeetime ヘッダ</target>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="translated">Accept-Charset ヘッダ</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charsetリクエストヘッダーフィールドを使用して、どの文字セットが応答に受け入れられるかを示すことができます。このフィールドを使用すると、クライアントは、より包括的または特殊目的の文字セットを理解でき、その文字セットでドキュメントを表現できるサーバーにその機能を通知できます。 Accept-Charset = &quot;Accept-Charset&quot; &quot;：&quot; 1＃（（charset | &quot;*&quot;）[&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）文字セット値については、&lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4で&lt;/a&gt;。各文字セットには、その文字セットに対するユーザーの好みを表す関連する品質値を与えることができます（MAY）。デフォルト値はq = 1です。例はAccept-Charsetです：iso-8859-5、unicode-1-1; q = 0.8特別な値 &quot;*&quot;がAccept-Charsetフィールドに存在する場合、すべての文字セット（ISO-8859-1を含む）に一致しますAccept-Charsetフィールドのどこにも記載されていません。 Accept-Charsetフィールドに「*」が存在しない場合、明示的に指定されていない場合に品質値1を取得するISO-8859-1を除いて、明示的に指定されていないすべての文字セットの品質値は0になります。 Accept-Charsetヘッダーが存在しない場合、デフォルトでは、任意の文字セットが受け入れられます。 Accept-Charsetヘッダーが存在する場合、また、サーバーがAccept-Charsetヘッダーに従って受け入れ可能な応答を送信できない場合、サーバーは406（受け入れられない）ステータスコードを含むエラー応答を送信する必要がありますが、受け入れられない応答の送信も許可されます。</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="translated">Accept-Encoding ヘッダ</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-EncodingリクエストヘッダーフィールドはAcceptに似ていますが、コンテンツコーディングを制限します（&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）応答で許容できるもの。 Accept-Encoding = &quot;Accept-Encoding&quot; &quot;：&quot; 1＃（codings [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）codings =（content-coding | &quot;*&quot;）使用例：Accept-Encoding：圧縮、gzip Accept-Encoding：Accept-Encoding：* Accept-Encoding：compress; q = 0.5、gzip; q = 1.0 Accept-Encoding：gzip; q = 1.0、identity; q = 0.5、*; q = 0サーバーは、次のルールを使用して、Accept-Encodingフィールドに従ってコンテンツコーディングが許容可能かどうかをテストします。1.コンテンツコーディングがAcceptにリストされているコンテンツコーディングの1つである場合-エンコードフィールド、qvalueが0を伴わない限り、それは受け入れられます（（&lt;a href=&quot;#section-3.9&quot;&gt;ますセクション3.9で&lt;/a&gt;、0のqvalueは「受け入れられない」を意味します。）2. Accept-Encodingフィールドの特別な「*」記号は、ヘッダーフィールドに明示的にリストされていない使用可能なcontent-codingと一致します。 3.複数のコンテンツコーディングが許容できる場合、ゼロ以外のqvalueが最も高い許容可能なコンテンツコーディングが優先されます。 4. Accept-Encodingフィールドに &quot;identity; q = 0&quot;が含まれているため、またはフィールドに &quot;*; q = 0&quot;が含まれ、明示的に &quot;アイデンティティ」コンテンツコーディング。 Accept-Encodingフィールド値が空の場合、「ID」エンコーディングのみが受け入れられます。Accept-Encodingフィールドがリクエストに存在し、サーバーがAccept-Encodingヘッダーに従って受け入れ可能な応答を送信できない場合、サーバーは406（Not Acceptable）ステータスコードを含むエラー応答を送信する必要があります（SHOULD）。 Accept-Encodingフィールドがリクエストに存在しない場合、サーバーはクライアントがコンテンツコーディングを受け入れると想定してもよい（MAY）。この場合、「アイデンティティ」が利用可能なコンテンツコーディングの1つである場合、サーバーは、別のコンテンツコーディングがクライアントにとって意味があるという追加情報がない限り、「アイデンティティ」コンテンツコーディングを使用する必要があります。注：リクエストにAccept-Encodingフィールドが含まれておらず、「identity」コンテンツコーディングが利用できない場合、HTTP / 1.0クライアント（つまり、「gzip」および「compress」が推奨されます。古いクライアントの中には、他のコンテンツコーディングで送信されたメッセージを正しく表示しないものがあります。サーバーは、特定のユーザーエージェントまたはクライアントに関する情報に基づいてこの決定を行うこともあります。注：ほとんどのHTTP / 1.0アプリケーションは、コンテンツコーディングに関連付けられたqvalueを認識または従いません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。つまり、qvaluesは機能せず、x-gzipまたはx-compressでは許可されません。</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="translated">Accept-Language ヘッダ</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-LanguageリクエストヘッダーフィールドはAcceptに似ていますが、リクエストへの応答として優先される自然言語のセットを制限します。言語タグはで定義されています&lt;a href=&quot;#section-3.10&quot;&gt;セクション3.10で&lt;/a&gt;。 Accept-Language = &quot;Accept-Language&quot; &quot;：&quot; 1＃（language-range [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]）language-range =（（1 * 8ALPHA *（ &quot;-&quot; 1 * 8ALPHA）） | &quot;*&quot;）各言語範囲には、その範囲で指定された言語に対するユーザーの好みの推定値を表す関連する品質値を指定できます（MAY）。品質値のデフォルトは「q = 1」です。たとえば、Accept-Language：da、en-gb; q = 0.8、en; q = 0.7は、「デンマーク語が好きですが、イギリス英語と他のタイプの英語は受け入れます」を意味します。言語範囲は、タグと完全に等しい場合、またはプレフィックスに続く最初のタグ文字が「-」になるようにタグのプレフィックスと正確に等しい場合、言語タグと一致します。Accept-Languageフィールドに存在する場合、特別な範囲「*」は、Accept-Languageフィールドに存在する他のどの範囲とも一致しないすべてのタグに一致します。注：このプレフィックス一致ルールの使用は、言語タグが言語に割り当てられていることを意味するものではなく、ユーザーが特定のタグを持つ言語を理解している場合、このユーザーはタグを持つすべての言語も理解するということが常に当てはまります。このタグがプレフィックスであるもの。この場合、接頭辞ルールは接頭辞タグの使用を許可するだけです。 Accept-Languageフィールドによって言語タグに割り当てられた言語品質係数は、言語タグと一致するフィールドの最も長い言語範囲の品質値です。タグに一致するフィールドの言語範囲がない場合、割り当てられる言語品質係数は0です。Accept-Languageヘッダーがリクエストに存在しない場合、サーバーはすべての言語が同等に受け入れ可能であると想定する必要があります（SHOULD）。 Accept-Languageヘッダーが存在する場合、0より大きい品質係数が割り当てられているすべての言語が受け入れ可能です。すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、すべてのリクエストでユーザーの完全な言語設定を含むAccept-Languageヘッダーを送信することは、ユーザーのプライバシーの期待に反する場合があります。この問題の説明については、 &lt;a href=&quot;#section-15.1.4&quot;&gt;セクション15.1.4&lt;/a&gt;。了解度は個々のユーザーに大きく依存するため、クライアントアプリケーションでユーザーが使用できる言語設定を選択できるようにすることをお勧めします。選択が利用可能にならない場合、リクエストでAccept-Languageヘッダーフィールドを指定してはなりません（MUST NOT）。注：言語設定の選択をユーザーが利用できるようにする場合、ユーザーは上記の言語マッチングの詳細に精通していないことを実装者に思い出させ、適切なガイダンスを提供する必要があります。例として、ユーザーは &quot;en-gb&quot;を選択すると、英国英語が利用できない場合にあらゆる種類の英語のドキュメントが提供されると想定する場合があります。このような場合、ユーザーエージェントは、「en」を追加して最適な一致動作を得るよう提案する場合があります。</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Rangesレスポンスヘッダーフィールドを使用すると、サーバーはリソースの範囲リクエストの受け入れを示すことができます。Accept-Ranges = &quot;Accept-Ranges&quot; &quot;：&quot;バイト範囲のリクエストを受け入れる「なし」のオリジンサーバーはAccept-Ranges：バイトを送信できますが、必須ではありません。クライアントは、関連するリソースのこのヘッダーを受信せずに、バイト範囲のリクエストを生成できます（MAY）。範囲の単位は&lt;a href=&quot;#section-3.12&quot;&gt;セクション3.12で&lt;/a&gt;定義されています。リソースに対するいかなる種類の範囲要求も受け入れないサーバーは、範囲要求を試みないようにクライアントに通知するためにAccept-Ranges：noneを送信してもよい（MAY）。</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Ageヘッダーフィールドは、キャッシュから取得した応答メッセージの推定経過時間を伝えるために使用されます。 Ageフィールドの値は、応答がオリジンサーバーによって生成または検証されてからのキャッシュの推定秒数です。本質的に、Age値は、応答がオリジンサーバーからのパスに沿って各キャッシュに常駐していた時間と、ネットワークパスに沿って転送されていた時間の合計です。次のデータは、年齢の計算に使用されます。age_value「age_value」という用語は、Ageヘッダーフィールドの値を示します（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）、算術演算に適した形式。利用できない場合は0。 date_value「date_value」という用語は、算術演算に適した形式で、Dateヘッダーフィールドの値を示します。Dateヘッダーフィールドの定義、およびそれなしの応答に関する要件について&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;は、[RFC7231]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;セクション&lt;/a&gt;7.1.1.2を参照してください。 now「今」という用語は、「計算を実行しているホストでのクロックの現在の値」を意味します。ホストはNTP（[&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt; RFC5905&lt;/a&gt;]）またはそのクロックを協定世界時に同期させるための類似のプロトコル。 request_time保存された応答をもたらす要求が行われたときのホストのクロックの現在の値。 response_time応答が受信されたときのホストのクロックの現在の値。応答の経過時間は、2つの完全に独立した方法で計算できます。1.「apparent_age」：ローカルクロックが元のサーバーのクロックに適切に同期されている場合は、response_timeからdate_valueを引いた値。結果が負の場合、結果はゼロに置き換えられます。 2.応答パスに沿ったすべてのキャッシュがHTTP / 1.1を実装している場合、「corrected_age_value」。キャッシュは、応答が受信された時間ではなく、要求が開始された時間に関連してこの値を解釈する必要があります。 Appearance_age = max（0、response_time-date_value）; response_delay = response_time-request_time; corrected_age_value = age_value + response_delay;これらは、次のように組み合わされます。キャッシュがAgeヘッダーフィールドの値に自信がない場合（たとえば、ViaヘッダーフィールドにHTTP / 1.0ホップがないため）。この場合、corrected_age_valueはcorrected_initial_ageとして使用できます（MAY）。保存された応答のcurrent_ageは、保存された応答が起点サーバーによって最後に検証されてからの時間（秒単位）をcorrected_initial_ageに追加することで計算できます。resident_time = now-response_time; current_age = corrected_initial_age + resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Age応答ヘッダーフィールドは、応答（またはその再検証）がオリジンサーバーで生成されてからの送信者の推定時間を伝えます。キャッシュされた応答は、その存続期間がその存続期間を超えない場合、「新鮮」です。年齢の値は、&lt;a href=&quot;#section-13.2.3&quot;&gt;セクション13.2.3で&lt;/a&gt;。 Age = &quot;Age&quot; &quot;：&quot; age-value age-value = delta-seconds Age値は、秒単位の時間を表す、負でない10進整数です。キャッシュが表すことができる最大の正の整数より大きい値を受信する場合、またはキャッシュの経過時間の計算のいずれかがオーバーフローする場合、キャッシュは2147483648（2 ^ 31）の値を持つ経過時間ヘッダーを送信する必要があります。キャッシュを含むHTTP / 1.1サーバーは、自身のキャッシュから生成されるすべての応答にAgeヘッダーフィールドを含める必要があります。キャッシュは、少なくとも31ビットの範囲の算術型を使用する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">Allow entity-header フィールドには、Request-URI で識別されたリソースがサポートするメソッドのセットが一覧表示されます。このフィールドの目的は、リソースに関連付けられた有効なメソッドを受信者に通知することです。Allowヘッダーフィールドは405(Method Not Allowed)応答に存在しなければならない[MUST]。Allow=&quot;Allow&quot; &quot;:&quot; Allow=&quot;Allow&quot; &quot;:&quot; #Method 使用例。Allow。使用例:Allow:GET,HEAD,PUT このフィールドは、クライアントが他のメソッドを試すのを防ぐことはできません。しかし、Allowヘッダーフィールド値によって与えられた指示に従うべきである[SHOULD]。実際に許可されるメソッドのセットは、各リクエスト時にオリジンサーバーが定義する。Allowヘッダーフィールドは、新規または修正されたリソースがサポートするメ ソッドを推奨するPUTリクエストで提供してもよい[MAY]。サーバーはこれらのメソッドをサポートすることを要求されず、実際にサポートされるメ ソッドを与える応答にAllowヘッダーを含めるべきである[SHOULD]。プロキシは、たとえ指定されたすべてのメソッドを理解していなくても、 Allowヘッダーフィールドを修正してはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atomプロトコルは、サーバーのアクションにほとんど制限を課しません。ここで制約が指定されていない限り、サーバーは、特にクライアントから送信されたAtomエントリーの操作に関して、動作が異なることが予想されます。たとえば、この仕様はGETとPOSTに関してコレクションの予想される動作のみを定義していますが、これは、PUT、DELETE、PROPPATCHなどがコレクションリソースで禁止されていることを意味するわけではありません。これらのメソッドに対する応答になります。同様に、一部のHTTPステータスコードが明示的に言及されていますが、クライアントはサーバーからのステータスコードを処理する準備をする必要があります。サーバーは、受け入れ、拒否、遅延、モデレート、検閲、再フォーマット、翻訳、再配置を選択できます。または、提出されたコンテンツを再分類します。これらの選択肢の一部だけが、クライアント要求への応答としてすぐにクライアントに中継されます。他の選択肢は、フィードまたは公開されたエントリで後でのみ明らかになる場合があります。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更フィードまたは公開されたエントリ内。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更フィードまたは公開されたエントリ内。 2つの異なる発行サイトへの同じ一連の要求により、異なる一連のHTTP応答、異なる結果のフィード、または異なるエントリコンテンツが発生する可能性があります。その結果、クライアントソフトウェアは、サーバーが送信の結果であると決定したものを受け入れるように柔軟に記述される必要があります。この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更この仕様またはHTTP [によって明示的に禁止されていないサーバー応答またはサーバーコンテンツの変更この仕様またはHTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;したがって、RFC2616 ]が許可されます。</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom プロトコルは、HTTP を使用してリソースを公開および編集するための操作を規定しています。Atom形式の表現を使用して、リソースの状態とメタデータを記述します。また、リソースのコレクションをどのように編成するかを定義し、リソースの発見、グループ化、および分類をサポートするためのフォーマットを規定しています。</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atomプロトコルは、HTTPで定義された応答ステータスコードを使用して、操作の成功または失敗を示します。各ステータスコードの詳細な定義については、HTTP仕様[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]を参照してください。実装者は、HTTP仕様に従って、HTTP 4xxおよび5xx応答エンティティに、人間が読める形式のエラーの説明を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">アトムパブリッシングプロトコル</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom Publishing Protocolは、HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]およびXML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] を使用してWebリソースを公開および編集するためのアプリケーションレベルのプロトコルです。このプロトコルは、Webリソースの作成をサポートし、次の機能を提供します。oコレクション：リソースのセット。全体または一部を取得できます。 oサービス：コレクションの発見と説明。 o編集：リソースの作成、編集、削除。 Atom Publishing Protocolは、サーバーがクライアントからの要求を処理する際に広い自由度を与えられているという点で、現在の多くのプロトコルとは異なります。詳細については、&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom Publishing ProtocolはHTTPに基づいているため、&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]のセクション15&lt;/a&gt;にあるセキュリティ上の考慮事項に従います。このセクションに記載されている脅威は、HTTPで実行される多くのプロトコルに適用されます。 Atompubワーキンググループは、TLSで認証済みのHTTPを実行することによって提供される保護（&lt;a href=&quot;#section-14&quot;&gt;セクション14で&lt;/a&gt;説明）が、このセクションに記載されている攻撃によって提示される問題の多くを軽減するのに十分であると判断しました 。</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom Publishing ProtocolはHTTPに基づいています。 HTTPの認証要件は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;、[RFC2616]のセクション11で説明されています&lt;/a&gt;。認証メカニズムを使用して、不明または無許可のクライアントによるPOSTや編集を防止することをお勧めしますが、必須ではありません。認証が使用されていない場合、クライアントとサーバーは、ささいなスプーフィング、サービス拒否攻撃、および改ざん攻撃に対して脆弱です。ただし、状況によっては、これは許容可能なリスクです。展開される認証の種類は、サーバーオペレーターによって行われるローカルな決定です。クライアントは、サーバーの配置によって異なる認証スキームに直面する可能性があります。少なくとも、クライアントとサーバーの実装は、HTTP基本認証を使用するように構成できる必要があります[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt; RFC2617&lt;/a&gt;] TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ]または後続の標準トラックバージョンのTLS（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]など）で作成された接続と組み合わせて、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818で&lt;/a&gt;説明されているHTTP over TLSを使用するための規則をサポート]。認証メカニズムの選択は、相互運用性に影響を与えます。上記で参照されている最低レベルのセキュリティ（TLSを使用した基本認証）は、この仕様の公開時点ではインターネットアプリケーションの優れたプラクティスと見なされており、相互運用性のベースラインを確立するには十分です。実装者は、展開時に同等またはそれ以上に優れていると見なされる代替メカニズムを調査して使用することをお勧めします。新しい認証スキームを展開できるようにクライアントを実装することをお勧めします。このプロトコルは、リクエストの結果を報告する主要な手段としてHTTPレスポンスステータスコードを使用するため、サーバーは、適切な4xx HTTPレスポンスコードを使用して、未承認または未認証のリクエストに応答することをお勧めします（たとえば、401「無許可」または403「禁止」）に従って[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom Publishing Protocolは、HTTPメソッドを使用して、次のようにメンバーリソースを作成します。o GETは、既知のリソースの表現を取得するために使用されます。 o POSTは、動的に名前が付けられた新しいリソースを作成するために使用されます。クライアントが非Atomエントリ表現をコレクションに送信して作成すると、常に2つのリソースが作成されます。要求されたリソースのメディアエントリと、コレクションに表示されるリソースに関するメタデータのメディアリンクエントリです。 o PUTは、既知のリソースを編集するために使用されます。リソースの作成には使用されません。 o DELETEは、既知のリソースを削除するために使用されます。 Atomプロトコルは、エントリおよびメディアリソースの作成、編集、削除のみを対象としています。コレクションを操作した結果、他のリソースが作成、編集、削除される可能性があります。ただし、それらのリソースの数、メディアタイプ、およびそれらに対するAtomプロトコル操作の影響は、この仕様の範囲外です。クライアントとサーバーの相互作用のすべての側面はHTTPに関して定義されるため、[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;この仕様でカバーされていない領域については、RFC2616を参照してください。</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;配信&lt;/a&gt;フォーマット[ RFC4287 ]では、「application / atom + xml」メディアタイプを定義して、AtomフィードとAtomエントリードキュメントの両方を識別します。実装の経験から、At​​omフィードとエントリードキュメントは異なる処理モデルを持つことができ、それらを区別する必要がある状況があることが実証されています。この仕様は、2つのタイプのAtom文書を区別するために使用される「タイプ」パラメーターを定義します。</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECTメソッドは、受信者がrequest-targetで識別された宛先オリジンサーバーへのトンネルを確立することを要求し、成功した場合は、トンネルが閉じるまで、その動作を双方向のパケットのブラインド転送に制限します。トンネルは一般に、1つ以上のプロキシを介してエンドツーエンドの仮想接続を作成するために使用され、TLS（Transport Layer Security、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt; RFC5246&lt;/a&gt;]）を使用して保護できます。 CONNECTは、プロキシへのリクエストでの使用のみを目的としています。自身のCONNECT要求を受信したオリジンサーバーは、2xx（成功）ステータスコードで応答して、接続が確立されたことを示すことができます。ただし、ほとんどのオリジンサーバーはCONNECTを実装していません。 CONNECTリクエストを送信するクライアントは、request-target（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt; [RFC7230]のセクション5.3）。&lt;/a&gt;）;つまり、request-targetは、コロンで区切られたトンネル宛先のホスト名とポート番号のみで構成されます。たとえば、CONNECT server.example.com:80 HTTP / 1.1 Host：server.example.com:80受信プロキシは、リクエストターゲットに直接接続するか、別のプロキシを使用するように構成されている場合は転送することにより、トンネルを確立できます。次のインバウンドプロキシへのCONNECTリクエスト。 2xx（成功）応答は、送信者（およびすべての受信プロキシ）が、成功応答のヘッダーセクションの最後の空白行の直後にトンネルモードに切り替わることを示します。その空白行の後に受信されたデータは、request-targetによって識別されたサーバーからのものです。成功した応答以外の応答は、トンネルがまだ形成されておらず、接続がHTTPによって管理されたままであることを示します。トンネルは、トンネルの仲介者がいずれかの側が接続を閉じたことを検出すると閉じられます。仲介者は、閉じられた側から来た未処理のデータを反対側に送信し、両方の接続を閉じて、未送信の残りのデータを破棄する必要があります。プロキシ認証は、トンネルを作成する権限を確立するために使用される場合があります。たとえば、CONNECT server.example.com:80 HTTP / 1.1 Host：server.example.com:80 Proxy-Authorization：basic aGVsbG86d29ybGQ =任意のサーバーへのトンネルを確立することには重大なリスクがあり、特に、宛先がWebトラフィック用ではない既知または予約済みのTCPポートである場合。たとえば、「example.com:25」のリクエストターゲットへのCONNECTは、プロキシがSMTPトラフィック用に予約されたポートに接続することを示唆します。許可されていれば、プロキシをだましてスパムメールをリレーさせることができます。 CONNECTをサポートするプロキシは、その使用を既知のポートの限定されたセットまたは安全な要求ターゲットの構成可能なホワイトリストに制限する必要があります（SHOULD）。サーバーは、CONNECTへの2xx（成功）応答でTransfer-EncodingまたはContent-Lengthヘッダーフィールドを送信してはなりません（MUST NOT）。クライアントは、CONNECTへの正常な応答で受信したContent-LengthまたはTransfer-Encodingヘッダーフィールドをすべて無視する必要があります。 CONNECTリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。CONNECTリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する場合があります。 CONNECTメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPYメソッドは、DestinationヘッダーのURIで識別される宛先リソースに、Request-URIで識別されるソースリソースの複製を作成します。 Destinationヘッダーが存在する必要があります。 COPYメソッドの正確な動作は、ソースリソースのタイプによって異なります。すべてのWebDAV準拠リソースは、COPYメソッドをサポートする必要があります。ただし、COPYメソッドのサポートは、リソースをコピーする機能を保証するものではありません。たとえば、別々のプログラムが同じサーバー上のリソースを制御する場合があります。その結果、同じサーバー上にあるように見える場所にリソースをコピーできない場合があります。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等ですが、安全ではありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">DepthヘッダーのないコレクションのCOPYメソッドは、値 &quot;infinity&quot;のDepthヘッダーが含まれているかのように動作する必要があります。クライアントは、 &quot;0&quot;または &quot;infinity&quot;の値を持つコレクションのCOPYでDepthヘッダーを送信できます。サーバーは、WebDAV準拠のリソースで「0」および「無限」の深度ヘッダー動作をサポートする必要があります。無限の深さのCOPYは、Request-URIで識別されるコレクションリソースをDestinationヘッダーのURIで識別される場所にコピーし、そのすべての内部メンバーリソースを、それに関連する場所に再帰的にコピーするように指示しますコレクション階層のすべてのレベルを通して。 / A /から/ A / B /への無限深度のCOPYは、正しく処理されない場合、無限再帰を引き起こす可能性があることに注意してください。 「深さのコピー：0は、コレクションとそのプロパティをコピーすることを指示するだけで、内部メンバーURLによって識別されるリソースはコピーしないことを指示します。COPYに含まれるヘッダーは、Destinationヘッダーを除いて、コピーするすべてのリソースの処理に適用する必要があります。 Destinationヘッダーは、Request-URIの宛先URIのみを指定します。Request-URIで識別されるコレクションのメンバーに適用される場合、Destinationの値は、階層内の現在の場所を反映するように変更されます。したがって、リクエスト-URIは/ a /で、ホストヘッダー値はhttp://example.com/で、宛先はhttp://example.com/b/であり、http：//example.com/a/c/dが処理されるとき、http：//example.com/b/c/dの宛先を使用する必要があります。COPYメソッドが処理を完了すると、宛先で一貫したURL名前空間を作成している必要があります（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;名前空間の一貫性の定義については）。ただし、内部コレクションのコピー中にエラーが発生した場合、サーバーはこのコレクションのメンバーによって識別されるリソースをコピーしてはなりません（つまり、サーバーはこのサブツリーをスキップする必要があります）。これにより、一貫性のない名前空間が作成されます。エラーを検出した後、COPY操作は可能な限り多くの元のコピー操作を終了しようとする必要があります（つまり、サーバーは、エラーの原因となるコレクションの子孫ではない他のサブツリーとそのメンバーを引き続きコピーする必要があります）。したがって、たとえば、コレクション/ a / b /および/ a / c /を含むコレクション/ a /に対して無限深度コピー操作が実行され、/ a / b /のコピー中にエラーが発生した場合でも、 / a / c /をコピーします。同様に、無限深度コピーの一部として非コレクションリソースをコピーしているときにエラーが発生した後、サーバーは、元のコピー操作を可能な限り終了しようとする必要があります（SHOULD）。 COPYメソッドの実行中にエラーがRequest-URIで識別されたリソース以外のリソースで発生した場合、応答は207（マルチステータス）でなければならず、失敗の原因となったリソースのURLは特定のエラー。 COPYメソッドからの207（マルチステータス）レスポンスでは、424（失敗した依存関係）ステータスコードを返すべきではありません（SHOULD NOT）。クライアントは親のエラーを受け取ったときにリソースの子孫をコピーできなかったことをクライアントが知っているので、これらの応答は安全に省略できます。さらに、201（作成済み）/ 204（コンテンツなし）ステータスコードは、COPYメソッドからの207（マルチステータス）レスポンスの値として返されるべきではありません（SHOULD NOT）。これらもデフォルトの成功コードであるため、省略しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORSメカニズムは、ブラウザとサーバー間の安全なクロスオリジンリクエストとデータ転送をサポートします。最新のブラウザは、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;などのAPIでCORSを使用して、クロスオリジンHTTPリクエストのリスクを軽減します。</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORSメカニズムは、ブラウザーとWebサーバー間の安全なクロスオリジン要求とデータ転送をサポートします。最近のブラウザーは、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;などのAPIコンテナーでCORSを使用して、クロスオリジンHTTPリクエストのリスクを軽減します。</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORSプロトコルは元々その動作を必要としていました&lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;が、その後&lt;/a&gt;、その動作を必要としないように変更されました。ただし、すべてのブラウザーが変更を実装しているわけではないため、元々必要だった動作がまだ行われています。</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSPの&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;ディレクティブは、このヘッダーと共に使用する必要があります。そうしないと、このヘッダーは高価な何もしないマシンになります。</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSPメカニズムでは、 &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダー、&lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダー、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素などを介して、リソースに複数のポリシーを指定できます。</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-headerフィールドは、要求/応答チェーンに沿ったすべてのキャッシングメカニズムに従う必要があるディレクティブを指定するために使用されます。ディレクティブは、キャッシュが要求または応答に悪影響を与えることを防ぐための動作を指定します。これらのディレクティブは通常、デフォルトのキャッシュアルゴリズムをオーバーライドします。リクエストにディレクティブが存在しても、応答で同じディレクティブが指定されることを意味しないという点で、キャッシュディレクティブは単方向です。 HTTP / 1.0キャッシュはCache-Controlを実装せず、Pragma：no-cacheのみを実装する場合があることに注意してください（&lt;a href=&quot;#section-14.32&quot;&gt;セクション14.32を&lt;/a&gt;参照）。）。ディレクティブは要求/応答チェーン上のすべての受信者に適用できるため、キャッシュディレクティブは、そのアプリケーションに対する重要性に関係なく、プロキシまたはゲートウェイアプリケーションによってパススルーされる必要があります。特定のキャッシュにcache-ディレクティブを指定することはできません。 Cache-Control = &quot;Cache-Control&quot; &quot;：&quot; 1＃cache-directive cache-directive = cache-request-directive | cache-response-directive cache-request-directive = &quot;no-cache&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | 「ストアなし」; &lt;a href=&quot;#section-14.9.2&quot;&gt;セクション14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3、14.9.4&lt;/a&gt; | 「max-stale」[&quot;=&quot;デルタ秒];&lt;a href=&quot;#section-14.9.3&quot;&gt;[&quot;=&quot;デルタ秒]; セクション14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; | &quot;変換なし&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;セクション14.9.5&lt;/a&gt; | &quot;キャッシュのみ&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; |キャッシュ拡張; &lt;a href=&quot;#section-14.9.6&quot;&gt;セクション14.9.6&lt;/a&gt; cache-response-directive = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | &quot;プライベート&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1＃フィールド名&amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | &quot;no-cache&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1＃field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;セクション14.9.1&lt;/a&gt; | 「ストアなし」;&lt;a href=&quot;#section-14.9.2&quot;&gt;セクション14.9.2&lt;/a&gt; | &quot;変換なし&quot;;&lt;a href=&quot;#section-14.9.5&quot;&gt;セクション14.9.5&lt;/a&gt; | 「再検証が必要」; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; | &quot;プロキシ再検証&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot;デルタ秒; &lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt; |キャッシュ拡張;&lt;a href=&quot;#section-14.9.6&quot;&gt;セクション14.9.6&lt;/a&gt; cache-extension = token [&quot;=&quot;（token | quoted-string）]ディレクティブが1＃field-nameパラメータなしで表示される場合、ディレクティブはリクエストまたはレスポンス全体に適用されます。そのようなディレクティブが1＃field-nameパラメーターと共に表示される場合、それは名前付きフィールドにのみ適用され、残りの要求または応答には適用されません。このメカニズムは拡張性をサポートします。 HTTPプロトコルの将来のバージョンの実装では、これらのディレクティブをHTTP / 1.1で定義されていないヘッダーフィールドに適用する可能性があります。キャッシュ制御ディレクティブは、次の一般的なカテゴリに分類できます。-キャッシュ可能なものに関する制限。これらは、オリジンサーバーによってのみ課される場合があります。 -キャッシュに保存できるものに関する制限。これらは、起点サーバーまたはユーザーエージェントによって課せられる場合があります。-基本的な有効期限メカニズムの変更。これらは、起点サーバーまたはユーザーエージェントによって課せられる場合があります。 -キャッシュの再検証とリロードの制御。これらは、ユーザーエージェントによってのみ課される場合があります。 -エンティティの変換を制御します。 -キャッシングシステムの拡張。</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control ヘッダ・フィールドは、オプションで割り当てられた値を持つ 1 つ以上の cache-extension トークンを使用して拡張できます。情報拡張 (キャッシュの動作の変更を必要としないもの)は、他のディレクティブのセマンティクスを変更せずに追加してもよい[MAY]。挙動拡張は、既存のキャッシュディレクティブのベースの修飾子として動作するように設計されています。新しいディレクティブと標準ディレクティブの両方が提供され、新しいディレクティブを理解していないアプリケーションは標準ディレクティブで指定された動作をデフォルトとし、新しいディレクティブを理解しているアプリケーションは標準ディレクティブに関連した要求を修正したものとして認識します。このようにして、キャッシュ制御ディレクティブへの拡張は、基本プロトコルへの変更を必要とせずに行うことができます。この拡張メカニズムは、HTTP キャッシュがそのネイティブ HTTP バージョン用に定義されたすべてのキャッシュ制御ディレクティブに従うこと、特定の拡張に従うこと、そして理解できないすべてのディレクティブを無視することに依存します。例えば、private ディレクティブの修飾子として動作する community と呼ばれる仮定の新しいレスポンスディレクティブを考えてみましょう。この新しいディレクティブを定義すると、非共有キャッシュに加えて、その値の中で指定されたコミュニティのメンバーだけが 共有するキャッシュが応答をキャッシュすることができることを意味します。UCI コミュニティがプライベートなレスポンスを共有キャッシュで使用することを許可したいオリジンサーバは、 Cache-Control:private,community=&quot;UCI&quot; と記述することで、このヘッダフィールドを見たキャッシュは、たとえキャッシュがコミュニティのキャッシュ拡張を理解していなくても正しく動作します。認識されないキャッシュディレクティブは無視されなければなりません(MUST)。HTTP/1.1 キャッシュで認識されない可能性のあるキャッシュディレクティブは、キャッシュが拡張機能を理解していなくてもキャッシュの挙動が最小限正しいままになるように、標準ディレクティブ(あるいはレスポンスのデフォルトのキャッシュ可能性)と結合されると仮定されています。</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control ヘッダフィールドは、オプションの値を持つ 1 つ以上の cache-extension トークンを使用して拡張できます。キャッシュは認識されないキャッシュディレクティブを無視しなければならない[MUST]。情報拡張 (キャッシュの動作の変更を必要としないもの)は他のディレクティブのセマンティクスを変更することなく追加することができます。挙動拡張は既存のキャッシュディレクティブのベースの修飾子として動作するように設計されています。新しいディレクティブと古いディレクティブの両方が提供され、新しいディレクティブを理解していないアプリケーションは古いディレクティブで指定された動作をデフォルトとし、新しいディレクティブを理解しているアプリケーションは古いディレクティブに関連した要求を修正したものとして認識します。このようにして、既存のキャッシュ制御ディレクティブの拡張を、配備されたキャッシュを壊すことなく行うことができます。例えば、private ディレクティブの修飾子として動作する &quot;community&quot; と呼ばれる仮定の新しいレスポンスディレクティブを考えてみましょう。プライベートキャッシュに加えて、指定されたコミュニティのメンバーだけが共有するキャッシュは、応答をキャッシュすることを許可します。 UCI コミュニティがプライベートな応答を共有キャッシュで使用することを許可したいオリジンサーバは、Cache-Control:private,community=&quot;UCI&quot; を含めることでそれができます。コミュニティキャッシュ拡張を認識しないキャッシュは、それを無視して private ディレクティブに従います。</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="translated">カリフォルニア州消費者プライバシー法</target>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="translated">Chrome（またはChromium / Blinkベースのエンジン）のユーザーエージェント文字列は、Firefoxのものと似ています。互換性のために、 &lt;code&gt;KHTML, like Gecko&lt;/code&gt; や &lt;code&gt;Safari&lt;/code&gt; などのKHTMLなどの文字列を追加します。</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome(またはChromium/blinkベースのエンジン)のユーザーエージェント文字列は、Firefoxのフォーマットに似ています。互換性のために、「GeckoのようなKHTML」や「Safari」のような文字列を追加しています。</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">接続の一般ヘッダーフィールドを使用すると、送信者は、特定の接続に必要なオプションを指定できます。また、プロキシは、他の接続を介して通信してはいけません。 Connectionヘッダーの文法は次のとおりです。Connection = &quot;Connection&quot; &quot;：&quot; 1＃（connection-token）connection-token = token HTTP / 1.1プロキシは、メッセージが転送される前に、および各connection-tokenについて、Connectionヘッダーフィールドを解析する必要がありますこのフィールドで、接続トークンと同じ名前のメッセージからヘッダーフィールドを削除します。接続オプションは、対応する追加のヘッダーフィールドではなく、接続ヘッダーフィールドに接続トークンが存在することで通知されます。その接続オプションに関連付けられたパラメーターがない場合、追加のヘッダーフィールドが送信されない可能性があるためです。 Connectionヘッダーにリストされているメッセージヘッダーには、Cache-Controlなどのエンドツーエンドヘッダーを含めることはできません。 HTTP / 1.1は、送信者が応答の完了後に接続が閉じられることを通知する「閉じる」接続オプションを定義します。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（応答の完了後に接続が閉じられることを送信者が通知するための接続オプション。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（応答の完了後に接続が閉じられることを送信者が通知するための接続オプション。たとえば、接続：リクエストヘッダーフィールドまたは応答ヘッダーフィールドのいずれかを閉じると、接続は「永続的」と見なされるべきではない（SHOULD NOT）（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;）現在の要求/応答が完了した後。永続的な接続をサポートしないHTTP / 1.1アプリケーションは、すべてのメッセージに「閉じる」接続オプションを含める必要があります。接続ヘッダーを含むHTTP / 1.0（またはそれよりも低いバージョン）メッセージを受信するシステムは、このフィールドの各接続トークンについて、接続と同じ名前のメッセージからヘッダーフィールドを削除して無視する必要があります。トークン。これにより、HTTP / 1.1より前のプロキシによるこのようなヘッダーフィールドの誤った転送から保護されます。&lt;a href=&quot;#section-19.6.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">接続ヘッダーフィールド（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）は、現在の要求/応答ペアの後に接続を閉じたい場合に送信者が送信する必要がある「閉じる」接続オプションを提供します。 「閉じる」接続オプションを送信するクライアントは、その接続で（「閉じる」を含むものの後に）さらなる要求を送信してはならず（MUST）、この要求に対応する最終応答メッセージを読んだ後に接続を閉じなければなりません（MUST）。 「クローズ」接続オプションを受信したサーバーは、「クローズ」を含むリクエストへの最終応答を送信した後、接続のクローズ（下記参照）を開始する必要があります。サーバーは、その接続の最終応答で「クローズ」接続オプションを送信する必要があります（SHOULD）。サーバーは、その接続で受信したそれ以上の要求を処理してはなりません（MUST NOT）。 「を送信するサーバーclose &quot;接続オプションは、&quot; close &quot;を含む応答を送信した後、接続のクローズを開始する必要があります（以下を参照）。サーバーは、その接続で受信したそれ以上の要求を処理してはなりません。&quot; close &quot;接続オプションを受信するクライアントは停止する必要がありますその接続で要求を送信し、 &quot;close&quot;を含む応答メッセージを読み取った後、接続を閉じます。追加のパイプライン化された要求が接続で送信された場合、クライアントはそれらがサーバーで処理されることを想定してはなりません（SHOULD NOT）。 TCP接続をすぐに閉じると、クライアントが最後のHTTP応答を読み取ることができないという重大なリスクがあります。サーバーが完全に閉じた接続でクライアントから追加のデータを受信した場合、サーバーの応答を受信する前にクライアントによって送信された別の要求など、サーバーのTCPスタックはリセットパケットをクライアントに送信します。残念ながら、リセットパケットは、クライアントのHTTPパーサーによって読み取られ解釈される前に、クライアントの未確認の入力バッファーを消去する可能性があります。 TCPリセットの問題を回避するために、サーバーは通常、段階的に接続を閉じます。まず、サーバーは読み取り/書き込み接続の書き込み側のみを閉じることにより、ハーフクローズを実行します。次に、サーバーは、クライアントによる対応するクローズを受信するまで、またはサーバーが自身のTCPスタックがサーバーの最後の応答を含むパケットのクライアントの確認応答を受信したことを合理的に確信するまで、接続からの読み取りを続けます。最後に、サーバーは接続を完全に閉じます。リセットの問題がTCPに限定されているのか、それとも他のトランスポート接続プロトコルに見られるのかは不明です。</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">Content-Disposition応答ヘッダーフィールドは、ユーザーがコンテンツをファイルに保存することを要求した場合に、オリジンサーバーがデフォルトのファイル名を提案する手段として提案されています。この使用法は、Content-Dispositionのセキュリティ問題に関する&lt;a href=&quot;#section-15.5&quot;&gt;セクション15.5の&lt;/a&gt; Content-Dispositionの定義から派生しています。&lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt; RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt; 35の&lt;/a&gt;]。 content-disposition = &quot;Content-Disposition&quot; &quot;：&quot; disposition-type *（ &quot;;&quot; disposition-parm）disposition-type = &quot;attachment&quot; | disp-extension-token disposition-parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string disp-extension-token = token disp-extension-parm = token &quot;=&quot;（token | quoted-string）例はContent-Disposition：attachmentです; filename = &quot;fname.ext&quot;受信側のユーザーエージェントは、filename-parmパラメータに存在するディレクトリパス情報を考慮すべきではありません。これは、現時点でHTTP実装に適用されると考えられる唯一のパラメータです。ファイル名は端末コンポーネントとしてのみ扱われる必要があります（SHOULD）。このヘッダーがapplication / octet-stream content-typeの応答で使用される場合、暗黙の提案は、ユーザーエージェントが応答を表示するのではなく、「save response as ...」ダイアログに直接入力することです。見る</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">Content-Encodingエンティティヘッダーフィールドは、メディアタイプの修飾子として使用されます。存在する場合、その値は、エンティティ本体に適用されている追加のコンテンツコーディングを示します。したがって、Content-Typeヘッダーフィールドで参照されるメディアタイプを取得するために適用する必要があるデコードメカニズムを示します。Content-Encodingは主に、基になるメディアタイプのIDを失うことなくドキュメントを圧縮できるようにするために使用されます。Content-Encoding = &quot;Content-Encoding&quot; &quot;：&quot; 1＃content-codingコンテンツコーディングは、&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5でます&lt;/a&gt;。その使用例は、Content-Encoding：gzipです。content-codingは、Request-URIによって識別されるエンティティの特性です。通常、エンティティ本体はこのエンコーディングで格納され、レンダリングまたは類似の使用の前にのみデコードされます。ただし、「no-transform」キャッシュ制御ディレクティブがメッセージに存在しない限り、新しいコーディングが受信者に受け入れられることがわかっている場合、非透過プロキシはコンテンツコーディングを変更してもよい（MAY）。エンティティのコンテンツコーディングが「アイデンティティ」ではない場合、応答にはContent-Encodingエンティティヘッダー（&lt;a href=&quot;#section-14.11&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt; 14.11&lt;/a&gt;）使用される非アイデンティティコンテンツコーディングをリストします。リクエストメッセージ内のエンティティのコンテンツコーディングが配信元サーバーに受け入れられない場合、サーバーはステータスコード415（サポートされていないメディアタイプ）で応答する必要があります（SHOULD）。エンティティに複数のエンコーディングが適用されている場合、コンテンツコーディングは、それらが適用された順にリストされている必要があります。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のエンティティヘッダーフィールドによって提供される場合があります。</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Languageエンティティヘッダーフィールドは、囲まれたエンティティの対象読者の自然言語を記述します。これは、エンティティ本体で使用されるすべての言語と同等ではない場合があることに注意してください。Content-Language = &quot;Content-Language&quot; &quot;：&quot; 1＃language-tag言語タグは、&lt;a href=&quot;#section-3.10&quot;&gt;セクション3.10でます&lt;/a&gt;。 Content-Languageの主な目的は、ユーザーが自分の優先言語に従ってエンティティを識別および区別できるようにすることです。したがって、本文のコンテンツがデンマーク語の読み書きの対象者のみを対象としている場合、適切なフィールドはContent-Languageです。da Content-Languageが指定されていない場合、デフォルトではコンテンツはすべての言語の対象者を対象としています。これは、送信者がそれを自然言語に固有であると見なしていないこと、または送信者が意図する言語がわからないことを意味している可能性があります。複数の視聴者を対象とするコンテンツには、複数の言語がリストされる場合があります。たとえば、オリジナルのマオリ語と英語のバージョンで同時に提示された「ワイタンギの条約」の表現では、Content-Language：mi、ただし、エンティティ内に複数の言語が存在するからといって、それが複数の言語の対象者を対象としていることを意味するわけではありません。例としては、「ラテン語での最初のレッスン」などの初心者向けの言語入門があります。これは、明らかに英語の知識のある読者が使用することを目的としています。この場合、Content-Languageには「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。Content-Languageには、「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。Content-Languageには、「en」のみが適切に含まれます。 Content-Languageは、あらゆるメディアタイプに適用できます（テキストドキュメントに限定されません）。</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Lengthエンティティヘッダーフィールドは、10進数のOCTETで受信者に送信されたエンティティボディのサイズを示します。または、HEADメソッドの場合、送信されたはずのエンティティボディのサイズを示します。リクエストはGETでした。 Content-Length = &quot;Content-Length&quot; &quot;：&quot; 1 * DIGIT例はContent-Length：3495です。これは、&lt;a href=&quot;#section-4.4&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4の&lt;/a&gt;ルールで禁止されている場合を除き、このフィールドを使用してメッセージ本文の転送長を示す必要があります（SHOULD）。。ゼロ以上のContent-Lengthは有効な値です。 &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;Content-Lengthが指定されていない場合にメッセージ本文の長さを決定する方法について説明します。このフィールドの意味は、MIMEの対応する定義とは大きく異なります。MIMEでは、「message / external-body」コンテンツタイプ内で使用されるオプションのフィールドです。 HTTPでは、&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4の&lt;/a&gt;ルールで禁止されていない限り、転送前にメッセージの長さを決定できる場合は常に送信する必要があります 。</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Content-Locationエンティティヘッダーフィールドは、要求されたリソースのURIとは別の場所からエンティティにアクセスできる場合、メッセージに含まれるエンティティのリソースの場所を提供するために使用できます。サーバーは、応答エンティティに対応するバリアントのContent-Locationを提供する必要があります（SHOULD）。特に、リソースに複数のエンティティが関連付けられていて、それらのエンティティが実際に個別にアクセスできる個別の場所を持っている場合、サーバーは、返される特定のバリアントのContent-Locationを提供する必要があります（SHOULD）。 Content-Location = &quot;Content-Location&quot; &quot;：&quot;（absoluteURI | relativeURI）Content-Locationの値は、エンティティのベースURIも定義します。Content-Location値は、要求された元のURIの代わりにはなりません。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つのリクエストされたリソースから取得した複数のエンティティを区別できます。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つのリクエストされたリソースから取得した複数のエンティティを区別できます。これは、リクエスト時のこの特定のエンティティに対応するリソースの場所のステートメントにすぎません。将来のリクエストでは、特定のエンティティのソースを識別したい場合は、Content-Location URIをrequest-URIとして指定できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。キャッシュは、それを取得するために使用されたURIとは異なるContent-Locationを持つエンティティーが、そのContent-Location URIに対する以降の要求に応答するために使用できると想定することはできません。ただし、コンテンツの場所を使用して、1つの要求されたリソースから取得した複数のエンティティを区別できます。&lt;a href=&quot;#section-13.6&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;。Content-Locationが相対URIの場合、相対URIはRequest-URIに関連して解釈されます。PUTまたはPOSTリクエストのContent-Locationヘッダーの意味は定義されていません。これらの場合、サーバーは自由に無視できます。</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]で定義されている Content-MD5エンティティヘッダーフィールドは、エンティティボディのエンドツーエンドのメッセージ整合性チェック（MIC）を提供するためのエンティティボディのMD5ダイジェストです。（注：MICは、転送中のエンティティ本体の偶発的な変更を検出するのに適していますが、悪意のある攻撃に対する証拠ではありません。）Content-MD5 = &quot;Content-MD5&quot; &quot;：&quot; md5-digest md5-digest = &amp;lt;base64 of &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864に&lt;/a&gt;基づく128ビットMD5ダイジェスト&amp;gt; Content-MD5ヘッダーフィールドは、エンティティボディの整合性チェックとして機能するために、オリジンサーバーまたはクライアントによって生成される場合があります。起点サーバーまたはクライアントのみがContent-MD5ヘッダーフィールドを生成できます。プロキシとゲートウェイはそれを生成してはなりません。これは、エンドツーエンドの整合性チェックとしてその値を無効にするためです。ゲートウェイやプロキシを含むエンティティ本体の受信者は、このヘッダーフィールドのダイジェスト値が受信したエンティティ本体のダイジェスト値と一致することを確認できます（MAY）。 MD5ダイジェストは、エンティティ本体のコンテンツに基づいて計算されます。これには、適用されたコンテンツコーディングは含まれますが、メッセージ本体に適用された転送エンコーディングは含まれません。メッセージがtransfer-encodingで受信された場合、Content-MD5値を受信エンティティと照合する前に、そのエンコーディングを削除する必要があります。これは、ダイジェストがエンティティボディのオクテットで正確に計算され、転送エンコーディングが適用されていなかった場合に送信されるという結果になります。 HTTP拡張&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;MIMEコンポジットメディアタイプ（例：multipart / *およびmessage / rfc822）のダイジェストを計算できるようにしますが、前の段落で定義したようにダイジェストの計算方法は変わりません。これにはいくつかの影響があります。複合型のエンティティボディには、それぞれが独自のMIMEおよびHTTPヘッダー（Content-MD5、Content-Transfer-Encoding、およびContent-Encodingヘッダーを含む）を持つ多くのボディパーツを含めることができます（MAY）。 body-partにContent-Transfer- EncodingまたはContent-Encodingヘッダーがある場合、body-partのコンテンツにはエンコードが適用されていると見なされ、body-partはそのままContent-MD5ダイジェストに含まれます-つまり、アプリケーションの後。 Transfer-Encodingヘッダーフィールドは、body-parts内では許可されていません。すべての改行のCRLFへの変換は、ダイジェストを計算またはチェックする前に行わないでください。実際に送信されるテキストで使用される改行規則は、ダイジェストを計算するときに変更しないでください。注：Content-MD5の定義は、HTTPの場合とまったく同じです。&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;MIMEエンティティボディのRFC 1864では、Content-MD5のHTTPエンティティボディへの適用と、MIMEエンティティボディへの適用が異なるいくつかの方法があります。 1つは、MIMEとは異なり、HTTPはContent-Transfer-Encodingを使用せず、Transfer-EncodingとContent-Encodingを使用することです。もう1つは、HTTPがMIMEよりもバイナリコンテンツタイプをより頻繁に使用することです。そのため、そのような場合、ダイジェストの計算に使用されるバイトオーダーは、タイプに定義された送信バイトオーダーです。最後に、HTTPでは、CRLFを使用した標準形式だけでなく、いくつかの改行規則のいずれかを使用してテキストタイプを送信できます。</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Rangeエンティティヘッダーは、エンティティボディの一部とともに送信され、エンティティボディ全体のどこに部分ボディを適用するかを指定します。範囲の単位は&lt;a href=&quot;#section-3.12&quot;&gt;セクション3.12で&lt;/a&gt;定義されています。 Content-Range = &quot;Content-Range&quot; &quot;：&quot; content-range-spec content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec &quot; / &quot;（instance-length |&quot; * &quot;）byte-range-resp-spec =（first-byte-pos&quot;-&quot;last-byte-pos）| &quot;*&quot; instance-length = 1 * DIGITヘッダーは、この長さが不明であるか判別が困難でない限り、エンティティ本体全体の全長を示す必要があります（SHOULD）。アスタリスク「*」文字は、応答が生成された時点ではインスタンスの長さが不明であることを意味します。バイト範囲指定子の値とは異なり（&lt;a href=&quot;#section-14.35.1&quot;&gt;セクション14.35.1を&lt;/a&gt;参照））、byte-range-resp-specは1つの範囲のみを指定する必要があり、範囲の最初と最後の両方のバイトの絶対バイト位置を含める必要があります。 last-byte-posの値がfirst-byte-posの値よりも小さいか、instance-lengthの値が最後のバイト以下のbyte-range-resp-specを持つbyte-content-range-specバイト位置の値が無効です。無効なbyte-content-range- specの受信者は、それとそれとともに転送されるすべてのコンテンツを無視する必要があります。ステータスコード416（要求された範囲を満たしていない）で応答を送信するサーバーは、バイト範囲のresp-specが「*」のContent-Rangeフィールドを含める必要があります（SHOULD）。 instance-lengthは、選択されたリソースの現在の長さを指定します。ステータスコード206（部分的なコンテンツ）の応答には、byte-range- resp-specが &quot;*&quot;のContent-Rangeフィールドを含めてはなりません（MUST NOT）。エンティティに合計1234バイトが含まれていると仮定した場合の、byte-content-range-spec値の例：最初の500バイト：バイト0-499 / 1234。 2番目の500バイト：バイト500-999 / 1234。最初の500バイトを除くすべて：バイト500-1233 / 1234。最後の500バイト：バイト734-1233 / 1234 HTTPメッセージに単一の範囲のコンテンツが含まれている場合（たとえば、単一の範囲の要求への応答、または穴のない重複する一連の範囲の要求への応答） ）、このコンテンツはContent-Rangeヘッダー、および実際に転送されたバイト数を示すContent-Lengthヘッダーとともに送信されます。たとえば、HTTP / 1です。1 206部分的なコンテンツ日付：1995年11月15日水曜日06:25:24 GMT最終更新日：1995年11月15日水曜日04:58:08 GMTコンテンツ範囲：バイト21010-47021 / 47022コンテンツ長：26012コンテンツタイプ：image / gif HTTPメッセージに複数の範囲のコンテンツ（たとえば、重複しない複数の範囲に対する要求への応答）が含まれている場合、これらはマルチパートメッセージとして送信されます。この目的で使用されるマルチパートメディアタイプは、付録19.2で定義されている「multipart / byteranges」です。互換性の問題については、付録19.6.3を参照してください。単一の範囲の要求に対する応答は、multipart / byterangesメディアタイプを使用して送信してはなりません（MUST NOT）。結果が単一の範囲である複数の範囲に対する要求への応答は、1つの部分を持つmultipart / byterangesメディアタイプとして送信される場合があります。multipart / byterangesメッセージをデコードできないクライアントは、単一のリクエストで複数のバイト範囲を要求してはなりません（MUST NOT）。クライアントが1つの要求で複数のバイト範囲を要求すると、サーバーは、要求に現れた順序でそれらを返す必要があります（SHOULD）。構文的に無効であるためにサーバーがbyte-range-specを無視する場合、サーバーはリクエストを無効なRangeヘッダーフィールドが存在しないかのように処理する必要があります（SHOULD）。 （通常、これはエンティティ全体を含む200応答を返すことを意味します）。サーバーが要求（If- Range request-headerフィールドを含むものを除く）を、満たされないRange request-ヘッダーフィールド（つまり、すべてのbyte-range-spec値のfirst-byte-pos値が大きい）で受信した場合選択したリソースの現在の長さよりも）、応答コード416（要求された範囲を満足できない）を返す必要があります（&lt;a href=&quot;#section-10.4.17&quot;&gt;セクション10.4.17&lt;/a&gt;）。注：すべてのサーバーがこのリクエストヘッダーを実装しているわけではないため、クライアントはサーバーに依存して、満足できない範囲のリクエストヘッダーに対して200（OK）応答の代わりに416（要求された範囲が満足できない）応答を送信することはできません。</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Typeエンティティヘッダーフィールドは、受信者に送信されたエンティティボディのメディアタイプを示します。HEADメソッドの場合は、リクエストがGETであった場合に送信されるメディアタイプを示します。 Content-Type = &quot;Content-Type&quot; &quot;：&quot; media-typeメディアタイプは&lt;a href=&quot;#section-3.7&quot;&gt;セクション3.7で&lt;/a&gt;定義されています。フィールドの例はContent-Type：text / htmlです。 charset = ISO-8859-4エンティティのメディアタイプを識別する方法の詳細については、&lt;a href=&quot;#section-7.2.1&quot;&gt;セクション7.2.1を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Cross-Origin Resource Sharing標準は、サーバーがWebブラウザーを使用してその情報を読み取ることが許可されているオリジンのセットを記述できるようにする新しい&lt;a href=&quot;headers&quot;&gt;HTTPヘッダー&lt;/a&gt;を追加することで機能します。さらに、サーバーのデータに副作用を引き起こす可能性のあるHTTP要求メソッド（特に、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外のHTTPメソッド、または特定の&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;での&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;使用）の場合、仕様はブラウザーが要求を「プリフライト」し、サポートされているメソッドを要求することを義務付けています。 HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;要求メソッドを使用してサーバーから送信し、サーバーからの「承認」時に、実際のHTTP要求メソッドを使用して実際の要求を送信します。サーバーは、「資格情報」かどうかをクライアントに通知することもできます（ &lt;a href=&quot;cookies&quot;&gt;クッキーを含む&lt;/a&gt;HTTP認証データ）はリクエストとともに送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="translated">クロスオリジンリソースシェアリング標準は、サーバーがWebブラウザーからその情報を読み取ることを許可されているオリジンを記述できるようにする新しい&lt;a href=&quot;headers&quot;&gt;HTTPヘッダー&lt;/a&gt;を追加することによって機能します。さらに、サーバーデータに副作用を引き起こす可能性のあるHTTPリクエストメソッド（特に、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外のHTTPメソッド、または特定の&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIMEタイプの&lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;）の場合、仕様では、ブラウザーがリクエストを「プリフライト」し、サーバーからサポートされているメソッドを要求することを義務付けています。 HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;リクエストメソッドを使用し、サーバーからの「承認」時に実際のリクエストを送信します。サーバーは、「資格情報」（&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;や&lt;a href=&quot;authentication&quot;&gt;HTTP認証&lt;/a&gt;など）かどうかをクライアントに通知することもできます。）リクエストとともに送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">コレクション上のDELETEメソッドは、&quot;Depth:infinity &quot;ヘッダが使用されたかのように動作しなければならない[MUST]。クライアントは、無限大以外の値を持つコレクションに対してDELETEでDepthヘッダーを提出してはならない[MUST NOT]。DELETEは、Request-URIで指定されたコレクションと、その内部のメンバURLで識別されるすべてのリソー スを削除することを指示する。メンバーの URL で識別されるリソースを削除できない場合は、URL 名前空間の一貫性を維持するために、そのメンバーのすべての祖先を削除してはなりません[MUST NOT]。DELETE に含まれるヘッダは、削除されるすべてのリソースの処理に適用されなければなりません(MUST)。DELETE メソッドが処理を完了したとき、一貫性のある URL 名前空間が得られなければなりません[MUST]。メンバーリソース(Request-URI で識別されたリソース以外のリソース)の削除でエラーが発生した場合、レスポンスは 207 (Multi-Status)になります。Multi-Status は、どの内部リソースが削除できなかったかをエラーコードを含めて示すために使用され、クライアントはどのリソースが失敗の原因となったのかを理解するのに役立つ。例えば、内部リソースがロックされていた場合、Multi-Status ボディにはステータス 423 (Locked)の応答を含めることができる。リクエストが完全に失敗した場合、サーバーは 207ではなく4xxというステータス応答を返してもよい[MAY]。424 (Failed Dependency)のステータスコードは、DELETE の 207 (Multi-Status)応答に含めるべきではない[SHOULD NOT]。なぜなら、クライアントが祖先の子孫に対するエラーを受け取ったときに、クライアントはリソースの祖先が削除できなかったことを知ることになるからである。さらに、204 (No Content)エラーは 207 (Multi-Status)で返されるべきではない[SHOULD NOT]。この禁止の理由は、204 (No Content)がデフォルトの成功コードであるためである。</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETEメソッドは、オリジンサーバーにRequest-URIで特定されたリソースの削除を要求します。このメソッドはオリジンサーバーの人間の介入(または他の手段)によって上書きしてもよい[MAY]。オリジンサーバーから返されるステータスコードがアクションが正常に完了したことを 示していたとしても、クライアントは操作が実行されたことを保証できない。しかしながら、応答が与えられた時点で、サーバーがリソースを削除するか、 アクセスできない場所に移動することを意図しない限り、サーバーは成功を示すべきでは ない[SHOULD NOT]。成功した応答は、応答がステータスを記述するエンティティを含む場合は200 (OK)、アクションがまだ実行されていない場合は202(Accepted)、アクションが 実行されているが応答がエンティティを含まない場合は204(No Content)であるべきである[SHOULD]。リクエストがキャッシュを通過し、Request-URIが現在キャッシュされている1つ以上の エンティティを識別する場合、それらのエントリは古いものとして扱われるべきである [SHOULD]。このメソッドに対する応答はキャッシュできない。</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETEメソッドは、オリジンサーバーがターゲットリソースとその現在の機能の間の関連付けを削除することを要求します。実際、このメソッドはUNIXのrmコマンドに似ています。以前関連付けられていた情報が削除されるという期待ではなく、オリジンサーバーのURIマッピングに対する削除操作を表します。ターゲットリソースに1つまたは複数の現在の表現がある場合、リソースの性質とオリジンサーバーによる実装に完全に依存して、それらはオリジンサーバーによって破棄される場合とされない場合があり、関連するストレージが再利用される場合とされない場合があります（この仕様の範囲外です）。同様に、DELETEの結果として、リソースの他の実装の側面を非アクティブ化またはアーカイブする必要がある場合があります。データベースやゲートウェイ接続など。一般に、元のサーバーは、削除を実行するための所定のメカニズムを持つリソースに対してのみDELETEを許可すると想定されています。比較的少数のリソースでDELETEメソッドを使用できます。その主な用途は、ユーザーがその効果について何らかの指示を与えるリモートオーサリング環境です。たとえば、以前にPUTリクエストを使用して作成されたリソース、またはPOSTリクエストに対する201（Created）レスポンスの後にLocationヘッダーフィールドで識別されたリソースは、対応するDELETEリクエストでそれらのアクションを取り消すことができます。同様に、リモート操作にHTTPを使用するリビジョンコントロールクライアントなどのオーサリング機能を実装するカスタムユーザーエージェントの実装では、サーバーが■URIスペースは、バージョンリポジトリに対応するように作成されています。 DELETEメソッドが正常に適用された場合、オリジンサーバーは、アクションが成功する可能性が高いがまだ制定されていない場合は202（Accepted）ステータスコードを送信し、アクションが制定されている場合は204（No Content）ステータスコードを送信します。情報が提供されます。アクションが実行され、応答メッセージにステータスを表す表現が含まれている場合は、200（OK）ステータスコード。 DELETEリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。 DELETEリクエストでペイロード本体を送信すると、一部の既存の実装がリクエストを拒否する可能性があります。 DELETEメソッドへの応答はキャッシュできません。 DELETE要求が、有効な要求URIに対する1つ以上の応答が格納されているキャッシュを通過する場合、これらの保存された応答は無効になります（参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]のセクション4.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">Date general-headerフィールドは、メッセージが発信された日時を表し、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822の&lt;/a&gt; orig-dateと同じセマンティクスを持ってい ます。&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1で&lt;/a&gt;説明されているように、フィールド値はHTTP日付です。それを送らなければなりません&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-日付形式。日付= &quot;日付&quot; &quot;：&quot; HTTP-date例は日付：火、1994年11月15日08:12:31 GMTオリジンサーバーは、以下の場合を除いて、すべての応答に日付ヘッダーフィールドを含める必要があります。1.応答ステータスの場合コードが100（続行）または101（スイッチングプロトコル）の場合、サーバーのオプションで、応答に日付ヘッダーフィールドを含めることができます（MAY）。 2.応答ステータスコードが500（内部サーバーエラー）や503（サービス利用不可）などのサーバーエラーを伝え、有効な日付を生成することが不便または不可能である場合。 3.サーバーが現在の時刻の妥当な概算を提供できるクロックを備えていない場合、その応答に日付ヘッダーフィールドを含めてはなりません（MUST NOT）。この場合、&lt;a href=&quot;#section-14.18.1&quot;&gt;セクション14.18.1のルール&lt;/a&gt;従わなければなりません。メッセージがその受信者によってキャッシュされるか、または日付を必要とするプロトコルを介してゲートウェイ処理される場合は、Dateヘッダーフィールドを持たない受信メッセージに受信者が割り当てる必要があります。クロックのないHTTP実装は、使用するたびに再検証せずに応答をキャッシュしてはなりません（MUST NOT）。 HTTPキャッシュ、特に共有キャッシュでは、NTPなどのメカニズムを使用する必要があります[ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;]、そのクロックを信頼できる外部標準と同期させます。クライアントは、PUTおよびPOSTリクエストの場合のように、エンティティボディを含むメッセージで日付ヘッダーフィールドのみを送信する必要があります（SHOULD）。それでもオプションです。クロックのないクライアントは、リクエストで日付ヘッダーフィールドを送信してはなりません（MUST NOT）。 Dateヘッダーで送信されるHTTP日付は、メッセージの生成後の日付と時刻を表すべきではありません（SHOULD NOT）。これは、実装が合理的に正確な日付と時刻を生成する手段を持っていない場合を除き、メッセージ生成の日付と時刻の利用可能な最良の概算を表す必要があります。理論的には、日付はエンティティが生成される直前の瞬間を表す必要があります。実際には、日付は、メッセージのセマンティック値に影響を与えることなく、メッセージの発信中にいつでも生成できます。</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">Depth ヘッダは LOCK メソッドで使用できる。0 または無限大以外の値は、LOCK メ ソッドのDepth ヘッダーで使用してはならない[MUST NOT]。LOCK メソッドをサポートするすべてのリソースは、Depth ヘッダをサポートしなければならない[MUST]。値0のDepthヘッダーは、Request-URIで指定されたリソースを単にロックすることを意味する。Depthヘッダーが無限大に設定されている場合、Request-URIで指定されたリソー スとそのすべてのメンバ(階層の下のすべての階層)がロックされる。結果が成功した場合、1つのロックトークンを返さなければならない[MUST]。同様に、このトークンに対してUNLOCKが成功した場合、関連するすべてのリソースはロック解除されます。したがって、LOCK や UNLOCK には部分的な成功は許されない。階層全体がロックされているか、リソースがロックされていないかのどちらかになります。すべてのリソースに対してロックを付与できなかった場合、サーバは、ロックが付与されなかった少なくとも 1 つのリソースの「response」要素を含む Multi-Status レスポンスを、その失敗に適したステータスコード (403 (Forbidden)や 423 (Locked)など)とともに返さなければならない[MUST]。さらに、失敗の原因となったリソースがリクエストされたリソースではない場合、 サーバーはRequest-URIに対しても同様に、Failed Dependencyを含む「status」要素を含む「response」 要素を含めるべきである[SHOULD]。LOCKリクエストでDepthヘッダーがサブミットされない場合、リクエストは 「Depth:infinity」がサブミットされたかのように動作しなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Destinationリクエストヘッダーは、2つのURIをパラメーターとして受け取るCOPYやMOVEなどのメソッドの宛先リソースを識別するURIを指定します。 Destination = &quot;Destination&quot; &quot;：&quot; Simple-ref Destinationの値が絶対URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]のセクション4.3&lt;/a&gt;）の場合、別のサーバー（または別のポートやスキーム）を指定する場合があります。ソースサーバーがリモートサーバーへのコピーを試行できない場合、要求は失敗する必要があります。リソースをリモートサーバーにコピーおよび移動することは、この仕様では完全には定義されていません（たとえば、特定のエラー条件）。 Destination値が長すぎるか、それ以外の場合は受け入れられない場合、サーバーはエラー本文に役立つ情報を含めて、理想的には400（Bad Request）を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETagレスポンスヘッダーフィールドは、リクエストされたバリアントのエンティティタグの現在の値を提供します。エンティティタグと共に使用されるヘッダはセクションに記載されており&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;、&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;及び&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。エンティティタグは、同じリソースの他のエンティティとの比較に使用できます（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を&lt;/a&gt;参照）。 ETag = &quot;ETag&quot; &quot;：&quot;エンティティタグ例：ETag： &quot;xyzzy&quot; ETag：W / &quot;xyzzy&quot; ETag： &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">ETag応答ヘッダーフィールドの値であるエンティティタグは、「不透明な」キャッシュバリデーターを提供します。これにより、HTTP日付値の1秒の解決では不十分な場合、または元のサーバーが変更日付の使用から生じる可能性がある特定のパラドックスを回避したい場合に、変更日付を保存するのが不便な状況で、より信頼できる検証が可能になります。 。エンティティタグについては、&lt;a href=&quot;#section-3.11&quot;&gt;セクション3.11で&lt;/a&gt;説明しています。エンティティタグと共に使用されるヘッダはセクションに記載されており&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;、&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;、&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;及び&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expectリクエストヘッダーフィールドは、特定のサーバー動作がクライアントに必要であることを示すために使用されます。 Expect = &quot;Expect&quot; &quot;：&quot; 1＃expectation expectation = &quot;100-continue&quot; | expectation-extension expectation-extension = token [&quot;=&quot;（token | quoted-string）* expect-params] expect-params = &quot;;&quot;トークン[&quot;=&quot;（トークン| quoted-string）]リクエストのExpectフィールドの期待値を理解できないか、またはそれらに準拠できないサーバーは、適切なエラーステータスで応答する必要があります。サーバーは、期待値のいずれかが満たされない場合、または要求に他の問題がある場合、他の4xxステータスがある場合、417（期待値失敗）ステータスで応答する必要があります。このヘッダーフィールドは、将来の拡張に備えて拡張可能な構文で定義されています。サーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る見る見る見る見る見る見るサーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見るサーバーが、サポートしていないExpectation-Extensionを含むExpectフィールドを含むリクエストを受信した場合、サーバーは417（Expectation Failed）ステータスで応答する必要があります。期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る見る見る期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る期待値の比較は、引用符で囲まれていないトークン（100継続トークンを含む）では大文字と小文字が区別されず、引用符で囲まれた文字列の期待値拡張では大文字と小文字が区別されます。 Expectメカニズムはホップバイホップです。つまり、HTTP / 1.1プロキシは、満たすことができないという期待のある要求を受け取った場合、417（Expectation Failed）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る1つのプロキシは、満たすことができないという期待のある要求を受け取った場合、417（期待失敗）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る1つのプロキシは、満たすことができないという期待のある要求を受け取った場合、417（期待失敗）ステータスを返さなければなりません（MUST）。ただし、Expectリクエストヘッダー自体はエンドツーエンドです。リクエストが転送される場合は、転送する必要があります。古いHTTP / 1.0およびHTTP / 1.1アプリケーションの多くは、Expectヘッダーを理解していません。見る&lt;a href=&quot;#section-8.2.3&quot;&gt;&lt;/a&gt;100（継続）ステータスの使用については、セクション8.2.3。</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expiresエンティティヘッダーフィールドは、応答が古くなったと見なされるまでの日時を示します。古いキャッシュエントリは通常、最初にオリジンサーバー（またはエンティティの新しいコピーを持つ中間キャッシュ）で検証されない限り、キャッシュ（プロキシキャッシュまたはユーザーエージェントキャッシュ）によって返されない場合があります。有効期限モデルの詳細については、&lt;a href=&quot;#section-13.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;を参照してください。Expiresフィールドの存在は、元のリソースがその時点で、前に、または後に変更または存在しなくなることを意味しません。形式は、&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1の&lt;/a&gt; HTTP-dateで定義されている絶対日時 です。&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;にある必要があります日付形式：Expires = &quot;Expires&quot; &quot;：&quot; HTTP-date使用例はExpires：Thu、01 Dec 1994 16:00:00 GMT注：応答にmax-ageディレクティブのCache-Controlフィールドが含まれている場合（&lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3を&lt;/a&gt;参照）、そのディレクティブはExpiresフィールドをオーバーライドします。 HTTP / 1.1クライアントとキャッシュは、他の無効な日付形式、特に過去のように値「0」を含む（つまり、「期限切れ」）を扱わなければなりません（MUST）。応答を「期限切れ」としてマークするために、オリジンサーバーはDateヘッダー値と等しいExpires日付を送信します。 （&lt;a href=&quot;#section-13.2.4&quot;&gt;セクション13.2.4の&lt;/a&gt;有効期限計算のルールを参照してください。）応答に「有効期限なし」のマークを付けるために、オリジンサーバーは、応答が送信されてから約1年後にExpires日付を送信します。 HTTP / 1.1サーバーは、1年以上先のExpires日付を送信してはなりません（SHOULD NOT）。そうでなければデフォルトでキャッシュ不可になるであろう応答の将来の日付の値を持つExpiresヘッダーフィールドが存在することは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;）で特に示されていない限り、応答がキャッシュ可能であることを示します。。</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="translated">&lt;code&gt;allowlist&lt;/code&gt; を適用する機能ポリシーディレクティブ。許可されるディレクティブ名のリストについては、以下の&lt;a href=&quot;#Directives&quot;&gt;ディレクティブを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">Feature-Policy HTTP ヘッダ</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">From request-headerフィールドが指定されている場合、SHOULDには、要求しているユーザーエージェントを制御する人間のユーザーのインターネット電子メールアドレスが含まれている必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8で&lt;/a&gt;更新された&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]の「メールボックス」で定義されているように、アドレスはマシンで使用できる必要があります（SHOULD）。]：From = &quot;From&quot; &quot;：&quot;メールボックス例は次のとおりです。From：webmaster@w3.orgこのヘッダーフィールドは、ログ記録の目的で、無効なリクエストや不要なリクエストのソースを特定する手段として使用できます。安全でない形式のアクセス保護として使用しないでください。このフィールドの解釈は、実行されたメソッドの責任を受け入れる、指定された人に代わってリクエストが実行されているということです。特に、ロボットエージェントには、受信側で問題が発生した場合にロボットの実行責任者に連絡できるように、このヘッダーを含める必要があります（SHOULD）。このフィールドのインターネット電子メールアドレスは、要求を発行したインターネットホストとは別の場合があります。たとえば、リクエストがプロキシを介して渡されると、元の発行者の■アドレスを使用する必要があります。クライアントは、ユーザーのプライバシー上の関心やサイトのセキュリティポリシーと競合する可能性があるため、ユーザーの承認なしにFromヘッダーフィールドを送信しないでください。ユーザーがリクエストの前にいつでもこのフィールドの値を無効化、有効化、および変更できるようにすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GETメソッドは、Request-URIで識別される情報（エンティティーの形式）を取得します。 Request-URIがデータ生成プロセスを参照する場合、そのテキストがたまたまプロセスの出力でない限り、プロセスのソーステキストではなく、応答のエンティティとして返されるのは生成されたデータです。リクエストメッセージにIf-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match、またはIf-Rangeヘッダーフィールドが含まれている場合、GETメソッドのセマンティクスは「条件付きGET」に変わります。条件付きGETメソッドは、条件付きヘッダーフィールドで記述された状況でのみエンティティを転送するよう要求します。条件付きGETメソッドは、複数のリクエストを要求したり、クライアントがすでに保持しているデータを転送したりせずに、キャッシュされたエンティティを更新できるようにすることで、不要なネットワーク使用量を減らすことを目的としています。リクエストメッセージにRangeヘッダーフィールドが含まれている場合、GETメソッドのセマンティクスは「部分的なGET」に変わります。部分的なGETは、エンティティの一部のみを転送するように要求します。&lt;a href=&quot;#section-14.35&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;。部分的なGETメソッドは、クライアントがすでに保持しているデータを転送せずに部分的に取得されたエンティティを完了できるようにすることで、不要なネットワーク使用量を減らすことを目的としています。 GET要求への応答は、&lt;a href=&quot;#section-13&quot;&gt;セクション13で&lt;/a&gt;説明されているHTTPキャッシングの要件を満たしている場合にのみキャッシュ可能です。フォームに使用する場合のセキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GETメソッドは、ターゲットリソースの現在選択されている表現の転送を要求します。 GETは情報検索の主要なメカニズムであり、ほとんどすべてのパフォーマンス最適化の焦点です。したがって、人々がHTTPを介して特定の情報を取得することについて話すとき、彼らは一般にGETリクエストを行うことを指します。リソース識別子をリモートファイルシステムのパス名として、表現をそのようなファイルの内容のコピーとして考えるのは魅力的です。実際、これが実装されているリソースの数です（&lt;a href=&quot;#section-9.1&quot;&gt;9.1項を&lt;/a&gt;参照）。 関連するセキュリティ上の考慮事項について）。ただし、実際にはそのような制限はありません。リソースのHTTPインターフェースは、コンテンツオブジェクトのツリー、さまざまなデータベースレコードのプログラムビュー、または他の情報システムへのゲートウェイとして実装される可能性が高いです。 URIマッピングメカニズムがファイルシステムに関連付けられている場合でも、ファイルを直接転送するのではなく、要求を入力としてファイルを実行し、表現として出力を送信するようにオリジンサーバーが構成されている場合があります。いずれにせよ、オリジンサーバーだけが、そのリソース識別子が実装にどのように対応するか、および各実装がGETへの応答でターゲットリソースの現在の表現を選択して送信する方法を知る必要があります。クライアントは、GETのセマンティクスを「」に変更できますリクエストでRangeヘッダーフィールドを送信して、選択された表現の一部のみの転送をリクエストします。&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]）。GETリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。GETリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する場合があります。GET要求への応答はキャッシュ可能です。キャッシュは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2）で&lt;/a&gt;特に示されていない限り、後続のGETおよびHEAD要求を満たすためにそれを使用できます（MAY ）。</target>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="translated">欧州連合における一般データプライバシー規制(GDPR)について</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEADメソッドはGETと同じであるが、サーバは応答中にメッセージボディを返してはならない[MUST NOT]。HEADリクエストに対する応答のHTTPヘッダーに含まれるメタ情報は、 GETリクエストに対する応答で送られた情報と同じであるべきである[SHOULD]。このメソッドは、エンティティボディ自体を転送することなく、リクエストが暗示する エンティティに関するメタ情報を取得するために使用できる。この方法は、ハイパーテキストリンクの有効性、アクセシビリティ、最近の変更のテストによく使われる。HEADリクエストに対する応答は、応答に含まれる情報をそのリソースから以前にキャッシュされた エンティティを更新するために使用してもよい[MAY]という意味で、キャッシュ可能であってもよい[MAY]。新しいフィールド値がキャッシュされたエンティティが現在のエンティティと異なることを示す場合(Content-Length、Content-MD5、ETag、Last-Modifiedの変更によって示されるような)、キャッシュはキャッシュエントリをstaleとして扱わなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEADメソッドは、サーバーが応答でメッセージ本文を送信してはならないこと（つまり、応答がヘッダーセクションの終わりで終了すること）を除いて、GETと同じです。サーバーは、リクエストがGETであった場合に送信されたのと同じヘッダーフィールドを、ペイロードヘッダーフィールド（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;）省略してもかまいません。このメソッドは、表現データを転送せずに選択した表現に関するメタデータを取得するために使用でき、有効性、アクセシビリティ、および最近の変更についてハイパーテキストリンクをテストするためによく使用されます。 HEADリクエストメッセージ内のペイロードには、セマンティクスが定義されていません。 HEADリクエストでペイロードボディを送信すると、一部の既存の実装がリクエストを拒否する可能性があります。 HEAD要求への応答はキャッシュ可能です。キャッシュは、Cache-Controlヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]のセクション5.2）で&lt;/a&gt;特に示されていない限り、後続のHEAD要求を満たすためにそれを使用できます（MAY ）。 HEAD応答は、以前にキャッシュされたGETへの応答にも影響を与える可能性があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]のセクション4.3.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; のHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページがHTTPSを使用している場合に、HTTPを介したアセットの読み込みを防ぎます。</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、HTTPSを使用してページが読み込まれるときに、HTTPを使用してアセットが読み込まれないようにします。</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、他のCSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下の各ディレクティブについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;を使用してロードされたフォントの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ディレクティブは、特定のコンテキストからのフォーム送信のターゲットとして使用できるURLを制限します。</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用してページを埋め込むことができる有効な親を指定します。</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれるネストされたブラウジングコンテキストの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ロードできるリソースのタイプを制限することにより、ドキュメントに埋め込むことができるプラグインのセットを制限します。</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTPの&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; ディレクティブの情報を指定するために使用さ&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;（シングルとヘッダ &lt;code&gt;r&lt;/code&gt; のページからのリンクについては、これはオリジナルの仕様でタイプミスだったように）。このAPIは廃止され、ブラウザから削除されました。</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性と同様に、要求されたリソースのサンドボックスを有効にします。ポップアップの防止、プラグインとスクリプトの実行の防止、同じ生成元のポリシーの適用など、ページのアクションに制限を適用します。</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、JavaScriptの有効なソースを指定します。これには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に直接読み込まれたURLだけでなく、インラインスクリプトイベントハンドラー（ &lt;code&gt;onclick&lt;/code&gt; ）やスクリプトの実行をトリガーできる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLTスタイルシート&lt;/a&gt;なども含まれます。</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; ディレクティブは、サイトのすべての安全でないURL（HTTP経由で提供される）が安全なURL（HTTPS経由で提供される）に置き換えられたかのように扱うようにユーザーエージェントに指示します。このディレクティブは、書き換えが必要な安全でないレガシーURLが多数あるWebサイトを対象としています。</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;スクリプトの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求は、ユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;default-src&lt;/code&gt; ディレクティブは、他のCSP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下のディレクティブのそれぞれについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;style-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページ上のスクリプトまたはスタイルに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;サブリソース整合性&lt;/a&gt;の使用を要求するようにクライアントに指示します。</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ディレクティブは、ドキュメントの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素で使用できるURLを制限します。この値がない場合、任意のURIが許可されます。このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の値を使用します。</target>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアの自動再生を許可されるかどうかを制御します。このポリシーが有効で、ユーザージェスチャがない場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素の &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアを自動再生できるかどうかを制御します。このポリシーが有効で、ユーザージェスチャーがなかった場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の &lt;code&gt;autoplay&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;で返さ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;を拒否します&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt; &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;document-domain&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;を設定できるかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;を設定しようとすると失敗し、 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）の使用を許可するかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;fullscreen&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;geolocation&lt;/code&gt; 、現在の文書が使用を許可されているかどうかを指示コントロール&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;インタフェース。このポリシーが有効な場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt;を呼び出すと、これらの関数のコールバックが &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;コードで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;microphone&lt;/code&gt; ディレクティブは、現在のドキュメントがオーディオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;midi&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターが &lt;code&gt;SecurityError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVRAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーフィールドの &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;支払い要求APIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーが無効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターはSyntaxErrorをスローし&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; ディレクティブは、HTTPSを使用してページが読み込まれるときに、HTTPを使用してアセットが読み込まれないようにします。</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スクリプトインターフェイスを使用してロードできるURLを制限します。制限されているAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、他のCSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;フェッチディレクティブの&lt;/a&gt;フォールバックとして機能します。存在しない以下の各ディレクティブについて、ユーザーエージェントは &lt;code&gt;default-src&lt;/code&gt; ディレクティブを探し、この値を使用します。</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;を使用してロードされたフォントの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ディレクティブは、特定のコンテキストからのフォーム送信のターゲットとして使用できるURLを制限します。</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用してページを埋め込むことができる有効な親を指定します。</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれるネストされたブラウジングコンテキストの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用してメディアをロードするための有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ロードできるリソースのタイプを制限することにより、ドキュメントに埋め込むことができるプラグインのセットを制限します。</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTPの&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; ディレクティブの情報を指定するために使用さ&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;（シングルとヘッダ &lt;code&gt;r&lt;/code&gt; のページからのリンクについては、これはオリジナルの仕様でタイプミスだったように）。このAPIは廃止され、ブラウザから削除されました。</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性と同様に、要求されたリソースのサンドボックスを有効にします。ポップアップの防止、プラグインとスクリプトの実行の防止、同じ生成元のポリシーの適用など、ページのアクションに制限を適用します。</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、JavaScriptの有効なソースを指定します。これには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に直接読み込まれたURLだけでなく、インラインスクリプトイベントハンドラー（ &lt;code&gt;onclick&lt;/code&gt; ）やスクリプトの実行をトリガーできる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLTスタイルシート&lt;/a&gt;なども含まれます。</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートのソースの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、スタイルシートの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP）の &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; ディレクティブは、サイトのすべての安全でないURL（HTTP経由で提供される）が安全なURL（HTTPS経由で提供される）に置き換えられたかのように扱うようにユーザーエージェントに指示します。このディレクティブは、書き換えが必要な安全でないレガシーURLが多数あるWebサイトを対象としています。</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;スクリプトの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、リソースに適用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;マニフェスト&lt;/a&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、画像とファビコンの有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の有効なソースを指定します。</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; ディレクティブは、ページ上のスクリプトまたはスタイルに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;サブリソース整合性&lt;/a&gt;の使用を要求するようにクライアントに指示します。</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ディレクティブは、ドキュメントの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素で使用できるURLを制限します。この値がない場合、任意のURIが許可されます。このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の値を使用します。</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;autoplay&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;インターフェイスを介して要求されたメディアの自動再生を許可されるかどうかを制御します。このポリシーが有効で、ユーザージェスチャがない場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と&amp;lt;video&amp;gt;要素の &lt;code&gt;autoplay&lt;/code&gt; 属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;camera&lt;/code&gt; ディレクティブは、現在のドキュメントがビデオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;で返さ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;を拒否します &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;document-domain&lt;/code&gt; ディレクティブは、現在のドキュメントでdocument.domainの設定を許可するかどうかを制御し&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;。このポリシーが有効になっている場合は、設定しようとし&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; をすることは&lt;/a&gt;できないと発生します &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;スローされます。</target>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;encrypted-media&lt;/code&gt; ディレクティブは、現在のドキュメントで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）の使用を許可するかどうかを制御します。このポリシーが有効になっている場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーの &lt;code&gt;fullscreen&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;を使用できるかどうかを制御します。このポリシーを有効にすると、返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; で&lt;/a&gt;拒否されます。</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;geolocation&lt;/code&gt; 、現在の文書が使用を許可されているかどうかを指示コントロール&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;インタフェース。このポリシーが有効な場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt;を呼び出すと、これらの関数のコールバックが &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;コードで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;microphone&lt;/code&gt; ディレクティブは、現在のドキュメントがオーディオ入力デバイスの使用を許可されるかどうかを制御します。このポリシーを有効にすると、 &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;がNotAllowedErrorで拒否されます。</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;midi&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDIAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;payment&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment RequestAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;コンストラクターは &lt;code&gt;SecurityError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダー &lt;code&gt;vr&lt;/code&gt; ディレクティブは、現在のドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVRAPIの&lt;/a&gt;使用を許可されるかどうかを制御します。このポリシーを有効にすると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;によって返される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;DOMException&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;メソッドは、ドキュメントの完全な置換のみを許可します。 &lt;code&gt;PUT&lt;/code&gt; とは異なり、 &lt;code&gt;PATCH&lt;/code&gt; はべき等ではありません。つまり、連続する同一のパッチリクエストは異なる効果を持つ&lt;em&gt;可能性&lt;/em&gt;があります。ただし、べき等になるように &lt;code&gt;PATCH&lt;/code&gt; リクエストを発行することは可能です。</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 情報ステータス応答コードは、これまでのところすべてが問題なく、クライアントが要求を続行するか、すでに完了している場合は無視する必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 成功ステータス応答コードは、リクエストが成功したことを示します。200応答はデフォルトでキャッシュ可能です。</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 成功ステータスレスポンスコードは、リクエストが成功し、リソースが作成されたことを示します。新しいリソースは、この応答が返送される前に効果的に作成され、メッセージの本文で新しいリソースが返されます。その場所は、リクエストのURLまたは&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーのコンテンツです。</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 応答ステータスは、要求は成功したが、囲まれたペイロードが、オリジンサーバーの&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;から変換プロキシによって変更されたことを示します。</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 応答ステータスは、リクエストは成功したが、囲まれたペイロードが、変換&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;によって元のサーバーの&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答のペイロードから変更されたことを示します。</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 成功ステータス応答コードは、リクエストは成功したが、クライアントが現在のページから離れる必要がないことを示します。デフォルトでは、204応答はキャッシュ可能です。AN &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ヘッダは、Aの応答に含まれています。</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 応答ステータスは、クライアントにドキュメントビューをリセットするように指示します。たとえば、フォームのコンテンツをクリアしたり、キャンバスの状態をリセットしたり、UIを更新したりします。</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 成功ステータス応答コードは、リクエストが成功し、リクエストの&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーで説明されているように、リクエストされたデータの範囲が本文に含まれていることを示します。</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; クライアントエラーステータス応答コードは、ターゲットリソースの有効な認証資格情報がないため、要求が適用されなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; クライアントエラーステータス応答コードは、サーバーが要求を理解したが、承認を拒否したことを示しています。</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; クライアントエラーステータス応答コードは、要求されたリソースにアクセスできるブラウザーとサーバーの間にある&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;プロキシサーバーの&lt;/a&gt;有効な認証資格情報がないため、要求が適用されなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; クライアントエラー応答コードは、リクエストの&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt;ヘッダーで指定された期待に応えられなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error応答コードは、サーバーがティーポットであるため、サーバーがコーヒーの淹れ方を拒否することを示しています。このエラーは、1998年にエイプリルフールのジョークであったハイパーテキストコーヒーポットコントロールプロトコルの参照です。</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; clientエラー応答コードは、サーバーが永続的にティーポットであるため、コーヒーの淹れ方を拒否したことを示しています。一時的にコーヒーがなくなったコーヒーとティーポットを組み合わせると、代わりに503が返されます。このエラーは、1998年と2014年のエイプリルフールのジョークで定義されたハイパーテキストコーヒーポットコントロールプロトコルへの参照です。</target>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 応答コードは、&lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;要求ヘッダーを含むメッセージを送信したクライアントからの要求に応じて、サーバーが切り替えているプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 応答コードは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;リクエストヘッダーを含むメッセージを送信したクライアントからの要求に応じて、サーバーが切り替えるプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、リクエストに複数の可能な応答があることを示しています。ユーザーエージェントまたはユーザーは、それらのいずれかを選択する必要があります。応答の1つを選択する標準化された方法がないため、この応答コードはほとんど使用されません。</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; クライアントリダイレクト応答コードは、要求されたリソースを再送信する必要がないことを示しています。これは、キャッシュされたリソースへの暗黙的なリダイレクトです。これは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;リクエストのようにリクエストメソッドが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全&lt;/a&gt;である場合、またはリクエストが条件付きで&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;ヘッダーを使用している場合に発生します。</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求されたリソースを見つけることができないことを示しています。404ページにつながるリンクは、多くの場合、壊れたのか死んでリンクと呼ばれ、対象とすることができ&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;リンク切れ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求されたリソースを見つけられないことを示します。404ページにつながるリンクは、多くの場合、リンク切れまたはデッドリンクと呼ばれ、&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;リンクの腐敗の&lt;/a&gt;影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、リクエストがサーバーの現在の状態と競合していることを示します。</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求がターゲットリソースの現在の状態と競合していることを示します。</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求エンティティがサーバーによって定義された制限よりも大きいことを示します。サーバーが接続を閉じるか、&lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt;ヘッダーフィールドを返す場合があります。</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントがリクエストしたURIが、サーバーが解釈するよりも長いことを示しています。</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">ペイロード形式がサポートされていない形式であるため、HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが要求の受け入れを拒否したことを示します。</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; クライアントエラーレスポンスコードは、サーバーが現在のプロトコルを使用してリクエストを実行することを拒否しているが、クライアントが別のプロトコルにアップグレードした後に実行する可能性があることを示します。</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、サーバーがリクエストを&lt;a href=&quot;../conditional_requests&quot;&gt;条件付きに&lt;/a&gt;する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、ユーザーが指定された時間内に送信したリクエストが多すぎることを示します（「レート制限」）。</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; が大きすぎますレスポンスステータスコードは、ヘッダーフィールドが大きすぎるため、サーバーがリクエストを処理したくないことを示します。リクエストヘッダーフィールドのサイズを小さくした後、リクエストを再送信できます。</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; が大きすぎる応答ステータスコードは、要求の&lt;a href=&quot;../headers&quot;&gt;HTTPヘッダー&lt;/a&gt;が長すぎるため、サーバーが要求の処理を拒否したことを示します。要求が&lt;em&gt;よい&lt;/em&gt;リクエストヘッダのサイズを小さくした後に再送信されます。</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントがネットワークアクセスを得るために認証する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーは、ピン留め違反の &lt;code&gt;report-uri&lt;/code&gt; ヘッダーで指定されたreport-uriに送信しますが、&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;とは異なり、ピン留めに違反した場合でもブラウザーはサーバーに接続できます。</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーを使用して、ピンニング違反の &lt;code&gt;report-uri&lt;/code&gt; ヘッダーで指定されたreport-uriに送信しましたが、&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;とは異なり、ピンニングが違反しました。HPKPのサポートが削除されたため、最近のブラウザーではヘッダーは黙って無視されます。代わりに、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;と&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してください。</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 応答ヘッダーは、特定の暗号化公開&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;鍵&lt;/a&gt;を特定のWebサーバーに関連付け、偽造された証明書による&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻撃のリスクを軽減します。1つまたは複数のキーが固定されていて、それらのいずれもサーバーで使用されていない場合、ブラウザは正当なものとして応答を受け入れず、表示しません。</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">特定の暗号化公開&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;鍵&lt;/a&gt;を特定のWebサーバーに関連付けて、偽造された証明書による&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻撃のリスクを軽減するために使用される、HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 応答ヘッダー。ただし、最新のブラウザーから削除され、サポートされなくなりました。代わりに、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;証明書の透明性&lt;/a&gt;と&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してください。</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; リクエストヘッダーには、サーバーでユーザーエージェントを認証するための認証情報が含まれています。通常、サーバーが&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ステータスと&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後です。</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 要求ヘッダーには、サーバーが&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ステータスと&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後、通常はサーバーでユーザーエージェントを認証するための資格情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 応答ヘッダーを使用すると、Web開発者はポリシーの効果を監視する（ただし強制しない）ことでポリシーを試すことができます。これらの違反レポートは、HTTP &lt;code&gt;POST&lt;/code&gt; リクエストを介して指定されたURIに送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;ドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 応答ヘッダーを使用すると、Webサイト管理者は、ユーザーエージェントが特定のページに対してロードできるリソースを制御できます。いくつかの例外はありますが、ポリシーには主にサーバーの起点とスクリプトのエンドポイントの指定が含まれます。これは、クロスサイトスクリプティング攻撃（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）を防ぐのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーは、独自のフレーム、およびドキュメント内の任意の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;要素内のコンテンツでのブラウザー機能の使用を許可および拒否するメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; ヘッダーは、独自のフレーム、およびそれが埋め込むiframeでのブラウザー機能の使用を許可および拒否するメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 応答ヘッダーは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;プロキシサーバーの&lt;/a&gt;背後にあるリソースにアクセスするために使用する認証方法を定義します。プロキシサーバーに対して要求を認証し、要求をさらに送信できるようにします。</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; リクエストヘッダーには、プロキシサーバーに対してユーザーエージェントを認証するための認証情報が含まれています。通常、サーバーが&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; ステータスと&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーで応答した後です。</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 要求ヘッダーは、暗号化および認証された応答に対するクライアントの設定を表す信号をサーバーに送信し、&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt;ディレクティブを正常に処理できることを示します。</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 応答ヘッダーは、リソースへのアクセスを取得するために使用される認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 応答ヘッダーは、Internet Explorer、Chrome、およびSafariの機能であり、反射されたクロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻撃を検出すると、ページの読み込みを停止します。インラインJavaScript（ &lt;code&gt;'unsafe-inline'&lt;/code&gt; ）の使用を無効にする強力な&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;をサイトが実装している場合、これらの保護は現代のブラウザーではほとんど不要ですが、まだまだ使用していない古いWebブラウザーのユーザーに保護を提供できます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSPを&lt;/a&gt;サポートします。</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP Strict Transport Security ヘッダは、HTTP を使用してサイトを決してロードしてはならず、HTTP を使用してサイトにアクセスしようとするすべての試みを、代わりに HTTPS リクエストに自動的に変換すべきであることをブラウザに通知します。</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URLネームスペースは、「/」文字で区切られた階層ネームスペースです。 HTTP URL名前空間は、次の条件を満たす場合に整合性があると見なされます。HTTP階層内のすべてのURLに対して、そのURLを内部メンバーURLとして含むコレクションが存在します。ルート、つまり検討中のネームスペースのトップレベルコレクションは、前のルールから除外されます。検討中のネームスペースの最上位のコレクションは、絶対パス「/」で識別されるコレクションであるとは限りません。1つ以上のパスセグメントで識別される場合があります（例：/ servlets / webdav / ...）どちらのHTTP / 1.1でもWebDAVでは、HTTP URLネームスペース全体が一貫している必要はありません。WebDAV互換リソースには親コレクションがない場合があります。しかしながら、特定のWebDAVメソッドは、名前空間の不整合を引き起こす結果を生成することが禁止されています。 [で暗黙的であるように&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]と[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]、コレクションリソースを含むすべてのリソースは、複数のURIで識別される場合があります。たとえば、リソースは複数のHTTP URLで識別できます。</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP認証フレームワークは、資格情報の機密性を維持するための単一のメカニズムを定義していません。代わりに、各認証スキームは、送信前に資格情報をエンコードする方法を定義します。これは、将来の認証スキームの開発に柔軟性を提供しますが、それ自体では機密性を提供しない、またはリプレイ攻撃から十分に保護しない既存のスキームの保護には不十分です。さらに、サーバーが個々のユーザーに固有の資格情報を期待している場合、それらの資格情報を交換すると、資格情報内のコンテンツが機密のままであっても、そのユーザーを識別する効果があります。HTTPは、ヘッダーフィールドの機密送信を提供するために、基になるトランスポートレベルまたはセッションレベルの接続のセキュリティプロパティに依存しています。つまり、サーバーがこのフレームワークを使用して認証されたユーザーへのアクセスを制限する場合、サーバーは、使用される認証スキームの性質に従って、接続が適切に保護されていることを確認する必要があります。たとえば、個々のユーザー認証に依存するサービスでは、TLS（「トランスポート層セキュリティ」、[個々のユーザー認証に依存するサービスでは、TLS（ &quot;Transport Layer Security&quot;、[個々のユーザー認証に依存するサービスでは、TLS（ &quot;Transport Layer Security&quot;、[&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）資格情報を交換する前。</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP条件付きリクエストヘッダーフィールド[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]を使用すると、クライアントはターゲットリソースの状態に事前条件を設定できるため、事前条件がfalseと評価された場合、メソッドのセマンティクスに対応するアクションは適用されません。この仕様で定義されている各前提条件は、ターゲットリソースの以前の表現から取得した一連のバリデータと、選択した表現のバリデータの現在の状態との比較で構成されています（&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）。したがって、これらの前提条件は、クライアントが既知の特定の状態以降にターゲットリソースの状態が変化したかどうかを評価します。このような評価の効果は、メソッドのセマンティクスと条件付きの選択に依存します。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232]のセクション5&lt;/a&gt;。 + --------------------- + -------------------------- + |ヘッダーフィールド名|で定義されています... | + --------------------- + -------------------------- + |イフマッチ| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232]のセクション3.1&lt;/a&gt; | | If-None-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]のセクション3.2&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]のセクション3.3&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232]のセクション3.4&lt;/a&gt; | | If-Range | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]のセクション3.2&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求で使用されているHTTPメソッドは、応答の&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたメソッドのリストに含まれていません。このヘッダーは、リクエストで指定されたURLにCORSを使用してアクセスするときに使用できるHTTPメソッドのコンマ区切りリストを指定します。要求が他の方法を使用している場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTPプロトコルは、要求/応答プロトコルです。クライアントは、リクエストメソッド、URI、プロトコルバージョンの形式でリクエストをサーバーに送信し、続いて、サーバーとの接続を介して、リクエスト修飾子、クライアント情報、および可能なボディコンテンツを含むMIMEのようなメッセージを送信します。サーバーは、メッセージのプロトコルバージョンと成功またはエラーコードを含むステータス行で応答し、その後にサーバー情報、エンティティメタ情報、および可能性のあるエンティティ本体コンテンツを含むMIMEのようなメッセージが続きます。 HTTPとMIMEの関係については、付録19.4で説明しています。ほとんどのHTTP通信はユーザーエージェントによって開始され、いくつかのオリジンサーバー上のリソースに適用される要求で構成されます。最も単純なケースでは、これは、ユーザーエージェント（UA）とオリジンサーバー（O）の間の単一の接続（v）を介して実現できます。リクエストチェーン------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;-----------------------応答チェーンより複雑な状況が発生すると1つ以上の仲介者が要求/応答チェーンに存在します。仲介には、プロキシ、ゲートウェイ、トンネルの3つの一般的な形式があります。プロキシは転送エージェントであり、絶対形式でURIの要求を受け取り、メッセージのすべてまたは一部を書き換え、URIで識別されるサーバーに向けて再フォーマットされた要求を転送します。ゲートウェイは受信エージェントであり、他のサーバーの上位層として機能し、必要に応じて、要求を基盤となるサーバーのプロトコルに変換します。トンネルは、メッセージを変更せずに2つの接続間の中継点として機能します。トンネルは、仲介者がメッセージの内容を理解できない場合でも、通信が仲介者（ファイアウォールなど）を通過する必要がある場合に使用されます。リクエストチェーン--------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ----------------------------レスポンスチェーン上の図は、ユーザーエージェントとオリジン間の3つの仲介者（A、B、C）を示していますサーバ。チェーン全体を移動する要求または応答メッセージは、4つの個別の接続を通過します。一部のHTTP通信オプションは最も近い非トンネルネイバーとの接続にのみ適用される場合があるため、この区別は重要です。チェーンのエンドポイントのみ、またはチェーンに沿ったすべての接続に。図は直線的ですが、各参加者は複数の同時通信に従事する場合があります。たとえば、Bは、A以外の多くのクライアントからの要求を受信して​​いる場合や、C以外のサーバーに要求を転送しているときに、Aの要求を処理している場合があります。トンネルとして機能していない通信の当事者は、要求を処理するために内部キャッシュを使用できます。キャッシュの効果は、チェーン上の参加者の1人がその要求に適用可能なキャッシュされた応答を持っている場合、要求/応答チェーンが短縮されることです。以下は、UAまたはAによってキャッシュされていないリクエストに対して、BがOからの（Cを介した）以前の応答のキャッシュされたコピーを持っている場合の結果のチェーンを示しています。リクエストチェーン----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;---------応答チェーンすべての応答が有効にキャッシュできるわけではなく、一部の要求には、キャッシュの動作に特別な要件を課す修飾子が含まれる場合があります。キャッシュ動作とキャッシュ可能な応答のHTTP要件は、&lt;a href=&quot;#section-13&quot;&gt;セクション13&lt;/a&gt;。実際、キャッシュとプロキシのさまざまなアーキテクチャと構成があり、現在World Wide Webで実験または配備されています。これらのシステムには、大洋横断の帯域幅を節約するプロキシキャッシュの全国階層、キャッシュエントリをブロードキャストまたはマルチキャストするシステム、CD-ROMを介してキャッシュデータのサブセットを配布する組織などが含まれます。 HTTPシステムは、高帯域幅リンク上の企業イントラネットで使用され、低電力の無線リンクと断続的な接続を備えたPDA経由のアクセスに使用されます。 HTTP / 1.1の目標は、高い信頼性を必要とするWebアプリケーションを構築する人のニーズを満たすプロトコルコンストラクトを導入しながら、すでに導入された幅広い構成をサポートし、少なくとも信頼性の高い失敗の兆候に失敗することです。HTTP通信は通常、TCP / IP接続を介して行われます。デフォルトのポートはTCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]ですが、他のポートを使用できます。これは、HTTPがインターネットまたは他のネットワーク上の他のプロトコルの上に実装されることを排除するものではありません。 HTTPは信頼できるトランスポートのみを前提としています。そのような保証を提供する任意のプロトコルを使用できます。問題のプロトコルのトランスポートデータユニットへのHTTP / 1.1要求および応答構造のマッピングは、この仕様の範囲外です。 HTTP / 1.0では、ほとんどの実装で、要求/応答交換ごとに新しい接続が使用されていました。 HTTP / 1.1では、接続は1つ以上の要求/応答交換に使用できますが、接続はさまざまな理由で閉じられる場合があります（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTPプロトコルは、&lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt;と呼ばれる要求メソッドを指定します。要求されたリソースとの双方向通信を開始し、トンネルを開くために使用できます。これは、HTTPプロキシの背後にあるクライアントがSSL（つまり、HTTPS、ポート443）を使用してWebサイトにアクセスする方法です。ただし、すべてのプロキシサーバーが &lt;code&gt;CONNECT&lt;/code&gt; メソッドをサポートしたり、ポート443のみに制限したりするわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">初期の段階で使用されていた HTTP プロトコルは非常にシンプルで、後に HTTP/0.9 と呼ばれるようになり、時には 1 行プロトコルとして使用されることもありました。</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP リクエストヘッダ</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">グローバル オブジェクトがインスタンス化されたリソースの HTTP ステータス コード。</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">リクエストで使用されているHTTPバージョンは、サーバーがサポートしていません。</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1標準は、サーバー主導のネゴシエーションを開始する標準ヘッダー（&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;）のリストを定義しています。厳密には&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;はこのリストに含まれていませんが、要求されたリソースの特定の表現を送信するために使用されることもありますが、これは良い習慣とは見なされていません。サーバーは&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、コンテンツネゴシエーションに実際に使用したヘッダー（正確には関連する応答ヘッダー）を示すため、&lt;a href=&quot;caching&quot;&gt;キャッシュ&lt;/a&gt;は最適に機能します。</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP/2のバイナリフレーム機構は、適用されたAPIや設定ファイルの変更を必要としないように設計されています。</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP/2プロトコルは、HTTP/1.1バージョンといくつかの主要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Host request-headerフィールドは、ユーザーまたは参照リソース（&lt;a href=&quot;#section-3.2.2&quot;&gt;セクション3.2.2で&lt;/a&gt;説明されているように、通常はHTTP URL）によって与えられた元のURIから取得した、要求されているリソースのインターネットホストとポート番号を指定します。 Hostフィールドの値は、元のURLで指定されたオリジンサーバーまたはゲートウェイの命名機関を表す必要があります。これにより、起点サーバーまたはゲートウェイは、単一のIPアドレス上の複数のホスト名のサーバーのルート「/」URLなど、内部的にあいまいなURLを区別できます。 Host = &quot;Host&quot; &quot;：&quot; host [&quot;：&quot; port]; &lt;a href=&quot;#section-3.2.2&quot;&gt;セクション3.2.2&lt;/a&gt; 後続のポート情報のない「ホスト」は、要求されたサービスのデフォルトポートを意味します（たとえば、HTTP URLの場合は「80」）。たとえば、&amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;に対するオリジンサーバーでのリクエスト&amp;gt; GET / pub / WWW / HTTP / 1.1 Host：www.w3.orgクライアントはすべてのHTTP / 1.1リクエストメッセージにHostヘッダーフィールドを含める必要があります。要求されたURIに、要求されているサービスのインターネットホスト名が含まれていない場合は、Hostヘッダーフィールドに空の値を指定する必要があります。 HTTP / 1.1プロキシは、転送するすべての要求メッセージに、プロキシによって要求されているサービスを識別する適切なホストヘッダーフィールドが含まれていることを確認する必要があります。すべてのインターネットベースのHTTP / 1.1サーバーは、ホストヘッダーフィールドがないHTTP / 1.1リクエストメッセージに対して400（Bad Request）ステータスコードで応答する必要があります。ホストに関連するその他の要件については、セクション&lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;および&lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="translated">Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances(HTCPCP-TEA)。レスポンスコード</target>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; responseステータスコードは、要求が処理のために受け入れられたが、処理が完了していないことを示します。実際、処理はまだ開始されていない可能性があります。リクエストは、実際に処理が行われるときに許可されない可能性があるため、最終的に処理される場合とされない場合があります。</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、要求が受信されたがまだ処理されていないことを示します。これは非コミットです。つまり、HTTPが要求の処理結果を示す非同期応答を後で送信する方法はありません。これは、別のプロセスまたはサーバーが要求を処理する場合、またはバッチ処理を目的としています。</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに確実に移動されたことを示します。ブラウザがこのページにリダイレクトし、検索エンジンがリソースへのリンクを更新します（ 'SEO-speak'では、 'link-juice'が新しいURLに送信されると言われています）。</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに一時的に移動されたことを示します。ブラウザはこのページにリダイレクトしますが、検索エンジンはリソースへのリンクを更新しません（ 'SEO-speak'では、 'link-juice'は新しいURLに送信されないと言われています）。</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、リダイレクトが新しくアップロードされたリソースではなく、確認ページやアップロードの進行状況ページなどの別のページにリンクされていることを示します。この応答コードは通常、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;結果として返送されます。このリダイレクトされたページを表示するために使用されるメソッドは常に&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コード&lt;strong&gt;」を参照してください。&lt;/strong&gt;リダイレクトは、新しくアップロードされたリソースではなく、別のページ（確認ページやアップロードの進行状況ページなど）にリンクします。この応答コードは通常、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; の&lt;/a&gt;結果として返送されます。このリダイレクトされたページを表示するために使用されるメソッドは、常に&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; リダイレクトステータス応答コードは、要求されたリソースが&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーで指定されたURLに確実に移動されたことを示します。ブラウザがこのページにリダイレクトし、検索エンジンがリソースへのリンクを更新します（ 'SEO-speak'では、 'link-juice'が新しいURLに送信されると言われています）。</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、クライアントエラーと見なされるもの（たとえば、不正な形式の要求構文、無効な要求メッセージフレーミング、または欺瞞的な要求）が原因で、サーバーが要求を処理できない、または処理しないことを示します。ルーティング）。</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、無効な構文のためにサーバーが要求を理解できなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、リクエストメソッドがサーバーで認識されているが、ターゲットリソースではサポートされていないことを示します。</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーがリクエストの事前対応型&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;ヘッダーで定義された許容値のリストと一致する応答を生成できず、サーバーがデフォルトの表現を提供することを望まないことを示します。</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; レスポンスステータスコードは、サーバーがこの未使用の接続をシャットダウンしたいことを意味します。&lt;em&gt;クライアントからの以前の要求がない場合でも&lt;/em&gt;、一部のサーバーによってアイドル接続で&lt;em&gt;送信されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; clientエラー応答コードは、ターゲットリソースへのアクセスがオリジンサーバーで利用できなくなったこと、およびこの状態が永続的である可能性が高いことを示しています。</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、サーバーが、定義された&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダーなしで要求を受け入れることを拒否することを示します。</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; クライアントエラー応答コードは、ターゲットリソースへのアクセスが拒否されたことを示します。これは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;以外のメソッドの条件付きリクエストで、&lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;ヘッダーによって定義された条件が満たされない場合に発生します。その場合、リクエスト（通常はリソースのアップロードまたは変更）を行うことができず、このエラー応答が返されます。</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; エラー応答コードは、サーバーが要求された範囲を処理できないことを示します。最も可能性の高い理由は、ドキュメントにそのような範囲が含まれていないか、&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーの値が構文的には正しいものの、意味がないことです。</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、サーバーが要求エンティティのコンテンツタイプを理解し、要求エンティティの構文は正しいが、含まれている指示を処理できなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 応答ステータスコードは、サーバーが再生される可能性のある要求を処理するリスクを負わないことを示し、再生攻撃の可能性を生み出します。</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; クライアントエラーレスポンスコードは、法的措置がとられたWebページなど、法的理由により利用できないリソースをユーザーが要求したことを示します。</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; サーバーエラーの応答コードは、サーバーが予期しない状態に遭遇し、要求の処理を妨げたことを示しています。</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、要求メソッドがサーバーでサポートされておらず、処理できないことを示します。サーバーがサポートする必要がある（したがって、このコードを返してはならない）唯一のメソッドは、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは&lt;strong&gt;、サーバーが要求を満たすために必要な機能をサポートしていない&lt;/strong&gt;ことを意味し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; サーバーのエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、上流サーバーから無効な応答を受信したことを示します。</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">HyperText Transfer Protocol（HTTP） &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーが要求を処理する準備ができていないことを示します。</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、時間内に応答を取得できないことを示します。</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; サーバーエラー応答コードは、サーバーがゲートウェイまたはプロキシとして機能しているときに、要求を完了するために必要なアップストリームサーバーからの応答を時間内に取得しなかったことを示します。</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP） &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; サポートされていないHTTPバージョンレスポンスステータスコードは、リクエストで使用されているHTTPバージョンがサーバーでサポートされていないことを示します。</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP）はステートレスなアプリケーションレベルの要求/応答プロトコルであり、拡張可能なセマンティクスと自己記述的なメッセージペイロードを使用して、ネットワークベースのハイパーテキスト情報システムと柔軟に対話します。このドキュメントは、HTTP / 1.1仕様をまとめて形成する一連のドキュメントの最初のものです。1.「メッセージの構文とルーティング」（このドキュメント）2.「セマンティクスとコンテンツ」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3.「条件付きリクエスト」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4.「範囲要求」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5.「キャッシング」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6.「認証」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]このHTTP / 1。1仕様は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145を廃止&lt;/a&gt;（HTTPバージョン管理上）。この仕様はまた、以前に&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;で定義されたトンネルを確立するためのCONNECTの使用を更新し、&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818で&lt;/a&gt;非公式に説明された「https」URIスキームを定義します。 HTTPは、情報システムの汎用インターフェースプロトコルです。提供されるリソースのタイプに依存しない均一なインターフェースをクライアントに提示することにより、サービスの実装方法の詳細を隠すように設計されています。同様に、サーバーは各クライアントの目的を認識する必要はありません。HTTP要求は、特定のタイプのクライアントや事前に定義された一連のアプリケーションステップに関連付けられるのではなく、単独で考慮されます。その結果、多くの異なるコンテキストで効果的に使用でき、実装が時間の経過とともに独立して進化できるプロトコルが得られます。 HTTPは、非HTTP情報システムとの間の通信を変換するための仲介プロトコルとして使用するためにも設計されています。HTTPプロキシとゲートウェイは、HTTPサービスと同じ方法でクライアントが表示および操作できるハイパーテキスト形式に多様なプロトコルを変換することにより、代替情報サービスへのアクセスを提供できます。この柔軟性の結果として、インターフェースの背後で何が発生するかに関してプロトコルを定義できなくなります。代わりに、通信の構文、受信した通信の意図、および受信者の予想される動作の定義に限定されます。通信が単独で考慮される場合、成功したアクションは、サーバーによって提供される監視可能なインターフェースへの対応する変更に反映されるべきです。ただし、複数のクライアントが並行して、おそらくはクロスパーパスで動作する可能性があるため、そのような変更が単一の応答の範囲を超えて観察可能であることを要求することはできません。このドキュメントでは、HTTPで使用または参照されるアーキテクチャ要素について説明し、「http」および「https」URIスキームを定義し、ネットワーク操作と接続管理全体を説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。全体的なネットワーク操作と接続管理について説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。全体的なネットワーク操作と接続管理について説明し、HTTPメッセージのフレーミングと転送の要件を定義します。私たちの目標は、メッセージのセマンティクスに依存しないHTTPメッセージの処理に必要なすべてのメカニズムを定義し、それによってメッセージパーサーとメッセージ転送の仲介者の要件の完全なセットを定義することです。</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">ハイパーテキスト転送プロトコル（HTTP）は、分散型の協調型ハイパーメディア情報システム用のアプリケーションレベルのプロトコルです。 HTTPは、1990年以来、World-Wide Webグローバル情報イニシアチブで使用されています。HTTP/ 0.9と呼ばれるHTTPの最初のバージョンは、インターネットを介した生データ転送用のシンプルなプロトコルでした。&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6で&lt;/a&gt;定義されている HTTP / 1.0]、メッセージをMIMEのようなメッセージの形式にできるようにすることでプロトコルを改善しました。これには、転送されたデータに関するメタ情報と、要求/応答セマンティクスの修飾子が含まれています。ただし、HTTP / 1.0では、階層プロキシ、キャッシュ、永続的な接続の必要性、または仮想ホストの影響を十分に考慮していません。さらに、「HTTP / 1.0」と呼ばれる不完全に実装されたアプリケーションの急増により、2つの通信アプリケーションが互いの真の機能を判別するために、プロトコルバージョンの変更が必要になりました。この仕様は、「HTTP / 1.1」と呼ばれるプロトコルを定義しています。このプロトコルには、その機能の信頼できる実装を保証するために、HTTP / 1.0よりも厳しい要件が含まれています。実用的な情報システムには、検索、フロントエンドの更新、注釈など、単純な検索よりも多くの機能が必要です。 HTTPは、リクエストの目的を示すメソッドとヘッダーの制限のないセットを許可します[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。メソッドが適用されるリソースを示すために、場所（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]または名前（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ] として、Uniform Resource Identifier（URI）[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ] によって提供される参照の規律に基づいて構築されています。メッセージは、多目的インターネットメール拡張機能（MIME）[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]で定義されているインターネットメール[ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] で使用されているものと同様の形式で渡されます。 HTTPは、SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ]、NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ]、FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ]、Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ]、およびWAIS [でサポートされているものを含む、他のインターネットシステムへのユーザーエージェントとプロキシ/ゲートウェイ間の通信の汎用プロトコルとしても使用されます。&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ]プロトコル。このように、HTTPは、さまざまなアプリケーションから利用可能なリソースへの基本的なハイパーメディアアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">ハイパーテキスト転送プロトコル ステータスコード 308 (恒久的リダイレクト)</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">Ifヘッダーには2つの異なる目的があります。o最初の目的は、特定のリソースにトークンおよびETagと一致する条件を含む一連の状態リストを提供することにより、要求を条件付きにすることです。このヘッダーが評価され、すべての状態リストが失敗した場合、リクエストは412（Precondition Failed）ステータスで失敗する必要があります。一方、要求は、記述された状態リストの1つが成功した場合にのみ成功できます。状態リストと一致する関数の成功基準は、セクション&lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;および&lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4で&lt;/a&gt;定義されています。。 oさらに、状態トークンがIfヘッダーに表示されるという単なる事実は、要求とともに「送信」されたことを意味します。一般に、これは、クライアントがその状態トークンを知っていることを示すために使用されます。状態トークンを送信するためのセマンティクスは、そのタイプによって異なります（ロックトークンについては、&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;を参照してください）。これら2つの目的は明確に扱う必要があることに注意してください。状態トークンは、サーバーが実際に出現する状態リストを評価したかどうかに関係なく、また、表現された条件がtrueであることが判明したかどうかに関係なく、送信されたものとしてカウントされます。</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">Ifリクエストヘッダーは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;、[RFC2616]のセクション14.24で&lt;/a&gt;定義されているIf-Matchヘッダーと同様の機能を持つことを目的としています。ただし、Ifヘッダーは、ETagsだけでなくすべての状態トークンを処理します。状態トークンの典型的な例はロックトークンであり、この仕様で定義されている状態トークンはロックトークンだけです。</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Matchリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。以前にリソースから取得した1つ以上のエンティティを持つクライアントは、関連するエンティティタグのリストをIf-Matchヘッダーフィールドに含めることにより、それらのエンティティの1つが最新であることを確認できます。エンティティタグは&lt;a href=&quot;#section-3.11&quot;&gt;セクション3.11で&lt;/a&gt;定義されています。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。また、リクエストの更新時に、誤ったバージョンのリソースが誤って変更されるのを防ぐためにも使用されます。特殊なケースとして、値「*」はリソースの現在のエンティティと一致します。 If-Match = &quot;If-Match&quot; &quot;：&quot;（ &quot;*&quot; | 1＃entity-tag）いずれかのエンティティタグが、類似のGETリクエストへの応答で返されるエンティティのエンティティタグと一致する場合（そのリソースにIf-Matchヘッダーがない場合）、または「*」が指定されていて、そのリソースに現在のエンティティが存在する場合、サーバーは、If-Matchヘッダーフィールドが存在しないかのように、要求されたメソッドを実行できます。サーバーは強力な比較関数を使用する必要があります（ &lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を参照）&lt;/a&gt;）If-Matchのエンティティタグを比較します。一致するエンティティタグがない場合、または「*」が指定されていて、現在のエンティティが存在しない場合、サーバーは要求されたメソッドを実行してはならず、412（前提条件失敗）応答を返さなければなりません（MUST）。この動作は、クライアントが最後にリソースを取得してから変更されたリソースをPUTなどの更新メソッドが変更できないようにする場合に最も役立ちます。リクエストが、If-Matchヘッダーフィールドなしで、2xxまたは412ステータス以外の結果になる場合は、If-Matchヘッダーを無視する必要があります。 &quot;If-Match：*&quot;の意味は、オリジンサーバー（またはキャッシュ、おそらくVaryメカニズムを使用）によって表現が選択された場合にメソッドを実行する必要があることです。&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44を&lt;/a&gt;参照してください。）存在し、表現が存在しない場合は実行してはならない（MUST NOT）。リソース（PUTなど）を更新することを目的としたリクエストには、If-Match値に対応するエンティティ（単一のエンティティタグ）がもはや存在しない場合、リクエストメソッドを適用してはならないことを示すIf-Matchヘッダーフィールドを含めることができます（MAY）。そのリソースの表現。これにより、ユーザーが知らないうちにリソースが変更された場合に、リクエストが成功しないことをユーザーが示すことができます。例：If-Match： &quot;xyzzy&quot; If-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot;、 &quot;c3piozzzz&quot; If-Match：* If-MatchヘッダーフィールドとIf-None-Matchの両方を持つリクエストの結果または、If-Modified-Sinceヘッダーフィールドはこの仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Sinceリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。要求されたバリアントがこのフィールドで指定された時間以降に変更されていない場合、エンティティはサーバーから返されません。代わりに、メッセージ本文なしで304（変更されていない）応答が返されます。 If-Modified-Since = &quot;If-Modified-Since&quot; &quot;：&quot; HTTP-dateフィールドの例は次のとおりです：If-Modified-Since：Sat、29 Oct 1994 19:43:31 GMT A GET method with a If- Modified-Sinceヘッダーがあり、Rangeヘッダーがない場合は、識別されたエンティティを、If-Modified-Sinceヘッダーで指定された日付以降に変更されている場合にのみ転送するように要求します。これを決定するためのアルゴリズムには、以下のケースが含まれます。a）リクエストが通常200（OK）ステータス以外になる場合、または渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るまたは、渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るまたは、渡されたIf-Modified-Since日付が無効な場合、応答は通常のGETの場合とまったく同じです。サーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るサーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るサーバーの現在時刻より後の日付は無効です。 b）バリアントがIf-Modified-Sinceの日付以降に変更されている場合、応答は通常のGETの場合とまったく同じです。 c）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るc）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見るc）バリアントが有効なIf-Modified-Since日付以降に変更されていない場合、サーバーは304（Not Modified）応答を返す必要があります（SHOULD）。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。注：Rangeリクエストヘッダーフィールドは、If-Modified-Sinceの意味を変更します。見る&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;詳細については。注：If-Modified-Since時刻はサーバーによって解釈され、その時刻はクライアントと同期されていない可能性があります。注：一部のサーバーは、If-Modified-Sinceヘッダーフィールドを処理するときに、小なり関数ではなく正確な日付比較関数を使用して、304（未変更）応答を送信するかどうかを決定します。キャッシュ検証のためにIf-Modified-Sinceヘッダーフィールドを送信するときに最良の結果を得るには、可能な限り、前回のLast-Modifiedヘッダーフィールドで受信した正確な日付文字列を使用することをお勧めします。注：クライアントが、同じリクエストのLast-Modifiedヘッダーから取得した日付ではなく、If-Modified-Sinceヘッダーで任意の日付を使用する場合、クライアントは、この日付がサーバーの時間の理解で解釈されるという事実を認識する必要があります。クライアントは、クライアントとサーバー間の時間のエンコーディングが異なるため、非同期のクロックと丸めの問題を考慮する必要があります。これには、ドキュメントが最初に要求された時刻と後続の要求のIf-Modified-Since日付の間にドキュメントが変更された場合の競合状態の可能性、およびIf-Modified-Since日付の場合のクロックスキュー関連の問題の可能性が含まれます。サーバーのクロックを修正せずに、クライアントのクロックから導出されます。クライアントとサーバー間の異なるタイムベースの修正は、ネットワークのレイテンシのため、せいぜい概算です。If-Modified-Sinceヘッダーフィールドと、If-MatchまたはIf-Unmodified-Sinceヘッダーフィールドの両方を持つリクエストの結果は、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Matchリクエストヘッダーフィールドは、条件付きにするためのメソッドで使用されます。リソースから以前に取得した1つ以上のエンティティを持つクライアントは、関連するエンティティタグのリストをIf-None-Matchヘッダーフィールドに含めることにより、それらのエンティティが現在のものでないことを確認できます。この機能の目的は、最小限のトランザクションオーバーヘッドでキャッシュされた情報を効率的に更新できるようにすることです。また、リソースが存在しないとクライアントが判断したときに、メソッド（PUTなど）が既存のリソースを誤って変更しないようにするためにも使用されます。特殊なケースとして、値「*」はリソースの現在のエンティティと一致します。 If-None-Match = &quot;If-None-Match&quot; &quot;：&quot;（ &quot;*&quot;| 1＃entity-tag）エンティティタグのいずれかが、そのリソースに対する同様のGETリクエスト（If-None-Matchヘッダーなし）への応答で返されるエンティティのエンティティタグと一致する場合、または &quot;* &quot;が指定されており、そのリソースに現在のエンティティが存在する場合、リソースの変更日がリクエストのIf-Modified-Sinceヘッダーフィールドで指定されたものと一致しないため、サーバーは必要に応じて、要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る見る見る見る見る次に、リソースの変更日付が要求のIf-Modified-Sinceヘッダーフィールドで指定された日付と一致しないため、サーバーは要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る次に、リソースの変更日付が要求のIf-Modified-Sinceヘッダーフィールドで指定された日付と一致しないため、サーバーは要求されたメソッドを実行してはなりません（MUST NOT）。代わりに、リクエストメソッドがGETまたはHEADの場合、サーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含め、304（Not Modified）レスポンスで応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見るサーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含む304（Not Modified）応答で応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見るサーバーは、一致したエンティティの1つのキャッシュ関連ヘッダーフィールド（特にETag）を含む304（Not Modified）応答で応答する必要があります（SHOULD）。他のすべての要求メソッドの場合、サーバーはステータス412（前提条件の失敗）で応答する必要があります。見る&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;2つのエンティティタグが一致するかどうかを判断する方法については、セクション13.3.3を参照してください。弱比較関数は、GETまたはHEADリクエストでのみ使用できます。一致するエンティティタグがない場合、サーバーは、If-None-Matchヘッダーフィールドが存在しない場合と同様に、リクエストされたメソッドを実行できますが、リクエスト内のすべてのIf-Modified-Sinceヘッダーフィールドも無視する必要があります。つまり、一致するエンティティタグがない場合、サーバーは304（Not Modified）応答を返してはなりません（MUST NOT）。リクエストが、If-None-Matchヘッダーフィールドなしで、2xxまたは304ステータス以外の結果になる場合、If-None-Matchヘッダーは無視される必要があります。 （&lt;a href=&quot;#section-13.3.4&quot;&gt;セクション13.3.4を&lt;/a&gt;参照If-Modified-SinceとIf-None-Matchの両方が同じリクエストに含まれる場合のサーバーの動作については、「If-None-Match：*」の意味は、表現が選択されている場合はメソッドを実行してはならないことです。オリジンサーバー（またはキャッシュ、おそらくVaryメカニズムを使用）、&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44を&lt;/a&gt;参照）が存在し、表現が存在しない場合は実行する必要があります（SHOULD）。この機能は、PUT操作間の競合を防ぐのに役立つことを目的としています。例：If-None-Match： &quot;xyzzy&quot; If-None-Match：W / &quot;xyzzy&quot; If-None-Match： &quot;xyzzy&quot;、 &quot;r2d2xxxx&quot;、 &quot;c3piozzzz&quot; If-None-Match：W / &quot;xyzzy&quot; 、W / &quot;r2d2xxxx&quot;、W / &quot;c3piozzzz&quot; If-None-Match：* If-None-Matchヘッダーフィールドと、If-MatchまたはIf-Unmodified-Sinceヘッダーフィールドの両方を持つリクエストの結果は、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Sinceリクエストヘッダーフィールドは、条件付きにするためのメソッドと共に使用される。リクエストされたリソースがこのフィールドで指定された時間以降に変更されていない場合、 サーバーはIf-Unmodified-Sinceヘッダーが存在しないかのようにリクエストされた 操作を実行するべきである[SHOULD]。要求された variant が指定された時間以降に変更されている場合、サーバーは要求された操作を実行してはならず[MUST NOT]、412(Precondition Failed)を返さなければならない[MUST]。If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date フィールドの例は以下の通りである。 If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT 通常のリクエスト(すなわち、If-Unmodified-Sinceヘッダーがない場合)が2xxまたは 412ステータス以外の結果になる場合、If-Unmodified-Sinceヘッダーは無視されるべきである[SHOULD]。指定された日付が無効な場合、ヘッダーは無視される。If-Unmodified-SinceヘッダーフィールドとIf-None-MatchまたはIf-Modified-Sinceヘッダー フィールドの両方を持つリクエストの結果は、この仕様では未定義である。</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">JavaScript関数は1つの文字列を返します。</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScriptの関数は常にそれ自体でファイルに保存されるべきであり、HTMLに埋め込まれるべきではありません。</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="translated">JavaScriptの機能は常に単独でファイルに保存しておく必要がありますが、HTMLファイルなどに埋め込んではいけません。</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">これらのセクションに含まれるJavaScriptスニペット（およびこれらのクロスサイトリクエストを正しく処理するサーバーコードの実行中のインスタンス）は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http：//arunranga.com/examples/access-control/&lt;/a&gt;で「動作中」にあり、クロスサイト &lt;code&gt;XMLHttpRequest&lt;/code&gt; をサポートするブラウザで動作します。</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">キープアライブヘッダー(実験仕様</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified エンティティヘッダフィールドは、オリジンサーバが variant が最後に変更されたと考える日時を示します。Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date 使用例は Last-Modified です。Tue,15 Nov 1994 12:45:26 GMT このヘッダフィールドの正確な意味は、オリジンサーバの実装と元のリソースの性質に依存します。ファイルの場合は、ファイルシステムの最終更新時刻になります。動的に含まれる部品を持つエンティティの場合は、その部品の最終更新時刻のセットの中で最も新しい時刻になります。データベース・ゲートウェイの場合は、レコードの最終更新時刻であるかもしれません。仮想オブジェクトの場合は、内部状態が最後に変更された時間かもしれません。送信元のサーバは、メッセージの送信元のサーバの時刻よりも遅いLast-Modifiedの日付を送信してはなりません[MUST NOT]。このような場合、リソースの最終変更が将来のある時点を示している場合、サーバーはその日付を メッセージの生成日に置き換えなければならない[MUST]。送信元サーバーは、エンティティのLast-Modified値を、それが応答のDate値を生成 する時間にできるだけ近い時間で取得するべきである[SHOULD]。これにより、特に応答が生成された時刻の近くでエンティティが変更された場合、受信者は エンティティの修正時刻を正確に評価することができる。HTTP/1.1サーバは可能な限りLast-Modifiedを送るべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified エンティティヘッダフィールド値はキャッシュバリデータとしてよく使用されます。簡単に言えば、キャッシュエントリは Last-Modified 値以降にエンティティが変更されていない場合に有効であると考えられます。</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Location応答ヘッダーフィールドは、要求の完了または新しいリソースの識別のために、受信者をRequest-URI以外の場所にリダイレクトするために使用されます。 201（Created）応答の場合、Locationは、要求によって作成された新しいリソースの場所です。 3xx応答の場合、ロケーションは、リソースへの自動リダイレクトのためのサーバーの優先URIを示す必要があります（SHOULD）。フィールド値は、単一の絶対URIで構成されています。 Location = &quot;Location&quot; &quot;：&quot; absoluteURI例：Location：&lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/pub/WWW/People.html 注：Content-Locationヘッダーフィールド（&lt;a href=&quot;#section-14.14&quot;&gt;セクション14.14&lt;/a&gt;）Locationとは異なります。Content-Locationは、リクエストに含まれるエンティティの元の場所を識別します。したがって、応答にLocationとContent-Locationの両方のヘッダーフィールドを含めることができます。一部のメソッドのキャッシュ要件については、&lt;a href=&quot;#section-13.10&quot;&gt;セクション13.10&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">視聴覚ファイルのMIMEタイプは、主にコンテナのフォーマットを示す。ウェブ上で最も一般的なものは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">非コレクションリソースに対するMOVE操作は、コピー（COPY）に論理的に相当し、一貫性の維持処理が続き、その後にソースの削除が続きます。3つのアクションすべてが1つの操作で実行されます。一貫性の維持ステップにより、サーバーは、移動元のリソースを識別するRequest-URI以外のすべてのURLを更新するなど、移動によって発生した更新を実行して、新しい移動先のリソースを指すことができます。 DestinationヘッダーはすべてのMOVEメソッドに存在する必要があり、MOVEメソッドのCOPY部分のすべてのCOPY要件に従う必要があります。すべてのWebDAV準拠リソースはMOVEメソッドをサポートする必要があります。 MOVEメソッドのサポートは、リソースを特定の宛先に移動する機能を保証するものではありません。例えば、別々のプログラムが実際に同じサーバー上の異なるリソースのセットを制御する場合があります。したがって、同じサーバーに属しているように見えるネームスペース内のリソースを移動できない場合があります。リソースが宛先に存在する場合、Overwriteヘッダーの制限に従い、MOVE操作の副作用として宛先リソースが削除されます。この方法はべき等ですが、安全ではありません（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwardsリクエストヘッダーフィールドは、TRACE（&lt;a href=&quot;#section-9.8&quot;&gt;セクション9.8&lt;/a&gt;）およびOPTIONS（&lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2&lt;/a&gt;）を備えたメカニズムを提供します。）リクエストを次の受信サーバーに転送できるプロキシまたはゲートウェイの数を制限するメソッド。これは、クライアントが途中のチェーンで失敗またはループしているように見えるリクエストチェーンをトレースしようとしている場合に役立ちます。 Max-Forwards = &quot;Max-Forwards&quot; &quot;：&quot; 1 * DIGIT Max-Forwards値は、この要求メッセージが転送される残りの回数を示す10進整数です。 Max-Forwardsヘッダーフィールドを含むTRACEまたはOPTIONSリクエストの各プロキシまたはゲートウェイ受信者は、リクエストを転送する前にその値を確認および更新する必要があります。受信した値がゼロ（0）の場合、受信者はリクエストを転送してはなりません（MUST NOT）。代わりに、最終的な受信者として応答する必要があります。受信したMax-Forwards値がゼロより大きい場合、次に、転送されたメッセージには、値が1減少した更新済みのMax-Forwardsフィールドが含まれている必要があります。 Max-Forwardsヘッダーフィールドは、この仕様で定義されている他のすべてのメソッド、およびそのメソッド定義の一部として明示的に参照されていない拡張メソッドでは無視される場合があります。</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">メンバーURIを使用すると、クライアントはHTTPのGET、PUT、およびDELETEメソッドを使用してメンバーリソースを取得、編集、および削除できます。エントリーリソースは、Atomエントリードキュメントとして表されます。メンバーURIは2つの場所に表示されます。以下の&lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2で&lt;/a&gt;説明するように、POSTを使用してリソースが正常に作成された後、それらはLocationヘッダーで返され ます。また、コレクションフィードのエントリに、リンク関係が「編集」のatom：link要素として表示される場合もあります。メンバーエントリには、メンバーURIを示す &quot;edit&quot;のリンク関係を持つ、atom：link要素を含める必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">Methodトークンは、Request-URIで識別されるリソースで実行されるメソッドを示します。このメソッドでは大文字と小文字が区別されます。メソッド= &quot;OPTIONS&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;セクション9.2&lt;/a&gt; | &quot;取得する&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;セクション9.3&lt;/a&gt; | &quot;頭&quot; ; &lt;a href=&quot;#section-9.4&quot;&gt;セクション9.4&lt;/a&gt; | &quot;役職&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt; | &quot;PUT&quot;; &lt;a href=&quot;#section-9.6&quot;&gt;セクション9.6&lt;/a&gt; | &quot;削除&quot;; &lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt; | &quot;痕跡&quot; ; &lt;a href=&quot;#section-9.8&quot;&gt;セクション9.8&lt;/a&gt; | 「接続」; &lt;a href=&quot;#section-9.9&quot;&gt;セクション9.9&lt;/a&gt; | extension-method extension-method = tokenリソースによって許可されるメソッドのリストは、Allowヘッダーフィールドで指定できます（&lt;a href=&quot;#section-14.7&quot;&gt;セクション14.7&lt;/a&gt;）。許可されたメソッドのセットは動的に変更できるため、リソースのメソッドが現在許可されているかどうか、応答の戻りコードは常にクライアントに通知します。オリジンサーバーは、メソッドがオリジンサーバーによって認識されているが要求されたリソースに対して許可されていない場合はステータスコード405（メソッドが許可されていない）を返し、メソッドがオリジンサーバーによって認識されていないか実装されていない場合は501（実装されていない）を返す必要があります。メソッドGETおよびHEADは、すべての汎用サーバーでサポートされている必要があります。他のすべての方法はオプションです。ただし、上記のメソッドが実装されている場合は、&lt;a href=&quot;#section-9&quot;&gt;セクション9で&lt;/a&gt;指定されているものと同じセマンティクスで実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONSメソッドは、Request-URIによって識別されるリクエスト/レスポンスチェイン上で利用可能な通信オプションに関する情報のリクエストを表す。このメソッドにより、クライアントは、リソースのアクションを暗示したり、リソースの検索を開始したりすることなく、リソースに関連付けられたオプションや要件、またはサーバの能力を決定することができる。このメソッドに対する応答はキャッシュ可能ではない。OPTIONSリクエストが(Content-LengthまたはTransfer-Encodingの存在で示されるように)エンティティボディを含む場合、メディアタイプはContent-Typeフィールドで示されな ければならない[MUST]。この仕様ではそのようなボディの使用法は定義されていないが、HTTPの将来の拡張はOPTIONSボディを使用して サーバー上でより詳細な問い合わせを行うかもしれない。そのような拡張をサポートしないサーバーはリクエストボディを破棄してもよい[MAY]。Request-URIがアスタリスク(&quot;*&quot;)の場合、OPTIONSリクエストは特定のリソー スではなく、一般的にサーバーに適用されることを意図している。サーバの通信オプションは通常リソースに依存するので、&quot;*&quot;リクエストは &quot;ping &quot;や &quot;no-op &quot;タイプのメソッドとしてのみ有用である。例えば、これはHTTP/1.1に準拠しているか(あるいは準拠していないか)のプロキシをテストするために 使うことができる。Request-URIがアスタリスクでない場合、OPTIONSリクエストはそのリソース と通信するときに利用可能なオプションにのみ適用される。200応答は、サーバーによって実装され、そのリソースに適用可能なオプション機能(例:Allow)を示すすべてのヘッダーフィールドを含むべきである[SHOULD]。応答ボディは、もしあれば、通信オプションに関する情報も含むべきである [SHOULD]。そのようなボディのためのフォーマットはこの仕様では定義されていないが、 HTTPの将来の拡張によって定義されるかもしれない。適切な応答フォーマットを選択するためにコンテントネゴシエーションを 使用してもよい[MAY]。応答ボディを含まない場合、応答はフィールド値が「0」のContent-Lengthフィールドを 含めなければならない[MUST]。Max-Forwardsリクエストヘッダーフィールドは、リクエストチェー ンの特定のプロキシをターゲットにするために使用してもよい[MAY]。プロキシがリクエスト転送が許可されるabsoluteURI上のOPTIONSリクエストを受け取るとき、プロキシは Max-Forwardsフィールドをチェックしなければならない[MUST]。Max-Forwardsフィールド値がゼロ(「0」)の場合、プロキシはメッセージを転送しては ならない[MUST NOT]。その代わりに、プロキシはそれ自身の通信オプションで応答す るべきである[SHOULD]。Max-Forwardsフィールド値がゼロよりも大きい整数である場合、プロキシはリク エストを転送するときにフィールド値をデクリメントしな ければならない[MUST]。リクエスト中にMax-Forwardsフィールドが存在しない場合、転送されたリクエス トはMax-Forwardsフィールドを含んではならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONSメソッドは、起点サーバーまたは介在する中間サーバーのいずれかで、ターゲットリソースに使用可能な通信オプションに関する情報を要求します。このメソッドを使用すると、クライアントは、リソースアクションを示唆することなく、リソースに関連するオプションや要件、またはサーバーの機能を決定できます。アスタリスク（ &quot;*&quot;）をリクエストターゲットとして持つOPTIONSリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]のセクション5.3）&lt;/a&gt;）は、特定のリソースではなくサーバー全般に適用されます。サーバーの通信オプションは通常リソースに依存するため、「*」リクエストは「ping」または「no-op」タイプのメソッドとしてのみ役立ちます。クライアントがサーバーの機能をテストできるようにするだけです。たとえば、HTTP / 1.1への準拠（またはその欠如）についてプロキシをテストするために使用できます。 request-targetがアスタリスクでない場合、OPTIONS要求は、ターゲットリソースとの通信時に使用可能なオプションに適用されます。 OPTIONSへの正常な応答を生成するサーバーは、サーバーによって実装され、ターゲットリソースに適用可能なオプション機能（許可など）を示す可能性のあるヘッダーフィールドを送信する必要があります（SHOULD）。この仕様で定義されていない潜在的な拡張機能を含みます。応答ペイロードは、存在する場合、マシンまたは人間が読める形式で通信オプションを記述することもあります。このような表現の標準形式はこの仕様では定義されていませんが、HTTPの将来の拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。ただし、将来のHTTPの拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。ただし、将来のHTTPの拡張によって定義される可能性があります。応答でペイロード本体が送信されない場合、サーバーは値「0」のContent-Lengthフィールドを生成する必要があります。クライアントは、OPTIONSリクエストでMax-Forwardsヘッダーフィールドを送信して、リクエストチェーン内の特定の受信者をターゲットにすることができます（MAY）。 &lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）。プロキシは、リクエストがMax-Forwardsフィールドで受信されない限り、リクエストの転送中にMax-Forwardsヘッダーフィールドを生成してはなりません（MUST NOT）。ペイロード本体を含むOPTIONSリクエストを生成するクライアントは、表現メディアタイプを説明する有効なContent-Typeヘッダーフィールドを送信する必要があります。この仕様では、このようなペイロードの使用を定義していませんが、HTTPの将来の拡張では、OPTIONSボディを使用してターゲットリソースに関するより詳細なクエリを作成する可能性があります。OPTIONSメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">OperaブラウザもBlinkエンジンに基づいているため、ほとんど同じように見えますが、 &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt; が追加されています。</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Operaブラウザーもまばたきエンジンに基づいているため、ほとんど同じに見えますが、「OPR / &amp;lt;version&amp;gt;」が追加されています。</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">OSはほとんどのUser Agentの文字列で与えられますが(Firefox OSのようなWebに特化したプラットフォームでは与えられませんが)、形式は様々です。これは、ユーザーエージェントのコメント部分で、2つのセミコロンの間に固定された文字列です。これらの文字列は各ブラウザに固有のものです。これらの文字列は OS を示しますが、多くの場合、そのバージョンや依存するハードウェア (32 ビットまたは 64 ビット、Mac の場合は Intel/PPC)の情報も示します。</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="translated">PACファイルの名前は &lt;code&gt;proxy.pac&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC ファイルは proxy.pac という名前です。</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以降のセクションのPHPスニペット（およびサーバーへのJavaScript呼び出し）は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここに投稿された実際のコードサンプル&lt;/a&gt;から取得されます。これらは、クロスサイト&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;を実装するブラウザーで機能します。</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POSTメソッドを使用して、オリジンサーバーがリクエストに含まれるエンティティを、Request-LineのRequest-URIで識別されるリソースの新しい下位として受け入れることをリクエストします。 POSTは、次の機能をカバーする統一メソッドを許可するように設計されています。-既存のリソースの注釈。 -掲示板、ニュースグループ、メーリングリスト、または同様の記事グループにメッセージを投稿する。 -フォームの送信結果などのデータブロックをデータ処理プロセスに提供する。 -追加操作によるデータベースの拡張。 POSTメソッドによって実行される実際の機能はサーバーによって決定され、通常はRequest-URIに依存します。投稿されたエンティティは、ファイルがそれを含むディレクトリに従属するのと同じように、そのURIに従属します。ニュース記事は、それが投稿されたニュースグループに従属するか、レコードがデータベースに従属します。 POSTメソッドによって実行されるアクションは、URIで識別できるリソースにならない場合があります。この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）であり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、ロケーションヘッダーを含む必要があります（を参照）。この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）である必要があり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、Locationヘッダー（「この場合、応答に結果を説明するエンティティが含まれているかどうかに応じて、200（OK）または204（コンテンツなし）が適切な応答ステータスです。オリジンサーバーでリソースが作成されている場合、応答は201（作成済み）である必要があり、リクエストのステータスを記述し、新しいリソースを参照するエンティティと、Locationヘッダー（「&lt;a href=&quot;#section-14.30&quot;&gt;セクション14.30&lt;/a&gt;）。このメソッドへの応答は、適切なCache-ControlまたはExpiresヘッダーフィールドが応答に含まれていない限り、キャッシュできません。ただし、303（その他を参照）応答を使用して、ユーザーエージェントにキャッシュ可能なリソースを取得するように指示できます。 POSTリクエストは、&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2に&lt;/a&gt;記載されているメッセージ送信要件に従う必要があります。セキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">POSTメソッドは、リソース自体の特定のセマンティクスに従って、ターゲットリソースがリクエストに含まれる表現を処理することをリクエストします。たとえば、POSTは（特に）次の機能に使用されます。o HTMLフォームに入力されたフィールドなどのデータブロックをデータ処理プロセスに提供します。 o掲示板、ニュースグループ、メーリングリスト、ブログ、または同様の記事グループにメッセージを投稿する。 oオリジンサーバーによってまだ識別されていない新しいリソースを作成します。 oリソースの既存の表現にデータを追加する。オリジンサーバーは、POSTリクエストの処理結果に応じて適切なステータスコードを選択することにより、応答セマンティクスを示します。この仕様で定義されているほとんどすべてのステータスコードは、POSTに対する応答で受信される可能性があります（例外は206（部分的なコンテンツ）、304（変更されていない）、および416（範囲が満たされていません）です）。 POSTリクエストを正常に処理した結果、1つ以上のリソースがオリジンサーバーで作成された場合、オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。オリジンサーバーは、作成されたプライマリリソースの識別子を提供するLocationヘッダーフィールドを含む201（Created）応答を送信する必要があります（SHOULD）。&lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt;）と、新しいリソースを参照しながらリクエストのステータスを説明する表現。 POST要求への応答は、明示的な鮮度情報が含まれている場合にのみキャッシュできます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]のセクション4.2.1を&lt;/a&gt;参照）。ただし、POSTキャッシングは広く実装されていません。オリジンサーバーがクライアントがPOSTの結果を後のGETで再利用できる方法でキャッシュできるようにしたい場合、オリジンサーバーは結果とContent-Locationを含む200（OK）応答を送信できます（MAY）。 POSTの有効なリクエストURIと同じ値を持つヘッダーフィールド（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション3.1.4.2&lt;/a&gt;）。 POSTの処理結果が既存のリソースの表現と同等である場合、オリジンサーバーは、Locationフィールドに既存のリソースの識別子を含む303（その他を参照）応答を送信することにより、ユーザーエージェントをそのリソースにリダイレクトできます（MAY）。これには、ユーザーエージェントにリソース識別子を提供し、共有キャッシュをより適用しやすい方法で表現を転送するという利点がありますが、ユーザーエージェントが表現をまだキャッシュしていない場合は追加の要求が発生します。</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">PROPFINDメソッドは、リソースに内部メンバーがない場合、Request-URIで識別されるリソースで定義されたプロパティを取得します。または、リソースが内部メンバーURL。すべてのDAV準拠リソースは、PROPFINDメソッドとpropfind XML要素をサポートする必要があります（&lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt;）その要素で使用するために定義されたすべてのXML要素とともに。クライアントは、PROPFINDリクエストで「0」、「1」、または「無限大」の値を持つDepthヘッダーを送信する必要があります。サーバーはWebDAV準拠のリソースで「0」と「1」の深さ要求をサポートする必要があり、「無限」要求をサポートする必要があります（SHOULD）。実際には、この動作に関連するパフォーマンスとセキュリティの問題により、無制限のリクエストのサポートは無効になる場合があります。サーバーは、Depthヘッダーのないリクエストを、「Depth：infinity」ヘッダーが含まれているかのように処理する必要があります（SHOULD）。クライアントは、リクエストされている情報を記述するリクエストメソッドの本文で「propfind」XML要素を送信できます。次のことが可能です。o特定のプロパティ値を要求する、'prop'要素内で必要なプロパティに名前を付けることにより（ここではプロパティの順序はサーバーで無視される可能性があります）、oこの仕様で定義されたプロパティのプロパティ値を要求しますallprop '要素（' include '要素を' allprop 'と共に使用して、サーバーに、他の方法では返されない可能性がある追加のライブプロパティも含めるように指示できます）、oリソースで定義されているすべてのプロパティの名前のリストを要求します。 'propname'要素を使用する。クライアントは、リクエスト本文を送信しないことを選択できます。空のPROPFINDリクエストボディは、 'allprop'リクエストであるかのように処理する必要があります。 「allprop」がすべてのライブプロパティの値を返すわけではないことに注意してください。WebDAVサーバーは、ますます高価な計算された、または長いプロパティを持っています（[&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]および[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]）とすべてのプロパティをまだ返しません。代わりに、WebDAVクライアントは、propname要求を使用して、存在するライブプロパティを検出し、値を取得するときに名前付きプロパティを要求できます。他の場所で定義されたライブプロパティの場合、その定義は、そのライブプロパティが「allprop」リクエストで返されるかどうかを指定できます。すべてのサーバーは、さまざまなプロパティを取得する試みの結果を説明するマルチステータスXML要素を含む、コンテンツタイプtext / xmlまたはapplication / xmlの応答を返すことをサポートする必要があります。プロパティの取得中にエラーが発生した場合は、適切なエラー結果を応答に含める必要があります。存在しないプロパティの値を取得する要求はエラーであり、「応答」で注記する必要があります404（見つかりません）ステータス値を含むXML要素。したがって、コレクションリソースの「マルチステータス」XML要素には、コレクションの各メンバーURLの「応答」XML要素を、要求された深さまで含める必要があります。 WebDAVに準拠していないリソースの「応答」要素は含めないでください。各 'response'要素には、prop XML要素のプロパティが定義されているリソースのURLを含む 'href'要素を含める必要があります。コレクションリソースに対するPROPFINDの結果は、エントリの順序が重要ではないフラットリストとして返されます。リソースは特定の名前のプロパティに対して1つの値しか持つことができないため、プロパティはPROPFIND応答で1回しか表示されない場合があることに注意してください。プロパティはアクセス制御の対象となる場合があります。 'allprop'および 'propname'リクエストの場合、プリンシパルが特定のプロパティが存在するかどうかを知る権利を持っていない場合、そのプロパティは黙って応答から除外される場合があります。ほとんどのプロパティにはキャッシュ検証メカニズムがないため、一部のPROPFIND結果は注意してキャッシュできます。この方法は安全であり、べき等です（参照&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCHメソッドは、リクエスト本文で指定された命令を処理して、Request-URIで識別されるリソースで定義されたプロパティを設定または削除します。すべてのDAV準拠リソースは、PROPPATCHメソッドをサポートする必要があり、propertyupdate、set、およびXML要素を使用して指定された命令を処理する必要があります。もちろん、このメソッドでのディレクティブの実行は、アクセス制御の制約に従います。 DAV準拠のリソースは、任意のデッドプロパティの設定をサポートする必要があります（SHOULD）。 PROPPATCHメソッドの要求メッセージ本文には、propertyupdate XML要素が含まれている必要があります。サーバーは、PROPPATCH命令をドキュメントの順序で処理する必要があります（順序は無関係であるという通常の規則の例外）。命令はすべて実行されるか、何も実行されないかのいずれかでなければなりません。したがって、処理中にエラーが発生した場合、実行されたすべての命令を元に戻して、適切なエラー結果を返す必要があります。命令処理の詳細は、セクションのセットおよび削除命令の定義にあります。&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;および&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。サーバーがPROPPATCHリクエストのプロパティを変更しようとする場合（つまり、本文を処理する前に、リクエストが高レベルのエラーのために拒否されない場合）、&lt;a href=&quot;#section-9.2.1&quot;&gt;セクション9.2.1で&lt;/a&gt;説明されているように、応答はマルチステータス応答でなければなりません。。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等ですが、安全ではありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUTメソッドは、囲まれたエンティティが指定されたRequest-URIに格納されることを要求します。 Request-URIが既存のリソースを参照している場合、囲まれたエンティティは、起点サーバーにあるエンティティの変更バージョンと見なされるべきです（SHOULD）。 Request-URIが既存のリソースを指さず、そのURIが要求元のユーザーエージェントによって新しいリソースとして定義できる場合、オリジンサーバーはそのURIでリソースを作成できます。新しいリソースが作成された場合、オリジンサーバーは201（Created）応答を介してユーザーエージェントに通知する必要があります。既存のリソースが変更された場合、200（OK）または204（No Content）応答コードのいずれかを送信して、リクエストが正常に完了したことを示す必要があります。 Request-URIでリソースを作成または変更できなかった場合、問題の性質を反映する適切なエラー応答を与える必要があります。エンティティの受信者は、理解または実装していないContent- *（Content-Rangeなど）ヘッダーを無視してはならず（MUST）、そのような場合は501（Not Implemented）応答を返さなければなりません（MUST）。リクエストがキャッシュを通過し、Request-URIが現在キャッシュされている1つ以上のエンティティを識別する場合、それらのエントリは古いものとして扱われる必要があります（SHOULD）。このメソッドへの応答はキャッシュできません。 POST要求とPUT要求の基本的な違いは、Request-URIの異なる意味に反映されています。 POSTリクエストのURIは、囲まれたエンティティを処理するリソースを識別します。そのリソースは、データを受け入れるプロセス、他のプロトコルへのゲートウェイ、または注釈を受け入れる個別のエンティティである可能性があります。対照的に、PUTリクエストのURIは、リクエストに含まれるエンティティを識別します。ユーザーエージェントは意図されているURIを認識しており、サーバーは他のリソースへのリクエストの適用を試みてはいけません。サーバーが要求を別のURIに適用することを望む場合、サーバーは301（永久に移動）応答を送信する必要があります。次に、ユーザーエージェントは、リクエストをリダイレクトするかどうかに関して独自の決定を行うことができます。単一のリソースは、多くの異なるURIによって識別される場合があります。たとえば、記事には、特定の各バージョンを識別するURIとは別の「現在のバージョン」を識別するためのURIがある場合があります。この場合、一般的なURIに対するPUT要求により、他のいくつかのURIがオリジンサーバーによって定義される可能性があります。 HTTP / 1。1は、PUTメソッドがオリジンサーバーの状態にどのように影響するかを定義していません。 PUTリクエストは、で設定されたメッセージ送信要件に従う必要があります&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;。特定のエンティティヘッダーに特に指定されていない限り、PUTリクエストのエンティティヘッダーは、PUTによって作成または変更されたリソースに適用する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUTメソッドは、ターゲットリソースの状態を作成するか、要求メッセージのペイロードで囲まれた表現で定義された状態に置き換えることを要求します。特定の表現のPUTが成功した場合、その同じターゲットリソースで後続のGETを実行すると、同等の表現が200（OK）応答で送信されることになります。ただし、後続のGETを受信する前に、ターゲットリソースが他のユーザーエージェントによって並行して処理されたり、元のサーバーによる動的処理の対象となる可能性があるため、このような状態変化が観察可能である保証はありません。成功した応答は、元のサーバーによる処理時にユーザーエージェントの意図が達成されたことを意味します。ターゲットリソースに現在の表現がなく、PUTがそれを正常に作成した場合、オリジンサーバーは201（Created）応答を送信してユーザーエージェントに通知する必要があります。ターゲットリソースに現在の表現があり、その表現が囲まれた表現の状態に従って正常に変更された場合、オリジンサーバーは200（OK）または204（No Content）応答のいずれかを送信して、正常に完了したことを示す必要があります。リクエスト。オリジンサーバーは、PUTリクエストで受信した認識されないヘッダーフィールドを無視する必要があります（つまり、リソース状態の一部として保存しないでください）。オリジンサーバーは、PUT表現が、PUTによって変更できない、または変更されないターゲットリソースに対するサーバーの制約と整合していることを確認する必要があります（SHOULD）。オリジンサーバーがURIに関連する内部構成情報を使用してGET応答の表現メタデータの値を設定する場合、これは特に重要です。 PUT表現がターゲットリソースと矛盾している場合、オリジンサーバーは、表現を変換するかリソース構成を変更してそれらを一貫させるか、表現が不適切である理由を説明する十分な情報を含む適切なエラーメッセージで応答する必要があります。 409（競合）または415（サポートされていないメディアタイプ）ステータスコードが推奨されますが、後者はContent-Type値の制約に固有のものです。たとえば、ターゲットリソースが常に &quot;text / html&quot;のコンテンツタイプを持つように構成されている場合そして、PUTで​​ある表現は &quot;image / jpeg&quot;のContent-Typeを持ち、オリジンサーバーは次のいずれかを実行する必要があります。新しいメディアタイプを反映するようにターゲットリソースを再構成します。 b。新しいリソース状態として保存する前に、PUT表現をリソースの形式と一致する形式に変換します。または、c。ターゲットリソースが「text / html」に制限されていることを示す415（Unsupported Media Type）応答でリクエストを拒否します。おそらく、新しい表現の適切なターゲットとなる別のリソースへのリンクが含まれます。 HTTPは、PUTメソッドがオリジンサーバーの状態にどのように影響するかを、ユーザーエージェント要求の意図とオリジンサーバーの応答のセマンティクスを超えて正確に定義していません。HTTPを介して提供されるインターフェースを超えて、その言葉の意味でのリソースが何であるかを定義しません。リソースの状態が「格納」される方法や、リソースの状態の変化の結果としてそのようなストレージがどのように変化するかも定義されていません。また、オリジンサーバーがリソースの状態を表現に変換する方法も定義していません。一般的に言って、リソースインターフェースの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（リソースインターフェイスの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（リソースインターフェイスの背後にあるすべての実装の詳細は、サーバーによって意図的に隠されています。オリジンサーバーはバリデーターヘッダーフィールド（&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）（ETagやLast-Modifiedフィールドなど）。リクエストの表現データが本体に変換を適用せずに保存された場合（つまり、リソースの新しい表現データが、 PUTリクエスト）とバリデーターフィールドの値は新しい表現を反映します。この要件により、ユーザーエージェントは、PUTの結果としてメモリ内にあるリプレゼンテーションボディが最新のままであるため、オリジンサーバーから再度取得する必要がなく、新しいバリデータが応答で受信されたことを知ることができます。偶発的な上書きを防止するために、将来の条件付きリクエストに使用できます（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）。 POSTメソッドとPUTメソッドの基本的な違いは、囲まれた表現の異なる意図によって強調されています。 POSTリクエストのターゲットリソースは、リソース自体のセマンティクスに従って囲まれた表現を処理するためのものですが、PUTリクエストの囲まれた表現は、ターゲットリソースの状態を置き換えるものとして定義されます。したがって、正確な効果がオリジンサーバーによってのみ認識されている場合でも、PUTの意図はべき等であり、仲介者に可視です。 PUTリクエストの適切な解釈は、ユーザーエージェントがどのターゲットリソースが必要かを知っていることを前提としています。クライアントに代わって適切なURIを選択するサービスは、状態変更要求を受け取った後、PUTで​​はなくPOSTメソッドを使用して実装する必要があります（SHOULD）。オリジンサーバーが要求されたPUT状態をターゲットリソースに変更せず、代わりに、リソースが別のURIに移動された場合など、別のリソースに適用したい場合、オリジンサーバーは適切な3xxを送信する必要があります。 （リダイレクト）応答;次に、ユーザーエージェントは、リクエストをリダイレクトするかどうかに関して独自の決定を行うことができます。ターゲットリソースに適用されたPUTリクエストは、他のリソースに悪影響を与える可能性があります。たとえば、記事には、特定の各バージョンを識別するURI（ある時点で現在のバージョンのリソースと同じ状態を共有するさまざまなリソース）とは別の「現在のバージョン」（リソース）を識別するためのURIがある場合があります。 「現在のバージョン」で成功したPUTリクエストしたがって、URIは、ターゲットリソースの状態を変更することに加えて、新しいバージョンのリソースを作成し、関連するリソース間にリンクを追加する可能性があります。特定のターゲットリソースでPUTを許可するオリジンサーバーは、Content-Rangeヘッダーフィールドを含むPUTリクエストに400（Bad Request）応答を送信する必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233]のセクション4.2&lt;/a&gt;）。ペイロードは、誤って完全な表現としてPUTされた部分的なコンテンツである可能性が高いため。部分的なコンテンツの更新は、より大きなリソースの一部と重複する状態を持つ個別に識別されたリソースをターゲットにするか、部分的な更新用に特別に定義された別の方法（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]で定義されたPATCHメソッドなど）を使用することで可能です。 PUTメソッドへの応答はキャッシュできません。成功したPUT要求が、有効な要求URIに対する1つ以上の格納された応答を持つキャッシュを通過する場合、それらの格納された応答は無効になります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]のセクション4.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma general-headerフィールドは、要求/応答チェーンに沿って任意の受信者に適用される可能性がある実装固有のディレクティブを含めるために使用されます。すべてのプラグマディレクティブは、プロトコルの観点からオプションの動作を指定します。ただし、一部のシステムでは、動作がディレクティブと一致している必要がある場合があります。プラグマ= &quot;プラグマ&quot; &quot;：&quot; 1＃pragma-directiveプラグマディレクティブ= &quot;no-cache&quot; | extension-pragma extension-pragma = token [&quot;=&quot;（token | quoted-string）] no-cacheディレクティブがリクエストメッセージに存在する場合、アプリケーションは、キャッシュされたコピーがある場合でも、リクエストをオリジンサーバーに転送する必要があります（SHOULD）。要求されているものの。 このプラグマディレクティブは、no-cache cache-directiveと同じセマンティクスを持っています（ &lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9を参照）。&lt;/a&gt;）、HTTP / 1.0との下位互換性のためにここで定義されています。 HTTP / 1.1に準拠していないことがわかっているサーバーにキャッシュなしのリクエストが送信される場合、クライアントは両方のヘッダーフィールドを含める必要があります（SHOULD）。ディレクティブは要求/応答チェーンに沿ったすべての受信者に適用できるため、プラグマディレクティブは、そのアプリケーションにとっての重要性に関係なく、プロキシまたはゲートウェイアプリケーションによってパススルーされる必要があります。特定の受信者にプラグマを指定することはできません。ただし、受信者に関連しないプラグマディレクティブは、その受信者によって無視される必要があります（SHOULD）。 HTTP / 1.1キャッシュは、「プラグマ：no-cache」を、クライアントが「Cache-Control：no-cache」を送信したかのように扱う必要があります（SHOULD）。新しいプラグマディレクティブはHTTPで定義されません。注：「プラグマ：応答ヘッダーフィールドとしてのno-cacheは実際には指定されていません。応答内の「Cache-Control：no-cache」の信頼できる代替にはなりません。</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">Proxy-Authenticate応答ヘッダーフィールドは、407（Proxy Authentication Required）応答の一部として含まれている必要があります。フィールド値は、このリクエストURIのプロキシに適用可能な認証スキームとパラメータを示すチャレンジで構成されます。 Proxy-Authenticate = &quot;Proxy-Authenticate&quot; &quot;：&quot; 1＃challenge HTTPアクセス認証プロセスについては、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。 WWW-Authenticateとは異なり、Proxy-Authenticateヘッダーフィールドは現在の接続にのみ適用され、ダウンストリームクライアントに渡すべきではありません（SHOULD NOT）。ただし、中間プロキシは、ダウンストリームクライアントに要求することで独自の資格情報を取得する必要がある場合があります。これは、プロキシがProxy-Authenticateヘッダーフィールドを転送しているように見える場合があります。</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorizationリクエストヘッダーフィールドを使用すると、認証を必要とするプロキシに対してクライアント（またはそのユーザー）を識別できます。 Proxy-Authorizationフィールドの値は、要求されているリソースのプロキシまたはレルム、あるいはその両方のユーザーエージェントの認証情報を含む資格情報で構成されています。 Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;：&quot;資格情報HTTPアクセス認証プロセスについては、「HTTP認証：基本認証とダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。承認とは異なり、Proxy-Authorizationヘッダーフィールドは、Proxy-Authenticateフィールドを使用して認証を要求した次の送信プロキシにのみ適用されます。複数のプロキシがチェーンで使用されている場合、Proxy-Authorizationヘッダーフィールドは、資格情報を受信することを期待していた最初の送信プロキシによって消費されます。プロキシーが所定の要求を協調的に認証するメカニズムである場合、プロキシーは資格情報をクライアント要求から次のプロキシーに中継することができます（MAY）。</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">クライアントは、Referer [sic] request-headerフィールドを使用して、サーバーの利益のために、Request-URIの取得元であるリソースのアドレス（URI）を指定できます（ヘッダーフィールドのスペルが間違っていますが、「referrer」）。サーバーは、Refererリクエストヘッダーを使用して、関心のあるリソースへのバックリンク、ロギング、最適化されたキャッシュなどのリストを生成できます。また、メンテナンスのために古いリンクやタイプミスしたリンクを追跡できます。ユーザーキーボードからの入力など、独自のURIを持たないソースからRequest-URIを取得した場合は、Refererフィールドを送信してはなりません（MUST NOT）。 Referer = &quot;Referer&quot; &quot;：&quot;（absoluteURI | relativeURI）例：リファラー：&lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/hypertext/DataSources/Overview.html フィールド値が相対URIの場合は、Request-URIを基準にして解釈する必要があります（SHOULD）。URIにフラグメントを含めることはできません。セキュリティに関する考慮事項については、&lt;a href=&quot;#section-15.1.3&quot;&gt;セクション15.1.3&lt;/a&gt;を参照してください 。</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Request-Lineはメソッドトークンで始まり、Request-URIとプロトコルバージョンが続き、CRLFで終わる。要素はSP文字で区切られる。最後のCRLFシーケンス以外では、CRやLFは許されない。Request-Line=Method SP Request-URI SP HTTP-Version CRLF</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URIはUniform Resource Identifier（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、リクエストを適用するリソースを識別します。 Request-URI = &quot;*&quot; |絶対URI | abs_path |権限Request-URIの4つのオプションは、要求の性質によって異なります。アスタリスク「*」は、リクエストが特定のリソースではなくサーバー自体に適用されることを意味し、使用されるメソッドが必ずしもリソースに適用されない場合にのみ許可されます。 1つの例はOPTIONS * HTTP / 1.1です。absoluteURI形式は、リクエストがプロキシに対して行われている場合に必須です。プロキシは、要求を転送するか、有効なキャッシュからサービスを提供し、応答を返すように要求されます。プロキシは、リクエストを別のプロキシに転送することも、absoluteURIで指定されたサーバーに直接転送することもできます。リクエストループを回避するために、プロキシは、エイリアス、ローカルバリエーション、および数値IPアドレスを含む、そのサーバー名のすべてを認識できる必要があります。 Request-Lineの例：GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1今後のバージョンのHTTPですべてのリクエストのabsoluteURIへの移行を可能にするため、すべてのHTTP / 1.1サーバーはリクエストのabsoluteURIフォームを受け入れる必要があります。 HTTP / 1.1クライアントは、プロキシへのリクエストでのみそれらを生成します。権限フォームは、CONNECTメソッドでのみ使用されます（&lt;a href=&quot;#section-9.9&quot;&gt;セクション9.9&lt;/a&gt;）。 Request-URIの最も一般的な形式は、オリジンサーバーまたはゲートウェイ上のリソースを識別するために使用される形式です。この場合、URIの絶対パスを送信する必要があります（&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション3.2.1を&lt;/a&gt;参照）。、abs_path）をリクエストURIとして、URIのネットワークロケーション（権限）をホストヘッダーフィールドで送信する必要があります。たとえば、上記のリソースをオリジンサーバーから直接取得するクライアントは、ホスト &quot;www.w3.org&quot;のポート80へのTCP接続を作成し、次の行を送信します。GET /pub/WWW/TheProject.html HTTP / 1.1ホスト：www.w3.orgとそれに続くリクエストの残り。絶対パスを空にすることはできません。元のURIに何も存在しない場合は、 &quot;/&quot;（サーバールート）として指定する必要があります。 Request-URIは、&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1で&lt;/a&gt;指定された形式で送信されます。 Request-URIが「％HEX HEX」エンコーディング[ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]、オリジンサーバーは、リクエストを適切に解釈するためにリクエストURIをデコードする必要があります。サーバーは、無効なリクエストURIに適切なステータスコードで応答する必要があります（SHOULD）。透過プロキシは、次の受信サーバーに転送するときに、受信したRequest-URIの「abs_path」の部分を書き換えてはなりません（ただし、上記のnull abs_pathを「/」に置き換える場合を除く）。注：「リライトなし」ルールは、オリジンサーバーが予約された目的で予約されていないURI文字を不適切に使用している場合に、プロキシがリクエストの意味を変更しないようにします。実装者は、HTTP / 1.1より前のプロキシの一部がRequest-URIを書き換えることがわかっていることを認識しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After応答ヘッダーフィールドは、503(Service Unavailable)応答と一緒に使用して、リクエストするクライアントがサービスを利用できないことが予想される時間を示すことができる。このフィールドは、リダイレクトされたリクエストを発行する前にユーザーエージェントが 要求される最小の待ち時間を示すために、3xx(Redirection)応答と一緒に使用してもよい[MAY]。このフィールドの値は、HTTPの日付か、応答の時間の後の秒数(10進数)の整数である。Retry-After=&quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds)2つの使用例があります。Fri,31 Dec 1999 23:59:59 GMT Retry-After.120 後者の例では、遅延は2分です。</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">サーバーの応答ヘッダーフィールドには、要求を処理するためにオリジンサーバーが使用するソフトウェアに関する情報が含まれています。このフィールドには、複数の製品トークン（&lt;a href=&quot;#section-3.8&quot;&gt;セクション3.8&lt;/a&gt;）およびサーバーと重要なサブ製品を識別するコメントを含めることができます。製品トークンは、アプリケーションを識別するために重要度の高い順にリストされています。 Server = &quot;Server&quot; &quot;：&quot; 1 *（product | comment）例：サーバー：CERN / 3.0 libwww / 2.17応答がプロキシを介して転送されている場合、プロキシアプリケーションはサーバーの応答ヘッダーを変更してはなりません（MUST NOT）。代わりに、Viaフィールドを含める必要があります（&lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt;を参照）。）。注：サーバーの特定のソフトウェアバージョンを明らかにすると、サーバーマシンがセキュリティホールを含むことがわかっているソフトウェアに対する攻撃に対してより脆弱になる可能性があります。サーバーの実装者は、このフィールドを構成可能なオプションにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code要素は、要求を理解して満足する試みの3桁の整数の結果コードです。これらのコードは&lt;a href=&quot;#section-10&quot;&gt;セクション10で&lt;/a&gt;完全に定義されています。 Reason-Phraseは、Status-Codeの短いテキストによる説明を提供することを目的としています。 Status-Codeはオートマトンによる使用を意図しており、Reason-Phraseは人間のユーザーを対象としています。クライアントは、Reason-Phraseを調べたり表示したりする必要はありません。ステータスコードの最初の桁は、応答のクラスを定義します。下2桁には分類の役割はありません。最初の桁には5つの値があります。-1xx：情報-要求を受信し、プロセスを続行します-2xx：成功-アクションは正常に受信、理解、および受け入れられました-3xx：リダイレクト-要求を完了するには、さらにアクションを実行する必要があります-4xx：クライアントエラー-リクエストに不正な構文が含まれているか、実行できない-5xx：サーバーエラー-サーバーは明らかに有効なリクエストを実行できませんでしたHTTP / 1.1に定義された数値ステータスコードの個々の値、および対応する理由フレーズのサンプルセットを以下に示します。ここに記載されている理由フレーズは推奨事項にすぎません。プロトコルに影響を与えることなく、ローカルの同等のものに置き換えることができます。ステータスコード= &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;セクション10.1.1&lt;/a&gt;：続行| &quot;101&quot;; &lt;a href=&quot;#section-10.1.2&quot;&gt;セクション10.1.2&lt;/a&gt;：プロトコルの切り替え| &quot;200&quot;; &lt;a href=&quot;#section-10.2.1&quot;&gt;セクション10.2.1&lt;/a&gt;：OK | &quot;201&quot;; &lt;a href=&quot;#section-10.2.2&quot;&gt;セクション10.2.2&lt;/a&gt;：作成| &quot;202&quot;; &lt;a href=&quot;#section-10.2.3&quot;&gt;セクション10.2.3&lt;/a&gt;：承認済み| &quot;203&quot;; &lt;a href=&quot;#section-10.2.4&quot;&gt;セクション10.2.4&lt;/a&gt;：信頼できない情報| &quot;204&quot;; &lt;a href=&quot;#section-10.2.5&quot;&gt;セクション10.2.5&lt;/a&gt;：コンテンツなし| &quot;205&quot;; &lt;a href=&quot;#section-10.2.6&quot;&gt;セクション10.2.6&lt;/a&gt;：コンテンツのリセット| &quot;206&quot;; &lt;a href=&quot;#section-10.2.7&quot;&gt;セクション10.2.7&lt;/a&gt;：部分的なコンテンツ| &quot;300&quot;; &lt;a href=&quot;#section-10.3.1&quot;&gt;セクション10.3.1&lt;/a&gt;：複数の選択肢| &quot;301&quot;; &lt;a href=&quot;#section-10.3.2&quot;&gt;セクション10.3&lt;/a&gt;2 ：永久に移動しました| &quot;302&quot;;&lt;a href=&quot;#section-10.3.3&quot;&gt;セクション10.3.3&lt;/a&gt;：見つかりました| &quot;303&quot;; &lt;a href=&quot;#section-10.3.4&quot;&gt;セクション10.3.4&lt;/a&gt;：その他を参照| &quot;304&quot;; &lt;a href=&quot;#section-10.3.5&quot;&gt;セクション10.3.5&lt;/a&gt;：変更なし| &quot;305&quot;; &lt;a href=&quot;#section-10.3.6&quot;&gt;セクション10.3.6&lt;/a&gt;：プロキシの使用| &quot;307&quot;; &lt;a href=&quot;#section-10.3.8&quot;&gt;セクション10.3.8&lt;/a&gt;：一時的なリダイレクト| &quot;400&quot;; &lt;a href=&quot;#section-10.4.1&quot;&gt;セクション10.4.1&lt;/a&gt;：不正な要求| &quot;401&quot;; &lt;a href=&quot;#section-10.4.2&quot;&gt;セクション10.4.2&lt;/a&gt;：不正| &quot;402&quot;; &lt;a href=&quot;#section-10.4.3&quot;&gt;セクション10.4.3&lt;/a&gt;：支払いが必要| &quot;403&quot;; &lt;a href=&quot;#section-10.4.4&quot;&gt;セクション10.4.4&lt;/a&gt;：禁止| &quot;404&quot;; &lt;a href=&quot;#section-10.4.5&quot;&gt;セクション10.4.5&lt;/a&gt;：見つかりません| &quot;405&quot;; &lt;a href=&quot;#section-10.4.6&quot;&gt;セクション10.4.6&lt;/a&gt;：メソッドは許可されていません| &quot;406&quot;; &lt;a href=&quot;#section-10.4.7&quot;&gt;セクション10.4.7&lt;/a&gt;：不可| &quot;407&quot;; &lt;a href=&quot;#section-10.4.8&quot;&gt;セクション10.4.8&lt;/a&gt;：プロキシ認証が必要| &quot;408&quot;; &lt;a href=&quot;#section-10.4.9&quot;&gt;セクション10.4.9&lt;/a&gt;：リクエストのタイムアウト| &quot;409&quot;; &lt;a href=&quot;#section-10.4.10&quot;&gt;セクション10.4.10&lt;/a&gt;：競合| &quot;410&quot;; &lt;a href=&quot;#section-10.4.11&quot;&gt;セクション10.4.11&lt;/a&gt;：終了| &quot;411&quot;; &lt;a href=&quot;#section-10.4.12&quot;&gt;セクション10.4.12&lt;/a&gt;：必要な長さ| &quot;412&quot;; &lt;a href=&quot;#section-10.4.13&quot;&gt;セクション10.4.13&lt;/a&gt;：前提条件が失敗しました| &quot;413&quot;; &lt;a href=&quot;#section-10.4.14&quot;&gt;セクション10.4.14&lt;/a&gt;：要求エンティティが大きすぎます| &quot;414&quot;; &lt;a href=&quot;#section-10.4.15&quot;&gt;セクション10.4.15&lt;/a&gt;：Request-URIが大きすぎる| &quot;415&quot;; &lt;a href=&quot;#section-10.4.16&quot;&gt;セクション10.4.16&lt;/a&gt;：サポートされていないメディアタイプ| &quot;416&quot;;&lt;a href=&quot;#section-10.4.17&quot;&gt;セクション10.4.17&lt;/a&gt;：要求された範囲は満足できません| &quot;417&quot;; &lt;a href=&quot;#section-10.4.18&quot;&gt;セクション10.4.18&lt;/a&gt;：期待に失敗しました| &quot;500&quot;; &lt;a href=&quot;#section-10.5.1&quot;&gt;セクション10.5.1&lt;/a&gt;：内部サーバーエラー| &quot;501&quot;; &lt;a href=&quot;#section-10.5.2&quot;&gt;セクション10.5.2&lt;/a&gt;：未実装| &quot;502&quot;; &lt;a href=&quot;#section-10.5.3&quot;&gt;セクション10.5.3&lt;/a&gt;：不正なゲートウェイ| &quot;503&quot;; &lt;a href=&quot;#section-10.5.4&quot;&gt;セクション10.5.4&lt;/a&gt;：サービスを利用できません| &quot;504&quot;; &lt;a href=&quot;#section-10.5.5&quot;&gt;セクション10.5.5&lt;/a&gt;：ゲートウェイのタイムアウト| &quot;505&quot;; &lt;a href=&quot;#section-10.5.6&quot;&gt;セクション10.5.6&lt;/a&gt;：HTTPバージョンはサポートされていません| extension-code extension-code = 3DIGIT Reason-Phrase = * &amp;lt;CR、LFを除くテキスト&amp;gt; HTTPステータスコードは拡張可能です。 HTTPアプリケーションは、登録されたすべてのステータスコードの意味を理解する必要はありませんが、そのような理解が明らかに望ましいです。ただし、アプリケーションは、最初の桁で示されるように、ステータスコードのクラスを理解しなければならず、認識されない応答はキャッシュされてはならないことを除いて、認識されない応答をそのクラスのx00ステータスコードと同等のものとして扱う必要があります。たとえば、認識されないステータスコード431をクライアントが受信した場合、リクエストに問題があると想定して、400ステータスコードを受信したかのように応答を処理できます。そのような場合、エンティティは異常なステータスを説明する人間が読み取れる情報を含む可能性が高いため、ユーザーエージェントはユーザーにレスポンスとともに返されたエンティティを提示する必要があります。</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP ハンドシェイク自体には時間がかかりますが、TCP 接続は負荷に適応し、持続的な(またはウォームな)接続が多いほど効率的になります。短命の接続では、TCP のこの効率性の特徴を利用しておらず、新しいコールド・コネクションでの送信を継続することで、パフォーマンスが最適から低下します。</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE要求ヘッダーフィールドは、応答で受け入れることができる拡張転送コーディングと、チャンク転送コーディングでトレーラーフィールドを受け入れるかどうかを示します。その値は、キーワード「予告編」および/またはオプションの受け入れパラメーター（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;説明）を備えた拡張転送コーディング名のコンマ区切りリストで構成されます。 TE = &quot;TE&quot; &quot;：&quot;＃（t-codings）t-codings = &quot;trailers&quot; | （transfer-extension [accept-params]）キーワード「trailers」の存在は、&lt;a href=&quot;#section-3.6.1&quot;&gt;セクション3.6.1で&lt;/a&gt;定義されているように、クライアントがチャンク転送コーディングのトレーラーフィールドを受け入れる用意があることを示します。。このキーワードはそれ自体が転送コーディングを表していない場合でも、転送コーディング値で使用するために予約されています。その使用例は次のとおりです。TE：deflate TE：TE：トレーラー、deflate; q = 0.5 TEヘッダーフィールドは、即時接続にのみ適用されます。したがって、キーワードはConnectionヘッダーフィールド内に指定する必要があります（&lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt;）TEがHTTP / 1.1メッセージに存在する場合。サーバーは、TEフィールドに従って、次のルールを使用して、転送コーディングが受け入れ可能かどうかをテストします。1.「チャンクされた」転送コーディングは常に受け入れ可能です。キーワード「予告編」がリストされている場合、クライアントは、自分自身とダウンストリームクライアントに代わってチャンクされた応答の予告フィールドを受け入れる用意があることを示します。つまり、クライアントは、指定された場合、すべてのダウンストリームクライアントが転送された応答のトレーラーフィールドを受け入れる用意があるか、またはダウンストリームの受信者に代わって応答をバッファリングしようとすることを示しています。注：HTTP / 1。1は、チャンクされた応答のサイズを制限してクライアントが応答全体を確実にバッファリングできるようにする手段を定義していません。 2.テストされる転送コーディングがTEフィールドにリストされている転送コーディングの1つである場合、qvalueが0を伴わない限り許容されます（（&lt;a href=&quot;#section-3.9&quot;&gt;セクション3.9&lt;/a&gt;、qvalue 0は「受け入れられない」を意味します。）3.複数の転送コーディングが受け入れられる場合、ゼロ以外のqvalueが最も高い受け入れ可能な転送コーディングが優先されます。 「チャンク」転送コーディングのqvalueは常に1です。TEフィールド値が空の場合、またはTEフィールドが存在しない場合、唯一の転送コーディングは「チャンク」されます。 transfer-codingのないメッセージは常に受け入れられます。</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACEメソッドは、要求メッセージのリモートのアプリケーション層ループバックを呼び出すために使用されます。リクエストの最後の受信者は、クライアントに返されたメッセージを200（OK）応答のエンティティ本体として反映する必要があります（SHOULD）。最終受信者は、起点サーバー、またはリクエストでゼロ（0）のMax-Forwards値を受信する最初のプロキシまたはゲートウェイです（&lt;a href=&quot;#section-14.31&quot;&gt;セクション14.31を&lt;/a&gt;参照）。 TRACEリクエストにエンティティを含めることはできません。 TRACEを使用すると、クライアントは要求チェーンの反対側で受信されているものを確認し、そのデータをテストまたは診断情報に使用できます。 Viaヘッダーフィールドの値（&lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt;）は、リクエストチェーンのトレースとして機能するため、特に重要です。 Max-Forwardsヘッダーフィールドを使用すると、クライアントはリクエストチェーンの長さを制限できます。これは、無限ループでメッセージを転送するプロキシのチェーンをテストするのに役立ちます。リクエストが有効な場合、レスポンスには、リクエストメッセージ全体がエンティティ本体に含まれ、Content-Typeは「message / http」になります。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACEメソッドは、要求メッセージのリモートのアプリケーションレベルのループバックを要求します。リクエストの最後の受信者は、以下に説明するいくつかのフィールドを除いて、受信したメッセージを、「メッセージ/ http」のContent-Typeを持つ200（OK）応答のメッセージ本文としてクライアントに反映する必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;セクション8.3.1の[RFC7230]&lt;/a&gt;）。最終受信者は、起点サーバーか、リクエストでMax-Forwards値ゼロ（0）を受信する最初のサーバーです（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）。クライアントは、応答によって開示される可能性のある機密データを含むTRACE要求でヘッダーフィールドを生成してはなりません（MUST NOT）。たとえば、ユーザーエージェントが保存されたユーザー資格情報[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]またはCookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;を送信するのはばかげています。] TRACEリクエスト内。リクエストの最後の受信者は、その受信者が応答本文を生成するときに機密データを含む可能性のあるリクエストヘッダーフィールドを除外する必要があります（SHOULD）。 TRACEを使用すると、クライアントは要求チェーンの反対側で受信されているものを確認し、そのデータをテストまたは診断情報に使用できます。 Viaヘッダーフィールドの値（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]のセクション5.7.1&lt;/a&gt;）は、リクエストチェーンのトレースとして機能するため、特に重要です。 Max-Forwardsヘッダーフィールドを使用すると、クライアントはリクエストチェーンの長さを制限できます。これは、無限ループでメッセージを転送するプロキシのチェーンをテストするのに役立ちます。クライアントは、TRACEリクエストでメッセージ本文を送信してはいけません。 TRACEメソッドへの応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Trailerの一般的なフィールドの値は、指定されたヘッダーフィールドのセットが、チャンク転送コーディングでエンコードされたメッセージのトレーラーに存在することを示しています。 Trailer = &quot;Trailer&quot; &quot;：&quot; 1＃field-name HTTP / 1.1メッセージは、空でないトレーラーでチャンク転送コーディングを使用して、メッセージにトレーラーヘッダーフィールドを含める必要があります（SHOULD）。そうすることで、受信者はトレーラーで予期されるヘッダーフィールドを知ることができます。トレーラーヘッダーフィールドが存在しない場合、トレーラーにはヘッダーフィールドを含めないでください。「チャンク」転送コーディングでのトレーラフィールドの使用に関する制限については、&lt;a href=&quot;#section-3.6.1&quot;&gt;セクション3.6.1&lt;/a&gt;を参照してください。 Trailerヘッダーフィールドにリストされているメッセージヘッダーフィールドには、次のヘッダーフィールドを含めることはできません。 Transfer-Encoding。 Content-Length。トレーラー</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Transfer-EncodingのGeneral-Headerフィールドは、送信者と受信者の間でメッセージを安全に転送するために、メッセージの本文に適用された変換のタイプ（存在する場合）を示します。これは、転送コーディングがエンティティではなくメッセージのプロパティである点で、コンテンツコーディングとは異なります。 Transfer-Encoding = &quot;Transfer-Encoding&quot; &quot;：&quot; 1＃transfer-coding Transfer-codingsは&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;定義されています。例は次のとおりです。Transfer-Encoding：chunked複数のエンコーディングがエンティティに適用されている場合、それらが適用された順序でtransfer-codingsをリストする必要があります。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のエンティティヘッダーフィールドによって提供される場合があります。古いHTTP / 1.0アプリケーションの多くは、Transfer-Encodingヘッダーを理解していません。</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encodingヘッダーフィールドには、メッセージ本文を形成するためにペイロード本文に適用された（または今後適用される）転送コーディングのシーケンスに対応する転送コーディング名がリストされます。転送コーディングは&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;定義されています。 Transfer-Encoding = 1＃transfer-coding Transfer-Encodingは、MIMEのContent-Transfer-Encodingフィールドに類似しています。これは、7ビットのトランスポートサービス（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045]、セクション6&lt;/a&gt;でバイナリデータを安全にトランスポートできるように設計されています。）。ただし、安全な転送では、8ビットのクリーンな転送プロトコルに対して別の焦点があります。 HTTPの場合、Transfer-Encodingは主に、動的に生成されたペイロードを正確に区切り、転送効率またはセキュリティにのみ適用されるペイロードエンコーディングを、選択されたリソースの特性と区別することを目的としています。受信者はチャンク転送コーディングを解析できなければなりません（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1）。&lt;/a&gt;）ペイロードの本体サイズが事前にわからない場合、メッセージのフレーミングに重要な役割を果たすからです。送信者は、チャンクをメッセージ本文に複数回適用してはなりません（つまり、すでにチャンクされたメッセージのチャンクは許可されていません）。チャンク以外の転送コーディングが要求ペイロード本体に適用される場合、送信者はメッセージが適切にフレーム化されることを保証するために、チャンクを最終転送コーディングとして適用する必要があります。チャンク以外の転送コーディングが応答ペイロード本体に適用される場合、送信者はチャンクを最終的な転送コーディングとして適用するか、接続を閉じることによってメッセージを終了する必要があります。たとえば、Transfer-Encoding：gzip、chunkedは、ペイロード本文がgzipコーディングを使用して圧縮され、メッセージ本文の作成中にチャンクコーディングを使用してチャンク化されたことを示します。Content-Encoding（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]のセクション3.1.2.1&lt;/a&gt;））、Transfer-Encodingは表現ではなくメッセージのプロパティであり、要求/応答チェーンに沿った受信者は、受信した転送コーディングをデコードするか、追加の転送コーディングを適用することができます（MAY） ）メッセージ本文に、対応する変更がTransfer-Encodingフィールド値に加えられたと仮定して。エンコーディングパラメータに関する追加情報は、この仕様で定義されていない他のヘッダーフィールドから提供できます。 Transfer-Encodingは、HEAD要求への応答または304（変更されていない）応答で送信できます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]のセクション4.1&lt;/a&gt;）。）GETリクエスト（いずれもメッセージ本文が含まれていない）に送信します。これは、リクエストが無条件GETであった場合に、オリジンサーバーがメッセージ本文に転送コーディングを適用したことを示します。ただし、応答チェーン（オリジンサーバーを含む）の受信者は、不要な転送コーディングを削除できるため、この指示は必要ありません。サーバーは、ステータスコード1xx（情報）または204（コンテンツなし）の応答でTransfer-Encodingヘッダーフィールドを送信してはなりません（MUST NOT）。サーバーは、CONNECTリクエストに対する2xx（成功）応答でTransfer-Encodingヘッダーフィールドを送信してはなりません（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6）。&lt;/a&gt;）。 Transfer-EncodingはHTTP / 1.1で追加されました。一般に、HTTP / 1.0サポートのみをアドバタイズする実装は、転送エンコードされたペイロードの処理方法を理解しないと想定されています。クライアントが、サーバーがHTTP / 1.1（またはそれ以降）の要求を処理することを認識していない限り、Transfer-Encodingを含む要求を送信してはなりません（MUST NOT）。そのような知識は、特定のユーザー構成の形で、または以前に受け取った応答のバージョンを記憶することである場合があります。対応する要求がHTTP / 1.1（またはそれ以降）を示さない限り、サーバーはTransfer-Encodingを含む応答を送信してはなりません（MUST NOT）。転送コーディングを含む要求メッセージを受信したサーバーは、501（実装されていません）で応答する必要があることを理解していません。</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">トランスポートレイヤセキュリティ(TLS)プロトコルバージョン1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">トランスポートレイヤセキュリティ(TLS)プロトコルバージョン1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">FirefoxのUA文字列自体は4つのコンポーネントに分解されています。</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCKメソッドは、Lock-Tokenリクエストヘッダーのロックトークンによって識別されるロックを削除します。 Request-URIは、ロックのスコープ内のリソースを識別しなければなりません（MUST）。 Lock-Tokenヘッダーを使用してロックトークンを提供することは、他の状態変更メソッドと一貫していないことに注意してください。これらのメソッドはすべて、ロックトークンを持つIfヘッダーを必要とします。したがって、ロックトークンを提供するためにIfヘッダーは必要ありません。当然、Ifヘッダーが存在する場合、条件付きヘッダーとしての通常の意味があります。このメソッドに正常に応答するには、サーバーはロックを完全に削除する必要があります。送信されたロックトークンでロックされているすべてのリソースをロック解除できない場合、UNLO​​CKリクエストは失敗する必要があります。 UNLOCKメソッドへの正常な応答は、リソースが必ずしもロック解除されていることを意味しません。これは、指定されたトークンに対応する特定のロックが存在しないことを意味します。 LOCKメソッドをサポートするDAV準拠のリソースは、UNLO​​CKメソッドをサポートする必要があります。この方法はべき等ですが、安全ではありません（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">違反が発生した文書のURI。</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">コンテンツセキュリティポリシーによってロードがブロックされたリソースのURI。ブロックされたURIが &lt;code&gt;document-uri&lt;/code&gt; とは異なるオリジンからのものである場合、ブロックされたURIは切り捨てられ、スキーム、ホスト、およびポートのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">コンテンツセキュリティポリシーによって読み込みがブロックされたリソースの URI。ブロックされたURIがdocument-uriとは異なる起源からのものである場合、ブロックされたURIは、スキーム、ホスト、ポートだけを含むように切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">クライアントが要求したURIは、サーバーが解釈したいと思っているよりも長い。</target>
        </trans-unit>
        <trans-unit id="3c5fb5f7c661d221d889ac05db6f82fe9c0205e8" translate="yes" xml:space="preserve">
          <source>The URI where the user agent should report &lt;code&gt;Expect-CT&lt;/code&gt; failures.</source>
          <target state="translated">ユーザーエージェントが &lt;code&gt;Expect-CT&lt;/code&gt; の失敗を報告する必要があるURI 。</target>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;http://example.com/&lt;/code&gt; は &lt;code&gt;http://www.example.com/&lt;/code&gt; にリダイレクトされ、その下にあるファイルやディレクトリもすべてリダイレクトされます（ &lt;code&gt;http://example.com/index.html&lt;/code&gt; は &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; にリダイレクトされます） ：//www.example.com/index.html）</target>
        </trans-unit>
        <trans-unit id="5efef24fc6384dd41fb192a1bf80a33651bde15a" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;https://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;https://example.com/some-page&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/some-page&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;https://example.com/&lt;/code&gt; はにリダイレクトされます &lt;code&gt;https://www.example.com/&lt;/code&gt; その下に任意のファイルやディレクトリが（うとして、 &lt;code&gt;https://example.com/some-page&lt;/code&gt; はにリダイレクトされます &lt;code&gt;https://www.example.com/some-page&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab68e1cdf6b3b2fc5d165ae5d131fcb809d37323" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome (versions 52 to 73), you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in policy or by launching with the &lt;code&gt;--unsafe-pac-url&lt;/code&gt; command-line flag (in Chrome 74, only the flag works, and from 75 onward, there is no way to disable path-stripping; as of Chrome 81, path-stripping does not apply to HTTP URLs, but there is interest in changing this behavior to match HTTPS); in Firefox, the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">アクセスされているURL。 &lt;code&gt;https://&lt;/code&gt; URLのパスおよびクエリコンポーネントが削除されます。Chrome（バージョン52から73）では、ポリシーで &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定するか、 &lt;code&gt;--unsafe-pac-url&lt;/code&gt; コマンドラインフラグを使用して起動することでこれを無効にできます（Chrome 74では、フラグのみが機能し、75以降、パスストリッピングを無効にする方法はありません。Chrome81の時点では、パスストリッピングはHTTP URLには適用されませんが、HTTPSに一致するようにこの動作を変更することに関心があります。Firefoxでは、設定は &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">アクセスされているURL。 &lt;code&gt;https://&lt;/code&gt; URL のパスおよびクエリコンポーネントは削除されます。Chromeでは、これを無効にするには、 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定します。Firefoxでは、プリファレンスは &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1aac5516d3c0193c8b37aa0f0d853eb420d0c8fa" translate="yes" xml:space="preserve">
          <source>The URL of the requested resource has been changed permanently. The new URL is given in the response.</source>
          <target state="translated">要求されたリソースの URL が永久に変更されました。新しいURLはレスポンスで与えられます。</target>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">Upgrade汎用ヘッダーを使用すると、クライアントは、サポートする追加の通信プロトコルを指定でき、サーバーがプロトコルの切り替えに適切であると判断した場合に使用します。サーバーは、101（Switching Protocols）応答内のUpgradeヘッダーフィールドを使用して、切り替えられるプロトコルを示す必要があります。 Upgrade = &quot;Upgrade&quot; &quot;：&quot; 1＃productたとえば、Upgrade：HTTP / 2.0、SHTTP / 1.3、IRC / 6.9、RTA / x11 Upgradeヘッダーフィールドは、HTTP / 1.1から一部に移行するための簡単なメカニズムを提供することを目的としていますその他、互換性のないプロトコル。これは、現在の要求がHTTP / 1.1を使用して行われた場合でも、クライアントが別のプロトコル（メジャーバージョン番号が大きい新しいバージョンのHTTPなど）を使用したいという希望を宣伝できるようにすることで実現します。これにより、クライアントがより一般的にサポートされているプロトコルで要求を開始できるようにし、利用可能な場合は「より良い」プロトコルを使用することをサーバーに示します（「より良い」はサーバーによって決定されます）。 、おそらくメソッドやリソースのリクエストに応じて）。 Upgradeヘッダーフィールドは、既存のトランスポート層接続でのアプリケーション層プロトコルの切り替えにのみ適用されます。アップグレードを使用してプロトコルの変更を要求することはできません。サーバーによるその受け入れと使用はオプションです。プロトコル変更後のアプリケーション層通信の機能と性質は、選択した新しいプロトコルに完全に依存しています。ただし、プロトコル変更後の最初のアクションは、Upgradeヘッダーフィールドを含む最初のHTTPリクエストへの応答でなければなりません。 Upgradeヘッダーフィールドは、直接接続にのみ適用されます。したがって、アップグレードキーワードはConnectionヘッダーフィールド（&lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt;）アップグレードがHTTP / 1.1メッセージに存在する場合は常に。 Upgradeヘッダーフィールドを使用して、別の接続上のプロトコルへの切り替えを示すことはできません。そのためには、301、302、303、または305リダイレクト応答を使用する方が適切です。この仕様では、&lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1の&lt;/a&gt; HTTPバージョンルールおよびこの仕様の将来の更新で定義されているように、ハイパーテキスト転送プロトコルのファミリで使用するプロトコル名「HTTP」のみを定義しています。任意のトークンをプロトコル名として使用できます。ただし、クライアントとサーバーの両方が名前を同じプロトコルに関連付ける場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">User-Agent（&lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt;）、Via（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]のセクション5.7.1&lt;/a&gt;）、およびServer（&lt;a href=&quot;#section-7.4.2&quot;&gt;セクション7.4.2&lt;/a&gt;）ヘッダーフィールドは、それぞれの送信者のソフトウェアシステムに関する情報を明らかにします。理論的には、これにより攻撃者は既知のセキュリティホールを簡単に悪用することができます。実際には、攻撃者は使用されているソフトウェアのバージョンに関係なく、すべての潜在的なホールを試す傾向があります。ネットワークファイアウォールを介してポータルとして機能するプロキシは、ファイアウォールの背後にあるホストを識別する可能性があるヘッダー情報の転送に関して、特別な予防策を講じる必要があります。 Viaヘッダーフィールドを使用すると、仲介者が機密のマシン名を仮名に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="d9bc48b6946945b170102521a95dcc585d202997" translate="yes" xml:space="preserve">
          <source>The User-Agent header</source>
          <target state="translated">ユーザーエージェントヘッダー</target>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">User-Agentリクエストヘッダーフィールドには、リクエストを発信したユーザーエージェントに関する情報が含まれます。これは統計的な目的、プロトコル違反の追跡、特定のユーザーエージェントの制限を回避するために応答を調整するためのユーザーエージェントの自動認識のためのものです。ユーザーエージェントは、リクエストにこのフィールドを含める必要があります。このフィールドには、複数の製品トークン（&lt;a href=&quot;#section-3.8&quot;&gt;セクション3.8&lt;/a&gt;）と、ユーザーエージェントの重要な部分を形成するエージェントおよびサブ製品を識別するコメントを含めることができます。慣例により、製品トークンは、アプリケーションを識別するために重要度の高い順にリストされています。 User-Agent = &quot;User-Agent&quot; &quot;：&quot; 1 *（product | comment）例：User-Agent：CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Varyフィールド値は、応答が新しい間、キャッシュが再検証なしで後続の要求に応答するために応答を使用することを許可されるかどうかを完全に決定する要求ヘッダーフィールドのセットを示します。キャッシュ不可または古い応答の場合、Varyフィールドの値は、表現の選択に使用された基準についてユーザーエージェントに通知します。 「*」のVaryフィールド値は、キャッシュが後続の要求の要求ヘッダーから、この応答が適切な表現であるかどうかを判断できないことを意味します。&lt;a href=&quot;#section-13.6&quot;&gt;セクション13.6を&lt;/a&gt;参照 キャッシュによるVaryヘッダーフィールドの使用。 Vary = &quot;Vary&quot; &quot;：&quot;（ &quot;*&quot; | 1＃field-name）HTTP / 1.1サーバーは、サーバー主導のネゴシエーションの対象となるキャッシュ可能な応答を持つVaryヘッダーフィールドを含める必要があります（SHOULD）。そうすることで、キャッシュはそのリソースに対する将来の要求を適切に解釈し、そのリソースでのネゴシエーションの存在についてユーザーエージェントに通知できます。サーバーは、サーバー主導のネゴシエーションの対象となる、キャッシュできない応答を持つVaryヘッダーフィールドを含めることができます。これは、ユーザーエージェントに、応答時に応答が変化するディメンションに関する有用な情報を提供するためです。フィールド名のリストで構成されるVaryフィールド値は、応答に対して選択された表現が、最も適切な表現を選択する際にリストされたリクエストヘッダーフィールド値のみを考慮する選択アルゴリズムに基づいていることを通知します。キャッシュは、応答が新しい間、リストされたフィールド名に同じ値を持つ将来のリクエストに対して同じ選択が行われると想定する場合があります。指定されたフィールド名は、この仕様で定義されている一連の標準リクエストヘッダーフィールドに限定されません。フィールド名は大文字と小文字を区別しません。 「*」のVaryフィールド値は、要求ヘッダー（クライアントのネットワークアドレスなど）に限定されない未指定のパラメーターが、応答表現の選択に役割を果たすことを示します。 「* &quot;値はプロキシサーバーで生成してはなりません（MUST NOT）。値はオリジンサーバーでのみ生成できます。</target>
        </trans-unit>
        <trans-unit id="c4eba333151816238416f3ddeba94021b6342f57" translate="yes" xml:space="preserve">
          <source>The Vary response header</source>
          <target state="translated">Vary レスポンスヘッダ</target>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">Via general-headerフィールドは、リクエストでユーザーエージェントとサーバーの間、および応答でオリジンサーバーとクライアントの間の中間プロトコルと受信者を示すために、ゲートウェイとプロキシで使用する必要があります。これは、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9の&lt;/a&gt;「受信」フィールドに類似してい ます。]メッセージ転送の追跡、要求ループの回避、および要求/応答チェーンに沿ったすべての送信者のプロトコル機能の識別に使用することを目的としています。 Via = &quot;Via&quot; &quot;：&quot; 1＃（received-protocol received-by [comment]）received-protocol = [protocol-name &quot;/&quot;] protocol-version protocol-name = token protocol-version = token received-by = （ホスト[&quot;：&quot;ポート]）| pseudonym pseudonym = token received-protocolは、要求/応答チェーンの各セグメントに沿ってサーバーまたはクライアントが受信したメッセージのプロトコルバージョンを示します。受信プロトコルバージョンは、メッセージが転送されるときにViaフィールド値に追加されるため、アップストリームアプリケーションのプロトコル機能に関する情報はすべての受信者に表示されたままになります。 protocol-nameは、 &quot;HTTP&quot;の場合のみオプションです。 received-byフィールドは通常、後でメッセージを転送した受信者サーバーまたはクライアントのホストおよびオプションのポート番号です。ただし、実際のホストが機密情報であると見なされる場合は、仮名に置き換えることができます。ポートが指定されていない場合、それは受信プロトコルのデフォルトポートであると見なされる場合があります。複数のViaフィールド値は、メッセージを転送した各プロキシまたはゲートウェイを表します。各受信者は、転送アプリケーションのシーケンスに従って最終結果が順序付けられるように、情報を追加する必要があります。 User-AgentおよびServerヘッダーフィールドと同様に、Viaヘッダーフィールドでコメントを使用して、受信者プロキシまたはゲートウェイのソフトウェアを識別できます。ただし、[Via]フィールドのすべてのコメントはオプションであり、メッセージを転送する前に受信者が削除する場合があります。たとえば、要求メッセージはHTTP / 1.0ユーザーエージェントから &quot;fred&quot;という名前の内部プロキシコードに送信され、HTTP / 1.1を使用して、要求をnowhere.comのパブリックプロキシに転送します。 www.ics.uci.eduのオリジンサーバーに転送します。 www.ics.uci.eduが受け取ったリクエストには、次のViaヘッダーフィールドがあります。Via：1.0 fred、1。1 nowhere.com（Apache / 1.1）ネットワークファイアウォールを介してポータルとして使用されるプロキシとゲートウェイは、デフォルトでは、ファイアウォールリージョン内のホストの名前とポートを転送すべきではありません。この情報は、明示的に有効にされている場合にのみ伝達されるべきです（SHOULD）。有効化されていない場合、ファイアウォールの背後にあるホストの受信ホストは、そのホストの適切な仮名に置き換えられる必要があります（SHOULD）。内部構造を非表示にするための強力なプライバシー要件がある組織の場合、プロキシは、Viaヘッダーフィールドエントリの順序付けられたサブシーケンスを、同一の受信プロトコル値と組み合わせて、そのような1つのエントリにしてもよい（MAY）。たとえば、Via：1.0 ricky、1.1 ethel、1.1 fred、1.0 lucyは、Via：1.0 ricky、1.1 mertz、1に折りたたむことができます。0 lucyアプリケーションは、それらがすべて同じ組織的制御下にあり、ホストがすでに仮名で置き換えられている場合を除き、複数のエントリを組み合わせるべきではありません（SHOULD NOT）。アプリケーションは、異なる受信プロトコル値を持つエントリを組み合わせてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">WWW-Authenticate応答ヘッダーフィールドは、401（無許可）応答メッセージに含まれている必要があります。フィールド値は、Request-URIに適用可能な認証スキームとパラメータを示す少なくとも1つのチャレンジで構成されます。 WWW-Authenticate = &quot;WWW-Authenticate&quot; &quot;：&quot; 1＃challenge HTTPアクセス認証プロセスについては、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で説明しています。ユーザーエージェントは、WWW-Authenticateフィールドの値を解析する際に特別な注意を払うことをお勧めします。複数のチャレンジが含まれている可能性があります。または、複数のWWW-Authenticateヘッダーフィールドが提供されている場合、チャレンジ自体の内容にカンマ区切りを含めることができます。認証パラメータのリスト。</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">警告の一般ヘッダーフィールドは、メッセージに反映されない可能性があるメッセージのステータスまたは変換に関する追加情報を伝えるために使用されます。この情報は、通常、メッセージのエンティティ本体に適用されるキャッシング操作または変換による意味の透過性の欠如の可能性について警告するために使用されます。警告ヘッダーは、次を使用して応答とともに送信されます：警告= &quot;警告&quot; &quot;：&quot; 1＃warning-value警告値= warn-code SP warn-agent SP warn-text [SP warn-date] warn-code = 3DIGIT warn-agent =（host [&quot;：&quot; port]）|仮名;追加するサーバーの名前または仮名。警告ヘッダーデバッグで使用する場合warn-text = quoted-string warn-date = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;応答には、複数の警告ヘッダーが含まれる場合があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。警告テキストは、応答を受け取るユーザーが理解できる可能性が最も高い自然言語と文字セットである必要があります（SHOULD）。この決定は、キャッシュまたはユーザーの場所、リクエストのAccept-Languageフィールド、レスポンスのContent-Languageフィールドなど、利用可能な知識に基づいている場合があります。デフォルトの言語は英語で、デフォルトの文字セットです。 ISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。応答のContent-Languageフィールドなど。デフォルトの言語は英語で、デフォルトの文字セットはISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。応答のContent-Languageフィールドなど。デフォルトの言語は英語で、デフォルトの文字セットはISO-8859-1です。 ISO-8859-1以外の文字セットを使用する場合は、で説明されている方法を使用して、警告テキストにエンコードする必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]。警告ヘッダーは一般にどのメッセージにも適用できますが、一部の特定の警告コードはキャッシュに固有であり、応答メッセージにのみ適用できます。新しい警告ヘッダーは、既存の警告ヘッダーの後に追加する必要があります。キャッシュは、メッセージとともに受信した警告ヘッダーを削除してはなりません（MUST NOT）。ただし、キャッシュがキャッシュエントリの検証に成功した場合、特定の警告コードに指定されている場合を除き、そのエントリに以前に付加された警告ヘッダーを削除する必要があります（SHOULD）。次に、検証応答で受信した警告ヘッダーを追加する必要があります。つまり、警告ヘッダーは、最新の関連する応答に添付されるヘッダーです。応答に複数の警告ヘッダーが添付されている場合、ユーザーエージェントは、それらをできるだけ多くユーザーに通知する必要があります。応答に現れる順序で。すべての警告をユーザーに通知することが不可能な場合、ユーザーエージェントは次のヒューリスティックに従います。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、-応答の早い段階で表示される警告は、応答の後で表示される警告よりも優先されます。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、-応答の早い段階で表示される警告は、応答の後で表示される警告よりも優先されます。 -ユーザーの優先文字セットの警告は、他の文字セットの警告よりも優先されますが、警告コードと警告エージェントは同じです。複数の警告ヘッダーを生成するシステムは、このユーザーエージェントの動作を念頭に置いて、それらを並べるべきです（SHOULD）。警告に関するキャッシュの動作の要件は、警告に関するキャッシュの動作の要件は、警告に関するキャッシュの動作の要件は、&lt;a href=&quot;#section-13.1.2&quot;&gt;セクション13.1.2&lt;/a&gt;。これは、現在定義されている警告コードのリストであり、それぞれに英語の推奨警告テキストとその意味の説明が含まれています。 110 Response is staleは、返された応答が古くなっている場合は必ず含める必要があります。 111サーバーに到達できないために応答の再検証に失敗したため、キャッシュが失効した応答を返す場合、111再検証の失敗を含める必要があります。 112切断された操作は、キャッシュが一定期間ネットワークの残りの部分から意図的に切断されている場合に含める必要があります。 113キャッシュがヒューリスティックに24時間を超えるフレッシュネスライフタイムを選択し、応答の経過時間が24時間を超える場合は、ヒューリスティックな有効期限を含める必要があります。199その他の警告警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受け取ったシステムは、ユーザーに警告を表示する以外に、自動化されたアクションを実行してはなりません。 214適用さ​​れた変換は、応答のコンテンツコーディング（Content-Encodingヘッダーで指定）またはメディアタイプ（Content-Typeヘッダーで指定）を変更する変換を適用する場合、中間キャッシュまたはプロキシによって追加する必要があります。または、この警告コードがすでに応答に表示されていない限り、応答のエンティティ本体。 299その他の永続的な警告警告テキストには、人間のユーザーに提示する、またはログに記録する任意の情報を含めることができます。この警告を受け取ったシステムは、自動化されたアクションを実行してはなりません。実装がHTTP / 1.0以下のバージョンの1つ以上の警告ヘッダーを持つメッセージを送信する場合、送信者は各警告値に応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。次に、送信者は、各警告値に、応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。次に、送信者は、各警告値に、応答の日付と一致する警告日付を含める必要があります。実装がwarn-dateを含むwarning-valueを含むメッセージを受信し、そのwarn-dateが応答のDate値と異なる場合、その警告値は、保存、転送、または前にメッセージから削除する必要があります。それを使用して。 （これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。（これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。（これにより、Warningヘッダーフィールドの単純なキャッシュによる悪影響を防ぎます。）この理由ですべてのwarning-valuesが削除された場合、Warningヘッダーも削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">Web APIには、base64にエンコードまたはデコードするネイティブメソッドがあります：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64エンコードおよびデコード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">ウェブオリジンのコンセプト</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">Web ランタイムは、デスクトップ Firefox と同じユーザーエージェント文字列を使用します。</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">予期せぬ理由でWebページが一時的に利用できなくなる。そうすることで、検索エンジンはリンクを更新しなくなります。</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">このWebページは、予期せぬ理由により一時的に利用できなくなっています。そうすれば、検索エンジンはリンクを更新しません。GET以外のリンク/操作がサイトで利用可能な場合は &lt;code&gt;302&lt;/code&gt; より優れています。</target>
        </trans-unit>
        <trans-unit id="d6e1f00a886091957899f1d426a1a907509a4636" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons.</source>
          <target state="translated">予期せぬ理由でWebページが一時的に利用できない状態になっています。</target>
        </trans-unit>
        <trans-unit id="d83272b4a920a61a8fef1340e4de8c385bd7ee81" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons. Better than &lt;code&gt;302&lt;/code&gt; when non-&lt;code&gt;GET&lt;/code&gt; operations are available on the site.</source>
          <target state="translated">不測の事態により、一時的にウェブページをご利用いただけません。サイトで非 &lt;code&gt;GET&lt;/code&gt; 操作が利用可能な場合は &lt;code&gt;302&lt;/code&gt; よりも優れています。</target>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">ウェブサーバー</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">WebSocketプロトコル</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">クライアントがサーバーと通信するときに使用するWebSocketプロトコルのバージョン。この番号は、&lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocketバージョン番号レジストリに&lt;/a&gt;リストされている可能な限り最新のバージョンである必要があります。WebSocketプロトコルの最新の最終バージョンはバージョン13です。</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">XML名前空間拡張（[ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]）は、他の要素名との衝突を恐れずに新しいXML要素を追加できるようにするために、この仕様で使用されています。 WebDAVの要求と応答の本文は任意のXML要素で拡張できますが、メッセージの受信者は無視できますが、「DAV：」名前空間のXML要素は、そのXML要素が明示的に定義されていない限り、要求または応答の本文では使用しないでください。 WebDAVワーキンググループによってレビューされたIETF RFCで。 WebDAVを拡張可能かつ下位互換性のあるものにするためには、クライアントとサーバーの両方が、予期しないまたは認識されないコマンド拡張を受信したときの動作方法を知る必要があります。 XML処理の場合、つまり、クライアントとサーバーは、予期しない要素と属性（および認識されない要素のすべての子）が存在しないかのように、受信したXMLドキュメントを処理する必要があります。予期しない要素または属性には、別のコンテキストで使用される可能性があるものの、ここでは予期されないものが含まれます。処理の目的でこのようなアイテムを無視することは、もちろん、すべての情報をログに記録したり、デバッグ用に提示したりすることと一致します。この制限は、DAVプロパティ値のクライアントによる処理にも適用されます。プロパティのスキーマで特に宣言されていない限り、予期しないXML要素を無視する必要があります（SHOULD）。この制限は、サーバーがすべてのXML要素を記録する必要があるサーバーでのデッドDAVプロパティの設定には適用されません。さらに、この制限は、XMLの使用には適用されません。たとえば、XMLがエンティティ本体のコンテンツタイプである場合（たとえば、PUTの本体として使用される場合）です。受信者はXMLの処理命令を無視する必要があります（SHOULD）。したがって、WebDAVを拡張する仕様では、規範的な動作を定義するために処理命令を使用しないでください。 XML DTDフラグメントは、この仕様で定義されているすべてのXML要素に含まれています。ただし、正しいXMLは、名前空間の使用法と拡張ルールにより、DTDに従って有効になりません。特に：oこの仕様の要素は「DAV：」名前空間にあります。o特に明記しない限り、要素の順序は関係ありません。o拡張属性を追加できます。o「ANY」の要素タイプ定義の場合、その要素の規範的なテキスト定義は、その中に何があり得るか、そしてそれが何を意味するかを定義します。 o「#PCDATA」の要素タイプ定義の場合、拡張要素を追加してはなりません。 o「EMPTY」を含む他の要素タイプ定義の場合、拡張要素が追加される場合があります。これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、これは、要素を含む要素を拡張してテキストを含めることはできず、その逆も同様であることに注意してください。上記のルールによってDTD検証が緩和されると、DTDフラグメントによって記述される制約は規範的なものになります（たとえば、 &lt;a href=&quot;#appendix-A&quot;&gt;付録A&lt;/a&gt;）。XMLボディを含むWebDAVメッセージの受信者は、ハードコードされた、または動的に宣言されたDTDに従ってXMLドキュメントを検証してはなりません。このセクションでは、下位互換性のある拡張性ルールについて説明しています。また、拡張機能が下位互換性がないように設計されている場合もあります。たとえば、このドキュメントで定義されているXML要素を再利用する拡張機能を定義し、この仕様のDTDで必要な子要素の1つを省略している場合があります。</target>
        </trans-unit>
        <trans-unit id="5abb61434aba6cac3c3255f0777b6e4ab04de6f1" translate="yes" xml:space="preserve">
          <source>The abbreviation for each format links to a longer description of the format, its capabilities, and detailed browser compatibility information; including which versions introduced support and specific special features that may have been introduced later.</source>
          <target state="translated">各フォーマットの略語は、フォーマットのより長い説明、その機能、ブラウザの互換性に関する詳細な情報へのリンクとなっています。</target>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">リソースをロックする機能は、そのリソースへのアクセスを直列化するメカニズムを提供します。ロックを使用することで、オーサリングクライアントは、編集中に別のプリンシパルがリソースを変更しないという合理的な保証を提供することができます。このようにして、クライアントは「更新が失われる」問題を防ぐことができる。この仕様では、クライアントが指定した2つのパラメータ、関係するプリンシパルの数(排他的か共有か)、および付与されるアクセスの種類に応じて、ロックを変化させることができるようにしています。この文書では、書き込みという1つのアクセスタイプのロックのみを定義しています。しかし、この構文は拡張可能であり、他のアクセスタイプのロックの仕様も可能にしています。</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">上記のコンテンツセキュリティポリシーは、インラインの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を許可します</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">上記のコンテンツセキュリティポリシーでは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;要素などのインラインスタイル、および任意の要素の &lt;code&gt;style&lt;/code&gt; 属性を許可します。</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">上記は、ブラウザーから送信された&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダー（$ _SERVER ['HTTP_ORIGIN']から取得）が ' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; 'と一致するかどうかを確認します。存在する場合は、&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.comを返します。この例は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここで実行されています&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ded9ed730bf997dd582fce073e6812fd63d3ebf3" translate="yes" xml:space="preserve">
          <source>The above code would have made several incorrect assumptions:</source>
          <target state="translated">上記のコードでは、いくつかの間違った仮定をしていたでしょう。</target>
        </trans-unit>
        <trans-unit id="ced1ab96d2e07e89bba3cc71ef4220a4d87bd67e" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts &lt;code&gt;www.mozilla.org&lt;/code&gt; and &lt;code&gt;merchant.mozilla.org&lt;/code&gt; will go through the proxy.</source>
          <target state="translated">上記の例では、ホスト &lt;code&gt;www.mozilla.org&lt;/code&gt; と &lt;code&gt;merchant.mozilla.org&lt;/code&gt; がプロキシを経由することを除いて、mozilla.orgドメインのローカルホストを除くすべてにプロキシを使用します。</target>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">上記の例では、mozilla.orgドメイン内のローカルホスト以外の全てのホストにプロキシを使用しますが、ホスト www.mozilla.org と merchant.mozilla.org はプロキシを経由します。</target>
        </trans-unit>
        <trans-unit id="7aeeb6c5396c82b22fb67dae5cbdfb5d930395d8" translate="yes" xml:space="preserve">
          <source>The above permissions may be cached for 86,400 seconds (1 day).</source>
          <target state="translated">上記のパーミッションは86,400秒(1日)キャッシュされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">上記では毎回DNSを参照する必要がありますが、他のルールで結果が出ない場合にのみDNSが参照されるように、他のルールとインテリジェントにグループ化することができます。</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">追加されたセキュリティは、ドキュメントにアクセスするユーザーが &lt;code&gt;X-Frame-Options&lt;/code&gt; をサポートするブラウザーを使用している場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="442c6996e10d8c8b2aa1a7ff243ac87908709eb2" translate="yes" xml:space="preserve">
          <source>The added security is provided only if the user accessing the document is using a browser that supports &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">追加のセキュリティは、ドキュメントにアクセスするユーザーが &lt;code&gt;X-Frame-Options&lt;/code&gt; をサポートするブラウザを使用している場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">現在要求されているページへのリンクが張られている前のウェブページのアドレス。</target>
        </trans-unit>
        <trans-unit id="b7f363462ba0e835d6efe5f6a4a754557a175395" translate="yes" xml:space="preserve">
          <source>The allow list is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">許可リストは &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">allowlistは、以下の値のいずれかを取るオリジンのリストです。</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">このヘッダーの代替および事実上の標準バージョンは、&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt;ヘッダーです。</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">app:categories要素は、カテゴリのリストが固定かオープンセットかを示す &quot;yes &quot;または &quot;no &quot;の値を持つ &quot;fixed &quot;属性を含むことができます。fixed」属性がない場合は、値が「no」の「fixed」属性があることと同じです。代わりに、app:categories要素は「href」属性を含んでもよい[MAY]。その値は、Category Documentを識別するIRI参照でなければならない[MUST]。href」属性が提供された場合、app:categories要素は空でなければならず[MUST]、「fixed」または「scheme」属性を持ってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">app：collection要素は、Atomフィードドキュメントのatom：feedまたはatom：source要素の子として表示される場合があります。そのコンテンツは、フィードに表示するために新しいエントリを追加できるコレクションを識別します。アトム：フィードまたはアトム：ソース要素に現れる場合&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;、[RFC4287]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;セクション&lt;/a&gt;6で定義されているように、app：コレクション要素は外部マークアップと見なされます。</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">app:collection要素は、コレクションのIRIを与える &quot;href &quot;属性を含まなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">app：workspace要素は、1つの &quot;atom：title&quot;要素（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]で定義されている）を含み、人間が読めるワークスペースのタイトルを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">application / httpタイプは、1つ以上のHTTP要求または応答メッセージ（混合されていない）のパイプラインを囲むために使用できます。タイプ名：アプリケーションサブタイプ名：http必須パラメーター：N / Aオプションパラメーター：バージョン、msgtypeバージョン：囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信する場合は、適切なContent-Transfer-Encodingを使用する必要があります。セキュリティに関する考慮事項：&lt;a href=&quot;#section-9&quot;&gt;セクション9を参照&lt;/a&gt; 相互運用性に関する考慮事項：N / A公開された仕様：この仕様（&lt;a href=&quot;#section-8.3.2&quot;&gt;セクション8.3.2を&lt;/a&gt;参照）。このメディアタイプを使用するアプリケーション：該当なしフラグメント識別子の考慮事項：該当なし追加情報：このタイプの廃止されたエイリアス名：該当なしマジック番号：該当なしファイル拡張子：該当なしMacintoshファイルタイプコード：該当なし詳細については、連絡先の人物と電子メールアドレス：作成者のアドレスセクションを参照してください。使用目的：共通使用上の制限：なし作成者：「作成者のアドレス」セクションを参照してください。コントローラーの変更：IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">&lt;a href=&quot;cors&quot;&gt;クライアントとサーバーの両方で使用されるHTTPヘッダー&lt;/a&gt;に関する記事はこちらにあり、前提条件として読む必要があります。</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">アスタリスクはリソースを表す特別な値です。</target>
        </trans-unit>
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">アスタリスクは、リソースを表す特別な値です。通常は&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;を使用してリソースをアップロードする場合にのみ、IDを持つ別のリソースがすでにアップロードされているかどうかを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">request-targetのアスタリスク形式は、サーバー全体のOPTIONSリクエストにのみ使用されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;[RFC7231]のセクション4.3.7&lt;/a&gt;）。 asterisk-form = &quot;*&quot;クライアントがそのサーバーの特定の名前付きリソースではなく、サーバー全体のOPTIONSを要求する場合、クライアントは要求ターゲットとして &quot;*&quot;（％x2A）のみを送信する必要があります。たとえば、OPTIONS * HTTP / 1.1 URIが空のパスを持ち、クエリコンポーネントがない絶対形式のrequest-targetを含むOPTIONSリクエストをプロキシが受信した場合、リクエストチェーンの最後のプロキシはリクエストを送信する必要があります。指定されたオリジンサーバーにリクエストを転送するときの「*」のターゲット。たとえば、リクエストOPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP / 1.1は、最終プロキシによってOPTIONS * HTTP / 1.1 Host：www.example.org:8001としてホスト「www.example.org」のポート8001に接続した後に転送されます。</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">ドメイン名とオプションでポート（ &lt;code&gt;':'&lt;/code&gt; 始まる）で構成されるURLの認証コンポーネントは、&lt;em&gt;認証フォーム&lt;/em&gt;と呼ばれます。HTTPトンネルをセットアップするときに、 &lt;code&gt;CONNECT&lt;/code&gt; でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">request-targetのauthority-formは、CONNECTリクエストにのみ使用されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6&lt;/a&gt;）。Authority-form = authority CONNECTリクエストを作成して1つまたは複数のプロキシを介してトンネルを確立する場合、クライアントはターゲットURIの権限コンポーネント（userinfoとその「@」区切り文字を除く）のみをリクエストターゲットとして送信する必要があります。たとえば、CONNECT www.example.com:80 HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">auto-configファイルは拡張子が.pacのファイルに保存されている必要があります。</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">auto-configファイルは、ファイル名拡張子が &lt;code&gt;.pac&lt;/code&gt; のファイルに保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="97bb2f02d88593e20d553e3a3a22148f46c0a1bc" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; environment variable in CGI).</source>
          <target state="translated">autoconfigファイルはCGIスクリプトで出力できます。これは、たとえば、autoconfigファイルがクライアントIPアドレス（CGIの &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 環境変数）に基づいて異なる動作をする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">自動設定ファイルはCGIスクリプトで出力することができます。これは例えば、クライアントの IP アドレス (CGI の環境変数 REMOTE_ADDR)に応じて自動設定ファイルの動作を変える場合に便利です。</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1の基本的なキャッシュメカニズム（サーバー指定の有効期限とバリデーター）は、キャッシュへの暗黙のディレクティブです。場合によっては、サーバーまたはクライアントがHTTPキャッシュに明示的なディレクティブを提供する必要があります。この目的のために、Cache-Controlヘッダーを使用します。 Cache-Controlヘッダーを使用すると、クライアントまたはサーバーは、要求または応答でさまざまなディレクティブを送信できます。これらのディレクティブは通常、デフォルトのキャッシュアルゴリズムをオーバーライドします。原則として、ヘッダー値の間に明らかな矛盾がある場合は、最も制限的な解釈が適用されます（つまり、セマンティックの透明性を維持する可能性が最も高い解釈）。ただし、場合によっては、キャッシュ制御ディレクティブがセマンティックの透過性の近似を弱めるものとして明示的に指定されています（たとえば、「max-stale」または「パブリック」）。キャッシュ制御ディレクティブについては、&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">クライアント-サーバプロトコルの基本的な機能:クライアント-サーバプロトコルで何ができるのか、そしてその目的とする用途について説明します。</target>
        </trans-unit>
        <trans-unit id="0a4f8aeb61f05bae2255b7ec47533f259568b8c3" translate="yes" xml:space="preserve">
          <source>The below status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;. You can find an updated specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC 7231&lt;/a&gt;.</source>
          <target state="translated">以下のステータスコードは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;、RFC2616のセクション10で&lt;/a&gt;定義されています。更新された仕様は&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC7231にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">ブラウザは&lt;strong&gt;常に&lt;/strong&gt;要求を開始するエンティティです。これは決してサーバーではありません（サーバーによって開始されたメッセージをシミュレートするために長年にわたっていくつかのメカニズムが追加されていますが）。</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">ブラウザのバージョンは、常にではありませんが、ユーザーエージェント文字列の&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;トークンの値の部分にあることがよくあります。もちろん、これはInternet Explorer（MSIEトークンの直後にバージョン番号を配置する）や、バージョン/バージョン&lt;em&gt;番号&lt;/em&gt;トークンを追加したバージョン10以降のOperaには&lt;em&gt;当てはまりません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">ブラウザは30分後に以前に応答しなかったプロキシを自動的に再試行します。追加の試行は 1 時間から始まり、試行間の経過時間に常に 30 分を加算します。</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">キャッシュはネットワークの他の部分から切り離されています。</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">キャッシュは使用する前に古いリソースの状態を確認しなければならず、期限切れのものは使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">キャッシュはクライアントのリクエストやサーバのレスポンスについて何も保存してはいけません。</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">キャッシュはクライアントのリクエストやサーバーのレスポンスについて何も保存してはいけません。リクエストはサーバに送信され、完全なレスポンスは毎回ダウンロードされます。</target>
        </trans-unit>
        <trans-unit id="7ca27201de90dba7af54bed9d5fa78a31a2d3e2e" translate="yes" xml:space="preserve">
          <source>The challenge and response flow works like this:</source>
          <target state="translated">チャレンジ&amp;レスポンスの流れはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">文字コードの規格です。</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">チャンク化されたエンコーディングでは、チャンクごとのメタデータ(署名やハッシュなど)、メッセージ中間制御情報、メッセージボディサイズのランダム化などを提供するために、各チャンクにチャンクサイズの直後に、0個以上のチャンク拡張を含めることができます。chunk-ext=*(&quot;;&quot; chunk-ext-name[&quot;=&quot; chunk-ext-val])chunk-ext-name=token chunk-ext-val=token/quoted-string チャンク化されたエンコーディングは各接続に固有のものであり、 高レベルのアプリケーションが拡張を検査する機会を持つ前に、各受信者(仲介者を含む)によって削除されたり、再コード化されたりする可能性が高い。したがって、チャンク拡張の使用は一般的に「ロングポーリング」(クライアントとサーバがチャンク拡張の使用に関して期待を共有することができる)やエンドツーエンドのセキュアな接続内でのパディングなどの特殊なHTTPサービスに限定されます。受信者は認識されていないチャンク拡張を無視しなければならない[MUST]。サーバーは、メッセージの他の部分に長さ制限とタイムアウトを適用するのと同じように、 リクエストで受け取ったチャンク拡張の合計長さを、提供されるサービスに 適した量に制限するべきである。</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">チャンクエンコーディングは、メッセージボディを変更して、それぞれに独自のサイズインジケーターが付いた一連のチャンクとして転送し、その後にエンティティヘッダーフィールドを含むオプションのトレーラーを続けます。これにより、動的に生成されたコンテンツを、受信者が完全なメッセージを受信したことを確認するために必要な情報とともに転送できます。 Chunked-Body = * chunk last-chunk trailer CRLF chunk = chunk-size [chunk-extension] CRLF chunk-data CRLF chunk-size = 1 * HEX last-chunk = 1 *（ &quot;0&quot;）[chunk-extension] CRLF chunk-extension = *（ &quot;;&quot; chunk-ext-name [&quot;=&quot;chunk-ext-val]）chunk-ext-name = token chunk-ext-val = token | quoted-string chunk-data = chunk-size（OCTET）trailer = *（entity-header CRLF）chunk-sizeフィールドは、チャンクのサイズを示す16進数の文字列です。チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（ &lt;a href=&quot;#section-14.40&quot;&gt;セクション14.40&lt;/a&gt;）。応答でチャンク転送コーディングを使用するサーバーは、次のいずれかに該当しない限り、ヘッダーフィールドにトレーラーを使用してはなりません（MUST）：a）要求に、「トレーラー」が転送コーディングで受け入れられることを示すTEヘッダーフィールドが含まれていた&lt;a href=&quot;#section-14.39&quot;&gt;セクション14.39で&lt;/a&gt;説明されている応答の ;または、b）サーバーは応答のオリジンサーバーであり、トレーラーフィールドは完全にオプションのメタデータで構成され、受信者はこのメタデータを受信せずにメッセージを（オリジンサーバーに受け入れられる方法で）使用できます。言い換えると、オリジンサーバーは、トレーラーフィールドがクライアントへのパスに沿って静かに破棄される可能性を受け入れる用意があります。この要件により、メッセージがHTTP / 1.1（またはそれ以降）のプロキシによって受信され、HTTP / 1.0受信者に転送されるときの相互運用性の障害が防止されます。これは、プロトコルに準拠するためにプロキシ上に無限のバッファが必要になる可能性がある状況を回避します。 Chunked-Bodyをデコードするプロセスの例を付録19.4.6に示します。すべてHTTP / 1。1つのアプリケーションは、「チャンクされた」転送コーディングを受信およびデコードできなければならず、また、理解できないチャンク拡張拡張を無視しなければなりません（MUST）。</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">チャンク化された転送コーディングは、ペイロードを一連のチャンクとして転送するために、ペイロード本体をラップし、それぞれが独自のサイズインジケータを持ち、その後にヘッダフィールドを含む OPTIONAL トレーラーが続く。これにより、送信者は接続の持続性を保持し、受信者はいつメッセージ全体を受信したかを知ることができます。chunked-body=*chunk last-chunk trailer-part CRLF chunk=chunk-size[chunk-ext]CRLF chunk-data CRLF chunk-size=1*HEXDIG last-chunk=1*(&quot;0&quot;)[chunk-ext]CRLF chunk-data=1*OCTET;a sequence of chunk-size octets チャンクサイズオクテットのシーケンス chunk-sizeフィールドは、オクテット単位でのチャンクデータのサイズを示す16進数の文字列である。チャンク化された転送コーディングは、チャンクサイズが0のチャンクが受信されたときに完了し、トレーラーが続く可能性があり、最後に空行で終了する。受信者はチャンク化された転送コーディングを解析してデコードできなければならない (MUST)。</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">クライアントのIPアドレス</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">クライアントはリクエストを続行する必要があります。この暫定応答は、要求の最初の部分が受信され、サーバーによってまだ拒否されていないことをクライアントに通知するために使用されます。クライアントは、残りのリクエストを送信して続行する必要があります。リクエストがすでに完了している場合は、このレスポンスを無視してください。リクエストが完了した後、サーバーは最終応答を送信する必要があります。このステータスコードの使用と処理の詳細については、&lt;a href=&quot;#section-8.2.3&quot;&gt;セクション8.2.3&lt;/a&gt;を参照してください 。</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">クライアントは、サーバーが待つ準備ができた時間内にリクエストを生成しなかった。クライアントは、後のいつでも修正せずにリクエストを繰り返してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">クライアントはコンテンツへのアクセス権を持っていない、つまり権限がないので、サーバは適切な応答を与えることを拒否しています。401とは異なり、クライアントの身元はサーバに知られています。</target>
        </trans-unit>
        <trans-unit id="20c408742f6f7b483f2e5d78c14bc1e7549de56d" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">クライアントはコンテンツへのアクセス権を持っていません。つまり、権限がないので、サーバは要求されたリソースの提供を拒否しています。401とは異なり、クライアントの身元はサーバに知られています。</target>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">クライアントはTCP接続(トランスポートレイヤーがTCPでない場合は適切な接続)を確立する。</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">クライアントは、サーバが満たさない前提条件をヘッダで指定しています。</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">クライアントは正規ドメインにリクエストを発行します： &lt;code&gt;http://example.org/whatddup&lt;/code&gt; : //example.org/whatddup</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">クライアントはリクエストを送信し、回答を待ちます。</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">クライアントは、この要求をそのまま繰り返してはいけません。</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">リクエストを開始したクライアントと、それに続くプロキシのチェーンのプロキシ。</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">以下に定義されているコードは、メッセージのペイロードを圧縮するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="971adc7eb81ae93f06509fafd469f5eea13bda5b" translate="yes" xml:space="preserve">
          <source>The comma-separated list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">許可される&lt;a href=&quot;../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;のコンマ区切りのリスト。</target>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">一般的な使用例は、ユーザーに表示されるページの現在のコンテンツを変更せずに、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;リクエストの結果として &lt;code&gt;204&lt;/code&gt; を返し、リソースを更新することです。リソースが作成されると、代わりに&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; が返されます。ページを新しく更新されたページに変更する必要がある場合は、代わりに&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">このステータスコードの一般的な使用例は、&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストの結果です。</target>
        </trans-unit>
        <trans-unit id="5dee61655e811dbf764699bfb5c6ab2c8de25fd2" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. If a listed &lt;code&gt;ETag&lt;/code&gt; has the &lt;code&gt;W/&lt;/code&gt; prefix indicating a weak entity tag, it will never match under this comparison algorithm.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;強力な比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルはバイト間でのみ同一と見なされます。リストされた &lt;code&gt;ETag&lt;/code&gt; に弱いエンティティタグを示す &lt;code&gt;W/&lt;/code&gt; プレフィックスが付いている場合、この比較アルゴリズムでは一致しません。</target>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;強力な比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルはバイト間で同一と見なされます。 &lt;code&gt;W/&lt;/code&gt; プレフィックスが &lt;code&gt;ETag&lt;/code&gt; の前で使用されると、これは弱くなります。</target>
        </trans-unit>
        <trans-unit id="72daedd3e8f61f2659bcac2190d51fd4c98967f8" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical if the content is equivalent &amp;mdash; they don't have to be identical byte for byte. For example, two pages that differ by the date of generation in the footer would still be considered as identical.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;弱い比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、コンテンツが同等である場合、2つのファイルは同一であると見なされます。つまり、バイトごとに同一である必要はありません。たとえば、フッターの生成日が異なる2つのページは、引き続き同一と見なされます。</target>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;弱い比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルがバイト間で同一である場合だけでなく、内容が同等である場合でも、2つのファイルは同一であると見なされます。たとえば、フッターの生成日のみが異なる2つのページは同一と見なされます。</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">このページの互換性テーブルは、構造化データから生成されます。データに貢献したい場合は、&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https：//github.com/mdn/browser-compat-data&lt;/a&gt;を確認し、プルリクエストを送信してください。</target>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">HPKPヘッダの配信に必要な具体的な手順は、使用するWebサーバによって異なります。</target>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">このコンテンツやコンセプトは、Atom コミュニティと Atompub Working Group の成果です。</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">「app：accept」要素の値の内容は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されているメディア範囲です。メディア範囲は、コレクションにPOSTできる表現のタイプを指定します。 app：accept要素は、HTTP Acceptリクエストヘッダー[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]に似ています。メディアタイプパラメータはapp：accept内で許可されますが、app：acceptには優先順位の概念はありません。&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;[RFC2616]のセクション14.1で&lt;/a&gt;指定されている「accept-params」または「q」引数は重要ではありません。空白（[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]）app：accept要素のメディア範囲は重要ではなく、無視する必要があります。 「application / atom + xml; type = entry」の値は、どのアプリにも表示される場合があります。メディア範囲のリストを受け入れ、AtomエントリドキュメントをコレクションにPOSTできることを示します。 app：accept要素が存在しない場合、クライアントはこれを、コンテンツが &quot;application / atom + xml; type = entry&quot;のapp：accept要素と同等であると見なすべきです。 1つのapp：accept要素が存在し、空の場合、クライアントは、コレクションが新しいエントリの作成をサポートしていないと想定する必要があります（SHOULD）。 appAccept = element app：accept {appCommonAttributes、（text？）}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">コンテンツセキュリティポリシー</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">上記で作成されたCookieは&lt;em&gt;セッションCookie&lt;/em&gt;です &lt;code&gt;Expires&lt;/code&gt; または &lt;code&gt;Max-Age&lt;/code&gt; ディレクティブを指定していないため、クライアントがシャットダウンすると削除されます。ただし、ウェブブラウザは&lt;strong&gt;セッションの復元を&lt;/strong&gt;使用する場合があります。これにより、ブラウザが閉じられなかったかのように、ほとんどのセッションCookieが永続的になります。</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">ロックの作成者には、ロックを使用してリソースを変更するための特別な特権があります。ロックされたリソースが変更されると、サーバーは、認証されたプリンシパルがロックの作成者と一致することを確認する必要があります（有効なロックトークン送信の確認に加えて）。サーバーは、ロックの作成者以外の特権ユーザーがロックを破棄することを許可する場合があります（たとえば、リソースの所有者や管理者）。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;の「ロック解除」権限]その許可を提供するために定義されました。サーバーがすべてのユーザーまたは匿名ユーザーからのLOCK要求を受け入れる必要はありません。ロックしても、ロックされたリソースを変更するための完全な権限は付与されないことに注意してください。書き込みアクセスおよびその他の特権は、ロックトークン値の不明瞭さに基づいてではなく、通常の特権または認証メカニズムを介して適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">クレデンシャルはこのように構成されています。</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">現在のポリシー制御された機能のセットは、2つの大まかなカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">データURLは、最初のヘッダ行の後にエンコードされたデータを使用します。</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">データURLのデータ部分は不透明であるため、データURLでクエリ文字列（ページ固有のパラメーター、構文 &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; ）を使用しようとすると、URLのデータにクエリ文字列が含まれますを表します。</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">送信されるデータはすでに圧縮されており、2回目の圧縮では送信されるデータは小さくなりません。画像フォーマットによってはこのような場合があります。</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">応答が古くなったとみなされる日時。</target>
        </trans-unit>
        <trans-unit id="0911607a468bc8e23c0901e6b8899136c11add6c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt; value is &lt;code&gt;'src'&lt;/code&gt;, so this is equivalent to:</source>
          <target state="translated">デフォルトの &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt;値は &lt;code&gt;'src'&lt;/code&gt; であるため、これは次と同等です。</target>
        </trans-unit>
        <trans-unit id="46f69faebfa441f8068a5c2a1d971d7bb75686df" translate="yes" xml:space="preserve">
          <source>The default allowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルトの許可リストは &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c0b5d6196048d6e0193482609dd5869326eae443" translate="yes" xml:space="preserve">
          <source>The default value in &lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chrome&lt;/a&gt; is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は&lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chromeが&lt;/a&gt;ある &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">コレクション状態の定義が修正されたため、Request-URIに応じて変更されることはなくなりました（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2を&lt;/a&gt;参照）。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;[RFC2518]のセクション4.6で&lt;/a&gt;導入されたDAV：sourceプロパティは、実装経験がないため削除されました。 DAVヘッダーは、コンプライアンスクラストークンに加えて、URIを介した非IETF拡張を許可するようになりました。この仕様は、ここで定義されているコンプライアンスクラスに関連するセマンティクスを定義していません（&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1を&lt;/a&gt;参照 ）。で&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;、奥行きヘッダの定義（&lt;a href=&quot;#section-9.2&quot;&gt;9.2節&lt;/a&gt;）では、デフォルトで、リクエストヘッダーをスコープ内の各リソースに適用する必要がありました。実装経験に基づいて、デフォルトが逆になりました（&lt;a href=&quot;#section-10.2&quot;&gt;セクション10.2を&lt;/a&gt;参照）。 HTTPステータスコード102（&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518]、セクション10.1&lt;/a&gt;）およびStatus-URI応答ヘッダー（&lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt;）の定義は、実装が不足しているため削除されました。 Timeoutリクエストヘッダーで使用されるTimeType形式と「timeout」XML要素は拡張可能でした。現在、この仕様で定義されている2つの形式のみが許可されています（&lt;a href=&quot;#section-10.7&quot;&gt;セクション10.7を&lt;/a&gt;参照））。著者のアドレスLisa Dusseault（editor）CommerceNet 2064 Edgewood Dr. Palo Alto、CA 94303 US EMail：ldusseault@commerce.net Copyright Copyright（C）The IETF Trust（2007）。このドキュメントは、&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78に&lt;/a&gt;含まれる権利、ライセンス、制限の対象となります。、およびそこに記載されている場合を除き、著者はすべての権利を保持します。このドキュメントとここに含まれる情報は「現状のまま」で提供され、寄稿者、彼/彼女の代表者、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません。知的財産IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用される範囲について、いかなる立場も取りません。利用できない場合があります。また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、次の場所にあります。&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。 IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可を得ようとした試みの結果を入手できます。&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;のIETFオンラインIPRリポジトリから 。 IETFは、この規格の実装に必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけています。 IEETのietf-ipr@ietf.orgに情報を送信してください。 RFC Editor機能の謝辞は、現在Internet Societyによって提供されています。 Dusseault Standards Track [ページ127]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">バリデータの弱点の定義が拡張され、明確になりました。 （&lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1&lt;/a&gt;）弱いエンティティタグは、範囲リクエストを除くすべてのリクエストで許可されるようになりました。 （セクション&lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;および&lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;）ETagヘッダーフィールドABNFは、quoted-stringを使用しないように変更され、エスケープの問題を回避しています。 （&lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt;）ETagは、選択された表現のエンティティタグを提供するために定義され、それによってさまざまな状況（PUT応答など）に適用されるものを明確にします。 （&lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt;）条件付き要求の評価の優先順位が定義されました。 （&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">delta-seconds ルールは時間を秒単位で表す非負の整数を指定します。 delta-seconds=1*DIGIT delta-seconds 値を解析してバイナリ形式に変換する受信者は、少なくとも 31 ビットの非負の整数範囲の算術型を使用しなければなりません。キャッシュが表現可能な最大の整数よりも大きいデルタ秒値を受け取った場合、またはその後の計算でオーバーフローした場合、キャッシュはその値を 2147483648 (2^31)または都合よく表現可能な最大の正の整数のいずれかと考えなければなりません(MUST)。注意:2147483648 という値は、歴史的な理由からここでは無限大(68 年以上)を事実上表しており、バイナリ形式で保存する必要はありません。ここで重要なのは、オーバーフローが検出され、後の計算で負の値として扱われないことです。</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは、コンテンツセキュリティポリシーに違反する試みを報告するようにユーザーエージェントに指示します。これらの違反レポートは、HTTP POSTリクエストを介して指定されたURIに送信されたJSONドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用してロードされた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求はユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは、コンテンツセキュリティポリシーに違反する試みを報告するようにユーザーエージェントに指示します。これらの違反レポートは、HTTP POSTリクエストを介して指定されたURIに送信されたJSONドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用してロードされた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求はユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="06d89b04e62b26b8ec32aee4540211a4cdd447d1" translate="yes" xml:space="preserve">
          <source>The design of the cookie mechanism is such that a server is unable to confirm that a cookie was set on a secure origin or even to tell &lt;em&gt;where&lt;/em&gt; a cookie was originally set.</source>
          <target state="translated">Cookieメカニズムの設計では、サーバーはCookieが安全なオリジンに設定されていることを確認できず、Cookieが最初に設定された&lt;em&gt;場所&lt;/em&gt;を知ることさえできません。</target>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">最適な表現の決定は、2つのメカニズムのうちの1つによって行われます。</target>
        </trans-unit>
        <trans-unit id="efd86e58a3f30de9823ac04636ac8858e24077e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;POST&lt;/code&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">差&lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;POST&lt;/code&gt; ことである &lt;code&gt;PUT&lt;/code&gt; の冪等である：一旦それを呼び出すか、数回連続して同じ効果（何ないことを持っている&lt;em&gt;側&lt;/em&gt;の連続した同一の効果）、 &lt;code&gt;POST&lt;/code&gt; は、順序を複数回通過するような付加的な効果を有していてもよいし。</target>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">差 &lt;code&gt;PUT&lt;/code&gt; および&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;ことである &lt;code&gt;PUT&lt;/code&gt; の冪等である：一旦それを呼び出すか、数回連続して同じ効果（何ないことを持っている&lt;em&gt;側&lt;/em&gt;の連続した同一の効果）、 &lt;code&gt;POST&lt;/code&gt; は、順序を複数回通過するような付加的な効果を有していてもよいし。</target>
        </trans-unit>
        <trans-unit id="6709d83055ac598235616e01accc6af867f222e8" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), whereas successive identical &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests may have additional effects, akin to placing an order several times.</source>
          <target state="translated">差 &lt;code&gt;PUT&lt;/code&gt; および&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; は&lt;/a&gt;そのさ &lt;code&gt;PUT&lt;/code&gt; の冪等である：一度の呼び出し又は複数回連続（noです同じ効果持つ&lt;em&gt;側&lt;/em&gt;連続同一のに対し、効果）&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストが順序を数回配置に類似の追加の効果を有することができます。</target>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">異なる動作は、使用されるリクエストのメソッドと、前提条件に使用されるヘッダーの セットによって定義される。</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTPで実行できるさまざまな操作：&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt;などのあまり一般的でないリクエスト。</target>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">このディレクティブはそれ自体には何の効果もなく、他のディレクティブとの組み合わせでのみ意味を持つようになります。</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">その施行が違反の原因となった指令。</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">違反の原因となった指令。</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">ディレクティブは大文字小文字を区別せず、オプションの引数を持ちます。複数のディレクティブはカンマで区切られています。</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーのディレクティブは、Content &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; も適用できます。</target>
        </trans-unit>
        <trans-unit id="279baf1d439803980239f8e98d3badd1808c8388" translate="yes" xml:space="preserve">
          <source>The discrete types currently registered with the IANA are:</source>
          <target state="translated">現在IANAに登録されている離散型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">ドキュメント &lt;code&gt;https://example.com/page.html&lt;/code&gt; はリファラーhttps://example.com/を送信し &lt;code&gt;https://example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation header&lt;/code&gt; 持つドキュメントが、 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; または &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 機能が設定されていない&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; または他の同様のメソッドで別のウィンドウを開いています。これは、上記と同じ理由、つまり、通信できるため、プロセスの切り替えを許可できないためです。</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを持つドキュメントは、 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; または &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 機能が設定されていない&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; または他の同様のメソッドによって開かれたウィンドウに読み込まれました。これらのウィンドウはオープナーと同じプロセス内にある必要があります。つまり、通信できるため、プロセスを切り替えることはできません。</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを含むドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;に読み込まれました。現在、Firefoxはiframeを新しいプロセスに移動できないため、ドキュメントは現在のプロセスに読み込まれる必要があります。</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">転送されたサーバのドメイン名です。</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">サーバーのドメイン名(仮想ホスティングの場合)またはIP。</target>
        </trans-unit>
        <trans-unit id="950978a8462def38d2b11b8a3fe9cb368d430082" translate="yes" xml:space="preserve">
          <source>The ePrivacy Directive in the EU</source>
          <target state="translated">EUにおけるeプライバシー指令</target>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">オリジンサーバでリソースに対して実行される特定のメソッドの影響により、1 つ以上の既存のキャッシュエントリが透過的でない無効なものになるかもしれません。つまり、それらは「新鮮」であり続けるかもしれませんが、オリジンサーバがそのリソースに対する新しいリクエストに対して返すものを正確に反映していません。HTTP プロトコルでは、そのようなキャッシュエントリがすべて無効とマークされていることを保証する方法はありません。例えば、オリジンサーバでの変更の原因となったリクエストはキャッシュエントリが保存されているプロキシを 通過していないかもしれません。しかし、いくつかの規則は、誤った動作の可能性を減らすのに役立つ。この節では、「エンティティを無効にする」という表現は、キャッシュがそのエンティティの全てのインスタンスをそのストレージから削除するか、あるいは、後続のリクエストに応答して返される前に、これらを「無効」としてマークし、強制的な再検証を必要とすることを意味します。いくつかの HTTP メソッドはキャッシュにエンティティを無効にさせなければなりません(MUST)。これは、Request-URI によって参照されるエンティティか、Location ヘッダや Content-Location ヘッダ (存在する場合)によって参照されるエンティティのいずれかです。これらのメソッドは以下の通りです。-PUT-DELETE-POST サービス拒否攻撃を防ぐために、Location または Content-Location ヘッダーの URI に基づく無効化は、ホスト部分が Request-URI と同じである場合にのみ実行されなければならない[MUST]。理解できないメソッドのリクエストを通過するキャッシュは、Request-URI で参照されたエンティティを無効にすべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="d5ae0833fdb7faa042296f4443d9009502223ddd" translate="yes" xml:space="preserve">
          <source>The encoding algorithm, usually a &lt;a href=&quot;compression&quot;&gt;compression algorithm&lt;/a&gt;, that can be used on the resource sent back.</source>
          <target state="translated">返送されたリソースで使用できるエンコードアルゴリズム（通常は&lt;a href=&quot;compression&quot;&gt;圧縮アルゴリズム&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">HTTP要求または応答で送信されたエンティティ本体（存在する場合）は、エンティティヘッダーフィールドで定義された形式とエンコーディングです。entity-body = * OCTET &lt;a href=&quot;#section-4.3&quot;&gt;4.3節で&lt;/a&gt;説明するように、エンティティボディは、メッセージボディが存在する場合にのみメッセージに存在します。entity-bodyは、メッセージの安全で適切な転送を保証するために適用された可能性のあるTransfer-Encodingをデコードすることにより、message-bodyから取得されます。</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">メッセージのエンティティ長は、転送コーディングが適用される前のメッセージ本文の長さです。&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;では、メッセージ本文の転送長を決定する方法を定義しています。</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同等の&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 応答には、ヘッダー&lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; が含まれ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="69c5ab4621c4edd07f710f991794d1e78a2f9d36" translate="yes" xml:space="preserve">
          <source>The exact directive for setting headers depends on your web server. In Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">ヘッダーを設定するための正確なディレクティブは、Webサーバーによって異なります。 Apacheで、サーバーの構成に次のような行を追加します（適切な &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 、または &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; セクション内）。構成は、典型的に見出される &lt;code&gt;.conf&lt;/code&gt; ファイル（ &lt;code&gt;httpd.conf&lt;/code&gt; ファイルと &lt;code&gt;apache.conf&lt;/code&gt; これらのための一般的な名称である）、又はで &lt;code&gt;.htaccess&lt;/code&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">インターネット要求によって識別される正確なリソースは、Request-URIとHostヘッダーフィールドの両方を調べることによって決定されます。リクエストされたホストによるリソースの違いを許可しないオリジンサーバーは、HTTP / 1.1リクエストで識別されたリソースを決定するときに、Hostヘッダーフィールドの値を無視してもよい（MAY）。（ただし、&lt;a href=&quot;#section-19.6.1.1&quot;&gt;セクション19.6.1.1を&lt;/a&gt;参照） HTTP / 1.1でのホストサポートに関する他の要件について。）要求されたホスト（仮想ホストまたはバニティホスト名と呼ばれることもある）に基づいてリソースを区別するオリジンサーバーは、HTTP /で要求されたリソースを決定するために次のルールを使用する必要があります。 1.1リクエスト：1. Request-URIがabsoluteURIの場合、ホストはRequest-URIの一部です。リクエスト内のホストヘッダーフィールド値はすべて無視する必要があります。 2. Request-URIが絶対URIではなく、リクエストにHostヘッダーフィールドが含まれている場合、ホストはHostヘッダーフィールドの値によって決定されます。 3.ルール1または2で決定されたホストがサーバー上の有効なホストでない場合、応答は400（Bad Request）エラーメッセージでなければなりません。 HostヘッダーフィールドのないHTTP / 1.0リクエストの受信者は、ヒューリスティック（たとえば、リクエストされている正確なリソースを判別するために、特定のホストに固有のURIパスの検査）。</target>
        </trans-unit>
        <trans-unit id="b7709fb173b9a7682e88163b1524346d08926812" translate="yes" xml:space="preserve">
          <source>The example above creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request. Also, a non-standard HTTP &lt;code&gt;X-PINGOTHER&lt;/code&gt; request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a &lt;code&gt;Content-Type&lt;/code&gt; of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="translated">上記の例では、 &lt;code&gt;POST&lt;/code&gt; リクエストで送信するXML本文を作成しています。また、非標準の &lt;code&gt;X-PINGOTHER&lt;/code&gt; リクエストヘッダーが設定されています。このようなヘッダーはHTTP / 1.1の一部ではありませんが、一般的にWebアプリケーションに役立ちます。リクエストは &lt;code&gt;application/xml&lt;/code&gt; の &lt;code&gt;Content-Type&lt;/code&gt; を使用し、カスタムヘッダーが設定されているため、このリクエストはプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">このドキュメントの最後にある例は完全なものです。ファイルに保存して使用するための追加の構文は必要ありません。(もちろん、サイトのドメイン名やサブネットを反映させるために、JavaScriptsを編集する必要があります)。</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">この例外は、ワーカースクリプトのオリジンがグローバルに一意な識別子である場合です (たとえば、URL にデータやブロブのスキームがある場合など)。この場合、ワーカーはそれを作成したドキュメントやワーカーのコンテンツセキュリティポリシーを継承します。</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">Expect要求ヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20を&lt;/a&gt;参照）で指定された期待値がこのサーバーで満たされなかったか、サーバーがプロキシの場合、次のホップのサーバーで要求が満たされなかったという明確な証拠がサーバーにある。</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">実行される割り当ての予想サイズをメガバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ed4c70c74d035f0ea716b0ccb4bd9c7c87a82ce4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;headers/accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">実験的な&lt;a href=&quot;headers/accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;は、サーバーが適切な応答を選択するために使用できる構成データをリストします。有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">実験的な&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;は、サーバーが適切な応答を選択するために使用できる構成データをリストします。有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">有効期限は以下のように計算されます。</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">エンティティの有効期限は、元のサーバーでExpiresヘッダーを使用して指定できます（&lt;a href=&quot;#section-14.21&quot;&gt;セクション14.21を&lt;/a&gt;参照）。）。または、応答でmax-ageディレクティブを使用して指定してもよい（MAY）。キャッシュされた応答にmax-age cache-controlディレクティブが存在する場合、現在の経過時間が、そのリソースに対する新しい要求時に指定された経過時間（秒単位）より大きい場合、応答は古くなります。応答のmax-ageディレクティブは、他のより制限的なキャッシュディレクティブも存在しない限り、応答がキャッシュ可能（つまり「パブリック」）であることを意味します。応答にExpiresヘッダーとmax-ageディレクティブの両方が含まれている場合、Expiresヘッダーの方が制限が厳しい場合でも、max-ageディレクティブはExpiresヘッダーをオーバーライドします。このルールにより、元のサーバーは、特定の応答に対して、HTTP / 1.0キャッシュよりもHTTP / 1.1（またはそれ以降）キャッシュに長い有効期限を提供できます。これは、特定のHTTP / 1.0キャッシュが、おそらく非同期化されたクロックが原因で、経過時間または有効期限を正しく計算しない場合に役立ちます。多くのHTTP / 1.0キャッシュ実装は、応答の日付値以下のExpires値を、Cache-Control応答ディレクティブ「no-cache」と同等のものとして扱います。 HTTP / 1.1キャッシュがそのような応答を受信し、その応答にCache-Controlヘッダーフィールドが含まれていない場合、HTTP / 1.0サーバーとの互換性を維持するために、その応答はキャッシュ不可であると見なすべきです。注：オリジンサーバーは、「プライベート」ディレクティブなどの比較的新しいHTTPキャッシュ制御機能を、その機能を理解しない古いキャッシュを含むネットワーク上で使用したい場合があります。オリジンサーバーは、新しい機能を、日付の値以下のExpiresフィールドと組み合わせる必要があります。これにより、古いキャッシュが応答を不適切にキャッシュするのを防ぎます。 s-maxage応答にs-maxageディレクティブが含まれている場合、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（次に、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（次に、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（ &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt;）、つまり、最初にオリジンサーバーで再検証することなく、共有キャッシュが古くなって次の要求に応答するようになった後は、そのエントリを使用してはなりません。 s-maxageディレクティブは、プライベートキャッシュによって常に無視されます。この仕様に準拠していない古いキャッシュのほとんどは、キャッシュ制御ディレクティブを実装していません。 HTTP / 1.1準拠のキャッシュによるキャッシュを制限するが防止はしないキャッシュ制御ディレクティブの使用を希望するオリジンサーバーは、max-ageディレクティブがExpiresヘッダーをオーバーライドするという要件、およびHTTPより前の/1.1準拠のキャッシュは、max-ageディレクティブを監視しません。その他のディレクティブを使用すると、ユーザーエージェントは基本的な有効期限メカニズムを変更できます。これらのディレクティブはリクエストで指定してもよいです：max-ageクライアントが、指定された時間（秒単位）以下の応答を受け入れる用意があることを示します。 max-staleディレクティブも含まれていない限り、クライアントは古い応答を受け入れる用意がありません。 min-freshクライアントが、フレッシュネスライフタイムが現在の経過時間と指定された時間（秒単位）を足したものである応答を受け入れる用意があることを示します。つまり、クライアントは、少なくとも指定された秒数の間、まだ新鮮な応答を望んでいます。 max-staleクライアントが、有効期限を超えた応答を受け入れる用意があることを示します。 max-staleに値が割り当てられている場合、その後、クライアントは、指定された秒数を超えて有効期限を超えた応答を受け入れます。 max-staleに値が割り当てられていない場合、クライアントは任意の年齢の古い応答を受け入れてもかまいません。リクエストのmax-staleディレクティブが原因で、またはキャッシュが応答の有効期限を上書きするように構成されているために、キャッシュが古い応答を返す場合、キャッシュは、警告110を使用して、古いヘッダーに警告ヘッダーを添付する必要があります。 （応答が古くなっています）。キャッシュは、検証なしで古い応答を返すように構成できますが、これは、キャッシュ検証に関する「MUST」レベルの要件（「must-revalidate」キャッシュ制御ディレクティブなど）と競合しない場合のみです。新しいリクエストとキャッシュされたエントリの両方に「max-age」ディレクティブが含まれている場合、そのリクエストのキャッシュされたエントリの鮮度を判断するために、2つの値の小さい方が使用されます。</target>
        </trans-unit>
        <trans-unit id="a65d812882b0aba90b93b31c9c8f523446f0f382" translate="yes" xml:space="preserve">
          <source>The features include (see &lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;Features list&lt;/a&gt;):</source>
          <target state="translated">機能は次のとおりです（&lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;機能リストを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">特徴としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">このファイルは &lt;code&gt;FindProxyForURL&lt;/code&gt; という関数で構成されています。以下の例は、内部DNSサーバーが内部ホスト名のみを解決できるように設定されている環境で機能し、解決できないホストに対してのみプロキシを使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">firefox.js ファイルはプリファレンス名と値を pref()関数に渡します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">最後のブロックは、オプションのデータを含むデータブロックです。</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">最後のブロックはオプションのデータブロックで、主にPOSTメソッドで使用される更なるデータを含む可能性があります。</target>
        </trans-unit>
        <trans-unit id="45bd5c32307d77b9998e20d89babbacc1a08c8ee" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;OPTIONS&lt;/code&gt;, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">リクエストの最後の部分はその本文です。すべてのリクエストに1つあるわけではありません &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;OPTIONS&lt;/code&gt; などのリソースをフェッチするリクエストには、通常は必要ありません。一部のリクエストは、更新するためにサーバーにデータを送信します &lt;code&gt;POST&lt;/code&gt; リクエスト（HTMLフォームデータを含む）の場合と同様です。</target>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">リクエストの最後の部分はその本文です。すべてのリクエストに1つあるわけではありません &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; 、DELETE、またはOPTIONS などのリソースをフェッチするリクエストは通常、必要ありません。一部のリクエストは、データを更新するためにサーバーにデータを送信します &lt;code&gt;POST&lt;/code&gt; リクエスト（HTMLフォームデータを含む）の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">リクエストの最終受信者は、以下に説明するいくつかのフィールドを除いて、受信したメッセージを、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;message/http&lt;/code&gt; の 200（OK）応答のメッセージ本文としてクライアントに反映する必要があります。最終受信者は、起点サーバーか、要求で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;値0 を受信する最初のサーバーです。</target>
        </trans-unit>
        <trans-unit id="fa5fe1af847469a3d3023206916eb30deabd5583" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">リクエストの最終受信者は、以下で説明する一部のフィールドを除いて、受信したメッセージを、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;message/http&lt;/code&gt; の&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答のメッセージ本文としてクライアントに反映する必要があります。最終的な受信者は、オリジンサーバーか、リクエストで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;値0を受信した最初のサーバーのいずれかです。</target>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">違反の原因となったインラインスクリプト、イベントハンドラ、またはスタイルの最初の40文字。</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">最初の行にはリクエストメソッドとそのパラメータが続きます。</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">レスポンスメッセージの最初の行はステータス行で、プロトコルバージョン、数値のステータスコード、およびそれに関連するテキストフレーズで構成され、各要素はSP文字で区切られています。最後の CRLF シーケンス以外では、CR や LF は使用できません。Status-Line=HTTP-Version SP Status-Code SP Reason-Phrase CRLF</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">応答メッセージの最初の行は、プロトコルバージョン、スペース（SP）、ステータスコード、別のスペース、ステータスコードを説明する空のテキストフレーズで構成され、CRLFで終わるステータス行です。 status-line = HTTP-version SP status-code SP reason-phrase CRLF status-code要素は、サーバーがクライアントの対応する要求を理解して満足する試みの結果を説明する3桁の整数コードです。残りの応答メッセージは、そのステータスコードに定義されているセマンティクスに照らして解釈されます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]のセクション6を&lt;/a&gt;参照してくださいステータスコードのクラス（最初の桁で示される）、この仕様で定義されているステータスコード、新しいステータスコードの定義に関する考慮事項、IANAレジストリなど、ステータスコードのセマンティクスについては、 status-code = 3DIGIT reason-phrase要素は、数値のステータスコードに関連付けられたテキストによる説明を提供することのみを目的として存在します。これは主に、インタラクティブテキストクライアントでより頻繁に使用されていた以前のインターネットアプリケーションプロトコルを順守しないためです。クライアントは理由フレーズの内容を無視する必要があります。理由フレーズ= *（HTAB / SP / VCHAR / obs-text）</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">最初の行である&lt;em&gt;status lineは&lt;/em&gt;、使用されているHTTPバージョンの確認応答と、それに続くステータス要求（および人間が読めるテキストでの簡単な意味）で構成されています。</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">HTTPコンテキストの最初のパラメーターは常に &lt;code&gt;form-data&lt;/code&gt; です。追加のパラメータは大文字と小文字を区別せず、 &lt;code&gt;'='&lt;/code&gt; 記号の後に引用符付き文字列構文を使用する引数があります。複数のパラメーターはセミコロン（ &lt;code&gt;';'&lt;/code&gt; ）で区切ります。</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">HTTPコンテキストの最初のパラメーターは、 &lt;code&gt;inline&lt;/code&gt; （デフォルト値、Webページ内に表示できること、またはWebページとして表示できることを示す）または &lt;code&gt;attachment&lt;/code&gt; （ダウンロードする必要があることを示す）です。ほとんどのブラウザーは、「名前を付けて保存」ダイアログを表示し、あらかじめ入力されています。存在する場合は、 &lt;code&gt;filename&lt;/code&gt; パラメータの値を含む）。</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">サイトが初めてHTTPSを使用してアクセスされ、 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; ヘッダーが返されると、ブラウザはこの情報を記録するため、HTTPを使用してサイトをロードしようとすると、代わりにHTTPSが自動的に使用されます。</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">リソースの最初のアップロードは、前のリソースのエッジケースです。リソースの更新と同様に、2つのクライアントが同じ時間に実行しようとすると、競合状態の影響を受けます。これを防ぐには、条件付きリクエストを使用できます。e-tagを表す特別な値 &lt;code&gt;'*'&lt;/code&gt; を使用して&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;を追加します。リクエストは、リソースが以前に存在しなかった場合にのみ成功します。</target>
        </trans-unit>
        <trans-unit id="cc100946d8979f9ce8df35a1f6c26e450e867343" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、ロードされません。</target>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="d9b73c421a277665ab08a8298b8930b892f83d26" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">次の &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">次のJavaコードはCORS応答ヘッダーを設定します。コードが &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 値を&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;リクエストヘッダーと同じ値に設定する方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">以下は、&lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standardに&lt;/a&gt;基づくすべての有効なJavaScript MIMEタイプです。</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">次のコマンドは、ウェブサイトのBase64エンコードされた情報を抽出します。</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">以下のコマンドは、鍵ファイル、証明書署名要求、証明書から Base64 エンコードされた情報を抽出するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">以下の接続がブロックされ、ロードされません。</target>
        </trans-unit>
        <trans-unit id="ce04653c2a877eee1709cad576d94e84ea8ac4bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;example.com&lt;/code&gt;:</source>
          <target state="translated">次のCookieは、 &lt;code&gt;example.com&lt;/code&gt; でホストされているサーバーによって設定された場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="f830b6e4479681c906a8958ca927a242872bc6bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;originalcompany.com&lt;/code&gt;:</source>
          <target state="translated">次のCookieは、 &lt;code&gt;originalcompany.com&lt;/code&gt; でホストされているサーバーによって設定された場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、HTAB（水平タブ）、LF（ラインフィード）、OCTET（データの8ビットシーケンス）、SP（スペース）、およびVCHAR（目に見えるUS-ASCII文字）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; RWS = &amp;lt;RWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; URI-reference = &amp;lt;URI-reference、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション2.7&amp;gt;絶対URI = &amp;lt;絶対URI、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション2.7 &amp;gt;コメント= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.6 &amp;gt;フィールド名= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2 &amp;gt;部分- URI = &amp;lt;partial-URI、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7を&lt;/a&gt;参照&amp;gt; quoted-string = &amp;lt;quoted-string、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt; token = &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。トークンから派生したすべてのルールは、範囲単位や許容範囲のように、大文字と小文字を区別せずに比較されることに注意してください。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;以下のルールは他の部分で定義されています：HTTP -date = &amp;lt;HTTP-date、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、セクション7.1.1.1&lt;/a&gt; &amp;gt;エンティティタグ= &amp;lt;エンティティタグ、&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]を&lt;/a&gt;参照、セクション2.3 &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています：BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; quoted-string = &amp;lt;quoted-string、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6&lt;/a&gt; &amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; field-name = &amp;lt;field-name、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2 &amp;gt; quoted-string = &amp;lt;quoted-string 、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt; port = &amp;lt;ポート、見る&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt; pseudonym = &amp;lt;pseudonym、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]、セクション5.7.1&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt;以下のルールは他の部分で定義されています：HTTP-日付= &amp;lt;HTTP-date、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、セクション7.1.1.1を参照&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; obs-text = &amp;lt;obs-text、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;以下のルールはその他の部分：HTTP-date = &amp;lt;HTTP-date、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、Section 7.1.1.1&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">次の例は、同じコピー操作が実行されていることを示していますが、Overwriteヘッダーが「F」に設定されています。宛先URLが既にリソースにマップされているため、412（前提条件の失敗）の応答が返されます。&amp;gt;&amp;gt;リクエストCOPY /~fielding/index.html HTTP / 1.1 Host：www.example.com Destination：http://www.example.com/users/f/fielding/index.html Overwrite：F &amp;gt;&amp;gt; Response HTTP / 1.1 412前提条件が失敗しました</target>
        </trans-unit>
        <trans-unit id="8d3395be0d0b51b8ffa7605b7ec7844c4e4a39c7" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to &lt;code&gt;foo.example&lt;/code&gt;.</source>
          <target state="translated">次の例では、24時間の証明書の透明性の実施を指定し、違反を &lt;code&gt;foo.example&lt;/code&gt; に報告します。</target>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">次の例では、証明書の透明性を24時間実施し、違反をfoo.exampleに報告することを指定しています。</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">以下のフォントリソースの読み込みがブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">以下のヘッダーは、WebSocketのアップグレードプロセスに関係しています。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーと&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを除いて、残りは一般にオプションであるか、ブラウザとサーバーが相互に通信しているときに自動的に処理されます。</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">以下はプリフライトされるリクエストの例です。</target>
        </trans-unit>
        <trans-unit id="f2caa1f526d805ff5feea71e36486901a1b33c7b" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted:</source>
          <target state="translated">以下はプリフライトされるリクエストの例です。</target>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">以下の行に関連するキー情報(pin-sha256=&quot;...&quot;フィールド)を記述することで、lighttpd上でHPKPを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">以下のリストでは、HTTP ヘッダを用途別にまとめています。アルファベット順のリストについては、左側のナビゲーションを参照してください。</target>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">次のPROPFINDメソッドのリクエスト本文は無効です。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot;&amp;gt; &amp;lt;D：allprop /&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;/ D：propfind&amp;gt;定義propfind要素では、allpropまたはpropname要素のみが許可され、両方は許可されません。したがって、上記はエラーであり、400（Bad Request）で応答する必要があります。ただし、サーバーが「親切」になりたがって、allprop要素を真の要素として選択してそれに応答することを決定したと想像してください。サーバーがコマンドをallpropとして処理した場合、propnameを実行することを目的とした、帯域幅が制限された回線で実行されているクライアントは、非常に驚​​きます。さらに、サーバーが寛大で、このリクエストに応答することにした場合、結果はサーバーごとにランダムに異なり、allpropディレクティブを実行するサーバーと、propnameディレクティブを実行するサーバーがあります。これにより、相互運用性が向上するのではなく、低下します。</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">&lt;a href=&quot;#section-3.4.1&quot;&gt;セクション3.4.1で&lt;/a&gt;定義されているように、次のリクエストヘッダーフィールドはユーザーエージェントによって送信され、レスポンスコンテンツの積極的な交渉に従事します。これらのフィールドで送信される設定は、ターゲットリソースの表現、エラーまたは処理ステータスの表現、プロトコル内に表示される可能性のあるその他のテキスト文字列など、応答のコンテンツに適用されます。 + ------------------- + --------------- + |ヘッダーフィールド名|で定義されています... | + ------------------- + --------------- + |同意する| &lt;a href=&quot;#section-5.3.2&quot;&gt;セクション5.3.2&lt;/a&gt; | | Accept-Charset | &lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt; | | Accept-Encoding | &lt;a href=&quot;#section-5.3.4&quot;&gt;セクション5.3.4&lt;/a&gt; | | Accept-Language | &lt;a href=&quot;#section-5.3.5&quot;&gt;セクション5.3.5&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">次のリクエストヘッダーフィールドは、リクエストの背後にあるユーザー、ユーザーエージェント、リソースに関する情報など、リクエストコンテキストに関する追加情報を提供します。+ ------------------- + --------------- + | ヘッダーフィールド名| で定義されています... | + ------------------- + --------------- + | から| &lt;a href=&quot;#section-5.5.1&quot;&gt;セクション5.5.1&lt;/a&gt; | | リファラー| &lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt; | | ユーザーエージェント| &lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">この仕様全体で、次のルールを使用して、基本的な構文解析構文を説明しています。US-ASCIIコード化文字セットは、ANSI X3.4-1986 [ &lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]。 OCTET = &amp;lt;任意の8ビットのデータシーケンス&amp;gt; CHAR = &amp;lt;任意のUS-ASCII文字（オクテット0-127）&amp;gt; UPALPHA = &amp;lt;任意のUS-ASCII大文字 &quot;A&quot; .. &quot;Z&quot;&amp;gt; LOALPHA = &amp;lt;任意のUS- ASCII小文字 &quot;a&quot; .. &quot;z&quot;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;任意のUS-ASCII数字 &quot;0&quot; .. &quot;9&quot;&amp;gt; CTL = &amp;lt;任意のUS-ASCII制御文字（オクテット0〜31）およびDEL（127）&amp;gt; CR = &amp;lt;US-ASCII CR、キャリッジリターン（ 13）&amp;gt; LF = &amp;lt;US-ASCII LF、改行（10）&amp;gt; SP = &amp;lt;US-ASCII SP、スペース（32）&amp;gt; HT = &amp;lt;US-ASCII HT、水平タブ（9）&amp;gt; &amp;lt;&quot;&amp;gt; = &amp;lt;US-ASCIIの二重引用符（34）&amp;gt; HTTP / 1.1は、エンティティボディを除くすべてのプロトコル要素の行末マーカーとしてシーケンスCR LFを定義します（耐性のあるアプリケーションについては、付録19.3を参照）。 entity-body内の行末マーカーは、関連するメディアタイプによって定義されます。&lt;a href=&quot;#section-3.7&quot;&gt;セクション3.7&lt;/a&gt;。 CRLF = CR LF継続行がスペースまたは水平タブで始まる場合、HTTP / 1.1ヘッダーフィールド値は複数行に折りたたむことができます。折りたたみを含むすべての線形空白は、SPと同じセマンティクスを持っています。受信者は、フィールド値を解釈したり、メッセージをダウンストリームに転送したりする前に、線形の空白を単一のSPで置き換えてもよい（MAY）。 LWS = [CRLF] 1 *（SP | HT）TEXTルールは、メッセージパーサーによる解釈を目的としない説明的なフィールドの内容と値にのみ使用されます。 * TEXTの単語には、&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047の&lt;/a&gt;規則に従ってエンコードされている場合にのみ、ISO-8859-1 [ &lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt; ] 以外の文字セットの文字を含めることができます [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]。 TEXT = &amp;lt;CTLを除く任意のOCTET、ただしLWSを含む&amp;gt;ヘッダーフィールドの継続の一部としてのみ、TEXTの定義でCRLFを使用できます。 TEXT値を解釈する前に、フォールディングLWSが単一のSPに置き換えられることが期待されています。 16進数の数字は、いくつかのプロトコル要素で使用されます。 HEX = &quot;A&quot; | 「B」| 「C」| 「D」| 「E」| 「F」| &quot;a&quot; | 「b」| 「c」| 「d」| 「e」| &quot;f&quot; | DIGIT多くのHTTP / 1.1ヘッダーフィールド値は、LWSまたは特殊文字で区切られた単語で構成されています。これらの特殊文字は、パラメータ値内で使用される引用符付き文字列に含まれている必要があります（ &lt;a href=&quot;#section-3.6&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6で定義）&lt;/a&gt;）。トークン= 1 * &amp;lt;CTLまたはセパレータを除く任意のCHAR&amp;gt;セパレータ= &quot;（&quot; | &quot;）&quot; | 「&amp;lt;」| &quot;&amp;gt;&quot; | 「@」| 「、」| 「;」 | &quot;：&quot; | 「\」| &amp;lt;&quot;&amp;gt; |&quot; / &quot;|&quot; [&quot;|&quot;] &quot;|&quot;？ &quot;|&quot; = &quot;|&quot; {&quot;|&quot;} &quot;| SP | HTコメントは、コメントテキストを次のように囲むことにより、一部のHTTPヘッダーフィールドに含めることができます。括弧。コメントは、フィールド値の定義の一部として「コメント」を含むフィールドでのみ許可されます。他のすべてのフィールドでは、括弧はフィールド値の一部と見なされます。comment= &quot;（&quot; *（ctext | quoted-pair | comment） &quot; ）」ctext = &amp;lt;「（」と「）」を除く任意のTEXT&amp;gt;テキストの文字列は、二重引用符で囲まれている場合、1つの単語として解析されます。 quoted-string =（&amp;lt;&quot;&amp;gt; *（qdtext | quoted-pair）&amp;lt;&quot;&amp;gt;）qdtext = &amp;lt;&amp;lt; &quot;&amp;gt;&amp;gt;を除く任意のテキストバックスラッシュ文字（&quot; \ &quot;）は、単一文字の引用メカニズムとしてのみ使用できますquoted-stringおよびcomment構文。quoted-pair = &quot;\&quot; CHAR）引用文字列とコメント構造内でのみ、単一文字の引用メカニズムとして使用できます。 quoted-pair = &quot;\&quot; CHAR）引用文字列とコメント構造内でのみ、単一文字の引用メカニズムとして使用できます。 quoted-pair = &quot;\&quot; CHAR</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">次のセクションでは、任意のアクセスタイプのロックを解除し、既存のロックを更新するために使用されるLOCKメソッドについて説明します。LOCKメソッドに関するこれらのセクションでは、LOCKメソッドに固有で、要求されるロックのアクセスタイプに依存しないセマンティクスのみを説明します。LOCKメソッドをサポートするリソースは、少なくとも、ここで定義されているXML要求および応答フォーマットをサポートする必要があります。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等でも安全でもありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">次のステータスコードは、HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されているものに追加されます。</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">主要なブラウザベンダーがモバイル端末でブラウザが動作していることを示す方法をまとめてみました。</target>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL の形式は非常に単純ですが、「データ」セグメントの前にコンマを置くのを忘れたり、データを誤ってbase64形式にエンコードしたりするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">形式の問題は、リクエストで示された&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;が原因であるか、データを直接検査した結果である可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6417d40b5bbb94e0ab0361d59b5efbe6a9c03d8" translate="yes" xml:space="preserve">
          <source>The forward slash (&lt;code&gt;/&lt;/code&gt;) character is interpreted as a directory separator, and subdirectories will be matched as well: for &lt;code&gt;Path=/docs&lt;/code&gt;, &lt;code&gt;/docs&lt;/code&gt;, &lt;code&gt;/docs/Web/&lt;/code&gt;, and &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; will all match.</source>
          <target state="translated">スラッシュ（ &lt;code&gt;/&lt;/code&gt; ）文字はディレクトリ区切り文字として解釈され、サブディレクトリも一致します &lt;code&gt;Path=/docs&lt;/code&gt; 、 &lt;code&gt;/docs&lt;/code&gt; 、 &lt;code&gt;/docs/Web/&lt;/code&gt; 、および &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; の場合はすべて一致します。</target>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">転送されるプロトコル(httpまたはhttps)。</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">HTTP認証のフレームワークは、&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;ではなく、このドキュメントで定義されるようになりました。 「レルム」パラメーターは、課題で常に必要とされなくなりました。その結果、ABNFは認証パラメーターなしでチャレンジを許可します。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）「Basic」などの従来の認証方式との一貫性を保つために、auth-paramリストの「token68」代替が追加されました。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）この仕様では、新しい認証方式に関する考慮事項とともに、認証方式レジストリを紹介しています。 （&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4d91b5b813304e8a213249cb1c603b64a74abb68" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-Control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime.</source>
          <target state="translated">鮮度の寿命は、いくつかのヘッダーに基づいて計算されます。「 &lt;code&gt;Cache-Control: max-age=N&lt;/code&gt; 」ヘッダーが指定されている場合、鮮度の有効期間はNに等しくなります。このヘッダーが存在しない場合（多くの場合）、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーが存在するかどうかがチェックされます。 &lt;code&gt;Expires&lt;/code&gt; ヘッダーが存在する場合、その値から&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;ヘッダーの値を引いたものが、鮮度の有効期間を決定します。</target>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">フレッシュネスライフタイムは、いくつかのヘッダーに基づいて計算されます。 &quot; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &quot;ヘッダーが指定されている場合、鮮度の有効期間はNに等しくなります。このヘッダーが存在しない場合、これは非常によくあることですが、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーが存在するかどうかが確認されます。場合 &lt;code&gt;Expires&lt;/code&gt; ヘッダが存在し、その値がマイナスの値&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;ヘッダは新鮮寿命を決定します。最後に、どちらのヘッダーも存在しない場合は、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;ヘッダーを探します。このヘッダーが存在する場合、キャッシュのフレッシュネスライフタイムは、 &lt;code&gt;Date&lt;/code&gt; ヘッダーの値から &lt;code&gt;Last-modified&lt;/code&gt; ヘッダーの値を10で割った値を引いた値に等しくなります。</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">一般的なHTTP認証フレームワーク</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">一般的な HTTP 認証フレームワークは、いくつかの認証スキームで使用されています。スキームは、セキュリティの強さや、クライアントやサーバのソフトウェアでの利用可能性が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">一般的な原則は、ウェブ開発者が機能が無効化された場合に、その機能を検出したり、処理したりするための、直感的な、あるいは壊れない方法があるべきであるということです。新しく導入された機能には、その状態を知らせる明示的なAPIがあるかもしれません。後にフィーチャーポリシーと統合される既存の機能は、一般的に既存のメカニズムを使用します。いくつかのアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">グローバル &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; 属性はHTML要素で使用され、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;ドキュメント全体またはその一部の言語を示します。</target>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">URL から抽出したホスト名。これは便宜上のものであり、 ://と最初の:または/の間と同じ文字列になります。ポート番号はこのパラメータには含まれません。必要に応じて URL から抽出することができます。</target>
        </trans-unit>
        <trans-unit id="5f24db479cf2b72fa937bcb464d99834bc0f6796" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between &lt;code&gt;://&lt;/code&gt; and the first &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">URLから抽出されたホスト名。これは便宜上のものです。 &lt;code&gt;://&lt;/code&gt; と最初の &lt;code&gt;:&lt;/code&gt; または &lt;code&gt;/&lt;/code&gt; の後の文字列と同じです。ポート番号はこのパラメーターに含まれていません。必要に応じてURLから抽出できます。</target>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">URLからのホスト名(ポート番号を除く)。</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">URLからのホスト名です。</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">IDとWeb上のリソースの場所は、ほとんどが単一のURL（URIの一種であるUniform Resource Locator）によって提供されます。IDと場所が同じURIで提供されない理由が時々あります。HTTPは、要求されたリソースがクライアントに別の場所でアクセスすることを要求したときに、特定のHTTPヘッダー&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">iframeのallow属性</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">いくつかのブラウザでこのプリフェッチを実装することで、実際のページコンテンツのフェッチと並行して(シリアルではなく)ドメイン名解決を行うことができます。これにより、高遅延のドメイン名解決プロセスは、コンテンツをフェッチしている間に遅延を発生させません。</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">app:draft &quot;要素を含めることは、メンバーリソースの可視性を制御するためのクライアントからのリクエストを表す。app:draft要素はサーバーによって無視されてもよい[MAY]。app:controlに含まれるapp:draft要素の数は0か1でなければならない[MUST]。app:draft要素の内容は &quot;yes &quot;か &quot;no &quot;のいずれかでなければならない[MUST]。要素に &quot;no &quot;が含まれている場合、これはメンバーリソースを公開することをクライアントが要求していることを示す。app:draft要素が存在しない場合、拡張機能をサポートするサーバーは、「no」を含む app:draft要素が送られたかのように動作しなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下の情報は、MDNのGitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）から取得されています。</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">クライアントによる情報は非常に冗長であり(HTTP/2ヘッダ圧縮はこの問題を軽減します)、プライバシーリスク(HTTPフィンガープリンティング)があります。</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下に示す情報は、MDNのGitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）から取得されています。</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">初期範囲単位レジストリには、以下の登録が含まれています。+ ------------- + ------------------------- -------------- + ------------- + |レンジユニット|説明|リファレンス| |名前| | | + ------------- + ----------------------------------- ---- + ------------- + |バイト|オクテットの範囲| &lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1&lt;/a&gt; | |なし|キーワードとして予約されており、| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | | |範囲がサポートされています| | + ------------- + ----------------------------------- ---- + ------------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">HTTPの初期バージョンにはバージョン番号がありませんでした。後のバージョンと区別するために、後で0.9と呼ばれています。HTTP / 0.9は非常にシンプルです。リクエストは1行で構成され、唯一可能なメソッド&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; で&lt;/a&gt;始まり、リソースへのパスが続きます（サーバーに接続すると、プロトコル、サーバー、ポートの両方が不要になるため、URLではありません）。</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">プロキシサーバにリクエストが入ってきたインターフェース。</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt;の導入により、ブラウザまたはクライアントは、その要件またはハードウェアの制約に関する情報をサーバーにプロアクティブに通信できます。</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">&lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーにセキュリティ関連のプレフィックスが導入されたことにより、安全なCookieが変更されていないことを保証できるようになりました。</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">発行されたリクエストは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">このアップグレード要求のキーです。クライアントがこれを追加したい場合はクライアントが追加します。 サーバは応答に独自のキーを含めます。</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]で説明されているように解釈されます。実装は、実装するプロトコルの1つ以上の必須レベルまたは必須レベルの要件を満たさない場合、準拠しません。プロトコルのすべてのMUSTまたはREQUIREDレベルおよびすべてのSHOULDレベルの要件を満たす実装は、「無条件に準拠」していると言われています。プロトコルのすべてのMUSTレベルの要件を満たしているが、そのプロトコルのすべてのSHOULDレベルの要件を満たしていないものは、「条件付きで準拠している」と言われます。</target>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。エラー処理に関する適合基準と考慮事項は、&lt;a href=&quot;#section-2.5&quot;&gt;セクション2.5で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。エラー処理に関する適合基準と考慮事項&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;は、[RFC7230]のセクション2.5で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">検証の種類は、使用するバリデーターとは無関係です。どちらも、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; のは、&lt;/a&gt;複雑さが異なる場合があり、サーバー側でそれを実装するものの、検証の両方のタイプを可能にします。HTTPはデフォルトで強力な検証を使用し、弱い検証をいつ使用できるかを指定します。</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">HTTPに起こった最大の変化は、1994年末に行われました。基本的なTCP/IPスタック上でHTTPを送信する代わりに、Netscape通信はその上に暗号化された送信層を追加で作成しました。SSLです。SSL 1.0は決して外部には公開されませんでしたが、SSL 2.0とその後継のSSL 3.0とSSL 3.1は、サーバーとクライアントの間で交換されるメッセージの真正性を暗号化して保証することで、電子商取引のウェブサイトを作成することを可能にしました。SSLは標準化され、最終的にはTLSとなり、バージョン1.0、1.1、1.2では脆弱性を解消することに成功しました。TLS 1.3は現在作成中です。</target>
        </trans-unit>
        <trans-unit id="cedd0ab48b46862829d9707f126e162c35e1388c" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communications created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the company, but SSL 2.0 and its successor SSL 3.0 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with versions 1.0, 1.1, 1.2, and 1.3 appearing successfully to close vulnerabilities.</source>
          <target state="translated">HTTPに起こった最大の変化は、1994年末に行われました。Netscape Communications は基本的な TCP/IP スタック上で HTTP を送信する代わりに、その上に暗号化された送信層を追加で作りました。SSLです。SSL 1.0が社外に公開されることはありませんでしたが、SSL 2.0とその後継のSSL 3.0では、サーバーとクライアントの間でやり取りされるメッセージを暗号化して真正性を保証することで、電子商取引のウェブサイトを作成することが可能になりました。SSLは標準化され、最終的にはTLSとなり、バージョン1.0、1.1.1、1.2、1.3では脆弱性を解消することに成功しました。</target>
        </trans-unit>
        <trans-unit id="8afbff65f36ae363825e270b4816f35143b381cc" translate="yes" xml:space="preserve">
          <source>The last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">同じリソースの複数のバージョンを比較するために使用される、リソースの最終変更日。&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ほど正確ではありませんが、環境によっては計算が簡単です。&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; を&lt;/a&gt;使用する条件付きリクエストは、この値を使用してリクエストの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="a9022ae767f477f1c7bcdb68243b1fa5a2efe966" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code that sufficiently answers the request without the need for corresponding payload (like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt;) usually don't.</source>
          <target state="translated">応答の最後の部分は体です。いないすべての応答は1を持っています。十分に（のようなペイロード対応を必要とせずに要求に答えることをステータスコードとレスポンス&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; か、&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; ）通常はしません。</target>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">応答の最後の部分は本文です。すべての応答に1つがあるわけではありません。通常、&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;などのステータスコードを持つ応答にはありません。</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">オクテット数の10進数での長さです。</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">メッセージ本文の長さは、次のいずれかによって決定されます（優先順）：1. HEAD要求に対する応答と、1xx（情報）、204（内容なし）、または304（変更なし）を含む応答。ステータスコードは、メッセージに存在するヘッダーフィールドに関係なく、常にヘッダーフィールドの後の最初の空行で終了するため、メッセージ本文を含めることはできません。2. CONNECT要求に対する2xx（成功）応答は、ヘッダーフィールドを終了する空の行の直後に接続がトンネルになることを意味します。クライアントは、そのようなメッセージで受信されたContent-LengthまたはTransfer-Encodingヘッダーフィールドを無視する必要があります。3. Transfer-Encodingヘッダーフィールドが存在し、チャンク転送コーディング（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）は最終的なエンコードです。メッセージ本体の長さは、転送コーディングがデータの完了を示すまで、チャンクされたデータを読み取ってデコードすることによって決定されます。 Transfer-Encodingヘッダーフィールドが応答に存在し、チャンク転送コーディングが最終的なエンコーディングでない場合、メッセージ本文の長さは、サーバーによって閉じられるまで接続を読み取ることによって決定されます。 Transfer-Encodingヘッダーフィールドがリクエストに存在し、チャンク転送コーディングが最終的なエンコーディングでない場合、メッセージ本文の長さを確実に決定できません。サーバーは400（Bad Request）ステータスコードで応答してから、接続を閉じる必要があります。 Transfer-EncodingヘッダーとContent-Lengthヘッダーフィールドの両方を含むメッセージを受信した場合、Transfer-EncodingはContent-Lengthをオーバーライドします。このようなメッセージは、リクエストの密輸（&lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt;）または応答分割（&lt;a href=&quot;#section-9.4&quot;&gt;セクション9.4&lt;/a&gt;）、エラーとして処理する必要があります。送信者は、このようなメッセージをダウンストリームに転送する前に、受信したContent-Lengthフィールドを削除する必要があります。 4.メッセージがTransfer-Encodingなしで受信され、フィールド値が異なる複数のContent-Lengthヘッダーフィールド、または無効な値を持つ単一のContent-Lengthヘッダーフィールドが含まれる場合、メッセージのフレーミングは無効であり、受信者はそれを処理する必要があります。回復不可能なエラーとして。これが要求メッセージである場合、サーバーは400（Bad Request）ステータスコードで応答してから、接続を閉じる必要があります。これがプロキシによって受信された応答メッセージである場合、プロキシはサーバーへの接続を閉じ、受信した応答を破棄し、502（不正なゲートウェイ）応答をクライアントに送信する必要があります。これがユーザーエージェントによって受信された応答メッセージである場合、ユーザーエージェントはサーバーへの接続を閉じ、受信した応答を破棄する必要があります。 5.有効なContent-LengthヘッダーフィールドがTransfer-Encodingなしで存在する場合、その10進値は予想されるメッセージ本文の長さをオクテットで定義します。送信者が接続を閉じるか、指定された数のオクテットを受信する前に受信者がタイムアウトした場合、受信者はメッセージが不完全であると見なして接続を閉じる必要があります。 6.これが要求メッセージであり、上記のいずれにも該当しない場合、メッセージ本文の長さはゼロです（メッセージ本文は存在しません）。 7.それ以外の場合、これはメッセージ本文の長さが宣言されていない応答メッセージです。したがって、メッセージ本文の長さは、サーバーが接続を閉じる前に受信したオクテットの数によって決まります。正常に完了した区切り文字のメッセージと、ネットワーク障害によって中断された部分的に受信されたメッセージを区別する方法がないため、サーバーは、可能な場合は常にエンコードメッセージまたは長さ区切りのメッセージを生成する必要があります。クローズ区切り機能は、主にHTTP / 1.0との下位互換性のために存在します。サーバーは、411（Length Required）で応答することにより、メッセージ本文を含むがContent-Lengthを含まない要求を拒否してもよい（MAY）。チャンク以外の転送コーディングが適用されていない限り、メッセージ本文を含むリクエストを送信するクライアントは、メッセージ本文の長さが事前にわかっている場合、有効なContent-Lengthヘッダーフィールドを使用する必要があります。チャンク転送コーディングではなく、チャンク転送コーディングを理解している場合でも、一部の既存のサービスは411（Length Required）ステータスコードでチャンクに応答します。これは通常、そのようなサービスが呼び出される前にcontent-lengthを必要とするゲートウェイを介して実装されており、サーバーが処理前にリクエスト全体をバッファリングできない、または望まないためです。メッセージ本文を含むリクエストを送信するユーザーエージェントは、サーバーがHTTP / 1.1（またはそれ以降）のリクエストを処理することを知らない場合、有効なContent-Lengthヘッダーフィールドを送信する必要があります。このような知識は、特定のユーザー構成の形式にすることも、以前に受け取った応答のバージョンを覚えておくこともできます。接続の最後のリクエストへの最終応答が完全に受信され、読み取る追加のデータが残っている場合、ユーザーエージェントは残りのデータを破棄するか、そのデータが前の応答本文の一部として属しているかどうかを判断しようとします。前のメッセージのContent-Length値が正しくない場合。そのような振る舞いはキャッシュポイズニングに対して脆弱であるため、クライアントはそのような余分なデータを別の応答として処理、キャッシュ、または転送してはなりません（MUST NOT）。このような動作はキャッシュポイズニングに対して脆弱であるためです。このような動作はキャッシュポイズニングに対して脆弱であるためです。</target>
        </trans-unit>
        <trans-unit id="bc721cb7f57681a68e8ffe39db25deee64045b40" translate="yes" xml:space="preserve">
          <source>The lifetime of a cookie can be defined in two ways:</source>
          <target state="translated">クッキーの寿命は2つの方法で定義できます。</target>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">許可された&lt;a href=&quot;../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;のリスト。</target>
        </trans-unit>
        <trans-unit id="2d4513b7f363144d73199955a36973cf7c46be3c" translate="yes" xml:space="preserve">
          <source>The maximum amount of time a resource is considered fresh. Unlike &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">リソースがフレッシュと見なされる最大時間。 &lt;code&gt;Expires&lt;/code&gt; とは異なり、このディレクティブはリクエストの時間に関連しています。</target>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">HTTP日付のタイムスタンプとしてのCookieの最大有効期間。詳細な形式については、&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;を参照してください。指定しない場合、Cookieには&lt;strong&gt;セッションCookieの&lt;/strong&gt;存続期間があり&lt;strong&gt;ます。&lt;/strong&gt;クライアントがシャットダウンするとセッションは終了します。つまり、セッションCookieはその時点で削除されます。ただし、多くのWebブラウザーにはセッションの復元と呼ばれる機能があり、すべてのタブが保存され、次回ブラウザーを使用したときにタブが再び表示されます。Cookieも表示され、ブラウザを実際に閉じたことがないようです。</target>
        </trans-unit>
        <trans-unit id="d852a80087f1759845814ae78b7b6a4cc10fa2cf" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the required formatting.</source>
          <target state="translated">HTTP日付タイムスタンプとしてのCookieの最大存続期間。必要なフォーマットについては、&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">サポートされる最大サイズは32kBです。</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">サポートされている最大サイズは4GBです。</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">成功の意味は、HTTPリクエストメソッドに依存します。</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">要求されたデータのメディアフォーマットがサーバーでサポートされていないため、サーバーは要求を拒否しています。</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">HTTPメッセージのメッセージ本文（存在する場合）は、その要求または応答のペイロード本文を運ぶために使用されます。&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1で&lt;/a&gt;説明されているように、転送コーディングが適用されていない限り、メッセージ本文はペイロード本文と同じです。 message-body = * OCTETメッセージでメッセージ本文を使用できる場合のルールは、要求と応答で異なります。リクエスト内のメッセージ本文の存在は、Content-LengthまたはTransfer-Encodingヘッダーフィールドによって通知されます。メソッドがメッセージ本文の使用を定義していない場合でも、要求メッセージのフレーミングはメソッドのセマンティクスとは無関係です。応答内のメッセージ本文の存在は、応答先のリクエストメソッドと応答ステータスコードの両方に依存します（&lt;a href=&quot;#section-3.1.2&quot;&gt;セクション3.1.2&lt;/a&gt;）。関連する応答ヘッダーフィールド（たとえば、Transfer-Encoding、Content-Lengthなど）が存在する場合、それらの値のみを示すため、HEADリクエストメソッド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]のセクション4.3.2&lt;/a&gt;）への応答には、メッセージ本文は含まれません。リクエストメソッドがGETであった場合（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]のセクション4.3.1&lt;/a&gt;）。 CONNECT要求メソッドへの2xx（成功）応答（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6&lt;/a&gt;）は、メッセージ本文の代わりにトンネルモードに切り替わります。すべての1xx（情報）、204（コンテンツなし）、および304（変更なし）応答には、メッセージ本文が含まれていません。他のすべての応答にはメッセージ本文が含まれますが、本文の長さがゼロの場合もあります。</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">以下のメッセージヘッダーフィールドを永続的なレジストリに追加する必要があります（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ]を参照）。</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">HTTPメッセージのメッセージ本文（存在する場合）は、要求または応答に関連付けられたエンティティ本体を運ぶために使用されます。 Transfer-Encodingヘッダーフィールド（&lt;a href=&quot;#section-14.41&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;）で示されているように、メッセージ本体がエンティティ本体と異なるのは、転送コーディングが適用されている場合のみです。メッセージ本体=エンティティ本体| &amp;lt;Transition-Encodingに従ってエンコードされたエンティティボディ&amp;gt; Transfer-Encodingは、メッセージの安全かつ適切な転送を保証するためにアプリケーションによって適用される転送コーディングを示すために使用する必要があります。 Transfer-Encodingはエンティティではなくメッセージのプロパティであるため、要求/応答チェーンに沿ってアプリケーションによって追加または削除される場合があります。 （ただし、&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;特定の転送コーディングをいつ使用できるかを制限します。）メッセージ本文でメッセージ本文を使用できる場合の規則は、要求と応答で異なります。要求内のメッセージ本文の存在は、要求のメッセージヘッダーにContent-LengthまたはTransfer-Encodingヘッダーフィールドを含めることによって通知されます。リクエストメソッドの仕様の場合、メッセージボディをリクエストに含めることはできません（&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）リクエストでエンティティ本体を送信することはできません。サーバーはどんなリクエストでもメッセージ本文を読んで転送すべきです。リクエストメソッドにエンティティボディの定義されたセマンティクスが含まれていない場合、リクエストを処理するときにメッセージボディを無視する必要があります（SHOULD）。応答メッセージの場合、メッセージ本文がメッセージに含まれるかどうかは、要求メソッドと応答ステータスコードの両方に依存します（&lt;a href=&quot;#section-6.1.1&quot;&gt;セクション6.1.1&lt;/a&gt;）。エンティティヘッダーフィールドが存在すると信じることができる場合でも、HEADリクエストメソッドへのすべての応答にメッセージ本文を含めることはできません。すべての1xx（情報）、204（コンテンツなし）、および304（変更されていない）応答には、メッセージ本文を含めることはできません。他のすべての応答にはメッセージ本文が含まれますが、長さはゼロになる場合があります。</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">message / httpタイプは、行の長さとエンコーディングに関するすべての「メッセージ」タイプのMIME制限に従う場合、単一のHTTP要求または応答メッセージを囲むために使用できます。タイプ名：メッセージサブタイプ名：http必須パラメーター：N / Aオプションパラメーター：バージョン、msgtypeバージョン：囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：「7ビット」、「8ビット」、または「バイナリ」のみが許可されますセキュリティに関する考慮事項：&lt;a href=&quot;#section-9&quot;&gt;セクション9を参照&lt;/a&gt; 相互運用性に関する考慮事項：N / A公開された仕様：この仕様（&lt;a href=&quot;#section-8.3.1&quot;&gt;セクション8.3.1を&lt;/a&gt;参照）。このメディアタイプを使用するアプリケーション：該当なしフラグメント識別子の考慮事項：該当なし追加情報：マジックナンバー：該当なしこのタイプの非推奨のエイリアス名：該当なしファイル拡張子：該当なしMacintoshファイルタイプコード：該当なし詳細については、連絡先の人物と電子メールアドレス：作成者のアドレスセクションを参照してください。使用目的：共通使用上の制限：なし作成者：「作成者のアドレス」セクションを参照してください。コントローラーの変更：IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">メソッドと元のリクエストの本文は、リダイレクトされたリクエストを実行するために再利用されます。メソッドを&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;に変更する場合は、代わりに&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; を&lt;/a&gt;使用してください。これは、アップロードされたリソースではなく、確認メッセージ（「正常にXYZをアップロードしました」など）である&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;メソッドへの回答を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="9c74b76d94e666b868875958cf478928caee388b" translate="yes" xml:space="preserve">
          <source>The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.</source>
          <target state="translated">サーバーがリクエストを正常に完了させるために必要な表現を保存できないため、リソースに対してメソッドを実行できませんでした。</target>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Request-Lineで指定されたメソッドは、Request-URIで特定されたリソー スに対して許可されていない。応答は、リクエストされたリソースに対して有効なメソッドのリストを含む Allowヘッダーを含まなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">誤解されているX-XSS-Protection &amp;ndash; blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">キャッシュされたリソースを使用すればするほど、Web サイトの応答性とパフォーマンスが向上します。これを最適化するために、グッドプラクティスでは、有効期限を可能な限り未来に設定することを推奨しています。これは定期的に更新されるか、頻繁に更新されるリソースでは可能ですが、まれに更新されるか、まれにしか更新されないリソースでは問題があります。これらのリソースは、キャッシングリソースから最も恩恵を受けるであろうリソースですが、そのために更新が非常に困難になっています。これは、各 Web ページに含まれ、各 Web ページからリンクされている技術的なリソースに典型的なものです。JavaScript と CSS ファイルはまれに変更されますが、変更されたときはすぐに更新したいものです。</target>
        </trans-unit>
        <trans-unit id="2b2d80c0ac04c3f4350cef824a1e1156d252f06e" translate="yes" xml:space="preserve">
          <source>The most &quot;original&quot; implementation of PAC and its JavaScript libraries is, therefore, &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; found in early versions of Firefox. These utilities are found in many other open-source systems including &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;. Firefox later integrated the file into &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; as a C++ string literal. To extract it into its own file, it suffices to copy the chunk into JavaScript with a &lt;code&gt;console.log&lt;/code&gt; directive to print it.</source>
          <target state="translated">したがって、PACとそのJavaScriptライブラリの最も「元の」実装は、Firefoxの初期バージョンにある &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; です。これらのユーティリティは、&lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;を含む他の多くのオープンソースシステムにあります。Firefoxは後で、ファイルをC ++文字列リテラルとして &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; に統合しました。それを独自のファイルに抽出するには、 &lt;code&gt;console.log&lt;/code&gt; ディレクティブを使用してチャンクをJavaScriptにコピーして印刷するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">ロックの最も基本的な形式は、排他ロックです。排他ロックは、この仕様で説明されている方法以外の調整を必要とせずに、コンテンツ変更の競合に対処する必要がないようにします。ただし、ロックの目的がアクセス権の行使から他人を排除することではなく、プリンシパルがアクセス権を行使するつもりであることを示すメカニズムを提供することである場合があります。この場合、共有ロックが提供されます。共有ロックにより、複数のプリンシパルがロックを受け取ることができます。したがって、アクセス権と有効なロックの両方を持つプリンシパルは、ロックされたリソースを使用できます。共有ロックには、リソースに影響を与える2つの信頼セットがあります。最初の信頼セットは、アクセス許可によって作成されます。たとえば、信頼されているプリンシパルリソースへの書き込み権限がある可能性があります。リソースへの書き込みアクセス権を持つユーザーの間で、共有ロックを取得したプリンシパルのセットも互いに信頼し、アクセス許可書き込みセット内に（通常は）より小さな信頼セットを作成する必要があります。インターネット上のすべての可能なプリンシパルから始めて、ほとんどの状況では、これらのプリンシパルの大部分は、特定のリソースへの書き込みアクセス権を持ちません。書き込みアクセス権を持っている少数のプリンシパルの中には、排他的書き込みロックを使用して、編集が上書きの競合から解放されることを保証することを決定する場合があります。他のユーザーは、共同編集者が自分の作業を上書きしないと確信し（潜在的な共同編集者のセットは書き込み権限を持つプリンシパルのセットです）、共有ロックを使用します。プリンシパルがリソースで作業している可能性があることを共同編集者に通知します。 HTTPのWebDAV拡張は、プリンシパルがアクティビティを調整するために必要なすべての通信パスを提供する必要はありません。共有ロックを使用する場合、プリンシパルは任意の帯域外通信チャネルを使用して作業を調整することができます（例：対面のやり取り、手書きのメモ、画面上の付箋、電話による会話、電子メールなど）。共有ロックの目的は、他の誰がリソースに取り組んでいるかを共同編集者に知らせることです。共有ロックが含まれているのは、Webで分散されたオーサリングシステムの経験から、排他ロックは厳格すぎることが多いためです。排他ロックは、特定の編集プロセスを強制するために使用されます。排他ロックを取り出し、リソースを読み取り、編集を実行します。リソースを書き込み、ロックを解放します。この編集プロセスには、プログラムがクラッシュしたときや、ロックの作成者がリソースのロックを解除せずに離れたときなど、ロックが常に適切に解放されるとは限らないという問題があります。両方のタイムアウト（&lt;a href=&quot;#section-6.6&quot;&gt;セクション6.6&lt;/a&gt;）および管理アクションを使用して問題のあるロックを削除できます。どちらのメカニズムも必要なときに使用できない場合があります。タイムアウトが長いか、管理者がいない可能性があります。新しい共有ロックの要求が成功すると、要求元のプリンシパルに関連付けられた一意のロックが生成される必要があります。したがって、5つのプリンシパルが同じリソースの共有書き込みロックを取り出した場合、各プリンシパルに1つずつ、5つのロックと5つのロックトークンが存在します。</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最も一般的な認証方式は、以下で詳しく説明する「基本」認証方式です。IANA &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;は認証スキームのリストを&lt;/a&gt;保持していますが、Amazon AWSなどのホストサービスによって提供される他のスキームもあります。一般的な認証スキームは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="255966f9ca10cd047714babaf260d4a6e24ab848" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme, which is introduced in more detail below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最も一般的な認証スキームは「基本」認証スキームであり、これについては以下で詳しく説明します。IANA&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;は認証スキームのリストを&lt;/a&gt;維持していますが、AmazonAWSなどのホストサービスによって提供される他のスキームがあります。一般的な認証スキームは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">URIの最も一般的な形式は、&lt;em&gt;Webアドレス&lt;/em&gt;と呼ばれるUniform Resource Locator（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;）です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">request-targetの最も一般的な形式はorigin-formです。origin-form =絶対パス[&quot;？&quot; クエリ] CONNECTまたはサーバー全体のOPTIONSリクエスト以外のオリジンサーバーに直接リクエストを送信する場合（詳細は以下を参照）、クライアントは絶対パスとターゲットURIのクエリコンポーネントのみをリクエストターゲットとして送信する必要があります。ターゲットURIのパスコンポーネントが空の場合、クライアントは、リクエストターゲットのorigin-form内のパスとして「/」を送信する必要があります。&lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4で&lt;/a&gt;定義されているように、ホストヘッダーフィールドも送信されます。 。たとえば、http：//www.example.org/where？q = nowとして識別されるリソースの表現をオリジンサーバーから直接取得したいクライアントは、ホストのポート80へのTCP接続を開く（または再利用する） &quot;www.example.org&quot;とし、GET / where？q = now HTTP / 1.1 Host：www.example.orgに続けてリクエストメッセージの残りの行を送信します。</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">ユーザーエージェントのスニッフィングを実行する最も一般的な理由は、ブラウザが動作するデバイスのタイプを決定することです。目的は、異なるデバイスタイプに異なる HTML を提供することです。</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">条件付きリクエストの最も一般的な使用例は、キャッシュの更新です。空のキャッシュがある場合、またはキャッシュがない場合、要求されたリソースは&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; のステータスで送り返されます。</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">最も一般的な使用例はダウンロードを再開することで、最後のフラグメントを受信してから保存されたリソースが変更されていないことを保証することです。</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最も一般的な使用例は、関連付けられた&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がないキャッシュされたエンティティを更新することです。</target>
        </trans-unit>
        <trans-unit id="f8e294a410237a9ceaa795c432872e161168f9e7" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server. The modern &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;Fetch API&lt;/code&gt;&lt;/a&gt; provides the same features with a more powerful and flexible feature set.</source>
          <target state="translated">HTTPに基づく最も一般的に使用されるAPIは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; API&lt;/a&gt;であり、これを使用して&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;とサーバー間でデータを交換できます。最新の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;Fetch API&lt;/code&gt; &lt;/a&gt;は、より強力で柔軟な機能セットを備えた同じ機能を提供します。</target>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">HTTP上で最も一般的に使用されるAPIは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; APIで、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;とサーバー間でデータを交換するために使用できます。</target>
        </trans-unit>
        <trans-unit id="0a53cc937fbb9dc05f3c30062aeb2e10f7633a16" translate="yes" xml:space="preserve">
          <source>The most commonly used MIME types used for web content are listed below. This isn't a complete list of all the types that may be available, however. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats&lt;/a&gt; guide for that.</source>
          <target state="translated">Webコンテンツに使用される最も一般的に使用されるMIMEタイプを以下に示します。ただし、これは利用可能なすべてのタイプの完全なリストではありません。そのための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;メディアコンテナフォーマット&lt;/a&gt;ガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">ここで最も重要なディレクティブは「 &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; 」であり、これはリソースが新しいと見なされる最大時間です。&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; と&lt;/a&gt;は異なり、このディレクティブはリクエストの時間に関連しています。変更されないアプリケーション内のファイルについては、通常、積極的なキャッシュを追加できます。これには、画像、CSSファイル、JavaScriptファイルなどの静的ファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="ec18430cf06631edb1cb32f0734bdaa2055f42e3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;, which is the maximum amount of time in which a resource will be considered fresh. This directive is relative to the time of the request, and overrides the &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header (if set). For the files in the application that will not change, you can normally use aggressive caching. This includes static files such as images, CSS files, and JavaScript files, for example.</source>
          <target state="translated">ここで最も重要なディレクティブは &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; です。これは、リソースが新しいと見なされる最大時間です。このディレクティブはリクエストの時間に関連しており、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダー（設定されている場合）をオーバーライドします。変更されないアプリケーション内のファイルについては、通常、積極的なキャッシュを使用できます。これには、画像、CSSファイル、JavaScriptファイルなどの静的ファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;とCORSの両方で公開されている最も興味深い機能は、&lt;a href=&quot;cookies&quot;&gt;HTTP Cookie&lt;/a&gt;とHTTP認証情報を認識する「資格のある」リクエストを作成する機能です。デフォルトでは、クロスサイト &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;呼び出しでは、ブラウザーは資格情報を送信し&lt;strong&gt;ません&lt;/strong&gt; &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; オブジェクトまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;コンストラクターが呼び出されるときに、特定のフラグを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f1f72e7e757ea8a76c23e50644af8cf17ebd184" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">両方によって公開された最も興味深い機能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;取得&lt;/a&gt;し、CORSは、「資格認定」を意識している要求できるようにする機能である&lt;a href=&quot;cookies&quot;&gt;HTTPクッキー&lt;/a&gt;やHTTP認証情報を。デフォルトでは、クロスサイト &lt;code&gt;XMLHttpRequest&lt;/code&gt; または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;呼び出しでは、ブラウザーは資格情報を送信し&lt;strong&gt;ません&lt;/strong&gt;。 &lt;code&gt;XMLHttpRequest&lt;/code&gt; オブジェクトまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;コンストラクターを呼び出すときに、特定のフラグを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">サポートされているリクエストヘッダの名前。このヘッダはカンマで区切られた任意の数のヘッダをリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">違反した政策課の名称。</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">リクエストを処理するソフトウェアまたは(サブ)製品の名前です。</target>
        </trans-unit>
        <trans-unit id="d061e432c2a538045e603ec2696ad4093da4b49d" translate="yes" xml:space="preserve">
          <source>The name of the software or product that handled the request. Usually in a format similar to &lt;a href=&quot;user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">リクエストを処理したソフトウェアまたは製品の名前。通常、&lt;a href=&quot;user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;と同様の形式です。</target>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; ヘッダーを追加するサーバーまたはソフトウェアの名前または仮名（エージェントが不明の場合は「-」の場合があります）。</target>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">HTTPの次のメジャーバージョンであるHTTP/3では、トランスポート層部分にTCP/TLSではなくQUICを使用します。</target>
        </trans-unit>
        <trans-unit id="b8b5231ea957c239b67921ea4d3ca6986e579896" translate="yes" xml:space="preserve">
          <source>The non-Chromium Edge puts its engine version after the &lt;em&gt;Edge/&lt;/em&gt; token, not the application version.</source>
          <target state="translated">非ChromiumEdgeは、アプリケーションバージョンではなく、&lt;em&gt;Edge /&lt;/em&gt;トークンの後にエンジンバージョンを配置します。</target>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">非標準の &lt;code&gt;Large-Allocation&lt;/code&gt; レスポンスヘッダーは、読み込まれているページが大きな割り当てを実行することをブラウザに通知します。現在、Firefoxにのみ実装されていますが、すべてのブラウザーに送信しても問題はありません。</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">HTTP ヘッダの概念は、リクエストとレスポンスの両方に導入され、メタデータの送信を可能にし、プロトコルを非常に柔軟で拡張性の高いものにしています。</target>
        </trans-unit>
        <trans-unit id="5a8511f9154b7d1710ad96380db408589218a6d1" translate="yes" xml:space="preserve">
          <source>The number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host of the received message as a known &lt;code&gt;Expect-CT&lt;/code&gt; host.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダーフィールドの受信後、ユーザーエージェントが受信したメッセージのホストを既知の &lt;code&gt;Expect-CT&lt;/code&gt; ホストと見なす必要がある秒数。</target>
        </trans-unit>
        <trans-unit id="1c597b22723fbfd913584650ba834a8d38d96da2" translate="yes" xml:space="preserve">
          <source>The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. Alternative service entries can be cached for up to &lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt; seconds, minus the age of the response (from the &lt;a href=&quot;age&quot;&gt;&lt;code&gt;Age&lt;/code&gt;&lt;/a&gt; header). If the cached entry expires, the client can no longer use this alternative service for new connections.</source>
          <target state="translated">代替サービスがフレッシュと見なされる秒数。省略した場合、デフォルトで24時間になります。代替サービスエントリは、最大&lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt;秒間、応答の経過時間（&lt;a href=&quot;age&quot;&gt; &lt;code&gt;Age&lt;/code&gt; &lt;/a&gt;ヘッダーから）を差し引いてキャッシュできます。キャッシュされたエントリの有効期限が切れると、クライアントはこの代替サービスを新しい接続に使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">廃止された&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt; ディレクティブ。</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">ユーザーエージェントが「新しいスタイル」のCookieを理解することをサーバーに通知するために使用されている廃止された &lt;code&gt;Cookie2&lt;/code&gt; HTTPリクエストヘッダーですが、現在では、ユーザーエージェントは代わりに&lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">廃止された &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP応答ヘッダーは、サーバーからユーザーエージェントにCookieを送信するために使用されましたが、仕様では非推奨になっています。代わりに&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">許可されているのは、この方法だけです。</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;ヘッダーに許可される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">唯一の違い &lt;code&gt;307&lt;/code&gt; 及び&lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; は、&lt;/a&gt;すなわち &lt;code&gt;307&lt;/code&gt; リダイレクトされた要求が行われたときの方法と本体が変更されないことを保証します。では &lt;code&gt;302&lt;/code&gt; 、いくつかの古いクライアントは間違っする方法を変更した&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;：非と行動 &lt;code&gt;GET&lt;/code&gt; メソッドと &lt;code&gt;302&lt;/code&gt; が持つ振る舞いに対し、Web上でその後、予測不可能である &lt;code&gt;307&lt;/code&gt; は、予測可能です。以下のため &lt;code&gt;GET&lt;/code&gt; リクエスト、彼らの行動は同じです。</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">仕様で定義されている唯一の期待値は &lt;code&gt;Expect: 100-continue&lt;/code&gt; であり、サーバーはそれに応答します。</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">このヘッダーの唯一の有効な値は &lt;code&gt;true&lt;/code&gt; （大文字と小文字を区別）です。資格情報が必要ない場合は、このヘッダーを完全に省略します（値を &lt;code&gt;false&lt;/code&gt; に設定するのではなく）。</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">異なるフィールド名を持つヘッダーフィールドが受信される順序は重要ではありません。ただし、要求のホストや応答の日付など、最初に制御データを含むヘッダーフィールドを送信することをお勧めします。これにより、実装は、メッセージをできるだけ早く処理しない場合を決定できます。後のヘッダーフィールドには条件、認証資格情報、またはリクエストの処理に影響を与える意図的に誤解を招く重複ヘッダーフィールドが含まれる可能性があるため、サーバーはリクエストヘッダーセクション全体が受信されるまでターゲットリソースにリクエストを適用してはなりません（MUST NOT）。送信者は、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されていない限り、メッセージ内で同じフィールド名を持つ複数のヘッダーフィールドを生成してはなりません[つまり、＃（values）]またはヘッダーフィールドは、よく知られている例外です（下記を参照）。受信者は、メッセージのセマンティクスを変更せずに、同じフィールド名を持つ複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合できます。結合されたフィールド値に、後続の各フィールド値を順番に追加します。コンマ。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[メッセージのセマンティクスを変更せずに、コンマで区切られた結合されたフィールド値に後続の各フィールド値を順番に追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[メッセージのセマンティクスを変更せずに、コンマで区切られた結合されたフィールド値に後続の各フィールド値を順番に追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[実際には、「Set-Cookie」ヘッダーフィールド（[実際には、「Set-Cookie」ヘッダーフィールド（[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]）は多くの場合、応答メッセージに複数回表示され、リスト構文を使用しないため、同じ名前の複数のヘッダーフィールドに対する上記の要件に違反しています。単一のフィールド値に結合できないため、受信者はヘッダーフィールドの処理中に「Set-Cookie」を特別なケースとして処理する必要があります。 （詳細について は、[ &lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ]の&lt;a href=&quot;#appendix-A.2.3&quot;&gt;付録A.2.3&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">originはリクエストが開始されたサーバーを示すURIである。これはパス情報を含まず、サーバー名のみを含む。</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">オリジンサーバはリクエストが条件付きであることを要求します。これは、クライアントがリソースの状態を GET してそれを修正し、それをサーバに PUT して戻している間に、 第三者がサーバの状態を修正してしまい、競合が発生してしまうという 'lost update' 問題を防ぐことを目的としています。</target>
        </trans-unit>
        <trans-unit id="73f93eb007ff12547887950cf639f167d2aeb94c" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">オリジンサーバはリクエストが条件付きであることを要求します。このレスポンスは、クライアントがリソースの状態を GET してそれを修正し、それをサーバに PUT して戻している間に、第三者がサーバの状態を修正してしまい、コンフリクトが発生してしまうという「ロストアップデート」の問題を防ぐことを目的としています。</target>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">マッピングされていないURLをロックするための元のWebDAVモデルは、「lock-nullリソース」を作成しました。このモデルは複雑すぎて、相互運用性と実装の問題がいくつか発見されました。マッピングされていないURLをロックするための新しいWebDAVモデル（&lt;a href=&quot;#section-7.3&quot;&gt;7.3節を&lt;/a&gt;参照））「ロックされた空のリソース」を作成します。 Lock-nullリソースは非推奨になりました。クライアントはどちらのモデルも処理できる必要があるため、このセクションでは元のモデルについて簡単に説明します。元の「ロックヌルリソース」モデルでは、実装に推奨されなくなりました。oロックヌルリソースが「見つかりません」と表示されることがありました。サーバーは、PUT、MKCOL、OPTIONS、PROPFIND、LOCK、UNLO​​CKを除くすべてのメソッドに対して404または405で応答します。ただし、ロックnullリソースは、親コレクションのメンバーとして表示されます。 o通常のリソースに変換される前にロックが解除されると、サーバーはロックヌルリソースを完全に削除します（URIはマップ解除されます）。ロックは、有効期限が切れたとき、またはロックが解除されたときだけでなく、リソースの名前が変更または移動された場合、または親コレクションの名前が変更または移動された場合も削除されます。 oサーバーは、URLへのPUT要求が成功した場合、lock-nullリソースを通常のリソースに変換します。 o URLへのMKCOL要求が成功した場合、サーバーはロックヌルリソースをコレクションに変換します（ただし、相互運用性の経験から、すべてのサーバーがこの要件を満たしているわけではありません）。 oプロパティ値はDAV：lockdiscoveryおよびDAV：supportedlockプロパティに対して定義されましたが、必ずしもDAV：getcontenttypeなどの他のプロパティに対しては定義されていません。クライアントは、古いモデルの「ロックヌルリソース」と「ロックされた空のリソース」の推奨モデルをサポートするサーバーの両方と簡単に相互運用できます。MKCOLやGETではなく、マップされていないURLへのLOCKの後にのみPUTを試行する。</target>
        </trans-unit>
        <trans-unit id="bd67e38aa52dda3f2ef7884d2b5f132dc5a16c44" translate="yes" xml:space="preserve">
          <source>The original header name &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="translated">元のヘッダー名の&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;は、「referrer」という単語のスペルミスです。 &lt;code&gt;Referrer-Policy&lt;/code&gt; ヘッダには、このスペルミスを共有しません。</target>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">HTTPの元のモデル、およびHTTP / 1.0のデフォルトのモデルは、&lt;em&gt;短期間の接続&lt;/em&gt;です。各HTTP要求は独自の接続で完了します。つまり、各HTTPリクエストの前にTCPハンドシェイクが発生し、これらはシリアル化されます。</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTPヘッダーで指定された元のポリシー。</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTPヘッダーで指定された元のポリシー。</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">ティム・バーナーズ=リーのウェブに対する最初のビジョンは、読み取り専用のメディアではありませんでした。彼が思い描いていたのは、人々がリモートでドキュメントを追加したり移動したりできるウェブ、一種の分散ファイルシステムでした。1996年頃、HTTPがオーサリングを可能にするために拡張され、WebDAVと呼ばれる規格が作られました。これはさらに拡張されて、アドレス帳のエントリーを扱うCardDAVやカレンダーを扱うCalDAVなど、特定のアプリケーション向けに拡張されてきました。しかし、これらすべての*DAV拡張には欠陥がありました。それは、使用するためにはサーバ側で実装しなければならず、これが非常に複雑でした。ウェブ領域での使用は秘密にされていました。</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">ページは、ページ自体と同じ原点のフレームにのみ表示できます。仕様では、このオプションをトップレベル、親、チェーン全体のいずれに適用するかを決定するのはブラウザベンダーに任されていますが、すべての祖先が同じオリジンにない限り、このオプションはあまり有用ではないと主張されています（&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;バグを&lt;/a&gt;参照）725490）。サポートの詳細については、&lt;a href=&quot;#Browser_compatibility&quot;&gt;ブラウザの互換性&lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">ページは、指定された原点のフレームにのみ表示できます。Firefoxでも、 &lt;code&gt;sameorigin&lt;/code&gt; と同じ問題が発生することに注意してください。フレームの祖先が同じオリジンにあるかどうかを確認するためのチェックは行われません。</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">フレーム内にページを表示しようとしているサイトに関わらず、フレーム内にページを表示することはできません。</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">パラメータ「filename」と「filename *」の違いは、「filename *」が&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987で&lt;/a&gt;定義されているエンコーディングを使用することだけです。「filename」と「filename *」の両方が1つのヘッダーフィールド値に存在する場合、「filename」よりも「filename *」の方が優先されます。</target>
        </trans-unit>
        <trans-unit id="acecd71c2fad3b28645f1a60d768a752cf9279b0" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; differ only in that &lt;code&gt;filename*&lt;/code&gt; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; are present in a single header field value, &lt;code&gt;filename*&lt;/code&gt; is preferred over &lt;code&gt;filename&lt;/code&gt; when both are understood.</source>
          <target state="translated">パラメータ &lt;code&gt;filename&lt;/code&gt; と &lt;code&gt;filename*&lt;/code&gt; という点でのみ異なる &lt;code&gt;filename*&lt;/code&gt; で定義されたエンコーディング使用&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987を&lt;/a&gt;。 &lt;code&gt;filename&lt;/code&gt; と &lt;code&gt;filename*&lt;/code&gt; 両方が単一のヘッダーフィールド値に存在する場合、両方が理解されると、 &lt;code&gt;filename*&lt;/code&gt; がファイル名よりも優先され &lt;code&gt;filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">フェッチするリソースのパス。たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;プロトコル&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;ドメイン&lt;/a&gt;（ここでは &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）、またはTCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;ポート&lt;/a&gt;（ここでは &lt;code&gt;80&lt;/code&gt; ）がない場合など、コンテキストから明らかな要素からリソースのURLを取り除いたもの。</target>
        </trans-unit>
        <trans-unit id="d2379dd36e7935200c9bebfe54ad165f2211a593" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here, &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here, &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">フェッチするリソースのパス。たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;プロトコル&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;ドメイン&lt;/a&gt;（ここでは、 &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）、またはTCP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;ポート&lt;/a&gt;（ここでは、 &lt;code&gt;80&lt;/code&gt; ）がない場合など、コンテキストから明らかな要素から削除されたリソースのURL 。</target>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">以前に取得したリソースを再利用することで、Web サイトやアプリケーションのパフォーマンスを大幅に向上させることができます。ウェブキャッシュはレイテンシとネットワークトラフィックを減らし、リソースの表現を表示するのに必要な時間を短縮します。HTTP キャッシングを利用することで、Web サイトの応答性が向上します。</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">ポリシーは、コンテンツ セキュリティ ポリシーを記述するポリシー ディレクティブを含む文字列です。</target>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">方針です。</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">1つ以上のリクエストヘッダーフィールドで与えられた前提条件は、サーバー上でテストされたときにfalseと評価された。この応答コードにより、クライアントは現在のリソースのメタ情報(ヘッダフィールドデータ)に前提条件を置くことができ、その結果、要求されたメソッドが意図されたもの以外のリソースに適用されることを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">コンテンツをデバイスフォームファクターにターゲティングする好ましい方法は、CSSメディアクエリを使用することです。ただし、UAスニッフィングを使用してコンテンツをデバイスのフォームファクターにターゲティングする場合は、電話のフォームファクターに&lt;strong&gt;Mobi&lt;/strong&gt;（「Mobi」を使用するOpera Mobileを含める）を探し、「Android」とデバイス間の相関関係&lt;strong&gt;は&lt;/strong&gt;想定し&lt;strong&gt;ない&lt;/strong&gt;でください。フォームファクタ。このようにして、Firefoxが他の電話/タブレットのオペレーティングシステムに同梱されている場合、またはラップトップにAndroidが使用されている場合に、コードが機能します。また、タブレットではないタッチデバイスが存在する場合があるため、「Mobi」や「Tablet」ではなく、タッチ検出を使用してタッチデバイスを検索してください。</target>
        </trans-unit>
        <trans-unit id="3f39eef261f64576ec5b25a729b1ec139f8018df" translate="yes" xml:space="preserve">
          <source>The preflight request below tells the server that we want to send a CORS &lt;code&gt;GET&lt;/code&gt; request that has the headers listed in &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;x-requested-with&lt;/code&gt;).</source>
          <target state="translated">以下のプリフライトリクエストは、私たちがCORSを送信することをサーバー伝え &lt;code&gt;GET&lt;/code&gt; に記載されているヘッダがある要求&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; の&lt;/a&gt;と &lt;code&gt;x-requested-with&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">搭乗前のリクエストでは、通常発生する可能性のあるネットワークエラーが発生していました。</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">前の例は、propfind要素に一緒に出現することが明示的に禁止された2つの要素を含んでいたため、違法でした。ただし、XMLは拡張可能な言語なので、propfindで使用するために定義されている新しい要素を想像できます。以下はPROPFINDのリクエスト本文であり、前の例と同様に、expired-props要素を理解しないサーバーによって400（Bad Request）で拒否される必要があります。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt;E：expired-props /&amp;gt; &amp;lt;/ D：propfind&amp;gt; 400（Bad Request）が返される理由を理解するために、expired-propsに慣れていないサーバーがそれを認識しているリクエスト本文を見てみましょう。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt; / D：propfind&amp;gt;サーバーは 'expired-props'要素を理解しないため、で指定されたWebDAV固有のXML処理ルールに従って &lt;a href=&quot;#section-17&quot;&gt;セクション17&lt;/a&gt;、要素が存在しないかのようにリクエストを処理する必要があります。したがって、サーバーは空のpropfindを参照します。これは、propfind要素の定義により不正です。拡張機能が追加された場合、必ずしも400（Bad Request）になるとは限らないことに注意してください。たとえば、PROPFINDの次のリクエスト本文を想像してください：&amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http：// www.example.com/standards/props / &quot;&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;E：leave-out&amp;gt; * boss * &amp;lt;/ E：leave-out&amp;gt; &amp;lt;/ D：propfind&amp;gt;前の例には、架空の要素leaveが含まれています-でる。その目的は、送信されたパターンに名前が一致するプロパティが返されないようにすることです。前の例が「leave-out」に慣れていないサーバーに送信された場合、唯一の結果は「leave-out」要素が無視され、propnameが実行されることです。</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">このリビジョンでの主な変更は、本質的に編集的なものです。メッセージング構文を抽出し、HTTPセマンティクスをコア機能、条件付きリクエスト、部分的リクエスト、キャッシング、および認証用の個別のドキュメントに分割します。要件を明確に対象とするように適合性言語が改訂され、表現とペイロード、およびリソースと表現を区別するために用語が改善されました。これは相互運用性の障害の一般的な原因であるため、URIに埋め込まれたセマンティクスがリクエストメソッドと一致しない場合は無効にするという新しい要件が追加されました。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）ペイロードが特定の識別子に関連付けられているかどうかを判断するアルゴリズムが追加されました。 （&lt;a href=&quot;#section-3.1.4.1&quot;&gt;セクション3.1.4.1&lt;/a&gt;）テキストメディアタイプ用のISO-8859-1のデフォルトの文字セットは削除されました。デフォルトは、メディアタイプの定義にあるとおりです。同様に、ISO-8859-1の特別な扱いがAccept-Charsetヘッダーフィールドから削除されました。 （&lt;a href=&quot;#section-3.1.1.3&quot;&gt;セクション3.1.1.3&lt;/a&gt;および&lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt;）Content-Locationの定義が変更され、相対的なURI参照を解決するためのベースURIに影響を与えなくなりました。これは、実装のサポートが不十分であり、コンテンツ内の相対リンクが壊れる可能性があるという望ましくない影響があるためです。交渉された資源。 （&lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;3.1.4.2）&lt;/a&gt; [ RFC7230のメソッド中立構文解析アルゴリズムと整合する]、GETの定義は緩和されているため、本文にGETの意味がない場合でも、リクエストに本文を含めることができます。 （&lt;a href=&quot;#section-4.3.1&quot;&gt;セクション4.3.1&lt;/a&gt;）サーバーはすべてのContent- *ヘッダーフィールドを処理する必要がなくなり、Content-Rangeの使用はPUTリクエストで明示的に禁止されました。 （&lt;a href=&quot;#section-4.3.4&quot;&gt;セクション4.3.4&lt;/a&gt;）CONNECTメソッドの定義は[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]からこの仕様に移動されました。 （&lt;a href=&quot;#section-4.3.6&quot;&gt;セクション4.3.6&lt;/a&gt;）OPTIONSおよびTRACEリクエストメソッドは安全であると定義されています。 （&lt;a href=&quot;#section-4.3.7&quot;&gt;セクション4.3.7&lt;/a&gt;および&lt;a href=&quot;#section-4.3.8&quot;&gt;セクション4.3.8&lt;/a&gt;）Expectヘッダーフィールドの拡張メカニズムは、広く展開されている壊れた実装のために削除されました。 （&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）Max-Forwardsヘッダーフィールドは、OPTIONSおよびTRACEメソッドに制限されています。以前は、拡張メソッドもそれを使用できました。 （&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）「about：blank」URIは、参照URIが適用されない場合のRefererヘッダーフィールドの値として提案されており、Refererフィールドが送信されていないか削除されている他の場合と区別されます。 （&lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt;）次のステータスコードがキャッシュ可能になりました（つまり、明示的な鮮度情報がなくても、キャッシュに保存して再利用できます）：204、404、405、414、501。（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）201（ Created）複数のリソースが作成された可能性を考慮して、ステータスの説明が変更されました。 （&lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt;）203（非信頼情報）の定義は、ペイロード変換のケースも含むように拡張されました。 （&lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt;）自動的にリダイレクトしても安全なリクエストメソッドのセットは閉じられなくなりました。ユーザーエージェントは、リクエストメソッドのセマンティクスに基づいてその決定を行うことができます。リダイレクトステータスコード301、302、および307には、応答ペイロードとユーザーインタラクションに関する規範的な要件がなくなりました。 （&lt;a href=&quot;#section-6.4&quot;&gt;6.4項&lt;/a&gt;）ステータスコード301および302が変更され、ユーザーエージェントがメソッドをPOSTからGETに書き換えることができるようになりました。 （セクション&lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;および&lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;）303（その他を参照）ステータスコードの説明が変更され、明示的な鮮度情報が指定された場合にキャッシュできるようになり、GETへの303応答に特定の定義が追加されました。 （&lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt;）305（プロキシの使用）ステータスコードは、プロキシのインバンド構成に関するセキュリティ上の懸念により廃止されました。 （&lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5項&lt;/a&gt;）400（Bad Request）ステータスコードが緩和され、構文エラーに限定されなくなりました。 （&lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt;）426（アップグレードが必要）ステータスコードが[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] から組み込まれました。 （&lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt;）HTTP-dateおよびDateヘッダーフィールドの要件のターゲットは、日付を送信するすべてのシステムではなく、日付を生成するシステムに削減されました。 （&lt;a href=&quot;#section-7.1.1&quot;&gt;セクション7.1.1&lt;/a&gt;）Locationヘッダーフィールドの構文が変更され、相対参照やフラグメントを含むすべてのURI参照が許可されるようになり、フラグメントの使用が適切でない場合の明確化も行われました。 （&lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt;）Allowが応答ヘッダーフィールドとして再分類され、PUTリクエストでそれを指定するオプションが削除されました。許可の内容に関する要件が緩和されました。これに対応して、クライアントは常にその値を信頼する必要はありません。 （&lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt;）メソッドレジストリが定義されました。 （&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;）ステータスコードレジストリはこの仕様で再定義されました。以前は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]のセクション7.1で&lt;/a&gt;定義されていました。（&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;）コンテンツコーディングの登録が変更され、IETFレビューが必要になりました。（&lt;a href=&quot;#section-8.4&quot;&gt;8.4節&lt;/a&gt;）Content-Dispositionヘッダーフィールドは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ]で定義されているため、削除された。Content-MD5ヘッダーフィールドは、部分的な応答に関して一貫して実装されていなかったため、削除されました。</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">HTTPヘッダーと &lt;code&gt;allow&lt;/code&gt; 属性の主な違いは、許可属性はiframe内の機能のみを制御することです。ヘッダーは、応答の機能とページ内の埋め込みコンテンツを制御します。</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">エンティティタグの背後にある原理は、適切なキャッシュ検証メカニズムを選択するのに十分なリソースのセマンティクスを知っているのはサービス作者だけであり、byte-equality よりも複雑なバリデータ比較関数の仕様はワームの道を開くことになります。したがって、他のヘッダの比較 (HTTP/1.0 との互換性のための Last-Modified を除く)はキャッシュエントリを検証する目的では決して使用されません。</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">エンティティタグの背後にある原則は、リソースの実装を知っているのはサービス作成者だけであり、そのリソースに対して最も正確で効率的な検証メカニズムを選択できること、そしてそのようなメカニズムは単純なオクテットのシーケンスにマッピングして簡単に比較できることです。 。値は不透明であるため、クライアントが各エンティティタグの構成方法を認識する必要はありません。たとえば、すべての変更に適用された実装固有のバージョニングを持つリソースは、おそらく内部ネゴシエーション番号を使用し、コンテンツネゴシエーションの差異識別子と組み合わせて、表現を正確に区別することができます。他の実装では、表現コンテンツの衝突に強いハッシュ、さまざまなファイル属性の組み合わせ、または、1秒未満の解像度を持つ変更タイムスタンプ。エンティティタグは条件付きリクエストで使用され、キャッシュの新しさを評価するため、オリジンサーバーは変更の検出を合理的かつ一貫して決定できる任意の選択された表現のETagを送信する必要があります（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]）は、HTTPネットワークトラフィックの大幅な削減につながる可能性があり、サービスのスケーラビリティと信頼性を向上させる重要な要素となります。</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">原理は単純ですが、1つの潜在的な問題があります:ダウンロードしたリソースが両方のダウンロードの間に変更されている場合、得られた範囲はリソースの2つの異なるバージョンに対応し、最終的なドキュメントが破損してしまいます。</target>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">使用されるプロトコル。通常は HTTP プロトコルまたはそのセキュアバージョンである HTTPS です。</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">HTTP キャッシュの目的は、将来のリクエストに応答する際に使用するために、 リクエストに応答して受け取った情報を保存することです。多くの場合、キャッシュは単にレスポンスの適切な部分を要求元に返します。しかし、キャッシュが以前のレスポンスに基づいてキャッシュエントリを保持している場合、キャッシュエントリに保持されているものと新しいレスポンスの一部を組み合わせなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">100（続行）ステータス（&lt;a href=&quot;#section-10.1.1&quot;&gt;セクション10.1.1を&lt;/a&gt;参照）の目的は、要求本文を含む要求メッセージを送信しているクライアントが、元のサーバーが要求を受け入れる用意があるかどうかを判断できるようにすることです（要求ヘッダーに基づく）。クライアントがリクエスト本文を送信する前。場合によっては、サーバーが本文を見ずにメッセージを拒否する場合、クライアントが本文を送信することが不適切または非効率的である可能性があります。 HTTP / 1.1クライアントの要件：-クライアントが100（Continue）応答を待ってからリクエストボディを送信する場合、「100-continue」の期待値を持つExpectリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt;）を送信する必要があります。 -クライアントはExpectリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;）リクエストボディを送信するつもりがない場合は、「100-continue」の期待。古い実装が存在するため、このプロトコルでは、クライアントが417（期待失敗）ステータスまたは100（続行）ステータスを受信せずに「期待：100-続行」を送信するあいまいな状況が許可されます。したがって、クライアントがこのヘッダーフィールドを（おそらくプロキシ経由で）オリジンサーバーに送信すると、100（Continue）ステータスを一度も確認したことがない場合、クライアントはリクエスト本文を送信する前に無期限に待機してはなりません（SHOULD NOT）。 HTTP / 1.1オリジンサーバーの要件：-「100-継続」の期待値を持つExpect要求ヘッダーフィールドを含む要求を受信すると、オリジンサーバーは100（Continue）ステータスで応答して入力ストリームからの読み取りを続けるか、または最終ステータスコードで応答する必要があります。オリジンサーバーは、100（Continue）応答を送信する前にリクエストボディを待機してはなりません（MUST NOT）。最終ステータスコードで応答する場合は、トランスポート接続を閉じるか、残りのリクエストを読み取って破棄してもよい（MAY）。最終ステータスコードを返す場合は、要求されたメソッドを実行してはなりません。 -リクエストメッセージに「100-continue」の期待値を持つExpectリクエストヘッダーフィールドが含まれていない場合、オリジンサーバーは100（Continue）レスポンスを送信すべきではなく、そのようなリクエストが来た場合は100（Continue）レスポンスを送信してはならない（MUST NOT） HTTP / 1.0（またはそれ以前）のクライアントから。このルールには例外があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;、サーバーは、HTTP / 1.1 PUTまたはPOSTリクエストへの応答として100（Continue）ステータスを送信することができます。このリクエストには、「100- continue」の期待を持つExpectリクエストヘッダーフィールドが含まれていません。この例外は、100（続行）ステータスの宣言されていない待機に関連するクライアント処理遅延を最小限に抑えることを目的としており、HTTP / 1.1リクエストにのみ適用され、他のHTTPバージョン値を持つリクエストには適用されません。 -オリジンサーバーは、対応するリクエストのリクエストボディの一部またはすべてをすでに受信している場合、100（Continue）レスポンスを省略してもよい（MAY）。 -100（Continue）応答を送信するオリジンサーバーは、リクエストボディが受信されて処理されると、最終的に最終ステータスコードを送信する必要があります。トランスポート接続が途中で終了しない限り。 -「100-continue」の期待値を持つExpectリクエストヘッダーフィールドを含まないリクエストをオリジンサーバーが受け取った場合、リクエストにはリクエストボディが含まれ、サーバーはリクエストボディ全体を読み取る前に最終ステータスコードで応答します。トランスポート接続の場合、サーバーは、リクエスト全体を読み取るまで、またはクライアントが接続を閉じるまで、トランスポート接続を閉じないでください。そうしないと、クライアントが応答メッセージを確実に受信できない可能性があります。ただし、この要件は、サーバーがサービス拒否攻撃からサーバーを防御したり、ひどく壊れたクライアント実装からサーバーを防御したりすることを妨げるものではありません。HTTP / 1.1プロキシの要件：-プロキシがExpectリクエストヘッダーフィールドに「100-continue」の期待値を含むリクエストを受信し、プロキシがネクストホップサーバーがHTTP / 1.1以上に準拠していることを知っている場合、またはネクストホップサーバーのHTTPバージョンがわからない場合は、Expectヘッダーフィールドを含め、リクエストを転送する必要があります。 -ネクストホップサーバーのバージョンがHTTP / 1.0以下であることをプロキシが認識している場合、プロキシはリクエストを転送してはならず（MUST）、417（期待失敗）ステータスで応答する必要があります。 -プロキシは、最近参照されたネクストホップサーバーから受信したHTTPバージョン番号を記録するキャッシュを維持する必要があります（SHOULD）。-リクエストメッセージがHTTP / 1.0（またはそれ以前）のクライアントから受信され、「100-continue」の期待値を持つExpectリクエストヘッダーフィールドが含まれていない場合、プロキシは100（Continue）応答を転送してはなりません（MUST NOT）。この要件は、1xx応答の転送に関する一般的なルールを上書きします（参照&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">引用符で囲まれた文字列は、Base64でエンコードされた&lt;em&gt;サブジェクトの公開キー情報&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）のフィンガープリントです。異なる公開鍵に複数のピンを指定することが可能です。一部のブラウザでは、将来、SHA-256以外のハッシュアルゴリズムが許可される可能性があります。証明書またはキーファイルからこの情報を抽出する方法については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">引用符で囲まれた文字列は、Base64でエンコードされたサブジェクトの公開キー情報（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）のフィンガープリントです。異なる公開鍵に複数のピンを指定することが可能です。一部のブラウザでは、将来、SHA-256以外のハッシュアルゴリズムが許可される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e7090e603b1c8468593db08ace13cc460b311c3" translate="yes" xml:space="preserve">
          <source>The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number.</source>
          <target state="translated">オプションのホストオーバーライド、コロン、必須のポート番号で構成される代替権限を指定する引用符で囲まれた文字列。</target>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">リクエストの &lt;code&gt;Range&lt;/code&gt; ヘッダーフィールドで指定された範囲は満たされません。範囲がターゲットURIのデータのサイズ外である可能性があります。</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">推奨されているのは、データをできるだけ圧縮することであり、したがってこのフィールドを使用することですが、jpeg画像のようないくつかのタイプのリソースは、すでに圧縮されています。追加の圧縮を使用してもペイロードのサイズが小さくならず、ペイロードが長くなることもあります。</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">Geckoベースのブラウザーのスニッフィングの推奨方法（機能検出を使用する代わりにブラウザーエンジン&lt;em&gt;を&lt;/em&gt;スニッフィングする必要&lt;em&gt;がある&lt;/em&gt;場合）は、「 &lt;code&gt;Gecko&lt;/code&gt; 」および「 &lt;code&gt;rv:&lt;/code&gt; 」文字列の存在による &lt;code&gt;like Gecko&lt;/code&gt; &quot;トークン。</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">違反が発生した文書の参照元。</target>
        </trans-unit>
        <trans-unit id="060f5108fa86aba94bed9d14146f77e7e9a8271d" translate="yes" xml:space="preserve">
          <source>The referring resource is a local &quot;file&quot; or &quot;data&quot; URI.</source>
          <target state="translated">参照するリソースは、ローカルの &quot;ファイル &quot;または &quot;データ &quot;URIです。</target>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">レジストリには、以下の登録が含まれています。+ ----------- + --------------------------- ------- + --------------- + |警告コード|短い説明|リファレンス| + ----------- + ---------------------------------- +- ------------- + | 110 |応答が古くなっています| &lt;a href=&quot;#section-5.5.1&quot;&gt;セクション5.5.1&lt;/a&gt; | | 111 |再検証に失敗しました| &lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt; | | 112 |切断された操作| &lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt; | | 113 |ヒューリスティックな有効期限| &lt;a href=&quot;#section-5.5.4&quot;&gt;セクション5.5.4&lt;/a&gt; | | 199 |その他の警告| &lt;a href=&quot;#section-5.5.5&quot;&gt;セクション5.5.5&lt;/a&gt; | | 214 |適用された変換| &lt;a href=&quot;#section-5.5.6&quot;&gt;セクション5.5.6&lt;/a&gt;| | 299 |その他の永続的な警告| &lt;a href=&quot;#section-5.5.7&quot;&gt;セクション5.5.7&lt;/a&gt; | + ----------- + ---------------------------------- +- ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">レジストリには以下の登録が入力されています：+ ------------------------ + -------------- -------------------- + |キャッシュディレクティブ|リファレンス| + ------------------------ + ------------------------ ---------- + |最大年齢| &lt;a href=&quot;#section-5.2.1.1&quot;&gt;セクション5.2.1.1&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.8&quot;&gt;セクション5.2.2.8&lt;/a&gt; | | max-stale | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;セクション5.2.1.2&lt;/a&gt; | | min-fresh | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;セクション5.2.1.3&lt;/a&gt; | |再検証が必要| &lt;a href=&quot;#section-5.2.2.1&quot;&gt;セクション5.2.2.1&lt;/a&gt; | |キャッシュなし| &lt;a href=&quot;#section-5.2.1.4&quot;&gt;セクション5.2.1.4&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.2&quot;&gt;セクション5.2.2.2&lt;/a&gt; | |ノーストア| &lt;a href=&quot;#section-5.2.1.5&quot;&gt;セクション5.2.1.5&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.3&quot;&gt;セクション5.2.2.3&lt;/a&gt; | | 変換しない| &lt;a href=&quot;#section-5.2.1.6&quot;&gt;セクション5.2.1.6&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.4&quot;&gt;セクション5.2.2.4&lt;/a&gt; | | only-if-cached | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;セクション5.2.1.7&lt;/a&gt; | | プライベート| &lt;a href=&quot;#section-5.2.2.6&quot;&gt;セクション5.2.2.6&lt;/a&gt; | | プロキシ再検証| &lt;a href=&quot;#section-5.2.2.7&quot;&gt;セクション5.2.2.7&lt;/a&gt; | | 公開| &lt;a href=&quot;#section-5.2.2.5&quot;&gt;セクション5.2.2.5&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;セクション5.2.2.9&lt;/a&gt; | | 古くなったエラー| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861]、セクション4&lt;/a&gt; | | 古くなった再検証| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861]、セクション3&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgradeヘッダーフィールドに&lt;/a&gt;関連するRFCドキュメントはRFC 7230のセクション6.7です。標準は、現在のクライアント、サーバー、トランスポートプロトコル接続で別のプロトコルにアップグレードまたは変更するためのルールを確立します。たとえば、サーバーがUpgradeヘッダーフィールドを確認して実装することを決定した場合、このヘッダー標準により、クライアントはHTTP 1.1からHTTP 2.0に変更できます。どちらの当事者も、Upgradeヘッダーフィールドで指定された条件に同意する必要はありません。クライアントとサーバーの両方のヘッダーで使用できます。 Upgradeヘッダーフィールドが指定されている場合、送信者はアップグレードオプションを指定してConnectionヘッダーフィールドも送信する必要があります。接続ヘッダーフィールドの&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;詳細については、前述のRFCのセクション6.1を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">残りの応答ヘッダーフィールドは、後のリクエストで潜在的に使用するためのターゲットリソースに関する詳細情報を提供します。 + ------------------- + -------------------------- + |ヘッダーフィールド名|で定義されています... | + ------------------- + -------------------------- + | Accept-Ranges | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;[RFC7233]のセクション2.3&lt;/a&gt; | |許可| &lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt; | |サーバー| &lt;a href=&quot;#section-7.4.2&quot;&gt;セクション7.4.2&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">レポートJSONオブジェクトには、以下のデータが含まれています。</target>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">HTTPメッセージに関連付けられた表現データは、メッセージのペイロードボディとして提供されるか、メッセージセマンティクスと有効なリクエストURIによって参照される。表現データは、表現メタデータヘッダフィールドによって定義されるフォーマットとエンコーディングである。表現データのデータ型は、ヘッダーフィールドContent-TypeとContent-Encodingで決まる。これらは2層の順序付きエンコーディングモデルを定義する。 representation-data :=Content-Encoding(Content-Type(bits))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">リソースの現在の状態との競合のためにリクエストを完了できませんでした。このコードは、ユーザーがコンフリクトを解決してリクエストを再送できるかもしれない と期待される状況でのみ許可される。応答ボディは、ユーザーが競合の原因を認識するのに十分な情報を含むべきである [SHOULD]。理想的には、応答ボディは、ユーザーまたはユーザーエージェントが 問題を解決するために十分な情報を含むべきである。コンフリクトはPUTリクエストに対する応答で最も起こりやすい。例えば、バージョニングが使用されていて、PUTされるエンティティが以前の(サードパーティの)リクエストで行われたものと競合するリソースへの変更を含んでいた場合、サーバーはリクエストを完了できないことを示すために409応答を使用するかもしれない。この場合、応答の実体は、応答のContent-Typeで定義された形式で、 2つのバージョン間の相違点のリストを含む可能性が高い。</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">リクエストは構文が正しくないためにサーバーに理解されなかった。クライアントは修正せずにリクエストを繰り返すべきではない[SHOULD NOT]。</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">前回のリクエストが失敗したため、リクエストに失敗しました。</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">リクエストは処理のために受理されたが、処理は完了していない。実際に処理が行われたときには拒否されるかもしれないので、そのリクエストは最終的に処理されるかもしれないし、そうでないかもしれない。このような非同期操作からステータスコードを再送する機能はない。202応答は意図的に非committalである。その目的は、プロセスが完了するまでサーバーへのユーザーエージェントの 接続が持続することを要求せずに、サーバーが他のプロセス(おそらく1日に1回しか実行され ないバッチ指向のプロセス)へのリクエストを受け付けることを可能にすることである。この応答で返される実体は、リクエストの現在のステータスの表示と、 ステータスモニターへのポインタ、またはユーザーがいつリクエストが 満たされると予想できるかの推定値を含むべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">リクエストが満たされ、新しいリソースが作成されました。新しく作成されたリソースは、応答のエンティティで返されるURIで参照できます。リソースの最も具体的なURIは、Locationヘッダーフィールドで指定されます。応答には、ユーザーまたはユーザーエージェントが最も適切なものを選択できるリソースの特性と場所のリストを含むエンティティが含まれる必要があります（SHOULD）。エンティティ形式は、Content-Typeヘッダーフィールドで指定されたメディアタイプによって指定されます。オリジンサーバーは、201ステータスコードを返す前にリソースを作成する必要があります。アクションをすぐに実行できない場合、サーバーは代わりに202（Accepted）応答で応答する必要があります（SHOULD）。201応答には、作成されたばかりの要求されたバリアントのエンティティタグの現在の値を示すETag応答ヘッダーフィールドが含まれる場合があります。&lt;a href=&quot;#section-14.19&quot;&gt;セクション14.19&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">リクエストは受信されたが、まだ処理されていない。これは非コミッタルであり、リクエストの処理結果を示す非同期応答を後から HTTP で送る方法がないことを意味します。これは、別のプロセスやサーバがリクエストを処理する場合や、 バッチ処理の場合に意図されています。</target>
        </trans-unit>
        <trans-unit id="585082aac4586ccf5aebfeb0d6987e1358cca064" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is noncommittal, since there is no way in HTTP to later send an asynchronous response indicating the outcome of the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">リクエストは受信されたが、まだ処理されていない。HTTPではリクエストの結果を示す非同期応答を後で送る方法がないので、これは非コミッタルです。これは、別のプロセスやサーバがリクエストを処理する場合や、 バッチ処理の場合を想定しています。</target>
        </trans-unit>
        <trans-unit id="7b875d4acb8b65c4bd9ffe04a6f98e27644fbcab" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. (There is no standardized way of choosing one of the responses, but HTML links to the possibilities are recommended so the user can pick.)</source>
          <target state="translated">リクエストは複数の可能な応答を持っています。ユーザーエージェントかユーザーはそのうちの一つを選択しなければなりません。(レスポンスの一つを選ぶ標準的な方法はありませんが、ユーザーが選べるように可能性のあるものへのHTMLリンクが推奨されています)。</target>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">リクエストは複数の可能な応答を持っています。ユーザーエージェントかユーザーはそれらのうちの一つを選択しなければなりません。応答のうちの一つを選択する標準化された方法はありません。</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">リクエストが成功し、その結果として新しいリソースが作成されました。これは通常、POST リクエストの後やいくつかのPUT リクエストの後に送られるレスポンスです。</target>
        </trans-unit>
        <trans-unit id="135d9441de12a3afffc64aee3e0646575c72a5dc" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result. This is typically the response sent after &lt;code&gt;POST&lt;/code&gt; requests, or some &lt;code&gt;PUT&lt;/code&gt; requests.</source>
          <target state="translated">リクエストは成功し、その結果、新しいリソースが作成されました。これは通常、 &lt;code&gt;POST&lt;/code&gt; 要求または一部の &lt;code&gt;PUT&lt;/code&gt; 要求の後に送信される応答です。</target>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">リクエストは成功しました。レスポンスで返される情報は、例えば、リクエストで使用された方法に依存します。GETはリクエストされたリソースに対応するエンティティをレスポンスで送信します。 HEADはリクエストされたリソースに対応するエンティティヘッダフィールドをメッセージボディなしでレスポンスで送信します。POSTはアクションの結果を記述した、またはそれを含むエンティティを送信します。</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">リクエストは成功しました。成功の意味はHTTPメソッドによって異なります。</target>
        </trans-unit>
        <trans-unit id="9bd73430623220d33656725bff084d01a5160eeb" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of the success depends on the HTTP method:</source>
          <target state="translated">リクエストは成功しました。成功の意味はHTTPメソッドに依存します。</target>
        </trans-unit>
        <trans-unit id="03ea2a026f2515cb348f3705c18e0640e28ad870" translate="yes" xml:space="preserve">
          <source>The request header of note is &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, which shows that the invocation is coming from &lt;code&gt;https://foo.example&lt;/code&gt;.</source>
          <target state="translated">注意のリクエストヘッダーは&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; です&lt;/a&gt;。これは、呼び出しが &lt;code&gt;https://foo.example&lt;/code&gt; からのものであることを示しています。</target>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">リクエストは以下のようになります(あまり興味のないヘッダはここでは省略します)。</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">リクエストメソッドと本文は変更されませんが、&lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;は誤って&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドに変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">要求メソッドはサーバーによって認識されていますが、無効になっているため使用できません。たとえば、APIはリソースの削除を禁止する場合があります。2つの必須メソッド、 &lt;code&gt;GET&lt;/code&gt; と &lt;code&gt;HEAD&lt;/code&gt; 無効にしてはならず、このエラーコードを返さないでください。</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">リクエストメソッドはサーバーでサポートされていないため、処理できません。サーバーがサポートする必要がある（したがって、このコードを返してはならない）唯一のメソッドは、 &lt;code&gt;GET&lt;/code&gt; および &lt;code&gt;HEAD&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">リクエストメソッドトークンは、リクエストセマンティクスの主要なソースです。これは、クライアントがこの要求を行った目的と、成功した結果としてクライアントが期待することを示しています。リクエストメソッドのセマンティクスは、リクエストに存在する場合、一部のヘッダーフィールドのセマンティクスによってさらに特殊化される場合があります（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;。ターゲットリソースによって許可されるメソッドのセットは、許可ヘッダーフィールドにリストできます（&lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt;&lt;a href=&quot;#section-5&quot;&gt;&lt;/a&gt;追加のセマンティクスがメソッドと競合しない場合場合セクション5）。たとえば、クライアントは条件付き要求ヘッダーフィールド（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）を送信して、要求されたアクションをターゲットリソースの現在の状態を条件とすることができます（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]）。 method = token HTTPは当初、分散オブジェクトシステムへのインターフェースとして使用できるように設計されました。リクエストメソッドは、識別されたオブジェクトで定義されたメソッドを呼び出すと、セマンティクスが適用されるのとほぼ同じ方法で、ターゲットリソースにセマンティクスを適用するものと想定されていました。メソッドトークンは、大文字と小文字を区別するメソッド名を持つオブジェクトベースのシステムへのゲートウェイとして使用される可能性があるため、大文字と小文字を区別します。分散オブジェクトとは異なり、HTTPの標準化されたリクエストメソッドはリソース固有ではありません。統一されたインターフェースにより、ネットワークベースのシステムでの可視性と再利用性が向上するためです[ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]。いったん定義されると、標準化されたメソッドは、リソースに適用されるときに同じセマンティクスを持つ必要がありますが、各リソースは、それらのセマンティクスが実装または許可されるかどうかを自分自身で決定します。この仕様では、次の表に概要を示すように、HTTPで一般的に使用される標準化されたメソッドをいくつか定義しています。慣例により、標準化されたメソッドはすべて大文字のUS-ASCII文字で定義されます。 + --------- + --------------------------------------- ---------- + ------- + |メソッド|説明| Sec。 | + --------- + --------------------------------------- ---------- + ------- + | GET |ターゲットの現在の表現を転送する| 4.3.1 | | |資源。 | | |ヘッド| GETと同じステータスラインのみを転送する| 4.3.2 | | |およびヘッダーセクション。 | | |投稿| |でリソース固有の処理を実行します4.3.3 | | |ペイロードをリクエストします。 | | | PUT | |の現在の表現をすべて置き換えます4.3.4 | | |リクエストペイロードを持つターゲットリソース。 | | |削除| |の現在の表現をすべて削除します4.3.5 | | |ターゲットリソース。 | | |接続| |で識別されるサーバーへのトンネルを確立します。 4.3.6 | | |ターゲットリソース。 | | |オプション| |の通信オプションについて説明してください4.3.7 | | |ターゲットリソース。| | | TRACE |パスに沿ってメッセージループバックテストを実行する| 4.3.8 | | |ターゲットリソースに。 | | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。| | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。| | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。）。ただし、許可されたメソッドのセットは動的に変更できます。認識されていないか、配信元サーバーで実装されていないリクエストメソッドを受信すると、配信元サーバーは501（未実装）ステータスコードで応答する必要があります（SHOULD）。オリジンサーバーによって認識されているがターゲットリソースに対して許可されていないリクエストメソッドが受信されると、オリジンサーバーは405（Method Not Allowed）ステータスコードで応答する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">リクエストにはユーザー認証が必要です。応答には、要求されたリソースに適用可能なチャレンジを含むWWW-Authenticateヘッダーフィールド（&lt;a href=&quot;#section-14.47&quot;&gt;セクション14.47&lt;/a&gt;）を含める必要があります。クライアントは適切なAuthorizationヘッダーフィールド（&lt;a href=&quot;#section-14.8&quot;&gt;セクション14.8&lt;/a&gt;）。要求にすでに認証資格情報が含まれている場合、401応答は、それらの資格情報の認証が拒否されたことを示します。 401応答に前の応答と同じチャレンジが含まれていて、ユーザーエージェントが少なくとも1回は認証を試みている場合、エンティティには関連する診断情報が含まれている可能性があるため、ユーザーには応答で指定されたエンティティを提示する必要があります（SHOULD）。 HTTPアクセス認証については、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で説明しています。</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">TLS へのリクエストは、オプションまたは強制的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">リクエストは応答を生成できないサーバーに向けられた。これは、リクエストURIに含まれるスキームと権限の組み合わせに対する 応答を生成するように構成されていないサーバーによって送られる可能性がある。</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">リクエストは 'https://example.com/foo' にリダイレクトされましたが、プリフライトを必要とするクロスオリジンリクエストでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">リクエストはよくできていたが、セマンティックエラーのためにそれに従うことができなかった。</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">リクエストヘッダーフィールドを使用すると、クライアントはリクエストとクライアント自体に関する追加情報をサーバーに渡すことができます。これらのフィールドは要求修飾子として機能し、セマンティクスはプログラミング言語のメソッド呼び出しのパラメーターと同等です。 request-header = Accept; &lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt; | Accept-Charset; &lt;a href=&quot;#section-14.2&quot;&gt;セクション14.2&lt;/a&gt; | Accept-Encoding; &lt;a href=&quot;#section-14.3&quot;&gt;セクション14.3&lt;/a&gt; | Accept-Language; &lt;a href=&quot;#section-14.4&quot;&gt;セクション14.4&lt;/a&gt; |認可; &lt;a href=&quot;#section-14.8&quot;&gt;セクション14.8&lt;/a&gt; |期待する; &lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt; |から; &lt;a href=&quot;#section-14.22&quot;&gt;セクション14.22&lt;/a&gt; |ホスト ; &lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt; | If-Match; &lt;a href=&quot;#section-14.24&quot;&gt;セクション14.24&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;セクション14.25&lt;/a&gt; | If-None-Match; &lt;a href=&quot;#section-14.26&quot;&gt;セクション14.26&lt;/a&gt; | If-Range; &lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt; | If-Unmodified-Since; &lt;a href=&quot;#section-14.28&quot;&gt;セクション14.28&lt;/a&gt; | Max-Forwards; &lt;a href=&quot;#section-14.31&quot;&gt;セクション14.31&lt;/a&gt; |プロキシ承認; &lt;a href=&quot;#section-14.34&quot;&gt;セクション14.34&lt;/a&gt; |範囲 ; &lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt; |リファラー; &lt;a href=&quot;#section-14.36&quot;&gt;セクション14.36&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;セクション14.39&lt;/a&gt; |ユーザーエージェント ; &lt;a href=&quot;#section-14.43&quot;&gt;セクション14.43&lt;/a&gt; リクエストヘッダーフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての関係者がリクエストヘッダーフィールドであると認識した場合、新しいヘッダーフィールドまたは実験的なヘッダーフィールドにリクエストヘッダーフィールドのセマンティクスを与えることができます。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">要求されたリソースは、Locationフィールドで指定されたプロキシを介してアクセスする必要があります。LocationフィールドはプロキシのURIを示します。受信者は、プロキシ経由でこの単一のリクエストを繰り返すことが期待されています。305応答は、オリジンサーバーによってのみ生成される必要があります。注：&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;は、305が単一の要求をリダイレクトすること、およびオリジンサーバーによってのみ生成されることを目的としていたことを明確にしていませんでした。これらの制限を守らないと、セキュリティに重大な影響があります。</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">要求されたリソースは、それぞれ固有の場所とエージェント主導のネゴシエーション情報（&lt;a href=&quot;#section-12&quot;&gt;セクション12&lt;/a&gt;）が提供されているため、ユーザー（またはユーザーエージェント）は優先表現を選択し、その要求をその場所にリダイレクトできます。 HEADリクエストでない限り、レスポンスには、ユーザーまたはユーザーエージェントが最も適切なものを選択できるリソースの特性と場所のリストを含むエンティティが含まれる必要があります（SHOULD）。エンティティの形式は、Content- Typeヘッダーフィールドで指定されたメディアタイプによって指定されます。ユーザーエージェントの形式と機能に応じて、最も適切な選択肢の選択が自動的に実行される場合があります。ただし、この仕様では、このような自動選択の標準を定義していません。サーバーが適切な表現の選択肢を持っている場合、その表現に固有のURIをLocationフィールドに含める必要があります（SHOULD）。ユーザーエージェントは、自動リダイレクトにLocationフィールドの値を使用できます。特に断らない限り、この応答はキャッシュ可能です。</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">リクエストされたリソースには新しいパーマネントURIが割り当てられ、このリソースへの将来の参照は、 返されたURIの1つを使用するべきである[SHOULD]。リンク編集機能を持つクライアントは、可能であれば、Request-URIへの参照をサーバから返された1つ以上の新しい参照に自動的に再リンクするべきである。この応答は、別段の指示がない限りキャッシュ可能である。新しいパーマネントURIは、応答のLocationフィールドで与えられるべきである [SHOULD]。リクエストメソッドがHEADでない限り、応答の実体は、新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。GETやHEAD以外のリクエストに対する応答で301ステータスコードを受け取った場合、ユーザーエージェ ントは、リクエストが発行された条件を変更するかもしれないので、 ユーザーが確認できない限り、そのリクエストを自動的にリダイレクトしては ならない[MUST NOT]。注意:301ステータスコードを受け取った後にPOSTリクエストを自動的にリダイレクトする場合、既存のHTTP/1.0ユーザエージェントの中には、それを誤ってGETリクエストに変更してしまうものがあります。</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">要求されたリソースはサーバで利用できなくなり、転送アドレスがわかりません。この状態は恒久的なものと考えられます。リンク編集機能を持つクライアントは、ユーザーの承認後にRequest-URIへの参照を削除すべきである [SHOULD]。サーバーがその状態が永続的かどうかを知らないか、または判断する機能を持たない 場合、ステータスコード404(Not Found)が代わりに使用されるべきである[SHOULD]。この応答は、別段の指示がない限りキャッシュ可能である。410 レスポンスは主に、受信者にリソースが意図的に利用できないことと、サーバの所有者がそのリソースへのリモートリンクを削除することを望むことを通知することで、ウェブメンテナンスのタスクを支援することを目的としています。このようなイベントは、期間限定のプロモーションサービスや、サーバのサイトではもはや働いていない個人が所有するリソースのために一般的です。永久に利用できないすべてのリソースを「消滅」としてマークする必要はありませんし、マークをいつまでも維持する必要もありません --それはサーバーの所有者の裁量に委ねられています。</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">リクエストされたリソースは一時的に異なるURIの下に存在する。リダイレクトは時々変更してもよい[MAY]ので、クライアントは今後のリクエ ストにRequest-URIを使い続けるべきである[SHOULD]。この応答は、Cache-ControlまたはExpiresヘッダーフィールドで示されている 場合にのみキャッシュ可能である。一時的なURIは応答中のLocationフィールドによって与えられるべきである [SHOULD]。リクエストメソッドがHEADでない限り、応答のエンティティは、多くのHTTP/1.1以前 のユーザーエージェントが307ステータスを理解していないため、新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。したがって、ノートは、ユーザーが新しいURIで元のリクエストを繰り返すために 必要な情報を含むべきである[SHOULD]。307ステータスコードがGETやHEAD以外のリクエストに応答して受け取られた場合、ユーザーエージェ ントは、リクエストが発行された条件を変更する可能性があるため、ユーザーに 確認できない限り、そのリクエストを自動的にリダイレクトしてはならない [MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">リクエストされたリソースは一時的に別のURIに存在します。リダイレクトは時々変更される可能性があるため、クライアントは今後のリクエストに引き続きRequest-URIを使用する必要があります。この応答は、Cache-ControlまたはExpiresヘッダーフィールドで示されている場合にのみキャッシュ可能です。一時URIは、応答のLocationフィールドで指定する必要があります（SHOULD）。リクエストメソッドがHEADでない限り、レスポンスのエンティティには、新しいURIへのハイパーリンクを含む短いハイパーテキストノートを含める必要があります（SHOULD）。 GETまたはHEAD以外のリクエストに応答して302ステータスコードを受信した場合、ユーザーエージェントは、ユーザーが確認できない限り、リクエストを自動的にリダイレクトしてはなりません。これにより、リクエストが発行された条件が変わる可能性があります。注：&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;は、クライアントがリダイレクトされた要求のメソッドを変更できないように指定しています。ただし、ほとんどの既存のユーザーエージェント実装は、302を303応答のように扱い、元のリクエストメソッドに関係なく、Locationフィールドの値に対してGETを実行します。ステータスコード303および307は、どのような反応がクライアントに期待されるかを明確にしたいサーバー用に追加されました。</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">クライアントとサーバーがホストヘッダーフィールドをサポートするという要件（&lt;a href=&quot;#section-5.4&quot;&gt;5.4節&lt;/a&gt;）、HTTP / 1.1リクエストから欠落している場合はエラーを報告、絶対URIを受け入れる（&lt;a href=&quot;#section-5.3&quot;&gt;5.3節）&lt;/a&gt;）は、HTTP / 1.1で定義されている最も重要な変更の1つです。古いHTTP / 1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。リクエストの対象となるサーバーを識別するための確立されたメカニズムは、そのリクエストの送信先のIPアドレス以外にありませんでした。ホストヘッダーフィールドはHTTP / 1.1の開発中に導入され、ほとんどのHTTP / 1.0ブラウザーによってすぐに実装されましたが、完全な採用を確実にするために、すべてのHTTP / 1.1要求に追加の要件が課されました。この記事の執筆時点では、ほとんどのHTTPベースのサービスは、ターゲットリクエストのHostヘッダーフィールドに依存しています。</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">クライアントとサーバーがホストリクエストヘッダーをサポートし、ホストリクエストヘッダー（&lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt;）がHTTP / 1.1リクエストにない場合はエラーを報告し、絶対URI（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;）を受け入れるという要件）は、この仕様で定義されている最も重要な変更の1つです。古いHTTP / 1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。リクエストの対象となるサーバーを識別するための確立されたメカニズムは、そのリクエストの送信先のIPアドレス以外にありませんでした。上記の変更により、古いHTTPクライアントが一般的でなくなると、インターネットは単一のIPアドレスから複数のWebサイトをサポートできるようになり、多数のIPアドレスを単一のホストに割り当てると深刻な問題が発生する大規模な運用Webサーバーが大幅に簡素化されます。 。また、インターネットは、ルートレベルのHTTP URLで特殊用途のドメイン名を使用できるようにするという唯一の目的で割り当てられたIPアドレスを回復することもできます。ウェブの成長率を考えると、すでにデプロイされているサーバーの数に応じて、HTTPのすべての実装（既存のHTTP / 1.0アプリケーションへの更新を含む）がこれらの要件を正しく実装することが非常に重要です。-クライアントとサーバーの両方がホスト要求ヘッダーをサポートする必要があります。 -HTTP / 1.1リクエストを送信するクライアントは、ホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。1つの要求でホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。1つの要求でホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">リクエストによって識別されたリソースは、リクエストで送られた acceptヘッダーに従って受け入れられないコンテンツ特性を持つ応答エンティティを生成することができるだけである。それがHEADリクエストでない限り、応答は、利用可能なエンティティ特性のリストと、ユーザーまたはユーザーエージェントが最も適切なものを選択できる場所(複数可)を含むエンティティを含むべきである[SHOULD]。エンティティの形式は、Content-Typeヘッダーフィールドで与えられたメ ディアタイプによって指定される。フォーマットとユーザーエージェントの能力に応じて、最も適切な選択の選択は自動的に実行されてもよい[MAY]。しかしながら、この仕様は、そのような自動選択のための標準を定義していない。注意:HTTP/1.1サーバは、リクエストで送られたACCEPTヘッダに従って受け入れられない応答を返すことが許されています。場合によっては、これは 406 応答を送るよりも望ましいかもしれません。ユーザエージェントは、受け入れ可能かどうかを判断するために、 受信したレスポンスのヘッダを検査することが推奨されます。応答が受け入れられない可能性がある場合、ユーザエージェントは、さらなるデータの受信を一時的に停止し、さらなるアクションの決定をユーザに問い合わせるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">アクセスされているリソースはロックされています。</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">サーバからの応答には、これらが含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">レスポンスヘッダーフィールドは、サーバがステータス行に置かれている以上の レスポンスに関する追加情報を渡すことを可能にします。これらのヘッダフィールドは、サーバについての情報、ターゲットリソースへのさらなるアクセス、または関連するリソースについての情報を与える。各レスポンスヘッダフィールドは定義された意味を持つが、一般的には、正確なセマンティクスはリクエストメソッドやレスポンスステータスコードのセマンティクスによってさらに洗練されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">レスポンスも非常にシンプルで、ファイル自体からしか構成されていませんでした。</target>
        </trans-unit>
        <trans-unit id="a187e434f07fa362732384aa76405b41edb39ff9" translate="yes" xml:space="preserve">
          <source>The response may &lt;strong&gt;not&lt;/strong&gt; be stored in &lt;em&gt;any&lt;/em&gt; cache. Note that this will not prevent a valid &lt;em&gt;pre-existing&lt;/em&gt; cached response being returned. Clients can set &lt;code&gt;max-age=0&lt;/code&gt; to also clear existing cache responses, as this forces the cache to revalidate with the server (no other directives have an effect when used with &lt;code&gt;no-store&lt;/code&gt;).</source>
          <target state="translated">応答は&lt;em&gt;どの&lt;/em&gt;キャッシュにも保存でき&lt;strong&gt;ません&lt;/strong&gt;。これは、有効な&lt;em&gt;既存の&lt;/em&gt;キャッシュされた応答が返されるのを妨げるものではないことに注意してください。クライアントは &lt;code&gt;max-age=0&lt;/code&gt; を設定して、既存のキャッシュ応答もクリアできます。これにより、キャッシュがサーバーで再検証されます（ &lt;code&gt;no-store&lt;/code&gt; で使用した場合、他のディレクティブは効果がありません）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="175c4a1ccf44338f289e8f6a8f5b206b71c5531a" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable.</source>
          <target state="translated">応答が通常キャッシュ&lt;em&gt;できない&lt;/em&gt;場合でも、応答は&lt;em&gt;任意の&lt;/em&gt;キャッシュに保存できます。</target>
        </trans-unit>
        <trans-unit id="cf2982c4aaa9bc3f78fafab7d00a3ebb08a20bc3" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable. However, the stored response MUST &lt;em&gt;always&lt;/em&gt; go through validation with the origin server first before using it, therefore, you cannot use &lt;code&gt;no-cache&lt;/code&gt; in-conjunction with &lt;code&gt;immutable&lt;/code&gt;. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="translated">応答が通常キャッシュ&lt;em&gt;できない&lt;/em&gt;場合でも、応答は&lt;em&gt;任意の&lt;/em&gt;キャッシュに保存できます。ただし、保存された応答は、使用する前に&lt;em&gt;必ず&lt;/em&gt;最初にオリジンサーバーで検証する必要があります。したがって、 &lt;code&gt;no-cache&lt;/code&gt; を &lt;code&gt;immutable&lt;/code&gt; と組み合わせて使用することはできません。 &lt;code&gt;no-store&lt;/code&gt; &lt;em&gt;このディレクティブは、キャッシュが応答を保存するのを防ぐのに効果的ではありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaa0d406c5950086dcf14084183c400a270e03bf" translate="yes" xml:space="preserve">
          <source>The response may be stored only by a &lt;em&gt;browser's&lt;/em&gt; cache, even if the response is normally non-cacheable. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="translated">応答が通常キャッシュできない場合でも、応答は&lt;em&gt;ブラウザの&lt;/em&gt;キャッシュによってのみ保存される場合があります。 &lt;code&gt;no-store&lt;/code&gt; &lt;em&gt;このディレクティブは、キャッシュが応答を保存するのを防ぐのに効果的ではありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18efe3bb77387fcf6dc94b18b57204fcd81a30a1" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header that holds the allowed methods:</source>
          <target state="translated">応答には、&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;れたメソッドを保持するAllowヘッダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">応答には、&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;れたメソッドを含むAllowヘッダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答に必要な&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;ヘッダーがありません。これは、現在のオリジン内で動作するコンテンツがリソースにアクセスできるかどうかを判断するために使用されます。</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">サーバーから送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答には、少なくとも1つの無効なヘッダー名を含む&lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;ヘッダーが含まれています。</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">サーバーから送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答には、少なくとも1つの無効なメソッド名を含む&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;ヘッダーが含まれています。</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">リクエストに対する応答は別のURIで見つけることができ、そのリソース上でGETメソッド を使用して取得するべきである[SHOULD]。このメソッドは主に、ユーザーエージェントを選択されたリソースにリダイレクト するためのPOST動作スクリプトの出力を可能にするために存在する。新しいURIは、最初にリクエストされたリソースの代替参照ではない。303応答はキャッシュされてはならない[MUST NOT]が、2つ目の(リダイレクトされた)リクエ ストに対する応答はキャッシュ可能かもしれない。異なるURIは応答のLocationフィールドで与えられるべきである[SHOULD]。リクエストメソッドがHEADでない限り、応答の実体は新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。注意:多くのHTTP/1.1以前のユーザーエージェントは303ステータスを理解していない。そのようなクライアントとの相互運用性が懸念される場合、代わりに 302ステータスコードを使用してもよい。</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">応答ヘッダーフィールドを使用すると、サーバーはステータスラインに配置できない応答に関する追加情報を渡すことができます。これらのヘッダーフィールドは、サーバーに関する情報と、Request-URIで識別されるリソースへの以降のアクセスに関する情報を提供します。 response-header = Accept-Ranges; &lt;a href=&quot;#section-14.5&quot;&gt;セクション14.5&lt;/a&gt; |年齢; &lt;a href=&quot;#section-14.6&quot;&gt;セクション14.6&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;セクション14.19&lt;/a&gt; |場所; &lt;a href=&quot;#section-14.30&quot;&gt;セクション14.30&lt;/a&gt; |プロキシ認証; &lt;a href=&quot;#section-14.33&quot;&gt;セクション14.33&lt;/a&gt; |再試行後; &lt;a href=&quot;#section-14.37&quot;&gt;セクション14.37&lt;/a&gt; | サーバー; &lt;a href=&quot;#section-14.38&quot;&gt;セクション14.38&lt;/a&gt; | 変化する; &lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44&lt;/a&gt; | WWW-Authenticate; &lt;a href=&quot;#section-14.47&quot;&gt;セクション14.47&lt;/a&gt; 応答ヘッダーフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての関係者がそれらを応答ヘッダーフィールドであると認識する場合、新しいヘッダーフィールドまたは実験的なヘッダーフィールドに応答ヘッダーフィールドのセマンティクスを与えることができます。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">結果の文字列は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;エンコードされます（ &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">エンティティヘッダーで返されるメタ情報は、オリジンサーバーから入手可能な最終的なセットではなく、 ローカルまたはサードパーティのコピーから収集されたものである。提示されるセットは、元のバージョンのサブセットまたはスーパーセットであってもよい[MAY]。例えば、リソースに関するローカルの注釈情報を含めると、オリジンサーバーが知っているメタ情報のスーパーセットになるかもしれません。この応答コードの使用は必須ではなく、応答が200(OK)の場合にのみ適切である。</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">revved リソースに追加されるリビジョンバージョンは、1.1.3 のような古典的なリビジョン文字列である必要はありません。ハッシュや日付のように、衝突を防ぐものであれば何でも構いません。</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">カテゴリドキュメントのルートは「app：categories」要素です。 app：categories要素には、Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]名前空間（ &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;）。「scheme」属性を持たないatom：category子要素は、app：categories親から属性を継承します。既存の「scheme」属性を持つatom：category子要素は、アプリの「scheme」値を継承しません：categories親要素atomCategory = element atom：category {atomCommonAttributes、attribute term {text}、attribute scheme {atomURI} ?, attribute label {text} ?, undefinedContent} appInlineCategories = element app：categories {attribute fixed {&quot;yes&quot; | &quot;no&quot;} ?、属性スキーム{atomURI}？、（atomCategory *、undefinedContent）} appOutOfLineCategories = element app：カテゴリー{属性href {アトムURI}、undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">サービスドキュメントのルートは「app：service」要素です。 app：service要素は、1つ以上のワークスペースに関連付けられたサービス情報のコンテナーです。 app：service要素には、1つ以上のapp：workspace要素が含まれている必要があります。名前空間app = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot; start = appService appService = element app：service {appCommonAttributes、（appWorkspace +＆extensionElement *）}</target>
        </trans-unit>
        <trans-unit id="7cc82da0d72b8678f1e0f58ad59a34e42ed94203" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">同じチャレンジアンドレスポンスメカニズムを&lt;em&gt;プロキシ認証に&lt;/em&gt;使用できます。リソース認証とプロキシ認証の両方が共存できるため、異なるヘッダーとステータスコードのセットが必要です。プロキシの場合、チャレンジステータスコードは&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（プロキシ認証が必要）であり、&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーにはプロキシに適用可能なチャレンジが少なくとも1つ含まれ、&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;リクエストヘッダーはプロキシに資格情報を提供するために使用されますサーバ。</target>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">同じチャレンジおよびレスポンスメカニズムを&lt;em&gt;プロキシ認証に&lt;/em&gt;使用できます。この場合、認証が必要なのは中間プロキシです。リソース認証とプロキシ認証の両方が共存できるため、異なるヘッダーとステータスコードのセットが必要です。プロキシの場合、チャレンジステータスコードは&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（Proxy Authentication Required）であり、&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーにはプロキシに適用可能なチャレンジが少なくとも1つ含まれ、&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;リクエストヘッダーはプロキシに資格情報を提供するために使用されますサーバ。</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">同一サイト属性は、2つの値のうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">機能ポリシーを使用する2番目の方法は、iframe内のコンテンツを制御することです。埋め込みコンテンツのポリシーリストを指定するには、 &lt;code&gt;allow&lt;/code&gt; 属性を使用します。</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;プリフライトされたアクセス制御要求&lt;/a&gt;に関するセクションには、クライアントとサーバー間のヘッダー交換が示されています。プリフライト要求に応答するサーバーリソースは、次の決定を行うことができる必要があります。</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">&lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt;のセクションでは、クライアントとサーバー間のヘッダー交換について説明します。以下は、単純なリクエストを処理するPHPコードセグメントです。</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">GETは「エンティティの形式で、Request-URIによって識別されるすべての情報を取得する」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] として定義されているため、コレクションに適用された場合、GETのセマンティクスは変更されません。 GETをコレクションに適用すると、「index.html」リソースのコンテンツ、人間が読めるコレクションのコンテンツのビュー、またはその他のものがすべて返される場合があります。したがって、コレクションに対するGETの結果は、コレクションのメンバーシップと相関関係がない可能性があります。同様に、HEADの定義は応答メッセージ本文のないGETであるため、コレクションリソースに適用した場合、HEADのセマンティクスは変更されません。</target>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">サーバーは、ターゲットリソースの現在サポートされているメソッドのリストを含む405応答に &lt;code&gt;Allow&lt;/code&gt; ヘッダーフィールドを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">サーバーは、値が「 &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; 」の &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; も送信し、これらが実際のリクエストで使用できるヘッダーであることを確認します。 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; と同様に、 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; は、受け入れ可能なヘッダーのコンマ区切りのリストです。</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">サーバーは、ヘッダー &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; ：http://example.org/whaddupを含むコード&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;で応答します。</target>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">サーバーは要求されたリソースを見つけることができません。ブラウザでは、これは URL が認識されていないことを意味します。API では、これはエンドポイントは有効だが、リソース自体が存在しないことを意味する場合もあります。サーバーは、許可されていないクライアントからリソースの存在を隠すために 403 の代わりにこの応答を送信することもあります。このレスポンスコードは、ウェブ上で頻繁に発生するため、おそらく最も有名なものです。</target>
        </trans-unit>
        <trans-unit id="5c4ccfae2be68876da45c9c1dc793bd8e937dfdb" translate="yes" xml:space="preserve">
          <source>The server can not find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurrence on the web.</source>
          <target state="translated">サーバーは要求されたリソースを見つけることができません。ブラウザでは、これは URL が認識されていないことを意味します。API では、これはエンドポイントは有効だが、リソース自体が存在しないことを意味する場合もあります。サーバーは、許可されていないクライアントからリソースの存在を隠すために 403 の代わりにこの応答を送信することもあります。このレスポンスコードは、ウェブ上で頻繁に発生するため、おそらく最も有名なものです。</target>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">これで、サーバーは安全なバージョンのサイトにリダイレクトできます。&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;サイトがアップグレードメカニズムをサポートしていないクライアントにキャッシュによって提供されないように、ヘッダを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">サーバーは、クライアントの比較 &lt;code&gt;ETag&lt;/code&gt; （で送信された &lt;code&gt;If-None-Match&lt;/code&gt; 付き） &lt;code&gt;ETag&lt;/code&gt; 、バックサーバの送信リソースの現在のバージョンの両方の値が一致した場合（つまり、リソースが変更されていない）&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; 状態を、本文なしで、応答のキャッシュされたバージョンがまだ適切であることをクライアントに伝えます（&lt;em&gt;fresh&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="605fba61796e65ffe01c32b3fab960c6c121a075" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource, and if both values match (that is, the resource has not changed), the server sends back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; status, without a body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">サーバーは、クライアントの比較 &lt;code&gt;ETag&lt;/code&gt; （で送信された &lt;code&gt;If-None-Match&lt;/code&gt; 付き） &lt;code&gt;ETag&lt;/code&gt; リソースの現在のバージョンの、そして両方の値である（つまり、リソースが変更されていない）と一致する場合、サーバが返信&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; ステータス、本文なし。これは、キャッシュされたバージョンの応答を引き続き使用できることをクライアントに通知します（&lt;em&gt;fresh&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">サーバーは、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;などの他の&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;ヘッダーも考慮することができます。</target>
        </trans-unit>
        <trans-unit id="de85219a30abbe89bbf789c793cb5b7464c7af45" translate="yes" xml:space="preserve">
          <source>The server could not understand the request due to invalid syntax.</source>
          <target state="translated">無効な構文のため、サーバーはリクエストを理解できませんでした。</target>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">サーバーはリクエストの処理中に無限ループを検出しました。</target>
        </trans-unit>
        <trans-unit id="d4d0d326b4b9b27451ac87954663d1d88395013c" translate="yes" xml:space="preserve">
          <source>The server did not respond to the actual request (even if it responded to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;Preflight request&lt;/a&gt;). One scenario might be an HTTP service being developed that panicked without returning any data.</source>
          <target state="translated">サーバーは実際の要求に応答しませんでした（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;プリフライト要求に&lt;/a&gt;応答した場合でも）。1つのシナリオは、データを返さずにパニックに陥った開発中のHTTPサービスである可能性があります。</target>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">サーバーはリクエストを満たすために必要な機能をサポートしていません。これは、サーバがリクエストメソッドを認識しておらず、どのリソースに対してもリクエストメソッドをサポートすることができない場合に適切な応答です。</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">サーバーは、要求メッセージで使用されたHTTPプロトコルバージョンをサポートしていないか、サポートを拒否します。サーバーは、&lt;a href=&quot;#section-3.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;で説明されているように、このエラーメッセージ以外では、クライアントと同じメジャーバージョンを使用して要求を完了することができないか、望まないことを示しています。応答には、そのバージョンがサポートされていない理由と、そのサーバーでサポートされている他のプロトコルを説明するエンティティが含まれている必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">サーバーはブラウザの機能を完全に把握していません。クライアントヒント拡張機能を使用しても、ブラウザの機能について完全な知識を持っているわけではありません。クライアントが選択するリアクティブなコンテンツネゴシエーションとは異なり、サーバーの選択は常に多少恣意的です。</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">サーバーは予期しない状態に遭遇したため、リクエストの実行ができませんでした。</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">選択されたバリアントリソースは、透過的なコンテンツネゴシエーションを行うように構成されているため、ネゴシエーションプロセスの適切なエンドポイントではありません。</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">サーバーには内部構成エラーがあります。リクエストに対する透過コンテンツネゴシエーションでは、循環参照が発生します。</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">サーバーが処理方法を知らない状況に遭遇しました。</target>
        </trans-unit>
        <trans-unit id="5cf27f01c140eea8ea3c01504b142779b0027690" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a &lt;code&gt;GET&lt;/code&gt; request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">サーバーはリソースに対する &lt;code&gt;GET&lt;/code&gt; 要求を実行しました。応答は、現在のインスタンスに適用された1つ以上のインスタンス操作の結果を表しています。</target>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">サーバはリソースに対する GET 要求を満たし、応答は現在のインスタンスに適用された 1 つ以上のインスタンス操作の結果を表現したものです。</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">サーバーはリソースの部分的なGETリクエストを実行しました。リクエストには、希望する範囲を示すRangeヘッダーフィールド（&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;）が含まれている必要があり、リクエストを条件付きにするためにIf-Rangeヘッダーフィールド（&lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt;）が含まれている場合があります。応答には、次のヘッダーフィールドを含める必要があります。-Content-Rangeヘッダーフィールド（&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt;）このレスポンスに含まれる範囲、または各パートのContent-Rangeフィールドを含むmultipart / byteranges Content-Typeを示します。 Content-Lengthヘッダーフィールドが応答に存在する場合、その値はメッセージ本文で送信される実際のOCTETの数と一致する必要があります。 -日付-ETagおよび/またはContent-Location（ヘッダーが同じリクエストへの200応答で送信された場合）-Expires、Cache-Control、および/またはVary、フィールド値が送信されたものと異なる場合同じバリアントに対する以前の応答206応答が強力なキャッシュバリデーターを使用したIf-Rangeリクエストの結果である場合（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を&lt;/a&gt;参照））、応答には他のエンティティヘッダーを含めないでください。応答が弱いバリデーターを使用したIf-Rangeリクエストの結果である場合、応答には他のエンティティヘッダーを含めることはできません。これにより、キャッシュされたエンティティ本体と更新されたヘッダーの間の不整合が防止されます。それ以外の場合、応答には、同じ要求に対する200（OK）応答で返されるすべてのエンティティヘッダーを含める必要があります。 ETagまたはLast-Modifiedヘッダーが正確に一致しない場合、キャッシュは206応答を他の以前にキャッシュされたコンテンツと組み合わせてはなりません（MUST NOT）。13.5.4を参照してください。 RangeおよびContent-Rangeヘッダーをサポートしないキャッシュは、206（部分）応答をキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">サーバーはリクエストを満たしたので、ユーザーエージェントはリクエストを送る原因となった ドキュメントビューをリセットすべきである[SHOULD]。この応答は、ユーザーが別の入力アクションを簡単に開始できるように、 ユーザー入力を介して行われるアクションのための入力を可能にすることを主 に意図しており、その後、入力が与えられたフォームのクリアが続く。応答はエンティティを含めてはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">サーバーはリクエストを満たしたが、エンティティボディを返す必要はなく、 更新されたメタ情報を返したいかもしれない。応答は、エンティティヘッダーの形で新規または更新されたメタ情報を 含めてもよい[MAY]。エンティティヘッダーが存在する場合、リクエストされた variantに関連付けられるべきである[SHOULD]。クライアントがユーザーエージェントの場合、リクエストを送った原因となった ドキュメントビューを変更するべきではない[SHOULD NOT]。この応答は主に、ユーザーエージェントのアクティブなドキュメントビューに変更を 起こさずに実行されるアクションのための入力を許可することを意図しているが、 新規または更新されたいかなるメタ情報も、現在ユーザーエージェントの アクティブなビューにあるドキュメントに適用されるべきである[SHOULD]。204応答はメッセージボディを含んではならない[MUST NOT]ため、常にヘッダーフィールドの後の最初の空行で終了する。</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">サーバーはRequest-URIに一致するものを見つけられませんでした。状態が一時的なものなのか永続的なものなのかは示されていない。410(Gone)ステータスコードは、古いリソースが永久に利用できず、転送アド レスを持たないことを、サーバーが内部的に設定可能な何らかのメカニズムを 通じて知っている場合に使用されるべきである[SHOULD]。このステータスコードは、サーバーがリクエストが拒否された理由を正確に明らかに したくない場合や、他の応答が適用できない場合に一般的に使用される。</target>
        </trans-unit>
        <trans-unit id="1d3eb58f597e0c6c5fa76c0069741d7639896309" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">サーバーは、この応答に、切り替えたプロトコルを示す&lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;応答ヘッダーを含めます。このプロセスについては、&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;プロトコルアップグレードメカニズムの&lt;/a&gt;記事で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">サーバーはこの応答に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;応答ヘッダーを含めて、切り替え先のプロトコルを示します。このプロセスは、「&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;プロトコルのアップグレードメカニズム」の&lt;/a&gt;記事で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">現在、サーバーは一時的な過負荷またはサーバーのメンテナンスのため、リクエストを処理することができません。これは一時的な状態であり、ある程度の遅延の後に緩和されるということを暗示 している。それがわかっている場合、遅延の長さをRetry-Afterヘッダーで示してもよい[MAY]。Retry-Afterが与えられない場合、クライアントは500応答の場合と同様に 応答を処理するべきである[SHOULD]。注意:503ステータスコードの存在は、過負荷になったときにサーバーがそれを使用しな ければならないことを暗示しているわけではない。サーバーによっては、単に接続を拒否することを望むかもしれない。</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">サーバーはリクエストを処理する準備ができていません。一般的な原因は、メンテナンスのためにサーバーがダウンしているか、過負荷になっているサーバーです。この応答とともに、問題を説明する使いやすいページを送信する必要があることに注意してください。この応答は一時的な状況で使用する必要があり、 &lt;code&gt;Retry-After:&lt;/code&gt; HTTPヘッダーには、可能であれば、サービスが回復するまでの推定時間を含める必要があります。これらの一時的な条件応答は通常キャッシュされるべきではないため、Webマスターは、この応答と共に送信されるキャッシュ関連のヘッダーにも注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">サーバーに負荷がかかりすぎていて、圧縮要件による計算オーバーヘッドを許容できない。一般的に、Microsoft は、サーバが 80% 以上の計算能力を使用している場合は圧縮しないことを推奨しています。</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">リクエストの実体がサーバーが処理する意思があるか、または処理できるよりも大きいため、 サーバーはリクエストの処理を拒否している。サーバーは、クライアントがリクエストを継続できないようにするために、 接続を閉じてもよい[MAY]。その状態が一時的なものである場合、サーバーはそれが一時的なものであり、何時までにクライア ントが再試行してもよい[MAY]ことを示すために、Retry-Afterヘッダーフィー ルドを含めるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">Request-URIがサーバーが解釈しようとするよりも長いため、サーバーはリクエストの サービスを拒否している。このまれな状態は、クライアントが長い問い合わせ情報を持つPOSTリクエストを 不適切にGETリクエストに変換した場合、クライアントがリダイレクションの URI「ブラックホール」(例えば、それ自身の接尾辞を指すリダイレクトされたURI接頭辞)に陥った場合、またはRequest-URIを読み取ったり操作したりするために固定長の バッファを使用するいくつかのサーバーに存在するセキュリティホールを悪用しようとするクライア ントによってサーバーが攻撃を受けている場合にのみ発生する可能性がある。</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">リクエストの実体が、リクエストされたメソッドに対してリクエストされたリソースがサポートしていない形式であるため、サーバーはリクエストのサービスを拒否しています。</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">サーバーはそのヘッダーフィールドが大きすぎるため、リクエストを処理する気がない。リクエストヘッダーフィールドのサイズを小さくしてから、リクエストを再提出してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="2cabf4085dccd9d1a0d60a5bef8f53aaaa7eb900" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">サーバーはリクエストのヘッダーフィールドが大きすぎるため、リクエストを処理する気がありません。リクエストヘッダーフィールドのサイズを小さくした後で、リクエストは再送されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">サーバーはアップグレードを拒否する可能性があります&amp;mdash;この場合、 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; ヘッダーを無視して通常の応答（要求されたリソースを提供できる場合は &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; 、リダイレクトを実行する場合は &lt;code&gt;30x&lt;/code&gt; ステータスコード）を返します。要求されたリソースを提供できない場合は &lt;code&gt;40x&lt;/code&gt; または &lt;code&gt;50x&lt;/code&gt; 倍）、またはアップグレードを受け入れます。この場合、選択したプロトコルを指定するUpgradeヘッダーを含む &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; を送り返します。</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">サーバはワイルドカードとして &quot;*&quot;を指定することができ、それによって任意のオリジンがタイミングリソースを見ることができるようになります。</target>
        </trans-unit>
        <trans-unit id="767e4fc07c131eef7a83181be5734574f3f01fab" translate="yes" xml:space="preserve">
          <source>The server now can respond if it will accept a request under these circumstances. In this example, the server response says that:</source>
          <target state="translated">このような状況下でリクエストを受け入れるかどうかをサーバが応答できるようになりました。この例では、サーバーのレスポンスはこう言っています。</target>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">サーバーはリクエストヘッダーを確認し、&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（Continue）レスポンスで応答して、クライアントにメッセージ本文を送信するように指示するか、期待値のいずれかが満たされない場合は&lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt;（Expectedation Failed）ステータスを送信します。</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">サーバーは、単一のオリジンである onlinebanking.jumbobank.com を通じて HTTPS で特別に読み込まれた文書へのアクセスのみを許可します。</target>
        </trans-unit>
        <trans-unit id="26883acb60acb54540a0e576eaa8444f3824e5cd" translate="yes" xml:space="preserve">
          <source>The server permits access only to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">サーバーは、単一のオリジンである onlinebanking.jumbobank.com を通じて、HTTPS で特別に読み込まれた文書へのアクセスのみを許可します。</target>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">サーバーはリクエストを処理し、その回答を送り返し、ステータスコードと適切なデータを提供します。</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">ティーポットでコーヒーを淹れようとすると、サーバーが断る。</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">サーバーは、定義されたContent-Lengthを持たないリクエストの受け入れを 拒否する。クライアントは、リクエストメッセージ中のメッセージボディの長さを含む有効な Content-Lengthヘッダーフィールドを追加する場合、リクエストを繰り返してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">サーバーは、現在のプロトコルを使用して要求を実行することを拒否しますが、クライアントが別のプロトコルにアップグレードした後で実行する可能性があります。サーバーは、426応答で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを送信して、必要なプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="82c879297c83c6c0c7f5e4355a3573667d1d3938" translate="yes" xml:space="preserve">
          <source>The server responds to a client with a &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt; (Unauthorized) response status and provides information on how to authorize with a &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; response header containing at least one challenge.</source>
          <target state="translated">サーバーは、&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt;（未承認）応答ステータスでクライアントに応答し、少なくとも1つのチャレンジを含む&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーで承認する方法に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">サーバーは&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で&lt;/a&gt;応答し、 &lt;code&gt;POST&lt;/code&gt; 、 &lt;code&gt;GET&lt;/code&gt; 、および &lt;code&gt;OPTIONS&lt;/code&gt; は問題のリソースを照会するための実行可能なメソッドであると述べています。このヘッダーは&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、CORSのコンテキスト内で厳密に使用されます。</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">サーバーは &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で応答し、 &lt;code&gt;POST&lt;/code&gt; および &lt;code&gt;GET&lt;/code&gt; は問題のリソースを照会するための実行可能なメソッドであると述べています。このヘッダーは&lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、アクセス制御のコンテキスト内で厳密に使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="50340f4cfb4f858ac4e526eb22f4eb0cf5120e8d" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt;, restricting access to just the requesting origin domain. It also responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, which says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question (this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control).</source>
          <target state="translated">サーバーは &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt; で応答し、要求元のドメインのみにアクセスを制限します。また、 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で応答します。これは、 &lt;code&gt;POST&lt;/code&gt; と &lt;code&gt;GET&lt;/code&gt; が問題のリソースをクエリするための実行可能なメソッドであることを示します（このヘッダーは&lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、アクセス制御のコンテキスト内で厳密に使用されます）。</target>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">サーバーは、 &lt;code&gt;Content-Encoding&lt;/code&gt; 応答ヘッダーで示される、使用されるスキームで応答します。</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">サーバーは&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ステータスと&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; ヘッダー。マルチパートバイト範囲が続くことを示します。各部分には独自の &lt;code&gt;Content-Type&lt;/code&gt; フィールドと &lt;code&gt;Content-Range&lt;/code&gt; フィールドが含まれ、必須の境界パラメーターは、各本体部分を区切るために使用される境界文字列を指定します。</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">サーバーは&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ステータスで応答します。</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">サーバーは、この応答と共に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを送信して、必要なプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">サーバーはこの応答を送信して、前の要求で使用されたのと同じメソッドを使用して、要求されたリソースを別のURIで取得するようクライアントに指示します。これは、同じセマンティック有する &lt;code&gt;302 Found&lt;/code&gt; ユーザーエージェントがことを除いて、HTTP応答コードを&lt;em&gt;してはならない&lt;/em&gt;場合：使用するHTTPメソッドを変更 &lt;code&gt;POST&lt;/code&gt; が最初の要求で使用された、 &lt;code&gt;POST&lt;/code&gt; は、第2の要求に使用されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">サーバはこのレスポンスを送信して、クライアントが要求されたリソースを別のURIでGETリクエストで取得するように指示しました。</target>
        </trans-unit>
        <trans-unit id="848c3b9ad4be0c1360d99c2d9af3ef34c33fe75c" translate="yes" xml:space="preserve">
          <source>The server takes the value of the Sec-WebSocket-Key sent in the handshake request, appends &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt;, takes SHA-1 of the new value, and is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded.</source>
          <target state="translated">サーバーは、ハンドシェイク要求で送信されたSec-WebSocket-Keyの値を取得し、 &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt; を追加し、新しい値のSHA-1を取得して、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64で&lt;/a&gt;エンコードします。</target>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">サーバーは、この接続で使用されているアプリケーションプロトコルの変更について、Upgradeメッセージヘッダーフィールド（&lt;a href=&quot;#section-14.42&quot;&gt;セクション14.42&lt;/a&gt;）を介してクライアントの要求を理解し、クライアントの要求に応じます。サーバーは、101応答を終了する空の行の直後に、プロトコルを応答のUpgradeヘッダーフィールドで定義されたプロトコルに切り替えます。プロトコルは、そうすることが有利な場合にのみ切り替える必要があります。たとえば、HTTPの新しいバージョンへの切り替えは古いバージョンよりも有利であり、リアルタイムの同期プロトコルへの切り替えは、そのような機能を使用するリソースを配信するときに有利になる場合があります。</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">サーバーはリクエストを理解したが、それを実行することを拒否している。認可は何の役にも立たず、リクエストは繰り返されるべきではない[SHOULD NOT]。リクエストメソッドがHEADではなく、サーバーがリクエストが満たされなかった理由を公開したい場合、 エンティティに拒否の理由を記述するべきである[SHOULD]。サーバーがこの情報をクライアントに公開したくない場合、代わりにステータスコード404(Not Found)を使用することができる。</target>
        </trans-unit>
        <trans-unit id="2bccd21746e24e17c4d6598c2feaeef9e50bab37" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;a href=&quot;headers/sec-websocket-accept&quot;&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/a&gt; header will have a value computed based upon the specified &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">サーバーの応答の&lt;a href=&quot;headers/sec-websocket-accept&quot;&gt; &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; &lt;/a&gt;ヘッダーには、指定された &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt; 基づいて計算された値が含まれます。</target>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">サーバーの応答の &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; ヘッダーには、指定された &lt;code&gt;key&lt;/code&gt; 基づいて計算された値が含まれます。</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">ゲートウェイまたはプロキシとして動作している間、サーバーはURIで指定されたアップストリームサーバー (HTTP、FTP、LDAPなど)またはリクエストを完了しようとする際にアクセスする必要のある他の補助サーバー(DNSなど)から タイムリーな応答を受け取らなかった。注意:実装者への注意:いくつかの配備されたプロキシは、DNSのルックアップがタイムアウトしたときに400または500を返すことが知られています。</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">サーバーがゲートウェイまたはプロキシとして動作しているときに、 リクエストを満たすためにアクセスしたアップストリームサーバーから 無効な応答を受け取った。</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">HTTP / 1.1の一般的なメソッドのセットを以下に定義します。このセットは拡張できますが、個別に拡張されたクライアントとサーバーで同じセマンティクスを共有する追加のメソッドを想定することはできません。Hostリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt;）は、すべてのHTTP / 1.1リクエストに伴う必要があります。</target>
        </trans-unit>
        <trans-unit id="3aa1224052f644e6f5d9789fe1626a5e5119f08c" translate="yes" xml:space="preserve">
          <source>The simplest MIME type consists of a &lt;var&gt;type&lt;/var&gt; and a &lt;var&gt;subtype&lt;/var&gt;; these are each strings which, when concatenated with a slash (&lt;code&gt;/&lt;/code&gt;) between them, comprise a MIME type. No whitespace is allowed in a MIME type:</source>
          <target state="translated">最も単純なMIMEタイプは、 &lt;var&gt;type&lt;/var&gt; と &lt;var&gt;subtype&lt;/var&gt; 構成されます。これらはそれぞれ文字列であり、それらの間にスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）を連結すると、MIMEタイプを構成します。MIMEタイプに空白は使用できません。</target>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">サイトは、投稿が公開されたことを確認する一般的な成功メッセージを返します。サーバーは、 &lt;code&gt;Content-Location&lt;/code&gt; を使用して新しい投稿の&lt;em&gt;場所を&lt;/em&gt;指定します。</target>
        </trans-unit>
        <trans-unit id="d9ec569438b6e170956f6c9751913bd129236874" translate="yes" xml:space="preserve">
          <source>The size of the resource, in decimal number of bytes.</source>
          <target state="translated">リソースのサイズを10進数で表します。</target>
        </trans-unit>
        <trans-unit id="9fb8b58154cc46b27e579e11d1cdd3ea67056760" translate="yes" xml:space="preserve">
          <source>The special value ''clear&quot; indicates that the origin requests all alternatives for that origin to be invalidated.</source>
          <target state="translated">特別な値 ''clear&quot; は、オリジンがそのオリジンのすべての代替案の無効化を要求していることを示します。</target>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">特別な値「 &lt;code&gt;*&lt;/code&gt; 」は、サーバー主導のコンテンツネゴシエーションでも、ヘッダーで伝達されない情報を使用して適切なコンテンツを選択することを意味します。</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">この仕様では、HTTPのオーバーヘッドを最小限に抑えるために、名前と説明は可能な限り短く(省略形を使用し、可能な場合はオプションの値を省略する)することが推奨されています。</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">仕様は明確にするために大幅に書き直されました。認証済みの応答をキャッシュできる条件が明確になりました。 （&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）新しいステータスコードで、キャッシュでヒューリスティックフレッシュネスを使用できることを定義できるようになりました。キャッシュは、クエリコンポーネントを使用してURIのヒューリスティックな鮮度を計算できるようになりました。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt;）年齢を計算するためのアルゴリズムの保守性が低下しました。正確に推測することができないため、キャッシュはタイムゾーンのある日付を無効であるかのように処理する必要があります。 （&lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt;）Content-Location応答ヘッダーフィールドは、検証時に使用する適切な応答を決定するために使用されなくなりました。 （&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）使用するためにキャッシュされたネゴシエートされた応答を選択するアルゴリズムは、いくつかの方法で明確にされています。特に、選択ヘッダーフィールドを処理するときに、ヘッダー固有の正規化を明示的に許可するようになりました。 （&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）無効化を実行する際のサービス拒否攻撃回避に関する要件が明確になりました。 （&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）キャッシュの無効化は、正常な応答を受信した場合にのみ発生します。 （&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）キャッシュディレクティブは、大文字と小文字を区別しないように明示的に定義されています。キャッシュディレクティブのインスタンスが1つだけ必要な場合の複数インスタンスの処理が定義されました。 （&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;） &quot;no-store&quot;リクエストディレクティブはレスポンスには適用されません。つまり、キャッシュは、ストアを持たない要求を満たし、それを無効化しません。 （&lt;a href=&quot;#section-5.2.1.5&quot;&gt;セクション5.2.1.5&lt;/a&gt;）プライベートおよびキャッシュなしのキャッシュディレクティブの修飾形式は、広く実装されていません。たとえば、 &quot;private = foo&quot;は多くのキャッシュによって単に &quot;private&quot;と解釈されます。さらに、ノーキャッシュの修飾形式の意味が明確になりました。 （&lt;a href=&quot;#section-5.2.2&quot;&gt;セクション5.2.2&lt;/a&gt;）「no-cache」応答ディレクティブの意味が明確になりました。 （&lt;a href=&quot;#section-5.2.2.2&quot;&gt;セクション5.2.2.2&lt;/a&gt;）Expiresヘッダーフィールド値の1年の制限が削除されました。代わりに、実用的な値を使用する理由が与えられます。 （&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）Pragmaヘッダーフィールドは、下位互換性のためにのみ定義されています。将来のプラグマは非推奨です。 （&lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt;）広く実装されていないため、警告ヘッダーフィールドの生成と処理に関する要件が緩和されました。さらに、警告ヘッダーフィールドは&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; エンコーディングを使用しなくなりました。また、これらの側面が実装されていなかったため、複数の言語を許可していません。 （&lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt;）この仕様では、キャッシュディレクティブと警告コードレジストリが導入され、新しいキャッシュディレクティブに関する考慮事項が定義されています。 （&lt;a href=&quot;#section-7.1&quot;&gt;セクション7.1&lt;/a&gt;および&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">指定されたHTTPSプロキシを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">指定されたSOCKSサーバ(指定されたSOCOCKバージョンのもの)を使用してください。</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">指定したSOCKSサーバを使用してください。</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">指定されたプロキシを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">標準化されたヘッダー。</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">&lt;em&gt;ステータスライン&lt;/em&gt;と呼ばれるHTTP応答の開始行には、次の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">HTTPメッセージの開始行ヘッダーとHTTPヘッダーはまとめて要求の&lt;em&gt;ヘッド&lt;/em&gt;と呼ばれ、そのペイロードは&lt;em&gt;本文&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">ステータスコードレジストリは、以下の登録で更新されました。+ ------- + ----------------------------- -+ ---------------- + |値|説明|リファレンス| + ------- + ------------------------------- + --------- ------- + | 100 |続ける| &lt;a href=&quot;#section-6.2.1&quot;&gt;セクション6.2.1&lt;/a&gt; | | 101 |スイッチングプロトコル| &lt;a href=&quot;#section-6.2.2&quot;&gt;セクション6.2.2&lt;/a&gt; | | 200 | OK | &lt;a href=&quot;#section-6.3.1&quot;&gt;セクション6.3.1&lt;/a&gt; | | 201 |作成されました| &lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt; | | 202 |受け入れられる| &lt;a href=&quot;#section-6.3.3&quot;&gt;セクション6.3.3&lt;/a&gt; | | 203 |信頼できない情報| &lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt; | | 204 |コンテンツなし|&lt;a href=&quot;#section-6.3.5&quot;&gt;セクション6.3.5&lt;/a&gt; | | 205 |コンテンツをリセット| &lt;a href=&quot;#section-6.3.6&quot;&gt;セクション6.3.6&lt;/a&gt; | | 300 |複数の選択肢| &lt;a href=&quot;#section-6.4.1&quot;&gt;セクション6.4.1&lt;/a&gt; | | 301 |永久に移動しました| &lt;a href=&quot;#section-6.4.2&quot;&gt;セクション6.4.2&lt;/a&gt; | | 302 |見つかった| &lt;a href=&quot;#section-6.4.3&quot;&gt;セクション6.4.3&lt;/a&gt; | | 303 |その他を見る| &lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt; | | 305 |プロキシを使用| &lt;a href=&quot;#section-6.4.5&quot;&gt;セクション6.4.5&lt;/a&gt; | | 306 | （未使用）| &lt;a href=&quot;#section-6.4.6&quot;&gt;セクション6.4.6&lt;/a&gt; | | 307 |一時的なリダイレクト| &lt;a href=&quot;#section-6.4.7&quot;&gt;セクション6.4.7&lt;/a&gt; | | 400 |悪い要求| &lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt; | | 402 |お支払いが必要です| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | 403 |禁じられた| &lt;a href=&quot;#section-6.5.3&quot;&gt;セクション6.5.3&lt;/a&gt; | | 404 |見つかりません| &lt;a href=&quot;#section-6.5.4&quot;&gt;セクション6.5.4&lt;/a&gt; | | 405 |メソッドは許可されていません| &lt;a href=&quot;#section-6.5.5&quot;&gt;セクション6.5.5&lt;/a&gt; | | 406 |受け入れられない| &lt;a href=&quot;#section-6.5.6&quot;&gt;セクション6.5.6&lt;/a&gt; | | 408 |リクエストのタイムアウト| &lt;a href=&quot;#section-6.5.7&quot;&gt;セクション6.5.7&lt;/a&gt; | | 409 |紛争| &lt;a href=&quot;#section-6.5.8&quot;&gt;セクション6.5.8&lt;/a&gt; | | 410 |なくなった| &lt;a href=&quot;#section-6.5.9&quot;&gt;セクション6.5.9&lt;/a&gt; | | 411 |必要な長さ| &lt;a href=&quot;#section-6.5.10&quot;&gt;セクション6.5.10&lt;/a&gt; | | 413 |ペイロードが大きすぎます|&lt;a href=&quot;#section-6.5.11&quot;&gt;セクション6.5.11&lt;/a&gt; | | 414 | URIが長すぎます| &lt;a href=&quot;#section-6.5.12&quot;&gt;セクション6.5.12&lt;/a&gt; | | 415 |サポートされていないメディアタイプ| &lt;a href=&quot;#section-6.5.13&quot;&gt;セクション6.5.13&lt;/a&gt; | | 417 |期待はずれ| &lt;a href=&quot;#section-6.5.14&quot;&gt;セクション6.5.14&lt;/a&gt; | | 426 |アップグレードが必要です| &lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt; | | 500 |内部サーバーエラー| &lt;a href=&quot;#section-6.6.1&quot;&gt;セクション6.6.1&lt;/a&gt; | | 501 |実装されていません| &lt;a href=&quot;#section-6.6.2&quot;&gt;セクション6.6.2&lt;/a&gt; | | 502 |悪いゲートウェイ| &lt;a href=&quot;#section-6.6.3&quot;&gt;セクション6.6.3&lt;/a&gt; | | 503 |サービスを利用できません| &lt;a href=&quot;#section-6.6.4&quot;&gt;セクション6.6.4&lt;/a&gt; | | 504 |ゲートウェイタイムアウト| &lt;a href=&quot;#section-6.6.5&quot;&gt;セクション6.6.5&lt;/a&gt; | | 505 | サポートされていないHTTPバージョン| &lt;a href=&quot;#section-6.6.6&quot;&gt;セクション6.6.6&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">下記のステータスコードは、本明細書で定義されている &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;[RFC7232]のセクション4&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;[RFC7233]のセクション4&lt;/a&gt;、および&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;[RFC7235]のセクション3&lt;/a&gt;。ここに記載されている理由フレーズは推奨事項にすぎません。プロトコルに影響を与えることなく、ローカルの同等のものに置き換えることができます。デフォルトでキャッシュ可能として定義されているステータスコード（たとえば、この仕様では200、203、204、206、300、301、404、405、410、414、および501）を持つ応答は、ヒューリスティックな有効期限のあるキャッシュで再利用できます。それ以外の場合は、メソッド定義または明示的なキャッシュ制御[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;];他のすべてのステータスコードは、デフォルトではキャッシュできません。 + ------ + ------------------------------- + ---------- ---------------- + |コード|理由フレーズ|で定義されています... | + ------ + ------------------------------- + ---------- ---------------- + | 100 |続ける| &lt;a href=&quot;#section-6.2.1&quot;&gt;セクション6.2.1&lt;/a&gt; | | 101 |スイッチングプロトコル| &lt;a href=&quot;#section-6.2.2&quot;&gt;セクション6.2.2&lt;/a&gt; | | 200 | OK | &lt;a href=&quot;#section-6.3.1&quot;&gt;セクション6.3.1&lt;/a&gt; | | 201 |作成されました| &lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt; | | 202 |受け入れられる| &lt;a href=&quot;#section-6.3.3&quot;&gt;セクション6.3.3&lt;/a&gt; | | 203 |信頼できない情報| &lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt; | | 204 |コンテンツなし| &lt;a href=&quot;#section-6.3.5&quot;&gt;セクション6.3.5&lt;/a&gt; | | 205 |コンテンツをリセット| &lt;a href=&quot;#section-6.3.6&quot;&gt;セクション6.3.6&lt;/a&gt; | | 206 |部分的なコンテンツ| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;[RFC7233]のセクション4.1&lt;/a&gt; | | 300 |複数の選択肢| &lt;a href=&quot;#section-6.4.1&quot;&gt;セクション6.4.1&lt;/a&gt; | | 301 |永久に移動しました| &lt;a href=&quot;#section-6.4.2&quot;&gt;セクション6.4.2&lt;/a&gt; | | 302 |見つかった| &lt;a href=&quot;#section-6.4.3&quot;&gt;セクション6.4.3&lt;/a&gt; | | 303 |その他を見る| &lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt; | | 304 |変更されていません| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]のセクション4.1&lt;/a&gt; | | 305 |プロキシを使用|&lt;a href=&quot;#section-6.4.5&quot;&gt;セクション6.4.5&lt;/a&gt; | | 307 |一時的なリダイレクト| &lt;a href=&quot;#section-6.4.7&quot;&gt;セクション6.4.7&lt;/a&gt; | | 400 |悪い要求| &lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt; | | 401 |無許可| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;[RFC7235]のセクション3.1&lt;/a&gt; | | 402 |お支払いが必要です| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | 403 |禁じられた| &lt;a href=&quot;#section-6.5.3&quot;&gt;セクション6.5.3&lt;/a&gt; | | 404 |見つかりません| &lt;a href=&quot;#section-6.5.4&quot;&gt;セクション6.5.4&lt;/a&gt; | | 405 |メソッドは許可されていません| &lt;a href=&quot;#section-6.5.5&quot;&gt;セクション6.5.5&lt;/a&gt; | | 406 |受け入れられない| &lt;a href=&quot;#section-6.5.6&quot;&gt;セクション6.5.6&lt;/a&gt; | | 407 |プロキシ認証が必要です| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;[RFC7235]のセクション3.2&lt;/a&gt; | | 408 |リクエストのタイムアウト| &lt;a href=&quot;#section-6.5.7&quot;&gt;セクション6.5.7&lt;/a&gt; | | 409 |紛争| &lt;a href=&quot;#section-6.5.8&quot;&gt;セクション6.5.8&lt;/a&gt; | | 410 |なくなった| &lt;a href=&quot;#section-6.5.9&quot;&gt;セクション6.5.9&lt;/a&gt; | | 411 |必要な長さ| &lt;a href=&quot;#section-6.5.10&quot;&gt;セクション6.5.10&lt;/a&gt; | | 412 |前提条件が失敗しました| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;[RFC7232]のセクション4.2&lt;/a&gt; | | 413 |ペイロードが大きすぎます| &lt;a href=&quot;#section-6.5.11&quot;&gt;セクション6.5.11&lt;/a&gt; | | 414 | URIが長すぎます| &lt;a href=&quot;#section-6.5.12&quot;&gt;セクション6.5.12&lt;/a&gt; | | 415 |サポートされていないメディアタイプ|&lt;a href=&quot;#section-6.5.13&quot;&gt;セクション6.5.13&lt;/a&gt; | | 416 |範囲が満足できません| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;[RFC7233]のセクション4.4&lt;/a&gt; | | 417 |期待はずれ| &lt;a href=&quot;#section-6.5.14&quot;&gt;セクション6.5.14&lt;/a&gt; | | 426 |アップグレードが必要です| &lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt; | | 500 |内部サーバーエラー| &lt;a href=&quot;#section-6.6.1&quot;&gt;セクション6.6.1&lt;/a&gt; | | 501 |実装されていません| &lt;a href=&quot;#section-6.6.2&quot;&gt;セクション6.6.2&lt;/a&gt; | | 502 |悪いゲートウェイ| &lt;a href=&quot;#section-6.6.3&quot;&gt;セクション6.6.3&lt;/a&gt; | | 503 |サービスを利用できません| &lt;a href=&quot;#section-6.6.4&quot;&gt;セクション6.6.4&lt;/a&gt; | | 504 |ゲートウェイタイムアウト| &lt;a href=&quot;#section-6.6.5&quot;&gt;セクション6.6.5&lt;/a&gt; | | 505 | サポートされていないHTTPバージョン| &lt;a href=&quot;#section-6.6.6&quot;&gt;セクション6.6.6&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- +このリストは完全ではないことに注意してください-他の仕様で定義されている拡張ステータスコードは含まれていません。ステータスコードの完全なリストは、IANAによって管理されています。詳細については、&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">status-code 要素は、リクエストを理解して満足させようとした結果を示す 3 桁の整数コードです。HTTP ステータスコードは拡張可能です。HTTP クライアントは登録されたすべてのステータスコードの意味を理解する必要はありませんが、そのような理解は明らかに望ましいです。しかしながら、クライアントは、最初の桁で示されるようなステータスコードのクラスを理解しなければならず[MUST]、認識されていないステータスコードを、受信者が認識されていないステータスコードを持つ応答をキャッシュしてはならない[MUST NOT]という例外を除いて、そのクラスのx00ステータスコードと同等であるとして扱わなければならない。例えば、認識されていないステータスコード471をクライアン トが受け取る場合、クライアントはリクエストに何か問題があったと仮定して、その 応答を400(Bad Request)ステータスコードを受け取ったかのように扱うことができる。応答メッセージは通常、ステータスを説明する表現を含む。ステータスコードの最初の桁は応答のクラスを定義します。最後の2桁は分類の役割を持ちません。最初の桁には5つの値がある。1xx (Informational):リクエストを受信しました。2xx (成功):要求は正常に受信され、理解され、受け入れられました。3xx (リダイレクション):リクエストを完了するためにさらなるアクションが必要です。4xx (クライアントエラー):リクエストは間違った構文を含んでいるか、実行できません。5xx (サーバーエラー):サーバーは一見有効なリクエストの実行に失敗しました。</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">文字列には、セミコロンで区切られた以下のビルディングブロックをいくつでも含めることができます。</target>
        </trans-unit>
        <trans-unit id="4d9a1a47b58bb09a0a513706e6f21fd9ec5db53c" translate="yes" xml:space="preserve">
          <source>The string following &lt;code&gt;filename&lt;/code&gt; should always be put into quotes; but, for compatibility reasons, many browsers try to parse unquoted names that contain spaces.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 続く文字列は常に引用符で囲む必要があります。ただし、互換性の理由から、多くのブラウザは、スペースを含む引用符で囲まれていない名前を解析しようとします。</target>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">多くの場合、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;の成功結果は &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; ではなく、&lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; （またはリソースが初めてアップロードされたときに&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; ）になります。</target>
        </trans-unit>
        <trans-unit id="7f017eb4d89aedd499f70986d2b736c586f7c389" translate="yes" xml:space="preserve">
          <source>The syntax for these headers is the following:</source>
          <target state="translated">これらのヘッダの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダーの構文を使用すると、サーバーメトリック名のみ、値付きのメトリック、値と説明付きのメトリック、およびメトリック付きの説明など、さまざまな方法でメトリックを通信できます。</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">Slugヘッダーの構文は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]のセクション2.1で&lt;/a&gt;定義されている拡張BNF構文を使用して定義されています。LWS = &amp;lt; &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]のセクション2.2で&lt;/a&gt;定義されています &amp;gt; slugtext =％x20-7E | LWS Slug = &quot;Slug&quot; &quot;：&quot; * slugtextフィールド値は、含まれる文字シーケンスのUTF-8エンコーディングのパーセントエンコードされた値です（ パーセントエンコーディングの定義については、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986]のセクション2.1を&lt;/a&gt;参照してください。&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;]は、UTF-8エンコーディングの定義です）。実装上の注意：文字シーケンスからフィールド値を生成するには、まずUTF-8エンコードを使用してエンコードし、次に％20-24および％26-7Eの範囲外のすべてのオクテットをパーセントエンコードを使用してエンコードします（％25はASCIIエンコードです） 「％」、つまりエスケープする必要があります）。フィールド値を消費するには、最初にパーセントエンコーディングを逆にし、次に結果のオクテットシーケンスをUTF-8デコードプロセスで実行します。</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">リソースに対してロック要求があった場合の動作を以下に示します。 True=ロックが許可されている。False=ロックは許可されてはならない。*=プリンシパルが同じロックを2回要求することは違法です。リソースの現在のロック状態は一番左の列に、ロック要求は最初の行に記載されています。行と列の交点がロック要求の結果を表します。例えば、リソースに共有ロックが保持されており、排他的ロックが要求された場合、テーブルのエントリは &quot;false &quot;であり、ロックを許可してはならないことを示します。</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれ、その性質はさらに定義されていません。ドキュメント、写真、その他の何でもかまいません。各リソースは、HTTP全体でリソースの識別に使用されるUniform Resource Identifier（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）によって識別されます。</target>
        </trans-unit>
        <trans-unit id="a332edd44b965848f63f0bd63edb5a5baade7db6" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, whose nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれ、その性質はこれ以上定義されません。ドキュメント、写真、その他何でもかまいません。各リソースは、リソースを識別するためにHTTP全体で使用されるUniform Resource Identifier（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）によって識別されます。</target>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれます。 HTTPはリソースの性質を制限しません。リソースとの対話に使用される可能性のあるインターフェースを定義するだけです。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]のセクション2.7で&lt;/a&gt;説明されているように、各リソースはUniform Resource Identifier（URI）によって識別され ます。クライアントがHTTP / 1.1要求メッセージを作成するとき、（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]のセクション5.3）で&lt;/a&gt;定義されているように、さまざまな形式の1つでターゲットURIを送信します。リクエストが受信されると、サーバーはターゲットリソースの有効なリクエストURIを再構築します（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]のセクション5.5&lt;/a&gt;）。 HTTPの設計目標の1つは、リソースの識別を要求のセマンティクスから分離することです。これは、要求のセマンティクスを要求メソッドに付与することで可能になります（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）といくつかのリクエスト変更ヘッダーフィールド（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt;で説明されているように、メソッドのセマンティクスとURI自体が意味するセマンティクスの間に矛盾がある場合、メソッドのセマンティクスが優先されます。</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">エラーメッセージのテキストは以下のようなものになります。</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">オブジェクトがプロキシキャッシュに保存されている時間を秒単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">ブラウザが覚えておくべき時間は、秒単位で、サイトがHTTPSを使ってアクセスするためだけのものであることを示しています。</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">このサイトは、定義されたキーのいずれかを使用してのみアクセスできることをブラウザが覚えておくべき時間(秒単位)です。</target>
        </trans-unit>
        <trans-unit id="4110d2a33eaaff440bedc1360a1f4ce9d0cb92f4" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the object has been in a proxy cache.</source>
          <target state="translated">オブジェクトがプロキシキャッシュに保存されている時間を秒単位で表示します。</target>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">ドキュメントの合計サイズ（不明 &lt;code&gt;'*'&lt;/code&gt; 場合は「*」）。</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">メッセージのtransfer-lengthは、メッセージに表示されるメッセージ本体の長さです。つまり、転送コーディングが適用された後です。メッセージ本文がメッセージに含まれている場合、その本文の転送長は、次のいずれかによって（優先順で）決定されます。 1xx、204、および304応答と、HEAD要求への応答）は、メッセージに存在するエンティティヘッダーフィールドに関係なく、常にヘッダーフィールドの後の最初の空行で終了します。 2. Transfer-Encodingヘッダーフィールド（&lt;a href=&quot;#section-14.41&quot;&gt;セクション14.41&lt;/a&gt;）が存在し、 &quot;identity&quot;以外の値がある場合、 &quot;chunked&quot;を使用してtransfer-lengthが定義されます。転送コーディング（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）、ただし、接続を閉じることによってメッセージが終了しない限り。 3. Content-Lengthヘッダーフィールドの場合（&lt;a href=&quot;#section-14.13&quot;&gt;セクション14.13&lt;/a&gt;）が存在する場合、OCTETの10進数値はエンティティ長と転送長の両方を表します。これら2つの長さが異なる場合（つまり、Transfer-Encodingヘッダーフィールドが存在する場合）、Content-Lengthヘッダーフィールドを送信してはなりません（MUST NOT）。 Transfer-EncodingヘッダーフィールドとContent-Lengthヘッダーフィールドの両方を含むメッセージを受信した場合、後者は無視する必要があります。 4.メッセージがメディアタイプ「multipart / byteranges」を使用し、転送長が特に指定されていない場合、この自己制限メディアタイプが転送長を定義します。このメディアタイプは、送信者が受信者が付与できることを知らない限り、使用しないでください。 1からの複数のバイト範囲指定子を持つRangeヘッダーのリクエスト内の存在。1クライアントは、リエントがmultipart / byteranges応答を解析できることを意味します。範囲ヘッダーは、マルチパート/バイト範囲を理解しない1.0プロキシによって転送される可能性があります。この場合、サーバーはこのセクションの項目1、3、または5で定義されたメソッドを使用してメッセージを区切る必要があります。 5.サーバーが接続を閉じる。 （接続を閉じることは、サーバーが応答を返す可能性を残さないため、要求本文の終わりを示すために使用することはできません。）HTTP / 1.0アプリケーションとの互換性のために、メッセージ本体を含むHTTP / 1.1要求はサーバーがHTTP / 1.1に準拠していることがわかっている場合を除き、有効なContent-Lengthヘッダーフィールドを含めます。リクエストにメッセージ本文が含まれ、Content-Lengthが指定されていない場合、サーバーは、メッセージの長さを判別できない場合は400（不正な要求）で応答する必要があり、有効なContent-Lengthの受信を要求する場合は411（必要な長さ）で応答する必要があります。エンティティを受信するすべてのHTTP / 1.1アプリケーションは、「チャンクされた」転送コーディング（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）。これにより、メッセージの長さが事前に決定できない場合に、このメカニズムをメッセージに使用できます。メッセージには、Content-Lengthヘッダーフィールドと非ID転送コーディングの両方を含めることはできません。メッセージに非アイデンティティ転送コーディングが含まれている場合、Content-Lengthは無視する必要があります。メッセージ本文が許可されているメッセージでContent-Lengthを指定する場合、そのフィールド値はメッセージ本文のOCTETの数と正確に一致する必要があります。HTTP / 1.1ユーザーエージェントは、無効な長さが受信および検出されたときにユーザーに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">2つのURNが対応しているのは</target>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">範囲の単位はバイトです。</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">範囲が指定される単位。これは通常 &lt;code&gt;bytes&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d38ef4967199ab3d3fb64a4af1f2610ad2fb5dab" translate="yes" xml:space="preserve">
          <source>The user has not specified a preference about tracking.</source>
          <target state="translated">ユーザーは、トラッキングに関する設定を指定していません。</target>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">ユーザーは与えられた時間内にあまりにも多くのリクエストを送信しました(「レート制限」)。</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">ユーザーは、ターゲットサイトで追跡されたくないことを希望しています。</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">ユーザーは、ターゲットサイトでのトラッキングを許可することを好みます。</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">ユーザーは、政府によって検閲されたウェブページなどの違法なリソースを要求します。</target>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">ユーザーのDNT設定は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt;プロパティを使用してJavaScriptから読み取ることもできます。</target>
        </trans-unit>
        <trans-unit id="ed64b46fa75921957cada3be294011ac523b15f9" translate="yes" xml:space="preserve">
          <source>The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.</source>
          <target state="translated">ユーザーエージェントは、政府によって検閲されたウェブページなど、法的に提供できないリソースを要求しました。</target>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">ユーザー名とパスワードはコロンで結合されます（ &lt;code&gt;aladdin:opensesame&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36e6a72462ef3ce7f1b58a51225794379cf53bdb" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報のあるリクエストでは、特別なセマンティクスのないリテラルヘッダー名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。</target>
        </trans-unit>
        <trans-unit id="26cfba7c951a6edda6e1e994a33a34814751c61e" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics. Note that the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報のあるリクエストでは、特別なセマンティクスのないリテラルヘッダー名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。&lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;ヘッダーはワイルドカード化できず、常に明示的にリストする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="854a2275bb7da001005de950b8d6724a4e032a0a" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal method name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報を含むリクエストでは、特別なセマンティクスのないリテラルメソッド名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。</target>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">プロパティの値は常に（整形式の）XMLフラグメントです。 XMLは、豊富なスキーマ定義をサポートする柔軟で自己記述的な構造化データ形式であり、複数の文字セットをサポートするために選択されました。 XMLの自己記述的な性質により、要素を追加することにより、プロパティの値を拡張できます。元のスキーマで指定されたデータがまだあり、理解できない要素を無視する必要があるため、拡張機能に遭遇してもクライアントは壊れません。 XMLの複数の文字セットのサポートにより、人間が読めるプロパティをエンコードして、ユーザーが使い慣れた文字セットで読み取ることができます。 &quot;xml：lang&quot;属性を使用した、複数の人間の言語に対するXMLのサポート同じ文字セットが複数の人間の言語で使用されているケースを処理します。 xml：langスコープは再帰的であることに注意してください。したがって、プロパティ名要素を含む要素のxml：lang属性は、よりローカルなスコープの属性によってオーバーライドされない限り、プロパティ値に適用されます。プロパティは1つの言語で1つの値のみを持つことに注意してください（または言語は未定義のままにすることができます）。プロパティには、異なる言語の複数の値や複数の言語の単一の値はありません。プロパティは常に、「プロパティ名要素」と呼ばれるプロパティ名で構成されるXML要素で表されます。最も単純な例は空のプロパティで、これは存在しないプロパティとは異なります：&amp;lt;R：title xmlns：R = &quot;http://www.example.com/ns/&quot;&amp;gt; &amp;lt;/ R：title&amp;gt;プロパティの値は、プロパティ名要素内に表示されます。値は、テキストのみのコンテンツと混合コンテンツの両方を含む、あらゆる種類の整形式のXMLコンテンツです。サーバーは、次のXML情報アイテムを保存する必要があります（[&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ]）無効なプロパティの保存と送信：プロパティ名の場合要素情報アイテム自体：[名前空間名] [ローカル名] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ]「xml：lang」という名前またはそのようなスコープ内の任意の属性[ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;子&lt;/a&gt; ]タイプ要素または文字のプロパティ値のすべての要素情報項目：[名前空間名] [ローカル名] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;子&lt;/a&gt;]要素または文字の型プロパティ値の属性情報項目：[名前空間名] [ローカル名] [正規化値]プロパティ値の文字情報項目：[文字コード]一部のXMLボキャブラリで接頭辞が使用されているため（XPath例えばXMLスキーマは、）、サーバは価値の情報項目のために、保存すべき：[ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;プレフィックス&lt;/a&gt; ] XML情報セットは、MAY、上記に記載されていない属性は、サーバによって保存されますが、クライアントはそれらが保存されている当てにしてはいけません。上記のルールは、特に定義されていない限り、デフォルトでライブプロパティにも適用されます。サーバーは、XML属性xml：spaceが存在する場合は無視し、空白処理を変更するために決して使用してはなりません（MUST）。プロパティ値の空白は重要です。</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">値 &lt;code&gt;*&lt;/code&gt; （すべての起点に対して有効）または &lt;code&gt;'none'&lt;/code&gt; （すべての起点に対して無効）は単独でのみ使用できますが、 &lt;code&gt;'self'&lt;/code&gt; および &lt;code&gt;'src'&lt;/code&gt; は1つ以上の起点で使用できます。</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">値 &lt;code&gt;*&lt;/code&gt; （すべての起点に対して有効）または &lt;code&gt;'none'&lt;/code&gt; （すべての起点に対して無効）は単独でのみ使用できますが、 &lt;code&gt;'self'&lt;/code&gt; は1つ以上の起点で使用できます。</target>
        </trans-unit>
        <trans-unit id="41c9624006fed0c69222297d2493c20e75ba3334" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;SameSite&lt;/code&gt; attribute are case-insensitive.</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 属性の値では、大文字と小文字は区別されません。</target>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">バージョン番号は関係ありません。これらをもとに資料を推測することは避けてください。</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">彼らが従うHTTPプロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">HTTP プロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">など、使用したプロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">警告文には、人間のユーザに提示するか、ログに記録される任意の情報を含めることができる。この警告を受信したシステムは、ユーザに警告を提示する以外に、いかなる自動化された行動もとってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">警告文には、人間のユーザに提示される任意の情報や、ログに記録される情報を含めることができます。この警告を受けたシステムは、自動化された行動をとってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">ウェブでは、悪用されるとプライバシーやセキュリティ上のリスクがある機能やAPIを提供しています。場合によっては、そのような機能がウェブサイトで使用される方法を厳密に制限したい場合があります。ウェブサイト内の特定のオリジンやフレームに対して機能の有効化/無効化を可能にするポリシー制御機能があります。利用可能な場合には、この機能はパーミッション API と統合されているか、または機能固有のメカニズムを使用して、その機能が利用可能かどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">最新の仕様で言及されているワイルドカード値(*)は、ブラウザではまだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;HTML5ボイラープレートプロジェクトは、&lt;/a&gt;上の例であり&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;、他の1つのドメインにリダイレクトするようにApacheサーバーを構成する方法を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 要素に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性を含めます。</target>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">そうすれば、クライアントはJSONのバージョンがその特定のURLで利用可能であることを覚えていて、次回そのドキュメントをリクエストするときにコンテンツのネゴシエーションをスキップすることができます。</target>
        </trans-unit>
        <trans-unit id="ccd8b24095654e9f5577f70574da438aa878682b" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you determine is appropriate.</source>
          <target state="translated">その後、レポートを受信するためにサーバーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">その後、レポートを受信するためにサーバーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="303618442946db88c6e44665ba0c19fde299ff1f" translate="yes" xml:space="preserve">
          <source>Then, with every subsequent request to the server, the browser sends back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">その後、サーバーへの後続のすべての要求で、ブラウザーは&lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して以前に保存されたすべてのCookieをサーバーに送り返します。</target>
        </trans-unit>
        <trans-unit id="02072bbfa0f86f96f0652069e08e342de2f1a9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to ensure that cookies are sent securely and are not accessed by unintended parties or scripts: the &lt;code&gt;Secure&lt;/code&gt; attribute and the &lt;code&gt;HttpOnly&lt;/code&gt; attribute.</source>
          <target state="translated">：クッキーが安全に送信され、意図しないパーティーやスクリプトによってアクセスされていないことを確認する方法はいくつかあり &lt;code&gt;Secure&lt;/code&gt; 属性と &lt;code&gt;HttpOnly&lt;/code&gt; の属性が。</target>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">要求メッセージと応答メッセージの両方に一般的に適用できるヘッダーフィールドがいくつかありますが、転送されるエンティティには適用されません。これらのヘッダーフィールドは、送信されるメッセージにのみ適用されます。 general-header = Cache-Control; &lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt; |接続; &lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt; |日付; &lt;a href=&quot;#section-14.18&quot;&gt;セクション14.18&lt;/a&gt; |プラグマ; &lt;a href=&quot;#section-14.32&quot;&gt;セクション14.32&lt;/a&gt; |トレーラー; &lt;a href=&quot;#section-14.40&quot;&gt;セクション14.40&lt;/a&gt; | Transfer-Encoding; &lt;a href=&quot;#section-14.41&quot;&gt;セクション14.41&lt;/a&gt; |アップグレード;&lt;a href=&quot;#section-14.42&quot;&gt;セクション14.42&lt;/a&gt; |経由; &lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt; |警告; &lt;a href=&quot;#section-14.46&quot;&gt;セクション14.46&lt;/a&gt; General-Headerフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての当事者がそれらを一般ヘッダーフィールドであると認識する場合、新規または実験的なヘッダーフィールドに一般ヘッダーフィールドのセマンティクスが与えられることがあります。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">稀にこんなことが起こることがあります。</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">HTTP認証フレームワークには、新しい認証スキームが機能する方法に制約を課す特定の側面があります。oHTTP認証はステートレスであると推定されます。要求の認証に必要なすべての情報は、依存するのではなく、要求で提供する必要があります。サーバーは以前のリクエストを記憶しています。基になる接続に基づく、またはバインドされている認証は、この仕様の範囲外であり、認証されたユーザー以外の者が接続を使用できないようにするための手順を講じない限り、本質的に欠陥があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]のセクション2.3を&lt;/a&gt;参照） 。 o認証パラメータ「レルム」は、&lt;a href=&quot;#section-2.2&quot;&gt;セクション2.2で&lt;/a&gt;説明されている保護スペースを定義するために予約されています。。新しいスキームは、その定義と互換性のない方法でそれを使用してはなりません。 o「token68」表記は、既存の認証スキームとの互換性のために導入され、チャレンジまたは資格情報ごとに1回のみ使用できます。したがって、新しいスキーマでは代わりにauth-param構文を使用する必要があります。そうしないと、将来の拡張が不可能になるためです。 oチャレンジと資格情報の解析は、この仕様で定義されており、新しい認証スキームで変更することはできません。 auth-param構文を使用する場合、すべてのパラメーターはトークンと引用符付き文字列の両方の構文をサポートする必要があり、構文制約は解析（つまり引用符付き文字列処理）後にフィールド値に定義する必要があります。これは、受信者がすべての認証スキームに適用される汎用パーサーを使用できるようにするために必要です。注：「レルム」パラメーターの値の構文がquoted-stringに制限されているという事実は、新しいパラメーターに対して繰り返さないようにするための設計上の選択として不適切でした。 o新しいスキームの定義は、未知の拡張パラメータの扱いを定義する必要があります。一般に、「無視する必要がある」ルールは、「理解する必要がある」ルールよりも望ましいです。そうしないと、レガシー受信者が存在する場合に新しいパラメーターを導入することが困難になるためです。さらに、新しいパラメーターを定義するためのポリシー（「仕様の更新」や「このレジストリーの使用」など）を記述することは良いことです。o認証スキームは、それらがオリジンサーバー認証（つまり、WWW-Authenticateを使用）、および/またはプロキシ認証（つまり、Proxy-Authenticateを使用）で使用可能かどうかを文書化する必要があります。 o Authorizationヘッダーフィールドに含まれる認証情報はユーザーエージェントに固有であるため、HTTPキャッシュには「プライベート」のCache-Control応答ディレクティブ（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;[RFC7234]のセクション5.2.2.6&lt;/a&gt;）、それらが現れるリクエストの範囲内。したがって、Authorizationヘッダーフィールドに資格情報を保持しないことを選択する新しい認証スキーム（たとえば、新しく定義されたヘッダーフィールドを使用）は、いずれかのCache-Controlリクエストディレクティブ（たとえば、「no-ストア」、&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;[RFC7234]のセクション5.2.1.5&lt;/a&gt;）または応答ディレクティブ（「プライベート」など）。</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;正規の&lt;/em&gt; Webサイトを選択する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">レンダリングエンジンには大きく分けて5つのエンジンがあります。Trident、Gecko、Presto、Blink、WebKitです。レンダリングエンジン名をスニッフするのが一般的なため、多くのユーザーエージェントが他のレンダリングエンジン名を追加して検出のトリガーにしています。そのため、レンダリングエンジンを検出する際には、誤検出を誘発しないように注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">使用に関する法的要件や技術的要件はありませんが、&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、Webアプリケーションが個々のユーザーのトラッキングまたはクロスサイトユーザートラッキングを無効にする必要があることを通知できます。詳細については、&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;ヘッダーを参照してください。</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">多数のリクエストヘッダが利用可能です。それらはいくつかのグループに分けることができます。</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">レスポンスヘッダは多数用意されています。これらはいくつかのグループに分けることができます。</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">リダイレクトには多くのユースケースがありますが、リダイレクトごとにパフォーマンスに影響を与えるため、その使用は最小限に抑えるべきです。</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">キャッシュにはいくつかの種類があります。これらは、プライベートキャッシュと共有キャッシュの2つの主なカテゴリに分類できます。&lt;em&gt;共有キャッシュは&lt;/em&gt;キャッシュされ、複数のユーザーによる再利用のための店舗応答います。&lt;em&gt;プライベートキャッシュは&lt;/em&gt;、単一のユーザーに捧げられています。このページでは、主にブラウザーとプロキシキャッシュについて説明しますが、WebサイトとWebアプリケーションの信頼性、パフォーマンス、スケーリングを向上させるために、ゲートウェイキャッシュ、CDN、リバースプロキシキャッシュ、ロードバランサーもWebサーバーに導入されています。</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">ユーザーエクスペリエンスに悪影響を与える可能性のある機能を表現するために設計されたポリシー制御機能がいくつかあります。これらの機能には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">良いパフォーマンスとユーザーエクスペリエンスを提供するためのベストプラクティスを実施するために、いくつかのポリシー制御機能があります。</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">リダイレクトにはいくつかの種類があり、永久的なもの、一時的なもの、特別なものの3つに分類されます。</target>
        </trans-unit>
        <trans-unit id="8b2d63fe70a304442a6a486676e591c0916f939e" translate="yes" xml:space="preserve">
          <source>There are several types of redirects, sorted into three categories:</source>
          <target state="translated">リダイレクトにはいくつかの種類があり、3つのカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; には、次の3つのディレクティブがあります。</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">範囲リクエストを扱う際には、3つの関連するステータスがあります。</target>
        </trans-unit>
        <trans-unit id="0fff28c9c934766aefa1ed8d526b79ea9e2c24ef" translate="yes" xml:space="preserve">
          <source>There are too many &lt;a href=&quot;../cookies&quot;&gt;Cookies&lt;/a&gt; sent in the request</source>
          <target state="translated">リクエストで送信された&lt;a href=&quot;../cookies&quot;&gt;Cookie&lt;/a&gt;が多すぎます</target>
        </trans-unit>
        <trans-unit id="ce50cfd249603fdf3debd56f0ffcb691991a174f" translate="yes" xml:space="preserve">
          <source>There are two classes of type: &lt;strong&gt;discrete&lt;/strong&gt; and &lt;strong&gt;multipart&lt;/strong&gt;. Discrete types are types which represent a single file or medium, such as a single text or music file, or a single video. A multipart type is one which represents a document that's comprised of multiple component parts, each of which may have its own individual MIME type; or, a multipart type may encapsulate multiple files being sent together in one transaction. For example, multipart MIME types are used when attaching multiple files to an email.</source>
          <target state="translated">タイプには、&lt;strong&gt;離散&lt;/strong&gt;と&lt;strong&gt;マルチパートの&lt;/strong&gt;2つのクラスがあります。ディスクリートタイプは、単一のテキストや音楽ファイル、または単一のビデオなど、単一のファイルまたはメディアを表すタイプです。マルチパートタイプは、複数のコンポーネントパーツで構成されるドキュメントを表すタイプであり、各コンポーネントには独自のMIMEタイプがあります。または、マルチパートタイプは、1つのトランザクションで一緒に送信される複数のファイルをカプセル化する場合があります。たとえば、マルチパートMIMEタイプは、複数のファイルを電子メールに添付するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">一般的な使用例は2つあります。</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">比較コンテキストで弱いバリデータの使用が許可されているかどうかによって、2 つのエンティティ タグ比較関数があります。 o 強い比較:2 つのエンティティ タグが両方とも弱いものではなく、不透明タグが文字ごとに一致している場合、2 つのエンティティ タグは等価です。以下の例は、エンティティタグのペアのセットの結果と、弱い比較と強い比較関数の両方の結果を示しています。+W/&quot;1&quot; | W/&quot;1&quot; | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">コレクション書き込みロックには2種類あります。コレクションの深さ0の書き込みロックは、コレクションプロパティとその1つのコレクションの内部メンバーURLを保護しますが、メンバーリソースのコンテンツまたはプロパティは保護しません（コレクション自体にエンティティボディがある場合、それらも保護されます）。コレクションに対する深さ無限の書き込みロックは、そのコレクションに対して同じ保護を提供し、すべてのメンバーリソースに対して書き込みロック保護も提供します。他の方法で表現すると、いずれかの種類の書き込みロックは、書き込みロックされたコレクションに新しいリソースを作成するすべての要求、書き込みロックされたコレクションの内部メンバーURLを削除するすべての要求、および任意のセグメント名を変更するすべての要求を保護します内部メンバー。したがって、コレクションの書き込みロックは、次のすべてのアクションを保護します。oコレクションの直接の内部メンバーを削除します。oコレクションから内部メンバーを移動します。o内部メンバーをコレクションに移動します。oMOVEは、コレクション内の内部メンバーの名前を変更します。oCOPYコレクションへの内部メンバー、および新しい内部メンバーを作成するPUTまたはMKCOL要求。個別にロックされている場合は、内部メンバー自体のロックトークンに加えて、コレクションのロックトークンが必要です。さらに、深さ無限ロックは、ロックされたコレクションのすべてのメンバーに対するすべての書き込み操作に影響します。深さ無限ロックでは、ロックのルートによって識別されるリソースが直接ロックされ、そのすべてのメンバーが間接的にロックされます。o深さ無限のロックされたコレクションの子孫として追加された新しいリソースは、間接的にロックされます。 oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;、ポイント3）、リクエストは423（ロック済み）ステータスコードで失敗する必要があり、応答には「no-conflicting-lock」前提条件が含まれている必要があります（SHOULD）。ロック要求によってリソースのURLが深さ無限のロックされたコレクションの内部メンバーURLとして追加される場合、新しいリソースはロックによって自動的に保護される必要があります。たとえば、コレクション/ a / b /が書き込みロックされていて、リソース/ cが/ a / b / cに移動された場合、リソース/ a / b / cが書き込みロックに追加されます。</target>
        </trans-unit>
        <trans-unit id="d5dc7184e37e2ac541668d7dc3337de81f5981e3" translate="yes" xml:space="preserve">
          <source>There are two multipart types:</source>
          <target state="translated">マルチパートタイプは2種類あります。</target>
        </trans-unit>
        <trans-unit id="d0970064e3114d24ebea32cf716e29a9559cf977" translate="yes" xml:space="preserve">
          <source>There are two possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; には2つの可能なディレクティブがあります。</target>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">HTTP メッセージにはリクエストとレスポンスの 2 種類があり、それぞれ独自のフォーマットを持っています。</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">プロキシには2つのタイプがあります。&lt;strong&gt;フォワードプロキシ&lt;/strong&gt;（またはトンネル、またはゲートウェイ）と&lt;strong&gt;リバースプロキシ&lt;/strong&gt;（負荷分散、認証、復号化、またはキャッシュのためにサーバーへのアクセスを制御および保護するために使用）です。</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">このリストにWebP（ &lt;code&gt;image/webp&lt;/code&gt; ）を追加することについての議論がありますが、ブラウザーベンダーはそれを受け入れることに慎重です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
