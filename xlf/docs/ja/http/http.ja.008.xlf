<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">アスタリスクは、リソースを表す特別な値です。通常は&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;を使用してリソースをアップロードする場合にのみ、IDを持つ別のリソースがすでにアップロードされているかどうかを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">request-targetのアスタリスク形式は、サーバー全体のOPTIONSリクエストにのみ使用されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;[RFC7231]のセクション4.3.7&lt;/a&gt;）。 asterisk-form = &quot;*&quot;クライアントがそのサーバーの特定の名前付きリソースではなく、サーバー全体のOPTIONSを要求する場合、クライアントは要求ターゲットとして &quot;*&quot;（％x2A）のみを送信する必要があります。たとえば、OPTIONS * HTTP / 1.1 URIが空のパスを持ち、クエリコンポーネントがない絶対形式のrequest-targetを含むOPTIONSリクエストをプロキシが受信した場合、リクエストチェーンの最後のプロキシはリクエストを送信する必要があります。指定されたオリジンサーバーにリクエストを転送するときの「*」のターゲット。たとえば、リクエストOPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP / 1.1は、最終プロキシによってOPTIONS * HTTP / 1.1 Host：www.example.org:8001としてホスト「www.example.org」のポート8001に接続した後に転送されます。</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">ドメイン名とオプションでポート（ &lt;code&gt;':'&lt;/code&gt; 始まる）で構成されるURLの認証コンポーネントは、&lt;em&gt;認証フォーム&lt;/em&gt;と呼ばれます。HTTPトンネルをセットアップするときに、 &lt;code&gt;CONNECT&lt;/code&gt; でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">request-targetのauthority-formは、CONNECTリクエストにのみ使用されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6&lt;/a&gt;）。Authority-form = authority CONNECTリクエストを作成して1つまたは複数のプロキシを介してトンネルを確立する場合、クライアントはターゲットURIの権限コンポーネント（userinfoとその「@」区切り文字を除く）のみをリクエストターゲットとして送信する必要があります。たとえば、CONNECT www.example.com:80 HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">auto-configファイルは拡張子が.pacのファイルに保存されている必要があります。</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">auto-configファイルは、ファイル名拡張子が &lt;code&gt;.pac&lt;/code&gt; のファイルに保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="97bb2f02d88593e20d553e3a3a22148f46c0a1bc" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; environment variable in CGI).</source>
          <target state="translated">autoconfigファイルはCGIスクリプトで出力できます。これは、たとえば、autoconfigファイルがクライアントIPアドレス（CGIの &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 環境変数）に基づいて異なる動作をする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">自動設定ファイルはCGIスクリプトで出力することができます。これは例えば、クライアントの IP アドレス (CGI の環境変数 REMOTE_ADDR)に応じて自動設定ファイルの動作を変える場合に便利です。</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1の基本的なキャッシュメカニズム（サーバー指定の有効期限とバリデーター）は、キャッシュへの暗黙のディレクティブです。場合によっては、サーバーまたはクライアントがHTTPキャッシュに明示的なディレクティブを提供する必要があります。この目的のために、Cache-Controlヘッダーを使用します。 Cache-Controlヘッダーを使用すると、クライアントまたはサーバーは、要求または応答でさまざまなディレクティブを送信できます。これらのディレクティブは通常、デフォルトのキャッシュアルゴリズムをオーバーライドします。原則として、ヘッダー値の間に明らかな矛盾がある場合は、最も制限的な解釈が適用されます（つまり、セマンティックの透明性を維持する可能性が最も高い解釈）。ただし、場合によっては、キャッシュ制御ディレクティブがセマンティックの透過性の近似を弱めるものとして明示的に指定されています（たとえば、「max-stale」または「パブリック」）。キャッシュ制御ディレクティブについては、&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">クライアント-サーバプロトコルの基本的な機能:クライアント-サーバプロトコルで何ができるのか、そしてその目的とする用途について説明します。</target>
        </trans-unit>
        <trans-unit id="0a4f8aeb61f05bae2255b7ec47533f259568b8c3" translate="yes" xml:space="preserve">
          <source>The below status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;. You can find an updated specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC 7231&lt;/a&gt;.</source>
          <target state="translated">以下のステータスコードは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;、RFC2616のセクション10で&lt;/a&gt;定義されています。更新された仕様は&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC7231にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">ブラウザは&lt;strong&gt;常に&lt;/strong&gt;要求を開始するエンティティです。これは決してサーバーではありません（サーバーによって開始されたメッセージをシミュレートするために長年にわたっていくつかのメカニズムが追加されていますが）。</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">ブラウザのバージョンは、常にではありませんが、ユーザーエージェント文字列の&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;トークンの値の部分にあることがよくあります。もちろん、これはInternet Explorer（MSIEトークンの直後にバージョン番号を配置する）や、バージョン/バージョン&lt;em&gt;番号&lt;/em&gt;トークンを追加したバージョン10以降のOperaには&lt;em&gt;当てはまりません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">ブラウザは30分後に以前に応答しなかったプロキシを自動的に再試行します。追加の試行は 1 時間から始まり、試行間の経過時間に常に 30 分を加算します。</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">キャッシュはネットワークの他の部分から切り離されています。</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">キャッシュは使用する前に古いリソースの状態を確認しなければならず、期限切れのものは使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">キャッシュはクライアントのリクエストやサーバのレスポンスについて何も保存してはいけません。</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">キャッシュはクライアントのリクエストやサーバーのレスポンスについて何も保存してはいけません。リクエストはサーバに送信され、完全なレスポンスは毎回ダウンロードされます。</target>
        </trans-unit>
        <trans-unit id="7ca27201de90dba7af54bed9d5fa78a31a2d3e2e" translate="yes" xml:space="preserve">
          <source>The challenge and response flow works like this:</source>
          <target state="translated">チャレンジ&amp;レスポンスの流れはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">文字コードの規格です。</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">チャンク化されたエンコーディングでは、チャンクごとのメタデータ(署名やハッシュなど)、メッセージ中間制御情報、メッセージボディサイズのランダム化などを提供するために、各チャンクにチャンクサイズの直後に、0個以上のチャンク拡張を含めることができます。chunk-ext=*(&quot;;&quot; chunk-ext-name[&quot;=&quot; chunk-ext-val])chunk-ext-name=token chunk-ext-val=token/quoted-string チャンク化されたエンコーディングは各接続に固有のものであり、 高レベルのアプリケーションが拡張を検査する機会を持つ前に、各受信者(仲介者を含む)によって削除されたり、再コード化されたりする可能性が高い。したがって、チャンク拡張の使用は一般的に「ロングポーリング」(クライアントとサーバがチャンク拡張の使用に関して期待を共有することができる)やエンドツーエンドのセキュアな接続内でのパディングなどの特殊なHTTPサービスに限定されます。受信者は認識されていないチャンク拡張を無視しなければならない[MUST]。サーバーは、メッセージの他の部分に長さ制限とタイムアウトを適用するのと同じように、 リクエストで受け取ったチャンク拡張の合計長さを、提供されるサービスに 適した量に制限するべきである。</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">チャンクエンコーディングは、メッセージボディを変更して、それぞれに独自のサイズインジケーターが付いた一連のチャンクとして転送し、その後にエンティティヘッダーフィールドを含むオプションのトレーラーを続けます。これにより、動的に生成されたコンテンツを、受信者が完全なメッセージを受信したことを確認するために必要な情報とともに転送できます。 Chunked-Body = * chunk last-chunk trailer CRLF chunk = chunk-size [chunk-extension] CRLF chunk-data CRLF chunk-size = 1 * HEX last-chunk = 1 *（ &quot;0&quot;）[chunk-extension] CRLF chunk-extension = *（ &quot;;&quot; chunk-ext-name [&quot;=&quot;chunk-ext-val]）chunk-ext-name = token chunk-ext-val = token | quoted-string chunk-data = chunk-size（OCTET）trailer = *（entity-header CRLF）chunk-sizeフィールドは、チャンクのサイズを示す16進数の文字列です。チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（チャンクエンコーディングは、サイズがゼロのチャンクで終了し、その後にトレーラが続き、空行で終了します。トレーラーにより、送信者はメッセージの最後に追加のHTTPヘッダーフィールドを含めることができます。トレーラーヘッダーフィールドを使用して、トレーラーに含めるヘッダーフィールドを指定できます（ &lt;a href=&quot;#section-14.40&quot;&gt;セクション14.40&lt;/a&gt;）。応答でチャンク転送コーディングを使用するサーバーは、次のいずれかに該当しない限り、ヘッダーフィールドにトレーラーを使用してはなりません（MUST）：a）要求に、「トレーラー」が転送コーディングで受け入れられることを示すTEヘッダーフィールドが含まれていた&lt;a href=&quot;#section-14.39&quot;&gt;セクション14.39で&lt;/a&gt;説明されている応答の ;または、b）サーバーは応答のオリジンサーバーであり、トレーラーフィールドは完全にオプションのメタデータで構成され、受信者はこのメタデータを受信せずにメッセージを（オリジンサーバーに受け入れられる方法で）使用できます。言い換えると、オリジンサーバーは、トレーラーフィールドがクライアントへのパスに沿って静かに破棄される可能性を受け入れる用意があります。この要件により、メッセージがHTTP / 1.1（またはそれ以降）のプロキシによって受信され、HTTP / 1.0受信者に転送されるときの相互運用性の障害が防止されます。これは、プロトコルに準拠するためにプロキシ上に無限のバッファが必要になる可能性がある状況を回避します。 Chunked-Bodyをデコードするプロセスの例を付録19.4.6に示します。すべてHTTP / 1。1つのアプリケーションは、「チャンクされた」転送コーディングを受信およびデコードできなければならず、また、理解できないチャンク拡張拡張を無視しなければなりません（MUST）。</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">チャンク化された転送コーディングは、ペイロードを一連のチャンクとして転送するために、ペイロード本体をラップし、それぞれが独自のサイズインジケータを持ち、その後にヘッダフィールドを含む OPTIONAL トレーラーが続く。これにより、送信者は接続の持続性を保持し、受信者はいつメッセージ全体を受信したかを知ることができます。chunked-body=*chunk last-chunk trailer-part CRLF chunk=chunk-size[chunk-ext]CRLF chunk-data CRLF chunk-size=1*HEXDIG last-chunk=1*(&quot;0&quot;)[chunk-ext]CRLF chunk-data=1*OCTET;a sequence of chunk-size octets チャンクサイズオクテットのシーケンス chunk-sizeフィールドは、オクテット単位でのチャンクデータのサイズを示す16進数の文字列である。チャンク化された転送コーディングは、チャンクサイズが0のチャンクが受信されたときに完了し、トレーラーが続く可能性があり、最後に空行で終了する。受信者はチャンク化された転送コーディングを解析してデコードできなければならない (MUST)。</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">クライアントのIPアドレス</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">クライアントはリクエストを続行する必要があります。この暫定応答は、要求の最初の部分が受信され、サーバーによってまだ拒否されていないことをクライアントに通知するために使用されます。クライアントは、残りのリクエストを送信して続行する必要があります。リクエストがすでに完了している場合は、このレスポンスを無視してください。リクエストが完了した後、サーバーは最終応答を送信する必要があります。このステータスコードの使用と処理の詳細については、&lt;a href=&quot;#section-8.2.3&quot;&gt;セクション8.2.3&lt;/a&gt;を参照してください 。</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">クライアントは、サーバーが待つ準備ができた時間内にリクエストを生成しなかった。クライアントは、後のいつでも修正せずにリクエストを繰り返してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">クライアントはコンテンツへのアクセス権を持っていない、つまり権限がないので、サーバは適切な応答を与えることを拒否しています。401とは異なり、クライアントの身元はサーバに知られています。</target>
        </trans-unit>
        <trans-unit id="20c408742f6f7b483f2e5d78c14bc1e7549de56d" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">クライアントはコンテンツへのアクセス権を持っていません。つまり、権限がないので、サーバは要求されたリソースの提供を拒否しています。401とは異なり、クライアントの身元はサーバに知られています。</target>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">クライアントはTCP接続(トランスポートレイヤーがTCPでない場合は適切な接続)を確立する。</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">クライアントは、サーバが満たさない前提条件をヘッダで指定しています。</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">クライアントは正規ドメインにリクエストを発行します： &lt;code&gt;http://example.org/whatddup&lt;/code&gt; : //example.org/whatddup</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">クライアントはリクエストを送信し、回答を待ちます。</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">クライアントは、この要求をそのまま繰り返してはいけません。</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">リクエストを開始したクライアントと、それに続くプロキシのチェーンのプロキシ。</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">以下に定義されているコードは、メッセージのペイロードを圧縮するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="971adc7eb81ae93f06509fafd469f5eea13bda5b" translate="yes" xml:space="preserve">
          <source>The comma-separated list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">許可される&lt;a href=&quot;../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;のコンマ区切りのリスト。</target>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">一般的な使用例は、ユーザーに表示されるページの現在のコンテンツを変更せずに、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;リクエストの結果として &lt;code&gt;204&lt;/code&gt; を返し、リソースを更新することです。リソースが作成されると、代わりに&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; が返されます。ページを新しく更新されたページに変更する必要がある場合は、代わりに&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">このステータスコードの一般的な使用例は、&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストの結果です。</target>
        </trans-unit>
        <trans-unit id="5dee61655e811dbf764699bfb5c6ab2c8de25fd2" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. If a listed &lt;code&gt;ETag&lt;/code&gt; has the &lt;code&gt;W/&lt;/code&gt; prefix indicating a weak entity tag, it will never match under this comparison algorithm.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;強力な比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルはバイト間でのみ同一と見なされます。リストされた &lt;code&gt;ETag&lt;/code&gt; に弱いエンティティタグを示す &lt;code&gt;W/&lt;/code&gt; プレフィックスが付いている場合、この比較アルゴリズムでは一致しません。</target>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;強力な比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルはバイト間で同一と見なされます。 &lt;code&gt;W/&lt;/code&gt; プレフィックスが &lt;code&gt;ETag&lt;/code&gt; の前で使用されると、これは弱くなります。</target>
        </trans-unit>
        <trans-unit id="72daedd3e8f61f2659bcac2190d51fd4c98967f8" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical if the content is equivalent &amp;mdash; they don't have to be identical byte for byte. For example, two pages that differ by the date of generation in the footer would still be considered as identical.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;弱い比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、コンテンツが同等である場合、2つのファイルは同一であると見なされます。つまり、バイトごとに同一である必要はありません。たとえば、フッターの生成日が異なる2つのページは、引き続き同一と見なされます。</target>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">保存された&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;との比較では、&lt;em&gt;弱い比較アルゴリズムが&lt;/em&gt;使用され&lt;em&gt;ます&lt;/em&gt;。つまり、2つのファイルがバイト間で同一である場合だけでなく、内容が同等である場合でも、2つのファイルは同一であると見なされます。たとえば、フッターの生成日のみが異なる2つのページは同一と見なされます。</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">このページの互換性テーブルは、構造化データから生成されます。データに貢献したい場合は、&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https：//github.com/mdn/browser-compat-data&lt;/a&gt;を確認し、プルリクエストを送信してください。</target>
        </trans-unit>
        <trans-unit id="8eddfd7122309a2d42352867b0fa5b1e063c2c65" translate="yes" xml:space="preserve">
          <source>The concept was originally proposed in 2012 (as</source>
          <target state="translated">このコンセプトは、2012年に提唱されたものです(</target>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">HPKPヘッダの配信に必要な具体的な手順は、使用するWebサーバによって異なります。</target>
        </trans-unit>
        <trans-unit id="c5a34df8c7328504dee9ce9f1c7756c81918158f" translate="yes" xml:space="preserve">
          <source>The connection failed due to errors in HTTP protocol not covered by previous errors</source>
          <target state="translated">以前のエラーではカバーされていない HTTP プロトコルのエラーが原因で接続に失敗しました。</target>
        </trans-unit>
        <trans-unit id="77b1cd5615c2676730c21d276af1a317e38fc749" translate="yes" xml:space="preserve">
          <source>The connection was aborted due to an HTTP protocol error</source>
          <target state="translated">HTTPプロトコルエラーにより接続が中断されました。</target>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">このコンテンツやコンセプトは、Atom コミュニティと Atompub Working Group の成果です。</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">「app：accept」要素の値の内容は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されているメディア範囲です。メディア範囲は、コレクションにPOSTできる表現のタイプを指定します。 app：accept要素は、HTTP Acceptリクエストヘッダー[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]に似ています。メディアタイプパラメータはapp：accept内で許可されますが、app：acceptには優先順位の概念はありません。&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;[RFC2616]のセクション14.1で&lt;/a&gt;指定されている「accept-params」または「q」引数は重要ではありません。空白（[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]）app：accept要素のメディア範囲は重要ではなく、無視する必要があります。 「application / atom + xml; type = entry」の値は、どのアプリにも表示される場合があります。メディア範囲のリストを受け入れ、AtomエントリドキュメントをコレクションにPOSTできることを示します。 app：accept要素が存在しない場合、クライアントはこれを、コンテンツが &quot;application / atom + xml; type = entry&quot;のapp：accept要素と同等であると見なすべきです。 1つのapp：accept要素が存在し、空の場合、クライアントは、コレクションが新しいエントリの作成をサポートしていないと想定する必要があります（SHOULD）。 appAccept = element app：accept {appCommonAttributes、（text？）}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">コンテンツセキュリティポリシー</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">上記で作成されたCookieは&lt;em&gt;セッションCookie&lt;/em&gt;です &lt;code&gt;Expires&lt;/code&gt; または &lt;code&gt;Max-Age&lt;/code&gt; ディレクティブを指定していないため、クライアントがシャットダウンすると削除されます。ただし、ウェブブラウザは&lt;strong&gt;セッションの復元を&lt;/strong&gt;使用する場合があります。これにより、ブラウザが閉じられなかったかのように、ほとんどのセッションCookieが永続的になります。</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">ロックの作成者には、ロックを使用してリソースを変更するための特別な特権があります。ロックされたリソースが変更されると、サーバーは、認証されたプリンシパルがロックの作成者と一致することを確認する必要があります（有効なロックトークン送信の確認に加えて）。サーバーは、ロックの作成者以外の特権ユーザーがロックを破棄することを許可する場合があります（たとえば、リソースの所有者や管理者）。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;の「ロック解除」権限]その許可を提供するために定義されました。サーバーがすべてのユーザーまたは匿名ユーザーからのLOCK要求を受け入れる必要はありません。ロックしても、ロックされたリソースを変更するための完全な権限は付与されないことに注意してください。書き込みアクセスおよびその他の特権は、ロックトークン値の不明瞭さに基づいてではなく、通常の特権または認証メカニズムを介して適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">クレデンシャルはこのように構成されています。</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">現在のポリシー制御された機能のセットは、2つの大まかなカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">データURLは、最初のヘッダ行の後にエンコードされたデータを使用します。</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">データURLのデータ部分は不透明であるため、データURLでクエリ文字列（ページ固有のパラメーター、構文 &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; ）を使用しようとすると、URLのデータにクエリ文字列が含まれますを表します。</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">送信されるデータはすでに圧縮されており、2回目の圧縮では送信されるデータは小さくなりません。画像フォーマットによってはこのような場合があります。</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">応答が古くなったとみなされる日時。</target>
        </trans-unit>
        <trans-unit id="0911607a468bc8e23c0901e6b8899136c11add6c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt; value is &lt;code&gt;'src'&lt;/code&gt;, so this is equivalent to:</source>
          <target state="translated">デフォルトの &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt;値は &lt;code&gt;'src'&lt;/code&gt; であるため、これは次と同等です。</target>
        </trans-unit>
        <trans-unit id="46f69faebfa441f8068a5c2a1d971d7bb75686df" translate="yes" xml:space="preserve">
          <source>The default allowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルトの許可リストは &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a21e6aaa7014c0a77730b148bd0e400306901bc7" translate="yes" xml:space="preserve">
          <source>The default alowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルトのalowlistは &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0ca00dba55294b3adb13ff2e5e265230f2df2011" translate="yes" xml:space="preserve">
          <source>The default value for unsized-media is &lt;code&gt;'*'&lt;/code&gt;, that is unsized media elements are allowed for all origins by default. The page will re-flow every time an image with unknown dimensions is loaded.</source>
          <target state="translated">サイズなしメディアのデフォルト値は &lt;code&gt;'*'&lt;/code&gt; です。つまり、サイズなしメディア要素はデフォルトですべてのオリジンに許可されます。寸法が不明な画像が読み込まれるたびに、ページがリフローします。</target>
        </trans-unit>
        <trans-unit id="c0b5d6196048d6e0193482609dd5869326eae443" translate="yes" xml:space="preserve">
          <source>The default value in &lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chrome&lt;/a&gt; is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は&lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chromeが&lt;/a&gt;ある &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87d048f49a1bc19ccb8bb277e49d40e7c59a0ae5" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'*'&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;'*'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;'self'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">コレクション状態の定義が修正されたため、Request-URIに応じて変更されることはなくなりました（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2を&lt;/a&gt;参照）。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;[RFC2518]のセクション4.6で&lt;/a&gt;導入されたDAV：sourceプロパティは、実装経験がないため削除されました。 DAVヘッダーは、コンプライアンスクラストークンに加えて、URIを介した非IETF拡張を許可するようになりました。この仕様は、ここで定義されているコンプライアンスクラスに関連するセマンティクスを定義していません（&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1を&lt;/a&gt;参照 ）。で&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;、奥行きヘッダの定義（&lt;a href=&quot;#section-9.2&quot;&gt;9.2節&lt;/a&gt;）では、デフォルトで、リクエストヘッダーをスコープ内の各リソースに適用する必要がありました。実装経験に基づいて、デフォルトが逆になりました（&lt;a href=&quot;#section-10.2&quot;&gt;セクション10.2を&lt;/a&gt;参照）。 HTTPステータスコード102（&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518]、セクション10.1&lt;/a&gt;）およびStatus-URI応答ヘッダー（&lt;a href=&quot;#section-9.7&quot;&gt;セクション9.7&lt;/a&gt;）の定義は、実装が不足しているため削除されました。 Timeoutリクエストヘッダーで使用されるTimeType形式と「timeout」XML要素は拡張可能でした。現在、この仕様で定義されている2つの形式のみが許可されています（&lt;a href=&quot;#section-10.7&quot;&gt;セクション10.7を&lt;/a&gt;参照））。著者のアドレスLisa Dusseault（editor）CommerceNet 2064 Edgewood Dr. Palo Alto、CA 94303 US EMail：ldusseault@commerce.net Copyright Copyright（C）The IETF Trust（2007）。このドキュメントは、&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78に&lt;/a&gt;含まれる権利、ライセンス、制限の対象となります。、およびそこに記載されている場合を除き、著者はすべての権利を保持します。このドキュメントとここに含まれる情報は「現状のまま」で提供され、寄稿者、彼/彼女の代表者、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません。知的財産IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用される範囲について、いかなる立場も取りません。利用できない場合があります。また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、次の場所にあります。&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。 IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可を得ようとした試みの結果を入手できます。&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;のIETFオンラインIPRリポジトリから 。 IETFは、この規格の実装に必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけています。 IEETのietf-ipr@ietf.orgに情報を送信してください。 RFC Editor機能の謝辞は、現在Internet Societyによって提供されています。 Dusseault Standards Track [ページ127]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">バリデータの弱点の定義が拡張され、明確になりました。 （&lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1&lt;/a&gt;）弱いエンティティタグは、範囲リクエストを除くすべてのリクエストで許可されるようになりました。 （セクション&lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;および&lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;）ETagヘッダーフィールドABNFは、quoted-stringを使用しないように変更され、エスケープの問題を回避しています。 （&lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt;）ETagは、選択された表現のエンティティタグを提供するために定義され、それによってさまざまな状況（PUT応答など）に適用されるものを明確にします。 （&lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt;）条件付き要求の評価の優先順位が定義されました。 （&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">delta-seconds ルールは時間を秒単位で表す非負の整数を指定します。 delta-seconds=1*DIGIT delta-seconds 値を解析してバイナリ形式に変換する受信者は、少なくとも 31 ビットの非負の整数範囲の算術型を使用しなければなりません。キャッシュが表現可能な最大の整数よりも大きいデルタ秒値を受け取った場合、またはその後の計算でオーバーフローした場合、キャッシュはその値を 2147483648 (2^31)または都合よく表現可能な最大の正の整数のいずれかと考えなければなりません(MUST)。注意:2147483648 という値は、歴史的な理由からここでは無限大(68 年以上)を事実上表しており、バイナリ形式で保存する必要はありません。ここで重要なのは、オーバーフローが検出され、後の計算で負の値として扱われないことです。</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは、コンテンツセキュリティポリシーに違反する試みを報告するようにユーザーエージェントに指示します。これらの違反レポートは、HTTP POSTリクエストを介して指定されたURIに送信されたJSONドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用してロードされた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求はユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは、コンテンツセキュリティポリシーに違反する試みを報告するようにユーザーエージェントに指示します。これらの違反レポートは、HTTP POSTリクエストを介して指定されたURIに送信されたJSONドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">非推奨のHTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; ディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用してロードされた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。ワーカーの場合、非準拠の要求はユーザーエージェントによって致命的なネットワークエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="06d89b04e62b26b8ec32aee4540211a4cdd447d1" translate="yes" xml:space="preserve">
          <source>The design of the cookie mechanism is such that a server is unable to confirm that a cookie was set on a secure origin or even to tell &lt;em&gt;where&lt;/em&gt; a cookie was originally set.</source>
          <target state="translated">Cookieメカニズムの設計では、サーバーはCookieが安全なオリジンに設定されていることを確認できず、Cookieが最初に設定された&lt;em&gt;場所&lt;/em&gt;を知ることさえできません。</target>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">最適な表現の決定は、2つのメカニズムのうちの1つによって行われます。</target>
        </trans-unit>
        <trans-unit id="efd86e58a3f30de9823ac04636ac8858e24077e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;POST&lt;/code&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">差&lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;POST&lt;/code&gt; ことである &lt;code&gt;PUT&lt;/code&gt; の冪等である：一旦それを呼び出すか、数回連続して同じ効果（何ないことを持っている&lt;em&gt;側&lt;/em&gt;の連続した同一の効果）、 &lt;code&gt;POST&lt;/code&gt; は、順序を複数回通過するような付加的な効果を有していてもよいし。</target>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">差 &lt;code&gt;PUT&lt;/code&gt; および&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;ことである &lt;code&gt;PUT&lt;/code&gt; の冪等である：一旦それを呼び出すか、数回連続して同じ効果（何ないことを持っている&lt;em&gt;側&lt;/em&gt;の連続した同一の効果）、 &lt;code&gt;POST&lt;/code&gt; は、順序を複数回通過するような付加的な効果を有していてもよいし。</target>
        </trans-unit>
        <trans-unit id="6709d83055ac598235616e01accc6af867f222e8" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), whereas successive identical &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests may have additional effects, akin to placing an order several times.</source>
          <target state="translated">差 &lt;code&gt;PUT&lt;/code&gt; および&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; は&lt;/a&gt;そのさ &lt;code&gt;PUT&lt;/code&gt; の冪等である：一度の呼び出し又は複数回連続（noです同じ効果持つ&lt;em&gt;側&lt;/em&gt;連続同一のに対し、効果）&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストが順序を数回配置に類似の追加の効果を有することができます。</target>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">異なる動作は、使用されるリクエストのメソッドと、前提条件に使用されるヘッダーの セットによって定義される。</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTPで実行できるさまざまな操作：&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt;などのあまり一般的でないリクエスト。</target>
        </trans-unit>
        <trans-unit id="611420eeacf58a81127cc81ea72c3d1d0f45c0e6" translate="yes" xml:space="preserve">
          <source>The digest is calculated over the entire representation. The representation itself may be:</source>
          <target state="translated">ダイジェストは表現全体にわたって計算されます。表現自体がそうであってもよい。</target>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">このディレクティブはそれ自体には何の効果もなく、他のディレクティブとの組み合わせでのみ意味を持つようになります。</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">その施行が違反の原因となった指令。</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">違反の原因となった指令。</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">ディレクティブは大文字小文字を区別せず、オプションの引数を持ちます。複数のディレクティブはカンマで区切られています。</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーのディレクティブは、Content &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; も適用できます。</target>
        </trans-unit>
        <trans-unit id="279baf1d439803980239f8e98d3badd1808c8388" translate="yes" xml:space="preserve">
          <source>The discrete types currently registered with the IANA are:</source>
          <target state="translated">現在IANAに登録されている離散型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">ドキュメント &lt;code&gt;https://example.com/page.html&lt;/code&gt; はリファラーhttps://example.com/を送信し &lt;code&gt;https://example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation header&lt;/code&gt; 持つドキュメントが、 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; または &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 機能が設定されていない&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; または他の同様のメソッドで別のウィンドウを開いています。これは、上記と同じ理由、つまり、通信できるため、プロセスの切り替えを許可できないためです。</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを持つドキュメントは、 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; または &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 機能が設定されていない&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; または他の同様のメソッドによって開かれたウィンドウに読み込まれました。これらのウィンドウはオープナーと同じプロセス内にある必要があります。つまり、通信できるため、プロセスを切り替えることはできません。</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを含むドキュメントが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;に読み込まれました。現在、Firefoxはiframeを新しいプロセスに移動できないため、ドキュメントは現在のプロセスに読み込まれる必要があります。</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">転送されたサーバのドメイン名です。</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">サーバーのドメイン名(仮想ホスティングの場合)またはIP。</target>
        </trans-unit>
        <trans-unit id="950978a8462def38d2b11b8a3fe9cb368d430082" translate="yes" xml:space="preserve">
          <source>The ePrivacy Directive in the EU</source>
          <target state="translated">EUにおけるeプライバシー指令</target>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">オリジンサーバでリソースに対して実行される特定のメソッドの影響により、1 つ以上の既存のキャッシュエントリが透過的でない無効なものになるかもしれません。つまり、それらは「新鮮」であり続けるかもしれませんが、オリジンサーバがそのリソースに対する新しいリクエストに対して返すものを正確に反映していません。HTTP プロトコルでは、そのようなキャッシュエントリがすべて無効とマークされていることを保証する方法はありません。例えば、オリジンサーバでの変更の原因となったリクエストはキャッシュエントリが保存されているプロキシを 通過していないかもしれません。しかし、いくつかの規則は、誤った動作の可能性を減らすのに役立つ。この節では、「エンティティを無効にする」という表現は、キャッシュがそのエンティティの全てのインスタンスをそのストレージから削除するか、あるいは、後続のリクエストに応答して返される前に、これらを「無効」としてマークし、強制的な再検証を必要とすることを意味します。いくつかの HTTP メソッドはキャッシュにエンティティを無効にさせなければなりません(MUST)。これは、Request-URI によって参照されるエンティティか、Location ヘッダや Content-Location ヘッダ (存在する場合)によって参照されるエンティティのいずれかです。これらのメソッドは以下の通りです。-PUT-DELETE-POST サービス拒否攻撃を防ぐために、Location または Content-Location ヘッダーの URI に基づく無効化は、ホスト部分が Request-URI と同じである場合にのみ実行されなければならない[MUST]。理解できないメソッドのリクエストを通過するキャッシュは、Request-URI で参照されたエンティティを無効にすべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="d5ae0833fdb7faa042296f4443d9009502223ddd" translate="yes" xml:space="preserve">
          <source>The encoding algorithm, usually a &lt;a href=&quot;compression&quot;&gt;compression algorithm&lt;/a&gt;, that can be used on the resource sent back.</source>
          <target state="translated">返送されたリソースで使用できるエンコードアルゴリズム（通常は&lt;a href=&quot;compression&quot;&gt;圧縮アルゴリズム&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">HTTP要求または応答で送信されたエンティティ本体（存在する場合）は、エンティティヘッダーフィールドで定義された形式とエンコーディングです。entity-body = * OCTET &lt;a href=&quot;#section-4.3&quot;&gt;4.3節で&lt;/a&gt;説明するように、エンティティボディは、メッセージボディが存在する場合にのみメッセージに存在します。entity-bodyは、メッセージの安全で適切な転送を保証するために適用された可能性のあるTransfer-Encodingをデコードすることにより、message-bodyから取得されます。</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">メッセージのエンティティ長は、転送コーディングが適用される前のメッセージ本文の長さです。&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;では、メッセージ本文の転送長を決定する方法を定義しています。</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同等の&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 応答には、ヘッダー&lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; が含まれ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="69c5ab4621c4edd07f710f991794d1e78a2f9d36" translate="yes" xml:space="preserve">
          <source>The exact directive for setting headers depends on your web server. In Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">ヘッダーを設定するための正確なディレクティブは、Webサーバーによって異なります。 Apacheで、サーバーの構成に次のような行を追加します（適切な &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 、または &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; セクション内）。構成は、典型的に見出される &lt;code&gt;.conf&lt;/code&gt; ファイル（ &lt;code&gt;httpd.conf&lt;/code&gt; ファイルと &lt;code&gt;apache.conf&lt;/code&gt; これらのための一般的な名称である）、又はで &lt;code&gt;.htaccess&lt;/code&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">インターネット要求によって識別される正確なリソースは、Request-URIとHostヘッダーフィールドの両方を調べることによって決定されます。リクエストされたホストによるリソースの違いを許可しないオリジンサーバーは、HTTP / 1.1リクエストで識別されたリソースを決定するときに、Hostヘッダーフィールドの値を無視してもよい（MAY）。（ただし、&lt;a href=&quot;#section-19.6.1.1&quot;&gt;セクション19.6.1.1を&lt;/a&gt;参照） HTTP / 1.1でのホストサポートに関する他の要件について。）要求されたホスト（仮想ホストまたはバニティホスト名と呼ばれることもある）に基づいてリソースを区別するオリジンサーバーは、HTTP /で要求されたリソースを決定するために次のルールを使用する必要があります。 1.1リクエスト：1. Request-URIがabsoluteURIの場合、ホストはRequest-URIの一部です。リクエスト内のホストヘッダーフィールド値はすべて無視する必要があります。 2. Request-URIが絶対URIではなく、リクエストにHostヘッダーフィールドが含まれている場合、ホストはHostヘッダーフィールドの値によって決定されます。 3.ルール1または2で決定されたホストがサーバー上の有効なホストでない場合、応答は400（Bad Request）エラーメッセージでなければなりません。 HostヘッダーフィールドのないHTTP / 1.0リクエストの受信者は、ヒューリスティック（たとえば、リクエストされている正確なリソースを判別するために、特定のホストに固有のURIパスの検査）。</target>
        </trans-unit>
        <trans-unit id="b7709fb173b9a7682e88163b1524346d08926812" translate="yes" xml:space="preserve">
          <source>The example above creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request. Also, a non-standard HTTP &lt;code&gt;X-PINGOTHER&lt;/code&gt; request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a &lt;code&gt;Content-Type&lt;/code&gt; of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="translated">上記の例では、 &lt;code&gt;POST&lt;/code&gt; リクエストで送信するXML本文を作成しています。また、非標準の &lt;code&gt;X-PINGOTHER&lt;/code&gt; リクエストヘッダーが設定されています。このようなヘッダーはHTTP / 1.1の一部ではありませんが、一般的にWebアプリケーションに役立ちます。リクエストは &lt;code&gt;application/xml&lt;/code&gt; の &lt;code&gt;Content-Type&lt;/code&gt; を使用し、カスタムヘッダーが設定されているため、このリクエストはプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">このドキュメントの最後にある例は完全なものです。ファイルに保存して使用するための追加の構文は必要ありません。(もちろん、サイトのドメイン名やサブネットを反映させるために、JavaScriptsを編集する必要があります)。</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">この例外は、ワーカースクリプトのオリジンがグローバルに一意な識別子である場合です (たとえば、URL にデータやブロブのスキームがある場合など)。この場合、ワーカーはそれを作成したドキュメントやワーカーのコンテンツセキュリティポリシーを継承します。</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">Expect要求ヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20を&lt;/a&gt;参照）で指定された期待値がこのサーバーで満たされなかったか、サーバーがプロキシの場合、次のホップのサーバーで要求が満たされなかったという明確な証拠がサーバーにある。</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">実行される割り当ての予想サイズをメガバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ed4c70c74d035f0ea716b0ccb4bd9c7c87a82ce4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;headers/accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">実験的な&lt;a href=&quot;headers/accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;は、サーバーが適切な応答を選択するために使用できる構成データをリストします。有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">実験的な&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;は、サーバーが適切な応答を選択するために使用できる構成データをリストします。有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">有効期限は以下のように計算されます。</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">エンティティの有効期限は、元のサーバーでExpiresヘッダーを使用して指定できます（&lt;a href=&quot;#section-14.21&quot;&gt;セクション14.21を&lt;/a&gt;参照）。）。または、応答でmax-ageディレクティブを使用して指定してもよい（MAY）。キャッシュされた応答にmax-age cache-controlディレクティブが存在する場合、現在の経過時間が、そのリソースに対する新しい要求時に指定された経過時間（秒単位）より大きい場合、応答は古くなります。応答のmax-ageディレクティブは、他のより制限的なキャッシュディレクティブも存在しない限り、応答がキャッシュ可能（つまり「パブリック」）であることを意味します。応答にExpiresヘッダーとmax-ageディレクティブの両方が含まれている場合、Expiresヘッダーの方が制限が厳しい場合でも、max-ageディレクティブはExpiresヘッダーをオーバーライドします。このルールにより、元のサーバーは、特定の応答に対して、HTTP / 1.0キャッシュよりもHTTP / 1.1（またはそれ以降）キャッシュに長い有効期限を提供できます。これは、特定のHTTP / 1.0キャッシュが、おそらく非同期化されたクロックが原因で、経過時間または有効期限を正しく計算しない場合に役立ちます。多くのHTTP / 1.0キャッシュ実装は、応答の日付値以下のExpires値を、Cache-Control応答ディレクティブ「no-cache」と同等のものとして扱います。 HTTP / 1.1キャッシュがそのような応答を受信し、その応答にCache-Controlヘッダーフィールドが含まれていない場合、HTTP / 1.0サーバーとの互換性を維持するために、その応答はキャッシュ不可であると見なすべきです。注：オリジンサーバーは、「プライベート」ディレクティブなどの比較的新しいHTTPキャッシュ制御機能を、その機能を理解しない古いキャッシュを含むネットワーク上で使用したい場合があります。オリジンサーバーは、新しい機能を、日付の値以下のExpiresフィールドと組み合わせる必要があります。これにより、古いキャッシュが応答を不適切にキャッシュするのを防ぎます。 s-maxage応答にs-maxageディレクティブが含まれている場合、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（次に、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（次に、共有キャッシュ（プライベートキャッシュではない）の場合、このディレクティブで指定された最大経過時間は、max-ageディレクティブまたはExpiresヘッダーで指定された最大経過時間を上書きします。 s-maxageディレクティブは、proxy-revalidateディレクティブのセマンティクスも意味します（ &lt;a href=&quot;#section-14.9.4&quot;&gt;セクション14.9.4&lt;/a&gt;）、つまり、最初にオリジンサーバーで再検証することなく、共有キャッシュが古くなって次の要求に応答するようになった後は、そのエントリを使用してはなりません。 s-maxageディレクティブは、プライベートキャッシュによって常に無視されます。この仕様に準拠していない古いキャッシュのほとんどは、キャッシュ制御ディレクティブを実装していません。 HTTP / 1.1準拠のキャッシュによるキャッシュを制限するが防止はしないキャッシュ制御ディレクティブの使用を希望するオリジンサーバーは、max-ageディレクティブがExpiresヘッダーをオーバーライドするという要件、およびHTTPより前の/1.1準拠のキャッシュは、max-ageディレクティブを監視しません。その他のディレクティブを使用すると、ユーザーエージェントは基本的な有効期限メカニズムを変更できます。これらのディレクティブはリクエストで指定してもよいです：max-ageクライアントが、指定された時間（秒単位）以下の応答を受け入れる用意があることを示します。 max-staleディレクティブも含まれていない限り、クライアントは古い応答を受け入れる用意がありません。 min-freshクライアントが、フレッシュネスライフタイムが現在の経過時間と指定された時間（秒単位）を足したものである応答を受け入れる用意があることを示します。つまり、クライアントは、少なくとも指定された秒数の間、まだ新鮮な応答を望んでいます。 max-staleクライアントが、有効期限を超えた応答を受け入れる用意があることを示します。 max-staleに値が割り当てられている場合、その後、クライアントは、指定された秒数を超えて有効期限を超えた応答を受け入れます。 max-staleに値が割り当てられていない場合、クライアントは任意の年齢の古い応答を受け入れてもかまいません。リクエストのmax-staleディレクティブが原因で、またはキャッシュが応答の有効期限を上書きするように構成されているために、キャッシュが古い応答を返す場合、キャッシュは、警告110を使用して、古いヘッダーに警告ヘッダーを添付する必要があります。 （応答が古くなっています）。キャッシュは、検証なしで古い応答を返すように構成できますが、これは、キャッシュ検証に関する「MUST」レベルの要件（「must-revalidate」キャッシュ制御ディレクティブなど）と競合しない場合のみです。新しいリクエストとキャッシュされたエントリの両方に「max-age」ディレクティブが含まれている場合、そのリクエストのキャッシュされたエントリの鮮度を判断するために、2つの値の小さい方が使用されます。</target>
        </trans-unit>
        <trans-unit id="a65d812882b0aba90b93b31c9c8f523446f0f382" translate="yes" xml:space="preserve">
          <source>The features include (see &lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;Features list&lt;/a&gt;):</source>
          <target state="translated">機能は次のとおりです（&lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;機能リストを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">特徴としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">このファイルは &lt;code&gt;FindProxyForURL&lt;/code&gt; という関数で構成されています。以下の例は、内部DNSサーバーが内部ホスト名のみを解決できるように設定されている環境で機能し、解決できないホストに対してのみプロキシを使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">firefox.js ファイルはプリファレンス名と値を pref()関数に渡します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">最後のブロックは、オプションのデータを含むデータブロックです。</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">最後のブロックはオプションのデータブロックで、主にPOSTメソッドで使用される更なるデータを含む可能性があります。</target>
        </trans-unit>
        <trans-unit id="45bd5c32307d77b9998e20d89babbacc1a08c8ee" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;OPTIONS&lt;/code&gt;, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">リクエストの最後の部分はその本文です。すべてのリクエストに1つあるわけではありません &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;OPTIONS&lt;/code&gt; などのリソースをフェッチするリクエストには、通常は必要ありません。一部のリクエストは、更新するためにサーバーにデータを送信します &lt;code&gt;POST&lt;/code&gt; リクエスト（HTMLフォームデータを含む）の場合と同様です。</target>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">リクエストの最後の部分はその本文です。すべてのリクエストに1つあるわけではありません &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; 、DELETE、またはOPTIONS などのリソースをフェッチするリクエストは通常、必要ありません。一部のリクエストは、データを更新するためにサーバーにデータを送信します &lt;code&gt;POST&lt;/code&gt; リクエスト（HTMLフォームデータを含む）の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">リクエストの最終受信者は、以下に説明するいくつかのフィールドを除いて、受信したメッセージを、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;message/http&lt;/code&gt; の 200（OK）応答のメッセージ本文としてクライアントに反映する必要があります。最終受信者は、起点サーバーか、要求で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;値0 を受信する最初のサーバーです。</target>
        </trans-unit>
        <trans-unit id="fa5fe1af847469a3d3023206916eb30deabd5583" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">リクエストの最終受信者は、以下で説明する一部のフィールドを除いて、受信したメッセージを、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;message/http&lt;/code&gt; の&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）応答のメッセージ本文としてクライアントに反映する必要があります。最終的な受信者は、オリジンサーバーか、リクエストで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;値0を受信した最初のサーバーのいずれかです。</target>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">違反の原因となったインラインスクリプト、イベントハンドラ、またはスタイルの最初の40文字。</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">最初の行にはリクエストメソッドとそのパラメータが続きます。</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">レスポンスメッセージの最初の行はステータス行で、プロトコルバージョン、数値のステータスコード、およびそれに関連するテキストフレーズで構成され、各要素はSP文字で区切られています。最後の CRLF シーケンス以外では、CR や LF は使用できません。Status-Line=HTTP-Version SP Status-Code SP Reason-Phrase CRLF</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">応答メッセージの最初の行は、プロトコルバージョン、スペース（SP）、ステータスコード、別のスペース、ステータスコードを説明する空のテキストフレーズで構成され、CRLFで終わるステータス行です。 status-line = HTTP-version SP status-code SP reason-phrase CRLF status-code要素は、サーバーがクライアントの対応する要求を理解して満足する試みの結果を説明する3桁の整数コードです。残りの応答メッセージは、そのステータスコードに定義されているセマンティクスに照らして解釈されます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]のセクション6を&lt;/a&gt;参照してくださいステータスコードのクラス（最初の桁で示される）、この仕様で定義されているステータスコード、新しいステータスコードの定義に関する考慮事項、IANAレジストリなど、ステータスコードのセマンティクスについては、 status-code = 3DIGIT reason-phrase要素は、数値のステータスコードに関連付けられたテキストによる説明を提供することのみを目的として存在します。これは主に、インタラクティブテキストクライアントでより頻繁に使用されていた以前のインターネットアプリケーションプロトコルを順守しないためです。クライアントは理由フレーズの内容を無視する必要があります。理由フレーズ= *（HTAB / SP / VCHAR / obs-text）</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">最初の行である&lt;em&gt;status lineは&lt;/em&gt;、使用されているHTTPバージョンの確認応答と、それに続くステータス要求（および人間が読めるテキストでの簡単な意味）で構成されています。</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">HTTPコンテキストの最初のパラメーターは常に &lt;code&gt;form-data&lt;/code&gt; です。追加のパラメータは大文字と小文字を区別せず、 &lt;code&gt;'='&lt;/code&gt; 記号の後に引用符付き文字列構文を使用する引数があります。複数のパラメーターはセミコロン（ &lt;code&gt;';'&lt;/code&gt; ）で区切ります。</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">HTTPコンテキストの最初のパラメーターは、 &lt;code&gt;inline&lt;/code&gt; （デフォルト値、Webページ内に表示できること、またはWebページとして表示できることを示す）または &lt;code&gt;attachment&lt;/code&gt; （ダウンロードする必要があることを示す）です。ほとんどのブラウザーは、「名前を付けて保存」ダイアログを表示し、あらかじめ入力されています。存在する場合は、 &lt;code&gt;filename&lt;/code&gt; パラメータの値を含む）。</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">サイトが初めてHTTPSを使用してアクセスされ、 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; ヘッダーが返されると、ブラウザはこの情報を記録するため、HTTPを使用してサイトをロードしようとすると、代わりにHTTPSが自動的に使用されます。</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">リソースの最初のアップロードは、前のリソースのエッジケースです。リソースの更新と同様に、2つのクライアントが同じ時間に実行しようとすると、競合状態の影響を受けます。これを防ぐには、条件付きリクエストを使用できます。e-tagを表す特別な値 &lt;code&gt;'*'&lt;/code&gt; を使用して&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;を追加します。リクエストは、リソースが以前に存在しなかった場合にのみ成功します。</target>
        </trans-unit>
        <trans-unit id="cc100946d8979f9ce8df35a1f6c26e450e867343" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、ロードされません。</target>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="d9b73c421a277665ab08a8298b8930b892f83d26" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;はブロックされており、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">次の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;要素はブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">次の &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">次のJavaコードはCORS応答ヘッダーを設定します。コードが &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 値を&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;リクエストヘッダーと同じ値に設定する方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">以下は、&lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standardに&lt;/a&gt;基づくすべての有効なJavaScript MIMEタイプです。</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">次のコマンドは、ウェブサイトのBase64エンコードされた情報を抽出します。</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">以下のコマンドは、鍵ファイル、証明書署名要求、証明書から Base64 エンコードされた情報を抽出するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">以下の接続がブロックされ、ロードされません。</target>
        </trans-unit>
        <trans-unit id="ce04653c2a877eee1709cad576d94e84ea8ac4bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;example.com&lt;/code&gt;:</source>
          <target state="translated">次のCookieは、 &lt;code&gt;example.com&lt;/code&gt; でホストされているサーバーによって設定された場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="f830b6e4479681c906a8958ca927a242872bc6bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;originalcompany.com&lt;/code&gt;:</source>
          <target state="translated">次のCookieは、 &lt;code&gt;originalcompany.com&lt;/code&gt; でホストされているサーバーによって設定された場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、HTAB（水平タブ）、LF（ラインフィード）、OCTET（データの8ビットシーケンス）、SP（スペース）、およびVCHAR（目に見えるUS-ASCII文字）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; RWS = &amp;lt;RWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; URI-reference = &amp;lt;URI-reference、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション2.7&amp;gt;絶対URI = &amp;lt;絶対URI、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション2.7 &amp;gt;コメント= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.6 &amp;gt;フィールド名= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2 &amp;gt;部分- URI = &amp;lt;partial-URI、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7を&lt;/a&gt;参照&amp;gt; quoted-string = &amp;lt;quoted-string、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt; token = &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。トークンから派生したすべてのルールは、範囲単位や許容範囲のように、大文字と小文字を区別せずに比較されることに注意してください。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;以下のルールは他の部分で定義されています：HTTP -date = &amp;lt;HTTP-date、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、セクション7.1.1.1&lt;/a&gt; &amp;gt;エンティティタグ= &amp;lt;エンティティタグ、&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]を&lt;/a&gt;参照、セクション2.3 &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています：BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; quoted-string = &amp;lt;quoted-string、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6&lt;/a&gt; &amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt; field-name = &amp;lt;field-name、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2 &amp;gt; quoted-string = &amp;lt;quoted-string 、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt; port = &amp;lt;ポート、見る&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt; pseudonym = &amp;lt;pseudonym、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]、セクション5.7.1&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt;以下のルールは他の部分で定義されています：HTTP-日付= &amp;lt;HTTP-date、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、セクション7.1.1.1を参照&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]の付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照として含まれています 。ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（可視のUS-ASCII文字） ）。以下のルールは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されています。OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; obs-text = &amp;lt;obs-text、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt;以下のルールはその他の部分：HTTP-date = &amp;lt;HTTP-date、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、Section 7.1.1.1&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">次の例は、同じコピー操作が実行されていることを示していますが、Overwriteヘッダーが「F」に設定されています。宛先URLが既にリソースにマップされているため、412（前提条件の失敗）の応答が返されます。&amp;gt;&amp;gt;リクエストCOPY /~fielding/index.html HTTP / 1.1 Host：www.example.com Destination：http://www.example.com/users/f/fielding/index.html Overwrite：F &amp;gt;&amp;gt; Response HTTP / 1.1 412前提条件が失敗しました</target>
        </trans-unit>
        <trans-unit id="8d3395be0d0b51b8ffa7605b7ec7844c4e4a39c7" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to &lt;code&gt;foo.example&lt;/code&gt;.</source>
          <target state="translated">次の例では、24時間の証明書の透明性の実施を指定し、違反を &lt;code&gt;foo.example&lt;/code&gt; に報告します。</target>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">次の例では、証明書の透明性を24時間実施し、違反をfoo.exampleに報告することを指定しています。</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">以下のフォントリソースの読み込みがブロックされ、読み込まれません。</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">以下のヘッダーは、WebSocketのアップグレードプロセスに関係しています。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーと&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを除いて、残りは一般にオプションであるか、ブラウザとサーバーが相互に通信しているときに自動的に処理されます。</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">以下はプリフライトされるリクエストの例です。</target>
        </trans-unit>
        <trans-unit id="f2caa1f526d805ff5feea71e36486901a1b33c7b" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted:</source>
          <target state="translated">以下はプリフライトされるリクエストの例です。</target>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">以下の行に関連するキー情報(pin-sha256=&quot;...&quot;フィールド)を記述することで、lighttpd上でHPKPを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">以下のリストでは、HTTP ヘッダを用途別にまとめています。アルファベット順のリストについては、左側のナビゲーションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c48b8f944a040a3a451f5a0b5b3b5d6f5f32bae2" translate="yes" xml:space="preserve">
          <source>The following object keys can be specified in the NEL header:</source>
          <target state="translated">NELヘッダには、以下のオブジェクトキーを指定することができます。</target>
        </trans-unit>
        <trans-unit id="0132826bcd8328191613e887dc58c7bad941d249" translate="yes" xml:space="preserve">
          <source>The following parameters are defined:

   SETTINGS_HEADER_TABLE_SIZE (0x1):  Allows the sender to inform the
      remote endpoint of the maximum size of the header compression
      table used to decode header blocks, in octets.  The encoder can
      select any size equal to or less than this value by using
      signaling specific to the header compression format inside a
      header block (see [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;]).  The initial value is 4,096
      octets.

   SETTINGS_ENABLE_PUSH (0x2):  This setting can be used to disable
      server push (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;).  An endpoint MUST NOT send a
      PUSH_PROMISE frame if it receives this parameter set to a value of
      0.  An endpoint that has both set this parameter to 0 and had it
      acknowledged MUST treat the receipt of a PUSH_PROMISE frame as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

      The initial value is 1, which indicates that server push is
      permitted.  Any value other than 0 or 1 MUST be treated as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   SETTINGS_MAX_CONCURRENT_STREAMS (0x3):  Indicates the maximum number
      of concurrent streams that the sender will allow.  This limit is
      directional: it applies to the number of streams that the sender
      permits the receiver to create.  Initially, there is no limit to
      this value.  It is recommended that this value be no smaller than
      100, so as to not unnecessarily limit parallelism.

      A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be
      treated as special by endpoints.  A zero value does prevent the
      creation of new streams; however, this can also happen for any 

      limit that is exhausted with active streams.  Servers SHOULD only
      set a zero value for short durations; if a server does not wish to
      accept requests, closing the connection is more appropriate.

   SETTINGS_INITIAL_WINDOW_SIZE (0x4):  Indicates the sender's initial
      window size (in octets) for stream-level flow control.  The
      initial value is 2^16-1 (65,535) octets.

      This setting affects the window size of all streams (see
      &lt;a href=&quot;#section-6.9.2&quot;&gt;Section 6.9.2&lt;/a&gt;).

      Values above the maximum flow-control window size of 2^31-1 MUST
      be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      FLOW_CONTROL_ERROR.

   SETTINGS_MAX_FRAME_SIZE (0x5):  Indicates the size of the largest
      frame payload that the sender is willing to receive, in octets.

      The initial value is 2^14 (16,384) octets.  The value advertised
      by an endpoint MUST be between this initial value and the maximum
      allowed frame size (2^24-1 or 16,777,215 octets), inclusive.
      Values outside this range MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   SETTINGS_MAX_HEADER_LIST_SIZE (0x6):  This advisory setting informs a
      peer of the maximum size of header list that the sender is
      prepared to accept, in octets.  The value is based on the
      uncompressed size of header fields, including the length of the
      name and value in octets plus an overhead of 32 octets for each
      header field.

      For any given request, a lower limit than what is advertised MAY
      be enforced.  The initial value of this setting is unlimited.

   An endpoint that receives a SETTINGS frame with any unknown or
   unsupported identifier MUST ignore that setting.</source>
          <target state="translated">次のパラメータが定義されています。SETTINGS_HEADER_TABLE_SIZE（0x1）：送信者は、ヘッダーブロックのデコードに使用されるヘッダー圧縮テーブルの最大サイズをオクテット単位でリモートエンドポイントに通知できます。エンコーダーは、ヘッダーブロック内のヘッダー圧縮形式に固有のシグナリングを使用して、この値以下の任意のサイズを選択できます（[ &lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt; ]を参照）。初期値は4,096オクテットです。 SETTINGS_ENABLE_PUSH（0x2）：この設定は、サーバープッシュを無効にするために使用できます（&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;）。エンドポイントは、値0に設定されたこのパラメーターを受信した場合、PUSH_PROMISEフレームを送信してはなりません。このパラメーターを0に設定し、確認応答したエンドポイントは、PUSH_PROMISEフレームの受信を接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4。 1&lt;/a&gt;）タイプPROTOCOL_ERROR。初期値は1で、サーバープッシュが許可されていることを示します。 0または1以外の値は、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。 SETTINGS_MAX_CONCURRENT_STREAMS（0x3）：送信者が許可する同時ストリームの最大数を示します。この制限は方向性があります。送信者が受信者に作成を許可するストリームの数に適用されます。最初は、この値に制限はありません。並列処理を不必要に制限しないように、この値は100以上にすることをお勧めします。 SETTINGS_MAX_CONCURRENT_STREAMSの値0は、エンドポイントによって特別なものとして扱われるべきではありません。ゼロ値は、新しいストリームの作成を防ぎます。ただし、これは、アクティブなストリームで使い果たされた制限に対しても発生する可能性があります。サーバーは、短期間にのみゼロ値を設定する必要があります。サーバーがリクエストを受け入れたくない場合は、接続を閉じる方が適切です。 SETTINGS_INITIAL_WINDOW_SIZE（0x4）：送信者を示します■ストリームレベルのフロー制御の初期ウィンドウサイズ（オクテット単位）。初期値は2 ^ 16-1（65,535）オクテットです。この設定は、すべてのストリームのウィンドウサイズに影響します（を参照）&lt;a href=&quot;#section-6.9.2&quot;&gt;セクション6.9.2&lt;/a&gt;）。最大フロー制御ウィンドウサイズの2 ^ 31-1を超える値は、タイプFLOW_CONTROL_ERRORの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として処理する必要があります。 SETTINGS_MAX_FRAME_SIZE（0x5）：送信者が受信しようとしている最大のフレームペイロードのサイズをオクテットで示します。初期値は2 ^ 14（16,384）オクテットです。エンドポイントによってアドバタイズされる値は、この初期値と最大許容フレームサイズ（2 ^ 24-1または16,777,215オクテット）の間にある必要があります。この範囲外の値は、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。 SETTINGS_MAX_HEADER_LIST_SIZE（0x6）：このアドバイザリ設定は、送信者が受け入れる準備ができているヘッダーリストの最大サイズをオクテット単位でピアに通知します。この値は、名前と値のオクテット単位の長さと、ヘッダーフィールドごとに32オクテットのオーバーヘッドを含む、ヘッダーフィールドの非圧縮サイズに基づいています。特定のリクエストに対して、アドバタイズされているものよりも低い制限が適用される場合があります。この設定の初期値は無制限です。不明またはサポートされていない識別子を持つSETTINGSフレームを受信するエンドポイントは、その設定を無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="7cd371c0bd518c2c5a7f7101657c16841e787471" translate="yes" xml:space="preserve">
          <source>The following pseudo-header fields are defined for HTTP/2 requests:

   o  The &quot;:method&quot; pseudo-header field includes the HTTP method
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;[RFC7231], Section&amp;nbsp;4&lt;/a&gt;).

   o  The &quot;:scheme&quot; pseudo-header field includes the scheme portion of
      the target URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;).

      &quot;:scheme&quot; is not restricted to &quot;http&quot; and &quot;https&quot; schemed URIs.  A
      proxy or gateway can translate requests for non-HTTP schemes,
      enabling the use of HTTP to interact with non-HTTP services.

   o  The &quot;:authority&quot; pseudo-header field includes the authority
      portion of the target URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;).  The authority
      MUST NOT include the deprecated &quot;userinfo&quot; subcomponent for &quot;http&quot;
      or &quot;https&quot; schemed URIs.

      To ensure that the HTTP/1.1 request line can be reproduced
      accurately, this pseudo-header field MUST be omitted when
      translating from an HTTP/1.1 request that has a request target in
      origin or asterisk form (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230], Section&amp;nbsp;5.3&lt;/a&gt;).  Clients
      that generate HTTP/2 requests directly SHOULD use the &quot;:authority&quot;
      pseudo-header field instead of the Host header field.  An
      intermediary that converts an HTTP/2 request to HTTP/1.1 MUST
      create a Host header field if one is not present in a request by
      copying the value of the &quot;:authority&quot; pseudo-header field.

   o  The &quot;:path&quot; pseudo-header field includes the path and query parts
      of the target URI (the &quot;path-absolute&quot; production and optionally a
      '?' character followed by the &quot;query&quot; production (see Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
      and 3.4 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]).  A request in asterisk form includes the
      value '*' for the &quot;:path&quot; pseudo-header field.

      This pseudo-header field MUST NOT be empty for &quot;http&quot; or &quot;https&quot;
      URIs; &quot;http&quot; or &quot;https&quot; URIs that do not contain a path component
      MUST include a value of '/'.  The exception to this rule is an
      OPTIONS request for an &quot;http&quot; or &quot;https&quot; URI that does not include
      a path component; these MUST include a &quot;:path&quot; pseudo-header field
      with a value of '*' (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3.4&quot;&gt;[RFC7230], Section&amp;nbsp;5.3.4&lt;/a&gt;). 

   All HTTP/2 requests MUST include exactly one valid value for the
   &quot;:method&quot;, &quot;:scheme&quot;, and &quot;:path&quot; pseudo-header fields, unless it is
   a CONNECT request (&lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).  An HTTP request that omits
   mandatory pseudo-header fields is malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   HTTP/2 does not define a way to carry the version identifier that is
   included in the HTTP/1.1 request line.</source>
          <target state="translated">次の疑似ヘッダーフィールドは、HTTP / 2リクエスト用に定義されています。o「：method」疑似ヘッダーフィールドには、HTTPメソッドが含まれます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;[RFC7231]、セクション4&lt;/a&gt;）。 o「：scheme」疑似ヘッダーフィールドには、ターゲットURIのスキーム部分が含まれます（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986]、セクション3.1&lt;/a&gt;）。 「：scheme」は「http」および「https」スキーム化URIに限定されません。プロキシまたはゲートウェイは、非HTTPスキームの要求を変換できるため、HTTPを使用して非HTTPサービスと対話できます。 o「：authority」疑似ヘッダーフィールドには、ターゲットURIの権限部分が含まれます（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986]、セクション3.2&lt;/a&gt;）。機関は、「http」または「https」スキーム化URIの非推奨の「userinfo」サブコンポーネントを含めてはなりません（MUSTNOT）。 HTTP / 1.1リクエストラインを正確に再現できるようにするには、オリジンまたはアスタリスク形式のリクエストターゲットを持つHTTP / 1.1リクエストから変換する場合、この疑似ヘッダーフィールドを省略しなければなりません（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]、セクション5.3を&lt;/a&gt;参照）。）。 HTTP / 2リクエストを直接生成するクライアントは、Hostヘッダーフィールドの代わりに「：authority」疑似ヘッダーフィールドを使用する必要があります。 HTTP / 2リクエストをHTTP / 1.1に変換する仲介者は、「：authority」疑似ヘッダーフィールドの値をコピーして、ホストヘッダーフィールドがリクエストに存在しない場合は作成する必要があります。 o「：path」疑似ヘッダーフィールドには、ターゲットURIのパス部分とクエリ部分が含まれます（「path-absolute」生成と、オプションで「？」文字の後に「query」生成が続きます（[のセクション&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;および3.4​​を参照）。&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]）。アスタリスク形式のリクエストには、「：path」疑似ヘッダーフィールドの値「*」が含まれます。この疑似ヘッダーフィールドは、「http」または「https」URIでは空であってはなりません。パスコンポーネントを含まない「http」または「https」URIには、「/」の値を含める必要があります。このルールの例外は、パスコンポーネントを含まない「http」または「https」URIに対するOPTIONSリクエストです。これらには、値が「*」の「：path」疑似ヘッダーフィールドを含める必要があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3.4&quot;&gt;[RFC7230]のセクション5.3.4を&lt;/a&gt;参照）。すべてのHTTP / 2リクエストには、CONNECTリクエスト（&lt;a href=&quot;#section-8.3&quot;&gt;セクション8.3&lt;/a&gt;）でない限り、「：method」、「：scheme」、および「：path」疑似ヘッダーフィールドに有効な値を1つだけ含める必要があります。必須の疑似ヘッダーフィールドを省略したHTTPリクエストの形式が正しくあり&lt;a href=&quot;#section-8.1.2.6&quot;&gt;ません（セクション8.1.2.6&lt;/a&gt;）。HTTP / 2は、HTTP /1.1リクエストラインに含まれるバージョン識別子を運ぶ方法を定義していません。</target>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">次のPROPFINDメソッドのリクエスト本文は無効です。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot;&amp;gt; &amp;lt;D：allprop /&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;/ D：propfind&amp;gt;定義propfind要素では、allpropまたはpropname要素のみが許可され、両方は許可されません。したがって、上記はエラーであり、400（Bad Request）で応答する必要があります。ただし、サーバーが「親切」になりたがって、allprop要素を真の要素として選択してそれに応答することを決定したと想像してください。サーバーがコマンドをallpropとして処理した場合、propnameを実行することを目的とした、帯域幅が制限された回線で実行されているクライアントは、非常に驚​​きます。さらに、サーバーが寛大で、このリクエストに応答することにした場合、結果はサーバーごとにランダムに異なり、allpropディレクティブを実行するサーバーと、propnameディレクティブを実行するサーバーがあります。これにより、相互運用性が向上するのではなく、低下します。</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">&lt;a href=&quot;#section-3.4.1&quot;&gt;セクション3.4.1で&lt;/a&gt;定義されているように、次のリクエストヘッダーフィールドはユーザーエージェントによって送信され、レスポンスコンテンツの積極的な交渉に従事します。これらのフィールドで送信される設定は、ターゲットリソースの表現、エラーまたは処理ステータスの表現、プロトコル内に表示される可能性のあるその他のテキスト文字列など、応答のコンテンツに適用されます。 + ------------------- + --------------- + |ヘッダーフィールド名|で定義されています... | + ------------------- + --------------- + |同意する| &lt;a href=&quot;#section-5.3.2&quot;&gt;セクション5.3.2&lt;/a&gt; | | Accept-Charset | &lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt; | | Accept-Encoding | &lt;a href=&quot;#section-5.3.4&quot;&gt;セクション5.3.4&lt;/a&gt; | | Accept-Language | &lt;a href=&quot;#section-5.3.5&quot;&gt;セクション5.3.5&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">次のリクエストヘッダーフィールドは、リクエストの背後にあるユーザー、ユーザーエージェント、リソースに関する情報など、リクエストコンテキストに関する追加情報を提供します。+ ------------------- + --------------- + | ヘッダーフィールド名| で定義されています... | + ------------------- + --------------- + | から| &lt;a href=&quot;#section-5.5.1&quot;&gt;セクション5.5.1&lt;/a&gt; | | リファラー| &lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt; | | ユーザーエージェント| &lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">この仕様全体で、次のルールを使用して、基本的な構文解析構文を説明しています。US-ASCIIコード化文字セットは、ANSI X3.4-1986 [ &lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]。 OCTET = &amp;lt;任意の8ビットのデータシーケンス&amp;gt; CHAR = &amp;lt;任意のUS-ASCII文字（オクテット0-127）&amp;gt; UPALPHA = &amp;lt;任意のUS-ASCII大文字 &quot;A&quot; .. &quot;Z&quot;&amp;gt; LOALPHA = &amp;lt;任意のUS- ASCII小文字 &quot;a&quot; .. &quot;z&quot;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;任意のUS-ASCII数字 &quot;0&quot; .. &quot;9&quot;&amp;gt; CTL = &amp;lt;任意のUS-ASCII制御文字（オクテット0〜31）およびDEL（127）&amp;gt; CR = &amp;lt;US-ASCII CR、キャリッジリターン（ 13）&amp;gt; LF = &amp;lt;US-ASCII LF、改行（10）&amp;gt; SP = &amp;lt;US-ASCII SP、スペース（32）&amp;gt; HT = &amp;lt;US-ASCII HT、水平タブ（9）&amp;gt; &amp;lt;&quot;&amp;gt; = &amp;lt;US-ASCIIの二重引用符（34）&amp;gt; HTTP / 1.1は、エンティティボディを除くすべてのプロトコル要素の行末マーカーとしてシーケンスCR LFを定義します（耐性のあるアプリケーションについては、付録19.3を参照）。 entity-body内の行末マーカーは、関連するメディアタイプによって定義されます。&lt;a href=&quot;#section-3.7&quot;&gt;セクション3.7&lt;/a&gt;。 CRLF = CR LF継続行がスペースまたは水平タブで始まる場合、HTTP / 1.1ヘッダーフィールド値は複数行に折りたたむことができます。折りたたみを含むすべての線形空白は、SPと同じセマンティクスを持っています。受信者は、フィールド値を解釈したり、メッセージをダウンストリームに転送したりする前に、線形の空白を単一のSPで置き換えてもよい（MAY）。 LWS = [CRLF] 1 *（SP | HT）TEXTルールは、メッセージパーサーによる解釈を目的としない説明的なフィールドの内容と値にのみ使用されます。 * TEXTの単語には、&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047の&lt;/a&gt;規則に従ってエンコードされている場合にのみ、ISO-8859-1 [ &lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt; ] 以外の文字セットの文字を含めることができます [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]。 TEXT = &amp;lt;CTLを除く任意のOCTET、ただしLWSを含む&amp;gt;ヘッダーフィールドの継続の一部としてのみ、TEXTの定義でCRLFを使用できます。 TEXT値を解釈する前に、フォールディングLWSが単一のSPに置き換えられることが期待されています。 16進数の数字は、いくつかのプロトコル要素で使用されます。 HEX = &quot;A&quot; | 「B」| 「C」| 「D」| 「E」| 「F」| &quot;a&quot; | 「b」| 「c」| 「d」| 「e」| &quot;f&quot; | DIGIT多くのHTTP / 1.1ヘッダーフィールド値は、LWSまたは特殊文字で区切られた単語で構成されています。これらの特殊文字は、パラメータ値内で使用される引用符付き文字列に含まれている必要があります（ &lt;a href=&quot;#section-3.6&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6で定義）&lt;/a&gt;）。トークン= 1 * &amp;lt;CTLまたはセパレータを除く任意のCHAR&amp;gt;セパレータ= &quot;（&quot; | &quot;）&quot; | 「&amp;lt;」| &quot;&amp;gt;&quot; | 「@」| 「、」| 「;」 | &quot;：&quot; | 「\」| &amp;lt;&quot;&amp;gt; |&quot; / &quot;|&quot; [&quot;|&quot;] &quot;|&quot;？ &quot;|&quot; = &quot;|&quot; {&quot;|&quot;} &quot;| SP | HTコメントは、コメントテキストを次のように囲むことにより、一部のHTTPヘッダーフィールドに含めることができます。括弧。コメントは、フィールド値の定義の一部として「コメント」を含むフィールドでのみ許可されます。他のすべてのフィールドでは、括弧はフィールド値の一部と見なされます。comment= &quot;（&quot; *（ctext | quoted-pair | comment） &quot; ）」ctext = &amp;lt;「（」と「）」を除く任意のTEXT&amp;gt;テキストの文字列は、二重引用符で囲まれている場合、1つの単語として解析されます。 quoted-string =（&amp;lt;&quot;&amp;gt; *（qdtext | quoted-pair）&amp;lt;&quot;&amp;gt;）qdtext = &amp;lt;&amp;lt; &quot;&amp;gt;&amp;gt;を除く任意のテキストバックスラッシュ文字（&quot; \ &quot;）は、単一文字の引用メカニズムとしてのみ使用できますquoted-stringおよびcomment構文。quoted-pair = &quot;\&quot; CHAR）引用文字列とコメント構造内でのみ、単一文字の引用メカニズムとして使用できます。 quoted-pair = &quot;\&quot; CHAR）引用文字列とコメント構造内でのみ、単一文字の引用メカニズムとして使用できます。 quoted-pair = &quot;\&quot; CHAR</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">次のセクションでは、任意のアクセスタイプのロックを解除し、既存のロックを更新するために使用されるLOCKメソッドについて説明します。LOCKメソッドに関するこれらのセクションでは、LOCKメソッドに固有で、要求されるロックのアクセスタイプに依存しないセマンティクスのみを説明します。LOCKメソッドをサポートするリソースは、少なくとも、ここで定義されているXML要求および応答フォーマットをサポートする必要があります。この方法は&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;べき&lt;/a&gt;等でも安全でもありません（[RFC2616]のセクション9.1を参照）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">次のステータスコードは、HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されているものに追加されます。</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">主要なブラウザベンダーがモバイル端末でブラウザが動作していることを示す方法をまとめてみました。</target>
        </trans-unit>
        <trans-unit id="dd1549ac99aae5d800f9a7d9d93287604b603639" translate="yes" xml:space="preserve">
          <source>The following warning might appear in your console:</source>
          <target state="translated">コンソールに以下のような警告が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL の形式は非常に単純ですが、「データ」セグメントの前にコンマを置くのを忘れたり、データを誤ってbase64形式にエンコードしたりするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">形式の問題は、リクエストで示された&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;が原因であるか、データを直接検査した結果である可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6417d40b5bbb94e0ab0361d59b5efbe6a9c03d8" translate="yes" xml:space="preserve">
          <source>The forward slash (&lt;code&gt;/&lt;/code&gt;) character is interpreted as a directory separator, and subdirectories will be matched as well: for &lt;code&gt;Path=/docs&lt;/code&gt;, &lt;code&gt;/docs&lt;/code&gt;, &lt;code&gt;/docs/Web/&lt;/code&gt;, and &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; will all match.</source>
          <target state="translated">スラッシュ（ &lt;code&gt;/&lt;/code&gt; ）文字はディレクトリ区切り文字として解釈され、サブディレクトリも一致します &lt;code&gt;Path=/docs&lt;/code&gt; 、 &lt;code&gt;/docs&lt;/code&gt; 、 &lt;code&gt;/docs/Web/&lt;/code&gt; 、および &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; の場合はすべて一致します。</target>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">転送されるプロトコル(httpまたはhttps)。</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">HTTP認証のフレームワークは、&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;ではなく、このドキュメントで定義されるようになりました。 「レルム」パラメーターは、課題で常に必要とされなくなりました。その結果、ABNFは認証パラメーターなしでチャレンジを許可します。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）「Basic」などの従来の認証方式との一貫性を保つために、auth-paramリストの「token68」代替が追加されました。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）この仕様では、新しい認証方式に関する考慮事項とともに、認証方式レジストリを紹介しています。 （&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4d91b5b813304e8a213249cb1c603b64a74abb68" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-Control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime.</source>
          <target state="translated">鮮度の寿命は、いくつかのヘッダーに基づいて計算されます。「 &lt;code&gt;Cache-Control: max-age=N&lt;/code&gt; 」ヘッダーが指定されている場合、鮮度の有効期間はNに等しくなります。このヘッダーが存在しない場合（多くの場合）、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーが存在するかどうかがチェックされます。 &lt;code&gt;Expires&lt;/code&gt; ヘッダーが存在する場合、その値から&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;ヘッダーの値を引いたものが、鮮度の有効期間を決定します。</target>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">フレッシュネスライフタイムは、いくつかのヘッダーに基づいて計算されます。 &quot; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &quot;ヘッダーが指定されている場合、鮮度の有効期間はNに等しくなります。このヘッダーが存在しない場合、これは非常によくあることですが、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーが存在するかどうかが確認されます。場合 &lt;code&gt;Expires&lt;/code&gt; ヘッダが存在し、その値がマイナスの値&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;ヘッダは新鮮寿命を決定します。最後に、どちらのヘッダーも存在しない場合は、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;ヘッダーを探します。このヘッダーが存在する場合、キャッシュのフレッシュネスライフタイムは、 &lt;code&gt;Date&lt;/code&gt; ヘッダーの値から &lt;code&gt;Last-modified&lt;/code&gt; ヘッダーの値を10で割った値を引いた値に等しくなります。</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">一般的なHTTP認証フレームワーク</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">一般的な HTTP 認証フレームワークは、いくつかの認証スキームで使用されています。スキームは、セキュリティの強さや、クライアントやサーバのソフトウェアでの利用可能性が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">一般的な原則は、ウェブ開発者が機能が無効化された場合に、その機能を検出したり、処理したりするための、直感的な、あるいは壊れない方法があるべきであるということです。新しく導入された機能には、その状態を知らせる明示的なAPIがあるかもしれません。後にフィーチャーポリシーと統合される既存の機能は、一般的に既存のメカニズムを使用します。いくつかのアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">グローバル &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; 属性はHTML要素で使用され、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;ドキュメント全体またはその一部の言語を示します。</target>
        </trans-unit>
        <trans-unit id="b96cd855a9766df4b3721ceeb897076805d066a4" translate="yes" xml:space="preserve">
          <source>The header contains identifiers for one or more digest algorithms that the sender wishes the responder to use to create the digest. The sender may use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality values&lt;/a&gt; to indicate its preference ordering among the choices it offers.</source>
          <target state="translated">ヘッダーには、送信者がレスポンダーにダイジェストの作成に使用することを希望する1つ以上のダイジェストアルゴリズムの識別子が含まれています。送信者は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;品質値&lt;/a&gt;を使用して、提供する選択肢の中から優先順位を示すことができます。</target>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">URL から抽出したホスト名。これは便宜上のものであり、 ://と最初の:または/の間と同じ文字列になります。ポート番号はこのパラメータには含まれません。必要に応じて URL から抽出することができます。</target>
        </trans-unit>
        <trans-unit id="5f24db479cf2b72fa937bcb464d99834bc0f6796" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between &lt;code&gt;://&lt;/code&gt; and the first &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">URLから抽出されたホスト名。これは便宜上のものです。 &lt;code&gt;://&lt;/code&gt; と最初の &lt;code&gt;:&lt;/code&gt; または &lt;code&gt;/&lt;/code&gt; の後の文字列と同じです。ポート番号はこのパラメーターに含まれていません。必要に応じてURLから抽出できます。</target>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">URLからのホスト名(ポート番号を除く)。</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">URLからのホスト名です。</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">IDとWeb上のリソースの場所は、ほとんどが単一のURL（URIの一種であるUniform Resource Locator）によって提供されます。IDと場所が同じURIで提供されない理由が時々あります。HTTPは、要求されたリソースがクライアントに別の場所でアクセスすることを要求したときに、特定のHTTPヘッダー&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">iframeのallow属性</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">いくつかのブラウザでこのプリフェッチを実装することで、実際のページコンテンツのフェッチと並行して(シリアルではなく)ドメイン名解決を行うことができます。これにより、高遅延のドメイン名解決プロセスは、コンテンツをフェッチしている間に遅延を発生させません。</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">app:draft &quot;要素を含めることは、メンバーリソースの可視性を制御するためのクライアントからのリクエストを表す。app:draft要素はサーバーによって無視されてもよい[MAY]。app:controlに含まれるapp:draft要素の数は0か1でなければならない[MUST]。app:draft要素の内容は &quot;yes &quot;か &quot;no &quot;のいずれかでなければならない[MUST]。要素に &quot;no &quot;が含まれている場合、これはメンバーリソースを公開することをクライアントが要求していることを示す。app:draft要素が存在しない場合、拡張機能をサポートするサーバーは、「no」を含む app:draft要素が送られたかのように動作しなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下の情報は、MDNのGitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）から取得されています。</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">クライアントによる情報は非常に冗長であり(HTTP/2ヘッダ圧縮はこの問題を軽減します)、プライバシーリスク(HTTPフィンガープリンティング)があります。</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下に示す情報は、MDNのGitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）から取得されています。</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">初期範囲単位レジストリには、以下の登録が含まれています。+ ------------- + ------------------------- -------------- + ------------- + |レンジユニット|説明|リファレンス| |名前| | | + ------------- + ----------------------------------- ---- + ------------- + |バイト|オクテットの範囲| &lt;a href=&quot;#section-2.1&quot;&gt;セクション2.1&lt;/a&gt; | |なし|キーワードとして予約されており、| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | | |範囲がサポートされています| | + ------------- + ----------------------------------- ---- + ------------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">HTTPの初期バージョンにはバージョン番号がありませんでした。後のバージョンと区別するために、後で0.9と呼ばれています。HTTP / 0.9は非常にシンプルです。リクエストは1行で構成され、唯一可能なメソッド&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; で&lt;/a&gt;始まり、リソースへのパスが続きます（サーバーに接続すると、プロトコル、サーバー、ポートの両方が不要になるため、URLではありません）。</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">プロキシサーバにリクエストが入ってきたインターフェース。</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt;の導入により、ブラウザまたはクライアントは、その要件またはハードウェアの制約に関する情報をサーバーにプロアクティブに通信できます。</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">&lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーにセキュリティ関連のプレフィックスが導入されたことにより、安全なCookieが変更されていないことを保証できるようになりました。</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">発行されたリクエストは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">このアップグレード要求のキーです。クライアントがこれを追加したい場合はクライアントが追加します。 サーバは応答に独自のキーを含めます。</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]で説明されているように解釈されます。実装は、実装するプロトコルの1つ以上の必須レベルまたは必須レベルの要件を満たさない場合、準拠しません。プロトコルのすべてのMUSTまたはREQUIREDレベルおよびすべてのSHOULDレベルの要件を満たす実装は、「無条件に準拠」していると言われています。プロトコルのすべてのMUSTレベルの要件を満たしているが、そのプロトコルのすべてのSHOULDレベルの要件を満たしていないものは、「条件付きで準拠している」と言われます。</target>
        </trans-unit>
        <trans-unit id="48f7d02ccdd6151055ec019221672e2ab74e0330" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   All numeric values are in network byte order.  Values are unsigned
   unless otherwise indicated.  Literal values are provided in decimal
   or hexadecimal as appropriate.  Hexadecimal literals are prefixed
   with &quot;0x&quot; to distinguish them from decimal literals.

   The following terms are used:

   client:  The endpoint that initiates an HTTP/2 connection.  Clients
      send HTTP requests and receive HTTP responses.

   connection:  A transport-layer connection between two endpoints.

   connection error:  An error that affects the entire HTTP/2
      connection.

   endpoint:  Either the client or server of the connection. 

   frame:  The smallest unit of communication within an HTTP/2
      connection, consisting of a header and a variable-length sequence
      of octets structured according to the frame type.

   peer:  An endpoint.  When discussing a particular endpoint, &quot;peer&quot;
      refers to the endpoint that is remote to the primary subject of
      discussion.

   receiver:  An endpoint that is receiving frames.

   sender:  An endpoint that is transmitting frames.

   server:  The endpoint that accepts an HTTP/2 connection.  Servers
      receive HTTP requests and send HTTP responses.

   stream:  A bidirectional flow of frames within the HTTP/2 connection.

   stream error:  An error on the individual HTTP/2 stream.

   Finally, the terms &quot;gateway&quot;, &quot;intermediary&quot;, &quot;proxy&quot;, and &quot;tunnel&quot;
   are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;.  Intermediaries act as both
   client and server at different times.

   The term &quot;payload body&quot; is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです。記載されるように解釈されるべき&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;]。すべての数値はネットワークバイトオーダーです。特に明記されていない限り、値は符号なしです。リテラル値は、必要に応じて10進数または16進数で提供されます。 16進リテラルには、10進リテラルと区別するために接頭辞「0x」が付いています。次の用語が使用されます。client：HTTP / 2接続を開始するエンドポイント。クライアントはHTTP要求を送信し、HTTP応答を受信します。接続：2つのエンドポイント間のトランスポート層接続。接続エラー：HTTP / 2接続全体に影響するエラー。エンドポイント：接続のクライアントまたはサーバー。フレーム：HTTP / 2接続内の通信の最小単位であり、ヘッダーと、フレームタイプに従って構造化されたオクテットの可変長シーケンスで構成されます。ピア：エンドポイント。特定のエンドポイントについて話し合うときは、「ピア」議論の主要な主題から離れたエンドポイントを指します。受信者：フレームを受信して​​いるエンドポイント。送信者：フレームを送信しているエンドポイント。サーバー：HTTP / 2接続を受け入れるエンドポイント。サーバーはHTTP要求を受信し、HTTP応答を送信します。ストリーム：HTTP / 2接続内のフレームの双方向フロー。ストリームエラー：個々のHTTP / 2ストリームのエラー。最後に、「ゲートウェイ」、「中間」、「プロキシ」、および「トンネル」という用語は、HTTP / 2接続内のフレームの双方向フロー。ストリームエラー：個々のHTTP / 2ストリームのエラー。最後に、「ゲートウェイ」、「中間」、「プロキシ」、および「トンネル」という用語は、HTTP / 2接続内のフレームの双方向フロー。ストリームエラー：個々のHTTP / 2ストリームのエラー。最後に、「ゲートウェイ」、「中間」、「プロキシ」、および「トンネル」という用語は、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]のセクション2.3&lt;/a&gt;。仲介者は、異なる時間にクライアントとサーバーの両方として機能します。 「ペイロード本体」という用語は&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;、[RFC7230]のセクション3.3で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。エラー処理に関する適合基準と考慮事項は、&lt;a href=&quot;#section-2.5&quot;&gt;セクション2.5で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 【に記載されるように解釈される&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]。エラー処理に関する適合基準と考慮事項&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;は、[RFC7230]のセクション2.5で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">検証の種類は、使用するバリデーターとは無関係です。どちらも、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; のは、&lt;/a&gt;複雑さが異なる場合があり、サーバー側でそれを実装するものの、検証の両方のタイプを可能にします。HTTPはデフォルトで強力な検証を使用し、弱い検証をいつ使用できるかを指定します。</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">HTTPに起こった最大の変化は、1994年末に行われました。基本的なTCP/IPスタック上でHTTPを送信する代わりに、Netscape通信はその上に暗号化された送信層を追加で作成しました。SSLです。SSL 1.0は決して外部には公開されませんでしたが、SSL 2.0とその後継のSSL 3.0とSSL 3.1は、サーバーとクライアントの間で交換されるメッセージの真正性を暗号化して保証することで、電子商取引のウェブサイトを作成することを可能にしました。SSLは標準化され、最終的にはTLSとなり、バージョン1.0、1.1、1.2では脆弱性を解消することに成功しました。TLS 1.3は現在作成中です。</target>
        </trans-unit>
        <trans-unit id="cedd0ab48b46862829d9707f126e162c35e1388c" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communications created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the company, but SSL 2.0 and its successor SSL 3.0 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with versions 1.0, 1.1, 1.2, and 1.3 appearing successfully to close vulnerabilities.</source>
          <target state="translated">HTTPに起こった最大の変化は、1994年末に行われました。Netscape Communications は基本的な TCP/IP スタック上で HTTP を送信する代わりに、その上に暗号化された送信層を追加で作りました。SSLです。SSL 1.0が社外に公開されることはありませんでしたが、SSL 2.0とその後継のSSL 3.0では、サーバーとクライアントの間でやり取りされるメッセージを暗号化して真正性を保証することで、電子商取引のウェブサイトを作成することが可能になりました。SSLは標準化され、最終的にはTLSとなり、バージョン1.0、1.1.1、1.2、1.3では脆弱性を解消することに成功しました。</target>
        </trans-unit>
        <trans-unit id="8afbff65f36ae363825e270b4816f35143b381cc" translate="yes" xml:space="preserve">
          <source>The last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">同じリソースの複数のバージョンを比較するために使用される、リソースの最終変更日。&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ほど正確ではありませんが、環境によっては計算が簡単です。&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; を&lt;/a&gt;使用する条件付きリクエストは、この値を使用してリクエストの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="a9022ae767f477f1c7bcdb68243b1fa5a2efe966" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code that sufficiently answers the request without the need for corresponding payload (like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt;) usually don't.</source>
          <target state="translated">応答の最後の部分は体です。いないすべての応答は1を持っています。十分に（のようなペイロード対応を必要とせずに要求に答えることをステータスコードとレスポンス&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; か、&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; ）通常はしません。</target>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">応答の最後の部分は本文です。すべての応答に1つがあるわけではありません。通常、&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;などのステータスコードを持つ応答にはありません。</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">オクテット数の10進数での長さです。</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">メッセージ本文の長さは、次のいずれかによって決定されます（優先順）：1. HEAD要求に対する応答と、1xx（情報）、204（内容なし）、または304（変更なし）を含む応答。ステータスコードは、メッセージに存在するヘッダーフィールドに関係なく、常にヘッダーフィールドの後の最初の空行で終了するため、メッセージ本文を含めることはできません。2. CONNECT要求に対する2xx（成功）応答は、ヘッダーフィールドを終了する空の行の直後に接続がトンネルになることを意味します。クライアントは、そのようなメッセージで受信されたContent-LengthまたはTransfer-Encodingヘッダーフィールドを無視する必要があります。3. Transfer-Encodingヘッダーフィールドが存在し、チャンク転送コーディング（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）は最終的なエンコードです。メッセージ本体の長さは、転送コーディングがデータの完了を示すまで、チャンクされたデータを読み取ってデコードすることによって決定されます。 Transfer-Encodingヘッダーフィールドが応答に存在し、チャンク転送コーディングが最終的なエンコーディングでない場合、メッセージ本文の長さは、サーバーによって閉じられるまで接続を読み取ることによって決定されます。 Transfer-Encodingヘッダーフィールドがリクエストに存在し、チャンク転送コーディングが最終的なエンコーディングでない場合、メッセージ本文の長さを確実に決定できません。サーバーは400（Bad Request）ステータスコードで応答してから、接続を閉じる必要があります。 Transfer-EncodingヘッダーとContent-Lengthヘッダーフィールドの両方を含むメッセージを受信した場合、Transfer-EncodingはContent-Lengthをオーバーライドします。このようなメッセージは、リクエストの密輸（&lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt;）または応答分割（&lt;a href=&quot;#section-9.4&quot;&gt;セクション9.4&lt;/a&gt;）、エラーとして処理する必要があります。送信者は、このようなメッセージをダウンストリームに転送する前に、受信したContent-Lengthフィールドを削除する必要があります。 4.メッセージがTransfer-Encodingなしで受信され、フィールド値が異なる複数のContent-Lengthヘッダーフィールド、または無効な値を持つ単一のContent-Lengthヘッダーフィールドが含まれる場合、メッセージのフレーミングは無効であり、受信者はそれを処理する必要があります。回復不可能なエラーとして。これが要求メッセージである場合、サーバーは400（Bad Request）ステータスコードで応答してから、接続を閉じる必要があります。これがプロキシによって受信された応答メッセージである場合、プロキシはサーバーへの接続を閉じ、受信した応答を破棄し、502（不正なゲートウェイ）応答をクライアントに送信する必要があります。これがユーザーエージェントによって受信された応答メッセージである場合、ユーザーエージェントはサーバーへの接続を閉じ、受信した応答を破棄する必要があります。 5.有効なContent-LengthヘッダーフィールドがTransfer-Encodingなしで存在する場合、その10進値は予想されるメッセージ本文の長さをオクテットで定義します。送信者が接続を閉じるか、指定された数のオクテットを受信する前に受信者がタイムアウトした場合、受信者はメッセージが不完全であると見なして接続を閉じる必要があります。 6.これが要求メッセージであり、上記のいずれにも該当しない場合、メッセージ本文の長さはゼロです（メッセージ本文は存在しません）。 7.それ以外の場合、これはメッセージ本文の長さが宣言されていない応答メッセージです。したがって、メッセージ本文の長さは、サーバーが接続を閉じる前に受信したオクテットの数によって決まります。正常に完了した区切り文字のメッセージと、ネットワーク障害によって中断された部分的に受信されたメッセージを区別する方法がないため、サーバーは、可能な場合は常にエンコードメッセージまたは長さ区切りのメッセージを生成する必要があります。クローズ区切り機能は、主にHTTP / 1.0との下位互換性のために存在します。サーバーは、411（Length Required）で応答することにより、メッセージ本文を含むがContent-Lengthを含まない要求を拒否してもよい（MAY）。チャンク以外の転送コーディングが適用されていない限り、メッセージ本文を含むリクエストを送信するクライアントは、メッセージ本文の長さが事前にわかっている場合、有効なContent-Lengthヘッダーフィールドを使用する必要があります。チャンク転送コーディングではなく、チャンク転送コーディングを理解している場合でも、一部の既存のサービスは411（Length Required）ステータスコードでチャンクに応答します。これは通常、そのようなサービスが呼び出される前にcontent-lengthを必要とするゲートウェイを介して実装されており、サーバーが処理前にリクエスト全体をバッファリングできない、または望まないためです。メッセージ本文を含むリクエストを送信するユーザーエージェントは、サーバーがHTTP / 1.1（またはそれ以降）のリクエストを処理することを知らない場合、有効なContent-Lengthヘッダーフィールドを送信する必要があります。このような知識は、特定のユーザー構成の形式にすることも、以前に受け取った応答のバージョンを覚えておくこともできます。接続の最後のリクエストへの最終応答が完全に受信され、読み取る追加のデータが残っている場合、ユーザーエージェントは残りのデータを破棄するか、そのデータが前の応答本文の一部として属しているかどうかを判断しようとします。前のメッセージのContent-Length値が正しくない場合。そのような振る舞いはキャッシュポイズニングに対して脆弱であるため、クライアントはそのような余分なデータを別の応答として処理、キャッシュ、または転送してはなりません（MUST NOT）。このような動作はキャッシュポイズニングに対して脆弱であるためです。このような動作はキャッシュポイズニングに対して脆弱であるためです。</target>
        </trans-unit>
        <trans-unit id="3e37cbe5ee6782b6ab613b55eb65c69ee9c91d78" translate="yes" xml:space="preserve">
          <source>The lifecycle of a stream is shown in Figure 2.

                                +--------+
                        send PP |        | recv PP
                       ,--------|  idle  |--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------| reserved |          | recv H    | reserved |------.
       |      | (local)  |          |           | (remote) |      |
       |      +----------+          v           +----------+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------|  open  |-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +--------+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half   |          |           |   half   |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----------+          |           +----------+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           | send R /       v        send R / |           |
       |           | recv R     +--------+   recv R   |           |
       | send R /  `-----------&amp;gt;|        |&amp;lt;-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `-----------------------&amp;gt;|        |&amp;lt;----------------------'
                                +--------+

          send:   endpoint sends this frame
          recv:   endpoint receives this frame

          H:  HEADERS frame (with implied CONTINUATIONs)
          PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
          ES: END_STREAM flag
          R:  RST_STREAM frame

                          Figure 2: Stream States

   Note that this diagram shows stream state transitions and the frames
   and flags that affect those transitions only.  In this regard,
   CONTINUATION frames do not result in state transitions; they are
   effectively part of the HEADERS or PUSH_PROMISE that they follow. 

   For the purpose of state transitions, the END_STREAM flag is
   processed as a separate event to the frame that bears it; a HEADERS
   frame with the END_STREAM flag set can cause two state transitions.

   Both endpoints have a subjective view of the state of a stream that
   could be different when frames are in transit.  Endpoints do not
   coordinate the creation of streams; they are created unilaterally by
   either endpoint.  The negative consequences of a mismatch in states
   are limited to the &quot;closed&quot; state after sending RST_STREAM, where
   frames might be received for some time after closing.

   Streams have the following states:

   idle:
      All streams start in the &quot;idle&quot; state.

      The following transitions are valid from this state:

      *  Sending or receiving a HEADERS frame causes the stream to
         become &quot;open&quot;.  The stream identifier is selected as described
         in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The same HEADERS frame can also cause a
         stream to immediately become &quot;half-closed&quot;.

      *  Sending a PUSH_PROMISE frame on another stream reserves the
         idle stream that is identified for later use.  The stream state
         for the reserved stream transitions to &quot;reserved (local)&quot;.

      *  Receiving a PUSH_PROMISE frame on another stream reserves an
         idle stream that is identified for later use.  The stream state
         for the reserved stream transitions to &quot;reserved (remote)&quot;.

      *  Note that the PUSH_PROMISE frame is not sent on the idle stream
         but references the newly reserved stream in the Promised Stream
         ID field.

      Receiving any frame other than HEADERS or PRIORITY on a stream in
      this state MUST be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
      of type PROTOCOL_ERROR.

   reserved (local):
      A stream in the &quot;reserved (local)&quot; state is one that has been
      promised by sending a PUSH_PROMISE frame.  A PUSH_PROMISE frame
      reserves an idle stream by associating the stream with an open
      stream that was initiated by the remote peer (see &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;). 

      In this state, only the following transitions are possible:

      *  The endpoint can send a HEADERS frame.  This causes the stream
         to open in a &quot;half-closed (remote)&quot; state.

      *  Either endpoint can send a RST_STREAM frame to cause the stream
         to become &quot;closed&quot;.  This releases the stream reservation.


      An endpoint MUST NOT send any type of frame other than HEADERS,
      RST_STREAM, or PRIORITY in this state.

      A PRIORITY or WINDOW_UPDATE frame MAY be received in this state.
      Receiving any type of frame other than RST_STREAM, PRIORITY, or
      WINDOW_UPDATE on a stream in this state MUST be treated as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   reserved (remote):
      A stream in the &quot;reserved (remote)&quot; state has been reserved by a
      remote peer.

      In this state, only the following transitions are possible:

      *  Receiving a HEADERS frame causes the stream to transition to
         &quot;half-closed (local)&quot;.

      *  Either endpoint can send a RST_STREAM frame to cause the stream
         to become &quot;closed&quot;.  This releases the stream reservation.

      An endpoint MAY send a PRIORITY frame in this state to
      reprioritize the reserved stream.  An endpoint MUST NOT send any
      type of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in
      this state.

      Receiving any type of frame other than HEADERS, RST_STREAM, or
      PRIORITY on a stream in this state MUST be treated as a connection
      error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   open:
      A stream in the &quot;open&quot; state may be used by both peers to send
      frames of any type.  In this state, sending peers observe
      advertised stream-level flow-control limits (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

      From this state, either endpoint can send a frame with an
      END_STREAM flag set, which causes the stream to transition into
      one of the &quot;half-closed&quot; states.  An endpoint sending an 

      END_STREAM flag causes the stream state to become &quot;half-closed
      (local)&quot;; an endpoint receiving an END_STREAM flag causes the
      stream state to become &quot;half-closed (remote)&quot;.

      Either endpoint can send a RST_STREAM frame from this state,
      causing it to transition immediately to &quot;closed&quot;.

   half-closed (local):
      A stream that is in the &quot;half-closed (local)&quot; state cannot be used
      for sending frames other than WINDOW_UPDATE, PRIORITY, and
      RST_STREAM.

      A stream transitions from this state to &quot;closed&quot; when a frame that
      contains an END_STREAM flag is received or when either peer sends
      a RST_STREAM frame.

      An endpoint can receive any type of frame in this state.
      Providing flow-control credit using WINDOW_UPDATE frames is
      necessary to continue receiving flow-controlled frames.  In this
      state, a receiver can ignore WINDOW_UPDATE frames, which might
      arrive for a short period after a frame bearing the END_STREAM
      flag is sent.

      PRIORITY frames received in this state are used to reprioritize
      streams that depend on the identified stream.

   half-closed (remote):
      A stream that is &quot;half-closed (remote)&quot; is no longer being used by
      the peer to send frames.  In this state, an endpoint is no longer
      obligated to maintain a receiver flow-control window.

      If an endpoint receives additional frames, other than
      WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in
      this state, it MUST respond with a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of
      type STREAM_CLOSED.

      A stream that is &quot;half-closed (remote)&quot; can be used by the
      endpoint to send frames of any type.  In this state, the endpoint
      continues to observe advertised stream-level flow-control limits
      (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

      A stream can transition from this state to &quot;closed&quot; by sending a
      frame that contains an END_STREAM flag or when either peer sends a
      RST_STREAM frame. 

   closed:
      The &quot;closed&quot; state is the terminal state.

      An endpoint MUST NOT send frames other than PRIORITY on a closed
      stream.  An endpoint that receives any frame other than PRIORITY
      after receiving a RST_STREAM MUST treat that as a stream error
      (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type STREAM_CLOSED.  Similarly, an endpoint
      that receives any frames after receiving a frame with the
      END_STREAM flag set MUST treat that as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type STREAM_CLOSED, unless the frame is
      permitted as described below.

      WINDOW_UPDATE or RST_STREAM frames can be received in this state
      for a short period after a DATA or HEADERS frame containing an
      END_STREAM flag is sent.  Until the remote peer receives and
      processes RST_STREAM or the frame bearing the END_STREAM flag, it
      might send frames of these types.  Endpoints MUST ignore
      WINDOW_UPDATE or RST_STREAM frames received in this state, though
      endpoints MAY choose to treat frames that arrive a significant
      time after sending END_STREAM as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

      PRIORITY frames can be sent on closed streams to prioritize
      streams that are dependent on the closed stream.  Endpoints SHOULD
      process PRIORITY frames, though they can be ignored if the stream
      has been removed from the dependency tree (see &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;).

      If this state is reached as a result of sending a RST_STREAM
      frame, the peer that receives the RST_STREAM might have already
      sent -- or enqueued for sending -- frames on the stream that
      cannot be withdrawn.  An endpoint MUST ignore frames that it
      receives on closed streams after it has sent a RST_STREAM frame.
      An endpoint MAY choose to limit the period over which it ignores
      frames and treat frames that arrive after this time as being in
      error.

      Flow-controlled frames (i.e., DATA) received after sending
      RST_STREAM are counted toward the connection flow-control window.
      Even though these frames might be ignored, because they are sent
      before the sender receives the RST_STREAM, the sender will
      consider the frames to count against the flow-control window.

      An endpoint might receive a PUSH_PROMISE frame after it sends
      RST_STREAM.  PUSH_PROMISE causes a stream to become &quot;reserved&quot;
      even if the associated stream has been reset.  Therefore, a
      RST_STREAM is needed to close an unwanted promised stream. 

   In the absence of more specific guidance elsewhere in this document,
   implementations SHOULD treat the receipt of a frame that is not
   expressly permitted in the description of a state as a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that PRIORITY can
   be sent and received in any stream state.  Frames of unknown types
   are ignored.

   An example of the state transitions for an HTTP request/response
   exchange can be found in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.  An example of the state
   transitions for server push can be found in Sections &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; and &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;.</source>
          <target state="translated">ストリームのライフサイクルを図2に示します。+ -------- + send PP | | recv PP、-------- |アイドル| --------。 / | | \ v + -------- + v + ---------- + | + ---------- + | | | Hを送信/ | | 、------ |予約済み| | recv H |予約済み| ------。 | | （ローカル）| | | （リモート）| | | + ---------- + v + ---------- + | | | + -------- + | | | | recv ES | | ESを送信| | | Hを送信| 、------- |開く| -------。 | recv H | | | / | | \ | | | vv + -------- + vv | | + ---------- + | + ---------- + | | |半分| | |半分| | | |クローズ| | Rを送信/ |クローズ| | | | （リモート）| | recv R | （ローカル）| | | + ---------- + | + ---------- + | | | | | | | | ESを送信/ | recv ES / | | | | R / vを送信R /を送信| | | | recv R + -------- + recv R | | | Rを送信/ `-----------&amp;gt; | | &amp;lt;----------- '送信R / | | recv R |クローズ| recv R | `-----------------------&amp;gt; | | &amp;lt;---------------------- '+ -------- +送信：エンドポイントはこのフレームを送信しますrecv：エンドポイントはこのフレームを受信しますH：HEADERSフレーム（暗黙のCONTINUATIONSを含む）PP：PUSH_PROMISEフレーム（暗黙のCONTINUATIONSを含む）ES：END_STREAMフラグR：RST_STREAMフレーム図2：ストリームの状態この図はストリームの状態遷移とこれらの遷移にのみ影響するフレームとフラグ。この点で、CONTINUATIONフレームは状態遷移を引き起こしません。それらは事実上、それらが従うHEADERSまたはPUSH_PROMISEの一部です。状態遷移の目的で、END_STREAMフラグは、それを保持するフレームとは別のイベントとして処理されます。 END_STREAMフラグが設定されたHEADERSフレームは、2つの状態遷移を引き起こす可能性があります。両方のエンドポイントには、フレームの転送中に異なる可能性のあるストリームの状態の主観的なビューがあります。エンドポイントはストリームの作成を調整しません。それらは、いずれかのエンドポイントによって一方的に作成されます。状態の不一致による悪影響は、RST_STREAMを送信した後の「閉じた」状態に限定されます。この場合、フレームは閉じた後しばらくの間受信される可能性があります。ストリームには次の状態があります。アイドル：すべてのストリームは「アイドル」状態で開始します。この状態から、次の遷移が有効になります。* HEADERSフレームを送信または受信すると、ストリームが「オープン」になります。ストリーム識別子は、説明されているように選択されますこの状態から、次の遷移が有効になります。* HEADERSフレームを送信または受信すると、ストリームが「オープン」になります。ストリーム識別子は、説明されているように選択されますこの状態から、次の遷移が有効になります。* HEADERSフレームを送信または受信すると、ストリームが「オープン」になります。ストリーム識別子は、説明されているように選択されます&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;。同じHEADERSフレームにより、ストリームがすぐに「ハーフクローズ」になる可能性もあります。 *別のストリームでPUSH_PROMISEフレームを送信すると、後で使用するために識別されたアイドルストリームが予約されます。予約済みストリームのストリーム状態は「予約済み（ローカル）」に移行します。 *別のストリームでPUSH_PROMISEフレームを受信すると、後で使用するために識別されるアイドルストリームが予約されます。予約済みストリームのストリーム状態は「予約済み（リモート）」に移行します。 * PUSH_PROMISEフレームはアイドルストリームでは送信されませんが、Promised StreamIDフィールドで新しく予約されたストリームを参照することに注意してください。この状態のストリームでHEADERSまたはPRIORITY以外のフレームを受信すると、接続エラーとして扱われる必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。予約済み（ローカル）：「予約済み（ローカル）」状態のストリームは、PUSH_PROMISEフレームを送信することによって約束されたストリームです。 PUSH_PROMISEフレームは、リモートピアによって開始されたオープンストリームにストリームを関連付けることにより、アイドルストリームを予約します（&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2を&lt;/a&gt;参照）。）。この状態では、次の遷移のみが可能です。*エンドポイントはHEADERSフレームを送信できます。これにより、ストリームは「ハーフクローズ（リモート）」状態で開きます。 *どちらのエンドポイントもRST_STREAMフレームを送信して、ストリームを「クローズ」にすることができます。これにより、ストリームの予約が解放されます。エンドポイントは、この状態でHEADERS、RST_STREAM、またはPRIORITY以外のタイプのフレームを送信してはなりません（MUSTNOT）。この状態では、PRIORITYまたはWINDOW_UPDATEフレームを受信できます。この状態のストリームでRST_STREAM、PRIORITY、またはWINDOW_UPDATE以外のタイプのフレームを受信する場合は、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。予約済み（リモート）：「予約済み（リモート）」状態のストリームは、リモートピアによって予約されています。この状態では、次の遷移のみが可能です。* HEADERSフレームを受信すると、ストリームは「ハーフクローズ（ローカル）」に遷移します。 *どちらのエンドポイントもRST_STREAMフレームを送信して、ストリームを「クローズ」にすることができます。これにより、ストリームの予約が解放されます。エンドポイントは、予約済みストリームの優先順位を再設定するために、この状態でPRIORITYフレームを送信してもよい[MAY]。エンドポイントは、この状態でRST_STREAM、WINDOW_UPDATE、またはPRIORITY以外のタイプのフレームを送信してはなりません（MUSTNOT）。この状態のストリームでHEADERS、RST_STREAM、またはPRIORITY以外のタイプのフレームを受信する場合は、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。 open：「open」状態のストリームは、両方のピアが任意のタイプのフレームを送信するために使用できます。この状態では、送信ピアはアドバタイズされたストリームレベルのフロー制御制限を監視します（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）。この状態から、どちらのエンドポイントもEND_STREAMフラグが設定されたフレームを送信できます。これにより、ストリームは「ハーフクローズ」状態の1つに遷移します。 END_STREAMフラグを送信するエンドポイントにより、ストリームの状態が「ハーフクローズ（ローカル）」になります。 END_STREAMフラグを受信するエンドポイントにより、ストリーム状態は「ハーフクローズ（リモート）」になります。どちらのエンドポイントも、この状態からRST_STREAMフレームを送信して、すぐに「クローズ」に移行させることができます。ハーフクローズ（ローカル）：「ハーフクローズ（ローカル）」状態のストリームは、WINDOW_UPDATE、PRIORITY、およびRST_STREAM以外のフレームの送信には使用できません。 END_STREAMフラグを含むフレームが受信されるか、いずれかのピアがRST_STREAMフレームを送信すると、ストリームはこの状態から「クローズ」に移行します。エンドポイントは、この状態で任意のタイプのフレームを受信できます。フロー制御フレームの受信を継続するには、WINDOW_UPDATEフレームを使用してフロー制御クレジットを提供する必要があります。この状態では、受信者はWINDOW_UPDATEフレームを無視できます。これは、END_STREAMフラグが設定されたフレームが送信された後、短期間で到着する可能性があります。この状態で受信されたPRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。ハーフクローズ（リモート）：「ハーフクローズ（リモート）」であるストリームは、フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（フロー制御フレームの受信を継続するには、WINDOW_UPDATEフレームを使用してフロー制御クレジットを提供する必要があります。この状態では、受信者はWINDOW_UPDATEフレームを無視できます。これは、END_STREAMフラグが設定されたフレームが送信された後、短期間で到着する可能性があります。この状態で受信されたPRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。ハーフクローズ（リモート）：「ハーフクローズ（リモート）」であるストリームは、フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（フロー制御フレームの受信を継続するには、WINDOW_UPDATEフレームを使用してフロー制御クレジットを提供する必要があります。この状態では、受信者はWINDOW_UPDATEフレームを無視できます。これは、END_STREAMフラグが設定されたフレームが送信された後、短期間で到着する可能性があります。この状態で受信されたPRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。ハーフクローズ（リモート）：「ハーフクローズ（リモート）」であるストリームは、フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（ストリームエラーで応答する必要があります（ストリームエラーで応答する必要があります（これは、END_STREAMフラグが設定されたフレームが送信された後、短期間で到着する可能性があります。この状態で受信されたPRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。ハーフクローズ（リモート）：「ハーフクローズ（リモート）」であるストリームは、フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（これは、END_STREAMフラグが設定されたフレームが送信された後、短期間で到着する可能性があります。この状態で受信されたPRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。ハーフクローズ（リモート）：「ハーフクローズ（リモート）」であるストリームは、フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（フレームを送信するためにピアによって使用されなくなりました。この状態では、エンドポイントはレシーバーフロー制御ウィンドウを維持する義務がなくなります。エンドポイントが、この状態のストリームに対してWINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、エンドポイントはストリームエラーで応答する必要があります（&lt;a href=&quot;#section-5.4.2&quot;&gt;&lt;/a&gt;タイプSTREAM_CLOSEDのセクション5.4.2）。 「ハーフクローズ（リモート）」のストリームは、エンドポイントが任意のタイプのフレームを送信するために使用できます。この状態では、エンドポイントはアドバタイズされたストリームレベルのフロー制御制限を引き続き監視します（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）。ストリームは、END_STREAMフラグを含むフレームを送信するか、いずれかのピアがRST_STREAMフレームを送信すると、この状態から「クローズ」に移行できます。クローズ：「クローズ」状態は最終状態です。エンドポイントは、クローズドストリームでPRIORITY以外のフレームを送信してはなりません（MUSTNOT）。 RST_STREAMを受信した後にPRIORITY以外のフレームを受信するエンドポイントは、それをストリームエラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.2&quot;&gt;セクション5.4.2&lt;/a&gt;）タイプSTREAM_CLOSED。同様に、END_STREAMフラグが設定されたフレームを受信した後にフレームを受信するエンドポイントは、以下で説明するようにフレームが許可されていない限り、それをタイプSTREAM_CLOSEDの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として処理する必要があります。 WINDOW_UPDATEまたはRST_STREAMフレームは、END_STREAMフラグを含むDATAまたはHEADERSフレームが送信された後、この状態で短期間受信できます。リモートピアは、RST_STREAMまたはEND_STREAMフラグが設定されたフレームを受信して​​処理するまで、これらのタイプのフレームを送信する場合があります。エンドポイントは、この状態で受信したWINDOW_UPDATEまたはRST_STREAMフレームを無視する必要がありますが、エンドポイントは、END_STREAMを送信してからかなりの時間が経過したフレームを接続エラーとして扱うことを選択できます（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1）。&lt;/a&gt;）タイプPROTOCOL_ERROR。 PRIORITYフレームをクローズドストリームで送信して、クローズドストリームに依存するストリームに優先順位を付けることができます。エンドポイントはPRIORITYフレームを処理する必要がありますが、依存関係ツリーからストリームが削除されている場合は無視できます（&lt;a href=&quot;#section-5.3.4&quot;&gt;セクション5.3.4を&lt;/a&gt;参照）。）。 RST_STREAMフレームを送信した結果としてこの状態に達した場合、RST_STREAMを受信するピアは、撤回できないストリーム上のフレームをすでに送信しているか、送信のためにキューに入れている可能性があります。エンドポイントは、RST_STREAMフレームを送信した後、クローズドストリームで受信したフレームを無視する必要があります。エンドポイントは、フレームを無視する期間を制限し、この時間の後に到着するフレームをエラーとして扱うことを選択できます（MAY）。 RST_STREAMの送信後に受信されたフロー制御フレーム（つまり、DATA）は、接続フロー制御ウィンドウにカウントされます。これらのフレームは無視される可能性がありますが、送信者がRST_STREAMを受信する前に送信されるため、送信者はフレームをフロー制御ウィンドウに対してカウントすることを検討します。エンドポイントは、RST_STREAMを送信した後にPUSH_PROMISEフレームを受信する場合があります。PUSH_PROMISEを使用すると、関連付けられたストリームがリセットされた場合でも、ストリームは「予約済み」になります。したがって、不要な約束されたストリームを閉じるには、RST_STREAMが必要です。このドキュメントの他の場所に具体的なガイダンスがない場合、実装は、状態の説明で明示的に許可されていないフレームの受信を接続エラーとして扱う必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;タイプPROTOCOL_ERRORのセクション5.4.1）。PRIORITYは、任意のストリーム状態で送受信できることに注意してください。不明なタイプのフレームは無視されます。HTTP要求/応答交換の状態遷移の例は、&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1にあり&lt;/a&gt;ます。サーバープッシュの状態遷移の例は、セクション&lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;および&lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bc721cb7f57681a68e8ffe39db25deee64045b40" translate="yes" xml:space="preserve">
          <source>The lifetime of a cookie can be defined in two ways:</source>
          <target state="translated">クッキーの寿命は2つの方法で定義できます。</target>
        </trans-unit>
        <trans-unit id="f51d769847399f42de0ee4cd02eb8aff1ca2aada" translate="yes" xml:space="preserve">
          <source>The link header contains parameters, which are separated with &lt;code&gt;;&lt;/code&gt; and are equivalent to attributes of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">リンクヘッダーには、 &lt;code&gt;;&lt;/code&gt; で区切られたパラメーターが含まれています。およびは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の属性と同等です。</target>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">許可された&lt;a href=&quot;../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;のリスト。</target>
        </trans-unit>
        <trans-unit id="2d4513b7f363144d73199955a36973cf7c46be3c" translate="yes" xml:space="preserve">
          <source>The maximum amount of time a resource is considered fresh. Unlike &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">リソースがフレッシュと見なされる最大時間。 &lt;code&gt;Expires&lt;/code&gt; とは異なり、このディレクティブはリクエストの時間に関連しています。</target>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">HTTP日付のタイムスタンプとしてのCookieの最大有効期間。詳細な形式については、&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;を参照してください。指定しない場合、Cookieには&lt;strong&gt;セッションCookieの&lt;/strong&gt;存続期間があり&lt;strong&gt;ます。&lt;/strong&gt;クライアントがシャットダウンするとセッションは終了します。つまり、セッションCookieはその時点で削除されます。ただし、多くのWebブラウザーにはセッションの復元と呼ばれる機能があり、すべてのタブが保存され、次回ブラウザーを使用したときにタブが再び表示されます。Cookieも表示され、ブラウザを実際に閉じたことがないようです。</target>
        </trans-unit>
        <trans-unit id="d852a80087f1759845814ae78b7b6a4cc10fa2cf" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the required formatting.</source>
          <target state="translated">HTTP日付タイムスタンプとしてのCookieの最大存続期間。必要なフォーマットについては、&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">サポートされる最大サイズは32kBです。</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">サポートされている最大サイズは4GBです。</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">成功の意味は、HTTPリクエストメソッドに依存します。</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">要求されたデータのメディアフォーマットがサーバーでサポートされていないため、サーバーは要求を拒否しています。</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">HTTPメッセージのメッセージ本文（存在する場合）は、その要求または応答のペイロード本文を運ぶために使用されます。&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1で&lt;/a&gt;説明されているように、転送コーディングが適用されていない限り、メッセージ本文はペイロード本文と同じです。 message-body = * OCTETメッセージでメッセージ本文を使用できる場合のルールは、要求と応答で異なります。リクエスト内のメッセージ本文の存在は、Content-LengthまたはTransfer-Encodingヘッダーフィールドによって通知されます。メソッドがメッセージ本文の使用を定義していない場合でも、要求メッセージのフレーミングはメソッドのセマンティクスとは無関係です。応答内のメッセージ本文の存在は、応答先のリクエストメソッドと応答ステータスコードの両方に依存します（&lt;a href=&quot;#section-3.1.2&quot;&gt;セクション3.1.2&lt;/a&gt;）。関連する応答ヘッダーフィールド（たとえば、Transfer-Encoding、Content-Lengthなど）が存在する場合、それらの値のみを示すため、HEADリクエストメソッド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]のセクション4.3.2&lt;/a&gt;）への応答には、メッセージ本文は含まれません。リクエストメソッドがGETであった場合（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]のセクション4.3.1&lt;/a&gt;）。 CONNECT要求メソッドへの2xx（成功）応答（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]のセクション4.3.6&lt;/a&gt;）は、メッセージ本文の代わりにトンネルモードに切り替わります。すべての1xx（情報）、204（コンテンツなし）、および304（変更なし）応答には、メッセージ本文が含まれていません。他のすべての応答にはメッセージ本文が含まれますが、本文の長さがゼロの場合もあります。</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">以下のメッセージヘッダーフィールドを永続的なレジストリに追加する必要があります（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ]を参照）。</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">HTTPメッセージのメッセージ本文（存在する場合）は、要求または応答に関連付けられたエンティティ本体を運ぶために使用されます。 Transfer-Encodingヘッダーフィールド（&lt;a href=&quot;#section-14.41&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;）で示されているように、メッセージ本体がエンティティ本体と異なるのは、転送コーディングが適用されている場合のみです。メッセージ本体=エンティティ本体| &amp;lt;Transition-Encodingに従ってエンコードされたエンティティボディ&amp;gt; Transfer-Encodingは、メッセージの安全かつ適切な転送を保証するためにアプリケーションによって適用される転送コーディングを示すために使用する必要があります。 Transfer-Encodingはエンティティではなくメッセージのプロパティであるため、要求/応答チェーンに沿ってアプリケーションによって追加または削除される場合があります。 （ただし、&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;特定の転送コーディングをいつ使用できるかを制限します。）メッセージ本文でメッセージ本文を使用できる場合の規則は、要求と応答で異なります。要求内のメッセージ本文の存在は、要求のメッセージヘッダーにContent-LengthまたはTransfer-Encodingヘッダーフィールドを含めることによって通知されます。リクエストメソッドの仕様の場合、メッセージボディをリクエストに含めることはできません（&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）リクエストでエンティティ本体を送信することはできません。サーバーはどんなリクエストでもメッセージ本文を読んで転送すべきです。リクエストメソッドにエンティティボディの定義されたセマンティクスが含まれていない場合、リクエストを処理するときにメッセージボディを無視する必要があります（SHOULD）。応答メッセージの場合、メッセージ本文がメッセージに含まれるかどうかは、要求メソッドと応答ステータスコードの両方に依存します（&lt;a href=&quot;#section-6.1.1&quot;&gt;セクション6.1.1&lt;/a&gt;）。エンティティヘッダーフィールドが存在すると信じることができる場合でも、HEADリクエストメソッドへのすべての応答にメッセージ本文を含めることはできません。すべての1xx（情報）、204（コンテンツなし）、および304（変更されていない）応答には、メッセージ本文を含めることはできません。他のすべての応答にはメッセージ本文が含まれますが、長さはゼロになる場合があります。</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">message / httpタイプは、行の長さとエンコーディングに関するすべての「メッセージ」タイプのMIME制限に従う場合、単一のHTTP要求または応答メッセージを囲むために使用できます。タイプ名：メッセージサブタイプ名：http必須パラメーター：N / Aオプションパラメーター：バージョン、msgtypeバージョン：囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：「7ビット」、「8ビット」、または「バイナリ」のみが許可されますセキュリティに関する考慮事項：&lt;a href=&quot;#section-9&quot;&gt;セクション9を参照&lt;/a&gt; 相互運用性に関する考慮事項：N / A公開された仕様：この仕様（&lt;a href=&quot;#section-8.3.1&quot;&gt;セクション8.3.1を&lt;/a&gt;参照）。このメディアタイプを使用するアプリケーション：該当なしフラグメント識別子の考慮事項：該当なし追加情報：マジックナンバー：該当なしこのタイプの非推奨のエイリアス名：該当なしファイル拡張子：該当なしMacintoshファイルタイプコード：該当なし詳細については、連絡先の人物と電子メールアドレス：作成者のアドレスセクションを参照してください。使用目的：共通使用上の制限：なし作成者：「作成者のアドレス」セクションを参照してください。コントローラーの変更：IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">メソッドと元のリクエストの本文は、リダイレクトされたリクエストを実行するために再利用されます。メソッドを&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;に変更する場合は、代わりに&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; を&lt;/a&gt;使用してください。これは、アップロードされたリソースではなく、確認メッセージ（「正常にXYZをアップロードしました」など）である&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;メソッドへの回答を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="9c74b76d94e666b868875958cf478928caee388b" translate="yes" xml:space="preserve">
          <source>The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.</source>
          <target state="translated">サーバーがリクエストを正常に完了させるために必要な表現を保存できないため、リソースに対してメソッドを実行できませんでした。</target>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Request-Lineで指定されたメソッドは、Request-URIで特定されたリソー スに対して許可されていない。応答は、リクエストされたリソースに対して有効なメソッドのリストを含む Allowヘッダーを含まなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">誤解されているX-XSS-Protection &amp;ndash; blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">キャッシュされたリソースを使用すればするほど、Web サイトの応答性とパフォーマンスが向上します。これを最適化するために、グッドプラクティスでは、有効期限を可能な限り未来に設定することを推奨しています。これは定期的に更新されるか、頻繁に更新されるリソースでは可能ですが、まれに更新されるか、まれにしか更新されないリソースでは問題があります。これらのリソースは、キャッシングリソースから最も恩恵を受けるであろうリソースですが、そのために更新が非常に困難になっています。これは、各 Web ページに含まれ、各 Web ページからリンクされている技術的なリソースに典型的なものです。JavaScript と CSS ファイルはまれに変更されますが、変更されたときはすぐに更新したいものです。</target>
        </trans-unit>
        <trans-unit id="2b2d80c0ac04c3f4350cef824a1e1156d252f06e" translate="yes" xml:space="preserve">
          <source>The most &quot;original&quot; implementation of PAC and its JavaScript libraries is, therefore, &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; found in early versions of Firefox. These utilities are found in many other open-source systems including &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;. Firefox later integrated the file into &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; as a C++ string literal. To extract it into its own file, it suffices to copy the chunk into JavaScript with a &lt;code&gt;console.log&lt;/code&gt; directive to print it.</source>
          <target state="translated">したがって、PACとそのJavaScriptライブラリの最も「元の」実装は、Firefoxの初期バージョンにある &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; です。これらのユーティリティは、&lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;を含む他の多くのオープンソースシステムにあります。Firefoxは後で、ファイルをC ++文字列リテラルとして &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; に統合しました。それを独自のファイルに抽出するには、 &lt;code&gt;console.log&lt;/code&gt; ディレクティブを使用してチャンクをJavaScriptにコピーして印刷するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">ロックの最も基本的な形式は、排他ロックです。排他ロックは、この仕様で説明されている方法以外の調整を必要とせずに、コンテンツ変更の競合に対処する必要がないようにします。ただし、ロックの目的がアクセス権の行使から他人を排除することではなく、プリンシパルがアクセス権を行使するつもりであることを示すメカニズムを提供することである場合があります。この場合、共有ロックが提供されます。共有ロックにより、複数のプリンシパルがロックを受け取ることができます。したがって、アクセス権と有効なロックの両方を持つプリンシパルは、ロックされたリソースを使用できます。共有ロックには、リソースに影響を与える2つの信頼セットがあります。最初の信頼セットは、アクセス許可によって作成されます。たとえば、信頼されているプリンシパルリソースへの書き込み権限がある可能性があります。リソースへの書き込みアクセス権を持つユーザーの間で、共有ロックを取得したプリンシパルのセットも互いに信頼し、アクセス許可書き込みセット内に（通常は）より小さな信頼セットを作成する必要があります。インターネット上のすべての可能なプリンシパルから始めて、ほとんどの状況では、これらのプリンシパルの大部分は、特定のリソースへの書き込みアクセス権を持ちません。書き込みアクセス権を持っている少数のプリンシパルの中には、排他的書き込みロックを使用して、編集が上書きの競合から解放されることを保証することを決定する場合があります。他のユーザーは、共同編集者が自分の作業を上書きしないと確信し（潜在的な共同編集者のセットは書き込み権限を持つプリンシパルのセットです）、共有ロックを使用します。プリンシパルがリソースで作業している可能性があることを共同編集者に通知します。 HTTPのWebDAV拡張は、プリンシパルがアクティビティを調整するために必要なすべての通信パスを提供する必要はありません。共有ロックを使用する場合、プリンシパルは任意の帯域外通信チャネルを使用して作業を調整することができます（例：対面のやり取り、手書きのメモ、画面上の付箋、電話による会話、電子メールなど）。共有ロックの目的は、他の誰がリソースに取り組んでいるかを共同編集者に知らせることです。共有ロックが含まれているのは、Webで分散されたオーサリングシステムの経験から、排他ロックは厳格すぎることが多いためです。排他ロックは、特定の編集プロセスを強制するために使用されます。排他ロックを取り出し、リソースを読み取り、編集を実行します。リソースを書き込み、ロックを解放します。この編集プロセスには、プログラムがクラッシュしたときや、ロックの作成者がリソースのロックを解除せずに離れたときなど、ロックが常に適切に解放されるとは限らないという問題があります。両方のタイムアウト（&lt;a href=&quot;#section-6.6&quot;&gt;セクション6.6&lt;/a&gt;）および管理アクションを使用して問題のあるロックを削除できます。どちらのメカニズムも必要なときに使用できない場合があります。タイムアウトが長いか、管理者がいない可能性があります。新しい共有ロックの要求が成功すると、要求元のプリンシパルに関連付けられた一意のロックが生成される必要があります。したがって、5つのプリンシパルが同じリソースの共有書き込みロックを取り出した場合、各プリンシパルに1つずつ、5つのロックと5つのロックトークンが存在します。</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最も一般的な認証方式は、以下で詳しく説明する「基本」認証方式です。IANA &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;は認証スキームのリストを&lt;/a&gt;保持していますが、Amazon AWSなどのホストサービスによって提供される他のスキームもあります。一般的な認証スキームは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="255966f9ca10cd047714babaf260d4a6e24ab848" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme, which is introduced in more detail below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最も一般的な認証スキームは「基本」認証スキームであり、これについては以下で詳しく説明します。IANA&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;は認証スキームのリストを&lt;/a&gt;維持していますが、AmazonAWSなどのホストサービスによって提供される他のスキームがあります。一般的な認証スキームは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">URIの最も一般的な形式は、&lt;em&gt;Webアドレス&lt;/em&gt;と呼ばれるUniform Resource Locator（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;）です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">request-targetの最も一般的な形式はorigin-formです。origin-form =絶対パス[&quot;？&quot; クエリ] CONNECTまたはサーバー全体のOPTIONSリクエスト以外のオリジンサーバーに直接リクエストを送信する場合（詳細は以下を参照）、クライアントは絶対パスとターゲットURIのクエリコンポーネントのみをリクエストターゲットとして送信する必要があります。ターゲットURIのパスコンポーネントが空の場合、クライアントは、リクエストターゲットのorigin-form内のパスとして「/」を送信する必要があります。&lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4で&lt;/a&gt;定義されているように、ホストヘッダーフィールドも送信されます。 。たとえば、http：//www.example.org/where？q = nowとして識別されるリソースの表現をオリジンサーバーから直接取得したいクライアントは、ホストのポート80へのTCP接続を開く（または再利用する） &quot;www.example.org&quot;とし、GET / where？q = now HTTP / 1.1 Host：www.example.orgに続けてリクエストメッセージの残りの行を送信します。</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">ユーザーエージェントのスニッフィングを実行する最も一般的な理由は、ブラウザが動作するデバイスのタイプを決定することです。目的は、異なるデバイスタイプに異なる HTML を提供することです。</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">条件付きリクエストの最も一般的な使用例は、キャッシュの更新です。空のキャッシュがある場合、またはキャッシュがない場合、要求されたリソースは&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; のステータスで送り返されます。</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">最も一般的な使用例はダウンロードを再開することで、最後のフラグメントを受信してから保存されたリソースが変更されていないことを保証することです。</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最も一般的な使用例は、関連付けられた&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;がないキャッシュされたエンティティを更新することです。</target>
        </trans-unit>
        <trans-unit id="f8e294a410237a9ceaa795c432872e161168f9e7" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server. The modern &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;Fetch API&lt;/code&gt;&lt;/a&gt; provides the same features with a more powerful and flexible feature set.</source>
          <target state="translated">HTTPに基づく最も一般的に使用されるAPIは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; API&lt;/a&gt;であり、これを使用して&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;とサーバー間でデータを交換できます。最新の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;Fetch API&lt;/code&gt; &lt;/a&gt;は、より強力で柔軟な機能セットを備えた同じ機能を提供します。</target>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">HTTP上で最も一般的に使用されるAPIは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; APIで、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;とサーバー間でデータを交換するために使用できます。</target>
        </trans-unit>
        <trans-unit id="0a53cc937fbb9dc05f3c30062aeb2e10f7633a16" translate="yes" xml:space="preserve">
          <source>The most commonly used MIME types used for web content are listed below. This isn't a complete list of all the types that may be available, however. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats&lt;/a&gt; guide for that.</source>
          <target state="translated">Webコンテンツに使用される最も一般的に使用されるMIMEタイプを以下に示します。ただし、これは利用可能なすべてのタイプの完全なリストではありません。そのための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;メディアコンテナフォーマット&lt;/a&gt;ガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">ここで最も重要なディレクティブは「 &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; 」であり、これはリソースが新しいと見なされる最大時間です。&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; と&lt;/a&gt;は異なり、このディレクティブはリクエストの時間に関連しています。変更されないアプリケーション内のファイルについては、通常、積極的なキャッシュを追加できます。これには、画像、CSSファイル、JavaScriptファイルなどの静的ファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="ec18430cf06631edb1cb32f0734bdaa2055f42e3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;, which is the maximum amount of time in which a resource will be considered fresh. This directive is relative to the time of the request, and overrides the &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header (if set). For the files in the application that will not change, you can normally use aggressive caching. This includes static files such as images, CSS files, and JavaScript files, for example.</source>
          <target state="translated">ここで最も重要なディレクティブは &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; です。これは、リソースが新しいと見なされる最大時間です。このディレクティブはリクエストの時間に関連しており、&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダー（設定されている場合）をオーバーライドします。変更されないアプリケーション内のファイルについては、通常、積極的なキャッシュを使用できます。これには、画像、CSSファイル、JavaScriptファイルなどの静的ファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;とCORSの両方で公開されている最も興味深い機能は、&lt;a href=&quot;cookies&quot;&gt;HTTP Cookie&lt;/a&gt;とHTTP認証情報を認識する「資格のある」リクエストを作成する機能です。デフォルトでは、クロスサイト &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;呼び出しでは、ブラウザーは資格情報を送信し&lt;strong&gt;ません&lt;/strong&gt; &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; オブジェクトまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;コンストラクターが呼び出されるときに、特定のフラグを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f1f72e7e757ea8a76c23e50644af8cf17ebd184" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">両方によって公開された最も興味深い機能&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;取得&lt;/a&gt;し、CORSは、「資格認定」を意識している要求できるようにする機能である&lt;a href=&quot;cookies&quot;&gt;HTTPクッキー&lt;/a&gt;やHTTP認証情報を。デフォルトでは、クロスサイト &lt;code&gt;XMLHttpRequest&lt;/code&gt; または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;呼び出しでは、ブラウザーは資格情報を送信し&lt;strong&gt;ません&lt;/strong&gt;。 &lt;code&gt;XMLHttpRequest&lt;/code&gt; オブジェクトまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;コンストラクターを呼び出すときに、特定のフラグを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">サポートされているリクエストヘッダの名前。このヘッダはカンマで区切られた任意の数のヘッダをリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">違反した政策課の名称。</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">リクエストを処理するソフトウェアまたは(サブ)製品の名前です。</target>
        </trans-unit>
        <trans-unit id="d061e432c2a538045e603ec2696ad4093da4b49d" translate="yes" xml:space="preserve">
          <source>The name of the software or product that handled the request. Usually in a format similar to &lt;a href=&quot;user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">リクエストを処理したソフトウェアまたは製品の名前。通常、&lt;a href=&quot;user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;と同様の形式です。</target>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; ヘッダーを追加するサーバーまたはソフトウェアの名前または仮名（エージェントが不明の場合は「-」の場合があります）。</target>
        </trans-unit>
        <trans-unit id="80bbc4479b72889e3d5c281d5038ca7ef63f0a3b" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by a user activation.</source>
          <target state="translated">ナビゲーションの要求は、ユーザーの活性化によって引き起こされました。</target>
        </trans-unit>
        <trans-unit id="58047e7a458a00060b7fa6474885924a7bbd022e" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by something other than a user activation.</source>
          <target state="translated">ナビゲーション要求は、ユーザーのアクティベーション以外の何かによってトリガーされました。</target>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">HTTPの次のメジャーバージョンであるHTTP/3では、トランスポート層部分にTCP/TLSではなくQUICを使用します。</target>
        </trans-unit>
        <trans-unit id="b8b5231ea957c239b67921ea4d3ca6986e579896" translate="yes" xml:space="preserve">
          <source>The non-Chromium Edge puts its engine version after the &lt;em&gt;Edge/&lt;/em&gt; token, not the application version.</source>
          <target state="translated">非ChromiumEdgeは、アプリケーションバージョンではなく、&lt;em&gt;Edge /&lt;/em&gt;トークンの後にエンジンバージョンを配置します。</target>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">非標準の &lt;code&gt;Large-Allocation&lt;/code&gt; レスポンスヘッダーは、読み込まれているページが大きな割り当てを実行することをブラウザに通知します。現在、Firefoxにのみ実装されていますが、すべてのブラウザーに送信しても問題はありません。</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">HTTP ヘッダの概念は、リクエストとレスポンスの両方に導入され、メタデータの送信を可能にし、プロトコルを非常に柔軟で拡張性の高いものにしています。</target>
        </trans-unit>
        <trans-unit id="5a8511f9154b7d1710ad96380db408589218a6d1" translate="yes" xml:space="preserve">
          <source>The number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host of the received message as a known &lt;code&gt;Expect-CT&lt;/code&gt; host.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; ヘッダーフィールドの受信後、ユーザーエージェントが受信したメッセージのホストを既知の &lt;code&gt;Expect-CT&lt;/code&gt; ホストと見なす必要がある秒数。</target>
        </trans-unit>
        <trans-unit id="1c597b22723fbfd913584650ba834a8d38d96da2" translate="yes" xml:space="preserve">
          <source>The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. Alternative service entries can be cached for up to &lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt; seconds, minus the age of the response (from the &lt;a href=&quot;age&quot;&gt;&lt;code&gt;Age&lt;/code&gt;&lt;/a&gt; header). If the cached entry expires, the client can no longer use this alternative service for new connections.</source>
          <target state="translated">代替サービスがフレッシュと見なされる秒数。省略した場合、デフォルトで24時間になります。代替サービスエントリは、最大&lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt;秒間、応答の経過時間（&lt;a href=&quot;age&quot;&gt; &lt;code&gt;Age&lt;/code&gt; &lt;/a&gt;ヘッダーから）を差し引いてキャッシュできます。キャッシュされたエントリの有効期限が切れると、クライアントはこの代替サービスを新しい接続に使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">廃止された&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt; ディレクティブ。</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">ユーザーエージェントが「新しいスタイル」のCookieを理解することをサーバーに通知するために使用されている廃止された &lt;code&gt;Cookie2&lt;/code&gt; HTTPリクエストヘッダーですが、現在では、ユーザーエージェントは代わりに&lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">廃止された &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP応答ヘッダーは、サーバーからユーザーエージェントにCookieを送信するために使用されましたが、仕様では非推奨になっています。代わりに&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">許可されているのは、この方法だけです。</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;ヘッダーに許可される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">唯一の違い &lt;code&gt;307&lt;/code&gt; 及び&lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; は、&lt;/a&gt;すなわち &lt;code&gt;307&lt;/code&gt; リダイレクトされた要求が行われたときの方法と本体が変更されないことを保証します。では &lt;code&gt;302&lt;/code&gt; 、いくつかの古いクライアントは間違っする方法を変更した&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;：非と行動 &lt;code&gt;GET&lt;/code&gt; メソッドと &lt;code&gt;302&lt;/code&gt; が持つ振る舞いに対し、Web上でその後、予測不可能である &lt;code&gt;307&lt;/code&gt; は、予測可能です。以下のため &lt;code&gt;GET&lt;/code&gt; リクエスト、彼らの行動は同じです。</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">仕様で定義されている唯一の期待値は &lt;code&gt;Expect: 100-continue&lt;/code&gt; であり、サーバーはそれに応答します。</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">このヘッダーの唯一の有効な値は &lt;code&gt;true&lt;/code&gt; （大文字と小文字を区別）です。資格情報が必要ない場合は、このヘッダーを完全に省略します（値を &lt;code&gt;false&lt;/code&gt; に設定するのではなく）。</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">異なるフィールド名を持つヘッダーフィールドが受信される順序は重要ではありません。ただし、要求のホストや応答の日付など、最初に制御データを含むヘッダーフィールドを送信することをお勧めします。これにより、実装は、メッセージをできるだけ早く処理しない場合を決定できます。後のヘッダーフィールドには条件、認証資格情報、またはリクエストの処理に影響を与える意図的に誤解を招く重複ヘッダーフィールドが含まれる可能性があるため、サーバーはリクエストヘッダーセクション全体が受信されるまでターゲットリソースにリクエストを適用してはなりません（MUST NOT）。送信者は、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されていない限り、メッセージ内で同じフィールド名を持つ複数のヘッダーフィールドを生成してはなりません[つまり、＃（values）]またはヘッダーフィールドは、よく知られている例外です（下記を参照）。受信者は、メッセージのセマンティクスを変更せずに、同じフィールド名を持つ複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合できます。結合されたフィールド値に、後続の各フィールド値を順番に追加します。コンマ。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[メッセージのセマンティクスを変更せずに、コンマで区切られた結合されたフィールド値に後続の各フィールド値を順番に追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[メッセージのセマンティクスを変更せずに、コンマで区切られた結合されたフィールド値に後続の各フィールド値を順番に追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。プロキシは、メッセージを転送するときにこれらのフィールド値の順序を変更してはなりません（MUST NOT）。注：実際には、「Set-Cookie」ヘッダーフィールド（[実際には、「Set-Cookie」ヘッダーフィールド（[実際には、「Set-Cookie」ヘッダーフィールド（[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]）は多くの場合、応答メッセージに複数回表示され、リスト構文を使用しないため、同じ名前の複数のヘッダーフィールドに対する上記の要件に違反しています。単一のフィールド値に結合できないため、受信者はヘッダーフィールドの処理中に「Set-Cookie」を特別なケースとして処理する必要があります。 （詳細について は、[ &lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ]の&lt;a href=&quot;#appendix-A.2.3&quot;&gt;付録A.2.3&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">originはリクエストが開始されたサーバーを示すURIである。これはパス情報を含まず、サーバー名のみを含む。</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">オリジンサーバはリクエストが条件付きであることを要求します。これは、クライアントがリソースの状態を GET してそれを修正し、それをサーバに PUT して戻している間に、 第三者がサーバの状態を修正してしまい、競合が発生してしまうという 'lost update' 問題を防ぐことを目的としています。</target>
        </trans-unit>
        <trans-unit id="73f93eb007ff12547887950cf639f167d2aeb94c" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">オリジンサーバはリクエストが条件付きであることを要求します。このレスポンスは、クライアントがリソースの状態を GET してそれを修正し、それをサーバに PUT して戻している間に、第三者がサーバの状態を修正してしまい、コンフリクトが発生してしまうという「ロストアップデート」の問題を防ぐことを目的としています。</target>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">マッピングされていないURLをロックするための元のWebDAVモデルは、「lock-nullリソース」を作成しました。このモデルは複雑すぎて、相互運用性と実装の問題がいくつか発見されました。マッピングされていないURLをロックするための新しいWebDAVモデル（&lt;a href=&quot;#section-7.3&quot;&gt;7.3節を&lt;/a&gt;参照））「ロックされた空のリソース」を作成します。 Lock-nullリソースは非推奨になりました。クライアントはどちらのモデルも処理できる必要があるため、このセクションでは元のモデルについて簡単に説明します。元の「ロックヌルリソース」モデルでは、実装に推奨されなくなりました。oロックヌルリソースが「見つかりません」と表示されることがありました。サーバーは、PUT、MKCOL、OPTIONS、PROPFIND、LOCK、UNLO​​CKを除くすべてのメソッドに対して404または405で応答します。ただし、ロックnullリソースは、親コレクションのメンバーとして表示されます。 o通常のリソースに変換される前にロックが解除されると、サーバーはロックヌルリソースを完全に削除します（URIはマップ解除されます）。ロックは、有効期限が切れたとき、またはロックが解除されたときだけでなく、リソースの名前が変更または移動された場合、または親コレクションの名前が変更または移動された場合も削除されます。 oサーバーは、URLへのPUT要求が成功した場合、lock-nullリソースを通常のリソースに変換します。 o URLへのMKCOL要求が成功した場合、サーバーはロックヌルリソースをコレクションに変換します（ただし、相互運用性の経験から、すべてのサーバーがこの要件を満たしているわけではありません）。 oプロパティ値はDAV：lockdiscoveryおよびDAV：supportedlockプロパティに対して定義されましたが、必ずしもDAV：getcontenttypeなどの他のプロパティに対しては定義されていません。クライアントは、古いモデルの「ロックヌルリソース」と「ロックされた空のリソース」の推奨モデルをサポートするサーバーの両方と簡単に相互運用できます。MKCOLやGETではなく、マップされていないURLへのLOCKの後にのみPUTを試行する。</target>
        </trans-unit>
        <trans-unit id="bd67e38aa52dda3f2ef7884d2b5f132dc5a16c44" translate="yes" xml:space="preserve">
          <source>The original header name &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="translated">元のヘッダー名の&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;は、「referrer」という単語のスペルミスです。 &lt;code&gt;Referrer-Policy&lt;/code&gt; ヘッダには、このスペルミスを共有しません。</target>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">HTTPの元のモデル、およびHTTP / 1.0のデフォルトのモデルは、&lt;em&gt;短期間の接続&lt;/em&gt;です。各HTTP要求は独自の接続で完了します。つまり、各HTTPリクエストの前にTCPハンドシェイクが発生し、これらはシリアル化されます。</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTPヘッダーで指定された元のポリシー。</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTPヘッダーで指定された元のポリシー。</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">ティム・バーナーズ=リーのウェブに対する最初のビジョンは、読み取り専用のメディアではありませんでした。彼が思い描いていたのは、人々がリモートでドキュメントを追加したり移動したりできるウェブ、一種の分散ファイルシステムでした。1996年頃、HTTPがオーサリングを可能にするために拡張され、WebDAVと呼ばれる規格が作られました。これはさらに拡張されて、アドレス帳のエントリーを扱うCardDAVやカレンダーを扱うCalDAVなど、特定のアプリケーション向けに拡張されてきました。しかし、これらすべての*DAV拡張には欠陥がありました。それは、使用するためにはサーバ側で実装しなければならず、これが非常に複雑でした。ウェブ領域での使用は秘密にされていました。</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">ページは、ページ自体と同じ原点のフレームにのみ表示できます。仕様では、このオプションをトップレベル、親、チェーン全体のいずれに適用するかを決定するのはブラウザベンダーに任されていますが、すべての祖先が同じオリジンにない限り、このオプションはあまり有用ではないと主張されています（&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;バグを&lt;/a&gt;参照）725490）。サポートの詳細については、&lt;a href=&quot;#Browser_compatibility&quot;&gt;ブラウザの互換性&lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">ページは、指定された原点のフレームにのみ表示できます。Firefoxでも、 &lt;code&gt;sameorigin&lt;/code&gt; と同じ問題が発生することに注意してください。フレームの祖先が同じオリジンにあるかどうかを確認するためのチェックは行われません。</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">フレーム内にページを表示しようとしているサイトに関わらず、フレーム内にページを表示することはできません。</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">パラメータ「filename」と「filename *」の違いは、「filename *」が&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987で&lt;/a&gt;定義されているエンコーディングを使用することだけです。「filename」と「filename *」の両方が1つのヘッダーフィールド値に存在する場合、「filename」よりも「filename *」の方が優先されます。</target>
        </trans-unit>
        <trans-unit id="acecd71c2fad3b28645f1a60d768a752cf9279b0" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; differ only in that &lt;code&gt;filename*&lt;/code&gt; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; are present in a single header field value, &lt;code&gt;filename*&lt;/code&gt; is preferred over &lt;code&gt;filename&lt;/code&gt; when both are understood.</source>
          <target state="translated">パラメータ &lt;code&gt;filename&lt;/code&gt; と &lt;code&gt;filename*&lt;/code&gt; という点でのみ異なる &lt;code&gt;filename*&lt;/code&gt; で定義されたエンコーディング使用&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987を&lt;/a&gt;。 &lt;code&gt;filename&lt;/code&gt; と &lt;code&gt;filename*&lt;/code&gt; 両方が単一のヘッダーフィールド値に存在する場合、両方が理解されると、 &lt;code&gt;filename*&lt;/code&gt; がファイル名よりも優先され &lt;code&gt;filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">フェッチするリソースのパス。たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;プロトコル&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;ドメイン&lt;/a&gt;（ここでは &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）、またはTCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;ポート&lt;/a&gt;（ここでは &lt;code&gt;80&lt;/code&gt; ）がない場合など、コンテキストから明らかな要素からリソースのURLを取り除いたもの。</target>
        </trans-unit>
        <trans-unit id="d2379dd36e7935200c9bebfe54ad165f2211a593" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here, &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here, &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">フェッチするリソースのパス。たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;プロトコル&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;ドメイン&lt;/a&gt;（ここでは、 &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）、またはTCP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;ポート&lt;/a&gt;（ここでは、 &lt;code&gt;80&lt;/code&gt; ）がない場合など、コンテキストから明らかな要素から削除されたリソースのURL 。</target>
        </trans-unit>
        <trans-unit id="e99d23287797e1b6634cb61b5bed379b6d4f6060" translate="yes" xml:space="preserve">
          <source>The payload of a SETTINGS frame consists of zero or more parameters,
   each consisting of an unsigned 16-bit setting identifier and an
   unsigned 32-bit value.

    +-------------------------------+
    |       Identifier (16)         |
    +-------------------------------+-------------------------------+
    |                        Value (32)                             |
    +---------------------------------------------------------------+

                         Figure 10: Setting Format</source>
          <target state="translated">SETTINGS フレームのペイロードは、0 個以上のパラメータで構成され、各パラメータは符号なし 16 ビットの設定識別子と符号なし 32 ビットの値で構成されます。-------------------------------+| 識別子(16)| +-------------------------------+-------------------------------+| 値(32)| +---------------------------------------------------------------+図 10:設定フォーマット</target>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">以前に取得したリソースを再利用することで、Web サイトやアプリケーションのパフォーマンスを大幅に向上させることができます。ウェブキャッシュはレイテンシとネットワークトラフィックを減らし、リソースの表現を表示するのに必要な時間を短縮します。HTTP キャッシングを利用することで、Web サイトの応答性が向上します。</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">ポリシーは、コンテンツ セキュリティ ポリシーを記述するポリシー ディレクティブを含む文字列です。</target>
        </trans-unit>
        <trans-unit id="04ca5099ed1ac07e8e246737ce5ea3bb570048a1" translate="yes" xml:space="preserve">
          <source>The policy is only effective for &lt;a href=&quot;https://fetch.spec.whatwg.org/#concept-request-mode&quot;&gt;&lt;samp&gt;no-cors&lt;/samp&gt;&lt;/a&gt; requests, which are issued by default for CORS-safelisted methods/headers.</source>
          <target state="translated">ポリシーは次の場合にのみ有効です &lt;a href=&quot;https://fetch.spec.whatwg.org/#concept-request-mode&quot;&gt;&lt;samp&gt;no-cors&lt;/samp&gt;&lt;/a&gt; CORSセーフリストのメソッド/ヘッダーに対してデフォルトで発行されるリクエスト。</target>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">方針です。</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">1つ以上のリクエストヘッダーフィールドで与えられた前提条件は、サーバー上でテストされたときにfalseと評価された。この応答コードにより、クライアントは現在のリソースのメタ情報(ヘッダフィールドデータ)に前提条件を置くことができ、その結果、要求されたメソッドが意図されたもの以外のリソースに適用されることを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">コンテンツをデバイスフォームファクターにターゲティングする好ましい方法は、CSSメディアクエリを使用することです。ただし、UAスニッフィングを使用してコンテンツをデバイスのフォームファクターにターゲティングする場合は、電話のフォームファクターに&lt;strong&gt;Mobi&lt;/strong&gt;（「Mobi」を使用するOpera Mobileを含める）を探し、「Android」とデバイス間の相関関係&lt;strong&gt;は&lt;/strong&gt;想定し&lt;strong&gt;ない&lt;/strong&gt;でください。フォームファクタ。このようにして、Firefoxが他の電話/タブレットのオペレーティングシステムに同梱されている場合、またはラップトップにAndroidが使用されている場合に、コードが機能します。また、タブレットではないタッチデバイスが存在する場合があるため、「Mobi」や「Tablet」ではなく、タッチ検出を使用してタッチデバイスを検索してください。</target>
        </trans-unit>
        <trans-unit id="3f39eef261f64576ec5b25a729b1ec139f8018df" translate="yes" xml:space="preserve">
          <source>The preflight request below tells the server that we want to send a CORS &lt;code&gt;GET&lt;/code&gt; request that has the headers listed in &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;x-requested-with&lt;/code&gt;).</source>
          <target state="translated">以下のプリフライトリクエストは、私たちがCORSを送信することをサーバー伝え &lt;code&gt;GET&lt;/code&gt; に記載されているヘッダがある要求&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; の&lt;/a&gt;と &lt;code&gt;x-requested-with&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">搭乗前のリクエストでは、通常発生する可能性のあるネットワークエラーが発生していました。</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">前の例は、propfind要素に一緒に出現することが明示的に禁止された2つの要素を含んでいたため、違法でした。ただし、XMLは拡張可能な言語なので、propfindで使用するために定義されている新しい要素を想像できます。以下はPROPFINDのリクエスト本文であり、前の例と同様に、expired-props要素を理解しないサーバーによって400（Bad Request）で拒否される必要があります。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt;E：expired-props /&amp;gt; &amp;lt;/ D：propfind&amp;gt; 400（Bad Request）が返される理由を理解するために、expired-propsに慣れていないサーバーがそれを認識しているリクエスト本文を見てみましょう。 &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt; / D：propfind&amp;gt;サーバーは 'expired-props'要素を理解しないため、で指定されたWebDAV固有のXML処理ルールに従って &lt;a href=&quot;#section-17&quot;&gt;セクション17&lt;/a&gt;、要素が存在しないかのようにリクエストを処理する必要があります。したがって、サーバーは空のpropfindを参照します。これは、propfind要素の定義により不正です。拡張機能が追加された場合、必ずしも400（Bad Request）になるとは限らないことに注意してください。たとえば、PROPFINDの次のリクエスト本文を想像してください：&amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot; xmlns：E = &quot;http：// www.example.com/standards/props / &quot;&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;E：leave-out&amp;gt; * boss * &amp;lt;/ E：leave-out&amp;gt; &amp;lt;/ D：propfind&amp;gt;前の例には、架空の要素leaveが含まれています-でる。その目的は、送信されたパターンに名前が一致するプロパティが返されないようにすることです。前の例が「leave-out」に慣れていないサーバーに送信された場合、唯一の結果は「leave-out」要素が無視され、propnameが実行されることです。</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">このリビジョンでの主な変更は、本質的に編集的なものです。メッセージング構文を抽出し、HTTPセマンティクスをコア機能、条件付きリクエスト、部分的リクエスト、キャッシング、および認証用の個別のドキュメントに分割します。要件を明確に対象とするように適合性言語が改訂され、表現とペイロード、およびリソースと表現を区別するために用語が改善されました。これは相互運用性の障害の一般的な原因であるため、URIに埋め込まれたセマンティクスがリクエストメソッドと一致しない場合は無効にするという新しい要件が追加されました。 （&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）ペイロードが特定の識別子に関連付けられているかどうかを判断するアルゴリズムが追加されました。 （&lt;a href=&quot;#section-3.1.4.1&quot;&gt;セクション3.1.4.1&lt;/a&gt;）テキストメディアタイプ用のISO-8859-1のデフォルトの文字セットは削除されました。デフォルトは、メディアタイプの定義にあるとおりです。同様に、ISO-8859-1の特別な扱いがAccept-Charsetヘッダーフィールドから削除されました。 （&lt;a href=&quot;#section-3.1.1.3&quot;&gt;セクション3.1.1.3&lt;/a&gt;および&lt;a href=&quot;#section-5.3.3&quot;&gt;セクション5.3.3&lt;/a&gt;）Content-Locationの定義が変更され、相対的なURI参照を解決するためのベースURIに影響を与えなくなりました。これは、実装のサポートが不十分であり、コンテンツ内の相対リンクが壊れる可能性があるという望ましくない影響があるためです。交渉された資源。 （&lt;a href=&quot;#section-3.1.4.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;3.1.4.2）&lt;/a&gt; [ RFC7230のメソッド中立構文解析アルゴリズムと整合する]、GETの定義は緩和されているため、本文にGETの意味がない場合でも、リクエストに本文を含めることができます。 （&lt;a href=&quot;#section-4.3.1&quot;&gt;セクション4.3.1&lt;/a&gt;）サーバーはすべてのContent- *ヘッダーフィールドを処理する必要がなくなり、Content-Rangeの使用はPUTリクエストで明示的に禁止されました。 （&lt;a href=&quot;#section-4.3.4&quot;&gt;セクション4.3.4&lt;/a&gt;）CONNECTメソッドの定義は[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]からこの仕様に移動されました。 （&lt;a href=&quot;#section-4.3.6&quot;&gt;セクション4.3.6&lt;/a&gt;）OPTIONSおよびTRACEリクエストメソッドは安全であると定義されています。 （&lt;a href=&quot;#section-4.3.7&quot;&gt;セクション4.3.7&lt;/a&gt;および&lt;a href=&quot;#section-4.3.8&quot;&gt;セクション4.3.8&lt;/a&gt;）Expectヘッダーフィールドの拡張メカニズムは、広く展開されている壊れた実装のために削除されました。 （&lt;a href=&quot;#section-5.1.1&quot;&gt;セクション5.1.1&lt;/a&gt;）Max-Forwardsヘッダーフィールドは、OPTIONSおよびTRACEメソッドに制限されています。以前は、拡張メソッドもそれを使用できました。 （&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション5.1.2&lt;/a&gt;）「about：blank」URIは、参照URIが適用されない場合のRefererヘッダーフィールドの値として提案されており、Refererフィールドが送信されていないか削除されている他の場合と区別されます。 （&lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt;）次のステータスコードがキャッシュ可能になりました（つまり、明示的な鮮度情報がなくても、キャッシュに保存して再利用できます）：204、404、405、414、501。（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）201（ Created）複数のリソースが作成された可能性を考慮して、ステータスの説明が変更されました。 （&lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt;）203（非信頼情報）の定義は、ペイロード変換のケースも含むように拡張されました。 （&lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt;）自動的にリダイレクトしても安全なリクエストメソッドのセットは閉じられなくなりました。ユーザーエージェントは、リクエストメソッドのセマンティクスに基づいてその決定を行うことができます。リダイレクトステータスコード301、302、および307には、応答ペイロードとユーザーインタラクションに関する規範的な要件がなくなりました。 （&lt;a href=&quot;#section-6.4&quot;&gt;6.4項&lt;/a&gt;）ステータスコード301および302が変更され、ユーザーエージェントがメソッドをPOSTからGETに書き換えることができるようになりました。 （セクション&lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;および&lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;）303（その他を参照）ステータスコードの説明が変更され、明示的な鮮度情報が指定された場合にキャッシュできるようになり、GETへの303応答に特定の定義が追加されました。 （&lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt;）305（プロキシの使用）ステータスコードは、プロキシのインバンド構成に関するセキュリティ上の懸念により廃止されました。 （&lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5項&lt;/a&gt;）400（Bad Request）ステータスコードが緩和され、構文エラーに限定されなくなりました。 （&lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt;）426（アップグレードが必要）ステータスコードが[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] から組み込まれました。 （&lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt;）HTTP-dateおよびDateヘッダーフィールドの要件のターゲットは、日付を送信するすべてのシステムではなく、日付を生成するシステムに削減されました。 （&lt;a href=&quot;#section-7.1.1&quot;&gt;セクション7.1.1&lt;/a&gt;）Locationヘッダーフィールドの構文が変更され、相対参照やフラグメントを含むすべてのURI参照が許可されるようになり、フラグメントの使用が適切でない場合の明確化も行われました。 （&lt;a href=&quot;#section-7.1.2&quot;&gt;セクション7.1.2&lt;/a&gt;）Allowが応答ヘッダーフィールドとして再分類され、PUTリクエストでそれを指定するオプションが削除されました。許可の内容に関する要件が緩和されました。これに対応して、クライアントは常にその値を信頼する必要はありません。 （&lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt;）メソッドレジストリが定義されました。 （&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;）ステータスコードレジストリはこの仕様で再定義されました。以前は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]のセクション7.1で&lt;/a&gt;定義されていました。（&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;）コンテンツコーディングの登録が変更され、IETFレビューが必要になりました。（&lt;a href=&quot;#section-8.4&quot;&gt;8.4節&lt;/a&gt;）Content-Dispositionヘッダーフィールドは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ]で定義されているため、削除された。Content-MD5ヘッダーフィールドは、部分的な応答に関して一貫して実装されていなかったため、削除されました。</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">HTTPヘッダーと &lt;code&gt;allow&lt;/code&gt; 属性の主な違いは、許可属性はiframe内の機能のみを制御することです。ヘッダーは、応答の機能とページ内の埋め込みコンテンツを制御します。</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">エンティティタグの背後にある原理は、適切なキャッシュ検証メカニズムを選択するのに十分なリソースのセマンティクスを知っているのはサービス作者だけであり、byte-equality よりも複雑なバリデータ比較関数の仕様はワームの道を開くことになります。したがって、他のヘッダの比較 (HTTP/1.0 との互換性のための Last-Modified を除く)はキャッシュエントリを検証する目的では決して使用されません。</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">エンティティタグの背後にある原則は、リソースの実装を知っているのはサービス作成者だけであり、そのリソースに対して最も正確で効率的な検証メカニズムを選択できること、そしてそのようなメカニズムは単純なオクテットのシーケンスにマッピングして簡単に比較できることです。 。値は不透明であるため、クライアントが各エンティティタグの構成方法を認識する必要はありません。たとえば、すべての変更に適用された実装固有のバージョニングを持つリソースは、おそらく内部ネゴシエーション番号を使用し、コンテンツネゴシエーションの差異識別子と組み合わせて、表現を正確に区別することができます。他の実装では、表現コンテンツの衝突に強いハッシュ、さまざまなファイル属性の組み合わせ、または、1秒未満の解像度を持つ変更タイムスタンプ。エンティティタグは条件付きリクエストで使用され、キャッシュの新しさを評価するため、オリジンサーバーは変更の検出を合理的かつ一貫して決定できる任意の選択された表現のETagを送信する必要があります（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]）は、HTTPネットワークトラフィックの大幅な削減につながる可能性があり、サービスのスケーラビリティと信頼性を向上させる重要な要素となります。</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">原理は単純ですが、1つの潜在的な問題があります:ダウンロードしたリソースが両方のダウンロードの間に変更されている場合、得られた範囲はリソースの2つの異なるバージョンに対応し、最終的なドキュメントが破損してしまいます。</target>
        </trans-unit>
        <trans-unit id="f6827a30a4e8cddeb55d2c26c8c9c575effc09d9" translate="yes" xml:space="preserve">
          <source>The protocol defined in this document has two identifiers.

   o  The string &quot;h2&quot; identifies the protocol where HTTP/2 uses
      Transport Layer Security (TLS) [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;].  This identifier is used
      in the TLS application-layer protocol negotiation (ALPN) extension
      [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;] field and in any place where HTTP/2 over TLS is
      identified.

      The &quot;h2&quot; string is serialized into an ALPN protocol identifier as
      the two-octet sequence: 0x68, 0x32.

   o  The string &quot;h2c&quot; identifies the protocol where HTTP/2 is run over
      cleartext TCP.  This identifier is used in the HTTP/1.1 Upgrade
      header field and in any place where HTTP/2 over TCP is identified.

      The &quot;h2c&quot; string is reserved from the ALPN identifier space but
      describes a protocol that does not use TLS.

   Negotiating &quot;h2&quot; or &quot;h2c&quot; implies the use of the transport, security,
   framing, and message semantics described in this document.</source>
          <target state="translated">このドキュメントで定義されているプロトコルには、2つの識別子があります。o文字列「h2」は、HTTP / 2がトランスポート層セキュリティ（TLS）[ &lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt; ]を使用するプロトコルを識別します。この識別子は、TLSアプリケーション層プロトコルネゴシエーション（ALPN）拡張機能で使用されます[ &lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;]フィールド、およびHTTP / 2 overTLSが識別される場所。「h2」文字列は、2オクテットシーケンス（0x68、0x32）としてALPNプロトコル識別子にシリアル化されます。o文字列 &quot;h2c&quot;は、HTTP / 2がクリアテキストTCP上で実行されるプロトコルを識別します。この識別子は、HTTP / 1.1 Upgradeヘッダーフィールド、およびHTTP / 2 overTCPが識別されるすべての場所で使用されます。「h2c」文字列はALPN識別子スペースから予約されていますが、TLSを使用しないプロトコルを記述しています。「h2」または「h2c」のネゴシエーションは、このドキュメントで説明されているトランスポート、セキュリティ、フレーミング、およびメッセージセマンティクスの使用を意味します。</target>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">使用されるプロトコル。通常は HTTP プロトコルまたはそのセキュアバージョンである HTTPS です。</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">HTTP キャッシュの目的は、将来のリクエストに応答する際に使用するために、 リクエストに応答して受け取った情報を保存することです。多くの場合、キャッシュは単にレスポンスの適切な部分を要求元に返します。しかし、キャッシュが以前のレスポンスに基づいてキャッシュエントリを保持している場合、キャッシュエントリに保持されているものと新しいレスポンスの一部を組み合わせなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">100（続行）ステータス（&lt;a href=&quot;#section-10.1.1&quot;&gt;セクション10.1.1を&lt;/a&gt;参照）の目的は、要求本文を含む要求メッセージを送信しているクライアントが、元のサーバーが要求を受け入れる用意があるかどうかを判断できるようにすることです（要求ヘッダーに基づく）。クライアントがリクエスト本文を送信する前。場合によっては、サーバーが本文を見ずにメッセージを拒否する場合、クライアントが本文を送信することが不適切または非効率的である可能性があります。 HTTP / 1.1クライアントの要件：-クライアントが100（Continue）応答を待ってからリクエストボディを送信する場合、「100-continue」の期待値を持つExpectリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt;）を送信する必要があります。 -クライアントはExpectリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.20&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;）リクエストボディを送信するつもりがない場合は、「100-continue」の期待。古い実装が存在するため、このプロトコルでは、クライアントが417（期待失敗）ステータスまたは100（続行）ステータスを受信せずに「期待：100-続行」を送信するあいまいな状況が許可されます。したがって、クライアントがこのヘッダーフィールドを（おそらくプロキシ経由で）オリジンサーバーに送信すると、100（Continue）ステータスを一度も確認したことがない場合、クライアントはリクエスト本文を送信する前に無期限に待機してはなりません（SHOULD NOT）。 HTTP / 1.1オリジンサーバーの要件：-「100-継続」の期待値を持つExpect要求ヘッダーフィールドを含む要求を受信すると、オリジンサーバーは100（Continue）ステータスで応答して入力ストリームからの読み取りを続けるか、または最終ステータスコードで応答する必要があります。オリジンサーバーは、100（Continue）応答を送信する前にリクエストボディを待機してはなりません（MUST NOT）。最終ステータスコードで応答する場合は、トランスポート接続を閉じるか、残りのリクエストを読み取って破棄してもよい（MAY）。最終ステータスコードを返す場合は、要求されたメソッドを実行してはなりません。 -リクエストメッセージに「100-continue」の期待値を持つExpectリクエストヘッダーフィールドが含まれていない場合、オリジンサーバーは100（Continue）レスポンスを送信すべきではなく、そのようなリクエストが来た場合は100（Continue）レスポンスを送信してはならない（MUST NOT） HTTP / 1.0（またはそれ以前）のクライアントから。このルールには例外があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;、サーバーは、HTTP / 1.1 PUTまたはPOSTリクエストへの応答として100（Continue）ステータスを送信することができます。このリクエストには、「100- continue」の期待を持つExpectリクエストヘッダーフィールドが含まれていません。この例外は、100（続行）ステータスの宣言されていない待機に関連するクライアント処理遅延を最小限に抑えることを目的としており、HTTP / 1.1リクエストにのみ適用され、他のHTTPバージョン値を持つリクエストには適用されません。 -オリジンサーバーは、対応するリクエストのリクエストボディの一部またはすべてをすでに受信している場合、100（Continue）レスポンスを省略してもよい（MAY）。 -100（Continue）応答を送信するオリジンサーバーは、リクエストボディが受信されて処理されると、最終的に最終ステータスコードを送信する必要があります。トランスポート接続が途中で終了しない限り。 -「100-continue」の期待値を持つExpectリクエストヘッダーフィールドを含まないリクエストをオリジンサーバーが受け取った場合、リクエストにはリクエストボディが含まれ、サーバーはリクエストボディ全体を読み取る前に最終ステータスコードで応答します。トランスポート接続の場合、サーバーは、リクエスト全体を読み取るまで、またはクライアントが接続を閉じるまで、トランスポート接続を閉じないでください。そうしないと、クライアントが応答メッセージを確実に受信できない可能性があります。ただし、この要件は、サーバーがサービス拒否攻撃からサーバーを防御したり、ひどく壊れたクライアント実装からサーバーを防御したりすることを妨げるものではありません。HTTP / 1.1プロキシの要件：-プロキシがExpectリクエストヘッダーフィールドに「100-continue」の期待値を含むリクエストを受信し、プロキシがネクストホップサーバーがHTTP / 1.1以上に準拠していることを知っている場合、またはネクストホップサーバーのHTTPバージョンがわからない場合は、Expectヘッダーフィールドを含め、リクエストを転送する必要があります。 -ネクストホップサーバーのバージョンがHTTP / 1.0以下であることをプロキシが認識している場合、プロキシはリクエストを転送してはならず（MUST）、417（期待失敗）ステータスで応答する必要があります。 -プロキシは、最近参照されたネクストホップサーバーから受信したHTTPバージョン番号を記録するキャッシュを維持する必要があります（SHOULD）。-リクエストメッセージがHTTP / 1.0（またはそれ以前）のクライアントから受信され、「100-continue」の期待値を持つExpectリクエストヘッダーフィールドが含まれていない場合、プロキシは100（Continue）応答を転送してはなりません（MUST NOT）。この要件は、1xx応答の転送に関する一般的なルールを上書きします（参照&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">引用符で囲まれた文字列は、Base64でエンコードされた&lt;em&gt;サブジェクトの公開キー情報&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）のフィンガープリントです。異なる公開鍵に複数のピンを指定することが可能です。一部のブラウザでは、将来、SHA-256以外のハッシュアルゴリズムが許可される可能性があります。証明書またはキーファイルからこの情報を抽出する方法については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">引用符で囲まれた文字列は、Base64でエンコードされたサブジェクトの公開キー情報（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）のフィンガープリントです。異なる公開鍵に複数のピンを指定することが可能です。一部のブラウザでは、将来、SHA-256以外のハッシュアルゴリズムが許可される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e7090e603b1c8468593db08ace13cc460b311c3" translate="yes" xml:space="preserve">
          <source>The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number.</source>
          <target state="translated">オプションのホストオーバーライド、コロン、必須のポート番号で構成される代替権限を指定する引用符で囲まれた文字列。</target>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">リクエストの &lt;code&gt;Range&lt;/code&gt; ヘッダーフィールドで指定された範囲は満たされません。範囲がターゲットURIのデータのサイズ外である可能性があります。</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">推奨されているのは、データをできるだけ圧縮することであり、したがってこのフィールドを使用することですが、jpeg画像のようないくつかのタイプのリソースは、すでに圧縮されています。追加の圧縮を使用してもペイロードのサイズが小さくならず、ペイロードが長くなることもあります。</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">Geckoベースのブラウザーのスニッフィングの推奨方法（機能検出を使用する代わりにブラウザーエンジン&lt;em&gt;を&lt;/em&gt;スニッフィングする必要&lt;em&gt;がある&lt;/em&gt;場合）は、「 &lt;code&gt;Gecko&lt;/code&gt; 」および「 &lt;code&gt;rv:&lt;/code&gt; 」文字列の存在による &lt;code&gt;like Gecko&lt;/code&gt; &quot;トークン。</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">違反が発生した文書の参照元。</target>
        </trans-unit>
        <trans-unit id="060f5108fa86aba94bed9d14146f77e7e9a8271d" translate="yes" xml:space="preserve">
          <source>The referring resource is a local &quot;file&quot; or &quot;data&quot; URI.</source>
          <target state="translated">参照するリソースは、ローカルの &quot;ファイル &quot;または &quot;データ &quot;URIです。</target>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">レジストリには、以下の登録が含まれています。+ ----------- + --------------------------- ------- + --------------- + |警告コード|短い説明|リファレンス| + ----------- + ---------------------------------- +- ------------- + | 110 |応答が古くなっています| &lt;a href=&quot;#section-5.5.1&quot;&gt;セクション5.5.1&lt;/a&gt; | | 111 |再検証に失敗しました| &lt;a href=&quot;#section-5.5.2&quot;&gt;セクション5.5.2&lt;/a&gt; | | 112 |切断された操作| &lt;a href=&quot;#section-5.5.3&quot;&gt;セクション5.5.3&lt;/a&gt; | | 113 |ヒューリスティックな有効期限| &lt;a href=&quot;#section-5.5.4&quot;&gt;セクション5.5.4&lt;/a&gt; | | 199 |その他の警告| &lt;a href=&quot;#section-5.5.5&quot;&gt;セクション5.5.5&lt;/a&gt; | | 214 |適用された変換| &lt;a href=&quot;#section-5.5.6&quot;&gt;セクション5.5.6&lt;/a&gt;| | 299 |その他の永続的な警告| &lt;a href=&quot;#section-5.5.7&quot;&gt;セクション5.5.7&lt;/a&gt; | + ----------- + ---------------------------------- +- ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">レジストリには以下の登録が入力されています：+ ------------------------ + -------------- -------------------- + |キャッシュディレクティブ|リファレンス| + ------------------------ + ------------------------ ---------- + |最大年齢| &lt;a href=&quot;#section-5.2.1.1&quot;&gt;セクション5.2.1.1&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.8&quot;&gt;セクション5.2.2.8&lt;/a&gt; | | max-stale | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;セクション5.2.1.2&lt;/a&gt; | | min-fresh | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;セクション5.2.1.3&lt;/a&gt; | |再検証が必要| &lt;a href=&quot;#section-5.2.2.1&quot;&gt;セクション5.2.2.1&lt;/a&gt; | |キャッシュなし| &lt;a href=&quot;#section-5.2.1.4&quot;&gt;セクション5.2.1.4&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.2&quot;&gt;セクション5.2.2.2&lt;/a&gt; | |ノーストア| &lt;a href=&quot;#section-5.2.1.5&quot;&gt;セクション5.2.1.5&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.3&quot;&gt;セクション5.2.2.3&lt;/a&gt; | | 変換しない| &lt;a href=&quot;#section-5.2.1.6&quot;&gt;セクション5.2.1.6&lt;/a&gt;、&lt;a href=&quot;#section-5.2.2.4&quot;&gt;セクション5.2.2.4&lt;/a&gt; | | only-if-cached | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;セクション5.2.1.7&lt;/a&gt; | | プライベート| &lt;a href=&quot;#section-5.2.2.6&quot;&gt;セクション5.2.2.6&lt;/a&gt; | | プロキシ再検証| &lt;a href=&quot;#section-5.2.2.7&quot;&gt;セクション5.2.2.7&lt;/a&gt; | | 公開| &lt;a href=&quot;#section-5.2.2.5&quot;&gt;セクション5.2.2.5&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;セクション5.2.2.9&lt;/a&gt; | | 古くなったエラー| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861]、セクション4&lt;/a&gt; | | 古くなった再検証| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861]、セクション3&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgradeヘッダーフィールドに&lt;/a&gt;関連するRFCドキュメントはRFC 7230のセクション6.7です。標準は、現在のクライアント、サーバー、トランスポートプロトコル接続で別のプロトコルにアップグレードまたは変更するためのルールを確立します。たとえば、サーバーがUpgradeヘッダーフィールドを確認して実装することを決定した場合、このヘッダー標準により、クライアントはHTTP 1.1からHTTP 2.0に変更できます。どちらの当事者も、Upgradeヘッダーフィールドで指定された条件に同意する必要はありません。クライアントとサーバーの両方のヘッダーで使用できます。 Upgradeヘッダーフィールドが指定されている場合、送信者はアップグレードオプションを指定してConnectionヘッダーフィールドも送信する必要があります。接続ヘッダーフィールドの&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;詳細については、前述のRFCのセクション6.1を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">残りの応答ヘッダーフィールドは、後のリクエストで潜在的に使用するためのターゲットリソースに関する詳細情報を提供します。 + ------------------- + -------------------------- + |ヘッダーフィールド名|で定義されています... | + ------------------- + -------------------------- + | Accept-Ranges | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;[RFC7233]のセクション2.3&lt;/a&gt; | |許可| &lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt; | |サーバー| &lt;a href=&quot;#section-7.4.2&quot;&gt;セクション7.4.2&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">レポートJSONオブジェクトには、以下のデータが含まれています。</target>
        </trans-unit>
        <trans-unit id="3cf9e42ccc33aee82c7b770f8203f6eabbfa160c" translate="yes" xml:space="preserve">
          <source>The reporting group referenced above is defined in the usual manner within the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Report-To&quot;&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/a&gt; header, for example:</source>
          <target state="translated">上記で参照されているレポートグループは、通常の方法で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Report-To&quot;&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/a&gt;ヘッダー内で定義されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">HTTPメッセージに関連付けられた表現データは、メッセージのペイロードボディとして提供されるか、メッセージセマンティクスと有効なリクエストURIによって参照される。表現データは、表現メタデータヘッダフィールドによって定義されるフォーマットとエンコーディングである。表現データのデータ型は、ヘッダーフィールドContent-TypeとContent-Encodingで決まる。これらは2層の順序付きエンコーディングモデルを定義する。 representation-data :=Content-Encoding(Content-Type(bits))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">リソースの現在の状態との競合のためにリクエストを完了できませんでした。このコードは、ユーザーがコンフリクトを解決してリクエストを再送できるかもしれない と期待される状況でのみ許可される。応答ボディは、ユーザーが競合の原因を認識するのに十分な情報を含むべきである [SHOULD]。理想的には、応答ボディは、ユーザーまたはユーザーエージェントが 問題を解決するために十分な情報を含むべきである。コンフリクトはPUTリクエストに対する応答で最も起こりやすい。例えば、バージョニングが使用されていて、PUTされるエンティティが以前の(サードパーティの)リクエストで行われたものと競合するリソースへの変更を含んでいた場合、サーバーはリクエストを完了できないことを示すために409応答を使用するかもしれない。この場合、応答の実体は、応答のContent-Typeで定義された形式で、 2つのバージョン間の相違点のリストを含む可能性が高い。</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">リクエストは構文が正しくないためにサーバーに理解されなかった。クライアントは修正せずにリクエストを繰り返すべきではない[SHOULD NOT]。</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">前回のリクエストが失敗したため、リクエストに失敗しました。</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">リクエストは処理のために受理されたが、処理は完了していない。実際に処理が行われたときには拒否されるかもしれないので、そのリクエストは最終的に処理されるかもしれないし、そうでないかもしれない。このような非同期操作からステータスコードを再送する機能はない。202応答は意図的に非committalである。その目的は、プロセスが完了するまでサーバーへのユーザーエージェントの 接続が持続することを要求せずに、サーバーが他のプロセス(おそらく1日に1回しか実行され ないバッチ指向のプロセス)へのリクエストを受け付けることを可能にすることである。この応答で返される実体は、リクエストの現在のステータスの表示と、 ステータスモニターへのポインタ、またはユーザーがいつリクエストが 満たされると予想できるかの推定値を含むべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">リクエストが満たされ、新しいリソースが作成されました。新しく作成されたリソースは、応答のエンティティで返されるURIで参照できます。リソースの最も具体的なURIは、Locationヘッダーフィールドで指定されます。応答には、ユーザーまたはユーザーエージェントが最も適切なものを選択できるリソースの特性と場所のリストを含むエンティティが含まれる必要があります（SHOULD）。エンティティ形式は、Content-Typeヘッダーフィールドで指定されたメディアタイプによって指定されます。オリジンサーバーは、201ステータスコードを返す前にリソースを作成する必要があります。アクションをすぐに実行できない場合、サーバーは代わりに202（Accepted）応答で応答する必要があります（SHOULD）。201応答には、作成されたばかりの要求されたバリアントのエンティティタグの現在の値を示すETag応答ヘッダーフィールドが含まれる場合があります。&lt;a href=&quot;#section-14.19&quot;&gt;セクション14.19&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">リクエストは受信されたが、まだ処理されていない。これは非コミッタルであり、リクエストの処理結果を示す非同期応答を後から HTTP で送る方法がないことを意味します。これは、別のプロセスやサーバがリクエストを処理する場合や、 バッチ処理の場合に意図されています。</target>
        </trans-unit>
        <trans-unit id="585082aac4586ccf5aebfeb0d6987e1358cca064" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is noncommittal, since there is no way in HTTP to later send an asynchronous response indicating the outcome of the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">リクエストは受信されたが、まだ処理されていない。HTTPではリクエストの結果を示す非同期応答を後で送る方法がないので、これは非コミッタルです。これは、別のプロセスやサーバがリクエストを処理する場合や、 バッチ処理の場合を想定しています。</target>
        </trans-unit>
        <trans-unit id="7b875d4acb8b65c4bd9ffe04a6f98e27644fbcab" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. (There is no standardized way of choosing one of the responses, but HTML links to the possibilities are recommended so the user can pick.)</source>
          <target state="translated">リクエストは複数の可能な応答を持っています。ユーザーエージェントかユーザーはそのうちの一つを選択しなければなりません。(レスポンスの一つを選ぶ標準的な方法はありませんが、ユーザーが選べるように可能性のあるものへのHTMLリンクが推奨されています)。</target>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">リクエストは複数の可能な応答を持っています。ユーザーエージェントかユーザーはそれらのうちの一つを選択しなければなりません。応答のうちの一つを選択する標準化された方法はありません。</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">リクエストが成功し、その結果として新しいリソースが作成されました。これは通常、POST リクエストの後やいくつかのPUT リクエストの後に送られるレスポンスです。</target>
        </trans-unit>
        <trans-unit id="135d9441de12a3afffc64aee3e0646575c72a5dc" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result. This is typically the response sent after &lt;code&gt;POST&lt;/code&gt; requests, or some &lt;code&gt;PUT&lt;/code&gt; requests.</source>
          <target state="translated">リクエストは成功し、その結果、新しいリソースが作成されました。これは通常、 &lt;code&gt;POST&lt;/code&gt; 要求または一部の &lt;code&gt;PUT&lt;/code&gt; 要求の後に送信される応答です。</target>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">リクエストは成功しました。レスポンスで返される情報は、例えば、リクエストで使用された方法に依存します。GETはリクエストされたリソースに対応するエンティティをレスポンスで送信します。 HEADはリクエストされたリソースに対応するエンティティヘッダフィールドをメッセージボディなしでレスポンスで送信します。POSTはアクションの結果を記述した、またはそれを含むエンティティを送信します。</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">リクエストは成功しました。成功の意味はHTTPメソッドによって異なります。</target>
        </trans-unit>
        <trans-unit id="9bd73430623220d33656725bff084d01a5160eeb" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of the success depends on the HTTP method:</source>
          <target state="translated">リクエストは成功しました。成功の意味はHTTPメソッドに依存します。</target>
        </trans-unit>
        <trans-unit id="03ea2a026f2515cb348f3705c18e0640e28ad870" translate="yes" xml:space="preserve">
          <source>The request header of note is &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, which shows that the invocation is coming from &lt;code&gt;https://foo.example&lt;/code&gt;.</source>
          <target state="translated">注意のリクエストヘッダーは&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; です&lt;/a&gt;。これは、呼び出しが &lt;code&gt;https://foo.example&lt;/code&gt; からのものであることを示しています。</target>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">リクエストは以下のようになります(あまり興味のないヘッダはここでは省略します)。</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">リクエストメソッドと本文は変更されませんが、&lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;は誤って&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッドに変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">要求メソッドはサーバーによって認識されていますが、無効になっているため使用できません。たとえば、APIはリソースの削除を禁止する場合があります。2つの必須メソッド、 &lt;code&gt;GET&lt;/code&gt; と &lt;code&gt;HEAD&lt;/code&gt; 無効にしてはならず、このエラーコードを返さないでください。</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">リクエストメソッドはサーバーでサポートされていないため、処理できません。サーバーがサポートする必要がある（したがって、このコードを返してはならない）唯一のメソッドは、 &lt;code&gt;GET&lt;/code&gt; および &lt;code&gt;HEAD&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">リクエストメソッドトークンは、リクエストセマンティクスの主要なソースです。これは、クライアントがこの要求を行った目的と、成功した結果としてクライアントが期待することを示しています。リクエストメソッドのセマンティクスは、リクエストに存在する場合、一部のヘッダーフィールドのセマンティクスによってさらに特殊化される場合があります（&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt;。ターゲットリソースによって許可されるメソッドのセットは、許可ヘッダーフィールドにリストできます（&lt;a href=&quot;#section-7.4.1&quot;&gt;セクション7.4.1&lt;/a&gt;&lt;a href=&quot;#section-5&quot;&gt;&lt;/a&gt;追加のセマンティクスがメソッドと競合しない場合場合セクション5）。たとえば、クライアントは条件付き要求ヘッダーフィールド（&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;）を送信して、要求されたアクションをターゲットリソースの現在の状態を条件とすることができます（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]）。 method = token HTTPは当初、分散オブジェクトシステムへのインターフェースとして使用できるように設計されました。リクエストメソッドは、識別されたオブジェクトで定義されたメソッドを呼び出すと、セマンティクスが適用されるのとほぼ同じ方法で、ターゲットリソースにセマンティクスを適用するものと想定されていました。メソッドトークンは、大文字と小文字を区別するメソッド名を持つオブジェクトベースのシステムへのゲートウェイとして使用される可能性があるため、大文字と小文字を区別します。分散オブジェクトとは異なり、HTTPの標準化されたリクエストメソッドはリソース固有ではありません。統一されたインターフェースにより、ネットワークベースのシステムでの可視性と再利用性が向上するためです[ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]。いったん定義されると、標準化されたメソッドは、リソースに適用されるときに同じセマンティクスを持つ必要がありますが、各リソースは、それらのセマンティクスが実装または許可されるかどうかを自分自身で決定します。この仕様では、次の表に概要を示すように、HTTPで一般的に使用される標準化されたメソッドをいくつか定義しています。慣例により、標準化されたメソッドはすべて大文字のUS-ASCII文字で定義されます。 + --------- + --------------------------------------- ---------- + ------- + |メソッド|説明| Sec。 | + --------- + --------------------------------------- ---------- + ------- + | GET |ターゲットの現在の表現を転送する| 4.3.1 | | |資源。 | | |ヘッド| GETと同じステータスラインのみを転送する| 4.3.2 | | |およびヘッダーセクション。 | | |投稿| |でリソース固有の処理を実行します4.3.3 | | |ペイロードをリクエストします。 | | | PUT | |の現在の表現をすべて置き換えます4.3.4 | | |リクエストペイロードを持つターゲットリソース。 | | |削除| |の現在の表現をすべて削除します4.3.5 | | |ターゲットリソース。 | | |接続| |で識別されるサーバーへのトンネルを確立します。 4.3.6 | | |ターゲットリソース。 | | |オプション| |の通信オプションについて説明してください4.3.7 | | |ターゲットリソース。| | | TRACE |パスに沿ってメッセージループバックテストを実行する| 4.3.8 | | |ターゲットリソースに。 | | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。| | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。| | + --------- + --------------------------------------- ---------- + ------- +すべての汎用サーバーは、GETおよびHEADメソッドをサポートする必要があります。他のすべての方法はオプションです。この仕様の範囲外の追加のメソッドは、HTTPで使用するために標準化されています。このようなメソッドはすべて、IANAによって維持されている「ハイパーテキスト転送プロトコル（HTTP）メソッドレジストリ」内に登録されている必要があります。）。ただし、許可されたメソッドのセットは動的に変更できます。認識されていないか、配信元サーバーで実装されていないリクエストメソッドを受信すると、配信元サーバーは501（未実装）ステータスコードで応答する必要があります（SHOULD）。オリジンサーバーによって認識されているがターゲットリソースに対して許可されていないリクエストメソッドが受信されると、オリジンサーバーは405（Method Not Allowed）ステータスコードで応答する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">リクエストにはユーザー認証が必要です。応答には、要求されたリソースに適用可能なチャレンジを含むWWW-Authenticateヘッダーフィールド（&lt;a href=&quot;#section-14.47&quot;&gt;セクション14.47&lt;/a&gt;）を含める必要があります。クライアントは適切なAuthorizationヘッダーフィールド（&lt;a href=&quot;#section-14.8&quot;&gt;セクション14.8&lt;/a&gt;）。要求にすでに認証資格情報が含まれている場合、401応答は、それらの資格情報の認証が拒否されたことを示します。 401応答に前の応答と同じチャレンジが含まれていて、ユーザーエージェントが少なくとも1回は認証を試みている場合、エンティティには関連する診断情報が含まれている可能性があるため、ユーザーには応答で指定されたエンティティを提示する必要があります（SHOULD）。 HTTPアクセス認証については、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で説明しています。</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">TLS へのリクエストは、オプションまたは強制的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="c08d03b683f62c643ba894d3c2dd507993993fdd" translate="yes" xml:space="preserve">
          <source>The request was aborted due to a detected redirect loop</source>
          <target state="translated">リダイレクトループが検出されたため、リクエストは中断されました。</target>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">リクエストは応答を生成できないサーバーに向けられた。これは、リクエストURIに含まれるスキームと権限の組み合わせに対する 応答を生成するように構成されていないサーバーによって送られる可能性がある。</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">リクエストは 'https://example.com/foo' にリダイレクトされましたが、プリフライトを必要とするクロスオリジンリクエストでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">リクエストはよくできていたが、セマンティックエラーのためにそれに従うことができなかった。</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">リクエストヘッダーフィールドを使用すると、クライアントはリクエストとクライアント自体に関する追加情報をサーバーに渡すことができます。これらのフィールドは要求修飾子として機能し、セマンティクスはプログラミング言語のメソッド呼び出しのパラメーターと同等です。 request-header = Accept; &lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt; | Accept-Charset; &lt;a href=&quot;#section-14.2&quot;&gt;セクション14.2&lt;/a&gt; | Accept-Encoding; &lt;a href=&quot;#section-14.3&quot;&gt;セクション14.3&lt;/a&gt; | Accept-Language; &lt;a href=&quot;#section-14.4&quot;&gt;セクション14.4&lt;/a&gt; |認可; &lt;a href=&quot;#section-14.8&quot;&gt;セクション14.8&lt;/a&gt; |期待する; &lt;a href=&quot;#section-14.20&quot;&gt;セクション14.20&lt;/a&gt; |から; &lt;a href=&quot;#section-14.22&quot;&gt;セクション14.22&lt;/a&gt; |ホスト ; &lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt; | If-Match; &lt;a href=&quot;#section-14.24&quot;&gt;セクション14.24&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;セクション14.25&lt;/a&gt; | If-None-Match; &lt;a href=&quot;#section-14.26&quot;&gt;セクション14.26&lt;/a&gt; | If-Range; &lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt; | If-Unmodified-Since; &lt;a href=&quot;#section-14.28&quot;&gt;セクション14.28&lt;/a&gt; | Max-Forwards; &lt;a href=&quot;#section-14.31&quot;&gt;セクション14.31&lt;/a&gt; |プロキシ承認; &lt;a href=&quot;#section-14.34&quot;&gt;セクション14.34&lt;/a&gt; |範囲 ; &lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt; |リファラー; &lt;a href=&quot;#section-14.36&quot;&gt;セクション14.36&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;セクション14.39&lt;/a&gt; |ユーザーエージェント ; &lt;a href=&quot;#section-14.43&quot;&gt;セクション14.43&lt;/a&gt; リクエストヘッダーフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての関係者がリクエストヘッダーフィールドであると認識した場合、新しいヘッダーフィールドまたは実験的なヘッダーフィールドにリクエストヘッダーフィールドのセマンティクスを与えることができます。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">要求されたリソースは、Locationフィールドで指定されたプロキシを介してアクセスする必要があります。LocationフィールドはプロキシのURIを示します。受信者は、プロキシ経由でこの単一のリクエストを繰り返すことが期待されています。305応答は、オリジンサーバーによってのみ生成される必要があります。注：&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;は、305が単一の要求をリダイレクトすること、およびオリジンサーバーによってのみ生成されることを目的としていたことを明確にしていませんでした。これらの制限を守らないと、セキュリティに重大な影響があります。</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">要求されたリソースは、それぞれ固有の場所とエージェント主導のネゴシエーション情報（&lt;a href=&quot;#section-12&quot;&gt;セクション12&lt;/a&gt;）が提供されているため、ユーザー（またはユーザーエージェント）は優先表現を選択し、その要求をその場所にリダイレクトできます。 HEADリクエストでない限り、レスポンスには、ユーザーまたはユーザーエージェントが最も適切なものを選択できるリソースの特性と場所のリストを含むエンティティが含まれる必要があります（SHOULD）。エンティティの形式は、Content- Typeヘッダーフィールドで指定されたメディアタイプによって指定されます。ユーザーエージェントの形式と機能に応じて、最も適切な選択肢の選択が自動的に実行される場合があります。ただし、この仕様では、このような自動選択の標準を定義していません。サーバーが適切な表現の選択肢を持っている場合、その表現に固有のURIをLocationフィールドに含める必要があります（SHOULD）。ユーザーエージェントは、自動リダイレクトにLocationフィールドの値を使用できます。特に断らない限り、この応答はキャッシュ可能です。</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">リクエストされたリソースには新しいパーマネントURIが割り当てられ、このリソースへの将来の参照は、 返されたURIの1つを使用するべきである[SHOULD]。リンク編集機能を持つクライアントは、可能であれば、Request-URIへの参照をサーバから返された1つ以上の新しい参照に自動的に再リンクするべきである。この応答は、別段の指示がない限りキャッシュ可能である。新しいパーマネントURIは、応答のLocationフィールドで与えられるべきである [SHOULD]。リクエストメソッドがHEADでない限り、応答の実体は、新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。GETやHEAD以外のリクエストに対する応答で301ステータスコードを受け取った場合、ユーザーエージェ ントは、リクエストが発行された条件を変更するかもしれないので、 ユーザーが確認できない限り、そのリクエストを自動的にリダイレクトしては ならない[MUST NOT]。注意:301ステータスコードを受け取った後にPOSTリクエストを自動的にリダイレクトする場合、既存のHTTP/1.0ユーザエージェントの中には、それを誤ってGETリクエストに変更してしまうものがあります。</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">要求されたリソースはサーバで利用できなくなり、転送アドレスがわかりません。この状態は恒久的なものと考えられます。リンク編集機能を持つクライアントは、ユーザーの承認後にRequest-URIへの参照を削除すべきである [SHOULD]。サーバーがその状態が永続的かどうかを知らないか、または判断する機能を持たない 場合、ステータスコード404(Not Found)が代わりに使用されるべきである[SHOULD]。この応答は、別段の指示がない限りキャッシュ可能である。410 レスポンスは主に、受信者にリソースが意図的に利用できないことと、サーバの所有者がそのリソースへのリモートリンクを削除することを望むことを通知することで、ウェブメンテナンスのタスクを支援することを目的としています。このようなイベントは、期間限定のプロモーションサービスや、サーバのサイトではもはや働いていない個人が所有するリソースのために一般的です。永久に利用できないすべてのリソースを「消滅」としてマークする必要はありませんし、マークをいつまでも維持する必要もありません --それはサーバーの所有者の裁量に委ねられています。</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">リクエストされたリソースは一時的に異なるURIの下に存在する。リダイレクトは時々変更してもよい[MAY]ので、クライアントは今後のリクエ ストにRequest-URIを使い続けるべきである[SHOULD]。この応答は、Cache-ControlまたはExpiresヘッダーフィールドで示されている 場合にのみキャッシュ可能である。一時的なURIは応答中のLocationフィールドによって与えられるべきである [SHOULD]。リクエストメソッドがHEADでない限り、応答のエンティティは、多くのHTTP/1.1以前 のユーザーエージェントが307ステータスを理解していないため、新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。したがって、ノートは、ユーザーが新しいURIで元のリクエストを繰り返すために 必要な情報を含むべきである[SHOULD]。307ステータスコードがGETやHEAD以外のリクエストに応答して受け取られた場合、ユーザーエージェ ントは、リクエストが発行された条件を変更する可能性があるため、ユーザーに 確認できない限り、そのリクエストを自動的にリダイレクトしてはならない [MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">リクエストされたリソースは一時的に別のURIに存在します。リダイレクトは時々変更される可能性があるため、クライアントは今後のリクエストに引き続きRequest-URIを使用する必要があります。この応答は、Cache-ControlまたはExpiresヘッダーフィールドで示されている場合にのみキャッシュ可能です。一時URIは、応答のLocationフィールドで指定する必要があります（SHOULD）。リクエストメソッドがHEADでない限り、レスポンスのエンティティには、新しいURIへのハイパーリンクを含む短いハイパーテキストノートを含める必要があります（SHOULD）。 GETまたはHEAD以外のリクエストに応答して302ステータスコードを受信した場合、ユーザーエージェントは、ユーザーが確認できない限り、リクエストを自動的にリダイレクトしてはなりません。これにより、リクエストが発行された条件が変わる可能性があります。注：&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;は、クライアントがリダイレクトされた要求のメソッドを変更できないように指定しています。ただし、ほとんどの既存のユーザーエージェント実装は、302を303応答のように扱い、元のリクエストメソッドに関係なく、Locationフィールドの値に対してGETを実行します。ステータスコード303および307は、どのような反応がクライアントに期待されるかを明確にしたいサーバー用に追加されました。</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">クライアントとサーバーがホストヘッダーフィールドをサポートするという要件（&lt;a href=&quot;#section-5.4&quot;&gt;5.4節&lt;/a&gt;）、HTTP / 1.1リクエストから欠落している場合はエラーを報告、絶対URIを受け入れる（&lt;a href=&quot;#section-5.3&quot;&gt;5.3節）&lt;/a&gt;）は、HTTP / 1.1で定義されている最も重要な変更の1つです。古いHTTP / 1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。リクエストの対象となるサーバーを識別するための確立されたメカニズムは、そのリクエストの送信先のIPアドレス以外にありませんでした。ホストヘッダーフィールドはHTTP / 1.1の開発中に導入され、ほとんどのHTTP / 1.0ブラウザーによってすぐに実装されましたが、完全な採用を確実にするために、すべてのHTTP / 1.1要求に追加の要件が課されました。この記事の執筆時点では、ほとんどのHTTPベースのサービスは、ターゲットリクエストのHostヘッダーフィールドに依存しています。</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">クライアントとサーバーがホストリクエストヘッダーをサポートし、ホストリクエストヘッダー（&lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt;）がHTTP / 1.1リクエストにない場合はエラーを報告し、絶対URI（&lt;a href=&quot;#section-5.1.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;）を受け入れるという要件）は、この仕様で定義されている最も重要な変更の1つです。古いHTTP / 1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。リクエストの対象となるサーバーを識別するための確立されたメカニズムは、そのリクエストの送信先のIPアドレス以外にありませんでした。上記の変更により、古いHTTPクライアントが一般的でなくなると、インターネットは単一のIPアドレスから複数のWebサイトをサポートできるようになり、多数のIPアドレスを単一のホストに割り当てると深刻な問題が発生する大規模な運用Webサーバーが大幅に簡素化されます。 。また、インターネットは、ルートレベルのHTTP URLで特殊用途のドメイン名を使用できるようにするという唯一の目的で割り当てられたIPアドレスを回復することもできます。ウェブの成長率を考えると、すでにデプロイされているサーバーの数に応じて、HTTPのすべての実装（既存のHTTP / 1.0アプリケーションへの更新を含む）がこれらの要件を正しく実装することが非常に重要です。-クライアントとサーバーの両方がホスト要求ヘッダーをサポートする必要があります。 -HTTP / 1.1リクエストを送信するクライアントは、ホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。1つの要求でホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。1つの要求でホストヘッダーを送信する必要があります。 -HTTP / 1.1リクエストにHostリクエストヘッダーが含まれていない場合、サーバーは400（Bad Request）エラーを報告する必要があります。 -サーバーは絶対URIを受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">リクエストによって識別されたリソースは、リクエストで送られた acceptヘッダーに従って受け入れられないコンテンツ特性を持つ応答エンティティを生成することができるだけである。それがHEADリクエストでない限り、応答は、利用可能なエンティティ特性のリストと、ユーザーまたはユーザーエージェントが最も適切なものを選択できる場所(複数可)を含むエンティティを含むべきである[SHOULD]。エンティティの形式は、Content-Typeヘッダーフィールドで与えられたメ ディアタイプによって指定される。フォーマットとユーザーエージェントの能力に応じて、最も適切な選択の選択は自動的に実行されてもよい[MAY]。しかしながら、この仕様は、そのような自動選択のための標準を定義していない。注意:HTTP/1.1サーバは、リクエストで送られたACCEPTヘッダに従って受け入れられない応答を返すことが許されています。場合によっては、これは 406 応答を送るよりも望ましいかもしれません。ユーザエージェントは、受け入れ可能かどうかを判断するために、 受信したレスポンスのヘッダを検査することが推奨されます。応答が受け入れられない可能性がある場合、ユーザエージェントは、さらなるデータの受信を一時的に停止し、さらなるアクションの決定をユーザに問い合わせるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">アクセスされているリソースはロックされています。</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">サーバからの応答には、これらが含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="90c2bdf40568a1e2ecdbf3f858aafd5dbb66fd4d" translate="yes" xml:space="preserve">
          <source>The response header below will cause compatible user agents to disallow cross-origin no-cors requests:</source>
          <target state="translated">以下の応答ヘッダーは、互換性のあるユーザーエージェントがクロスオリジンのno-corsリクエストを許可しないようにします。</target>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">レスポンスヘッダーフィールドは、サーバがステータス行に置かれている以上の レスポンスに関する追加情報を渡すことを可能にします。これらのヘッダフィールドは、サーバについての情報、ターゲットリソースへのさらなるアクセス、または関連するリソースについての情報を与える。各レスポンスヘッダフィールドは定義された意味を持つが、一般的には、正確なセマンティクスはリクエストメソッドやレスポンスステータスコードのセマンティクスによってさらに洗練されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">レスポンスも非常にシンプルで、ファイル自体からしか構成されていませんでした。</target>
        </trans-unit>
        <trans-unit id="a187e434f07fa362732384aa76405b41edb39ff9" translate="yes" xml:space="preserve">
          <source>The response may &lt;strong&gt;not&lt;/strong&gt; be stored in &lt;em&gt;any&lt;/em&gt; cache. Note that this will not prevent a valid &lt;em&gt;pre-existing&lt;/em&gt; cached response being returned. Clients can set &lt;code&gt;max-age=0&lt;/code&gt; to also clear existing cache responses, as this forces the cache to revalidate with the server (no other directives have an effect when used with &lt;code&gt;no-store&lt;/code&gt;).</source>
          <target state="translated">応答は&lt;em&gt;どの&lt;/em&gt;キャッシュにも保存でき&lt;strong&gt;ません&lt;/strong&gt;。これは、有効な&lt;em&gt;既存の&lt;/em&gt;キャッシュされた応答が返されるのを妨げるものではないことに注意してください。クライアントは &lt;code&gt;max-age=0&lt;/code&gt; を設定して、既存のキャッシュ応答もクリアできます。これにより、キャッシュがサーバーで再検証されます（ &lt;code&gt;no-store&lt;/code&gt; で使用した場合、他のディレクティブは効果がありません）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="175c4a1ccf44338f289e8f6a8f5b206b71c5531a" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable.</source>
          <target state="translated">応答が通常キャッシュ&lt;em&gt;できない&lt;/em&gt;場合でも、応答は&lt;em&gt;任意の&lt;/em&gt;キャッシュに保存できます。</target>
        </trans-unit>
        <trans-unit id="cf2982c4aaa9bc3f78fafab7d00a3ebb08a20bc3" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable. However, the stored response MUST &lt;em&gt;always&lt;/em&gt; go through validation with the origin server first before using it, therefore, you cannot use &lt;code&gt;no-cache&lt;/code&gt; in-conjunction with &lt;code&gt;immutable&lt;/code&gt;. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="translated">応答が通常キャッシュ&lt;em&gt;できない&lt;/em&gt;場合でも、応答は&lt;em&gt;任意の&lt;/em&gt;キャッシュに保存できます。ただし、保存された応答は、使用する前に&lt;em&gt;必ず&lt;/em&gt;最初にオリジンサーバーで検証する必要があります。したがって、 &lt;code&gt;no-cache&lt;/code&gt; を &lt;code&gt;immutable&lt;/code&gt; と組み合わせて使用することはできません。 &lt;code&gt;no-store&lt;/code&gt; &lt;em&gt;このディレクティブは、キャッシュが応答を保存するのを防ぐのに効果的ではありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaa0d406c5950086dcf14084183c400a270e03bf" translate="yes" xml:space="preserve">
          <source>The response may be stored only by a &lt;em&gt;browser's&lt;/em&gt; cache, even if the response is normally non-cacheable. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="translated">応答が通常キャッシュできない場合でも、応答は&lt;em&gt;ブラウザの&lt;/em&gt;キャッシュによってのみ保存される場合があります。 &lt;code&gt;no-store&lt;/code&gt; &lt;em&gt;このディレクティブは、キャッシュが応答を保存するのを防ぐのに効果的ではありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18efe3bb77387fcf6dc94b18b57204fcd81a30a1" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header that holds the allowed methods:</source>
          <target state="translated">応答には、&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;れたメソッドを保持するAllowヘッダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">応答には、&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;れたメソッドを含むAllowヘッダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答に必要な&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;ヘッダーがありません。これは、現在のオリジン内で動作するコンテンツがリソースにアクセスできるかどうかを判断するために使用されます。</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">サーバーから送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答には、少なくとも1つの無効なヘッダー名を含む&lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;ヘッダーが含まれています。</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">サーバーから送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;要求への応答には、少なくとも1つの無効なメソッド名を含む&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;ヘッダーが含まれています。</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">リクエストに対する応答は別のURIで見つけることができ、そのリソース上でGETメソッド を使用して取得するべきである[SHOULD]。このメソッドは主に、ユーザーエージェントを選択されたリソースにリダイレクト するためのPOST動作スクリプトの出力を可能にするために存在する。新しいURIは、最初にリクエストされたリソースの代替参照ではない。303応答はキャッシュされてはならない[MUST NOT]が、2つ目の(リダイレクトされた)リクエ ストに対する応答はキャッシュ可能かもしれない。異なるURIは応答のLocationフィールドで与えられるべきである[SHOULD]。リクエストメソッドがHEADでない限り、応答の実体は新しいURIへのハイパーリ ンクを持つ短いハイパーテキストノートを含むべきである[SHOULD]。注意:多くのHTTP/1.1以前のユーザーエージェントは303ステータスを理解していない。そのようなクライアントとの相互運用性が懸念される場合、代わりに 302ステータスコードを使用してもよい。</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">応答ヘッダーフィールドを使用すると、サーバーはステータスラインに配置できない応答に関する追加情報を渡すことができます。これらのヘッダーフィールドは、サーバーに関する情報と、Request-URIで識別されるリソースへの以降のアクセスに関する情報を提供します。 response-header = Accept-Ranges; &lt;a href=&quot;#section-14.5&quot;&gt;セクション14.5&lt;/a&gt; |年齢; &lt;a href=&quot;#section-14.6&quot;&gt;セクション14.6&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;セクション14.19&lt;/a&gt; |場所; &lt;a href=&quot;#section-14.30&quot;&gt;セクション14.30&lt;/a&gt; |プロキシ認証; &lt;a href=&quot;#section-14.33&quot;&gt;セクション14.33&lt;/a&gt; |再試行後; &lt;a href=&quot;#section-14.37&quot;&gt;セクション14.37&lt;/a&gt; | サーバー; &lt;a href=&quot;#section-14.38&quot;&gt;セクション14.38&lt;/a&gt; | 変化する; &lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44&lt;/a&gt; | WWW-Authenticate; &lt;a href=&quot;#section-14.47&quot;&gt;セクション14.47&lt;/a&gt; 応答ヘッダーフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての関係者がそれらを応答ヘッダーフィールドであると認識する場合、新しいヘッダーフィールドまたは実験的なヘッダーフィールドに応答ヘッダーフィールドのセマンティクスを与えることができます。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="de697a10218156ed8950f6eb5d8f3042358089a2" translate="yes" xml:space="preserve">
          <source>The result of applying the digest algorithm to the resource representation and encoding the result. The choice of digest algorithm also determines the encoding to use: for example &lt;code&gt;SHA-256&lt;/code&gt; uses base64 encoding.</source>
          <target state="translated">ダイジェストアルゴリズムをリソース表現に適用し、結果をエンコードした結果。ダイジェストアルゴリズムの選択により、使用するエンコーディングも決まります。たとえば、 &lt;code&gt;SHA-256&lt;/code&gt; はbase64エンコーディングを使用します。</target>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">結果の文字列は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;エンコードされます（ &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">エンティティヘッダーで返されるメタ情報は、オリジンサーバーから入手可能な最終的なセットではなく、 ローカルまたはサードパーティのコピーから収集されたものである。提示されるセットは、元のバージョンのサブセットまたはスーパーセットであってもよい[MAY]。例えば、リソースに関するローカルの注釈情報を含めると、オリジンサーバーが知っているメタ情報のスーパーセットになるかもしれません。この応答コードの使用は必須ではなく、応答が200(OK)の場合にのみ適切である。</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">revved リソースに追加されるリビジョンバージョンは、1.1.3 のような古典的なリビジョン文字列である必要はありません。ハッシュや日付のように、衝突を防ぐものであれば何でも構いません。</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">カテゴリドキュメントのルートは「app：categories」要素です。 app：categories要素には、Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]名前空間（ &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;）。「scheme」属性を持たないatom：category子要素は、app：categories親から属性を継承します。既存の「scheme」属性を持つatom：category子要素は、アプリの「scheme」値を継承しません：categories親要素atomCategory = element atom：category {atomCommonAttributes、attribute term {text}、attribute scheme {atomURI} ?, attribute label {text} ?, undefinedContent} appInlineCategories = element app：categories {attribute fixed {&quot;yes&quot; | &quot;no&quot;} ?、属性スキーム{atomURI}？、（atomCategory *、undefinedContent）} appOutOfLineCategories = element app：カテゴリー{属性href {アトムURI}、undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">サービスドキュメントのルートは「app：service」要素です。 app：service要素は、1つ以上のワークスペースに関連付けられたサービス情報のコンテナーです。 app：service要素には、1つ以上のapp：workspace要素が含まれている必要があります。名前空間app = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot; start = appService appService = element app：service {appCommonAttributes、（appWorkspace +＆extensionElement *）}</target>
        </trans-unit>
        <trans-unit id="7cc82da0d72b8678f1e0f58ad59a34e42ed94203" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">同じチャレンジアンドレスポンスメカニズムを&lt;em&gt;プロキシ認証に&lt;/em&gt;使用できます。リソース認証とプロキシ認証の両方が共存できるため、異なるヘッダーとステータスコードのセットが必要です。プロキシの場合、チャレンジステータスコードは&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（プロキシ認証が必要）であり、&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーにはプロキシに適用可能なチャレンジが少なくとも1つ含まれ、&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;リクエストヘッダーはプロキシに資格情報を提供するために使用されますサーバ。</target>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">同じチャレンジおよびレスポンスメカニズムを&lt;em&gt;プロキシ認証に&lt;/em&gt;使用できます。この場合、認証が必要なのは中間プロキシです。リソース認証とプロキシ認証の両方が共存できるため、異なるヘッダーとステータスコードのセットが必要です。プロキシの場合、チャレンジステータスコードは&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（Proxy Authentication Required）であり、&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーにはプロキシに適用可能なチャレンジが少なくとも1つ含まれ、&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;リクエストヘッダーはプロキシに資格情報を提供するために使用されますサーバ。</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">同一サイト属性は、2つの値のうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">機能ポリシーを使用する2番目の方法は、iframe内のコンテンツを制御することです。埋め込みコンテンツのポリシーリストを指定するには、 &lt;code&gt;allow&lt;/code&gt; 属性を使用します。</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;プリフライトされたアクセス制御要求&lt;/a&gt;に関するセクションには、クライアントとサーバー間のヘッダー交換が示されています。プリフライト要求に応答するサーバーリソースは、次の決定を行うことができる必要があります。</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">&lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt;のセクションでは、クライアントとサーバー間のヘッダー交換について説明します。以下は、単純なリクエストを処理するPHPコードセグメントです。</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">GETは「エンティティの形式で、Request-URIによって識別されるすべての情報を取得する」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] として定義されているため、コレクションに適用された場合、GETのセマンティクスは変更されません。 GETをコレクションに適用すると、「index.html」リソースのコンテンツ、人間が読めるコレクションのコンテンツのビュー、またはその他のものがすべて返される場合があります。したがって、コレクションに対するGETの結果は、コレクションのメンバーシップと相関関係がない可能性があります。同様に、HEADの定義は応答メッセージ本文のないGETであるため、コレクションリソースに適用した場合、HEADのセマンティクスは変更されません。</target>
        </trans-unit>
        <trans-unit id="396399030f5f70b59d96457aab0c93681f8f8559" translate="yes" xml:space="preserve">
          <source>The sender provides a list of digests which it is prepared to accept, and the server uses one of them:</source>
          <target state="translated">送信者は受け入れる準備ができているダイジェストのリストを提供し、サーバはそれらのうちの1つを使用します。</target>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">サーバーは、ターゲットリソースの現在サポートされているメソッドのリストを含む405応答に &lt;code&gt;Allow&lt;/code&gt; ヘッダーフィールドを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">サーバーは、値が「 &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; 」の &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; も送信し、これらが実際のリクエストで使用できるヘッダーであることを確認します。 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; と同様に、 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; は、受け入れ可能なヘッダーのコンマ区切りのリストです。</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">サーバーは、ヘッダー &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; ：http://example.org/whaddupを含むコード&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;で応答します。</target>
        </trans-unit>
        <trans-unit id="9ba7f7b6673dbfa8ce3c9b9d755ecdbe8064fd0d" translate="yes" xml:space="preserve">
          <source>The server can choose to ignore the request, for any reason, in which case it should just respond as though the &lt;code&gt;Upgrade&lt;/code&gt; header had not been sent (for example, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">サーバーは、何らかの理由で要求を無視することを選択できます。その場合、サーバーは、 &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーが送信されていないかのように応答する必要があります（たとえば、&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200 OK&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">サーバーは要求されたリソースを見つけることができません。ブラウザでは、これは URL が認識されていないことを意味します。API では、これはエンドポイントは有効だが、リソース自体が存在しないことを意味する場合もあります。サーバーは、許可されていないクライアントからリソースの存在を隠すために 403 の代わりにこの応答を送信することもあります。このレスポンスコードは、ウェブ上で頻繁に発生するため、おそらく最も有名なものです。</target>
        </trans-unit>
        <trans-unit id="5c4ccfae2be68876da45c9c1dc793bd8e937dfdb" translate="yes" xml:space="preserve">
          <source>The server can not find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurrence on the web.</source>
          <target state="translated">サーバーは要求されたリソースを見つけることができません。ブラウザでは、これは URL が認識されていないことを意味します。API では、これはエンドポイントは有効だが、リソース自体が存在しないことを意味する場合もあります。サーバーは、許可されていないクライアントからリソースの存在を隠すために 403 の代わりにこの応答を送信することもあります。このレスポンスコードは、ウェブ上で頻繁に発生するため、おそらく最も有名なものです。</target>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">これで、サーバーは安全なバージョンのサイトにリダイレクトできます。&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;サイトがアップグレードメカニズムをサポートしていないクライアントにキャッシュによって提供されないように、ヘッダを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">サーバーは、クライアントの比較 &lt;code&gt;ETag&lt;/code&gt; （で送信された &lt;code&gt;If-None-Match&lt;/code&gt; 付き） &lt;code&gt;ETag&lt;/code&gt; 、バックサーバの送信リソースの現在のバージョンの両方の値が一致した場合（つまり、リソースが変更されていない）&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; 状態を、本文なしで、応答のキャッシュされたバージョンがまだ適切であることをクライアントに伝えます（&lt;em&gt;fresh&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="605fba61796e65ffe01c32b3fab960c6c121a075" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource, and if both values match (that is, the resource has not changed), the server sends back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; status, without a body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">サーバーは、クライアントの比較 &lt;code&gt;ETag&lt;/code&gt; （で送信された &lt;code&gt;If-None-Match&lt;/code&gt; 付き） &lt;code&gt;ETag&lt;/code&gt; リソースの現在のバージョンの、そして両方の値である（つまり、リソースが変更されていない）と一致する場合、サーバが返信&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; ステータス、本文なし。これは、キャッシュされたバージョンの応答を引き続き使用できることをクライアントに通知します（&lt;em&gt;fresh&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">サーバーは、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;などの他の&lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;ヘッダーも考慮することができます。</target>
        </trans-unit>
        <trans-unit id="de85219a30abbe89bbf789c793cb5b7464c7af45" translate="yes" xml:space="preserve">
          <source>The server could not understand the request due to invalid syntax.</source>
          <target state="translated">無効な構文のため、サーバーはリクエストを理解できませんでした。</target>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">サーバーはリクエストの処理中に無限ループを検出しました。</target>
        </trans-unit>
        <trans-unit id="d4d0d326b4b9b27451ac87954663d1d88395013c" translate="yes" xml:space="preserve">
          <source>The server did not respond to the actual request (even if it responded to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;Preflight request&lt;/a&gt;). One scenario might be an HTTP service being developed that panicked without returning any data.</source>
          <target state="translated">サーバーは実際の要求に応答しませんでした（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;プリフライト要求に&lt;/a&gt;応答した場合でも）。1つのシナリオは、データを返さずにパニックに陥った開発中のHTTPサービスである可能性があります。</target>
        </trans-unit>
        <trans-unit id="718a8af818cfbe608b72da24119ebf87df3d139e" translate="yes" xml:space="preserve">
          <source>The server does not support any of the requested digest algorithms, so responds with a 400 error and includes another &lt;code&gt;Want-Digest&lt;/code&gt; header, listing the algorithms that it does support:</source>
          <target state="translated">サーバーは要求されたダイジェストアルゴリズムをサポートしていないため、400エラーで応答し、サポートしているアルゴリズムを一覧表示する別の &lt;code&gt;Want-Digest&lt;/code&gt; ヘッダーを含めます。</target>
        </trans-unit>
        <trans-unit id="e0e228c6efc54e191da08ed522fb1aa98706bc14" translate="yes" xml:space="preserve">
          <source>The server does not support any of the requested digest algorithms, so uses a different algorithm:</source>
          <target state="translated">サーバーは要求されたダイジェストアルゴリズムをサポートしていないため、別のアルゴリズムを使用しています。</target>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">サーバーはリクエストを満たすために必要な機能をサポートしていません。これは、サーバがリクエストメソッドを認識しておらず、どのリソースに対してもリクエストメソッドをサポートすることができない場合に適切な応答です。</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">サーバーは、要求メッセージで使用されたHTTPプロトコルバージョンをサポートしていないか、サポートを拒否します。サーバーは、&lt;a href=&quot;#section-3.1&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;で説明されているように、このエラーメッセージ以外では、クライアントと同じメジャーバージョンを使用して要求を完了することができないか、望まないことを示しています。応答には、そのバージョンがサポートされていない理由と、そのサーバーでサポートされている他のプロトコルを説明するエンティティが含まれている必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">サーバーはブラウザの機能を完全に把握していません。クライアントヒント拡張機能を使用しても、ブラウザの機能について完全な知識を持っているわけではありません。クライアントが選択するリアクティブなコンテンツネゴシエーションとは異なり、サーバーの選択は常に多少恣意的です。</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">サーバーは予期しない状態に遭遇したため、リクエストの実行ができませんでした。</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">選択されたバリアントリソースは、透過的なコンテンツネゴシエーションを行うように構成されているため、ネゴシエーションプロセスの適切なエンドポイントではありません。</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">サーバーには内部構成エラーがあります。リクエストに対する透過コンテンツネゴシエーションでは、循環参照が発生します。</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">サーバーが処理方法を知らない状況に遭遇しました。</target>
        </trans-unit>
        <trans-unit id="5cf27f01c140eea8ea3c01504b142779b0027690" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a &lt;code&gt;GET&lt;/code&gt; request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">サーバーはリソースに対する &lt;code&gt;GET&lt;/code&gt; 要求を実行しました。応答は、現在のインスタンスに適用された1つ以上のインスタンス操作の結果を表しています。</target>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">サーバはリソースに対する GET 要求を満たし、応答は現在のインスタンスに適用された 1 つ以上のインスタンス操作の結果を表現したものです。</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">サーバーはリソースの部分的なGETリクエストを実行しました。リクエストには、希望する範囲を示すRangeヘッダーフィールド（&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;）が含まれている必要があり、リクエストを条件付きにするためにIf-Rangeヘッダーフィールド（&lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt;）が含まれている場合があります。応答には、次のヘッダーフィールドを含める必要があります。-Content-Rangeヘッダーフィールド（&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt;）このレスポンスに含まれる範囲、または各パートのContent-Rangeフィールドを含むmultipart / byteranges Content-Typeを示します。 Content-Lengthヘッダーフィールドが応答に存在する場合、その値はメッセージ本文で送信される実際のOCTETの数と一致する必要があります。 -日付-ETagおよび/またはContent-Location（ヘッダーが同じリクエストへの200応答で送信された場合）-Expires、Cache-Control、および/またはVary、フィールド値が送信されたものと異なる場合同じバリアントに対する以前の応答206応答が強力なキャッシュバリデーターを使用したIf-Rangeリクエストの結果である場合（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3を&lt;/a&gt;参照））、応答には他のエンティティヘッダーを含めないでください。応答が弱いバリデーターを使用したIf-Rangeリクエストの結果である場合、応答には他のエンティティヘッダーを含めることはできません。これにより、キャッシュされたエンティティ本体と更新されたヘッダーの間の不整合が防止されます。それ以外の場合、応答には、同じ要求に対する200（OK）応答で返されるすべてのエンティティヘッダーを含める必要があります。 ETagまたはLast-Modifiedヘッダーが正確に一致しない場合、キャッシュは206応答を他の以前にキャッシュされたコンテンツと組み合わせてはなりません（MUST NOT）。13.5.4を参照してください。 RangeおよびContent-Rangeヘッダーをサポートしないキャッシュは、206（部分）応答をキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">サーバーはリクエストを満たしたので、ユーザーエージェントはリクエストを送る原因となった ドキュメントビューをリセットすべきである[SHOULD]。この応答は、ユーザーが別の入力アクションを簡単に開始できるように、 ユーザー入力を介して行われるアクションのための入力を可能にすることを主 に意図しており、その後、入力が与えられたフォームのクリアが続く。応答はエンティティを含めてはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">サーバーはリクエストを満たしたが、エンティティボディを返す必要はなく、 更新されたメタ情報を返したいかもしれない。応答は、エンティティヘッダーの形で新規または更新されたメタ情報を 含めてもよい[MAY]。エンティティヘッダーが存在する場合、リクエストされた variantに関連付けられるべきである[SHOULD]。クライアントがユーザーエージェントの場合、リクエストを送った原因となった ドキュメントビューを変更するべきではない[SHOULD NOT]。この応答は主に、ユーザーエージェントのアクティブなドキュメントビューに変更を 起こさずに実行されるアクションのための入力を許可することを意図しているが、 新規または更新されたいかなるメタ情報も、現在ユーザーエージェントの アクティブなビューにあるドキュメントに適用されるべきである[SHOULD]。204応答はメッセージボディを含んではならない[MUST NOT]ため、常にヘッダーフィールドの後の最初の空行で終了する。</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">サーバーはRequest-URIに一致するものを見つけられませんでした。状態が一時的なものなのか永続的なものなのかは示されていない。410(Gone)ステータスコードは、古いリソースが永久に利用できず、転送アド レスを持たないことを、サーバーが内部的に設定可能な何らかのメカニズムを 通じて知っている場合に使用されるべきである[SHOULD]。このステータスコードは、サーバーがリクエストが拒否された理由を正確に明らかに したくない場合や、他の応答が適用できない場合に一般的に使用される。</target>
        </trans-unit>
        <trans-unit id="1d3eb58f597e0c6c5fa76c0069741d7639896309" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">サーバーは、この応答に、切り替えたプロトコルを示す&lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;応答ヘッダーを含めます。このプロセスについては、&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;プロトコルアップグレードメカニズムの&lt;/a&gt;記事で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">サーバーはこの応答に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;応答ヘッダーを含めて、切り替え先のプロトコルを示します。このプロセスは、「&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;プロトコルのアップグレードメカニズム」の&lt;/a&gt;記事で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">現在、サーバーは一時的な過負荷またはサーバーのメンテナンスのため、リクエストを処理することができません。これは一時的な状態であり、ある程度の遅延の後に緩和されるということを暗示 している。それがわかっている場合、遅延の長さをRetry-Afterヘッダーで示してもよい[MAY]。Retry-Afterが与えられない場合、クライアントは500応答の場合と同様に 応答を処理するべきである[SHOULD]。注意:503ステータスコードの存在は、過負荷になったときにサーバーがそれを使用しな ければならないことを暗示しているわけではない。サーバーによっては、単に接続を拒否することを望むかもしれない。</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">サーバーはリクエストを処理する準備ができていません。一般的な原因は、メンテナンスのためにサーバーがダウンしているか、過負荷になっているサーバーです。この応答とともに、問題を説明する使いやすいページを送信する必要があることに注意してください。この応答は一時的な状況で使用する必要があり、 &lt;code&gt;Retry-After:&lt;/code&gt; HTTPヘッダーには、可能であれば、サービスが回復するまでの推定時間を含める必要があります。これらの一時的な条件応答は通常キャッシュされるべきではないため、Webマスターは、この応答と共に送信されるキャッシュ関連のヘッダーにも注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">サーバーに負荷がかかりすぎていて、圧縮要件による計算オーバーヘッドを許容できない。一般的に、Microsoft は、サーバが 80% 以上の計算能力を使用している場合は圧縮しないことを推奨しています。</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">リクエストの実体がサーバーが処理する意思があるか、または処理できるよりも大きいため、 サーバーはリクエストの処理を拒否している。サーバーは、クライアントがリクエストを継続できないようにするために、 接続を閉じてもよい[MAY]。その状態が一時的なものである場合、サーバーはそれが一時的なものであり、何時までにクライア ントが再試行してもよい[MAY]ことを示すために、Retry-Afterヘッダーフィー ルドを含めるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">Request-URIがサーバーが解釈しようとするよりも長いため、サーバーはリクエストの サービスを拒否している。このまれな状態は、クライアントが長い問い合わせ情報を持つPOSTリクエストを 不適切にGETリクエストに変換した場合、クライアントがリダイレクションの URI「ブラックホール」(例えば、それ自身の接尾辞を指すリダイレクトされたURI接頭辞)に陥った場合、またはRequest-URIを読み取ったり操作したりするために固定長の バッファを使用するいくつかのサーバーに存在するセキュリティホールを悪用しようとするクライア ントによってサーバーが攻撃を受けている場合にのみ発生する可能性がある。</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">リクエストの実体が、リクエストされたメソッドに対してリクエストされたリソースがサポートしていない形式であるため、サーバーはリクエストのサービスを拒否しています。</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">サーバーはそのヘッダーフィールドが大きすぎるため、リクエストを処理する気がない。リクエストヘッダーフィールドのサイズを小さくしてから、リクエストを再提出してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="2cabf4085dccd9d1a0d60a5bef8f53aaaa7eb900" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">サーバーはリクエストのヘッダーフィールドが大きすぎるため、リクエストを処理する気がありません。リクエストヘッダーフィールドのサイズを小さくした後で、リクエストは再送されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">サーバーはアップグレードを拒否する可能性があります&amp;mdash;この場合、 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; ヘッダーを無視して通常の応答（要求されたリソースを提供できる場合は &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; 、リダイレクトを実行する場合は &lt;code&gt;30x&lt;/code&gt; ステータスコード）を返します。要求されたリソースを提供できない場合は &lt;code&gt;40x&lt;/code&gt; または &lt;code&gt;50x&lt;/code&gt; 倍）、またはアップグレードを受け入れます。この場合、選択したプロトコルを指定するUpgradeヘッダーを含む &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; を送り返します。</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">サーバはワイルドカードとして &quot;*&quot;を指定することができ、それによって任意のオリジンがタイミングリソースを見ることができるようになります。</target>
        </trans-unit>
        <trans-unit id="767e4fc07c131eef7a83181be5734574f3f01fab" translate="yes" xml:space="preserve">
          <source>The server now can respond if it will accept a request under these circumstances. In this example, the server response says that:</source>
          <target state="translated">このような状況下でリクエストを受け入れるかどうかをサーバが応答できるようになりました。この例では、サーバーのレスポンスはこう言っています。</target>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">サーバーはリクエストヘッダーを確認し、&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（Continue）レスポンスで応答して、クライアントにメッセージ本文を送信するように指示するか、期待値のいずれかが満たされない場合は&lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt;（Expectedation Failed）ステータスを送信します。</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">サーバーは、単一のオリジンである onlinebanking.jumbobank.com を通じて HTTPS で特別に読み込まれた文書へのアクセスのみを許可します。</target>
        </trans-unit>
        <trans-unit id="26883acb60acb54540a0e576eaa8444f3824e5cd" translate="yes" xml:space="preserve">
          <source>The server permits access only to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">サーバーは、単一のオリジンである onlinebanking.jumbobank.com を通じて、HTTPS で特別に読み込まれた文書へのアクセスのみを許可します。</target>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">サーバーはリクエストを処理し、その回答を送り返し、ステータスコードと適切なデータを提供します。</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">ティーポットでコーヒーを淹れようとすると、サーバーが断る。</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">サーバーは、定義されたContent-Lengthを持たないリクエストの受け入れを 拒否する。クライアントは、リクエストメッセージ中のメッセージボディの長さを含む有効な Content-Lengthヘッダーフィールドを追加する場合、リクエストを繰り返してもよい[MAY]。</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">サーバーは、現在のプロトコルを使用して要求を実行することを拒否しますが、クライアントが別のプロトコルにアップグレードした後で実行する可能性があります。サーバーは、426応答で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを送信して、必要なプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="82c879297c83c6c0c7f5e4355a3573667d1d3938" translate="yes" xml:space="preserve">
          <source>The server responds to a client with a &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt; (Unauthorized) response status and provides information on how to authorize with a &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; response header containing at least one challenge.</source>
          <target state="translated">サーバーは、&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt;（未承認）応答ステータスでクライアントに応答し、少なくとも1つのチャレンジを含む&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;応答ヘッダーで承認する方法に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">サーバーは&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で&lt;/a&gt;応答し、 &lt;code&gt;POST&lt;/code&gt; 、 &lt;code&gt;GET&lt;/code&gt; 、および &lt;code&gt;OPTIONS&lt;/code&gt; は問題のリソースを照会するための実行可能なメソッドであると述べています。このヘッダーは&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、CORSのコンテキスト内で厳密に使用されます。</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">サーバーは &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で応答し、 &lt;code&gt;POST&lt;/code&gt; および &lt;code&gt;GET&lt;/code&gt; は問題のリソースを照会するための実行可能なメソッドであると述べています。このヘッダーは&lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、アクセス制御のコンテキスト内で厳密に使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="50340f4cfb4f858ac4e526eb22f4eb0cf5120e8d" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt;, restricting access to just the requesting origin domain. It also responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, which says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question (this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control).</source>
          <target state="translated">サーバーは &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt; で応答し、要求元のドメインのみにアクセスを制限します。また、 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; で応答します。これは、 &lt;code&gt;POST&lt;/code&gt; と &lt;code&gt;GET&lt;/code&gt; が問題のリソースをクエリするための実行可能なメソッドであることを示します（このヘッダーは&lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;応答ヘッダーに似ていますが、アクセス制御のコンテキスト内で厳密に使用されます）。</target>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">サーバーは、 &lt;code&gt;Content-Encoding&lt;/code&gt; 応答ヘッダーで示される、使用されるスキームで応答します。</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">サーバーは&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ステータスと&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; ヘッダー。マルチパートバイト範囲が続くことを示します。各部分には独自の &lt;code&gt;Content-Type&lt;/code&gt; フィールドと &lt;code&gt;Content-Range&lt;/code&gt; フィールドが含まれ、必須の境界パラメーターは、各本体部分を区切るために使用される境界文字列を指定します。</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">サーバーは&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ステータスで応答します。</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">サーバーは、この応答と共に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを送信して、必要なプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">サーバーはこの応答を送信して、前の要求で使用されたのと同じメソッドを使用して、要求されたリソースを別のURIで取得するようクライアントに指示します。これは、同じセマンティック有する &lt;code&gt;302 Found&lt;/code&gt; ユーザーエージェントがことを除いて、HTTP応答コードを&lt;em&gt;してはならない&lt;/em&gt;場合：使用するHTTPメソッドを変更 &lt;code&gt;POST&lt;/code&gt; が最初の要求で使用された、 &lt;code&gt;POST&lt;/code&gt; は、第2の要求に使用されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">サーバはこのレスポンスを送信して、クライアントが要求されたリソースを別のURIでGETリクエストで取得するように指示しました。</target>
        </trans-unit>
        <trans-unit id="848c3b9ad4be0c1360d99c2d9af3ef34c33fe75c" translate="yes" xml:space="preserve">
          <source>The server takes the value of the Sec-WebSocket-Key sent in the handshake request, appends &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt;, takes SHA-1 of the new value, and is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded.</source>
          <target state="translated">サーバーは、ハンドシェイク要求で送信されたSec-WebSocket-Keyの値を取得し、 &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt; を追加し、新しい値のSHA-1を取得して、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64で&lt;/a&gt;エンコードします。</target>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">サーバーは、この接続で使用されているアプリケーションプロトコルの変更について、Upgradeメッセージヘッダーフィールド（&lt;a href=&quot;#section-14.42&quot;&gt;セクション14.42&lt;/a&gt;）を介してクライアントの要求を理解し、クライアントの要求に応じます。サーバーは、101応答を終了する空の行の直後に、プロトコルを応答のUpgradeヘッダーフィールドで定義されたプロトコルに切り替えます。プロトコルは、そうすることが有利な場合にのみ切り替える必要があります。たとえば、HTTPの新しいバージョンへの切り替えは古いバージョンよりも有利であり、リアルタイムの同期プロトコルへの切り替えは、そのような機能を使用するリソースを配信するときに有利になる場合があります。</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">サーバーはリクエストを理解したが、それを実行することを拒否している。認可は何の役にも立たず、リクエストは繰り返されるべきではない[SHOULD NOT]。リクエストメソッドがHEADではなく、サーバーがリクエストが満たされなかった理由を公開したい場合、 エンティティに拒否の理由を記述するべきである[SHOULD]。サーバーがこの情報をクライアントに公開したくない場合、代わりにステータスコード404(Not Found)を使用することができる。</target>
        </trans-unit>
        <trans-unit id="2bccd21746e24e17c4d6598c2feaeef9e50bab37" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;a href=&quot;headers/sec-websocket-accept&quot;&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/a&gt; header will have a value computed based upon the specified &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">サーバーの応答の&lt;a href=&quot;headers/sec-websocket-accept&quot;&gt; &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; &lt;/a&gt;ヘッダーには、指定された &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt; 基づいて計算された値が含まれます。</target>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">サーバーの応答の &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; ヘッダーには、指定された &lt;code&gt;key&lt;/code&gt; 基づいて計算された値が含まれます。</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">ゲートウェイまたはプロキシとして動作している間、サーバーはURIで指定されたアップストリームサーバー (HTTP、FTP、LDAPなど)またはリクエストを完了しようとする際にアクセスする必要のある他の補助サーバー(DNSなど)から タイムリーな応答を受け取らなかった。注意:実装者への注意:いくつかの配備されたプロキシは、DNSのルックアップがタイムアウトしたときに400または500を返すことが知られています。</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">サーバーがゲートウェイまたはプロキシとして動作しているときに、 リクエストを満たすためにアクセスしたアップストリームサーバーから 無効な応答を受け取った。</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">HTTP / 1.1の一般的なメソッドのセットを以下に定義します。このセットは拡張できますが、個別に拡張されたクライアントとサーバーで同じセマンティクスを共有する追加のメソッドを想定することはできません。Hostリクエストヘッダーフィールド（&lt;a href=&quot;#section-14.23&quot;&gt;セクション14.23&lt;/a&gt;）は、すべてのHTTP / 1.1リクエストに伴う必要があります。</target>
        </trans-unit>
        <trans-unit id="3aa1224052f644e6f5d9789fe1626a5e5119f08c" translate="yes" xml:space="preserve">
          <source>The simplest MIME type consists of a &lt;var&gt;type&lt;/var&gt; and a &lt;var&gt;subtype&lt;/var&gt;; these are each strings which, when concatenated with a slash (&lt;code&gt;/&lt;/code&gt;) between them, comprise a MIME type. No whitespace is allowed in a MIME type:</source>
          <target state="translated">最も単純なMIMEタイプは、 &lt;var&gt;type&lt;/var&gt; と &lt;var&gt;subtype&lt;/var&gt; 構成されます。これらはそれぞれ文字列であり、それらの間にスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）を連結すると、MIMEタイプを構成します。MIMEタイプに空白は使用できません。</target>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">サイトは、投稿が公開されたことを確認する一般的な成功メッセージを返します。サーバーは、 &lt;code&gt;Content-Location&lt;/code&gt; を使用して新しい投稿の&lt;em&gt;場所を&lt;/em&gt;指定します。</target>
        </trans-unit>
        <trans-unit id="7fbace9bd6e583c6dea1bfd3ddf4f66e59607425" translate="yes" xml:space="preserve">
          <source>The size of a frame payload is limited by the maximum size that a
   receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.  This
   setting can have any value between 2^14 (16,384) and 2^24-1
   (16,777,215) octets, inclusive.

   All implementations MUST be capable of receiving and minimally
   processing frames up to 2^14 octets in length, plus the 9-octet frame
   header (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).  The size of the frame header is not included
   when describing frame sizes.

      Note: Certain frame types, such as PING (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;), impose
      additional limits on the amount of payload data allowed.

   An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame
   exceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any
   limit defined for the frame type, or is too small to contain
   mandatory frame data.  A frame size error in a frame that could alter
   the state of the entire connection MUST be treated as a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;); this includes any frame carrying a header
   block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) (that is, HEADERS, PUSH_PROMISE, and
   CONTINUATION), SETTINGS, and any frame with a stream identifier of 0. 

   Endpoints are not obligated to use all available space in a frame.
   Responsiveness can be improved by using frames that are smaller than
   the permitted maximum size.  Sending large frames can result in
   delays in sending time-sensitive frames (such as RST_STREAM,
   WINDOW_UPDATE, or PRIORITY), which, if blocked by the transmission of
   a large frame, could affect performance.</source>
          <target state="translated">フレームペイロードのサイズは、受信者がSETTINGS_MAX_FRAME_SIZE設定でアドバタイズする最大サイズによって制限されます。この設定には、2 ^ 14（16,384）から2 ^ 24-1（16,777,215）オクテットまでの任意の値を指定できます。すべての実装は、最大2 ^ 14オクテットの長さのフレームと、9オクテットのフレームヘッダーを受信して​​最小限に処理できる必要があります（&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）。フレームサイズを記述する場合、フレームヘッダーのサイズは含まれません。注：PING（&lt;a href=&quot;#section-6.7&quot;&gt;セクション6.7）&lt;/a&gt;などの特定のフレームタイプ）、許可されるペイロードデータの量に追加の制限を課します。フレームがSETTINGS_MAX_FRAME_SIZEで定義されたサイズを超える場合、フレームタイプに定義された制限を超える場合、または必須のフレームデータを含めるには小さすぎる場合、エンドポイントはFRAME_SIZE_ERRORのエラーコードを送信する必要があります。接続全体の状態を変更する可能性のあるフレームのフレームサイズエラーは、接続エラーとして処理する必要があります（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）。これには、ヘッダーブロックを運ぶフレームが含まれます（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）（つまり、HEADERS、PUSH_PROMISE、およびCONTINUATION）、SETTINGS、およびストリーム識別子が0のフレーム。エンドポイントは、フレーム内の使用可能なすべてのスペースを使用する義務はありません。許容最大サイズよりも小さいフレームを使用することで、応答性を向上させることができます。大きなフレームを送信すると、時間に敏感なフレーム（RST_STREAM、WINDOW_UPDATE、PRIORITYなど）の送信に遅延が発生する可能性があり、大きなフレームの送信によってブロックされると、パフォーマンスに影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="d9ec569438b6e170956f6c9751913bd129236874" translate="yes" xml:space="preserve">
          <source>The size of the resource, in decimal number of bytes.</source>
          <target state="translated">リソースのサイズを10進数で表します。</target>
        </trans-unit>
        <trans-unit id="9fb8b58154cc46b27e579e11d1cdd3ea67056760" translate="yes" xml:space="preserve">
          <source>The special value ''clear&quot; indicates that the origin requests all alternatives for that origin to be invalidated.</source>
          <target state="translated">特別な値 ''clear&quot; は、オリジンがそのオリジンのすべての代替案の無効化を要求していることを示します。</target>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">特別な値「 &lt;code&gt;*&lt;/code&gt; 」は、サーバー主導のコンテンツネゴシエーションでも、ヘッダーで伝達されない情報を使用して適切なコンテンツを選択することを意味します。</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">この仕様では、HTTPのオーバーヘッドを最小限に抑えるために、名前と説明は可能な限り短く(省略形を使用し、可能な場合はオプションの値を省略する)することが推奨されています。</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">仕様は明確にするために大幅に書き直されました。認証済みの応答をキャッシュできる条件が明確になりました。 （&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）新しいステータスコードで、キャッシュでヒューリスティックフレッシュネスを使用できることを定義できるようになりました。キャッシュは、クエリコンポーネントを使用してURIのヒューリスティックな鮮度を計算できるようになりました。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt;）年齢を計算するためのアルゴリズムの保守性が低下しました。正確に推測することができないため、キャッシュはタイムゾーンのある日付を無効であるかのように処理する必要があります。 （&lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt;）Content-Location応答ヘッダーフィールドは、検証時に使用する適切な応答を決定するために使用されなくなりました。 （&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）使用するためにキャッシュされたネゴシエートされた応答を選択するアルゴリズムは、いくつかの方法で明確にされています。特に、選択ヘッダーフィールドを処理するときに、ヘッダー固有の正規化を明示的に許可するようになりました。 （&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）無効化を実行する際のサービス拒否攻撃回避に関する要件が明確になりました。 （&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）キャッシュの無効化は、正常な応答を受信した場合にのみ発生します。 （&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）キャッシュディレクティブは、大文字と小文字を区別しないように明示的に定義されています。キャッシュディレクティブのインスタンスが1つだけ必要な場合の複数インスタンスの処理が定義されました。 （&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;） &quot;no-store&quot;リクエストディレクティブはレスポンスには適用されません。つまり、キャッシュは、ストアを持たない要求を満たし、それを無効化しません。 （&lt;a href=&quot;#section-5.2.1.5&quot;&gt;セクション5.2.1.5&lt;/a&gt;）プライベートおよびキャッシュなしのキャッシュディレクティブの修飾形式は、広く実装されていません。たとえば、 &quot;private = foo&quot;は多くのキャッシュによって単に &quot;private&quot;と解釈されます。さらに、ノーキャッシュの修飾形式の意味が明確になりました。 （&lt;a href=&quot;#section-5.2.2&quot;&gt;セクション5.2.2&lt;/a&gt;）「no-cache」応答ディレクティブの意味が明確になりました。 （&lt;a href=&quot;#section-5.2.2.2&quot;&gt;セクション5.2.2.2&lt;/a&gt;）Expiresヘッダーフィールド値の1年の制限が削除されました。代わりに、実用的な値を使用する理由が与えられます。 （&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）Pragmaヘッダーフィールドは、下位互換性のためにのみ定義されています。将来のプラグマは非推奨です。 （&lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt;）広く実装されていないため、警告ヘッダーフィールドの生成と処理に関する要件が緩和されました。さらに、警告ヘッダーフィールドは&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; エンコーディングを使用しなくなりました。また、これらの側面が実装されていなかったため、複数の言語を許可していません。 （&lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt;）この仕様では、キャッシュディレクティブと警告コードレジストリが導入され、新しいキャッシュディレクティブに関する考慮事項が定義されています。 （&lt;a href=&quot;#section-7.1&quot;&gt;セクション7.1&lt;/a&gt;および&lt;a href=&quot;#section-7.2&quot;&gt;セクション7.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">指定されたHTTPSプロキシを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">指定されたSOCKSサーバ(指定されたSOCOCKバージョンのもの)を使用してください。</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">指定したSOCKSサーバを使用してください。</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">指定されたプロキシを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">標準化されたヘッダー。</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">&lt;em&gt;ステータスライン&lt;/em&gt;と呼ばれるHTTP応答の開始行には、次の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">HTTPメッセージの開始行ヘッダーとHTTPヘッダーはまとめて要求の&lt;em&gt;ヘッド&lt;/em&gt;と呼ばれ、そのペイロードは&lt;em&gt;本文&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">ステータスコードレジストリは、以下の登録で更新されました。+ ------- + ----------------------------- -+ ---------------- + |値|説明|リファレンス| + ------- + ------------------------------- + --------- ------- + | 100 |続ける| &lt;a href=&quot;#section-6.2.1&quot;&gt;セクション6.2.1&lt;/a&gt; | | 101 |スイッチングプロトコル| &lt;a href=&quot;#section-6.2.2&quot;&gt;セクション6.2.2&lt;/a&gt; | | 200 | OK | &lt;a href=&quot;#section-6.3.1&quot;&gt;セクション6.3.1&lt;/a&gt; | | 201 |作成されました| &lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt; | | 202 |受け入れられる| &lt;a href=&quot;#section-6.3.3&quot;&gt;セクション6.3.3&lt;/a&gt; | | 203 |信頼できない情報| &lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt; | | 204 |コンテンツなし|&lt;a href=&quot;#section-6.3.5&quot;&gt;セクション6.3.5&lt;/a&gt; | | 205 |コンテンツをリセット| &lt;a href=&quot;#section-6.3.6&quot;&gt;セクション6.3.6&lt;/a&gt; | | 300 |複数の選択肢| &lt;a href=&quot;#section-6.4.1&quot;&gt;セクション6.4.1&lt;/a&gt; | | 301 |永久に移動しました| &lt;a href=&quot;#section-6.4.2&quot;&gt;セクション6.4.2&lt;/a&gt; | | 302 |見つかった| &lt;a href=&quot;#section-6.4.3&quot;&gt;セクション6.4.3&lt;/a&gt; | | 303 |その他を見る| &lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt; | | 305 |プロキシを使用| &lt;a href=&quot;#section-6.4.5&quot;&gt;セクション6.4.5&lt;/a&gt; | | 306 | （未使用）| &lt;a href=&quot;#section-6.4.6&quot;&gt;セクション6.4.6&lt;/a&gt; | | 307 |一時的なリダイレクト| &lt;a href=&quot;#section-6.4.7&quot;&gt;セクション6.4.7&lt;/a&gt; | | 400 |悪い要求| &lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt; | | 402 |お支払いが必要です| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | 403 |禁じられた| &lt;a href=&quot;#section-6.5.3&quot;&gt;セクション6.5.3&lt;/a&gt; | | 404 |見つかりません| &lt;a href=&quot;#section-6.5.4&quot;&gt;セクション6.5.4&lt;/a&gt; | | 405 |メソッドは許可されていません| &lt;a href=&quot;#section-6.5.5&quot;&gt;セクション6.5.5&lt;/a&gt; | | 406 |受け入れられない| &lt;a href=&quot;#section-6.5.6&quot;&gt;セクション6.5.6&lt;/a&gt; | | 408 |リクエストのタイムアウト| &lt;a href=&quot;#section-6.5.7&quot;&gt;セクション6.5.7&lt;/a&gt; | | 409 |紛争| &lt;a href=&quot;#section-6.5.8&quot;&gt;セクション6.5.8&lt;/a&gt; | | 410 |なくなった| &lt;a href=&quot;#section-6.5.9&quot;&gt;セクション6.5.9&lt;/a&gt; | | 411 |必要な長さ| &lt;a href=&quot;#section-6.5.10&quot;&gt;セクション6.5.10&lt;/a&gt; | | 413 |ペイロードが大きすぎます|&lt;a href=&quot;#section-6.5.11&quot;&gt;セクション6.5.11&lt;/a&gt; | | 414 | URIが長すぎます| &lt;a href=&quot;#section-6.5.12&quot;&gt;セクション6.5.12&lt;/a&gt; | | 415 |サポートされていないメディアタイプ| &lt;a href=&quot;#section-6.5.13&quot;&gt;セクション6.5.13&lt;/a&gt; | | 417 |期待はずれ| &lt;a href=&quot;#section-6.5.14&quot;&gt;セクション6.5.14&lt;/a&gt; | | 426 |アップグレードが必要です| &lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt; | | 500 |内部サーバーエラー| &lt;a href=&quot;#section-6.6.1&quot;&gt;セクション6.6.1&lt;/a&gt; | | 501 |実装されていません| &lt;a href=&quot;#section-6.6.2&quot;&gt;セクション6.6.2&lt;/a&gt; | | 502 |悪いゲートウェイ| &lt;a href=&quot;#section-6.6.3&quot;&gt;セクション6.6.3&lt;/a&gt; | | 503 |サービスを利用できません| &lt;a href=&quot;#section-6.6.4&quot;&gt;セクション6.6.4&lt;/a&gt; | | 504 |ゲートウェイタイムアウト| &lt;a href=&quot;#section-6.6.5&quot;&gt;セクション6.6.5&lt;/a&gt; | | 505 | サポートされていないHTTPバージョン| &lt;a href=&quot;#section-6.6.6&quot;&gt;セクション6.6.6&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">下記のステータスコードは、本明細書で定義されている &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;[RFC7232]のセクション4&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;[RFC7233]のセクション4&lt;/a&gt;、および&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;[RFC7235]のセクション3&lt;/a&gt;。ここに記載されている理由フレーズは推奨事項にすぎません。プロトコルに影響を与えることなく、ローカルの同等のものに置き換えることができます。デフォルトでキャッシュ可能として定義されているステータスコード（たとえば、この仕様では200、203、204、206、300、301、404、405、410、414、および501）を持つ応答は、ヒューリスティックな有効期限のあるキャッシュで再利用できます。それ以外の場合は、メソッド定義または明示的なキャッシュ制御[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;];他のすべてのステータスコードは、デフォルトではキャッシュできません。 + ------ + ------------------------------- + ---------- ---------------- + |コード|理由フレーズ|で定義されています... | + ------ + ------------------------------- + ---------- ---------------- + | 100 |続ける| &lt;a href=&quot;#section-6.2.1&quot;&gt;セクション6.2.1&lt;/a&gt; | | 101 |スイッチングプロトコル| &lt;a href=&quot;#section-6.2.2&quot;&gt;セクション6.2.2&lt;/a&gt; | | 200 | OK | &lt;a href=&quot;#section-6.3.1&quot;&gt;セクション6.3.1&lt;/a&gt; | | 201 |作成されました| &lt;a href=&quot;#section-6.3.2&quot;&gt;セクション6.3.2&lt;/a&gt; | | 202 |受け入れられる| &lt;a href=&quot;#section-6.3.3&quot;&gt;セクション6.3.3&lt;/a&gt; | | 203 |信頼できない情報| &lt;a href=&quot;#section-6.3.4&quot;&gt;セクション6.3.4&lt;/a&gt; | | 204 |コンテンツなし| &lt;a href=&quot;#section-6.3.5&quot;&gt;セクション6.3.5&lt;/a&gt; | | 205 |コンテンツをリセット| &lt;a href=&quot;#section-6.3.6&quot;&gt;セクション6.3.6&lt;/a&gt; | | 206 |部分的なコンテンツ| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;[RFC7233]のセクション4.1&lt;/a&gt; | | 300 |複数の選択肢| &lt;a href=&quot;#section-6.4.1&quot;&gt;セクション6.4.1&lt;/a&gt; | | 301 |永久に移動しました| &lt;a href=&quot;#section-6.4.2&quot;&gt;セクション6.4.2&lt;/a&gt; | | 302 |見つかった| &lt;a href=&quot;#section-6.4.3&quot;&gt;セクション6.4.3&lt;/a&gt; | | 303 |その他を見る| &lt;a href=&quot;#section-6.4.4&quot;&gt;セクション6.4.4&lt;/a&gt; | | 304 |変更されていません| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]のセクション4.1&lt;/a&gt; | | 305 |プロキシを使用|&lt;a href=&quot;#section-6.4.5&quot;&gt;セクション6.4.5&lt;/a&gt; | | 307 |一時的なリダイレクト| &lt;a href=&quot;#section-6.4.7&quot;&gt;セクション6.4.7&lt;/a&gt; | | 400 |悪い要求| &lt;a href=&quot;#section-6.5.1&quot;&gt;セクション6.5.1&lt;/a&gt; | | 401 |無許可| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;[RFC7235]のセクション3.1&lt;/a&gt; | | 402 |お支払いが必要です| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | 403 |禁じられた| &lt;a href=&quot;#section-6.5.3&quot;&gt;セクション6.5.3&lt;/a&gt; | | 404 |見つかりません| &lt;a href=&quot;#section-6.5.4&quot;&gt;セクション6.5.4&lt;/a&gt; | | 405 |メソッドは許可されていません| &lt;a href=&quot;#section-6.5.5&quot;&gt;セクション6.5.5&lt;/a&gt; | | 406 |受け入れられない| &lt;a href=&quot;#section-6.5.6&quot;&gt;セクション6.5.6&lt;/a&gt; | | 407 |プロキシ認証が必要です| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;[RFC7235]のセクション3.2&lt;/a&gt; | | 408 |リクエストのタイムアウト| &lt;a href=&quot;#section-6.5.7&quot;&gt;セクション6.5.7&lt;/a&gt; | | 409 |紛争| &lt;a href=&quot;#section-6.5.8&quot;&gt;セクション6.5.8&lt;/a&gt; | | 410 |なくなった| &lt;a href=&quot;#section-6.5.9&quot;&gt;セクション6.5.9&lt;/a&gt; | | 411 |必要な長さ| &lt;a href=&quot;#section-6.5.10&quot;&gt;セクション6.5.10&lt;/a&gt; | | 412 |前提条件が失敗しました| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;[RFC7232]のセクション4.2&lt;/a&gt; | | 413 |ペイロードが大きすぎます| &lt;a href=&quot;#section-6.5.11&quot;&gt;セクション6.5.11&lt;/a&gt; | | 414 | URIが長すぎます| &lt;a href=&quot;#section-6.5.12&quot;&gt;セクション6.5.12&lt;/a&gt; | | 415 |サポートされていないメディアタイプ|&lt;a href=&quot;#section-6.5.13&quot;&gt;セクション6.5.13&lt;/a&gt; | | 416 |範囲が満足できません| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;[RFC7233]のセクション4.4&lt;/a&gt; | | 417 |期待はずれ| &lt;a href=&quot;#section-6.5.14&quot;&gt;セクション6.5.14&lt;/a&gt; | | 426 |アップグレードが必要です| &lt;a href=&quot;#section-6.5.15&quot;&gt;セクション6.5.15&lt;/a&gt; | | 500 |内部サーバーエラー| &lt;a href=&quot;#section-6.6.1&quot;&gt;セクション6.6.1&lt;/a&gt; | | 501 |実装されていません| &lt;a href=&quot;#section-6.6.2&quot;&gt;セクション6.6.2&lt;/a&gt; | | 502 |悪いゲートウェイ| &lt;a href=&quot;#section-6.6.3&quot;&gt;セクション6.6.3&lt;/a&gt; | | 503 |サービスを利用できません| &lt;a href=&quot;#section-6.6.4&quot;&gt;セクション6.6.4&lt;/a&gt; | | 504 |ゲートウェイタイムアウト| &lt;a href=&quot;#section-6.6.5&quot;&gt;セクション6.6.5&lt;/a&gt; | | 505 | サポートされていないHTTPバージョン| &lt;a href=&quot;#section-6.6.6&quot;&gt;セクション6.6.6&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- +このリストは完全ではないことに注意してください-他の仕様で定義されている拡張ステータスコードは含まれていません。ステータスコードの完全なリストは、IANAによって管理されています。詳細については、&lt;a href=&quot;#section-8.2&quot;&gt;セクション8.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">status-code 要素は、リクエストを理解して満足させようとした結果を示す 3 桁の整数コードです。HTTP ステータスコードは拡張可能です。HTTP クライアントは登録されたすべてのステータスコードの意味を理解する必要はありませんが、そのような理解は明らかに望ましいです。しかしながら、クライアントは、最初の桁で示されるようなステータスコードのクラスを理解しなければならず[MUST]、認識されていないステータスコードを、受信者が認識されていないステータスコードを持つ応答をキャッシュしてはならない[MUST NOT]という例外を除いて、そのクラスのx00ステータスコードと同等であるとして扱わなければならない。例えば、認識されていないステータスコード471をクライアン トが受け取る場合、クライアントはリクエストに何か問題があったと仮定して、その 応答を400(Bad Request)ステータスコードを受け取ったかのように扱うことができる。応答メッセージは通常、ステータスを説明する表現を含む。ステータスコードの最初の桁は応答のクラスを定義します。最後の2桁は分類の役割を持ちません。最初の桁には5つの値がある。1xx (Informational):リクエストを受信しました。2xx (成功):要求は正常に受信され、理解され、受け入れられました。3xx (リダイレクション):リクエストを完了するためにさらなるアクションが必要です。4xx (クライアントエラー):リクエストは間違った構文を含んでいるか、実行できません。5xx (サーバーエラー):サーバーは一見有効なリクエストの実行に失敗しました。</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">文字列には、セミコロンで区切られた以下のビルディングブロックをいくつでも含めることができます。</target>
        </trans-unit>
        <trans-unit id="4d9a1a47b58bb09a0a513706e6f21fd9ec5db53c" translate="yes" xml:space="preserve">
          <source>The string following &lt;code&gt;filename&lt;/code&gt; should always be put into quotes; but, for compatibility reasons, many browsers try to parse unquoted names that contain spaces.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 続く文字列は常に引用符で囲む必要があります。ただし、互換性の理由から、多くのブラウザは、スペースを含む引用符で囲まれていない名前を解析しようとします。</target>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">多くの場合、&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;の成功結果は &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; ではなく、&lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; （またはリソースが初めてアップロードされたときに&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; ）になります。</target>
        </trans-unit>
        <trans-unit id="7f017eb4d89aedd499f70986d2b736c586f7c389" translate="yes" xml:space="preserve">
          <source>The syntax for these headers is the following:</source>
          <target state="translated">これらのヘッダの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; ヘッダーの構文を使用すると、サーバーメトリック名のみ、値付きのメトリック、値と説明付きのメトリック、およびメトリック付きの説明など、さまざまな方法でメトリックを通信できます。</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">Slugヘッダーの構文は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]のセクション2.1で&lt;/a&gt;定義されている拡張BNF構文を使用して定義されています。LWS = &amp;lt; &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]のセクション2.2で&lt;/a&gt;定義されています &amp;gt; slugtext =％x20-7E | LWS Slug = &quot;Slug&quot; &quot;：&quot; * slugtextフィールド値は、含まれる文字シーケンスのUTF-8エンコーディングのパーセントエンコードされた値です（ パーセントエンコーディングの定義については、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986]のセクション2.1を&lt;/a&gt;参照してください。&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;]は、UTF-8エンコーディングの定義です）。実装上の注意：文字シーケンスからフィールド値を生成するには、まずUTF-8エンコードを使用してエンコードし、次に％20-24および％26-7Eの範囲外のすべてのオクテットをパーセントエンコードを使用してエンコードします（％25はASCIIエンコードです） 「％」、つまりエスケープする必要があります）。フィールド値を消費するには、最初にパーセントエンコーディングを逆にし、次に結果のオクテットシーケンスをUTF-8デコードプロセスで実行します。</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">リソースに対してロック要求があった場合の動作を以下に示します。 True=ロックが許可されている。False=ロックは許可されてはならない。*=プリンシパルが同じロックを2回要求することは違法です。リソースの現在のロック状態は一番左の列に、ロック要求は最初の行に記載されています。行と列の交点がロック要求の結果を表します。例えば、リソースに共有ロックが保持されており、排他的ロックが要求された場合、テーブルのエントリは &quot;false &quot;であり、ロックを許可してはならないことを示します。</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれ、その性質はさらに定義されていません。ドキュメント、写真、その他の何でもかまいません。各リソースは、HTTP全体でリソースの識別に使用されるUniform Resource Identifier（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）によって識別されます。</target>
        </trans-unit>
        <trans-unit id="a332edd44b965848f63f0bd63edb5a5baade7db6" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, whose nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれ、その性質はこれ以上定義されません。ドキュメント、写真、その他何でもかまいません。各リソースは、リソースを識別するためにHTTP全体で使用されるUniform Resource Identifier（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）によって識別されます。</target>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">HTTPリクエストのターゲットは「リソース」と呼ばれます。 HTTPはリソースの性質を制限しません。リソースとの対話に使用される可能性のあるインターフェースを定義するだけです。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]のセクション2.7で&lt;/a&gt;説明されているように、各リソースはUniform Resource Identifier（URI）によって識別され ます。クライアントがHTTP / 1.1要求メッセージを作成するとき、（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]のセクション5.3）で&lt;/a&gt;定義されているように、さまざまな形式の1つでターゲットURIを送信します。リクエストが受信されると、サーバーはターゲットリソースの有効なリクエストURIを再構築します（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]のセクション5.5&lt;/a&gt;）。 HTTPの設計目標の1つは、リソースの識別を要求のセマンティクスから分離することです。これは、要求のセマンティクスを要求メソッドに付与することで可能になります（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）といくつかのリクエスト変更ヘッダーフィールド（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）。&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt;で説明されているように、メソッドのセマンティクスとURI自体が意味するセマンティクスの間に矛盾がある場合、メソッドのセマンティクスが優先されます。</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">エラーメッセージのテキストは以下のようなものになります。</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">オブジェクトがプロキシキャッシュに保存されている時間を秒単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">ブラウザが覚えておくべき時間は、秒単位で、サイトがHTTPSを使ってアクセスするためだけのものであることを示しています。</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">このサイトは、定義されたキーのいずれかを使用してのみアクセスできることをブラウザが覚えておくべき時間(秒単位)です。</target>
        </trans-unit>
        <trans-unit id="4110d2a33eaaff440bedc1360a1f4ce9d0cb92f4" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the object has been in a proxy cache.</source>
          <target state="translated">オブジェクトがプロキシキャッシュに保存されている時間を秒単位で表示します。</target>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">ドキュメントの合計サイズ（不明 &lt;code&gt;'*'&lt;/code&gt; 場合は「*」）。</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">メッセージのtransfer-lengthは、メッセージに表示されるメッセージ本体の長さです。つまり、転送コーディングが適用された後です。メッセージ本文がメッセージに含まれている場合、その本文の転送長は、次のいずれかによって（優先順で）決定されます。 1xx、204、および304応答と、HEAD要求への応答）は、メッセージに存在するエンティティヘッダーフィールドに関係なく、常にヘッダーフィールドの後の最初の空行で終了します。 2. Transfer-Encodingヘッダーフィールド（&lt;a href=&quot;#section-14.41&quot;&gt;セクション14.41&lt;/a&gt;）が存在し、 &quot;identity&quot;以外の値がある場合、 &quot;chunked&quot;を使用してtransfer-lengthが定義されます。転送コーディング（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）、ただし、接続を閉じることによってメッセージが終了しない限り。 3. Content-Lengthヘッダーフィールドの場合（&lt;a href=&quot;#section-14.13&quot;&gt;セクション14.13&lt;/a&gt;）が存在する場合、OCTETの10進数値はエンティティ長と転送長の両方を表します。これら2つの長さが異なる場合（つまり、Transfer-Encodingヘッダーフィールドが存在する場合）、Content-Lengthヘッダーフィールドを送信してはなりません（MUST NOT）。 Transfer-EncodingヘッダーフィールドとContent-Lengthヘッダーフィールドの両方を含むメッセージを受信した場合、後者は無視する必要があります。 4.メッセージがメディアタイプ「multipart / byteranges」を使用し、転送長が特に指定されていない場合、この自己制限メディアタイプが転送長を定義します。このメディアタイプは、送信者が受信者が付与できることを知らない限り、使用しないでください。 1からの複数のバイト範囲指定子を持つRangeヘッダーのリクエスト内の存在。1クライアントは、リエントがmultipart / byteranges応答を解析できることを意味します。範囲ヘッダーは、マルチパート/バイト範囲を理解しない1.0プロキシによって転送される可能性があります。この場合、サーバーはこのセクションの項目1、3、または5で定義されたメソッドを使用してメッセージを区切る必要があります。 5.サーバーが接続を閉じる。 （接続を閉じることは、サーバーが応答を返す可能性を残さないため、要求本文の終わりを示すために使用することはできません。）HTTP / 1.0アプリケーションとの互換性のために、メッセージ本体を含むHTTP / 1.1要求はサーバーがHTTP / 1.1に準拠していることがわかっている場合を除き、有効なContent-Lengthヘッダーフィールドを含めます。リクエストにメッセージ本文が含まれ、Content-Lengthが指定されていない場合、サーバーは、メッセージの長さを判別できない場合は400（不正な要求）で応答する必要があり、有効なContent-Lengthの受信を要求する場合は411（必要な長さ）で応答する必要があります。エンティティを受信するすべてのHTTP / 1.1アプリケーションは、「チャンクされた」転送コーディング（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）。これにより、メッセージの長さが事前に決定できない場合に、このメカニズムをメッセージに使用できます。メッセージには、Content-Lengthヘッダーフィールドと非ID転送コーディングの両方を含めることはできません。メッセージに非アイデンティティ転送コーディングが含まれている場合、Content-Lengthは無視する必要があります。メッセージ本文が許可されているメッセージでContent-Lengthを指定する場合、そのフィールド値はメッセージ本文のOCTETの数と正確に一致する必要があります。HTTP / 1.1ユーザーエージェントは、無効な長さが受信および検出されたときにユーザーに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">2つのURNが対応しているのは</target>
        </trans-unit>
        <trans-unit id="4126df10224ce6149afe3c692dbb573c02f4b6df" translate="yes" xml:space="preserve">
          <source>The type of the network error may be one of the following pre-defined values from the specification, but browsers can add and send their own error types:</source>
          <target state="translated">ネットワーク・エラーのタイプは、仕様から以下のようにあらかじめ定義された値のいずれかになりますが、ブラウザは独自のエラー・タイプを追加して送信することができます。</target>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">範囲の単位はバイトです。</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">範囲が指定される単位。これは通常 &lt;code&gt;bytes&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5af5f6da44581e8c2be8542aa108c546975539ef" translate="yes" xml:space="preserve">
          <source>The user agent successfully received a response, but it had a &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5&quot;&gt;4xx&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.6&quot;&gt;5xx&lt;/a&gt; status code</source>
          <target state="translated">ユーザーエージェントは正常に応答を受信しましたが、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5&quot;&gt;4xx&lt;/a&gt;または&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.6&quot;&gt;5xxの&lt;/a&gt;ステータスコードがありました</target>
        </trans-unit>
        <trans-unit id="d38ef4967199ab3d3fb64a4af1f2610ad2fb5dab" translate="yes" xml:space="preserve">
          <source>The user has not specified a preference about tracking.</source>
          <target state="translated">ユーザーは、トラッキングに関する設定を指定していません。</target>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">ユーザーは与えられた時間内にあまりにも多くのリクエストを送信しました(「レート制限」)。</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">ユーザーは、ターゲットサイトで追跡されたくないことを希望しています。</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">ユーザーは、ターゲットサイトでのトラッキングを許可することを好みます。</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">ユーザーは、政府によって検閲されたウェブページなどの違法なリソースを要求します。</target>
        </trans-unit>
        <trans-unit id="c2570aabe29d82468d07516df77cc2dacb787ebd" translate="yes" xml:space="preserve">
          <source>The user's DNS server is unreachable</source>
          <target state="translated">ユーザーのDNSサーバーにアクセスできない</target>
        </trans-unit>
        <trans-unit id="bde98a07efaff68f2ccfa98c53613a6d16bf7576" translate="yes" xml:space="preserve">
          <source>The user's DNS server responded but was unable to resolve an IP address for the requested URI.</source>
          <target state="translated">ユーザーのDNSサーバーは応答したが、要求されたURIのIPアドレスを解決できなかった。</target>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">ユーザーのDNT設定は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt;プロパティを使用してJavaScriptから読み取ることもできます。</target>
        </trans-unit>
        <trans-unit id="ed64b46fa75921957cada3be294011ac523b15f9" translate="yes" xml:space="preserve">
          <source>The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.</source>
          <target state="translated">ユーザーエージェントは、政府によって検閲されたウェブページなど、法的に提供できないリソースを要求しました。</target>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">ユーザー名とパスワードはコロンで結合されます（ &lt;code&gt;aladdin:opensesame&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36e6a72462ef3ce7f1b58a51225794379cf53bdb" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報のあるリクエストでは、特別なセマンティクスのないリテラルヘッダー名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。</target>
        </trans-unit>
        <trans-unit id="26cfba7c951a6edda6e1e994a33a34814751c61e" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics. Note that the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報のあるリクエストでは、特別なセマンティクスのないリテラルヘッダー名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。&lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;ヘッダーはワイルドカード化できず、常に明示的にリストする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="854a2275bb7da001005de950b8d6724a4e032a0a" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal method name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="translated">値「 &lt;code&gt;*&lt;/code&gt; 」は、資格情報のないリクエスト（&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;またはHTTP認証情報のないリクエスト）の特別なワイルドカード値としてのみカウントされます。認証情報を含むリクエストでは、特別なセマンティクスのないリテラルメソッド名「 &lt;code&gt;*&lt;/code&gt; 」として扱われます。</target>
        </trans-unit>
        <trans-unit id="9f2ea3fa86a0e7cfbb653b4bde310cf9741eba62" translate="yes" xml:space="preserve">
          <source>The value is a Boolean Structured Header.</source>
          <target state="translated">値はブール型構造化ヘッダです。</target>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">プロパティの値は常に（整形式の）XMLフラグメントです。 XMLは、豊富なスキーマ定義をサポートする柔軟で自己記述的な構造化データ形式であり、複数の文字セットをサポートするために選択されました。 XMLの自己記述的な性質により、要素を追加することにより、プロパティの値を拡張できます。元のスキーマで指定されたデータがまだあり、理解できない要素を無視する必要があるため、拡張機能に遭遇してもクライアントは壊れません。 XMLの複数の文字セットのサポートにより、人間が読めるプロパティをエンコードして、ユーザーが使い慣れた文字セットで読み取ることができます。 &quot;xml：lang&quot;属性を使用した、複数の人間の言語に対するXMLのサポート同じ文字セットが複数の人間の言語で使用されているケースを処理します。 xml：langスコープは再帰的であることに注意してください。したがって、プロパティ名要素を含む要素のxml：lang属性は、よりローカルなスコープの属性によってオーバーライドされない限り、プロパティ値に適用されます。プロパティは1つの言語で1つの値のみを持つことに注意してください（または言語は未定義のままにすることができます）。プロパティには、異なる言語の複数の値や複数の言語の単一の値はありません。プロパティは常に、「プロパティ名要素」と呼ばれるプロパティ名で構成されるXML要素で表されます。最も単純な例は空のプロパティで、これは存在しないプロパティとは異なります：&amp;lt;R：title xmlns：R = &quot;http://www.example.com/ns/&quot;&amp;gt; &amp;lt;/ R：title&amp;gt;プロパティの値は、プロパティ名要素内に表示されます。値は、テキストのみのコンテンツと混合コンテンツの両方を含む、あらゆる種類の整形式のXMLコンテンツです。サーバーは、次のXML情報アイテムを保存する必要があります（[&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ]）無効なプロパティの保存と送信：プロパティ名の場合要素情報アイテム自体：[名前空間名] [ローカル名] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ]「xml：lang」という名前またはそのようなスコープ内の任意の属性[ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;子&lt;/a&gt; ]タイプ要素または文字のプロパティ値のすべての要素情報項目：[名前空間名] [ローカル名] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;子&lt;/a&gt;]要素または文字の型プロパティ値の属性情報項目：[名前空間名] [ローカル名] [正規化値]プロパティ値の文字情報項目：[文字コード]一部のXMLボキャブラリで接頭辞が使用されているため（XPath例えばXMLスキーマは、）、サーバは価値の情報項目のために、保存すべき：[ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;プレフィックス&lt;/a&gt; ] XML情報セットは、MAY、上記に記載されていない属性は、サーバによって保存されますが、クライアントはそれらが保存されている当てにしてはいけません。上記のルールは、特に定義されていない限り、デフォルトでライブプロパティにも適用されます。サーバーは、XML属性xml：spaceが存在する場合は無視し、空白処理を変更するために決して使用してはなりません（MUST）。プロパティ値の空白は重要です。</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">値 &lt;code&gt;*&lt;/code&gt; （すべての起点に対して有効）または &lt;code&gt;'none'&lt;/code&gt; （すべての起点に対して無効）は単独でのみ使用できますが、 &lt;code&gt;'self'&lt;/code&gt; および &lt;code&gt;'src'&lt;/code&gt; は1つ以上の起点で使用できます。</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">値 &lt;code&gt;*&lt;/code&gt; （すべての起点に対して有効）または &lt;code&gt;'none'&lt;/code&gt; （すべての起点に対して無効）は単独でのみ使用できますが、 &lt;code&gt;'self'&lt;/code&gt; は1つ以上の起点で使用できます。</target>
        </trans-unit>
        <trans-unit id="41c9624006fed0c69222297d2493c20e75ba3334" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;SameSite&lt;/code&gt; attribute are case-insensitive.</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 属性の値では、大文字と小文字は区別されません。</target>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">バージョン番号は関係ありません。これらをもとに資料を推測することは避けてください。</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">彼らが従うHTTPプロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">HTTP プロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">など、使用したプロトコルのバージョン。</target>
        </trans-unit>
        <trans-unit id="be45aceeb5134141e742c9ee174ea085d4d54965" translate="yes" xml:space="preserve">
          <source>The warning appears because any cookie that requests &lt;code&gt;SameSite=None&lt;/code&gt; but is not marked &lt;code&gt;Secure&lt;/code&gt; will be rejected.</source>
          <target state="translated">&lt;code&gt;SameSite=None&lt;/code&gt; を要求するが、 &lt;code&gt;Secure&lt;/code&gt; とマークされていないCookieはすべて拒否されるため、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="a0ee5181aca77b1eb5d9d19b58966bc71984796c" translate="yes" xml:space="preserve">
          <source>The warning appears because the &lt;code&gt;SameSite&lt;/code&gt; policy for a cookie has not specified explicitly:</source>
          <target state="translated">Cookieの &lt;code&gt;SameSite&lt;/code&gt; ポリシーが明示的に指定されていないため、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">警告文には、人間のユーザに提示するか、ログに記録される任意の情報を含めることができる。この警告を受信したシステムは、ユーザに警告を提示する以外に、いかなる自動化された行動もとってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">警告文には、人間のユーザに提示される任意の情報や、ログに記録される情報を含めることができます。この警告を受けたシステムは、自動化された行動をとってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">ウェブでは、悪用されるとプライバシーやセキュリティ上のリスクがある機能やAPIを提供しています。場合によっては、そのような機能がウェブサイトで使用される方法を厳密に制限したい場合があります。ウェブサイト内の特定のオリジンやフレームに対して機能の有効化/無効化を可能にするポリシー制御機能があります。利用可能な場合には、この機能はパーミッション API と統合されているか、または機能固有のメカニズムを使用して、その機能が利用可能かどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">最新の仕様で言及されているワイルドカード値(*)は、ブラウザではまだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;HTML5ボイラープレートプロジェクトは、&lt;/a&gt;上の例であり&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;、他の1つのドメインにリダイレクトするようにApacheサーバーを構成する方法を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 要素に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性を含めます。</target>
        </trans-unit>
        <trans-unit id="5b298470c1b05d975bfb02d7b35971fafe965683" translate="yes" xml:space="preserve">
          <source>Then on subsequent requests the client might send &lt;code&gt;DPR&lt;/code&gt; header back:</source>
          <target state="translated">その後のリクエストで、クライアントは &lt;code&gt;DPR&lt;/code&gt; ヘッダーを送り返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="cacc625cf3f9a66a41f951c41016e7992de78fa8" translate="yes" xml:space="preserve">
          <source>Then on subsequent requests the client might send &lt;code&gt;Device-Memory&lt;/code&gt; header back:</source>
          <target state="translated">その後のリクエストで、クライアントは &lt;code&gt;Device-Memory&lt;/code&gt; ヘッダーを送り返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">そうすれば、クライアントはJSONのバージョンがその特定のURLで利用可能であることを覚えていて、次回そのドキュメントをリクエストするときにコンテンツのネゴシエーションをスキップすることができます。</target>
        </trans-unit>
        <trans-unit id="ccd8b24095654e9f5577f70574da438aa878682b" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you determine is appropriate.</source>
          <target state="translated">その後、レポートを受信するためにサーバーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">その後、レポートを受信するためにサーバーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="303618442946db88c6e44665ba0c19fde299ff1f" translate="yes" xml:space="preserve">
          <source>Then, with every subsequent request to the server, the browser sends back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">その後、サーバーへの後続のすべての要求で、ブラウザーは&lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して以前に保存されたすべてのCookieをサーバーに送り返します。</target>
        </trans-unit>
        <trans-unit id="02072bbfa0f86f96f0652069e08e342de2f1a9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to ensure that cookies are sent securely and are not accessed by unintended parties or scripts: the &lt;code&gt;Secure&lt;/code&gt; attribute and the &lt;code&gt;HttpOnly&lt;/code&gt; attribute.</source>
          <target state="translated">：クッキーが安全に送信され、意図しないパーティーやスクリプトによってアクセスされていないことを確認する方法はいくつかあり &lt;code&gt;Secure&lt;/code&gt; 属性と &lt;code&gt;HttpOnly&lt;/code&gt; の属性が。</target>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">要求メッセージと応答メッセージの両方に一般的に適用できるヘッダーフィールドがいくつかありますが、転送されるエンティティには適用されません。これらのヘッダーフィールドは、送信されるメッセージにのみ適用されます。 general-header = Cache-Control; &lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt; |接続; &lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt; |日付; &lt;a href=&quot;#section-14.18&quot;&gt;セクション14.18&lt;/a&gt; |プラグマ; &lt;a href=&quot;#section-14.32&quot;&gt;セクション14.32&lt;/a&gt; |トレーラー; &lt;a href=&quot;#section-14.40&quot;&gt;セクション14.40&lt;/a&gt; | Transfer-Encoding; &lt;a href=&quot;#section-14.41&quot;&gt;セクション14.41&lt;/a&gt; |アップグレード;&lt;a href=&quot;#section-14.42&quot;&gt;セクション14.42&lt;/a&gt; |経由; &lt;a href=&quot;#section-14.45&quot;&gt;セクション14.45&lt;/a&gt; |警告; &lt;a href=&quot;#section-14.46&quot;&gt;セクション14.46&lt;/a&gt; General-Headerフィールド名は、プロトコルバージョンの変更と組み合わせた場合にのみ確実に拡張できます。ただし、通信のすべての当事者がそれらを一般ヘッダーフィールドであると認識する場合、新規または実験的なヘッダーフィールドに一般ヘッダーフィールドのセマンティクスが与えられることがあります。認識されないヘッダーフィールドは、エンティティヘッダーフィールドとして扱われます。</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">稀にこんなことが起こることがあります。</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">HTTP認証フレームワークには、新しい認証スキームが機能する方法に制約を課す特定の側面があります。oHTTP認証はステートレスであると推定されます。要求の認証に必要なすべての情報は、依存するのではなく、要求で提供する必要があります。サーバーは以前のリクエストを記憶しています。基になる接続に基づく、またはバインドされている認証は、この仕様の範囲外であり、認証されたユーザー以外の者が接続を使用できないようにするための手順を講じない限り、本質的に欠陥があります（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]のセクション2.3を&lt;/a&gt;参照） 。 o認証パラメータ「レルム」は、&lt;a href=&quot;#section-2.2&quot;&gt;セクション2.2で&lt;/a&gt;説明されている保護スペースを定義するために予約されています。。新しいスキームは、その定義と互換性のない方法でそれを使用してはなりません。 o「token68」表記は、既存の認証スキームとの互換性のために導入され、チャレンジまたは資格情報ごとに1回のみ使用できます。したがって、新しいスキーマでは代わりにauth-param構文を使用する必要があります。そうしないと、将来の拡張が不可能になるためです。 oチャレンジと資格情報の解析は、この仕様で定義されており、新しい認証スキームで変更することはできません。 auth-param構文を使用する場合、すべてのパラメーターはトークンと引用符付き文字列の両方の構文をサポートする必要があり、構文制約は解析（つまり引用符付き文字列処理）後にフィールド値に定義する必要があります。これは、受信者がすべての認証スキームに適用される汎用パーサーを使用できるようにするために必要です。注：「レルム」パラメーターの値の構文がquoted-stringに制限されているという事実は、新しいパラメーターに対して繰り返さないようにするための設計上の選択として不適切でした。 o新しいスキームの定義は、未知の拡張パラメータの扱いを定義する必要があります。一般に、「無視する必要がある」ルールは、「理解する必要がある」ルールよりも望ましいです。そうしないと、レガシー受信者が存在する場合に新しいパラメーターを導入することが困難になるためです。さらに、新しいパラメーターを定義するためのポリシー（「仕様の更新」や「このレジストリーの使用」など）を記述することは良いことです。o認証スキームは、それらがオリジンサーバー認証（つまり、WWW-Authenticateを使用）、および/またはプロキシ認証（つまり、Proxy-Authenticateを使用）で使用可能かどうかを文書化する必要があります。 o Authorizationヘッダーフィールドに含まれる認証情報はユーザーエージェントに固有であるため、HTTPキャッシュには「プライベート」のCache-Control応答ディレクティブ（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;[RFC7234]のセクション5.2.2.6&lt;/a&gt;）、それらが現れるリクエストの範囲内。したがって、Authorizationヘッダーフィールドに資格情報を保持しないことを選択する新しい認証スキーム（たとえば、新しく定義されたヘッダーフィールドを使用）は、いずれかのCache-Controlリクエストディレクティブ（たとえば、「no-ストア」、&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;[RFC7234]のセクション5.2.1.5&lt;/a&gt;）または応答ディレクティブ（「プライベート」など）。</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;正規の&lt;/em&gt; Webサイトを選択する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">レンダリングエンジンには大きく分けて5つのエンジンがあります。Trident、Gecko、Presto、Blink、WebKitです。レンダリングエンジン名をスニッフするのが一般的なため、多くのユーザーエージェントが他のレンダリングエンジン名を追加して検出のトリガーにしています。そのため、レンダリングエンジンを検出する際には、誤検出を誘発しないように注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">使用に関する法的要件や技術的要件はありませんが、&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、Webアプリケーションが個々のユーザーのトラッキングまたはクロスサイトユーザートラッキングを無効にする必要があることを通知できます。詳細については、&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;ヘッダーを参照してください。</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">多数のリクエストヘッダが利用可能です。それらはいくつかのグループに分けることができます。</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">レスポンスヘッダは多数用意されています。これらはいくつかのグループに分けることができます。</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">リダイレクトには多くのユースケースがありますが、リダイレクトごとにパフォーマンスに影響を与えるため、その使用は最小限に抑えるべきです。</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">キャッシュにはいくつかの種類があります。これらは、プライベートキャッシュと共有キャッシュの2つの主なカテゴリに分類できます。&lt;em&gt;共有キャッシュは&lt;/em&gt;キャッシュされ、複数のユーザーによる再利用のための店舗応答います。&lt;em&gt;プライベートキャッシュは&lt;/em&gt;、単一のユーザーに捧げられています。このページでは、主にブラウザーとプロキシキャッシュについて説明しますが、WebサイトとWebアプリケーションの信頼性、パフォーマンス、スケーリングを向上させるために、ゲートウェイキャッシュ、CDN、リバースプロキシキャッシュ、ロードバランサーもWebサーバーに導入されています。</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">ユーザーエクスペリエンスに悪影響を与える可能性のある機能を表現するために設計されたポリシー制御機能がいくつかあります。これらの機能には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">良いパフォーマンスとユーザーエクスペリエンスを提供するためのベストプラクティスを実施するために、いくつかのポリシー制御機能があります。</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">リダイレクトにはいくつかの種類があり、永久的なもの、一時的なもの、特別なものの3つに分類されます。</target>
        </trans-unit>
        <trans-unit id="8b2d63fe70a304442a6a486676e591c0916f939e" translate="yes" xml:space="preserve">
          <source>There are several types of redirects, sorted into three categories:</source>
          <target state="translated">リダイレクトにはいくつかの種類があり、3つのカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; には、次の3つのディレクティブがあります。</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">範囲リクエストを扱う際には、3つの関連するステータスがあります。</target>
        </trans-unit>
        <trans-unit id="0fff28c9c934766aefa1ed8d526b79ea9e2c24ef" translate="yes" xml:space="preserve">
          <source>There are too many &lt;a href=&quot;../cookies&quot;&gt;Cookies&lt;/a&gt; sent in the request</source>
          <target state="translated">リクエストで送信された&lt;a href=&quot;../cookies&quot;&gt;Cookie&lt;/a&gt;が多すぎます</target>
        </trans-unit>
        <trans-unit id="ce50cfd249603fdf3debd56f0ffcb691991a174f" translate="yes" xml:space="preserve">
          <source>There are two classes of type: &lt;strong&gt;discrete&lt;/strong&gt; and &lt;strong&gt;multipart&lt;/strong&gt;. Discrete types are types which represent a single file or medium, such as a single text or music file, or a single video. A multipart type is one which represents a document that's comprised of multiple component parts, each of which may have its own individual MIME type; or, a multipart type may encapsulate multiple files being sent together in one transaction. For example, multipart MIME types are used when attaching multiple files to an email.</source>
          <target state="translated">タイプには、&lt;strong&gt;離散&lt;/strong&gt;と&lt;strong&gt;マルチパートの&lt;/strong&gt;2つのクラスがあります。ディスクリートタイプは、単一のテキストや音楽ファイル、または単一のビデオなど、単一のファイルまたはメディアを表すタイプです。マルチパートタイプは、複数のコンポーネントパーツで構成されるドキュメントを表すタイプであり、各コンポーネントには独自のMIMEタイプがあります。または、マルチパートタイプは、1つのトランザクションで一緒に送信される複数のファイルをカプセル化する場合があります。たとえば、マルチパートMIMEタイプは、複数のファイルを電子メールに添付するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">一般的な使用例は2つあります。</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">比較コンテキストで弱いバリデータの使用が許可されているかどうかによって、2 つのエンティティ タグ比較関数があります。 o 強い比較:2 つのエンティティ タグが両方とも弱いものではなく、不透明タグが文字ごとに一致している場合、2 つのエンティティ タグは等価です。以下の例は、エンティティタグのペアのセットの結果と、弱い比較と強い比較関数の両方の結果を示しています。+W/&quot;1&quot; | W/&quot;1&quot; | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない | 一致しない</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">コレクション書き込みロックには2種類あります。コレクションの深さ0の書き込みロックは、コレクションプロパティとその1つのコレクションの内部メンバーURLを保護しますが、メンバーリソースのコンテンツまたはプロパティは保護しません（コレクション自体にエンティティボディがある場合、それらも保護されます）。コレクションに対する深さ無限の書き込みロックは、そのコレクションに対して同じ保護を提供し、すべてのメンバーリソースに対して書き込みロック保護も提供します。他の方法で表現すると、いずれかの種類の書き込みロックは、書き込みロックされたコレクションに新しいリソースを作成するすべての要求、書き込みロックされたコレクションの内部メンバーURLを削除するすべての要求、および任意のセグメント名を変更するすべての要求を保護します内部メンバー。したがって、コレクションの書き込みロックは、次のすべてのアクションを保護します。oコレクションの直接の内部メンバーを削除します。oコレクションから内部メンバーを移動します。o内部メンバーをコレクションに移動します。oMOVEは、コレクション内の内部メンバーの名前を変更します。oCOPYコレクションへの内部メンバー、および新しい内部メンバーを作成するPUTまたはMKCOL要求。個別にロックされている場合は、内部メンバー自体のロックトークンに加えて、コレクションのロックトークンが必要です。さらに、深さ無限ロックは、ロックされたコレクションのすべてのメンバーに対するすべての書き込み操作に影響します。深さ無限ロックでは、ロックのルートによって識別されるリソースが直接ロックされ、そのすべてのメンバーが間接的にロックされます。o深さ無限のロックされたコレクションの子孫として追加された新しいリソースは、間接的にロックされます。 oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）oロックされたコレクションからロック解除されたコレクションに移動された間接的にロックされたリソースは、その後ロック解除されます。 o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）o間接的にロックされたリソースは、ロックされたソースコレクションから深さ無限のロックされたターゲットコレクションに移動されますが、間接的にロックされたままですが、ターゲットコレクションのロックによって保護されます（その後、ターゲットコレクションのロックトークンは、さらに変更する必要があります）。新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）新しいロックと競合する方法で現在ロックされているリソースを識別するメンバーURLを含むコレクションに、深さ無限の書き込みLOCK要求が発行された場合（を参照）&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;、ポイント3）、リクエストは423（ロック済み）ステータスコードで失敗する必要があり、応答には「no-conflicting-lock」前提条件が含まれている必要があります（SHOULD）。ロック要求によってリソースのURLが深さ無限のロックされたコレクションの内部メンバーURLとして追加される場合、新しいリソースはロックによって自動的に保護される必要があります。たとえば、コレクション/ a / b /が書き込みロックされていて、リソース/ cが/ a / b / cに移動された場合、リソース/ a / b / cが書き込みロックに追加されます。</target>
        </trans-unit>
        <trans-unit id="d5dc7184e37e2ac541668d7dc3337de81f5981e3" translate="yes" xml:space="preserve">
          <source>There are two multipart types:</source>
          <target state="translated">マルチパートタイプは2種類あります。</target>
        </trans-unit>
        <trans-unit id="d0970064e3114d24ebea32cf716e29a9559cf977" translate="yes" xml:space="preserve">
          <source>There are two possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; には2つの可能なディレクティブがあります。</target>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">HTTP メッセージにはリクエストとレスポンスの 2 種類があり、それぞれ独自のフォーマットを持っています。</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">プロキシには2つのタイプがあります。&lt;strong&gt;フォワードプロキシ&lt;/strong&gt;（またはトンネル、またはゲートウェイ）と&lt;strong&gt;リバースプロキシ&lt;/strong&gt;（負荷分散、認証、復号化、またはキャッシュのためにサーバーへのアクセスを制御および保護するために使用）です。</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">このリストにWebP（ &lt;code&gt;image/webp&lt;/code&gt; ）を追加することについての議論がありますが、ブラウザーベンダーはそれを受け入れることに慎重です。</target>
        </trans-unit>
        <trans-unit id="973c4945198f89ca852f9330ea8ecbaa87253ef7" translate="yes" xml:space="preserve">
          <source>There is effort from browsers in moving to a stricter default value, namely &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; (see &lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952&lt;/a&gt;), consider using this value (or a stricter one), if possible, when changing the Referrer-Policy.</source>
          <target state="translated">より厳密なデフォルト値、つまり &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; （&lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952を&lt;/a&gt;参照）に移行するためのブラウザーの努力があります。この値（またはより厳密な値）の使用を検討してください。 1）可能であれば、リファラーポリシーを変更するとき。</target>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">このリクエストに送る内容はありませんが、ヘッダは役に立つかもしれません。ユーザーエージェントはこのリソースのキャッシュされたヘッダを新しいもので更新するかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">2つのクライアントのどちらかに迷惑をかけずに対処する方法はありません。しかし、ロストアップデートやレース状態は避けたいものです。予測可能な結果を望み、クライアントの変更が拒否されたときに通知されることを期待しています。</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">すでに1つの連想配列が定義されています (JavaScriptでは定義できないため)。</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">クライアントが状態トークンを送信したいが、状態トークンがもはや最新ではないという理由だけで要求が失敗したくない場合があります。これを行う簡単な方法の1つは、次のように常にtrueと評価されることがわかっている条件を含めることです。 lock&amp;gt;） &quot;DAV：no-lock&quot;は、現在のロックトークンを決して表さないことがわかっています。ロックトークンは、で説明されている一意性の要件に従って、サーバーによって割り当てられます。&lt;a href=&quot;#section-6.5&quot;&gt;セクション6.5で&lt;/a&gt;したがって、「DAV：」スキームは使用できません。したがって、最新ではないことがわかっている状態トークンに「Not」を適用すると、Conditionは常にtrueと評価されます。その結果、Ifヘッダー全体が常にtrueと評価され、ロックトークンurn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2がどのような場合でも送信されます。</target>
        </trans-unit>
        <trans-unit id="ea32afad30d9372a076356ddcbf2224780548842" translate="yes" xml:space="preserve">
          <source>There may be other regulations governing the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer &quot;cookie banner&quot; code that helps you comply with these regulations.</source>
          <target state="translated">お住まいの地域では、クッキーの使用を管理する他の規制がある場合があります。これらの規制を知り、遵守することはお客様の負担となります。これらの規制を遵守するのに役立つ「クッキーバナー」コードを提供している会社があります。</target>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">機密性の高い行動には必ず確認が必要です。</target>
        </trans-unit>
        <trans-unit id="291573b8b0016bfdbfee8add5e78d0c5e2c87fdd" translate="yes" xml:space="preserve">
          <source>There was one associative array (object) already defined, because at the time JavaScript code was unable to define it by itself:</source>
          <target state="translated">既に一つの連想配列(オブジェクト)が定義されていたのですが、当時のJavaScriptのコードでは定義できませんでした。</target>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">これらのHTTPコードは再定義されていませんが、その使用はWebDAVのメソッドや要件によって多少拡張されています。一般的に、多くのHTTPステータスコードは、このドキュメントで説明されている場合だけでなく、どのようなリクエストに対しても応答として使用することができます。また、WebDAVサーバが300レベルのリダイレクト応答を使うことが知られていることにも注意してください(初期の相互運用性テストでは、クライアントがそれらの応答を見る準備ができていないことがわかりました)。サーバーがリクエストに応答して新しいリソースを生成したときに 300レベルの応答を使ってはならない[MUST NOT]。</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">サイトのような、それが希望する任意のURLパターンを持つ別のファイルタイプに役立つ可能性-これらのURLは一例であり&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;、クエリ文字列パラメータを&lt;/a&gt;： &lt;code&gt;/documents/foo?format=json&lt;/code&gt; 、 &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; 、というように。</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">これらの URL はリクエストが行われる前に書き換えられ、安全でないリクエストがネットワークにヒットしないことを意味します。リクエストされたリソースが実際に HTTPS で利用できない場合、リクエストは HTTP にフォールバックすることなく失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">これらは、様々なプラットフォーム上の他の Gecko ベースのブラウザからの UA 文字列のサンプルです。これらの多くは Gecko 2.0 ではまだリリースされていないことに注意してください!</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">これらは、コンテキストがより良い情報を提供しないときに送信される値です。すべてのブラウザがすべてのケースをカバーするために &lt;code&gt;*/*&lt;/code&gt; MIMEタイプを追加することに注意してください。これは通常、ブラウザのアドレスバーまたはHTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を介して開始されたリクエストに使用されます。</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">これらの4つの構成要素は、1990年末までに完了し、最初のサーバはすでに8月6日早い1991年でCERNの外を実行していた&lt;sup&gt;目&lt;/sup&gt; 1991、ティム・バーナーズ=リーの&lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;ポスト&lt;/a&gt;公共の&lt;em&gt;alt.hypertextの&lt;/em&gt;ニュースグループは現在、公式として考えられていますパブリックプロジェクトとしてのWorld Wide Webの開始。</target>
        </trans-unit>
        <trans-unit id="0baa00267d012f566fcf313a5a48be2638b11dd3" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">これらの4つの構成要素は、1990年末までに完了し、最初のサーバはすでに8月6日早い1991年でCERNの外を実行していた&lt;sup&gt;目&lt;/sup&gt;1991、ティム・バーナーズ=リーの&lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;ポスト&lt;/a&gt;公共の&lt;em&gt;alt.hypertextの&lt;/em&gt;ニュースグループは現在、公式として考えられていますパブリックプロジェクトとしてのワールドワイドウェブの開始。</target>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">これらの関数は、PACファイルを構築する際に使用することができます。</target>
        </trans-unit>
        <trans-unit id="1a84013246b548f38ea0c6cbcd4306fd09b1fd50" translate="yes" xml:space="preserve">
          <source>These headers &lt;em&gt;must&lt;/em&gt; be transmitted to the final recipient of the message: the server for a request, or the client for a response. Intermediate proxies must retransmit these headers unmodified and caches must store them.</source>
          <target state="translated">これらのヘッダーは、メッセージの最終受信者（要求の場合はサーバー、応答の場合はクライアント）に送信する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。中間プロキシはこれらのヘッダーを変更せずに再送信する必要があり、キャッシュはそれらを保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">これらのヘッダーは、単一のトランスポートレベルの接続でのみ意味があり、プロキシによって再送信されたり、キャッシュされたりしてはなりません。そのようなヘッダーは、&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;汎用ヘッダーを使用して設定できるのは、ホップバイホップヘッダーのみです。</target>
        </trans-unit>
        <trans-unit id="c6d30d003653ac1d60828803e6858dd6022c5e88" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection, and &lt;em&gt;must not&lt;/em&gt; be retransmitted by proxies or cached. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">これらのヘッダーは、単一のトランスポートレベルの接続に対してのみ意味が&lt;em&gt;あり&lt;/em&gt;、プロキシによって再送信したり、キャッシュしたりして&lt;em&gt;は&lt;/em&gt;なり&lt;em&gt;ません&lt;/em&gt;。&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;一般ヘッダーを使用して設定できるのはホップバイホップヘッダーのみであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">これらのヘッダーは、メッセージの最終受信者に送信されなければならない。中間プロキシは、エンドツーエンドのヘッダを変更せずに再送しなければならず、 キャッシュはそれらを保存しなければならない。</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">これらの目新しさは協調的な取り組みとして紹介されたのではなく、1991〜1995年の試作アプローチとして導入されました。サーバーとブラウザが1つの機能を追加し、牽引力があるかどうかを確認しました。多くの相互運用性の問題が一般的でした。1996年11月、これらの煩わしさを解決するために、一般的な慣行を説明する情報文書、&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;が公開されました。これはHTTP / 1.0の定義であり、狭義の意味では、それが公式の標準ではないことは注目に値します。</target>
        </trans-unit>
        <trans-unit id="970955263d6d4ddd63f73c663170a288a2997da3" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it got traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">これらのノベルティは、協調した取り組みとして導入されたのではなく、1991年から1995年の期間にわたる試用アプローチとして導入されました。サーバーとブラウザーが1つの機能を追加し、それが牽引力を獲得したかどうかを確認しました。多くの相互運用性の問題が一般的でした。 1996年11月、これらの煩わしさを解決するために、一般的な慣行を説明する情報文書、&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;が公開されました。これはHTTP / 1.0の定義であり、狭義の意味で、公式の標準ではないことは注目に値します。</target>
        </trans-unit>
        <trans-unit id="0c3e47aa5ab3cee6753961966b6b7cea5b1c2b29" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should no longer be used, and replaced with the new one.Search engine robots, RSS readers, and other crawlers will update the original URL for the resource.</source>
          <target state="translated">これらのリダイレクトは永遠に続くことを意味します。検索エンジンロボット、RSSリーダー、および他のクローラーは、リソースの元のURLを更新します。</target>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">これらのリダイレクトは永遠に続くことを意味します。これらのリダイレクトは、元のURLはもう使用されず、新しいURLが好まれることを意味します。検索エンジンのロボットは、インデックス内のリソースに関連するURLの更新をトリガーにします。</target>
        </trans-unit>
        <trans-unit id="a400740c640b1a2456fc464d677ae89fe9a9ea33" translate="yes" xml:space="preserve">
          <source>These regulations have global reach, because they apply to any site on the &lt;em&gt;World Wide&lt;/em&gt; Web that is accessed by users from these jurisdictions (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among other things.)</source>
          <target state="translated">これらの規制は、これらの管轄区域（EUおよびカリフォルニア）のユーザーがアクセスする&lt;em&gt;ワールドワイド&lt;/em&gt;ウェブ上のすべてのサイトに適用されるため、グローバルに適用されます。ただし、カリフォルニア州の法律は、総収入が2,500万米ドルを超える事業体にのみ適用されます。他のもの。）</target>
        </trans-unit>
        <trans-unit id="d896ad159048e4b552eaa0836d02af56e04f2aad" translate="yes" xml:space="preserve">
          <source>These regulations include requirements such as:</source>
          <target state="translated">これらの規制には、次のような要件が含まれています。</target>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">これらのタイプの操作は、&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; CSPディレクティブを介してJavascriptを禁止することにより防止できます。</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">彼らは存在しています。防御するのは難しい 研究は続いています 気をつけて</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">たとえば、サイトで言語メニューを提供するなど、サーバーが選択した言語を克服する方法を常に提供する必要があります。ほとんどのユーザーエージェントは &lt;code&gt;Accept-Language&lt;/code&gt; ヘッダーのデフォルト値を提供し、ユーザーインターフェース言語に適合させており、エンドユーザーは多くの場合、方法を知らないか、インターネットカフェのようにそれを変更できないため、これを変更しません。例えば。</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">第三者のクッキー</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">この&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;とワーカーはブロックされ、読み込まれません：</target>
        </trans-unit>
        <trans-unit id="f02d516991c23089fc7ef470b5b1f7122a1b1ddc" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; can enable cross-site HTTP requests for:</source>
          <target state="translated">この&lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;クロスオリジン共有標準&lt;/a&gt;は、以下のクロスサイトHTTPリクエストを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">この&lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;クロスオリジン共有標準&lt;/a&gt;は、次のサイト間HTTPリクエストを有効にするために使用されます。</target>
        </trans-unit>
        <trans-unit id="881b9b16e882da2c89e10f1e6cd38cf9b040fadb" translate="yes" xml:space="preserve">
          <source>This Feature Policy directive was at one point defined as &lt;code&gt;xr&lt;/code&gt; (but implemented in Chrome as &lt;a href=&quot;vr&quot;&gt;&lt;code&gt;vr&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この機能ポリシーディレクティブは、ある時点で &lt;code&gt;xr&lt;/code&gt; として定義されていました（ただし、Chromeでは&lt;a href=&quot;vr&quot;&gt; &lt;code&gt;vr&lt;/code&gt; &lt;/a&gt;として実装されていました）。代わりに&lt;a href=&quot;xr-spatial-tracking&quot;&gt; &lt;code&gt;xr-spatial-tracking&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">この警告コードは、この警告コードが応答に既に現れていない限り、コンテン ツコーディング、メディアタイプの変更、表現データの修正など、表現に何らかの 変換を適用する場合、プロキシによって追加されなければならない [MUST]。</target>
        </trans-unit>
        <trans-unit id="8c5ceee1b632af499883fff54e65911348e83c82" translate="yes" xml:space="preserve">
          <source>This Webpage has a redirect loop</source>
          <target state="translated">このウェブページにはリダイレクトループがあります。</target>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">これにより、 &lt;code&gt;X-My-Custom-Header&lt;/code&gt; および &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; ヘッダーをブラウザーに公開できます。</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">この付録は参考情報です。 Relax NGスキーマは、仕様のこのリビジョンで定義されていないAtomプロトコル名前空間の要素を明示的に除外します。このようなマークアップが発生したAtomプロトコルプロセッサの要件は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]のセクション&lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;および&lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;に記載されています。サービスドキュメントのスキーマ：＃-*-rnc-*-＃Atomプロトコルの名前空間app = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot; namespace atom = &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http：//の&lt;/a&gt; RELAX NGコンパクト構文文法www.w3.org/2005/Atom &quot;namespace xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &quot;namespace xhtml =&quot; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appService＃common：attrs atomURI = text appCommonAttributes = attribute xml：base {atomURI} ?, attribute xml：lang {atomLanguageTag} ?, attribute xml：space {&quot; default &quot;|&quot; preserved &quot;}？ 、undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute = attribute *-（xml：base | xml：space | xml：lang | local：*）{text} atomLanguageTag = xsd：string {pattern = &quot;（[A-Za-z] {1 、8}（-[A-Za-z0-9] {1,8}）*）？ &quot;} atomDateConstruct = appCommonAttributes、xsd：dateTime＃app：service appService = element app：service {appCommonAttributes、（appWorkspace +＆extensionElement * ）}＃app：workspace appWorkspace = element app：workspace {appCommonAttributes、（atomTitle＆appCollection *＆extensionSansTitleElement *）} atomTitle = element atom：title {atomTextConstruct}＃app：collection appCollection = element app：collection {appCommonAttributes、attribute href {atomURI}、（atomTitle＆appAccept *＆appCategories * ＆extensionSansTitleElement *）}＃app：categories atomCategory = element atom：category {atomCommonAttributes、attribute term {text}、attribute scheme {atomURI} ?, attribute label {text} ?, undefinedContent} appInlineCategories = element app：categories {attribute fixed { 「はい」| &quot;番号&quot; }？、属性スキーム{atomURI} ?,（atomCategory *、undefinedContent）} appOutOfLineCategories = element app：categories {attribute href {atomURI}、undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories＃app：accept appAccept = element app：accept {appCommonAttributes、（text？）}＃Simple Extension simpleSansTitleExtensionElement = element *-（app：* | atom：title）{text} simpleExtensionElement = element *-（app：*）{テキスト}＃構造化拡張構造化構造化SansTitleExtensionElement = element *-（app：* | atom：title）{（attribute * {text} +、（text | anyElement）*）| （属性* {テキスト} *、（テキスト？、anyElement +、（text | anyElement）*））} structuredExtensionElement = element *-（app：*）{（attribute * {text} +、（text | anyElement）*）| （attribute * {text} *、（text ?, anyElement +、（text | anyElement）*））}＃その他の拡張機能extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | StructureExtensionElement undefinedContent =（text | anyForeignElement）*＃Extensions anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-app：* {（attribute * {text} | text | anyElement）* } atomPlainTextConstruct = atomCommonAttributes、属性タイプ{&quot;テキスト&quot; | &quot;html&quot;} ?、テキストatomXHTMLTextConstruct = atomCommonAttributes、属性タイプ{&quot;xhtml&quot;}、xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml：* {（attribute * {text} | text | anyXHTML）*} xhtmlDiv = element xhtml：div {（attribute * {text} | text | anyXHTML）*}＃EOFカテゴリドキュメントのスキーマ：＃ -*-rnc-*-＃Atomプロトコル名前空間app = &quot;のRELAX NGコンパクト構文文法xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml：* {（attribute * {text} | text | anyXHTML）*} xhtmlDiv = element xhtml：div {（attribute * {text} | text | anyXHTML）*}＃EOFカテゴリドキュメントのスキーマ：＃ -*-rnc-*-＃Atomプロトコル名前空間app = &quot;のRELAX NGコンパクト構文文法xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml：* {（attribute * {text} | text | anyXHTML）*} xhtmlDiv = element xhtml：div {（attribute * {text} | text | anyXHTML）*}＃EOFカテゴリドキュメントのスキーマ：＃ -*-rnc-*-＃Atomプロトコル名前空間app = &quot;のRELAX NGコンパクト構文文法&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;名前空間アトム=&quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;名前空間xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appCategories atomCommonAttributes = attribute xml：base {atomURI} ?, attribute xml：lang {atomLanguageTag} ?, undefinedAttribute * undefinedAttribute = attribute *-（xml：base | xml：lang | local：*）{ text} atomURI = text atomLanguageTag = xsd：string {pattern = &quot;（[A-Za-z] {1,8}（-[A-Za-z0-9] {1,8}）*）？&quot;} atomCategory = element atom：category {atomCommonAttributes、attribute term {text}、attribute scheme {atomURI} ?, attribute label {text} ?, undefinedContent} appInlineCategories = element app：categories {attribute fixed {&quot;yes&quot; | &quot;no&quot;} ?,属性スキーム{atomURI} ?,（atomCategory *、undefinedContent）} appOutOfLineCategories = element app：categories {attribute href {atomURI}、（empty）} appCategories = appInlineCategories | appOutOfLineCategories＃拡張性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute * {text} | text | anyElement）* }＃EOF作成者のアドレスJoe Gregorio（編集者）Google Eメール：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃拡張性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute * {text} | text | anyElement）* }＃EOF作成者のアドレスJoe Gregorio（編集者）Google Eメール：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃拡張性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute * {text} | text | anyElement）* }＃EOF作成者のアドレスJoe Gregorio（編集者）Google Eメール：joe@bitworking.org URI：* {（属性* {テキスト} |テキスト| anyElement）*}＃EOF作成者のアドレスJoe Gregorio（編集者）Google Eメール：joe@bitworking.org URI：* {（属性* {テキスト} |テキスト| anyElement）*}＃EOF作成者のアドレスJoe Gregorio（編集者）Google Eメール：joe@bitworking.org URI： &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Bill de hOra（editor）NewBay Software EMail：bill@dehora.net URI：&lt;a href=&quot;http://dehora.net/&quot;&gt;http&lt;/a&gt; ://dehora.net/ Full Copyright Statement Copyright（C）The IETF Trust（2007）。このドキュメントは、に含まれる権利、ライセンス、および制限の対象となります。&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt; BCP 78に&lt;/a&gt;、およびそこに記載されている場合を除き、著者はすべての権利を保持します。このドキュメントとここに含まれる情報は「現状のまま」で提供され、寄稿者、彼/彼女の代表者、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません。知的財産IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用される範囲について、いかなる立場も取りません。利用できない場合があります。また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、次の場所にあります。&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可を得ようとした試みの結果を入手できます。&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/iprに&lt;/a&gt;あるIETFオンラインIPRリポジトリから 。 IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、利害関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。 Gregorio＆de hOra Standards Track [Page 53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">この記事では、HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; のデフォルト値について説明します、特定の入力とブラウザバージョンヘッダー。</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">この記事では、Cross-Origin Resource Sharingの一般的な議論として、必要なHTTPヘッダについての議論が含まれています。</target>
        </trans-unit>
        <trans-unit id="f43366408332e68939fb55f17a9ba0a7c3e2020f" translate="yes" xml:space="preserve">
          <source>This article provides guidance on how to choose whether to use a www-prefixed domain or not, along with the consequences of that choice.</source>
          <target state="translated">この記事では、www-prefixedドメインを使用するかどうかを選択する方法と、その選択の結果についてのガイダンスを提供します。</target>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">これは、LinuxおよびMac OS Xシステムでコマンドラインの &lt;code&gt;uuencode&lt;/code&gt; ユーティリティを使用して簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">これは、コンテンツを動的に提供する場合などに役立ちます。 &lt;code&gt;Vary: User-Agent&lt;/code&gt; ヘッダーを使用する場合、キャッシュサーバーは、ページをキャッシュから提供するかどうかを決定するときにユーザーエージェントを考慮する必要があります。モバイルユーザーにさまざまなコンテンツを提供している場合、キャッシュがモバイルユーザーに誤ってデスクトップバージョンのサイトを提供するのを防ぐのに役立ちます。さらに、Googleや他の検索エンジンがモバイルバージョンのページを発見するのに役立ち、&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;クローキング&lt;/a&gt;が意図されていないことを伝えることもできます。</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">これは、JavaScript コードが複数のドメインのコンテンツにアクセスできるように拡張された権限で実行されている場合などに発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">このクラスのステータスコードは、Status-Line とオプションのヘッダのみで構成される暫定応答を示し、空行で終了します。このクラスのステータスコードには必須のヘッダはありません。HTTP/1.0 は 1xx ステータスコードを定義していなかったので、サーバは実験的な条件下を除いて、HTTP/1.0 クライアントに 1xx 応答を送ってはならない[MUST NOT]。クライアントは、たとえクライアントが100(Continue)ステータスメッ セージを期待していなくても、通常の応答の前に1つ以上の1xxステータス 応答を受け入れる準備をしなければならない[MUST]。予期しない1xxステータス応答は、ユーザーエージェントに無視されてもよい[MAY]。プロキシは、プロキシとそれのクライアント間の接続が閉じられていないか、 またはプロキシ自身が1xx応答の生成をリクエストしない限り、 1xx応答を転送しなければならない[MUST]。(例えば、プロキシがリクエストを転送するときに「Expect:100-continue」フィールドを追加する場合、プロキシは対応する100(Continue)応答を転送する必要はない。</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">このクラスのステータスコードは、リクエストを満たすためにユーザーエージェ ントがさらなるアクションを取る必要があることを示す。必要なアクションは、2つ目のリクエストで使用されたメソッドがGETまたは HEADである場合に限り、ユーザーとの対話なしにユーザーエージェントが実行してもよい[MAY]。クライアントは無限のリダイレクションループを検出すべきである[SHOULD]。注意:この仕様の以前のバージョンでは、最大5回のリダイレクトを推奨していました。コンテンツ開発者は、このような固定制限を実装しているクライアントがあるかもしれないことに注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">このクラスのステータスコードは、クライアントのリクエストが正常に受信され、理解され、受け入れられたことを示す。</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">このコードは、サーバーがリクエストを受信して処理しているが、レスポンスがまだ利用できないことを示しています。</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">このコードは将来の使用のために予約されています。</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">このコードは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;への応答として送信されます、クライアントがリクエストヘッダー、サーバーが切り替えるプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="aa1e5327237aabe301b48a95db0d8c6c85cc5f0b" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header from the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">このコードは、クライアントからの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;要求ヘッダーに応答して送信され、サーバーが切り替えているプロトコルを示します。</target>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">このコードは401（Unauthorized）に似ていますが、クライアントが最初にプロキシで自身を認証する必要があることを示しています。プロキシは、要求されたリソースのプロキシに適用可能なチャレンジを含むProxy-Authenticateヘッダーフィールド（&lt;a href=&quot;#section-14.33&quot;&gt;セクション14.33&lt;/a&gt;）を返す必要があります。クライアントは適切なProxy-Authorizationヘッダーフィールド（&lt;a href=&quot;#section-14.34&quot;&gt;セクション14.34&lt;/a&gt;）でリクエストを繰り返すことができます（MAY ）。HTTPアクセス認証については、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で説明しています。</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">このデザイン手法では、ボトムアップのアプローチを使用してウェブサイトを「レイヤー」で開発し、シンプルなレイヤーから始めて、より多くの機能を使用して連続したレイヤーでサイトの機能を向上させます。</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">このディレクティブは、Public-Key-Pins-Report-Onlyヘッダには意味がなく、ユーザエージェントには無視され、ヘッダはキャッシュされません。</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">このディレクティブは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素または&lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt;ではサポートされていませんヘッダーフィールド。</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">このディレクティブは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="9666f84cadce7c6f50435b52cac971eac2053a67" translate="yes" xml:space="preserve">
          <source>This document creates two registrations for the identification of
   HTTP/2 (see &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) in the &quot;Application-Layer Protocol
   Negotiation (ALPN) Protocol IDs&quot; registry established in [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   The &quot;h2&quot; string identifies HTTP/2 when used over TLS:

   Protocol:  HTTP/2 over TLS

   Identification Sequence:  0x68 0x32 (&quot;h2&quot;)

   Specification:  This document

   The &quot;h2c&quot; string identifies HTTP/2 when used over cleartext TCP:

   Protocol:  HTTP/2 over TCP 

   Identification Sequence:  0x68 0x32 0x63 (&quot;h2c&quot;)

   Specification:  This document</source>
          <target state="translated">このドキュメントは、[ &lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt; ]で確立された「Application-LayerProtocol Negotiation（ALPN）ProtocolIDs」レジストリにHTTP / 2（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3を&lt;/a&gt;参照）を識別するための2つの登録を作成します。 「h2」文字列は、TLSで使用される場合にHTTP / 2を識別します。プロトコル：HTTP / 2 over TLS識別シーケンス：0x68 0x32（ &quot;h2&quot;）仕様：このドキュメント「h2c」文字列は、クリアテキストTCPで使用される場合にHTTP / 2を識別します。プロトコル：HTTP / 2 over TCP識別シーケンス：0x68 0x32 0x63（ &quot;h2c&quot;）仕様：このドキュメント</target>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">このドキュメントでは、クライアントがリモートWebコンテンツのオーサリング操作を実行できるようにするHTTP / 1.1プロトコルの拡張について説明します。この拡張機能は、次の操作を提供する一貫した一連のメソッド、ヘッダー、リクエストエンティティボディフォーマット、およびレスポンスエンティティボディフォーマットを提供します。プロパティ：Webページに関する情報（作成者、作成日、コレクションなど：ドキュメントのセットを作成し、階層的なメンバーシップの一覧（ファイルシステムのディレクトリ一覧など）を取得する機能。ロック：複数のユーザーが同時にドキュメントで作業できないようにする機能。これにより、最初の作成者、次に別の作成者として変更が失われる「失われた更新の問題」が防止されます。他の作成者の変更をマージせずに変更を書き込みます。名前空間操作：サーバーにWebリソースをコピーおよび移動するように指示する機能、マッピングをURLからリソースに変更する操作。これらの操作の要件と根拠は、関連ドキュメント「World Wide Webの分散オーサリングおよびバージョン管理プロトコルの要件」に記載されています。&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]。このドキュメントでは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]で提案されているバージョン管理操作を指定していません。その作業は別のドキュメント「Versioning Extensions to WebDAV」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]で行われました。以下のセクションでは、さまざまなWebDAV抽象化の詳細な紹介を提供します。リソースプロパティ（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）、リソースのコレクション（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）、一般的なロック（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）、および書き込みロック（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）です。これらの抽象化は、WebDAV固有のHTTPメソッド（&lt;a href=&quot;#section-9&quot;&gt;セクション9&lt;/a&gt;）および追加のHTTPヘッダー（&lt;a href=&quot;#section-10&quot;&gt;セクション10&lt;/a&gt;）WebDAVメソッドで使用されます。 WebDAVでのHTTP要求と応答の処理に関する一般的な考慮事項は、&lt;a href=&quot;#section-8&quot;&gt;セクション8に記載されてい&lt;/a&gt;ます。 HTTP / 1.1によって提供されるステータスコードは、WebDAVメソッドで発生するほとんどのエラー状態を説明するのに十分ですが、既存のカテゴリに適切に分類されないエラーがいくつかあります。この仕様では、WebDAVメソッド用に開発された追加のステータスコード（&lt;a href=&quot;#section-11&quot;&gt;セクション11&lt;/a&gt;）を定義し、WebDAVで使用される既存のHTTPステータスコード（&lt;a href=&quot;#section-12&quot;&gt;セクション12&lt;/a&gt;）について説明します。一部のWebDAVメソッドは多くのリソースで動作する可能性があるため、マルチステータス応答（&lt;a href=&quot;#section-13&quot;&gt;セクション13&lt;/a&gt;）は、複数のリソースのステータス情報を返すために導入されました。最後に、このバージョンのWebDAVでは、エラー応答の本文に前提条件と事後条件（&lt;a href=&quot;#section-16&quot;&gt;セクション16&lt;/a&gt;）のXML要素が導入されています。 WebDAVは、プロパティ名と一部の値にXML（[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]）を使用し、XMLを使用して複雑な要求と応答をマーシャリングします。この仕様には、マーシャリングで使用されるすべてのプロパティ（&lt;a href=&quot;#section-15&quot;&gt;セクション15&lt;/a&gt;）およびその他すべてのXML要素（&lt;a href=&quot;#section-14&quot;&gt;セクション14&lt;/a&gt;）のDTDおよびテキスト定義が含まれています。 WebDAVには、下位互換性のある方法でWebDAV XMLマーシャリングを拡張するためのいくつかの特別なルールが含まれています（&lt;a href=&quot;#section-17&quot;&gt;セクション17&lt;/a&gt;）。仕様の最後には、リソースがこの仕様に準拠することの意味（&lt;a href=&quot;#section-18&quot;&gt;セクション18&lt;/a&gt;）、国際化対応（&lt;a href=&quot;#section-19&quot;&gt;セクション19&lt;/a&gt;）、およびセキュリティ（&lt;a href=&quot;#section-20&quot;&gt;セクション20&lt;/a&gt;）に関するセクションがあります。</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">このドキュメントでは、Firefox 4以降と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0以降に基づくアプリケーションで使用されるユーザーエージェント文字列について説明します。Gecko 2.0での文字列への変更の詳細については、&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4の最終ユーザーエージェント文字列&lt;/a&gt;（ブログ投稿）を参照してください。&lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;ユーザーエージェントのスニッフィング&lt;/a&gt;に関するこのドキュメントおよびこの&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacksブログ投稿&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">このドキュメントでは、Firefox 4以降と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0以降に基づくアプリケーションで使用されるユーザーエージェント文字列について説明します。Gecko 2.0での文字列への変更の詳細については、&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4の最終ユーザーエージェント文字列&lt;/a&gt;（ブログ投稿）を参照してください。&lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;ユーザーエージェントのスニッフィング&lt;/a&gt;に関するこのドキュメントおよびこの&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacksブログ投稿&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="9b57385183fbc92e2837db521b9c0af9d5e6a089" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 error codes.  The
   &quot;HTTP/2 Error Code&quot; registry manages a 32-bit space.  The &quot;HTTP/2
   Error Code&quot; registry operates under the &quot;Expert Review&quot; policy
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;].

   Registrations for error codes are required to include a description
   of the error code.  An expert reviewer is advised to examine new
   registrations for possible duplication with existing error codes.
   Use of existing registrations is to be encouraged, but not mandated.

   New registrations are advised to provide the following information:

   Name:  A name for the error code.  Specifying an error code name is
      optional.

   Code:  The 32-bit error code value.

   Description:  A brief description of the error code semantics, longer
      if no detailed specification is provided. 

   Specification:  An optional reference for a specification that
      defines the error code.

   The entries in the following table are registered by this document.

   +---------------------+------+----------------------+---------------+
   | Name                | Code | Description          | Specification |
   +---------------------+------+----------------------+---------------+
   | NO_ERROR            | 0x0  | Graceful shutdown    | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | PROTOCOL_ERROR      | 0x1  | Protocol error       | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | detected             |               |
   | INTERNAL_ERROR      | 0x2  | Implementation fault | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | exceeded             |               |
   | SETTINGS_TIMEOUT    | 0x4  | Settings not         | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | acknowledged         |               |
   | STREAM_CLOSED       | 0x5  | Frame received for   | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | closed stream        |               |
   | FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | REFUSED_STREAM      | 0x7  | Stream not processed | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | CANCEL              | 0x8  | Stream cancelled     | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | COMPRESSION_ERROR   | 0x9  | Compression state    | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | not updated          |               |
   | CONNECT_ERROR       | 0xa  | TCP connection error | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | for CONNECT method   |               |
   | ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | exceeded             |               |
   | INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | parameters not       |               |
   |                     |      | acceptable           |               |
   | HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | request              |               |
   +---------------------+------+----------------------+---------------+</source>
          <target state="translated">このドキュメントは、HTTP / 2エラーコードのレジストリを確立します。 「HTTP / 2エラーコード」レジストリは32ビットスペースを管理します。 「HTTP / 2エラーコード」レジストリは「エキスパートレビュー」ポリシーの下で動作します[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;]。エラーコードの説明を含めるには、エラーコードの登録が必要です。専門家のレビュー担当者は、既存のエラーコードと重複する可能性があるかどうか新しい登録を調べることをお勧めします。既存の登録の使用は推奨されますが、必須ではありません。新規登録では、次の情報を提供することをお勧めします。名前：エラーコードの名前。エラーコード名の指定はオプションです。コード：32ビットのエラーコード値。説明：エラーコードのセマンティクスの簡単な説明。詳細な仕様が提供されていない場合は長くなります。仕様：エラーコードを定義する仕様のオプションのリファレンス。次の表のエントリは、このドキュメントによって登録されています。+ --------------------- + ------ + -------------------- -+ --------------- + |名前|コード|説明|仕様| + --------------------- + ------ + -------------------- -+ --------------- + | NO_ERROR | 0x0 |正常なシャットダウン|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | PROTOCOL_ERROR | 0x1 |プロトコルエラー|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | |検出されました| | | INTERNAL_ERROR | 0x2 |実装障害|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | FLOW_CONTROL_ERROR | 0x3 |フロー制御制限|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | |超えた| | | SETTINGS_TIMEOUT | 0x4 |設定ではありません|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | |認められた| | | STREAM_CLOSED | 0x5 |のために受け取ったフレーム|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | |クローズドストリーム| | | FRAME_SIZE_ERROR | 0x6 |フレームサイズが正しくありません|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | REFUSED_STREAM | 0x7 |ストリームが処理されていません|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | |キャンセル| 0x8 |ストリームがキャンセルされました|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | COMPRESSION_ERROR | 0x9 |圧縮状態|&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;| | | | 更新されていません| | | CONNECT_ERROR | 0xa | TCP接続エラー| &lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | | CONNECTメソッドの場合| | | ENHANCE_YOUR_CALM | 0xb | 処理能力| &lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | | 超えた| | | INADEQUATE_SECURITY | 0xc | ネゴシエートされたTLS | &lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | | パラメータではありません| | | | | 許容できる| | | HTTP_1_1_REQUIRED | 0xd | |にはHTTP / 1.1を使用します &lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt; | | | | リクエスト| | + --------------------- + ------ + -------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="faecb381f710b16b72849f7c98fe2e1b97f46ebf" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 frame type codes.
   The &quot;HTTP/2 Frame Type&quot; registry manages an 8-bit space.  The &quot;HTTP/2
   Frame Type&quot; registry operates under either of the &quot;IETF Review&quot; or
   &quot;IESG Approval&quot; policies [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] for values between 0x00 and 0xef,
   with values between 0xf0 and 0xff being reserved for Experimental
   Use.

   New entries in this registry require the following information:

   Frame Type:  A name or label for the frame type.

   Code:  The 8-bit code assigned to the frame type.

   Specification:  A reference to a specification that includes a
      description of the frame layout, its semantics, and flags that the
      frame type uses, including any parts of the frame that are
      conditionally present based on the value of flags.

   The entries in the following table are registered by this document.

   +---------------+------+--------------+
   | Frame Type    | Code | Section      |
   +---------------+------+--------------+
   | DATA          | 0x0  | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;  |
   | HEADERS       | 0x1  | &lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;  |
   | PRIORITY      | 0x2  | &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;  |
   | RST_STREAM    | 0x3  | &lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;  |
   | SETTINGS      | 0x4  | &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;  |
   | PUSH_PROMISE  | 0x5  | &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;  |
   | PING          | 0x6  | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;  |
   | GOAWAY        | 0x7  | &lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;  |
   | WINDOW_UPDATE | 0x8  | &lt;a href=&quot;#section-6.9&quot;&gt;Section 6.9&lt;/a&gt;  |
   | CONTINUATION  | 0x9  | &lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt; |
   +---------------+------+--------------+</source>
          <target state="translated">このドキュメントは、HTTP / 2フレームタイプコードのレジストリを確立します。「HTTP / 2フレームタイプ」レジストリは8ビットスペースを管理します。「HTTP / 2フレームタイプ」レジストリは、「IETFレビュー」または「IESG承認」ポリシーのいずれかの下で動作します[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] 0x00〜0xefの値の場合、0xf0〜0xffの値は実験用に予約されています。このレジストリの新しいエントリには、次の情報が必要です。フレームタイプ：フレームタイプの名前またはラベル。コード：フレームタイプに割り当てられた8ビットコード。仕様：フレームレイアウト、そのセマンティクス、およびフレームタイプが使用するフラグの説明を含む仕様への参照。これには、フラグの値に基づいて条件付きで存在するフレームの部分が含まれます。次の表のエントリは、このドキュメントによって登録されています。 + --------------- + ------ + -------------- + |フレームタイプ|コード|セクション| + --------------- + ------ + -------------- + |データ| 0x0 |&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt; | |ヘッダー| 0x1 |&lt;a href=&quot;#section-6.2&quot;&gt;セクション6.2&lt;/a&gt; | |優先順位| 0x2 |&lt;a href=&quot;#section-6.3&quot;&gt;セクション6.3&lt;/a&gt;| | RST_STREAM | 0x3 | &lt;a href=&quot;#section-6.4&quot;&gt;セクション6.4&lt;/a&gt; | | 設定| 0x4 | &lt;a href=&quot;#section-6.5&quot;&gt;セクション6.5&lt;/a&gt; | | PUSH_PROMISE | 0x5 | &lt;a href=&quot;#section-6.6&quot;&gt;セクション6.6&lt;/a&gt; | | PING | 0x6 | &lt;a href=&quot;#section-6.7&quot;&gt;セクション6.7&lt;/a&gt; | | GOAWAY | 0x7 | &lt;a href=&quot;#section-6.8&quot;&gt;セクション6.8&lt;/a&gt; | | WINDOW_UPDATE | 0x8 | &lt;a href=&quot;#section-6.9&quot;&gt;セクション6.9&lt;/a&gt; | | 継続| 0x9 | &lt;a href=&quot;#section-6.10&quot;&gt;セクション6.10&lt;/a&gt; | + --------------- + ------ + -------------- +</target>
        </trans-unit>
        <trans-unit id="434a26cb19aff51c4ded66c4fa66f2ee39778b92" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 settings.  The
   &quot;HTTP/2 Settings&quot; registry manages a 16-bit space.  The &quot;HTTP/2
   Settings&quot; registry operates under the &quot;Expert Review&quot; policy
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] for values in the range from 0x0000 to 0xefff, with values
   between and 0xf000 and 0xffff being reserved for Experimental Use. 

   New registrations are advised to provide the following information:

   Name:  A symbolic name for the setting.  Specifying a setting name is
      optional.

   Code:  The 16-bit code assigned to the setting.

   Initial Value:  An initial value for the setting.

   Specification:  An optional reference to a specification that
      describes the use of the setting.

   The entries in the following table are registered by this document.

   +------------------------+------+---------------+---------------+
   | Name                   | Code | Initial Value | Specification |
   +------------------------+------+---------------+---------------+
   | HEADER_TABLE_SIZE      | 0x1  | 4096          | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | ENABLE_PUSH            | 0x2  | 1             | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | INITIAL_WINDOW_SIZE    | 0x4  | 65535         | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_FRAME_SIZE         | 0x5  | 16384         | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   +------------------------+------+---------------+---------------+</source>
          <target state="translated">このドキュメントは、HTTP / 2設定のレジストリを確立します。「HTTP / 2設定」レジストリは16ビットスペースを管理します。「HTTP / 2設定」レジストリは「エキスパートレビュー」ポリシーの下で動作します[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] 0x0000〜0xefffの範囲の値の場合、〜0xf000〜0xffffの値は実験用に予約されています。新規登録では、次の情報を提供することをお勧めします。名前：設定の記号名。設定名の指定は任意です。コード：設定に割り当てられた16ビットコード。初期値：設定の初期値。仕様：設定の使用法を説明する仕様へのオプションの参照。次の表のエントリは、このドキュメントによって登録されています。 + ------------------------ + ------ + --------------- +- -------------- + |名前|コード|初期値|仕様| + ------------------------ + ------ + --------------- +- -------------- + | HEADER_TABLE_SIZE | 0x1 | 4096 |&lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | ENABLE_PUSH | 0x2 | 1 |&lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt;| | MAX_CONCURRENT_STREAMS | 0x3 | （無限）| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | INITIAL_WINDOW_SIZE | 0x4 | 65535 | &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | MAX_FRAME_SIZE | 0x5 | 16384 | &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | | MAX_HEADER_LIST_SIZE | 0x6 | （無限）| &lt;a href=&quot;#section-6.5.2&quot;&gt;セクション6.5.2&lt;/a&gt; | + ------------------------ + ------ + --------------- +- -------------- +</target>
        </trans-unit>
        <trans-unit id="7bcb90a7a70de2cd5491bcc598340f2ac5156315" translate="yes" xml:space="preserve">
          <source>This document registers the &quot;h2c&quot; upgrade token in the &quot;HTTP Upgrade
   Tokens&quot; registry (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.6&quot;&gt;[RFC7230], Section&amp;nbsp;8.6&lt;/a&gt;).

   Value:  h2c

   Description:  Hypertext Transfer Protocol version 2 (HTTP/2)

   Expected Version Tokens:  None

   Reference:  &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; of this document</source>
          <target state="translated">このドキュメントは、「HTTPアップグレードトークン」レジストリ（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.6&quot;&gt;[RFC7230]、セクション8.6&lt;/a&gt;）に「h2c」アップグレードトークンを登録します。値：h2c説明：ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）予想されるバージョントークン：なし参照：このドキュメントの&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e60b8e7d814d2b2e8b9e1b3562ab67f85484b1c" translate="yes" xml:space="preserve">
          <source>This document registers the 421 (Misdirected Request) HTTP status
   code in the &quot;HTTP Status Codes&quot; registry (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.2&quot;&gt;[RFC7231], Section&amp;nbsp;8.2&lt;/a&gt;).

   Status Code:  421

   Short Description:  Misdirected Request

   Specification:  &lt;a href=&quot;#section-9.1.2&quot;&gt;Section 9.1.2&lt;/a&gt; of this document</source>
          <target state="translated">このドキュメントは、421（Misdirected Request）HTTPステータスコードを「&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.2&quot;&gt;HTTPStatusCodes&lt;/a&gt;」レジストリ（[RFC7231]、セクション8.2）に登録します。ステータスコード：421簡単な説明：誤った要求仕様：このドキュメントの&lt;a href=&quot;#section-9.1.2&quot;&gt;セクション9.1.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">この版のHTTP / 1.1は、&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;、および&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;に組み込まれた多くの貢献に基づいています。、以前の著者、編集者、ワーキンググループチェアによる多大な貢献を含む：Tim Berners-Lee、Ari Luotonen、Roy T. Fielding、Henrik Frystyk Nielsen、Jim Gettys、Jeffrey C. Mogul、Larry Masinter、Paul J. Leach 。マークノッティンガムは、この取り組みをワーキンググループチェアとして監督しました。 1999年以降、次の寄稿者は、バグの報告、賢い質問の作成、テキストの起草またはレビュー、および未解決の問題の評価を行うことにより、HTTP仕様の改善に貢献してきました。AdamBarth、Adam Roach、Addison Phillips、Adrian Chadd、Adrian Cole、Adrien W. de Croy 、アラン・フォード、アラン・ルッテンベルク、アルバート・ランデ、アレク・ストーム、アレックス・ルスコフ、アレクサンドル・モルゴー、アレクセイ・メルニコフ、アリシャ・スミス、アミチャイ・ロスマン、アミット・クライン、アモス・ジェフリーズ、アンドレアス・マイヤー、アンドレアス・ピーターソン、アンドレイ・ポポフ、アニル・シャルマ、アン・ファン・ケステレン、アンソニーブライアン、アスビョルンアルスバーグ、アショククマール、バラチャンダークリシュナムマーシー、バリーレイバ、ベンローリー、ベンジャミンカーライル、ベンジャミンニベンジェンキンス、ブノワクレイズ、ビルコリー、ビルバーク、ビョルンホエールマン、ボブシェイフラー、ボリスズキンスキー、ブレットスラット、ブレットスラットブライアンマクバロン、ブライアンペイン、ブライアンレイモア、ブライアンスミス、ブルースペレンズ、ブライスネスビット、キャメロンヘボンジョーンズ、カールクグラー、カーステンボルマン、チャールズフライ、クリスバーデス、クリスニューマン、クリスチャンウイテマ、サイラスダブー、デイルロバートアンダーソン、ダンウィング、Dan Winship、Daniel Stenberg、Darrel Miller、Dave Cridland、Dave Crocker、Dave Kristol、Dave Thaler、David Booth、David Singer、David W. Morris、Diwakar Shetty、Dmitry Kurochkin、Drummond Reed、Duane Wessels、Edward Lee、Eitan Adler 、エリオット・リア、エミール・ステファン、エラン・ハマー・ラハブ、エリック・D・ウィリアムズ、エリック・J・ボーマン、エリック・ローレンス、エリック・レスコーラ、エリック・アロンスティー、エウンジュン・イー、エヴァン・プロドロモウ、フェリックス・ガイセンドーファー、フロリアン・ワイマー、フランク・エラマン、フレッド・アカリン、フレッド・ボーレ、フレデリック・カイザー、ガボール・モルナー、ガブリエル・モンテネグロ、ジェフリー・スネドン、ジェルバーゼ・グリブザ・グラハム、ギリザ・グリーザ、グレッグ・スレパック、グレッグ・ウィルキンス、グジェゴルズ・カルコフスキー、ハラルド・トベイト・アルヴェストランド、ハリー・ハルピン、ヘルゲ・ヘス、ヘンリック・ノードストローム、ヘンリー・S・トンプソン、ヘンリー・ストーリー、ハーバート・ファン・デ・ソンペル、エルベ・ルエラン、ハワード・メルマン、ヒューゴ・ハース、イアン・フェット・イエット、Ido Safruti、Ilari Liusvaara、Ilya Grigorik、Ingo Struck、J。Ross Nicoll、James Cloos、James H. Manger、James Lacey、James M. Snell、Jamie Lokier、Jan Algermissen、Jari Arkko、Jeff Hodges 「有効なリクエスト-URI」という用語）、Jeff Pinner、Jeff Walden、Jim Luther、Jitu Padhye、Joe D. Williams、ジョー・グレゴリオ、ジョー・オートン、ジョエル・ジャグリ、ジョン・C・クレンシン、ジョン・C・マレリー、ジョン・コーワン、ジョン・ケンプ、ジョン・パンツァー、ジョン・シュナイダー、ジョン・ストラック、ジョン・サリバン、ジョナス・シッキング、ジョナサン・A・リース、ジョナサン・ビリントン、ジョナサン・ムーア、Jonathan Silvera、Jordi Ros、Joris Dobbelsteen、Josh Cohen、Julien Pierre、Jungshik Shin、Justin Chapweske、Justin Erenkrantz、Justin James、Kalvinder Singh、Karl Dubost、Kathleen Moriarty、Keith Hoffman、Keith Moore、Ken Murchison、Koen Holton Voronkov、Kris Zyp、Leif Hedstrom、Lionel Morand、Lisa Dusseault、Maciej Stachowiak、Manu Sporny、Marc Schneider、Marc Sl​​emko、Mark Ba​​ker、Mark Pauley、Mark Watson、Markus Isomaki、Markus Lanthaler、Martin J. Duerst、Martin Musatov、Martin Nilsson、Martin Thomson、Matt Lynch、Matthew Cox、Matthew Kerwin、Max Clark、Menachem Dodge、Meral Shirazipour、Michael Burrows、Michael Hausenblas、Michael Scharf、Michael Sweet、Michael Tuexen、Michael Welzl、Mike Amundsen、Mike Belshe、Mike Bishop、Mike Kelly、Mike Schinkel、Miles Sabin、Murray S. Kucherawy、Mykyta Yevstifeyev、Nathan Rixham、ニコラスシャンクス、ニコウィリアムズ、ニコラスアルバレス、ニコラスマイヨット、ノアスレーター、オサママザヒル、パブロカストロ、パットヘイズ、パトリックRマクマナス、ポールEジョーンズ、ポールホフマン、ポールマーケス、ピートレズニック、ピーターレペスカ、ピーターオクシル、ピーターセントアンドレ、ピーターワトキンス、フィルアーチャー、フィルハント、フィリップムジャン、フィリップハラムベイカー、ピオトルドブロゴスト、ポールヘニングカンプ、プリティナタラジャン、ラジーエフセクター、レイポーク、レトバックマングミュア、リチャードバーンズ、リチャードシガニアック、ロブTrace、Robby Simpson、Robert Brewer、Robert Collins、Robert Mattson、Robert O'Callahan、Robert Olofsson、Robert Sayre、Robert Siemer、Robert de Wilde、Roberto Javier Godoy、Roberto Peon、Roland Zink、Ronny Widjaja、Ryan Hamilton、S。Mike Dierken、Salvatore Loreto、Sam Johnston、Sam Pullara、Sam Ruby、Saurabh Kulkarni、Scottローレンス（元の問題リストを維持した人）、ショーンB.パーマー、ショーンターナー、セバスチャンバルヌード、シェーンマッカロン、大津茂樹、サイモンヤーデ、ステファンアイシング、ステファンティルコフ、ステファノスハラハラキス、ステファンボルツマイヤー、スティーブンファレル、スティーブンケント、スティーブンルディン、スチュアートウィリアムズ、サブブアラマラジュ、サブラマニアンムーネサミー、スーザンヘアス、シルヴァンヘルレグアーチ、タパンディヴェカール、辻川達宏、林達也、テッドハーディ、テッドレモン、トーマスブロイヤー、トーマスフォッサティ、トーマスマスレン、トーマスナドー、トーマスノルディン、トーマスロスラーブレイ、ティムモーガン、ティムオルセン、トムジョウ、トラビススヌージー、タイラークローズ、ヴィンセントマーフィー、ウェンボチュー、ヴェルナーバウマン、ウィルバーストリート、ウィルフレドサンチェスベガ、ウィリアムA.ロウジュニア、ウィリアムチャン、ウィリータロー、シャオシュワン、ヤロンゴランド、イングベナイセーターペッターセン、ヨーブニル、ヨゲシュバン、ユチュンチェン、大岩豊、Yves Lafon（編集チームの長いメンバー）、Zed A. Shaw、Zhong Yu。見る&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;[RFC2616]のセクション16は&lt;/a&gt;、以前の改訂からの追加の謝辞です。</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">このエラーは、応答に複数の &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーが含まれている場合にも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">このエラーは、ユーザーが開いているタブやウィンドウのトップレベルでドキュメントが読み込まれなかったことを意味します。このような状況で発生することがあります。</target>
        </trans-unit>
        <trans-unit id="852ff1bb35f3874b9a14a70ab4ee1ec671ff8707" translate="yes" xml:space="preserve">
          <source>This error occurs when attempting to preflight a header that is not expressly allowed (that is, it's not included in the list specified by the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header sent by the server). To fix this, the server needs to be updated so that it allows the indicated header, or you need to avoid using that header.</source>
          <target state="translated">このエラーは、明示的に許可されていないヘッダーをプリフライトしようとしたときに発生します（つまり、サーバーから送信された &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダーで指定されたリストに含まれていません）。これを修正するには、サーバーを更新して、指定されたヘッダーを許可するか、そのヘッダーの使用を回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">このエラー応答は、一般的な「キャッチオール」応答です。サーバー管理者は、将来的にエラーが再び発生するのを防ぐために、リクエストについてのより詳細な情報とともに、500 ステータスコードのようなエラー応答をログに記録することがあります。</target>
        </trans-unit>
        <trans-unit id="bf47d90cae9806b4c78cd4a0f7b36fa115bda893" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Usually, this indicates the server cannot find a better 5xx error code to response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">このエラー応答は、一般的な「キャッチオール」応答である。通常、これはサーバが応答するためのより良い 5xx エラーコードを見つけることができないことを示しています。時々、サーバ管理者は、将来エラーが再び発生するのを防ぐために、リクエストについてのより詳細な情報とともに、500 ステータスコードのようなエラー応答をログに記録します。</target>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">このエラー応答は、サーバがゲートウェイとして動作していて、時間内に応答を得ることができない場合に与えられます。</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">このエラー応答は、サーバーが、リクエストを処理するために必要な応答を取得するためのゲートウェイとして動作している間に、無効な応答を取得したことを意味します。</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">このエラーは、十分にテストされた生産システムでは発生しないはずですが、新しいシステムをテストしている間に、より頻繁に発見される可能性があります。</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">このHTTPの進化は、その拡張性とシンプルさを証明し、多くのアプリケーションの作成を解放し、プロトコルの採用を余儀なくさせました。現在のHTTPが使われている環境は、1990年代初頭とは大きく異なります。HTTP のオリジナルデザインは傑作であることを証明し、四半世紀にわたって反乱を起こすことなく Web を進化させることができました。欠陥を治しつつ、HTTP を成功に導いた柔軟性と拡張性を維持することで、HTTP/2 の採用はプロトコルの明るい未来を示唆しています。</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">この例では、特定のオリジンの &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; コンテンツがユーザーの場所にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">この例では、サーバーwww.example.comに/ webdisc / xfiles /というコレクションを作成します。&amp;gt;&amp;gt;リクエストMKCOL / webdisc / xfiles / HTTP / 1.1 Host：www.example.com &amp;gt;&amp;gt; Response HTTP / 1.1 201 Created</target>
        </trans-unit>
        <trans-unit id="a0811554d7dd6c0c801a3a83158f7a56615c10fc" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers - as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">この例はもっと洗練されています。4台のプロキシサーバがあり、そのうちの1台は他のすべてのプロキシサーバのホットスタンバイとなっているので、 残りの3台のうちのどれかがダウンした場合は4台目のプロキシサーバが引き継ぐことになります。さらに、残りの3つのプロキシサーバはURLのパターンに基づいて負荷を共有しています。負荷はこのように分散されます。</target>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">この例はもっと洗練されています。4台のプロキシサーバがあり、そのうちの1台は他のすべてのプロキシサーバのホットスタンバイとなっているので、 残りの3台のうちどれかがダウンした場合は4台目のプロキシサーバが引き継ぐことになります。さらに、残りの三つのプロキシサーバはURLのパターンに基づいて負荷を共有しています。負荷はこのように分散されます。</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">この応答例は、IETF RFC（下記を参照）から取得され、&lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty PythonのLife of Brian&lt;/a&gt;への参照が含まれています。</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">この例は、複数のヘッダーのサポートを指定する場合の &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; を示しています。</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">この例では、リソースhttp://www.example.com/~fielding/index.htmlがロケーションhttp://www.example.com/users/f/fielding/index.htmlにコピーされています。204（コンテンツなし）ステータスコードは、宛先の既存のリソースが上書きされたことを示します。&amp;gt;&amp;gt;リクエストCOPY /~fielding/index.html HTTP / 1.1 Host：www.example.com Destination：http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt; Response HTTP / 1.1 204いいえコンテンツ</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">この例では、リソースhttp://www.example.com/~fielding/index.htmlが場所http://www.example.com/users/f/fielding/index.htmlに移動されています。宛先URLがすでにリソースにマップされている場合、宛先リソースのコンテンツは上書きされていました。この場合、宛先リソースには何もなかったため、応答コードは201（Created）です。 &amp;gt;&amp;gt;リクエストMOVE /~fielding/index.html HTTP / 1.1 Host：www.example.com Destination：http：//www.example/users/f/fielding/index.html &amp;gt;&amp;gt; Response HTTP / 1.1 201 Created Location： http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">この例は、内部DNSサーバが内部ホスト名のみを解決できるように設定されていて、 解決できないホストに対してのみプロキシを使用することを目的としている環境で動作します。</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">HTTPのこの拡張可能な性質により、時間の経過とともに、Webのより多くの制御と機能が可能になりました。キャッシュまたは認証方法は、HTTP履歴の初期に処理された機能でした。対照的に、&lt;em&gt;発生元の制約&lt;/em&gt;を緩和する機能は2010年代にのみ追加されました。</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">この機能はWeb標準から削除されました。一部のブラウザーではまだサポートされている可能性がありますが、削除される途中です。使用を避け、可能であれば既存のコードを更新してください。このページの下部にある&lt;a href=&quot;#Browser_compatibility&quot;&gt;互換性の表&lt;/a&gt;を参照して、決定を行ってください。この機能はいつでも機能しなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="04e8879adf91055abe755b306ecdfa7377e41ed0" translate="yes" xml:space="preserve">
          <source>This feature is available only in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;secure contexts&lt;/a&gt; (HTTPS), in some or all &lt;a href=&quot;#Browser_compatibility&quot;&gt;supporting browsers&lt;/a&gt;.</source>
          <target state="translated">この機能は、一部またはすべての&lt;a href=&quot;#Browser_compatibility&quot;&gt;サポートブラウザ&lt;/a&gt;で、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;セキュアコンテキスト&lt;/a&gt;（HTTPS）でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="5f97d5c5e8a61c76b7ca883b249f65188e1add95" translate="yes" xml:space="preserve">
          <source>This feature is commonly used to allow a resource to be cached in uncompressed and (various) compressed forms, and served appropriately to user agents based on the encodings that they support. For example, a server can set &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; to ensure that a separate version of a resource is cached for all requests that specify support for a particular set of encodings, e.g. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;.</source>
          <target state="translated">この機能は通常、リソースを非圧縮および（さまざまな）圧縮形式でキャッシュし、サポートするエンコーディングに基づいてユーザーエージェントに適切に提供できるようにするために使用されます。たとえば、サーバーは &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; を設定して、 &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt; 特定のエンコーディングセットのサポートを指定するすべてのリクエストに対して、リソースの個別のバージョンがキャッシュされるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="17fdac85d6009334c365dfdd6eb6bef5e4374b26" translate="yes" xml:space="preserve">
          <source>This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">この機能は推奨されなくなりました。一部のブラウザーはまだそれをサポートしている可能性がありますが、関連するWeb標準から既に削除されているか、削除中か、互換性を保つ目的でのみ保持されている可能性があります。使用を避け、可能であれば既存のコードを更新してください。このページの下部にある&lt;a href=&quot;#Browser_compatibility&quot;&gt;互換性の表&lt;/a&gt;を参照して、決定を行ってください。この機能はいつでも機能しなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">この機能は非標準であり、標準化されていません。Webに面した本番サイトでは使用しないでください:すべてのユーザーに対して動作するわけではありません。また、実装間に大きな非互換性があるかもしれませんし、将来的に動作が変わるかもしれません。</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">この機能は廃止されました。一部のブラウザではまだ動作するかもしれませんが、いつでも削除される可能性があるため、使用はお勧めしません。使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="44d6d26ec2012e7ff67a4bdfd287c446e6ad0a4f" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: What happens under the hood when you click on a link in your browser.</source>
          <target state="translated">この基本的な記事では、典型的な HTTP セッションについて説明します。ブラウザでリンクをクリックしたときに何が起こるかを説明します。</target>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">この基本的な記事では、典型的なHTTPセッションについて説明します。ブラウザーでリンクをクリックすると、内部で何が起こりますか&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;バリデーターまたは&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; の&lt;/a&gt;いずれかで使用できますが、両方では使用できません。</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">サーバからのこのヘッダは、クライアントにクッキーを保存するように指示します。</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">このヘッダーは、特定のURLなど、ユーザーが明示的に決定することで制御される別の方法でサーバーが言語を判別する方法がない場合に使用されるヒントです。サーバーが明示的な決定を上書きしないことをお勧めします。 &lt;code&gt;Accept-Language&lt;/code&gt; のコンテンツは、ユーザーが制御できない場合がよくあります（旅行して別の国でインターネットカフェを使用する場合など）。ユーザーは、ユーザーインターフェイスのロケール以外の言語でページにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">このヘッダーは、それを使用することを選択したクライアントによって自動的に追加されます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt;メソッドを使用して追加することはできません。</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素内ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">このヘッダーは、リクエストに&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;ヘッダーがある場合に必要です。</target>
        </trans-unit>
        <trans-unit id="737f8eaab76cbd788575174bfce1b83385303b75" translate="yes" xml:space="preserve">
          <source>This header is still in an experimental state, and is subject to change at any time. Be wary of this when implementing it on your website. The header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">このヘッダーはまだ実験的な状態であり、いつでも変更される可能性があります。あなたのウェブサイトにそれを実装するとき、これに注意してください。ヘッダーは仕様で &lt;code&gt;Permissions-Policy&lt;/code&gt; に名前が変更され、この記事は最終的にその変更を反映するように更新されます。</target>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">このヘッダはデバッグ、統計、位置依存コンテンツの生成に使用され、設計上、クライアントのIPアドレスのようなプライバシーに敏感な情報を公開します。したがって、このヘッダをデプロイする際には、ユーザのプライバシーを考慮しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">サーバーが&lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; ステータスコードで応答して、使用できるリクエストメソッドを示す場合、このヘッダーを送信する必要があります。空の &lt;code&gt;Allow&lt;/code&gt; ヘッダーは、リソースが要求メソッドを許可しないことを示します。これは、たとえば、特定のリソースで一時的に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d038bd6662fb532b2ff18177eb47f5f8cd56f9cb" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, or &lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;malware redirects&lt;/a&gt;, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">このヘッダーは、発生したはずの違反を報告します。これを使用して、コンテンツセキュリティポリシーを繰り返し処理できます。サイトの動作を観察し、違反レポートや&lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;マルウェアのリダイレクトを&lt;/a&gt;監視してから、&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーによって適用される目的のポリシーを選択します。</target>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">このヘッダーは、発生したはずの違反を報告します。これを使用して、コンテンツセキュリティポリシーを繰り返し処理できます。サイトの動作を監視し、違反レポートを監視してから、&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーによって適用される目的のポリシーを選択します。</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">このヘッダは、ウェブマスターがコンテンツスニッフィングをブロックするための方法として IE 8 で Microsoft によって導入され、実行不可能な MIME タイプを実行可能な MIME タイプに変換することができました。それ以来、他のブラウザは MIME スニッフィングアルゴリズムがそれほど積極的ではなかったとしても、このヘッダを導入してきました。</target>
        </trans-unit>
        <trans-unit id="ff8f924b302448210e272cb74eecb8ba48436a36" translate="yes" xml:space="preserve">
          <source>This header was originally defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt;, but the definition of &quot;selected representation&quot; in &lt;a href=&quot;https://www.rfc-editor.org/info/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; made the original definition inconsistent with current HTTP specifications. When released, The &quot;Resource Digests for HTTP&quot; draft therefore will obsolete RFC 3230 and will update the standard to be consistent.</source>
          <target state="translated">このヘッダーは元々&lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC3230&lt;/a&gt;で定義されていましたが、&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;での「選択された表現」の定義により、元の定義が現在のHTTP仕様と矛盾していました。したがって、リリースされると、「HTTPのリソースダイジェスト」ドラフトはRFC 3230を廃止し、一貫性を保つように標準を更新します。</target>
        </trans-unit>
        <trans-unit id="7910eee90b814ebcea921d5e05f3e798655b01a9" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue the request, or ignore the response if the request is already finished.</source>
          <target state="translated">この暫定応答は、これまでのところすべてがOKであり、クライアントはリクエストを継続すべきであることを示す。</target>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">この暫定応答は、これまでのところすべてがOKであり、クライアントは リクエストを続行するか、すでに終了している場合はそれを無視するべきであることを示す。</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">これは、 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダーで無効または不明なヘッダー名を送信しないようにサーバーの構成を変更することにより、サーバー側でのみ修正できる可能性が高い問題です。クライアントで使用しているユーザーエージェントまたはHTTPライブラリが最新であることを確認することも確認する価値があります。</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">これは、 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; ヘッダーで無効または不明なメソッド名を送信しないようにサーバーの構成を変更することによって、サーバー側でのみ修正できる可能性が高い問題です。クライアントで使用しているユーザーエージェントまたはHTTPライブラリが最新であることを確認することも確認する価値があります。</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">これはトップダウン型のアプローチで、必要な機能をすべて使用して可能な限り最高のサイトを構築し、古いブラウザでも動作するように微調整します。これは、プログレッシブ・エンハンスメントよりも難しく、効果的ではありませんが、場合によっては有用な場合もあります。</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">これは非常に主観的なトピックであり、&lt;a href=&quot;http://bikeshed.com/&quot;&gt;バイクシェディングの&lt;/a&gt;問題と考えることができます。より深く読みたい場合は、このテーマ&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;に関する&lt;/a&gt;&lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;多くの&lt;/a&gt;記事のいくつかをご覧ください。</target>
        </trans-unit>
        <trans-unit id="641095a78e4ebe2abe2b4166aac4c4584c32cfcf" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">これは非常に主観的なトピックであり、&lt;a href=&quot;http://bikeshed.com/&quot;&gt;バイクシェディングの&lt;/a&gt;問題と見なすことができます。もっと深く読みたい場合は、このテーマ&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;に関する&lt;/a&gt;&lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;多くの&lt;/a&gt;記事のいくつかを参照してください。</target>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">これは以前の &lt;code&gt;Accept&lt;/code&gt; ヘッダーよりも改善されており、 &lt;code&gt;text/html&lt;/code&gt; の上に &lt;code&gt;image/png&lt;/code&gt; をランク付けしなくなりました。</target>
        </trans-unit>
        <trans-unit id="b2128edd161faa94a80e6eb961a49e5e2001c4b7" translate="yes" xml:space="preserve">
          <source>This is an obsolete directive that no longer works in modern browsers. Don't use it. In supporting legacy browsers, a page can be displayed in a frame only on the specified origin &lt;em&gt;uri&lt;/em&gt;. Note that in the legacy Firefox implementation this still suffered from the same problem as &lt;code&gt;SAMEORIGIN&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin. The &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header has a &lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;&lt;/a&gt; directive which you can use instead.</source>
          <target state="translated">これは廃止されたディレクティブであり、最近のブラウザでは機能しなくなりました。使用しないでください。従来のブラウザをサポートする場合、ページは指定された元の&lt;em&gt;URIで&lt;/em&gt;のみフレームに表示できます。従来のFirefoxの実装では、これは &lt;code&gt;SAMEORIGIN&lt;/code&gt; と同じ問題を抱えていたことに注意してください。フレームの祖先が同じオリジンにあるかどうかはチェックされません。&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;HTTPヘッダーがあり&lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt; &lt;code&gt;frame-ancestors&lt;/code&gt; &lt;/a&gt;かわりに使用できるディレクティブを。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">これは、&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して実装されます。etagが元のファイルと一致しない場合、または取得後にファイルが変更されている場合、変更は&lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; エラーで拒否されます。その後、エラーを処理するかどうかはクライアント次第です。ユーザーに再起動するよう通知する（今回は最新バージョン）か、ユーザーに両方のバージョンの&lt;em&gt;差分&lt;/em&gt;を表示して、保持する変更を決定するのに役立ちます。 。</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">これは&lt;em&gt;クライアントヒント&lt;/em&gt;と呼ばれる&lt;strong&gt;実験的な&lt;/strong&gt;テクノロジーの一部であり、Chrome 61以降でのみ使用できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8cd6fbb7a4f7885010a0bffbaf4241fed054fc3" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">これは&lt;em&gt;クライアントヒント&lt;/em&gt;と呼ばれる&lt;strong&gt;実験的な&lt;/strong&gt;テクノロジーの一部であり、Chrome61以降でのみ使用できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">これは、&lt;em&gt;クライアントヒント&lt;/em&gt;と呼ばれる&lt;strong&gt;実験的な&lt;/strong&gt;テクノロジーの一部です。初期サポートはChrome 46以降です。Device-Memoryの値はChrome 61以降です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">これは401と似ていますが、認証はプロキシで行う必要があります。</target>
        </trans-unit>
        <trans-unit id="eeed176b4c6d9e486d6e3b46cc4c1482f2ae547b" translate="yes" xml:space="preserve">
          <source>This is the default behavior if no policy is specified, or if the provided value is invalid. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;path&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;querystring&lt;/a&gt; of the URL are sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS) or improves (HTTP&amp;rarr;HTTPS), but isn't sent to less secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">これは、ポリシーが指定されていない場合、または指定された値が無効な場合のデフォルトの動作です。URLの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;発信元&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;パス&lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;クエリ文字列&lt;/a&gt;は、プロトコルのセキュリティレベルが同じ（HTTP&amp;rarr;HTTP、HTTPS&amp;rarr;HTTPS）または改善（HTTP&amp;rarr;HTTPS）の場合にリファラーとして送信されますが、安全性の低い宛先には送信されません（ HTTPS&amp;rarr;HTTP）。</target>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">これは、バイナリファイルのデフォルトです。&lt;em&gt;不明なバイナリ&lt;/em&gt;ファイルを意味するため、ブラウザは通常それを実行せず、実行するかどうかも尋ねません。&lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt;ヘッダーがattachmentに設定されているかのように扱い、「名前を &lt;code&gt;attachment&lt;/code&gt; 保存」ダイアログを提案します。</target>
        </trans-unit>
        <trans-unit id="763b865e8143c4b06adf307c51b45264f147e5ff" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary&lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">これは、バイナリファイルのデフォルトです。それは&lt;em&gt;未知のバイナリ&lt;/em&gt;ファイルを意味するので、ブラウザは通常それを実行しません、あるいはそれが実行されるべきかどうかさえ尋ねます。彼らはそれを&lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt;ヘッダーが &lt;code&gt;attachment&lt;/code&gt; に設定されているかのように扱い、「名前を付けて保存」ダイアログを提案します。</target>
        </trans-unit>
        <trans-unit id="5a1fbd395e24ae5276bcd50aae6f6286330fa789" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &quot;unknown textual file,&quot; browsers assume they can display it.</source>
          <target state="translated">これがテキストファイルのデフォルトです。たとえそれが本当に「不明なテキストファイル」を意味していたとしても、ブラウザはそれを表示できると思い込んでいます。</target>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">これはテキストファイルのデフォルトです。それが本当に&lt;em&gt;未知のテキスト&lt;/em&gt;ファイルを意味する場合でも、ブラウザはそれを表示できると想定します。</target>
        </trans-unit>
        <trans-unit id="65a6727795861e19e32215df8fff896b8941c0ee" translate="yes" xml:space="preserve">
          <source>This is the default value. Allows the document to be added to its opener's browsing context group unless the opener itself has a COOP of &lt;code&gt;same-origin&lt;/code&gt; or &lt;code&gt;same-origin-allow-popups&lt;/code&gt;.</source>
          <target state="translated">これがデフォルト値です。オープナー自体に &lt;code&gt;same-origin&lt;/code&gt; または &lt;code&gt;same-origin-allow-popups&lt;/code&gt; COOPがない限り、ドキュメントをオープナーのブラウジングコンテキストグループに追加できるようにします。</target>
        </trans-unit>
        <trans-unit id="99e6e8d58bc61269a54fd031cb14f2fe33969d30" translate="yes" xml:space="preserve">
          <source>This is the default value. Allows the document to fetch cross-origin resources without giving explicit permission through the CORS protocol or the &lt;a href=&quot;cross-origin-resource-policy&quot;&gt;&lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">これがデフォルト値です。CORSプロトコルまたは&lt;a href=&quot;cross-origin-resource-policy&quot;&gt; &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーを介して明示的な許可を与えることなく、ドキュメントがクロスオリジンリソースをフェッチできるようにします。</target>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">これは、ポリシーが指定されていない場合のユーザーエージェントのデフォルトの動作です。URLは、プロトコルのセキュリティレベルが同じ場合（HTTP&amp;rarr;HTTP、HTTPS&amp;rarr;HTTPS）、参照元として送信されますが、安全性の低い宛先（HTTPS&amp;rarr;HTTP）には送信されません。</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">これは、ポリシーが指定されていない場合のユーザーエージェントのデフォルトの動作です。オリジンはリファラーとしてアプリオリの安全性の高い宛先（HTTPS-&amp;gt; HTTPS）に送信されますが、安全性の低い宛先（HTTPS-&amp;gt; HTTP）には送信されません。</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">これはキャッシュ目的で使用されます。レスポンスが変更されていないことをクライアントに伝え、クライアントは同じキャッシュされたバージョンのレスポンスを使い続けることができます。</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">これは通常悪い習慣ですが、これが必要な場合もあります。このような場合は、まず状況を分析して、本当に必要かどうかを確認する必要があります。非セマンティックな&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt;要素または&amp;lt;span&amp;gt;要素を追加することでそれを防ぐことができますか？ユーザーエージェント検出をうまく使用することの難しさは、HTMLの純粋さを少し中断するだけの価値があります。また、デザインを再考してください。プログレッシブエンハンスメントまたは流動レイアウトを使用して、これを行う必要をなくすことができますか？</target>
        </trans-unit>
        <trans-unit id="0d42afd2b8cd7621e5970bc258f4d2e2f724c681" translate="yes" xml:space="preserve">
          <source>This means that if you do not need to support legacy browsers, it is recommended that you use &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; without allowing &lt;code&gt;unsafe-inline&lt;/code&gt; scripts instead.</source>
          <target state="translated">つまり、従来のブラウザをサポートする必要がない場合は、代わりに &lt;code&gt;unsafe-inline&lt;/code&gt; スクリプトを許可せずに &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">これは、リソースが &lt;code&gt;Location:&lt;/code&gt; HTTP Responseヘッダーで指定された別のURIに永続的に配置されることを意味します。これは、ユーザーエージェント&lt;em&gt;が&lt;/em&gt;使用するHTTPメソッドを変更しては&lt;em&gt;ならない&lt;/em&gt;ことを除いて、 &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP応答コードと同じセマンティクスを持っています。最初のリクエストで &lt;code&gt;POST&lt;/code&gt; を使用した場合、2番目のリクエストで &lt;code&gt;POST&lt;/code&gt; を使用する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">このメカニズムは常にクライアントによって開始され（1つの例外を除いて、サーバー&lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;がTLSへのアップグレードを要求する&lt;/a&gt;可能性があります）、サーバーは新しいプロトコルへの切り替えを受け入れるか拒否する場合があります。これにより、HTTP / 1.1などの一般的に使用されているプロトコルを使用して接続を開始し、HTTP / 2またはWebSocketへの接続の切り替えを要求できます。</target>
        </trans-unit>
        <trans-unit id="6fd8e35050a88061004785e66da5be5ef6c4558f" translate="yes" xml:space="preserve">
          <source>This mechanism is optional; it cannot be used to insist on a protocol change. Implementations can choose not to take advantage of an upgrade even if they support the new protocol, and in practice, this mechanism is used mostly to bootstrap a WebSockets connection.</source>
          <target state="translated">このメカニズムはオプションです。プロトコルの変更を主張するために使用することはできません。実装では、たとえ新しいプロトコルをサポートしていても、アップグレードを利用しないことを選択できます。</target>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">このメッセージは、ブラウザーが &lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを確認し、ページを新しいプロセスに再読み込みして、より多くの連続したメモリを確保する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">このモデルは、HTTP / 1.0で使用されるデフォルトのモデルです（&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーがない場合、またはその値が &lt;code&gt;close&lt;/code&gt; に設定されている場合）。HTTP / 1.1では、このモデルは、値が &lt;code&gt;close&lt;/code&gt; の&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーが送信された場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">このページは完全ではありません。</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーが原因で、このページは新しいプロセスで読み込まれました。</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">このページは、 &lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーが原因で新しいプロセスに読み込まれますが、Win32以外のプラットフォームでは、 &lt;code&gt;Large-Allocation&lt;/code&gt; プロセスの作成は無効になっています。</target>
        </trans-unit>
        <trans-unit id="24edd3164f6204b4aeaaef84edccb45a164270bb" translate="yes" xml:space="preserve">
          <source>This pattern of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; headers is the simplest use of the access control protocol. If the resource owners at &lt;code&gt;https://bar.other&lt;/code&gt; wished to restrict access to the resource to requests &lt;em&gt;only&lt;/em&gt; from &lt;code&gt;https://foo.example&lt;/code&gt;, (i.e no domain other than &lt;code&gt;https://foo.example&lt;/code&gt; can access the resource in a cross-site manner) they would send:</source>
          <target state="translated">このパターン&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;ヘッダはアクセス制御プロトコルの最も簡単な使用です。 &lt;code&gt;https://bar.other&lt;/code&gt; のリソース所有者が、リソースへのアクセスを &lt;code&gt;https://foo.example&lt;/code&gt; からのリクエスト&lt;em&gt;のみ&lt;/em&gt;に制限したい場合（つまり、 &lt;code&gt;https://foo.example&lt;/code&gt; 以外のドメインはリソースにアクセスできません）クロスサイト方式）送信します：</target>
        </trans-unit>
        <trans-unit id="07bca8347d8092d11755f1e4e5691c56881328bb" translate="yes" xml:space="preserve">
          <source>This performs a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">これは、CORS ヘッダを使用して特権を処理するためにクライアントとサーバの間で簡単な交換を行います。</target>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">このポリシーは、TLS で保護されたリソースから安全でないオリジンへのオリジンとパスをリークします。この設定の影響を慎重に検討してください。</target>
        </trans-unit>
        <trans-unit id="e32c67984e9c6672ef8d338fdf20280130724f78" translate="yes" xml:space="preserve">
          <source>This policy will leak potentially-private information from HTTPS resource URLs to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">このポリシーは、HTTPS リソースの URL から安全ではない出所に、潜在的にプライベートな情報を漏らすことになります。この設定の影響を慎重に検討してください。</target>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">このプリフェッチはバックグラウンドで実行されるため、参照されているアイテムが必要になるまでに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt;が解決されている可能性があります。これにより、ユーザーがリンクをクリックしたときの待ち時間が短縮されます。</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">HTTP/1.1やHTTP/2はWebサイトやアプリケーションの適応を必要としないため、このような急速な普及率が生まれたと考えられます。HTTP/1.1やHTTP/2を使用することは、Webサイトやアプリケーションの適応を必要としないからです。</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">これは、その内容を持つHTMLリソースを表します。</target>
        </trans-unit>
        <trans-unit id="88b4a61039714ba204509f652a8c7c13f179e1ae" translate="yes" xml:space="preserve">
          <source>This request does not relate to any context like site, origin, or frame. This can happen when user had initiated this request by, e.g. directly entering a URL in the address bar, opening a bookmark, or draging-and-dropping a file into the browser window.</source>
          <target state="translated">このリクエストは、サイト、オリジン、フレームなどのコンテキストには関係ありません。これは、ユーザーがアドレスバーにURLを直接入力したり、ブックマークを開いたり、ブラウザウィンドウにファイルをドラッグ&amp;ドロップしたりして、このリクエストを開始した場合に起こります。</target>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">このレスポンスコードはもはや使用されておらず、現在は予約されているだけです。これは以前のバージョンの HTTP 1.1 仕様で使用されていました。</target>
        </trans-unit>
        <trans-unit id="8d9b5cfc9ffb70c58676155836edb7100932e47c" translate="yes" xml:space="preserve">
          <source>This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.</source>
          <target state="translated">このレスポンスコードはもはや使用されておらず、予約されているだけです。これは以前のバージョンの HTTP/1.1 仕様で使用されていました。</target>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">この応答コードは将来の使用のために予約されています。このコードを作成した当初の目的は、デジタル決済システムに使用することでしたが、現在は使用されていません。</target>
        </trans-unit>
        <trans-unit id="2dd19a171f836779710936f505245545bdd2344b" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.</source>
          <target state="translated">この応答コードは将来の使用のために予約されている。このコードを作成した当初の目的は、デジタル決済システムに使用することでしたが、このステータスコードが使用されることは非常に稀であり、標準的な規約は存在しません。</target>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">このレスポンスコードは、このリクエストを送信したユーザエージェントにドキュメントビューのリセットを伝えるために、リクエストを達成した後に送信されます。</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">この応答コードは、ダウンロードを複数のストリームに分離するためにクライアントから送信されるレンジヘッダのために使用されます。</target>
        </trans-unit>
        <trans-unit id="b0b3091267e6eb1f6619e52e3332c6b0eef55bd5" translate="yes" xml:space="preserve">
          <source>This response code is used when the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header is sent from the client to request only part of a resource.</source>
          <target state="translated">この応答コードは、リソースの一部のみを要求するために&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーがクライアントから送信されるときに使用されます。</target>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">このレスポンスコードは、返されたメタ情報セットが、オリジンサーバから利用可能な正確なセットではなく、ローカルまたはサードパーティのコピーから収集されたものであることを意味します。この条件を除いては、このレスポンスの代わりに200 OKレスポンスを優先してください。</target>
        </trans-unit>
        <trans-unit id="adaff7b5972a65eef381227188ec9967318ffddd" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">この応答コードは、要求されたリソースのURIが&lt;em&gt;一時的に&lt;/em&gt;変更されたことを意味します。将来、URIがさらに変更される可能性があります。したがって、これと同じURIをクライアントが将来のリクエストで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">この応答コードは、要求されたリソースのURIが&lt;em&gt;一時的に&lt;/em&gt;変更されたことを意味します。URIに新しい変更が将来加えられる可能性があります。したがって、この同じURIをクライアントが将来のリクエストで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">このレスポンスコードは、要求されたリソースのURIが変更されたことを意味します。おそらく、新しいURIがレスポンスで与えられるだろう。</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">この応答コードは、 &lt;code&gt;Expect&lt;/code&gt; リクエストヘッダーフィールドで示された期待値がサーバーで満たされなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="f85333520aaa3b92348b920c927ea684bb37f464" translate="yes" xml:space="preserve">
          <source>This response code means the returned meta-information is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the &quot;200 OK&quot; response is preferred to this status.</source>
          <target state="translated">このレスポンスコードは、返されたメタ情報がオリジンサーバから利用可能なものと全く同じではなく、ローカルまたはサードパーティのコピーから収集されたものであることを意味します。これは主にミラーや別のリソースのバックアップに使用されます。そのような特定のケースを除いて、このステータスよりも「200 OK」応答の方が優先される。</target>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">このレスポンスは、クライアントからの事前のリクエストがなくても、いくつかのサーバによってはアイドル状態の接続に対して送信されます。これは、サーバがこの使用されていない接続をシャットダウンしたいことを意味します。このレスポンスは、Chrome、Firefox 27+、IE9 などの一部のブラウザでは、サーフィンを高速化するために HTTP プリコネクションメカニズムを使用しているため、より多く使用されています。また、このメッセージを送信せずに単に接続をシャットダウンするサーバもあることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">このレスポンスは、リクエストがサーバの現在の状態と競合した場合に送信されます。</target>
        </trans-unit>
        <trans-unit id="e9b8041c4bfcb3ea983601ee1d46fb89425a8ff6" translate="yes" xml:space="preserve">
          <source>This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">このレスポンスは、要求されたコンテンツがサーバから永久に削除され、転送アドレスがない場合に送信されます。クライアントはキャッシュとリソースへのリンクを削除することが期待されます。HTTP の仕様では、このステータスコードを「期間限定のプロモーションサービス」に使用することを意図しています。API は、このステータスコードで削除されたリソースを示すことを強制されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">この応答は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;サーバー主導のコンテンツネゴシエーションを&lt;/a&gt;実行した後、ユーザーエージェントによって指定された基準に従ってコンテンツが見つからない場合に送信されます。</target>
        </trans-unit>
        <trans-unit id="f98b7a29dead3c53a44ae4ec7ab268f3fe1c0fc6" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content that conforms to the criteria given by the user agent.</source>
          <target state="translated">この応答は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;サーバー主導のコンテンツネゴシエーションを&lt;/a&gt;実行した後、Webサーバーがユーザーエージェントによって指定された基準に一致するコンテンツを見つけられなかった場合に送信されます。</target>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">このレスポンスは、Chrome、Firefox 27+、IE9など、一部のブラウザではHTTPプリコネクションの仕組みを利用して高速化を図っているため、より多く利用されています。</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">このレスポンスは、サーバが無効な構文のためにリクエストを理解できなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">この応答は、要求されたコンテンツがサーバから永久に削除され、転送アドレスがない場合に送信されます。クライアントはキャッシュとリソースへのリンクを削除することが期待されます。HTTP の仕様では、このステータスコードを「期間限定のプロモーションサービス」に使用することを意図しています。API は、このステータスコードで削除されたリソースを示すことを強制されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="25f3e97dc8e2e8ca7707d926d10342dc166ba356" translate="yes" xml:space="preserve">
          <source>This restriction solves &quot;layout instability&quot; problem caused by providing default dimensions for images whose size is not specified in advance so that image doesn't change size after loading.</source>
          <target state="translated">この制限は、あらかじめサイズが指定されていない画像にデフォルトの寸法を与えることで、読み込み後に画像のサイズが変化しないようにすることで、「レイアウトの不安定さ」の問題を解決するものです。</target>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">このセクションでは、リクエストに前提条件を適用するためのHTTP / 1.1ヘッダーフィールドの構文とセマンティクスを定義します。 &lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;は、前提条件がいつ適用されるかを定義します。 &lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;では、複数の前提条件が存在する場合の評価の順序を定義します。</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">このセクションでは、キャッシングに関連するHTTP/1.1ヘッダフィールドの構文とセマンティクスを定義します。</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">この節では、すべての標準 HTTP/1.1 ヘッダフィールドの構文とセマンティクスを定義します。エンティティヘッダフィールドについては、送信者と受信者の両方がクライアントとサーバのどちらかを参照し、誰がそのエンティティを送信し、誰が受信するかに依存します。</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">このセクションでは、HTTP 認証フレームワークに関連するヘッダフィールドの構文とセマンティクスを定義します。</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;data&lt;/code&gt; URLの作成および使用時に一般的に発生する問題について説明します。</target>
        </trans-unit>
        <trans-unit id="cea338a7477f06ca64266e85820b20d68a3f92ae" translate="yes" xml:space="preserve">
          <source>This section describes restrictions on the TLS 1.2 feature set that
   can be used with HTTP/2.  Due to deployment limitations, it might not
   be possible to fail TLS negotiation when these restrictions are not
   met.  An endpoint MAY immediately terminate an HTTP/2 connection that
   does not meet these TLS requirements with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY.

   A deployment of HTTP/2 over TLS 1.2 MUST disable compression.  TLS
   compression can lead to the exposure of information that would not
   otherwise be revealed [&lt;a href=&quot;https://tools.ietf.org/html/rfc3749&quot;&gt;RFC3749&lt;/a&gt;].  Generic compression is unnecessary
   since HTTP/2 provides compression features that are more aware of
   context and therefore likely to be more appropriate for use for
   performance, security, or other reasons.

   A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation.  An
   endpoint MUST treat a TLS renegotiation as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that disabling 

   renegotiation can result in long-lived connections becoming unusable
   due to limits on the number of messages the underlying cipher suite
   can encipher.

   An endpoint MAY use renegotiation to provide confidentiality
   protection for client credentials offered in the handshake, but any
   renegotiation MUST occur prior to sending the connection preface.  A
   server SHOULD request a client certificate if it sees a renegotiation
   request immediately after establishing a connection.

   This effectively prevents the use of renegotiation in response to a
   request for a specific protected resource.  A future specification
   might provide a way to support this use case.  Alternatively, a
   server might use an error (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;) of type HTTP_1_1_REQUIRED to
   request the client use a protocol that supports renegotiation.

   Implementations MUST support ephemeral key exchange sizes of at least
   2048 bits for cipher suites that use ephemeral finite field Diffie-
   Hellman (DHE) [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;] and 224 bits for cipher suites that use
   ephemeral elliptic curve Diffie-Hellman (ECDHE) [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;RFC4492&lt;/a&gt;].  Clients
   MUST accept DHE sizes of up to 4096 bits.  Endpoints MAY treat
   negotiation of key sizes smaller than the lower limits as a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY.</source>
          <target state="translated">このセクションでは、HTTP / 2で使用できるTLS1.2機能セットの制限について説明します。展開の制限により、これらの制限が満たされていない場合、TLSネゴシエーションに失敗できない場合があります。エンドポイントは、これらのTLS要件を満たさないHTTP / 2接続を、タイプINADEQUATE_SECURITYの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）で即座に終了してもよい[MAY ]。 TLS1.2を介したHTTP / 2のデプロイでは、圧縮を無効にする必要があります。 TLS圧縮は、他の方法では明らかにされない情報の公開につながる可能性があります[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3749&quot;&gt;RFC3749&lt;/a&gt;]。 HTTP / 2はコンテキストをより認識し、パフォーマンス、セキュリティ、またはその他の理由での使用により適している可能性が高い圧縮機能を提供するため、一般的な圧縮は不要です。 TLS1.2を介したHTTP / 2の展開では、再ネゴシエーションを無効にする必要があります。エンドポイントはTLS再ネゴシエーションを接続エラーとして扱わなければなりません（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）タイプPROTOCOL_ERROR。再ネゴシエーションを無効にすると、基盤となる暗号スイートが暗号化できるメッセージの数が制限されるため、長期間有効な接続が使用できなくなる可能性があることに注意してください。エンドポイントは、ハンドシェイクで提供されるクライアント資格情報の機密保護を提供するために再ネゴシエーションを使用できますが、接続の序文を送信する前に再ネゴシエーションを実行する必要があります。サーバーは、接続を確立した直後に再ネゴシエーション要求を検出した場合、クライアント証明書を要求する必要があります。これにより、特定の保護されたリソースの要求に応じた再ネゴシエーションの使用が効果的に防止されます。将来の仕様では、このユースケースをサポートする方法が提供される可能性があります。または、サーバーがエラーを使用する場合があります（&lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt;）タイプHTTP_1_1_REQUIREDの場合、クライアントに再ネゴシエーションをサポートするプロトコルの使用を要求します。実装は、エフェメラル有限体Diffie-Hellman（DHE）[ &lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt; ]を使用する暗号スイートでは少なくとも2048ビット、エフェメラル楕円曲線Diffie-Hellman（ECDHE）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;RFC4492&lt;/a&gt; ]を使用する暗号スイートでは224ビットのエフェメラルキー交換サイズをサポートする必要があります。クライアントは、最大4096ビットのDHEサイズを受け入れる必要があります。エンドポイントは、下限よりも小さいキーサイズのネゴシエーションを、タイプINADEQUATE_SECURITYの接続エラー（&lt;a href=&quot;#section-5.4.1&quot;&gt;セクション5.4.1&lt;/a&gt;）として扱う場合があります。</target>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">このセクションでは、書き込みロックタイプに固有のセマンティクスについて説明します。書き込みロックは、ロックタイプの特定のインスタンスであり、この仕様で説明されている唯一のロックタイプです。排他的書き込みロックはリソースを保護します。これは、ロック作成者以外のプリンシパルによる変更や、ロックトークンが送信されない場合（たとえば、ロックを保持しているプロセス以外のクライアントプロセスによる変更）を防ぎます。クライアントは、書き込みロックされたリソースを変更する要求で使用することを許可されているロックトークンを送信する必要があります。書き込みロックの対象となる変更のリストには、次のものが含まれます。1.書き込みロックされたリソースの次の側面の変更：*バリアント、*デッドプロパティ、*ロック可能な任意のライブプロパティ（特に定義されていない限り、ライブプロパティはロック可能）。2.コレクションの場合、内部メンバーURIの変更。コレクションの内部メンバーURIは、追加、削除、または別のリソースを識別した場合、変更されたと見なされます。書き込みロックとコレクションの詳細については、 &lt;a href=&quot;#section-7.4&quot;&gt;セクション7.4&lt;/a&gt;。 3.書き込みロックのルートの、別のリソースへのマッピングまたはリソースなしへのマッピングの変更（例：DELETE）。 HTTPおよびWebDAVで定義されているメソッドのうち、PUT、POST、PROPPATCH、LOCK、UNLO​​CK、MOVE、COPY（宛先リソースの場合）、DELETE、およびMKCOLは書き込みロックの影響を受けます。これまでに定義された他のすべてのHTTP / WebDAVメソッド（特にGET）は、書き込みロックとは無関係に機能します。次のいくつかのセクションでは、書き込みロックがさまざまな操作とどのように相互作用するかをより具体的に説明します。</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">この節は、アプリケーション開発者、情報提供者、ユーザに、この文書で説明されている HTTP/1.1 のセキュリティ制限を知らせることを目的としています。この議論には、明らかになった問題に対する決定的な解決策は含まれていませんが、セキュリティリスクを軽減するためのいくつかの提案があります。</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">このセクションは、開発者、情報プロバイダー、およびユーザーに、HTTPセマンティクスに関連する既知のセキュリティ問題と、インターネット経由で情報を転送するためのその使用法を通知することを目的としています。メッセージの構文、解析、ルーティングに関する考慮事項&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;は、[RFC7230]のセクション9で&lt;/a&gt;説明されています。以下の考慮事項のリストは完全ではありません。 HTTPセマンティクスに関連するほとんどのセキュリティ上の懸念は、サーバー側アプリケーション（HTTPインターフェースの背後にあるコード）の保護、HTTP経由で受信したペイロードのユーザーエージェント処理の保護、またはプロトコルのセキュリティではなくインターネットの一般的な使用の保護に関するものです。さまざまな組織が、トピック情報と、Webアプリケーションセキュリティに関する現在の研究へのリンク（たとえば、[ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]）を維持しています。</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">このセクションは、HTTP認証に固有の既知のセキュリティ問題を開発者、情報プロバイダー、およびユーザーに通知することを目的としています。より一般的なセキュリティの考慮事項は、HTTPメッセージング[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]およびセマンティクス[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]。 HTTP認証のトピックに関するすべてはセキュリティ上の考慮事項であるため、以下の考慮事項のリストは完全ではありません。さらに、特定の認証スキーム（これらのスキームを定義する仕様で文書化する必要があります）のすべての潜在的な考慮事項について説明するのではなく、認証フレームワークに関するセキュリティの考慮事項に限定されます。さまざまな組織が、実際に見られる認証スキームの実装と使用に関する一般的な落とし穴など、トピック情報とWebアプリケーションセキュリティに関する現在の研究（[ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]など）へのリンクを維持しています。</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">このセクションは、HTTPキャッシングに固有の既知のセキュリティ問題を開発者、情報プロバイダー、およびユーザーに通知することを目的としています。より一般的なセキュリティの考慮事項は、HTTPメッセージング[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]およびセマンティクス[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]。キャッシュのコンテンツは悪意のある悪用の魅力的なターゲットであるため、キャッシュは潜在的な脆弱性をさらけ出します。キャッシュの内容はHTTPリクエストが完了した後も存続するため、ユーザーがネットワークから情報が削除されたとユーザーが信じた後も、キャッシュに対する攻撃によって情報が明らかになる可能性があります。したがって、キャッシュの内容は機密情報として保護する必要があります。特に、さまざまな攻撃が共有キャッシュに格納されることで増幅される可能性があります。このような「キャッシュポイズニング」攻撃は、キャッシュを使用して悪意のあるペイロードを多くのクライアントに配布します。特に攻撃者が実装の欠陥、昇格された特権、またはその他の手法を使用してそのような応答をキャッシュに挿入できる場合に効果的です。キャッシュポイズニングの一般的な攻撃方法の1つは、プロキシとユーザーエージェントのメッセージ解析の違いを悪用することです。見る &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;&lt;/a&gt;関連要件については、[RFC7230]のセクション3.3.3。同様に、実装の欠陥（およびキャッシュ操作の誤解）は、機密であると考えられる機密情報（認証資格情報など）のキャッシングにつながり、それを無許可の第三者に公開する可能性があります。さらに、キャッシュの使用そのものがプライバシーの問題を引き起こす可能性があります。たとえば、2人のユーザーがキャッシュを共有し、最初のユーザーがサイトを閲覧した場合、2番目のユーザーは、もう1人がそのサイトにアクセスしたことを検出できる可能性があります。 Set-Cookie応答ヘッダーフィールド[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]キャッシュを抑制しません。Set-Cookieヘッダーフィールドを持つキャッシュ可能な応答は、キャッシュへの後続の要求を満たすために使用できます（多くの場合、使用されます）。これらの応答のキャッシュを制御するサーバーは、適切なCache-Control応答ヘッダーフィールドを発行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">このセクションは、HTTP条件付き要求メカニズムに固有の既知のセキュリティ問題を開発者、情報プロバイダー、およびユーザーに通知することを目的としています。より一般的なセキュリティの考慮事項は、HTTPの「メッセージの構文とルーティング」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]および「セマンティクスとコンテンツ」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231で対処されています。&lt;/a&gt;]。この仕様で定義されているバリデーターは、表現の有効性を保証したり、悪意のある変更から保護したり、中間者攻撃を検出したりすることを意図していません。せいぜい、すべての参加者が適切に動作しているときに、より効率的なキャッシュ更新と楽観的な同時書き込みが可能になります。最悪の場合、条件は失敗し、クライアントは条件付き要求のないHTTP交換と同じくらい害のない応答を受け取ります。エンティティタグは、プライバシーリスクを引き起こす方法で悪用される可能性があります。たとえば、サイトは、ユーザーまたはユーザーエージェントに固有の意味的に無効なエンティティタグを意図的に作成し、それをキャッシュに入れられる応答で長い更新時間で送信します。その後、そのユーザーまたはユーザーエージェントを再識別する手段として、後の条件付きリクエストでそのエンティティタグを読み取ります。このような識別タグは、ユーザーエージェントが元のキャッシュエントリを保持している限り、永続的な識別子になります。表現をキャッシュするユーザーエージェントは、ユーザーが保存されたCookieのクリアやプライベートブラウジングモードへの変更などのプライバシーを維持するアクションを実行するたびに、キャッシュがクリアまたは置き換えられるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">このセクションは、HTTP範囲要求メカニズムに固有の既知のセキュリティ問題を開発者、情報プロバイダー、およびユーザーに通知することを目的としています。セキュリティに関するより一般的な考慮事項は、HTTPメッセージング[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]およびセマンティクス[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]で対処されています。</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">このセクションは、HTTPメッセージの構文、解析、およびルーティングに関連する既知のセキュリティの考慮事項について、開発者、情報プロバイダー、およびユーザーに通知することを目的としています。HTTPセマンティクスとペイロードに関するセキュリティの考慮事項は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]で対処されています。</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">このセクションでは、WebDAVアプリケーションが認識する必要のあるセキュリティの影響に関する問題について詳しく説明します。 HTTP / 1.1（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で説明）およびXML（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]で説明）のセキュリティに関する考慮事項はすべて、WebDAVにも適用されます。さらに、リモートオーサリングに固有のセキュリティリスクには、より強力な認証テクノロジーが必要であり、いくつかの新しいプライバシーの懸念が生じ、サーバーの設計が不十分な場合の危険性が高まる可能性があります。これらの問題の詳細は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">このセクションでは、クロスオリジン共有機能を利用するためにクライアントがHTTPリクエストを発行するときに使用できるヘッダーをリストします。これらのヘッダーは、サーバーを呼び出すときに設定されることに注意してください。クロスサイト&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;機能を使用する開発者は、クロスオリジン共有リクエストヘッダーをプログラムで設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">このセクションでは、このドキュメントと&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;との間の主要な変更点をリストします。実装の変更につながる可能性の高いものから始めます。サーバーは、DAV応答ヘッダーでコンプライアンスクラス「3」を返すことにより、この仕様のすべての変更のサポートをアドバタイズします（セクション&lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;および&lt;a href=&quot;#section-18.3&quot;&gt;18.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">このセクションでは、Cross-Origin Resource Sharing 仕様で定義されているアクセス制御要求に対してサーバが返す HTTP レスポンスヘッダの一覧を示します。前のセクションでは、これらの動作の概要を説明しました。</target>
        </trans-unit>
        <trans-unit id="27698771798e35901c64b1cc865da252efad8115" translate="yes" xml:space="preserve">
          <source>This section outlines attributes of the HTTP protocol that improve
   interoperability, reduce exposure to known security vulnerabilities,
   or reduce the potential for implementation variation.</source>
          <target state="translated">このセクションでは、相互運用性を向上させ、既知のセキュリティ脆弱性にさらされる可能性を低減し、実装のばらつきの可能性を低減する HTTP プロトコルの属性を概説します。</target>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">このセクションでは、ロックの動作に関する簡潔なモデルを提供します。後のセクションでは、いくつかの概念の詳細を説明し、これらのモデルステートメントを再度参照します。 LOCKおよびUNLOCKメソッドの処理に関連する規範的なステートメントは、これらのメソッドのセクションにありますが、任意のメソッドを網羅する規範的なステートメントはここにまとめられています。 1.ロックは、直接的または間接的にリソースをロックします。 2.リソースのURLへのLOCKリクエストが新しいロックを作成すると、リソースは直接ロックされます。新しいロックの「ロックルート」はそのURLです。リクエスト時にURLがリソースにマッピングされていない場合、新しい空のリソースが作成され、直接ロックされます。 3.排他ロック（&lt;a href=&quot;#section-6.2&quot;&gt;セクション6.2&lt;/a&gt;）ロックが直接か間接かに関係なく、同じリソースの他の種類のロックと競合します。サーバーはリソースに競合するロックを作成してはなりません（MUST NOT）。 4.深さ無限ロックLでロックされているコレクションの場合、すべてのメンバーリソースが間接的にロックされます。このようなコレクションのメンバーシップの変更は、間接的にロックされたリソースのセットに影響します。*メンバーリソースがコレクションに追加された場合、新しいリソースは、Lによって間接的にロックされる必要があるため、競合するロックをすでに持ってはなりません。メンバーリソースがコレクションのメンバーでなくなった場合、リソースはLによって間接的にロックされてはならない（MUST）。5。各ロックは、単一のグローバルに一意のロックトークン（&lt;a href=&quot;#section-6.5&quot;&gt;セクション6.5&lt;/a&gt;）。 6. UNLOCK要求は、指定されたロックトークンを持つロックを削除します。ロックが削除されると、そのロックによってロックされるリソースはなくなります。 7.ロックトークンは、「If」ヘッダーに表示されるときにリクエストで「送信」されます（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;、「書き込みロック」では、書き込みロックにトークンの送信が必要な場合について説明します）。 8.リクエストによってロックのロックルートがマップされていないURLになる場合、そのリクエストによってロックも削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">このセクションでは、Web リソースの一種であるコレクションについて説明し、HTTP URL 名前空間と HTTP メソッドとの相互作用について説明します。コレクションリソースの目的は、サーバの名前空間内でコレクションのようなオブジェクト(ファイルシステムのディレクトリなど)をモデル化することです。すべての DAV 準拠のリソースは、ここで指定された HTTP URL 名前空間モデルをサポートしなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">このセクションでは、いくつかの一般的なセキュリティポリシーのシナリオの例を示します。</target>
        </trans-unit>
        <trans-unit id="791632f4a575a961d693dba3896ef6d189e33a10" translate="yes" xml:space="preserve">
          <source>This section registers the &quot;PRI&quot; method in the &quot;HTTP Method Registry&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.1&quot;&gt;[RFC7231], Section&amp;nbsp;8.1&lt;/a&gt;).

   Method Name:  PRI

   Safe:  Yes

   Idempotent:  Yes

   Specification document(s):  &lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt; of this document

   Related information:  This method is never used by an actual client.
      This method will appear to be used when an HTTP/1.1 server or
      intermediary attempts to parse an HTTP/2 connection preface.</source>
          <target state="translated">このセクションでは、「PRI」メソッドを「HTTPメソッドレジストリ」（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.1&quot;&gt;[RFC7231]、セクション8.1&lt;/a&gt;）に登録します。メソッド名：PRIセーフ：はいべき等：はい仕様書：このドキュメントの&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;関連情報：このメソッドは、実際のクライアントでは使用されません。このメソッドは、HTTP /1.1サーバーまたは仲介者がHTTP / 2接続の序文を解析しようとするときに使用されるように見えます。</target>
        </trans-unit>
        <trans-unit id="0c8a15caa0998b07cccc63db3b596341d80032d0" translate="yes" xml:space="preserve">
          <source>This section registers the HTTP2-Settings header field in the
   &quot;Permanent Message Header Field Names&quot; registry [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Header field name:  HTTP2-Settings

   Applicable protocol:  http

   Status:  standard

   Author/Change controller:  IETF 

   Specification document(s):  &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt; of this document

   Related information:  This header field is only used by an HTTP/2
      client for Upgrade-based negotiation.</source>
          <target state="translated">このセクションでは、HTTP2-Settingsヘッダーフィールドを「PermanentMessage &lt;a href=&quot;#ref-BCP90&quot;&gt;HeaderFieldNames&lt;/a&gt;」レジストリ[ BCP90 ]に登録します。ヘッダーフィールド名：HTTP2-設定適用可能なプロトコル：httpステータス：標準作成者/変更コントローラー：IETF仕様ドキュメント：このドキュメントの&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション3.2.1&lt;/a&gt;関連情報：このヘッダーフィールドは、アップグレードのためにHTTP / 2クライアントによってのみ使用されますベースのネゴシエーション。</target>
        </trans-unit>
        <trans-unit id="f0ae1108ba21e7623f0028b8a84ebb3b288cc03e" translate="yes" xml:space="preserve">
          <source>This section shows HTTP/1.1 requests and responses, with
   illustrations of equivalent HTTP/2 requests and responses.

   An HTTP GET request includes request header fields and no payload
   body and is therefore transmitted as a single HEADERS frame, followed
   by zero or more CONTINUATION frames containing the serialized block
   of request header fields.  The HEADERS frame in the following has
   both the END_HEADERS and END_STREAM flags set; no CONTINUATION frames
   are sent.

     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==&amp;gt;     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg 

   Similarly, a response that includes only response header fields is
   transmitted as a HEADERS frame (again, followed by zero or more
   CONTINUATION frames) containing the serialized block of response
   header fields.

     HTTP/1.1 304 Not Modified        HEADERS
     ETag: &quot;xyzzy&quot;              ==&amp;gt;     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = &quot;xyzzy&quot;
                                          expires = Thu, 23 Jan 

   An HTTP POST request that includes request header fields and payload
   data is transmitted as one HEADERS frame, followed by zero or more
   CONTINUATION frames containing the request header fields, followed by
   one or more DATA frames, with the last CONTINUATION (or HEADERS)
   frame having the END_HEADERS flag set and the final DATA frame having
   the END_STREAM flag set:

     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==&amp;gt;     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   Note that data contributing to any given header field could be spread
   between header block fragments.  The allocation of header fields to
   frames in this example is illustrative only.

   A response that includes header fields and payload data is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames, followed by one or more DATA frames, with the last DATA frame
   in the sequence having the END_STREAM flag set: 

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&amp;gt;     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   An informational response using a 1xx status code other than 101 is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames.

   Trailing header fields are sent as a header block after both the
   request or response header block and all the DATA frames have been
   sent.  The HEADERS frame starting the trailers header block has the
   END_STREAM flag set.

   The following example includes both a 100 (Continue) status code,
   which is sent in response to a request containing a &quot;100-continue&quot;
   token in the Expect header field, and trailing header fields:

     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==&amp;gt;     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&amp;gt;     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-length = 123
     123                                  content-type = image/jpeg
     {binary data}                        trailer = Foo
     0
     Foo: bar                         DATA
                                        - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar</source>
          <target state="translated">このセクションでは、HTTP / 1.1の要求と応答を示し、同等のHTTP / 2の要求と応答を示します。 HTTP GETリクエストには、リクエストヘッダーフィールドが含まれ、ペイロードボディは含まれないため、単一のHEADERSフレームとして送信され、その後に、リクエストヘッダーフィールドのシリアル化されたブロックを含む0個以上のCONTINUATIONフレームが続きます。次のHEADERSフレームには、END_HEADERSフラグとEND_STREAMフラグの両方が設定されています。 CONTINUATIONフレームは送信されません。 GET / resource HTTP / 1.1 HEADERSホスト：example.org ==&amp;gt; + END_STREAM Accept：image / jpeg + END_HEADERS：method = GET：scheme = https：path = / resource host = example.org accept = image / jpeg同様に、応答ヘッダーフィールドのみを含む応答は、HEADERSフレームとして送信されます（ここでも、応答ヘッダーフィールドのシリアル化されたブロックを含む0個以上のCONTINUATIONフレームが続きます。 HTTP / 1.1304未変更HEADERSETag： &quot;xyzzy&quot; ==&amp;gt; + END_STREAM Expires：Thu、23 Jan ... + END_HEADERS：status = 304 etag = &quot;xyzzy&quot; expires = Thu、23Janリクエストを含むHTTPPOSTリクエストヘッダーフィールドとペイロードデータは、1つのHEADERSフレーム、リクエストヘッダーフィールドを含む0個以上のCONTINUATIONフレーム、1つ以上のDATAフレームとして送信され、最後のCONTINUATION（またはHEADERS）フレームにはEND_HEADERSフラグが設定され、最後のEND_STREAMフラグが設定されたDATAフレーム：POST / resource HTTP / 1.1 HEADERSホスト：example.org ==&amp;gt; --END_STREAM Content-Type：image / jpeg --END_HEADERS Content-Length：123：method = POST：path = / resource {binaryデータ}：スキーム= https CONTINUATION + END_HEADERS content-type = image / jpeg host = example.org content-length = 123 DATA + END_STREAM {バイナリデータ}特定のヘッダーフィールドに寄与するデータは、ヘッダーブロックフラグメント間で拡散される可能性があることに注意してください。この例でのフレームへのヘッダーフィールドの割り当ては、単なる例示です。ヘッダーフィールドとペイロードデータを含む応答は、HEADERSフレーム、0個以上のCONTINUATIONフレーム、1つ以上のDATAフレームとして送信され、シーケンスの最後のDATAフレームにはEND_STREAMフラグが設定されています：HTTP / 1.1 200 OK HEADERS Content-Type：image / jpeg ==&amp;gt; --END_STREAM Content-Length：123 + END_HEADERS：status = 200 {binary data} content-type = image / jpeg content-length = 123 DATA + END_STREAM {binary data} 101以外の1xxステータスコードを使用した情報応答がHEADERSフレームとして送信され、その後に0個以上のCONTINUATIONが続きます。フレーム。後続のヘッダーフィールドは、要求または応答ヘッダーブロックとすべてのDATAフレームの両方が送信された後、ヘッダーブロックとして送信されます。トレーラーヘッダーブロックを開始するHEADERSフレームには、END_STREAMフラグが設定されています。次の例には、Expectヘッダーフィールドに「100-continue」トークンを含むリクエストに応答して送信される100（Continue）ステータスコードと、末尾のヘッダーフィールドの両方が含まれています。HTTP/ 1.1 100 Continue HEADERS Extension-Field： bar ==&amp;gt;-END_STREAM + END_HEADERS：status = 100 extension-field = bar HTTP / 1.1 200 OK HEADERS Content-Type：image / jpeg ==&amp;gt;--END_STREAM転送-エンコーディング：チャンク+ END_HEADERSトレーラー：Foo：status = 200 content-length = 123 123 content-type = image / jpeg {binary data} trailer = Foo 0 Foo：bar DATA-END_STREAM {binary data} HEADERS + END_STREAM + END_HEADERS foo = bar</target>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">ここでは、HTTP/1.0とHTTP/1.1のバージョンの主な違いをまとめています。</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">このセクションは、他のメソッドの同様のセクションと同様に、PROPFINDで特に役立つ可能性のあるエラーコードと前提条件または事後条件（&lt;a href=&quot;#section-16&quot;&gt;セクション16で&lt;/a&gt;定義）に関するガイダンスを提供します。403 Forbidden-サーバーは、深さヘッダーが「Infinity」のコレクションに対するPROPFIND要求を拒否できます。その場合、このエラーは、エラー本文内の前提条件コード「propfind-finite-depth」で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee00e4e33c5031393996d9cbbb32237668a87ffc" translate="yes" xml:space="preserve">
          <source>This shows the server sending headers to tell the client to store a pair of cookies:</source>
          <target state="translated">これは、サーバがクライアントにクッキーのペアを保存するように指示するためにヘッダを送信していることを示しています。</target>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">このシンプルなHTMLファイルは、ブラウザに表示されるのではなく、通常のダウンロードとして保存されます。ほとんどのブラウザは、 &lt;code&gt;cool.html&lt;/code&gt; ファイル名（デフォルト）で保存することを提案します。</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">このシンプルなモデルでは、パフォーマンスに生来の制限があります。クライアントとサーバの間でいくつかのメッセージを交換しなければなりません。ネットワークのレイテンシと帯域幅は、リクエストを送信する必要があるときのパフォーマンスに影響を与えます。最近のウェブページでは、必要な情報量を提供するために多くのリクエスト(十数個)を必要とし、この初期のモデルが非効率的であることが証明されています。</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">このソリューションはより効率的ですが、条件では1つのエタグしか使用できないため、柔軟性が若干低下します。このような追加の柔軟性が必要とされることは稀です。</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">この仕様は、リンク関係のAtomレジストリに値「edit」を追加します（&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]のセクション7.1を&lt;/a&gt;参照）。&quot;edit&quot;の値は、href属性の値が編集可能なメンバーエントリのIRIであることを指定します。atom：entry内に表示される場合、href IRIを使用して、そのエントリーで表されるリソースを取得、更新、および削除できます。atom：entryには、複数の「編集」リンク関係を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">この仕様は、リンク関係のAtomレジストリに値「edit-media」を追加します（&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]のセクション7.1を&lt;/a&gt;参照）。）。 atom：entry内に表示される場合、href属性の値は、そのエントリに関連付けられたメディアリソースを変更するために使用できるIRIです。 atom：entry要素には、0個以上の「編集-メディア」リンク関係を含めることができます（MAY）。 atom：entryには、「rel」属性値が「edit-media」で、同じ「type」属性値と「hreflang」属性値を持つ複数のatom：link要素を含めてはなりません（MUST NOT）。同じエントリ内のすべての「編集-メディア」リンク関係は、同じリソースを参照します。クライアントがエントリで複数の「編集メディア」リンク関係に遭遇した場合、クライアントは「タイプ」と「hreflang」のクライアント設定に基づいてリンクを選択する必要があります。クライアントが複数の「編集メディア」に遭遇した場合エントリ内のリレーションをリンクし、「type」属性と「hreflang」属性に基づく設定がない場合、クライアントはドキュメントの順序で最初の「edit-media」リンクリレーションを選択する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">本仕様では、&quot;application/atom+xml &quot;メディアタイプで使用するための新しい &quot;type &quot;パラメータを定義する。type &quot;パラメータの値は &quot;entry &quot;または &quot;feed &quot;である。パラメータ名もその値も大文字小文字を区別しない。値「entry」は、メディアタイプがAtomエントリ文書を識別することを示す。ドキュメントのルート要素は atom:entry でなければならない[MUST]。値「feed」は、メディアタイプが Atom フィードドキュメントを識別することを示す。文書のルート要素は atom:feed でなければならない(MUST)。指定されない場合、型は未指定とみなされ、Atomプロセッサはルート要素を調べてAtom文書の型を決定する必要がある。</target>
        </trans-unit>
        <trans-unit id="f81e275d5b5e2405f6e31db20010a4f63cffd1c9" translate="yes" xml:space="preserve">
          <source>This specification defines a number of frame types, each identified
   by a unique 8-bit type code.  Each frame type serves a distinct
   purpose in the establishment and management either of the connection
   as a whole or of individual streams.

   The transmission of specific frame types can alter the state of a
   connection.  If endpoints fail to maintain a synchronized view of the
   connection state, successful communication within the connection will
   no longer be possible.  Therefore, it is important that endpoints
   have a shared comprehension of how the state is affected by the use
   any given frame.</source>
          <target state="translated">本仕様では、8 ビットのユニークなタイプコードで識別される多数のフレームタイプを定義します。各フレームタイプは、接続全体または個々のストリームのいずれかの確立と管理において明確な目的を果たす。特定のフレームタイプの送信は、接続の状態を変化させることができます。エンドポイントが接続状態の同期化されたビューを維持できない場合、接続内での正常な通信はもはや不可能になります。したがって、エンドポイントが、任意のフレームの使用によって状態がどのように影響を受けるかについて、共通の理解を持つことが重要です。</target>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">この仕様は、「&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;」名前空間内でコントロールを公開するために&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;、[RFC4287]のセクション6で&lt;/a&gt;定義されているAtom形式の構造化拡張を定義します。</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">この仕様は、HTTPステータスコードを定義していますo 207マルチステータス（&lt;a href=&quot;#section-11.1&quot;&gt;セクション11.1&lt;/a&gt;）o 422処理できないエンティティ（&lt;a href=&quot;#section-11.2&quot;&gt;セクション11.2&lt;/a&gt;）、o 423ロック（&lt;a href=&quot;#section-11.3&quot;&gt;セクション11.3&lt;/a&gt;）、o 424失敗した依存関係（&lt;a href=&quot;#section-11.4&quot;&gt;セクション11.4&lt;/a&gt;）および507不十分なストレージ（&lt;a href=&quot;#section-11.5&quot;&gt;セクション11.5&lt;/a&gt;） 、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;のレジストリで更新されます。注：HTTPステータスコード102（処理中）は、この仕様では削除されています。 IANA登録は引き続き&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;を参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">この仕様は、2つのURIスキームを定義します。1。&lt;a href=&quot;#appendix-C&quot;&gt;付録C&lt;/a&gt;で定義された「opaquelocktoken」スキームと、&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2。WebDAV&lt;/a&gt;プロパティとXML要素名を明確にするために[ RFC2518 ] で歴史的に使用された「DAV」URIスキーム。この仕様およびその他のWebDAVを拡張する目的で使用されます。 「DAV：」名前空間での識別子の作成は、IETFによって制御されます。 XML名前空間に新しいURIスキームを定義することは現在推奨されていないことに注意してください。 「DAV：」は、標準のベストプラクティスが出現する前に定義されました。</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">この仕様は、リソースの状態を監視して前提条件をテストするために一般的に使用される2つの形式のメタデータを定義します。変更日付（&lt;a href=&quot;#section-2.2&quot;&gt;セクション2.2&lt;/a&gt;）と不透明なエンティティタグ（&lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt;）です。リソースの状態を反映する追加のメタデータは、この仕様の範囲を超える、Web分散オーサリングやバージョン管理（WebDAV、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ]）などのHTTPのさまざまな拡張機能によって定義されています。リソースメタデータ値は、前提条件内で使用される場合、「バリデーター」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">この仕様では、カテゴリドキュメントとサービスドキュメントの2種類のドキュメントを定義しています。カテゴリドキュメント（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）には、Atom Syndication Format（&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;[RFC4287]のセクション4.2.2を&lt;/a&gt;参照）の &quot;atom：category&quot;要素を使用して指定されたカテゴリのリストが含まれています。サービスドキュメント（&lt;a href=&quot;#section-8&quot;&gt;セクション8&lt;/a&gt;）は、使用可能なコレクションをワークスペースにグループ化します。いずれかの種類のドキュメントの名前空間名[ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt; ]は、次のとおりです&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;。http&lt;/a&gt;： //www.w3.org/2007/app Atom Publishing Protocol XMLドキュメントは、セクション7で指定されている「namespace-well-formed」でなければなりません[ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;]。この仕様では、名前空間名に接頭辞「app：」を使用しています。接頭辞「atom：」は、Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] の名前空間名である「&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;」に使用されます。これらの名前空間接頭辞は、意味的に重要ではありません。この仕様では、Atomプロトコル形式のDTDは定義されていないため、[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] で使用される意味で「有効」である必要はありません。</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">この仕様では、既存のコレクションに対するPUTメソッドの動作は定義されていません。既存のコレクションへのPUTリクエストは、エラー(405 Method Not Allowed)として処理してもよい[MAY]。MKCOL メソッドはコレクションを作成するために定義されています。</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">この仕様では、空間と時間全体での一意性を保証するために、ロックトークン（&lt;a href=&quot;#section-6.5&quot;&gt;セクション6.5&lt;/a&gt;）に「汎用一意識別子（UUID）URN名前空間」（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ]）を使用することを推奨しています。バージョン1 UUID（&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;定義））「ノード」フィールドを含めることができます。「IEEE 802 MACアドレス、通常はホストアドレスで構成されます。複数のIEEEアドレスを持つシステムの場合、使用可能なアドレスを使用できます」。 WebDAVサーバーはその存続期間中に多くのロックを発行するため、IEEE 802アドレスを公開している可能性もあります。 IEEE 802アドレスの公開に関連するいくつかのリスクがあります。 IEEE 802アドレスの使用：oサブネット間でのハードウェアの移動を追跡することが可能です。 o WebDAVサーバーを実行しているハードウェアの製造元を特定できる場合があります。 o WebDAVを実行している各タイプのコンピューターの数を判別できる場合があります。このリスクは、ホストアドレスベースのUUIDバージョンにのみ適用されます。 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;[RFC4122]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;セクション&lt;/a&gt;4は、ホストアドレスを含まないため、このリスクの影響を受けないUUIDを生成するための他のいくつかのメカニズムについて説明しています。</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">この仕様は、キーワードの使用を修正および明確にするために慎重に監査されています。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068に&lt;/a&gt;は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ] で規定された規則に関して多くの問題がありました。受信サーバーの障害（DNS障害など）に使用するエラーコードを明確にしました。 （&lt;a href=&quot;#section-10.5.5&quot;&gt;セクション10.5.5&lt;/a&gt;）。 CREATEには、リソースが最初に作成されたときにEtagを送信する必要がある競合がありました。 （&lt;a href=&quot;#section-10.2.2&quot;&gt;セクション10.2.2&lt;/a&gt;）。 Content-Baseは仕様から削除されました。それは広く実装されておらず、堅牢な拡張メカニズムなしに導入する簡単で安全な方法はありません。また、MHTMLでも同様に使用されていますが、同一ではありません[ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]。転送コーディングとメッセージの長さはすべて、チャンクエンコーディングが使用されるときに正確に修正する必要がある方法で相互作用します（自己区切りではない可能性がある転送エンコーディングを可能にするため）。メッセージの長さの計算方法を正確に正確にすることが重要でした。 （セクション3.6、4.4、7.2.2、13.5.2、14.13、14.16）キャッシングで発見された問題を解決するために、「アイデンティティ」のコンテンツコーディングが導入されました。 （&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）ゼロの品質値は、クライアントが表現を拒否できるようにするために、「何かが欲しくない」ことを示す必要があります。 （&lt;a href=&quot;#section-3.9&quot;&gt;セクション3.9&lt;/a&gt;）HTTPバージョン番号の使用と解釈は&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145で&lt;/a&gt;明確にされています。 HTTP / 1.0実装で発見された問題に対処するために、プロキシがサポートする最高のプロトコルバージョンにリクエストをアップグレードする必要があります（&lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt;）。 （&lt;a href=&quot;#section-14.2&quot;&gt;セクション14.2&lt;/a&gt;）HTTP / 1.1のCache-Controlモデルでケースが見落とされました。この欠落したケースを追加するためにs-maxageが導入されました。 （セクション&lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;、&lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;、&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;、14.9.3）のCache-Control：MAX-ageディレクティブが適切に応答するために定義されていませんでした。 （&lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3&lt;/a&gt;）サーバー（特にプロキシ）が応答の完全な長さを認識していないが、バイト範囲の要求を処理できる場合があります。したがって、メッセージの全長を示さないcontent-rangeを持つバイト範囲を許可するメカニズムが必要です。 （&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt;）すべてのメタデータが常に返される場合、範囲要求の応答は非常に冗長になります。サーバーが206応答で必要なヘッダーのみを送信できるようにすることで、この問題を回避できます。 （&lt;a href=&quot;#section-10.2.7&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;、13.5.3、および14.27）満足できない範囲のリクエストに関する問題を修正しました。 2つのケースがあります。構文上の問題と、ドキュメントに範囲が存在しない場合です。文書の実際のコンテンツの範囲外にあるバイト範囲要求のエラーを示すために必要なこのあいまいさを解決するために、416ステータスコードが必要でした。 （&lt;a href=&quot;#section-10.4.17&quot;&gt;セクション10.4.17&lt;/a&gt;、14.16）ここでのエラーの結果はインターネットに大きな影響を与える可能性があり、次の問題に対処できるため、実装者が誤解するのをはるかに困難にするメッセージ送信要件の書き換え：1.「HTTP / 1.1またはこれは、HTTP / 1.x 2の将来のバージョンの実装の動作に誤って要件を課していたコンテキストでは、「クライアント」ではなく、ユーザーエージェントが要求を再試行する必要があることを明確にしました。 &quot; 一般に。 3.クライアントが予期しない100（続行）応答を無視するための要件と、プロキシが100応答を転送するための要件を、1xx応答の一般要件に変換しました。 4.一部のTCP固有の言語を変更しました。HTTPで非TCPトランスポートが可能であることを明確にするため。 5.オリジンサーバーが必要な100（Continue）応答を送信する前に、リクエストボディを待機してはならないことを要求します。 6.要求本文の一部がすでに表示されている場合は、サーバーが100（続行）を省略できるようにします。 7.サーバーがサービス拒否攻撃や壊れたクライアントから防御できるようにします。この変更により、Expectヘッダーと417ステータスコードが追加されます。メッセージ送信要件の修正はセクションにありますサーバーがリクエスト本文の一部をすでに確認している場合は、100（続行）を省略します。 7.サーバーがサービス拒否攻撃や壊れたクライアントから防御できるようにします。この変更により、Expectヘッダーと417ステータスコードが追加されます。メッセージ送信要件の修正はセクションにありますサーバーがリクエスト本文の一部をすでに確認している場合は、100（続行）を省略します。 7.サーバーがサービス拒否攻撃や壊れたクライアントから防御できるようにします。この変更により、Expectヘッダーと417ステータスコードが追加されます。メッセージ送信要件の修正はセクションにあります&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;、&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;、8.1.2.2、13.11、及び14.20。プロキシは、必要に応じてContent-Lengthを追加できる必要があります。 （&lt;a href=&quot;#section-13.5.2&quot;&gt;セクション13.5.2&lt;/a&gt;）403応答と404応答の混乱を解消します。 （&lt;a href=&quot;#section-10.4.4&quot;&gt;セクション&lt;/a&gt; 10.4.4、10.4.5、および10.4.11）警告は誤ってキャッシュされるか、適切に更新されない可能性があります。 （&lt;a href=&quot;#section-13.1.2&quot;&gt;セクション13.1.2&lt;/a&gt;、13.2.4、13.5.2、13.5.3、14.9.3、および14.46）PUTまたは他のメソッドがリクエストで必要とする場合があるため、警告も一般的なヘッダーである必要があります。転送コーディングには、特にチャンクエンコーディングとのやり取りで重大な問題がありました。解決策は、転送コーディングがコンテンツコーディングと同じくらい本格的なものになることです。これには、転送コーディング（コンテンツコーディングとは別）のIANAレジストリの追加、新しいヘッダーフィールド（TE）、および将来のトレーラーヘッダーの有効化が含まれます。転送エンコーディングはパフォーマンス上の大きな利点であるため、修正する価値がありました[ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]。 TEはまた、認証トレーラー、チャンクエンコーディング、およびHTTP / 1.0クライアント間の相互作用が原因で発生する可能性がある、別のあいまいな下位相互運用性の問題も解決します。（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;、3.6.1、および14.39）PATCH、LINK、UNLINKメソッドが定義されましたが、この仕様の以前のバージョンでは一般的に実装されていませんでした。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]を参照してください。Alternates、Content-Version、Derived-From、Link、URI、Public、およびContent-Baseヘッダーフィールドは、この仕様の以前のバージョンで定義されていましたが、一般的には実装されていませんでした。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]を参照してください。</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">この仕様は、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]のためにDavid H. Crockerによって定義された拡張BNFと一般的な構成を多用しています。同様に、MIMEのNathaniel BorensteinとNed Freedによって提供された定義の多くを再利用します[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]。この仕様に含めることで、HTTPとインターネットメールメッセージフォーマット間の関係に関する過去の混乱を減らすのに役立つことを願っています。 HTTPプロトコルは、長年にわたってかなり進化してきました。これは、大規模でアクティブな開発者コミュニティ（www-talkメーリングリストに参加した多くの人々）の恩恵を受けており、HTTPとWorld-Wide Webの成功に最も責任があるのは、そのコミュニティです。一般的な。マークアンドリーセン、ロバートカイリア、ダニエルW.コノリー、ボブデニー、ジョンフランク、ジャンフランソワグロフ、フィリップM.ハラムベイカー、ホーコンW.リー、アリルオトネン、ロブマックール、ルーモントゥリ、デイブラゲット、トニーサンダース、 Marc VanHeyningenは、プロトコルの初期段階を定義する彼らの努力に対して特別な評価を受けるに値します。このドキュメントは、HTTP-WGに参加しているすべての人々のコメントから大きな恩恵を受けています。すでに言及したものに加えて、次の個人がこの仕様に貢献しました：ゲイリーアダムスロスパターソンハラルドトベイトアルヴェストランドアルバートルンドキースボールジョンC.ローマンチボラビルペリーマイケルA.ドランジェフリーペリーデビッドJ.フィアンダースコットパワーズアランフレイアーオーウェンリースマルクヘドルンドルイージリッツォグレッグハーリヒデビッドロビンソンコーンホルトマンマークサロモンアレックスホップマンリッチサルツボブジャーニガンアランM.シフマンシェルカパンジムザイドマンロヒトカーレチャックショットンジョンクレシンエリックW.シンクマーティンコスターサイモンE. KosutリチャードN.テイラーデビッドM.クリストルロバートS.タウダニエルラリベルテビル（ベアハート）ウェインマンベンローリーフランソワヤーゴーポールJ.リーチメアリーエレンズルコダニエルデュボアジョシュコーエンキャッシングデザインのコンテンツとプレゼンテーションの多くは、シェルカパン、ポールリーチ、ケンホルトマン、デビッドモリス、ラリーマスインターなどの個人からの提案とコメントによるものです。範囲の仕様のほとんどは、元々Ari LuotonenとJohn Franksによって行われた作業に基づいており、Steve Zillesからの追加の入力があります。パロアルトの「洞窟男性」に感謝します。あなたはあなたが誰であるか知っています。 Jim Gettys（このドキュメントの現在の編集者）は、John Klensin、Jeff Mogul、Paul Leach、Dave Kristol、Koen Holtman、John Franks、Josh Cohen、Alex Hopmann、このドキュメントの以前の編集者であるRoy Fieldingに特に感謝します。スコット・ローレンスとラリー・マシンターの協力。そして、「MUST / MAY / SHOULD」監査を実行してくれたJeff MogulとScott Lawrenceに特に感謝します。 Apache Group、ジグソーの作者であるAnselm Baird-Smith、およびHenrik Frystykが実装されました&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068は&lt;/a&gt;早く、このドキュメントで修正しようとしている問題の多くを発見してくれたことに感謝したいと思います。</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">この仕様では、動的にトンネルに切り替えることができるプロキシ（SSLトンネリング[ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]など）で使用するために、メソッド名CONNECTが予約されています。</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">この仕様は、以前に&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617で&lt;/a&gt;定義されたHTTP認証フレームワークの定義を引き継ぎます。ジョンフランクス、フィリップM.ハラムベイカー、ジェフリーL.ホステラー、スコットD.ローレンス、ポールJ.リーチ、アリルオトネン、およびローレンスC.スチュワートにその仕様に関する作業を感謝します。さらなる謝辞について&lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;は[RFC2617]のセクション6を&lt;/a&gt;見てください。このドキュメントの改訂に関連する謝辞については、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]のセクション10を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">この仕様は、HTTP通信の参加者の役割に応じた適合基準を対象としている。したがって、HTTP要求は、要求によって制約される動作に応じて、送信者、受信者、クライアント、サーバ、ユーザエージェント、仲介者、オリジンサーバ、プロキシ、ゲートウェイ、またはキャッシュに置かれる。追加の(社会的な)要件は、単一の通信の範囲を超えて適用される場合、実装、リソースの所有者、プロトコル要素の登録に置かれる。send」の代わりに動詞「generate」が使用される。ここでは、要件がプロトコル要素を作成することと、受信した要素を単に下流に転送することとを区別する。実装は、それがHTTPで担う役割に関連するすべての要件に準拠していれば、適合しているとみなされます。適合性には、プロトコル要素の構文とセマンティクスの両方が含まれます。送信者は、その送信者が偽であることがわかっている意味を伝えるプロトコル要素を生成してはならない[MUST NOT]。送信者は、対応するABNF規則で定義された文法に合致しないプロトコル要素を生成してはならない[MUST NOT]。あるメッセージ内で、送信者は、他のロール(すなわち、送信者がそのメッセージに対して持っていないロール)の参加者によってのみ生成が許可されるプロトコル要素や構文の代替を生成してはならない[MUST NOT]。受信したプロトコル要素が解析されるとき、受信者は、受信者のロールに適用可能で、対応するABNFルールで定義された文法に一致する、妥当な長さの値をすべて解析できなければならない[MUST]。しかし、受信したプロトコル要素の中には解析できないものもあることに注意すること。例えば、メッセージを転送する仲介者は、ヘッダフィールドを一般的なフィールド名と フィールド値のコンポーネントに解析して、フィールド値の内部をさらに解析せずに ヘッダフィールドを転送するかもしれない。適切な長さは実装のコンテキストや目的によって大きく異なるため、HTTPの多くのプロトコル要素には特定の長さの制限はありません。したがって、送信者と受信者の間の相互運用性は、各プロトコル要素の妥当な長さが何であるかについての共通の期待に依存します。さらに、いくつかのプロトコル要素の妥当な長さと一般的に理解されているものは、過去20年間のHTTP使用の間に変化しており、今後も変化し続けると予想されています。最低でも、受信者は、他のメッセージで同じプロトコルエレメントに対して生成される値と少なくとも同じ長さのプロトコルエレメントの長さを解析して処理することができなければなりません[MUST]。例えば、それ自身のリソースに対して非常に長いURI参照を公開するオリジンサーバー は、リクエストターゲットとして受け取ったときにそれらの同じ参照を解析して処理でき る必要がある。受信者は、受信者が(経験や設定を通して)送信者がそれらのセマンティクスで暗示されて いることを誤って実装していると受信者が判断しない限り、この仕様の拡張を含め、この 仕様で定義されているセマンティクスに従って受信したプロトコルエレメントを解釈しな ければならない[MUST]。例えば、オリジンサーバーは、User-Agentヘッダーフィールドの検査が、特定のコンテン ツコーディングの受信で失敗することが知られている特定の実装バージョンを 示す場合、受信したAccept-Encodingヘッダーフィールドの内容を無視するかもしれない。別段の断りがない限り、受信者は無効な構文から使用可能なプロトコルエレメン トを回復しようと試みてもよい[MAY]。HTTPは、プロトコルの異なるアプリケーションが異なるエラー処理戦略を必要とするため、セキュリティに直接影響を与える場合を除き、特定のエラー処理メカニズムを定義しません。例えば、Web ブラウザは Location ヘッダフィールドが ABNF に従ってパースされない応答から透過的に回復したいと思うかもしれませんが、システム制御クライアントはどのような形式のエラー回復も危険であると考えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">この仕様では、HTTP通信の参加者とHTTP通信のオブジェクトが果たす役割を指すために、いくつかの用語を使用しています。接続通信を目的として2つのプログラム間に確立されたトランスポート層仮想回線。メッセージHTTP通信の基本単位。&lt;a href=&quot;#section-4&quot;&gt;セクション4で&lt;/a&gt;定義された構文に一致し、接続を介して送信されるオクテットの構造化されたシーケンスで構成されます。 request &lt;a href=&quot;#section-5&quot;&gt;セクション5で&lt;/a&gt;定義されているHTTPリクエストメッセージ。 response &lt;a href=&quot;#section-6&quot;&gt;セクション6で&lt;/a&gt;定義されているHTTP応答メッセージ。リソース&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2で&lt;/a&gt;定義されている、URIで識別できるネットワークデータオブジェクトまたはサービス。リソースは、複数の表現（複数の言語、データ形式、サイズ、解像度など）で利用できる場合と、他の方法で異なる場合があります。エンティティリクエストまたはレスポンスのペイロードとして転送される情報。エンティティは、&lt;a href=&quot;#section-7&quot;&gt;セクション7で&lt;/a&gt;説明するように、エンティティヘッダーフィールドの形式のメタ情報とエンティティ本体の形式のコンテンツで構成されます。表現&lt;a href=&quot;#section-12&quot;&gt;セクション12で&lt;/a&gt;説明されているように、コンテンツネゴシエーションの対象となる応答に含まれるエンティティ。特定の応答ステータスに関連付けられた複数の表現が存在する場合があります。コンテンツネゴシエーション&lt;a href=&quot;#section-12&quot;&gt;セクション12で&lt;/a&gt;説明されている、要求を処理するときに適切な表現を選択するためのメカニズム。応答内のエンティティの表現は、ネゴシエートできます（エラー応答を含む）。バリアントAリソースには、任意の瞬間に1つまたは複数の表現が関連付けられている場合があります。これらの表現のそれぞれを「バリアント」と呼びます。 「バリアント」という用語の使用は、リソースがコンテンツネゴシエーションの対象であることを必ずしも意味しません。クライアント要求を送信する目的で接続を確立するプログラム。ユーザーエージェントリクエストを開始するクライアント。これらは、多くの場合、ブラウザー、エディター、スパイダー（Webトラバースロボット）、またはその他のエンドユーザーツールです。サーバー応答を送り返すことによって要求を処理するために接続を受け入れるアプリケーションプログラム。特定のプログラムは、クライアントとサーバーの両方になることができます。これらの用語の使用は、プログラムの一般的な機能ではなく、特定の接続に対してプログラムによって実行される役割のみを指します。同様に、どのサーバーもオリジンサーバー、プロキシ、ゲートウェイ、またはトンネルとして機能し、各リクエストの性質に基づいて動作を切り替えます。起点サーバー特定のリソースが存在するサーバー、または作成されるサーバー。プロキシ他のクライアントに代わってリクエストを行う目的でサーバーとクライアントの両方として機能する中間プログラム。要求は、内部的に、または可能な変換を使用して他のサーバーに渡すことによって処理されます。プロキシは、この仕様のクライアント要件とサーバー要件の両方を実装する必要があります。「透過プロキシ」は、プロキシの認証と識別に必要なものを超えて要求または応答を変更しないプロキシです。 「非透過プロキシ」とは、グループアノテーションサービス、メディアタイプ変換、プロトコル削減、匿名フィルタリングなどの追加サービスをユーザーエージェントに提供するために、要求または応答を変更するプロキシです。透過的または非透過的な動作が明示的に述べられている場合を除き、HTTPプロキシ要件は両方のタイプのプロキシに適用されます。ゲートウェイ他のサーバーの仲介として機能するサーバー。プロキシとは異なり、ゲートウェイはリクエストされたリソースのオリジンサーバーであるかのようにリクエストを受信します。要求元のクライアントは、ゲートウェイと通信していることを認識していない場合があります。トンネル2つの接続間のブラインドリレーとして機能する中間プログラム。いったんアクティブになると、トンネルはHTTP通信の当事者とは見なされませんが、トンネルはHTTP要求によって開始された可能性があります。リレーされた接続の両端が閉じられると、トンネルは存在しなくなります。キャッシュプログラムの応答メッセージのローカルストアと、メッセージの保存、取得、削除を制御するサブシステム。キャッシュは、将来の同等の要求での応答時間とネットワーク帯域幅の消費を削減するために、キャッシュ可能な応答を格納します。トンネルとして機能しているサーバーはキャッシュを使用できませんが、クライアントまたはサーバーにはキャッシュを含めることができます。cacheableキャッシュは、後続の要求への応答に使用するために応答メッセージのコピーを保存することが許可されている場合、キャッシュ可能です。 HTTP応答のキャッシュ可能性を決定するためのルールは、&lt;a href=&quot;#section-13&quot;&gt;セクション13&lt;/a&gt;。リソースがキャッシュ可能である場合でも、特定の要求に対してキャッシュがキャッシュされたコピーを使用できるかどうかに追加の制約がある場合があります。 first-handおそらく1つまたは複数のプロキシを介して、オリジンサーバーから直接、かつ不必要な遅延なしに返される場合、応答は直接的なものです。オリジンサーバーで直接有効性を確認した直後の場合も、レスポンスは直接的なものです。明示的な有効期限起点サーバーが、エンティティをさらに検証しないとキャッシュから返されないようにする予定の時間。ヒューリスティック有効期限明示的な有効期限がない場合にキャッシュによって割り当てられる有効期限。 age応答の経過時間は、元のサーバーから送信されてから、または正常に検証されてからの時間です。フレッシュネスライフタイム応答の生成とその有効期限の間の時間の長さ。フレッシュ年齢がフレッシュネスライフタイムを超えていない場合、レスポンスはフレッシュです。古くなった存続期間が経過すると、応答は古くなります。意味的に透過的キャッシュは、特定の応答に関して「意味的に透過的」な方法で動作します。キャッシュの使用は、パフォーマンスの向上を除いて、要求側のクライアントにもオリジンサーバーにも影響を与えません。キャッシュが意味的に透過的である場合、クライアントは、要求がオリジンサーバーによって直接処理された場合とまったく同じ応答（ホップバイホップヘッダーを除く）を受け取ります。バリデータープロトコル要素（例えば、エンティティタグまたはLast-Modified時間）。これは、キャッシュエントリがエンティティの同等のコピーであるかどうかを確認するために使用されます。アップストリーム/ダウンストリームアップストリームとダウンストリームは、メッセージのフローを示します。すべてのメッセージは、アップストリームからダウンストリームに流れます。インバウンド/アウトバウンドインバウンドおよびアウトバウンドは、メッセージのリクエストおよびレスポンスパスを指します。「インバウンド」は「オリジンサーバーに向かう」を意味し、「アウトバウンド」は「ユーザーエージェントに向かう」を意味しますインバウンド/アウトバウンドインバウンドおよびアウトバウンドは、メッセージのリクエストおよびレスポンスパスを指します。「インバウンド」は「オリジンサーバーに向かう」を意味し、「アウトバウンド」は「ユーザーエージェントに向かう」を意味しますインバウンド/アウトバウンドインバウンドおよびアウトバウンドは、メッセージのリクエストおよびレスポンスパスを指します。「インバウンド」は「オリジンサーバーに向かう」を意味し、「アウトバウンド」は「ユーザーエージェントに向かう」を意味します</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">この仕様では、&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;で定義されたリスト拡張付きの[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]の拡張バッカスナウアフォーム（ABNF）表記を使用し、「＃」演算子を使用してコンマ区切りリストをコンパクトに定義できます（「* '演算子は繰り返しを示します）。 &lt;a href=&quot;#appendix-B&quot;&gt;付録B&lt;/a&gt;は、すべてのリスト演算子が標準のABNF表記に拡張された、収集された文法を示しています。&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]、付録B.1で&lt;/a&gt;定義されているように、次のコアルールが参照により含まれています ：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、DIGIT（10進数の0-9）、DQUOTE（二重引用符）、HEXDIG（16進数の0-9 / AF / af）、HTAB （水平タブ）、LF（ラインフィード）、OCTET（データの任意の8ビットシーケンス）、SP（スペース）、およびVCHAR（表示可能な[ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]文字）。慣例として、「obs-」で始まるABNFルール名は、歴史的な理由で現れる「廃止された」文法ルールを示します。</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">この仕様では、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC7230&lt;/a&gt; ]の&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;セクション7で&lt;/a&gt;定義されている、リスト拡張付きの[ RFC5234 ] のAugmented Backus-Naur Form（ABNF）表記を使用します。これにより、「＃」演算子を使用してコンマ区切りリストをコンパクトに定義できます（ 「*」演算子が繰り返しを示す方法）。 &lt;a href=&quot;#appendix-B&quot;&gt;付録Bでは&lt;/a&gt;、他のドキュメントからインポートされたルールについて説明します。 &lt;a href=&quot;#appendix-C&quot;&gt;付録C&lt;/a&gt;は、すべてのリスト演算子が標準のABNF表記に拡張された、収集された文法を示しています。</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">この仕様では、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] のAugmented Backus-Naur Form（ABNF）表記と[ RFC7230 ]の&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;セクション7で&lt;/a&gt;定義されているリスト拡張を使用して、「＃」演算子を使用したコンマ区切りリストのコンパクトな定義を可能にしています（ 「*」演算子が繰り返しを示す方法）。 &lt;a href=&quot;#appendix-C&quot;&gt;付録Cでは&lt;/a&gt;、他のドキュメントからインポートされたルールについて説明します。 &lt;a href=&quot;#appendix-D&quot;&gt;付録D&lt;/a&gt;は、すべてのリスト演算子が標準のABNF表記に拡張された、収集された文法を示しています。</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">この仕様では、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC7230&lt;/a&gt; ]の&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;セクション7で&lt;/a&gt;定義されている、リスト拡張付きの[ RFC5234 ] のAugmented Backus-Naur Form（ABNF）表記を使用します。これにより、「＃」演算子を使用してコンマ区切りリストをコンパクトに定義できます（ 「*」演算子が繰り返しを示す方法）。 &lt;a href=&quot;#appendix-C&quot;&gt;付録Cでは&lt;/a&gt;、他のドキュメントからインポートされたルールについて説明します。 &lt;a href=&quot;#appendix-D&quot;&gt;付録D&lt;/a&gt;は、すべてのリスト演算子が標準のABNF表記に拡張された、収集された文法を示しています。この仕様では、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]で定義されている「文字」、「文字エンコーディングスキーム」、「charset」、「プロトコル要素」という用語を使用しています。</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">本仕様では、線形の空白の使用を表すために 3 つの規則を使用する。OWS(任意の空白)、RWS(必須の空白)、BWS(&quot;悪い &quot;空白)です。OWSルールは、0個以上の直線的な空白オクテットが出現する可能性がある場合に使用されます。可読性を向上させるためにオプションの空白が好ましいプロトコルエレメントのために、 送信者はオプションの空白を1つのSPとして生成するべきである[SHOULD]。そうでない場合、送信者は、インプレースメッセージ フィルタリング中に無効または不要なプロトコルエレメントをホワイトアウトするために 必要な場合を除き、オプションの空白を生成するべきではない[SHOULD NOT]。RWSルールは、フィールドトークンを分離するために少なくとも1つの直線的なホワイトスペースオクテットが必要な場合に使用される。送信者はRWSを1つのSPとして生成するべきである[SHOULD]。BWSルールは、文法が歴史的な理由からオプションの空白を許可している場合に使用される。送信者はメッセージ中にBWSを生成してはならない[MUST NOT]。受信者は、プロトコル要素を解釈する前に、そのような不正な空白を解析して削除しなければならない[MUST]。OWS=*(SP/HTAB);オプションの空白 RWS=1*(SP/HTAB);必須の空白 BWS=OWS;&quot;悪い &quot;空白</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">この仕様は、に記載したレジストリ・メカニズムに準拠二つの新しいメディアタイプ使用&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ]、レジストリ・メカニズムに準拠する[で説明した新しいメッセージヘッダ&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;に記載したレジストリ・メカニズムに準拠]、2つの新しいリンク関係&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287を&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="230704ae6595086f8b4b75eab8034387112b13dd" translate="yes" xml:space="preserve">
          <source>This status can also send a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header, telling the requester when to check back to see if the functionality is supported by then.</source>
          <target state="translated">このステータスは、&lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt;ヘッダーを送信して、その時点で機能がサポートされているかどうかを確認するタイミングをリクエスターに通知することもできます。</target>
        </trans-unit>
        <trans-unit id="755885b5d7d7ceb53dac1ececfff6ea91ddc944f" translate="yes" xml:space="preserve">
          <source>This status code is primarily intended to be used with the &lt;a href=&quot;headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header, letting the user agent start &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;preloading&lt;/a&gt; resources while the server prepares a response.</source>
          <target state="translated">このステータスコードは、主に&lt;a href=&quot;headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt;ヘッダーで使用することを目的としており、サーバーが応答を準備している間、ユーザーエージェントがリソースの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;プリロードを&lt;/a&gt;開始できるようにします。</target>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">このステータスコードはHTTP 1.1ではRequest-URIに対してのみ使用され、他の場所のURIに対しては使用されません。</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">この状態は、オリジンサーバーではなく、ネットワークへのアクセスを制御するプロキシを傍受することで生成されます。</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">このステータスは、正しく認証する方法に関する情報を含む&lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーとともに送信されます。</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">このステータスは、正しく認証する方法に関する情報を含む&lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;ヘッダーとともに送信されます。</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">このステータスは&lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt;に似ていますが、この場合、再認証しても違いはありません。アクセスは永久に禁止され、リソースへの不十分な権限などのアプリケーションロジックに関連付けられます。</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">このステータスは&lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt;と似ていますが、この場合は認証が可能です。</target>
        </trans-unit>
        <trans-unit id="d740e14cfb624c7102c236e54e55ea5db95b95e3" translate="yes" xml:space="preserve">
          <source>This technique does work for internal links, but try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request occurs). If you can avoid it by correcting internal links, you should fix those links instead.</source>
          <target state="translated">このテクニックは内部リンクに対しては有効ですが、内部リダイレクトは避けるようにしましょう。リダイレクトには、(余分な HTTP リクエストが発生するために)大きなパフォーマンスコストがかかります。内部リンクを修正することで回避できるのであれば、代わりにそれらのリンクを修正すべきです。</target>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">このテクニックにはもう一つの利点があります:二つのキャッシュされたリソースを同時に更新しても、一方のリソースの古いバージョンがもう一方のリソースの新しいバージョンと組み合わせて使用されるという状況にはなりません。これは、Web サイトに相互依存性を持つ CSS スタイルシートや JS スクリプトがある場合、つまり、同じ HTML 要素を参照しているために相互に依存している場合に非常に重要です。</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">この値は、&lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt;パラメータを使用して変更できます。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;ソース&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a0945e40dcef867b66faa0e27a1bd4227d6481c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">この値は、 &lt;code&gt;image.http.accept&lt;/code&gt; パラメーターを使用して変更できます。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;ソース&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">この値は、 &lt;code&gt;image.http.accept&lt;/code&gt; パラメータを使用して変更できます。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;ソース&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">これにより、CORSヘッダを使用して特権を処理することで、クライアントとサーバの間で簡単なやりとりを行うことができます。</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">これは、クライアントが開始するアップグレードとほぼ同じように機能します。メッセージに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを追加すると、オプションのアップグレードが要求されます。ただし、必須アップグレードは、次のように、受け取ったメッセージに&lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt;ステータスコードを返信することでアップグレードを要求するという点で、動作が少し異なります。</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">これにより、Mozilla、Google、Microsoft、AppleのドメインからのCORSリクエストが可能になる。</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">フィーチャーポリシーは、一貫した構文を使用して複数のフィーチャを制御しますが、ポリシーで制御されるフィーチャの動作は異なり、いくつかの要因に依存します。</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2では複雑さが増しますが、HTTPメッセージをフレームに埋め込んでパフォーマンスを向上させることにより、メッセージの基本構造はHTTP / 1.0以降同じままです。セッションフローは単純なままなので、調査して、単純な&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTPメッセージモニターで&lt;/a&gt;デバッグできます。</target>
        </trans-unit>
        <trans-unit id="9a15157e510ae4fb6f9c552a8502c5d3c090f5d9" translate="yes" xml:space="preserve">
          <source>Though fixed in Firefox 69, previous 32-bit versions of Firefox running on 64-bit processors would report that the system is using a 32-bit CPU.</source>
          <target state="translated">Firefox 69 で修正されましたが、64 ビットプロセッサ上で動作する以前の 32 ビットバージョンの Firefox では、システムが 32 ビット CPU を使用していると報告されていました。</target>
        </trans-unit>
        <trans-unit id="c1440c92eaa6c1b3552c42a43600691971d67871" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; is not supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">けれども&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;ディレクティブは非推奨置き換えることを意図している &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブを、&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;まだほとんどのブラウザでサポートされていません。したがって、現在のブラウザーとの互換性のために、ブラウザーが&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; を&lt;/a&gt;サポートするときに上位互換性を追加するために、 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; と&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; の&lt;/a&gt;両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">けれども&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;ディレクティブは非推奨置き換えることを意図している &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブを、&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;まだほとんどのブラウザでサポートされていません。そのため、現在のブラウザーとの互換性を確保すると同時に、ブラウザーが&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;サポートを取得するときに上位互換性を追加するには、 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; と&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; の&lt;/a&gt;両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">けれども&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;ディレクティブは非推奨置き換えることを意図している &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブを、&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;まだほとんどのブラウザでサポートされていません。そのため、現在のブラウザーとの互換性を確保すると同時に、ブラウザーが&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;サポートを取得するときに上位互換性を追加するには、 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; と&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; の&lt;/a&gt;両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">コンテンツを選択するためにこのヘッダーを使用する正当な方法がありますが、ユーザーエージェントがサポートする機能を定義するためにこのヘッダーに依存すること&lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;は悪い習慣と見なさ&lt;/a&gt;れています。</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">リファラーに対する厳格な制御&amp;ndash; Mozillaセキュリティブログ</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">時間ベースの条件</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut = &quot;Timeout&quot; &quot;：&quot; 1＃TimeType TimeType =（ &quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;）; TimeType DAVTimeOutVal = 1 * DIGITクライアント内でLWSは許可されません。クライアントは、LOCKリクエストにタイムアウトリクエストヘッダーを含めることができます。ただし、サーバーはこれらの要求を尊重したり考慮したりする必要はありません。クライアントは、LOCKメソッド以外のメソッドでTimeoutリクエストヘッダーを送信してはなりません（MUST NOT）。 &quot;Second&quot; TimeTypeは、サーバーでのロックの許可とロックの自動削除との間の経過秒数を指定します。 TimeType &quot;Second&quot;のタイムアウト値は2 ^ 32-1より大きくてはいけません。ロックタイムアウトの動作については、&lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">コレクションにメンバーを追加するために、クライアントはPOSTリクエストをコレクションのURIに送信します。メンバーの作成が成功すると、201（「作成済み」）応答コードで示されます。コレクションがステータスコード201で応答する場合、コレクションは応答本文も返す必要があります。これは、新しく作成されたリソースを表すAtomエントリドキュメントである必要があります。サーバーは、たとえば、atom：id要素のコンテンツを変更することによってPOSTされたエントリーを自由に変更できるため、エントリーを返すことはクライアントにとって有用であり、新しいエントリーのクライアントとサーバーのビューを関連付けることができます。メンバーリソースが作成されると、そのメンバーエントリURIがコレクションの応答のLocationヘッダーで返される必要があります。作成リクエストにAtomエントリドキュメントが含まれている場合、サーバーからの後続の応答に、Location-headerの文字と一致するContent-Locationヘッダーが含まれている場合、クライアントは応答エンティティを新しく作成されたエントリの完全な表現であると解釈することを許可されます。一致するContent-Locationヘッダーがない場合、クライアントは、返されたエンティティが作成されたリソースの完全な表現であると想定してはなりません（MUST NOT）。 POSTで送信されるリクエストの本文は、Atomエントリである必要はありません。たとえば、写真や映画などです。コレクションは、ステータスコード415（「サポートされていないメディアタイプ」）の応答を返して、POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示す場合があります。このようなコンテンツを作成する際の問題については、以下を参照してください。見る見る次に、クライアントは、応答エンティティを新しく作成されたエントリの完全な表現であると解釈することを許可されます。一致するContent-Locationヘッダーがない場合、クライアントは、返されたエンティティが作成されたリソースの完全な表現であると想定してはなりません（MUST NOT）。 POSTで送信されるリクエストの本文は、Atomエントリである必要はありません。たとえば、写真や映画などです。コレクションは、ステータスコード415（「サポートされていないメディアタイプ」）の応答を返して、POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示す場合があります。このようなコンテンツを作成する際の問題については、以下を参照してください。次に、クライアントは、応答エンティティを新しく作成されたエントリの完全な表現であると解釈することを許可されます。一致するContent-Locationヘッダーがない場合、クライアントは、返されたエンティティが作成されたリソースの完全な表現であると想定してはなりません（MUST NOT）。 POSTで送信されるリクエストの本文は、Atomエントリである必要はありません。たとえば、写真や映画などです。コレクションは、ステータスコード415（「サポートされていないメディアタイプ」）の応答を返して、POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示す場合があります。このようなコンテンツを作成する際の問題については、以下を参照してください。クライアントは、返されたエンティティが作成されたリソースの完全な表現であることを想定してはなりません（MUST NOT）。 POSTで送信されるリクエストの本文は、Atomエントリである必要はありません。たとえば、写真や映画などです。コレクションは、ステータスコード415（「サポートされていないメディアタイプ」）の応答を返して、POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示す場合があります。このようなコンテンツを作成する際の問題については、以下を参照してください。クライアントは、返されたエンティティが作成されたリソースの完全な表現であることを想定してはなりません（MUST NOT）。 POSTで送信されるリクエストの本文は、Atomエントリである必要はありません。たとえば、写真や映画などです。コレクションは、ステータスコード415（「サポートされていないメディアタイプ」）の応答を返して、POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示す場合があります。このようなコンテンツを作成する際の問題については、以下を参照してください。）POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示します。このようなコンテンツを作成する際の問題については、以下を参照してください。）POSTされたエンティティのメディアタイプがコレクションで許可またはサポートされていないことを示します。このようなコンテンツを作成する際の問題については、以下を参照してください。&lt;a href=&quot;#section-9.6&quot;&gt;セクション9.6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">&lt;code&gt;X-Kuma-Revision&lt;/code&gt; のようなカスタムヘッダーをさらに公開するには、カンマで区切られた複数のヘッダーを指定できます。</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">&lt;code&gt;https://developer.mozilla.org&lt;/code&gt; がタイミングリソースを表示できるようにするには、次のように指定できます。</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">任意のリソースにタイミングリソースを見られるようにする。</target>
        </trans-unit>
        <trans-unit id="de9aa903d9e34061f0b89ba2ccd4efede6a71126" translate="yes" xml:space="preserve">
          <source>To allow any site to make CORS requests &lt;em&gt;without&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; wildcard (for example, to enable credentials), your server must read the value of the request's &lt;code&gt;Origin&lt;/code&gt; header and use that value to set &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, and must also set a &lt;code&gt;Vary: Origin&lt;/code&gt; header to indicate that some headers are being set dynamically depending on the origin.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; ワイルドカード&lt;em&gt;を&lt;/em&gt;使用&lt;em&gt;せずに&lt;/em&gt;サイトがCORSリクエストを実行できるようにするには（たとえば、認証情報を有効にするため）、サーバーはリクエストの &lt;code&gt;Origin&lt;/code&gt; ヘッダーの値を読み取り、その値を使用して &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; を設定する必要があります。 &lt;code&gt;Vary: Origin&lt;/code&gt; ヘッダーを設定して、一部のヘッダーがオリジンに応じて動的に設定されていることを示します。</target>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">インラインスクリプトとインラインイベントハンドラーを許可するには、 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 、ノンスソース、またはインラインブロックと一致するハッシュソースを指定できます。</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">インラインスタイルを許可するには、 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 、インラインブロックに一致するノンスソースまたはハッシュソースを指定できます。</target>
        </trans-unit>
        <trans-unit id="13976356a231a259baf5887e2defcf39ece5cf88" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a directory or only certain pages, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">ディレクトリまたは特定のページのみにリダイレクトを適用するには、 &lt;code&gt;rewrite&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">フォルダーまたはページのサブセットのみにリダイレクトを適用するには、 &lt;code&gt;rewrite&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">既存のWebコンテンツの破壊を回避するために、このようなポリシー制御機能のデフォルトでは、すべてのオリジンが機能を使用できるようになっています。つまり、各機能のデフォルトの許可リストは &lt;code&gt;'*'&lt;/code&gt; です。次善の機能の使用を防ぐには、機能を無効にするポリシーを明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4241af7f93eeeca05ab65287e814f22f52b1e121" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary requests and duplicated cache entries, caching servers should use &lt;strong&gt;normalization &lt;/strong&gt;to pre-process the request and cache only files that are needed. For example, in the case of &lt;code&gt;Accept-Encoding&lt;/code&gt; you could check for &lt;code&gt;gzip&lt;/code&gt; and other compression types in the header before doing further processing, and otherwise unset the header. In &quot;pseudo code&quot; this might look like:</source>
          <target state="translated">不要な要求と重複したキャッシュエントリを回避するために、キャッシュサーバーは&lt;strong&gt;正規化&lt;/strong&gt;を使用して要求を前処理し、必要なファイルのみをキャッシュする必要があります。たとえば、 &lt;code&gt;Accept-Encoding&lt;/code&gt; の場合、さらに処理を行う前にヘッダー内の &lt;code&gt;gzip&lt;/code&gt; およびその他の圧縮タイプを確認し、それ以外の場合はヘッダーの設定を解除できます。「擬似コード」では、これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b23e40255a27317ad4c5e7988f79e6d83e22e91b" translate="yes" xml:space="preserve">
          <source>To check if cross origin isolation has been successful, you can test against the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; property available to window and worker contexts:</source>
          <target state="translated">クロスオリジン分離が成功したかどうかを確認するには、ウィンドウおよびワーカーコンテキストで使用可能な &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; プロパティに対してテストできます。</target>
        </trans-unit>
        <trans-unit id="87498cccdcb4487afbcf49b5c7bb695ac3af44f7" translate="yes" xml:space="preserve">
          <source>To check if cross-origin isolation has been successful, you can test against the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; property available to window and worker contexts:</source>
          <target state="translated">クロスオリジン分離が成功したかどうかを確認するには、ウィンドウおよびワーカーコンテキストで使用可能な &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; プロパティに対してテストできます。</target>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">すべてのページの &lt;code&gt;X-Frame-Options&lt;/code&gt; ヘッダーを送信するようにApacheを構成するには、これをサイトの構成に追加します。</target>
        </trans-unit>
        <trans-unit id="ed88de8ec706b4b0a28b855a26786e3ee2a0c543" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; DENY, add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; DENYを設定するようにApacheを構成するには、これをサイトの構成に追加します。</target>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; deny を設定するようにApacheを構成するには、これをサイトの構成に追加します。</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">設定するようにApacheを設定するには、 &lt;code&gt;X-Frame-Options&lt;/code&gt; することが &lt;code&gt;allow-from&lt;/code&gt; 、特定のホストサイトの設定にこれを追加します。</target>
        </trans-unit>
        <trans-unit id="c6efccd4af9ebeaf527c38eab55daa0481a50728" translate="yes" xml:space="preserve">
          <source>To configure Express to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, you can use &lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;helmet&lt;/a&gt; which uses &lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;frameguard&lt;/a&gt; to set the header. Add this to your server configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; ヘッダーを送信するようにExpressを構成するには、フレーム&lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;ガード&lt;/a&gt;を使用してヘッダーを設定する&lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;ヘルメット&lt;/a&gt;を使用できます。これをサーバー構成に追加します。</target>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; ヘッダーを送信するようにHAProxyを構成するには、フロントエンド、リッスン、またはバックエンドの構成にこれを追加します。</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; ヘッダーを送信するようにIISを構成するには、これをサイトの &lt;code&gt;Web.config&lt;/code&gt; ファイルに追加します。</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; ヘッダーを送信するようにnginxを構成するには、http、サーバー、または場所の構成にこれを追加します。</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">クライアント側でこの問題を修正するには、CORSリクエストを発行するときに、資格情報フラグの値が &lt;code&gt;false&lt;/code&gt; であることを確認します。</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">メンバーリソースを削除するには、クライアントは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で指定されているように、DELETE要求をそのメンバーURIに送信します。メディアリンクエントリを削除すると、対応するメディアリソースも削除されます（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="72f4f993e89f8fbf65e0d29a84346e687a67b7ba" translate="yes" xml:space="preserve">
          <source>To disable caching of a resource, you can send the following response header:</source>
          <target state="translated">リソースのキャッシュを無効にするには、以下のレスポンスヘッダを送信します。</target>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">すべてのプラグインを禁止するには、&lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt;ディレクティブを &lt;code&gt;'none'&lt;/code&gt; に設定して、プラグインを禁止する必要があります。 &lt;code&gt;plugin-types&lt;/code&gt; あなたが持つプラグインできるようにしている場合ディレクティブにのみ使用される &lt;code&gt;object-src&lt;/code&gt; すべてのを。</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">より詳細なレベルで http 資産を許可しないようにするには、個々のディレクティブを &quot;https:&quot; に設定することもできます。例えば、安全でない http 画像を許可しないようにするには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="a213397329a4dbbb753416e90e80c6286443a758" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &lt;code&gt;https:&lt;/code&gt;. For example, to disallow nonsecure HTTP images:</source>
          <target state="translated">より詳細なレベルでhttpアセットを禁止するために、個々のディレクティブを &lt;code&gt;https:&lt;/code&gt; 設定することもできます。たとえば、安全でないHTTP画像を禁止するには：</target>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">これを行うために、HTTPはエンドツーエンド圧縮のコンテンツネゴシエーションと同様のメカニズムを使用します。要求を送信するノードは&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して意志をアドバタイズし、他のノードは適切な方法を選択して適用し、その選択を示します&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダ。</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">展開を容易にするために、CSP はレポート専用モードで展開することができます。ポリシーは強制されませんが、違反は提供された URI に報告されます。さらに、report-only ヘッダは、実際にデプロイすることなく、将来のポリシーのリビジョンをテストするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">メンバーリソースを編集するには、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で指定されているように、クライアントがメンバーURIにPUTリクエストを送信します。メンバーエントリまたはメディアリンクエントリの編集時に意図しないデータの損失を回避するために、Atomプロトコルクライアント&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;は、[RFC4287]のセクション6で&lt;/a&gt;定義されている不明な外部マークアップを含め、意図的に変更されていないすべてのメタデータを保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">サーバーの構成を変更してこのエラーを解消するには、サーバーの構成を調整して &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; ヘッダーの値を &lt;code&gt;true&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">CSPを有効にするには、&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTPヘッダーを返すようにWebサーバーを構成する必要があります（ &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; ヘッダーの説明が表示されることもありますが、それは古いバージョンであり、その必要はありません。もう指定しない）。</target>
        </trans-unit>
        <trans-unit id="19b1b9201d67c0e13d81834b3ed7b51ae71bba12" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header. (Sometimes you may see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore.)</source>
          <target state="translated">CSPを有効にするには、&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; PolicyHTTPヘッダーを返すようにWebサーバーを構成する必要があります。（ &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; ヘッダーについての言及が表示される場合がありますが、これは古いバージョンであり、もう指定する必要はありません。）</target>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">サイトでこの機能を有効にするには、サイトがHTTPS経由でアクセスされたときに&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; HTTPヘッダーを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;セッションで使用されるサーバーの公開鍵の信頼性を確保するために、この公開鍵は、通常は認証局（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;）によって署名されるX.509証明書にラップされます。ブラウザなどのWebクライアントは、これらのCAの多くを信頼します。これらのCAはすべて、任意のドメイン名の証明書を作成できます。攻撃者が単一のCAを危険にさらすことができる場合、攻撃者はさまざまなTLS接続でMITM攻撃を実行できます。 HPKPは、特定のWebサーバーに属する公開鍵をクライアントに通知することにより、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;プロトコルに対するこの脅威を回避できます。</target>
        </trans-unit>
        <trans-unit id="bb1ec08765a8cde8081dbd27d2c650bba3f705fa" translate="yes" xml:space="preserve">
          <source>To expose a non-CORS-safelisted request header, you can specify:</source>
          <target state="translated">CORSセーフリストに登録されていないリクエストヘッダを公開するには、以下のように指定します。</target>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">シンプルでないレスポンスヘッダを公開するには、指定することができます。</target>
        </trans-unit>
        <trans-unit id="c49b225b0a37fb347c33ef070bf2b8ce3177f370" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;) response headers.</source>
          <target state="translated">サーバーが &lt;code&gt;PATCH&lt;/code&gt; をサポートしているかどうかを確認するために、サーバーは、&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../cors&quot;&gt;CORSの場合&lt;/a&gt;）応答ヘッダーのリストに追加することで、サポートをアドバタイズできます。</target>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">サーバーが &lt;code&gt;PATCH&lt;/code&gt; をサポートしているかどうかを確認するために、サーバーはそれを&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;（CORSの場合）応答ヘッダーのリストに追加することで、そのサポートをアドバタイズできます。</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">サーバがサポートしているリクエストメソッドを調べるには、curl を使用して OPTIONS リクエストを発行します。</target>
        </trans-unit>
        <trans-unit id="94a06678a04eb20207fc7bb6378a7dadaf3ba84d" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use the &lt;code&gt;curl&lt;/code&gt; command-line program to issue an &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="translated">サーバーがサポートするリクエストメソッドを見つけるには、 &lt;code&gt;curl&lt;/code&gt; コマンドラインプログラムを使用して &lt;code&gt;OPTIONS&lt;/code&gt; リクエストを発行します。</target>
        </trans-unit>
        <trans-unit id="0e18f6487121f857662c6a85c3a47051c59f1876" translate="yes" xml:space="preserve">
          <source>To fix the problem, update your code to use the new URL as reported by the redirect, thereby avoiding the redirect.</source>
          <target state="translated">問題を修正するには、リダイレクトによって報告された新しいURLを使用するようにコードを更新することで、リダイレクトを回避することができます。</target>
        </trans-unit>
        <trans-unit id="32dbd3b679bd14efe132327b76684a2c87a18ba4" translate="yes" xml:space="preserve">
          <source>To fix this problem on the client side, revise the code to not request the use of credentials.</source>
          <target state="translated">クライアント側でこの問題を修正するには、クレデンシャルの使用を要求しないようにコードを修正します。</target>
        </trans-unit>
        <trans-unit id="35039835a23cd330912a1e328fb92250be4508c7" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs, Web Fonts (&lt;code&gt;@font-face&lt;/code&gt;), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGL textures&lt;/a&gt;, and XSL stylesheets.</source>
          <target state="translated">この問題を修正するには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; API、Web Fonts（ &lt;code&gt;@font-face&lt;/code&gt; ）、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGLテクスチャ&lt;/a&gt;、XSLスタイルシートなどのCORSを含むリクエストを発行するときにHTTPSURLを使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="2617321bfe1280098dd397ad19ede4778814a0fc" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS.</source>
          <target state="translated">この問題を解決するには、CORS を含むリクエストを発行する際に HTTPS URL を使用していることを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="f21f1534d5e4a79d894d05095d228a6afa694b9f" translate="yes" xml:space="preserve">
          <source>To fix this, you will have to add the &lt;code&gt;Secure&lt;/code&gt; attribute to your &lt;code&gt;SameSite=None&lt;/code&gt; cookies.</source>
          <target state="translated">これを修正するには、 &lt;code&gt;SameSite=None&lt;/code&gt; Cookieに &lt;code&gt;Secure&lt;/code&gt; 属性を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="15680ede5ec99b5956f1bf553d855c87853f86ba" translate="yes" xml:space="preserve">
          <source>To have a server check the request's headers, a client must send &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: 100-continue&lt;/code&gt; as a header in its initial request and receive a &lt;code&gt;100 Continue&lt;/code&gt; status code in response before sending the body.</source>
          <target state="translated">サーバーにリクエストのヘッダーをチェックさせるには、クライアントは&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: 100-continue&lt;/code&gt; を最初のリクエストのヘッダーとして送信し、本文を送信する前に応答として &lt;code&gt;100 Continue&lt;/code&gt; ステータスコードを受信する必要があります。</target>
        </trans-unit>
        <trans-unit id="a8e97e24a55d2464483db3779fca7d3ac69353bb" translate="yes" xml:space="preserve">
          <source>To list the Members of a Collection, the client sends a GET request
   to the URI of a Collection.  An Atom Feed Document is returned whose
   Entries contain the IRIs of Member Resources.  The returned Feed may
   describe all, or only a partial list, of the Members in a Collection
   (see &lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;).

   Client                          Server
     |                                |
     |  1.) GET to Collection URI     |
     |-------------------------------&amp;gt;|
     |                                |
     |  2.) 200 Ok                    |
     |      Atom Feed Document        |
     |&amp;lt;-------------------------------|
     |                                |

   1.  The client sends a GET request to the URI of the Collection.

   2.  The server responds with an Atom Feed Document containing the
       IRIs of the Collection Members.</source>
          <target state="translated">コレクションのメンバーをリストするために、クライアントはGETリクエストをコレクションのURIに送信します。エントリーにメンバーリソースのIRIが含まれているAtomフィードドキュメントが返されます。返されるフィードは、コレクション内のメンバーのすべてまたは一部のリストのみを説明する場合があります（&lt;a href=&quot;#section-10&quot;&gt;セクション10を&lt;/a&gt;参照））。クライアントサーバー| | | 1.）コレクションURIに取得| | -------------------------------&amp;gt; | | | | 2.）200 OK | | Atomフィードドキュメント| | &amp;lt;------------------------------- | | | 1.クライアントは、コレクションのURIにGET要求を送信します。2.サーバーは、コレクションメンバーのIRIを含むAtomフィードドキュメントで応答します。</target>
        </trans-unit>
        <trans-unit id="40d4be7657f2f51d2de5be0cbaac7191b3c8a653" translate="yes" xml:space="preserve">
          <source>To load an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; you must specify &lt;code&gt;application/x-java-applet&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;をロードするには、 &lt;code&gt;application/x-java-applet&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d201d9342cffef73d7a41bc9cba81a23914667e" translate="yes" xml:space="preserve">
          <source>To password-protect a directory on an Apache server, you will need a &lt;code&gt;.htaccess&lt;/code&gt; and a &lt;code&gt;.htpasswd&lt;/code&gt; file.</source>
          <target state="translated">Apacheサーバー上のディレクトリをパスワードで保護するには、 &lt;code&gt;.htaccess&lt;/code&gt; ファイルと &lt;code&gt;.htpasswd&lt;/code&gt; ファイルが必要です。</target>
        </trans-unit>
        <trans-unit id="2b1b9e12e5ed28875fdd87d9931a916a268928e4" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document from the page. It then parses this file, fetching additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">Web ページを表示するには、ブラウザはページから HTML ドキュメントを取得するためのオリジナルのリクエストを送信します。次に、このファイルを解析し、実行スクリプト、表示するレイアウト情報 (CSS)、ページ内に含まれるサブリソース (通常は画像や動画)に対応する追加のリクエストを取得します。次に Web ブラウザはこれらのリソースを混合して、ユーザーに完全なドキュメントである Web ページを提示します。ブラウザによって実行されるスクリプトは、後の段階でより多くのリソースを取得することができ、ブラウザはそれに応じて Web ページを更新します。</target>
        </trans-unit>
        <trans-unit id="9e60dfe4ac6141599165a832cd24e1d13bc8342c" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">Web ページを表示するには、ブラウザは元のリクエストを送信して、ページを表す HTML ドキュメントを取得します。次にこのファイルを解析し、実行スクリプト、表示するレイアウト情報 (CSS)、ページ内に含まれるサブリソース (通常は画像や動画)に対応する追加のリクエストを行います。Web ブラウザは、これらのリソースを混合して、ユーザーに完全なドキュメントである Web ページを提示します。ブラウザによって実行されるスクリプトは、後の段階でより多くのリソースを取得することができ、ブラウザはそれに応じて Web ページを更新します。</target>
        </trans-unit>
        <trans-unit id="bbc3791377cf289d3e10d82216c0c34f70d22305" translate="yes" xml:space="preserve">
          <source>To prevent cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks, &lt;code&gt;HttpOnly&lt;/code&gt; cookies are inaccessible to JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; they are only sent to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and the &lt;code&gt;HttpOnly&lt;/code&gt; flag should be set.</source>
          <target state="translated">クロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻撃を防ぐために、 &lt;code&gt;HttpOnly&lt;/code&gt; CookieはJavaScriptの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; APIにアクセスできません。それらはサーバーにのみ送信されます。たとえば、サーバー側のセッションを保持するCookieはJavaScriptで使用できる必要はなく、 &lt;code&gt;HttpOnly&lt;/code&gt; フラグを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="72ede2114830d9b5c365d2af6457cc4237ba98cd" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.</source>
          <target state="translated">スヌーピングやその他のプライバシー侵害を防ぐために、WebブラウザはWebサイト間の厳密な分離を強制します。&lt;strong&gt;同じオリジンの&lt;/strong&gt;ページのみがWebページのすべての情報にアクセスできます。このような制約はサーバーの負担になりますが、HTTPヘッダーはサーバー側でのこの厳密な分離を緩和し、ドキュメントをさまざまなドメインから提供される情報のパッチワークにすることができます。そうするためのセキュリティ関連の理由さえあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="da58d84bcbf609daa347015eaf4c1596d9aec024" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation server-side, allowing a document to become a patchwork of information sourced from different domains (there could even be security-related reasons to do so).</source>
          <target state="translated">スヌーピングやその他のプライバシーの侵害を防ぐために、WebブラウザはWebサイト間を厳密に分離します。&lt;strong&gt;同じオリジンの&lt;/strong&gt;ページだけがWebページのすべての情報にアクセスできます。このような制約はサーバーの負担ですが、HTTPヘッダーはサーバー側でこの厳密な分離を緩和し、ドキュメントが異なるドメインから発信された情報のパッチワークになることを可能にします（そうするためにセキュリティ関連の理由もある可能性があります）。</target>
        </trans-unit>
        <trans-unit id="6fdb9fa15e3fd167189ceff75fae693acf53ca4b" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">これを防ぐために、条件付き要求が使用されます。範囲の場合、これを行うには2つの方法があります。より柔軟なものは、&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;を利用し、前提条件が失敗した場合、サーバーはエラーを返します。その後、クライアントはダウンロードを最初から再開します。</target>
        </trans-unit>
        <trans-unit id="51d6446ef1d59700324bbaf38bfb84d4a066a702" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">これを防ぐために、条件付きリクエストが使用されます。範囲の場合、これを行うには2つの方法があります。より柔軟なものは、&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;を利用し、前提条件が失敗した場合、サーバーはエラーを返します。次に、クライアントはダウンロードを最初から再開します。</target>
        </trans-unit>
        <trans-unit id="8ae0931ca2f4a9bdada593d70fdcc9e0e5795272" translate="yes" xml:space="preserve">
          <source>To provide information about the proxy itself (not about the client connecting to it), the &lt;code&gt;Via&lt;/code&gt; header can be used.</source>
          <target state="translated">プロキシ自体に関する情報（プロキシに接続するクライアントに関する情報ではない）を提供するには、 &lt;code&gt;Via&lt;/code&gt; ヘッダーを使用できます。</target>
        </trans-unit>
        <trans-unit id="39f35e596ed723bf2514b5c1b49a714286137491" translate="yes" xml:space="preserve">
          <source>To request a mandatory upgrade to TLS&amp;mdash;that is, to upgrade and fail the connection if the upgrade is not successful&amp;mdash;your first request must be an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request, like this:</source>
          <target state="translated">TLSへの必須アップグレードを要求するには、つまり、アップグレードが成功せず、接続をアップグレードして失敗させるには、最初の要求は次のような&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;要求でなければなりません。</target>
        </trans-unit>
        <trans-unit id="0ac4a6a255bea42439869af2e4020d47f12f5638" translate="yes" xml:space="preserve">
          <source>To see stored cookies (and other storage that a web page can use), you can enable the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt; in Developer Tools and select Cookies from the storage tree.</source>
          <target state="translated">保存されたCookie（およびWebページが使用できるその他のストレージ）を表示するには、開発者ツールで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt;を有効にし、ストレージツリーからCookieを選択します。</target>
        </trans-unit>
        <trans-unit id="bc330ab165d9d2700ffdde233d29f19baad1a79d" translate="yes" xml:space="preserve">
          <source>To select the algorithm to use, browsers and servers use &lt;a href=&quot;content_negotiation&quot;&gt;proactive content negotiation&lt;/a&gt;. The browser sends an &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header with the algorithm it supports and its order of precedence, the server picks one, uses it to compress the body of the response and uses the &lt;a href=&quot;headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; header to tell the browser the algorithm it has chosen. As content negotiation has been used to choose a representation based on its encoding, the server must send a &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header containing at least &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; alongside this header in the response; that way, caches will be able to cache the different representations of the resource.</source>
          <target state="translated">使用するアルゴリズムを選択するために、ブラウザーとサーバーは&lt;a href=&quot;content_negotiation&quot;&gt;プロアクティブなコンテンツネゴシエーションを&lt;/a&gt;使用します。ブラウザは、サポートするアルゴリズムとその優先順位を含む&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダーを送信します。サーバーが1つを選択し、それを使用して応答の本文を圧縮し、&lt;a href=&quot;headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、選択したアルゴリズムをブラウザに通知します。コンテンツネゴシエーションはエンコードに基づいて表現を選択するために使用されているため、サーバーは、応答内のこのヘッダーと一緒に少なくとも&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;を含む&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;ヘッダーを送信する必要があります。このようにして、キャッシュはリソースのさまざまな表現をキャッシュすることができます。</target>
        </trans-unit>
        <trans-unit id="634a9fb6a29c3c70ac67df06d1d205bf0ae96039" translate="yes" xml:space="preserve">
          <source>To set allowed types for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, use the &lt;a href=&quot;plugin-types&quot;&gt;&lt;code&gt;plugin-types&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素に許可されるタイプを設定するには、&lt;a href=&quot;plugin-types&quot;&gt; &lt;code&gt;plugin-types&lt;/code&gt; &lt;/a&gt;ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="1df8505922402bf519c64877c4fe5b468a0d15a0" translate="yes" xml:space="preserve">
          <source>To turn off caching, you can send the following response header. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Pragma&lt;/code&gt; headers.</source>
          <target state="translated">キャッシュをオフにするには、次の応答ヘッダーを送信します。さらに、 &lt;code&gt;Expires&lt;/code&gt; および &lt;code&gt;Pragma&lt;/code&gt; ヘッダーも参照してください。</target>
        </trans-unit>
        <trans-unit id="dd73224596457324eeb7f6a3787968a990efcb06" translate="yes" xml:space="preserve">
          <source>To turn on the enforcement of all the best practices, specify the policy as below.</source>
          <target state="translated">すべてのベストプラクティスの施行をオンにするには、以下のようにポリシーを指定します。</target>
        </trans-unit>
        <trans-unit id="e986abf32e5ea3dcadc05857dd5f7dc3d3e31912" translate="yes" xml:space="preserve">
          <source>To understand the underlying issue with the CORS configuration, you need to find out which request is at fault and why. These steps may help you do so:</source>
          <target state="translated">CORS 構成の根本的な問題を理解するには、どのリクエストに障害があるのか、その理由を調べる必要があります。以下の手順はそれを行うのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="a5de27ea55a3c3a2648dd523ae819b4dad29f351" translate="yes" xml:space="preserve">
          <source>To upgrade to TLS optionally (that is, allowing the connection to continue in cleartext if the upgrade to TLS fails), you simply use the &lt;code&gt;Upgrade&lt;/code&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers as expected. For example, given the original request:</source>
          <target state="translated">オプションでTLSにアップグレードするには（つまり、TLSへのアップグレードが失敗した場合に接続をクリアテキストで続行できるようにするため）、期待どおりに &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーと&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを使用するだけです。たとえば、元のリクエストが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="044deb9959ba1185df13d8adce29060324260efa" translate="yes" xml:space="preserve">
          <source>Today, every HTTP/1.1-compliant proxy and server should support pipelining, though many have limitations in practice: a significant reason no modern browser activates this feature by default.</source>
          <target state="translated">今日では、すべての HTTP/1.1 準拠のプロキシとサーバがパイプライン化をサポートしているはずですが、実際には多くのものには限界があります。</target>
        </trans-unit>
        <trans-unit id="e354edd2f2d8086de47823e3cb62b62a590f4266" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;&lt;strong&gt;&lt;a href=&quot;require-trusted-types-for&quot;&gt;require-trusted-types-for&lt;/a&gt;&lt;/strong&gt;&lt;/code&gt; directive, this allows authors to define rules guarding writing values to the DOM and thus reducing the DOM XSS attack surface to small, isolated parts of the web application codebase, facilitating their monitoring and code review. This directive declares an allow-list of trusted type policy names created with &lt;code&gt;TrustedTypes.createPolicy&lt;/code&gt; from Trusted Types API.</source>
          <target state="translated">一緒に &lt;code&gt;&lt;strong&gt;&lt;a href=&quot;require-trusted-types-for&quot;&gt;require-trusted-types-for&lt;/a&gt;&lt;/strong&gt;&lt;/code&gt; のディレクティブ、これは著者はDOMに値を書き込むため、Webアプリケーションのコードベースの小さな、孤立部分にDOM XSSの攻撃面を減らし、彼らの監視とコードレビューを促進守るルールを定義することができます。このディレクティブは、Trusted &lt;code&gt;TrustedTypes.createPolicy&lt;/code&gt; からTrustedTypes.createPolicyを使用して作成されたトラステッドタイプポリシー名の許可リストを宣言します。</target>
        </trans-unit>
        <trans-unit id="33aad73dfe686c313271fd5a3616235aaa85ae94" translate="yes" xml:space="preserve">
          <source>Together with the resource, the validators are sent in the headers. In this example, both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; are sent, but it could equally have been only one of them. These validators are cached with the resource (like all headers) and will be used to craft conditional requests, once the cache becomes stale.</source>
          <target state="translated">リソースとともに、バリデーターはヘッダーで送信されます。この例では、&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; の&lt;/a&gt;両方が送信されていますが、同等にそれらの1つだけである可能性もあります。これらのバリデーターは（すべてのヘッダーと同様に）リソースとともにキャッシュされ、キャッシュが古くなると、条件付き要求を作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0525ab49d332c5db40375b0a9f6ea89615d60e2c" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; resources</source>
          <target state="translated">ツールとリソース</target>
        </trans-unit>
        <trans-unit id="b9ddad26522153eb9872297e87c93c799247f043" translate="yes" xml:space="preserve">
          <source>Tools to check your cache-related headers</source>
          <target state="translated">キャッシュ関連のヘッダをチェックするツール</target>
        </trans-unit>
        <trans-unit id="7b5272923a452bc32a23884c3fe28dc343ef4efe" translate="yes" xml:space="preserve">
          <source>Top-level navigation blocked to data:// URIs</source>
          <target state="translated">トップレベルのナビゲーションはdata://URIにブロックされています。</target>
        </trans-unit>
        <trans-unit id="e81a151bd05091f9935dc3aba219eed346e7bb4f" translate="yes" xml:space="preserve">
          <source>Tracking</source>
          <target state="translated">Tracking</target>
        </trans-unit>
        <trans-unit id="5dcb619778c5a48fbe9ce0ea8e4e07da0e9aea7d" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression</source>
          <target state="translated">トラッキング選好表現</target>
        </trans-unit>
        <trans-unit id="2af5d6ecb9eb76a6bccbc8c68b541e6b6b396809" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'DNT Header Field for HTTP Requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">Tracking Preference Expression（DNT）&lt;br/&gt;&lt;small&gt;その仕様における「HTTPリクエストのDNTヘッダーフィールド」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="84aa830d1d5897f6ae5f7fca1156da8d8706f8cb" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'Tk header field' in that specification.&lt;/small&gt;</source>
          <target state="translated">Tracking Preference Expression（DNT）&lt;br/&gt;&lt;small&gt;その仕様における「Tkヘッダーフィールド」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d37a3197e485b933cb995fe9c9d3f25f9de908c0" translate="yes" xml:space="preserve">
          <source>Tracking and privacy</source>
          <target state="translated">追跡とプライバシー</target>
        </trans-unit>
        <trans-unit id="8e5bd5bfa384bf004de3147d61aadd3993d2c684" translate="yes" xml:space="preserve">
          <source>Tracking with consent. The origin server believes it has received prior consent for tracking this user, user agent, or device.</source>
          <target state="translated">同意を得たトラッキング オリジンサーバーは、このユーザー、ユーザーエージェント、またはデバイスを追跡するために事前に同意を得たと考えています。</target>
        </trans-unit>
        <trans-unit id="a58efd8405db46a290d75d073d8104640ac8bf79" translate="yes" xml:space="preserve">
          <source>Tracking.</source>
          <target state="translated">Tracking.</target>
        </trans-unit>
        <trans-unit id="26013bccba39d56f3505ecd08b5aabdc74ef7701" translate="yes" xml:space="preserve">
          <source>Trailer</source>
          <target state="translated">Trailer</target>
        </trans-unit>
        <trans-unit id="2f8c965a489badb0e16d07f424592d1f9df923ab" translate="yes" xml:space="preserve">
          <source>Trailer (RFC 2616)</source>
          <target state="translated">トレーラー(RFC2616</target>
        </trans-unit>
        <trans-unit id="77a56b4b0d25c8ae802cf40ac536850a7797b43e" translate="yes" xml:space="preserve">
          <source>Transfer Codings (RFC 7230)</source>
          <target state="translated">転送コーディング (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="70841a225420fbcb24be7613367795a906d292c9" translate="yes" xml:space="preserve">
          <source>Transfer coding</source>
          <target state="translated">転送コーディング</target>
        </trans-unit>
        <trans-unit id="7ebdaa3f3a4520281b97e02b5d2f54005ba580f8" translate="yes" xml:space="preserve">
          <source>Transfer coding names are used to indicate an encoding transformation
   that has been, can be, or might need to be applied to a payload body
   in order to ensure &quot;safe transport&quot; through the network.  This
   differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.

     transfer-coding    = &quot;chunked&quot; ; &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;
                        / &quot;compress&quot; ; &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;
                        / &quot;deflate&quot; ; &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;
                        / &quot;gzip&quot; ; &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;
                        / transfer-extension
     transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )

   Parameters are in the form of a name or name=value pair.

     transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   All transfer-coding names are case-insensitive and ought to be
   registered within the HTTP Transfer Coding registry, as defined in
   &lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;.  They are used in the TE (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and
   Transfer-Encoding (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;) header fields.</source>
          <target state="translated">転送コーディング名は、ネットワークを介した「安全なトランスポート」を保証するために、ペイロード本体に適用されている、適用できる、または適用する必要がある可能性があるエンコーディング変換を示すために使用されます。これは、転送コーディングが転送される表現のプロパティではなくメッセージのプロパティであるという点で、コンテンツコーディングとは異なります。 transfer-coding = &quot;chunked&quot;; &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; / &quot;compress&quot;; &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; / &quot;deflate&quot;; &lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt; / &quot;gzip&quot;; &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; / transfer-extension transfer-extension = token *（OWS &quot;;&quot; OWS transfer-parameter）パラメータは、名前または名前=値のペアの形式です。 transfer-parameter = token BWS &quot;=&quot; BWS（token / quoted-string）すべてのtransfer-coding名は大文字と小文字を区別せず、&lt;a href=&quot;#section-8.4&quot;&gt;セクション8.4で&lt;/a&gt;定義されているように、HTTP Transfer Codingレジストリ内に登録する必要があります 。これらは、TE（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）およびTransfer-Encoding（&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt;）ヘッダーフィールドで使用されます。</target>
        </trans-unit>
        <trans-unit id="4d8b97a685db2fa279df1bb0d54e0fdc0c9f8bb5" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding</source>
          <target state="translated">Transfer-Encoding</target>
        </trans-unit>
        <trans-unit id="4626d4537fdc031b31ab03445f507eb645f0b745" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding (RFC 2616)</source>
          <target state="translated">転送符号化(RFC2616)</target>
        </trans-unit>
        <trans-unit id="af30d73f2f27d92a78211f034fdce80b11f12b01" translate="yes" xml:space="preserve">
          <source>Transfer-coding values are used to indicate an encoding
   transformation that has been, can be, or may need to be applied to an
   entity-body in order to ensure &quot;safe transport&quot; through the network.
   This differs from a content coding in that the transfer-coding is a
   property of the message, not of the original entity.

       transfer-coding         = &quot;chunked&quot; | transfer-extension
       transfer-extension      = token *( &quot;;&quot; parameter )

   Parameters are in  the form of attribute/value pairs.

       parameter               = attribute &quot;=&quot; value
       attribute               = token
       value                   = token | quoted-string

   All transfer-coding values are case-insensitive. HTTP/1.1 uses
   transfer-coding values in the TE header field (&lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;) and in
   the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;).

   Whenever a transfer-coding is applied to a message-body, the set of
   transfer-codings MUST include &quot;chunked&quot;, unless the message is
   terminated by closing the connection. When the &quot;chunked&quot; transfer-
   coding is used, it MUST be the last transfer-coding applied to the
   message-body. The &quot;chunked&quot; transfer-coding MUST NOT be applied more
   than once to a message-body. These rules allow the recipient to
   determine the transfer-length of the message (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).

   Transfer-codings are analogous to the Content-Transfer-Encoding
   values of MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;], which were designed to enable safe transport of
   binary data over a 7-bit transport service. However, safe transport
   has a different focus for an 8bit-clean transfer protocol. In HTTP,
   the only unsafe characteristic of message-bodies is the difficulty in
   determining the exact body length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;), or the desire to
   encrypt data over a shared transport. 

   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   transfer-coding value tokens. Initially, the registry contains the
   following tokens: &quot;chunked&quot; (&lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;), &quot;identity&quot; (&lt;a href=&quot;#section-3.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt;), &quot;gzip&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), &quot;compress&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), and &quot;deflate&quot;
   (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   New transfer-coding value tokens SHOULD be registered in the same way
   as new content-coding value tokens (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   A server which receives an entity-body with a transfer-coding it does
   not understand SHOULD return 501 (Unimplemented), and close the
   connection. A server MUST NOT send transfer-codings to an HTTP/1.0
   client.</source>
          <target state="translated">transfer-coding値は、ネットワークを介した「安全なトランスポート」を保証するために、エンティティ本体に適用されている、適用できる、または適用する必要があるエンコーディング変換を示すために使用されます。これは、転送コーディングが元のエンティティではなくメッセージのプロパティであるという点で、コンテンツコーディングとは異なります。 transfer-coding = &quot;chunked&quot; | transfer-extension transfer-extension = token *（ &quot;;&quot; parameter）パラメータは、属性/値のペアの形式です。パラメータ=属性 &quot;=&quot;値属性=トークン値=トークン| quoted-stringすべてのtransfer-coding値は大文字と小文字を区別しません。 HTTP / 1.1は、TEヘッダーフィールドの転送コーディング値を使用します（&lt;a href=&quot;#section-14.39&quot;&gt;セクション14.39&lt;/a&gt;）およびTransfer-Encodingヘッダーフィールド（&lt;a href=&quot;#section-14.41&quot;&gt;セクション14.41&lt;/a&gt;）。転送コーディングがメッセージ本文に適用される場合は常に、接続を閉じることによってメッセージが終了しない限り、転送コーディングのセットに「チャンク」が含まれている必要があります。 「チャンクされた」転送コーディングが使用される場合、それはメッセージ本文に適用される最後の転送コーディングでなければなりません。 「チャンクされた」転送コーディングは、メッセージ本文に複数回適用してはなりません（MUST NOT）。これらのルールにより、受信者はメッセージの転送長を決定できます（&lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;）。転送コーディングは、MIMEのContent-Transfer-Encoding値に類似しています[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]、7ビットのトランスポートサービスを介してバイナリデータを安全にトランスポートできるように設計されています。ただし、安全な転送では、8ビットのクリーンな転送プロトコルに対して別の焦点があります。 HTTPでは、メッセージ本文の安全でない唯一の特徴は、正確な本文の長さ（&lt;a href=&quot;#section-7.2.2&quot;&gt;セクション7.2.2&lt;/a&gt;）を決定するのが難しいこと、または共有トランスポートを介してデータを暗号化することです。 Internet Assigned Numbers Authority（IANA）は、転送コーディング値トークンのレジストリとして機能します。最初、レジストリには次のトークンが含まれています：「チャンク」（&lt;a href=&quot;#section-3.6.1&quot;&gt;セクション3.6.1&lt;/a&gt;）、「アイデンティティー」（&lt;a href=&quot;#section-3.6.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt;）、「gzip」（&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）、「圧縮」（&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）、および「収縮」（ &lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）。新しいtransfer-coding値トークンは、新しいcontent-coding値トークンと同じ方法で登録する必要があります（&lt;a href=&quot;#section-3.5&quot;&gt;セクション3.5&lt;/a&gt;）。理解できないtransfer-codingのエンティティ本体を受信するサーバーは、501（実装されていない）を返し、接続を閉じます。サーバーは転送コーディングをHTTP / 1.0クライアントに送信してはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="8f06d2432c28b1a1b63093c7243e8fc4296b2052" translate="yes" xml:space="preserve">
          <source>Transformation Applied</source>
          <target state="translated">変形応用</target>
        </trans-unit>
        <trans-unit id="0333efced7aed7a62393f804f6f0a1fac69384cf" translate="yes" xml:space="preserve">
          <source>Transitioning from &lt;code&gt;X-Forwarded-For&lt;/code&gt; to &lt;code&gt;Forwarded&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; から &lt;code&gt;Forwarded&lt;/code&gt; への移行</target>
        </trans-unit>
        <trans-unit id="d9dbb92c213907795b866e8682bea20bfe425f28" translate="yes" xml:space="preserve">
          <source>Transparent Content Negotiation in HTTP</source>
          <target state="translated">HTTP における透過的なコンテンツネゴシエーション</target>
        </trans-unit>
        <trans-unit id="01d5987738fe39dbda22e95b91e209136e267709" translate="yes" xml:space="preserve">
          <source>Transparent negotiation is a combination of both server-driven and
   agent-driven negotiation. When a cache is supplied with a form of the
   list of available representations of the response (as in agent-driven
   negotiation) and the dimensions of variance are completely understood
   by the cache, then the cache becomes capable of performing server-
   driven negotiation on behalf of the origin server for subsequent
   requests on that resource.

   Transparent negotiation has the advantage of distributing the
   negotiation work that would otherwise be required of the origin
   server and also removing the second request delay of agent-driven
   negotiation when the cache is able to correctly guess the right
   response.

   This specification does not define any mechanism for transparent
   negotiation, though it also does not prevent any such mechanism from
   being developed as an extension that could be used within HTTP/1.1.</source>
          <target state="translated">透過ネゴシエーションはサーバー駆動型とエージェント駆動型のネゴシエーションの組み合わせです。キャッシュが(エージェント駆動ネゴシエーションのように)応答の利用可能な表現のリストの形で提供され、分散の次元がキャッシュによって完全に理解されると、キャッシュはそのリソースに対する後続のリクエストに対して、オリジンサーバに代わってサーバ駆動ネゴシエーションを実行することができるようになります。透過ネゴシエーションには、そうでなければオリジンサーバに要求されるネゴシエーション作業を分散し、キャッシュが正しい応答を正しく推測することができたときにエージェント駆動ネゴシエーションの2回目のリクエスト遅延を取り除くという利点があります。この仕様は透過ネゴシエーションのためのメカニズムを定義していませんが、そのようなメカニズムが HTTP/1.1 内で使用できる拡張として開発されることを妨げていません。</target>
        </trans-unit>
        <trans-unit id="78b9ce3dc78962972447ca0b6f58074fd970dfbb" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</source>
          <target state="translated">トランスポートレイヤセキュリティ(TLS)アプリケーションレイヤプロトコルネゴシエーションエクステンション</target>
        </trans-unit>
        <trans-unit id="dfd6efe315d54c8cdd2adc5afbb8872f6a336102" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in iOS before 13. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="translated">トリート &lt;code&gt;SameSite=None&lt;/code&gt; として、無効な値が &lt;code&gt;Strict&lt;/code&gt; 13を参照する前に、iOS版で&lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;バグ198181&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b08ea38352dc45d4d989417f6fef8d6f90e693b" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in macOS before 10.15 Catalina. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="translated">トリート &lt;code&gt;SameSite=None&lt;/code&gt; として、無効な値が &lt;code&gt;Strict&lt;/code&gt; 10.15カタリナ前のMacOSインチ &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;バグ198181を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="323f99b9a56b4b45411c566426be7157525a2168" translate="yes" xml:space="preserve">
          <source>Trident</source>
          <target state="translated">Trident</target>
        </trans-unit>
        <trans-unit id="ca3606ead865c2815a13e76d1b25c992f4f3c6f9" translate="yes" xml:space="preserve">
          <source>Trident/7.0; .*rv:xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">トライデント/7.0; 。* rv：xyz &lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c266c97b59663994c186c4ed953693b711755a83" translate="yes" xml:space="preserve">
          <source>Trident/xyz</source>
          <target state="translated">Trident/xyz</target>
        </trans-unit>
        <trans-unit id="ea2c9903532f8ca9b9bfd8b8e86bf77e287eda98" translate="yes" xml:space="preserve">
          <source>Tries to resolve the hostname. Returns true if succeeds.</source>
          <target state="translated">ホスト名の解決を試みます。成功した場合は真を返します。</target>
        </trans-unit>
        <trans-unit id="0ad2653fb337835a830a479f5211338052b81788" translate="yes" xml:space="preserve">
          <source>Troubleshooting HTTP 405</source>
          <target state="translated">HTTP 405 のトラブルシューティング</target>
        </trans-unit>
        <trans-unit id="9b5aeb48bb5b3f47bc91e7f66bbbde649d99b8a5" translate="yes" xml:space="preserve">
          <source>Troubleshooting errors</source>
          <target state="translated">トラブルシューティングエラー</target>
        </trans-unit>
        <trans-unit id="6e7d676a3f4acf661dbd32eb846f4d30d45c42b9" translate="yes" xml:space="preserve">
          <source>True if and only if the IP address of the host matches the specified IP address pattern.</source>
          <target state="translated">ホストの IP アドレスが指定された IP アドレスパターンと一致する場合にのみ、真。</target>
        </trans-unit>
        <trans-unit id="853354f33edc8bdc875b21e01f674d1cc985ac56" translate="yes" xml:space="preserve">
          <source>True if and only if there is no domain name in the hostname (no dots).</source>
          <target state="translated">ホスト名にドメイン名が含まれていない(ドットがない)場合にのみ真。</target>
        </trans-unit>
        <trans-unit id="40b3edf718ee234d3ed60de8590b0eab146b9f6b" translate="yes" xml:space="preserve">
          <source>TrueType Font</source>
          <target state="translated">TrueTypeフォント</target>
        </trans-unit>
        <trans-unit id="bbf3f0cb2c9cd2650c1a090a531af44cd91ba47e" translate="yes" xml:space="preserve">
          <source>Trusted Types</source>
          <target state="translated">信頼できるタイプ</target>
        </trans-unit>
        <trans-unit id="c859b305a822310a954cdbf0855833e891bb6bad" translate="yes" xml:space="preserve">
          <source>Trusted Types with &lt;a href=&quot;https://github.com/cure53/DOMPurify#what-about-dompurify-and-trusted-types&quot;&gt;DOMPurify&lt;/a&gt; XSS sanitizer</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cure53/DOMPurify#what-about-dompurify-and-trusted-types&quot;&gt;DOMPurifyXSS&lt;/a&gt;サニタイザーを使用した信頼できるタイプ</target>
        </trans-unit>
        <trans-unit id="deed064463d5fe6a9b6de90de79e1d7bc5664ed3" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;http&lt;/code&gt; resource from a page with an &lt;code&gt;https&lt;/code&gt; origin will also cause this error.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; オリジンを持つページから &lt;code&gt;http&lt;/code&gt; リソースにアクセスしようとすると、このエラーも発生します。</target>
        </trans-unit>
        <trans-unit id="1ecb3021f84a92249f81d93e6449bc294633f5a4" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;https&lt;/code&gt; resource that has an invalid certificate will cause this error.</source>
          <target state="translated">無効な証明書を持つ &lt;code&gt;https&lt;/code&gt; リソースにアクセスしようとすると、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="cb7dd9fead5f39240201ca09db25e60a206fb473" translate="yes" xml:space="preserve">
          <source>Trying to use a &lt;a href=&quot;../../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request will fail with this error.</source>
          <target state="translated">&lt;a href=&quot;../../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;要求を使用しようとすると、このエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="91efe823a9a6e3fb633db6d257efcabfa7cfb34a" translate="yes" xml:space="preserve">
          <source>Tunneling transmits private network data and protocol information through public network by encapsulating the data. HTTP tunneling is using a protocol of higher level (HTTP) to transport a lower level protocol (TCP).</source>
          <target state="translated">トンネリングは、プライベートネットワークのデータやプロトコル情報をカプセル化してパブリックネットワークを介して送信します。HTTP トンネリングは、上位プロトコル(HTTP)を使用して下位プロトコル(TCP)を伝送します。</target>
        </trans-unit>
        <trans-unit id="e28a72d2f72f9e470a9c017ef73151d89a57b9b9" translate="yes" xml:space="preserve">
          <source>Turning on and off prefetching</source>
          <target state="translated">プリフェッチのオン/オフの切り替え</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="2b805468035d4d32817647d90742c71d232cc025" translate="yes" xml:space="preserve">
          <source>Two header fields are used for carrying authentication credentials,
   as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;].  Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;].

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authorization | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7235]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]で定義されているように、認証資格情報を伝達するために2つのヘッダーフィールドが使用されます。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]で定義されているように、ユーザー認証のさまざまなカスタムメカニズムがこの目的でCookieヘッダーフィールドを使用することに注意してください。 + --------------------- + -------------------------- + |ヘッダーフィールド名|で定義されています... | + --------------------- + -------------------------- + |認可| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]のセクション4.2&lt;/a&gt; | |プロキシ認証| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;[RFC7235]のセクション4.4&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="ce0195a6ae48268edebd5bad672073160522c130" translate="yes" xml:space="preserve">
          <source>Two newer models were created in HTTP/1.1. The persistent-connection model keeps connections opened between successive requests, reducing the time needed to open new connections. The HTTP pipelining model goes one step further, by sending several successive requests without even waiting for an answer, reducing much of the latency in the network.</source>
          <target state="translated">HTTP/1.1では、2つの新しいモデルが作成されました。persistent-connection モデルは、連続したリクエストの間に接続を開いたままにしておき、新しい接続を開くのに必要な時間を短縮します。HTTP パイプラインモデルはさらに一歩進んだもので、応答を待つことなく複数の連続したリクエストを送信し、ネットワークの待ち時間の多くを短縮します。</target>
        </trans-unit>
        <trans-unit id="a6b6a2cb2500b00f4598bac08b45cc08135ddf62" translate="yes" xml:space="preserve">
          <source>Two others content encoding, &lt;code&gt;bzip&lt;/code&gt; and &lt;code&gt;bzip2&lt;/code&gt;, are sometimes used, though not standard. They implement the algorithm used by these two UNIX programs. Note that the first one was discontinued due to patent licensing problems.</source>
          <target state="translated">標準ではありませんが、他の2つのコンテンツエンコーディング &lt;code&gt;bzip&lt;/code&gt; と &lt;code&gt;bzip2&lt;/code&gt; が時々使用されます。これらは、これら2つのUNIXプログラムで使用されるアルゴリズムを実装しています。最初のものは、特許ライセンスの問題のために中止されたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="be051f060f0e48af75e9fbc48e21748ef6b4cb67" translate="yes" xml:space="preserve">
          <source>Two primary MIME types are important for the role of default types:</source>
          <target state="translated">デフォルトタイプの役割には、2つの主要なMIMEタイプが重要です。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f3b42007b5826f0bf510edecae6f14cfe0fe14b4" translate="yes" xml:space="preserve">
          <source>Type name:  multipart

   Subtype name:  byteranges

   Required parameters:  boundary

   Optional parameters:  N/A

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted

   Security considerations:  see &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).

   Applications that use this media type:  HTTP components supporting
      multiple ranges in a single request.

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:  See
      Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">タイプ名：マルチパートサブタイプ名：バイト範囲必須パラメーター：境界オプションパラメーター：N / Aエンコーディングの考慮事項：「7ビット」、「8ビット」、または「バイナリ」のみが許可されますセキュリティの考慮事項：&lt;a href=&quot;#section-6&quot;&gt;セクション6を&lt;/a&gt;参照してください 相互運用性の考慮事項：なし公開された仕様：この仕様（&lt;a href=&quot;#appendix-A&quot;&gt;付録Aを&lt;/a&gt;参照））。このメディアタイプを使用するアプリケーション：1つのリクエストで複数の範囲をサポートするHTTPコンポーネント。フラグメント識別子に関する考慮事項：なし追加情報：このタイプの非推奨のエイリアス名：なしマジック番号：なしファイル拡張子：なしMacintoshファイルタイプコード：なし人物詳細については、連絡先の電子メールアドレス：作成者のアドレスセクションを参照してください。使用目的：共通使用上の制限：なし作成者：「作成者のアドレス」セクションを参照してください。コントローラーの変更：IESG</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="1cdbcf1104e531ebfadc11eeae080e4dae018fc1" translate="yes" xml:space="preserve">
          <source>Types of policy-controlled features</source>
          <target state="translated">ポリシーで制御される機能の種類</target>
        </trans-unit>
        <trans-unit id="7e09f83609dd0c3d502c7f963c9a6cb433242aef" translate="yes" xml:space="preserve">
          <source>Typescript file</source>
          <target state="translated">タイプスクリプトファイル</target>
        </trans-unit>
        <trans-unit id="bcdcdf22eca538d6ec2cf257367ae227cf6af679" translate="yes" xml:space="preserve">
          <source>Typical use case</source>
          <target state="translated">代表的な使用例</target>
        </trans-unit>
        <trans-unit id="9d181320d36d0df488b3ffb530573b04214390c3" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like these:</source>
          <target state="translated">通常、サーバーの応答には、次のような &lt;code&gt;WWW-Authenticate&lt;/code&gt; ヘッダーが含まれています。</target>
        </trans-unit>
        <trans-unit id="5c770b12d663e3645cbb00a17170089090ea1bce" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like this:</source>
          <target state="translated">通常、サーバーの応答には、次のような &lt;code&gt;WWW-Authenticate&lt;/code&gt; ヘッダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="b7575b8da7bfc80688b2b000e08fcdc14b5cd506" translate="yes" xml:space="preserve">
          <source>Typically, this means that a required precondition header, such as &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, &lt;strong&gt;is missing&lt;/strong&gt;.</source>
          <target state="translated">典型的には、この手段などの必要な前提条件ヘッダ、その&lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;、&lt;strong&gt;欠落しています&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="037314288a9afb85b05677ae9ceceff454cbc8e0" translate="yes" xml:space="preserve">
          <source>Typically, you don't want your users to resend &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests. If you serve the response as the result of this request, a simple press of the reload button will resend the request (possibly after a confirmation message).</source>
          <target state="translated">通常、ユーザーに&lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 、&lt;/a&gt;または&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;リクエストを再送信させたくありません。このリクエストの結果として応答を提供する場合、リロードボタンを押すだけでリクエストが再送信されます（おそらく確認メッセージの後で）。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="f70305059f0d6ca694366421ab9addbc18e37b87" translate="yes" xml:space="preserve">
          <source>URI/URL - A Uniform Resource Identifier and Uniform Resource Locator,
   respectively.  These terms (and the distinction between them) are
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   URI/URL Mapping - A relation between an absolute URI and a resource.
   Since a resource can represent items that are not network
   retrievable, as well as those that are, it is possible for a resource
   to have zero, one, or many URI mappings.  Mapping a resource to an
   &quot;http&quot; scheme URI makes it possible to submit HTTP protocol requests
   to the resource using the URI. 

   Path Segment - Informally, the characters found between slashes (&quot;/&quot;)
   in a URI.  Formally, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;.

   Collection - Informally, a resource that also acts as a container of
   references to child resources.  Formally, a resource that contains a
   set of mappings between path segments and resources and meets the
   requirements defined in &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;.

   Internal Member (of a Collection) - Informally, a child resource of a
   collection.  Formally, a resource referenced by a path segment
   mapping contained in the collection.

   Internal Member URL (of a Collection) - A URL of an internal member,
   consisting of the URL of the collection (including trailing slash)
   plus the path segment identifying the internal member.

   Member (of a Collection) - Informally, a &quot;descendant&quot; of a
   collection.  Formally, an internal member of the collection, or,
   recursively, a member of an internal member.

   Member URL (of a Collection) - A URL that is either an internal
   member URL of the collection itself, or is an internal member URL of
   a member of that collection.

   Property - A name/value pair that contains descriptive information
   about a resource.

   Live Property - A property whose semantics and syntax are enforced by
   the server.  For example, the live property DAV:getcontentlength has
   its value, the length of the entity returned by a GET request,
   automatically calculated by the server.

   Dead Property - A property whose semantics and syntax are not
   enforced by the server.  The server only records the value of a dead
   property; the client is responsible for maintaining the consistency
   of the syntax and semantics of a dead property.

   Principal - A distinct human or computational actor that initiates
   access to network resources.

   State Token - A URI that represents a state of a resource.  Lock
   tokens are the only state tokens defined in this specification.</source>
          <target state="translated">URI / URL-それぞれUniform Resource IdentifierおよびUniform Resource Locator。これらの用語（およびそれらの違い）は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]で定義されています。 URI / URLマッピング-絶対URIとリソースの関係。リソースはネットワークで取得できないアイテムと同様にアイテムを表すことができるので、リソースは0、1、または多くのURIマッピングを持つことができます。リソースを「http」スキームのURIにマッピングすると、URIを使用してHTTPプロトコル要求をリソースに送信できます。パスセグメント-非公式には、URIのスラッシュ（ &quot;/&quot;）の間にある文字。&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]のセクション3.3で&lt;/a&gt;定義されているとおり。コレクション-非公式には、子リソースへの参照のコンテナとしても機能するリソース。正式には、パスセグメントとリソース間の一連のマッピングを含み、&lt;a href=&quot;#section-5&quot;&gt;セクション5で&lt;/a&gt;定義された要件を満たすリソース。 （コレクションの）内部メンバー-非公式には、コレクションの子リソース。正式には、コレクションに含まれるパスセグメントマッピングによって参照されるリソース。 （コレクションの）内部メンバーURL-コレクション（末尾のスラッシュを含む）のURLと内部メンバーを識別するパスセグメントで構成される内部メンバーのURL。 （コレクションの）メンバー-非公式には、コレクションの「子孫」。正式には、コレクションの内部メンバー、または再帰的に内部メンバーのメンバー。 （コレクションの）メンバーURL-コレクション自体の内部メンバーURL、またはそのコレクションのメンバーの内部メンバーURLであるURL。プロパティ-リソースに関する説明情報を含む名前/値のペア。ライブプロパティ-そのセマンティクスと構文がサーバーによって強制されるプロパティ。たとえば、ライブプロパティDAV：getcontentlengthには、GETリクエストによって返されたエンティティの長さの値があり、サーバーによって自動的に計算されます。デッドプロパティ-そのセマンティクスと構文がサーバーによって強制されないプロパティ。サーバーは、デッドプロパティの値のみを記録します。クライアントは、死んだプロパティの構文とセマンティクスの一貫性を維持する責任があります。プリンシパル-ネットワークリソースへのアクセスを開始する別個の人間または計算アクター。状態トークン-リソースの状態を表すURI。ロックトークンは、この仕様で定義されている唯一の状態トークンです。getcontentlengthには値があり、GETリクエストによって返されるエンティティの長さで、サーバーによって自動的に計算されます。デッドプロパティ-そのセマンティクスと構文がサーバーによって強制されないプロパティ。サーバーは、デッドプロパティの値のみを記録します。クライアントは、死んだプロパティの構文とセマンティクスの一貫性を維持する責任があります。プリンシパル-ネットワークリソースへのアクセスを開始する別個の人間または計算アクター。状態トークン-リソースの状態を表すURI。ロックトークンは、この仕様で定義されている唯一の状態トークンです。getcontentlengthには値があり、GETリクエストによって返されるエンティティの長さで、サーバーによって自動的に計算されます。デッドプロパティ-そのセマンティクスと構文がサーバーによって強制されないプロパティ。サーバーは、デッドプロパティの値のみを記録します。クライアントは、死んだプロパティの構文とセマンティクスの一貫性を維持する責任があります。プリンシパル-ネットワークリソースへのアクセスを開始する別個の人間または計算アクター。状態トークン-リソースの状態を表すURI。ロックトークンは、この仕様で定義されている唯一の状態トークンです。サーバーは、デッドプロパティの値のみを記録します。クライアントは、死んだプロパティの構文とセマンティクスの一貫性を維持する責任があります。プリンシパル-ネットワークリソースへのアクセスを開始する別個の人間または計算アクター。状態トークン-リソースの状態を表すURI。ロックトークンは、この仕様で定義されている唯一の状態トークンです。サーバーは、デッドプロパティの値のみを記録します。クライアントは、死んだプロパティの構文とセマンティクスの一貫性を維持する責任があります。プリンシパル-ネットワークリソースへのアクセスを開始する別個の人間または計算アクター。状態トークン-リソースの状態を表すURI。ロックトークンは、この仕様で定義されている唯一の状態トークンです。</target>
        </trans-unit>
        <trans-unit id="1b1db348af514b6bea21a18f53ca916d54264149" translate="yes" xml:space="preserve">
          <source>URIs and how to access resources on the Web.</source>
          <target state="translated">URIとWeb上のリソースへのアクセス方法。</target>
        </trans-unit>
        <trans-unit id="6d39406666e0fced7b5feeca9564a556a649dc18" translate="yes" xml:space="preserve">
          <source>URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.

   Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead.

   Since the Referer header field tells a target site about the context
   that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any
   personal information that might be found in the referring resource's
   URI.  Limitations on the Referer header field are described in
   &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; to address some of its security considerations.</source>
          <target state="translated">URIは、セキュリティで保護されたリソースを識別した場合でも、共有ではなく保護されることを目的としています。 URIは多くの場合、ディスプレイに表示され、ページの印刷時にテンプレートに追加され、保護されていないさまざまなブックマークリストに保存されます。したがって、機密性の高い、個人を特定できる、または開示するリスクがあるURI内に情報を含めることは賢明ではありません。サービスの作成者は、機密データの送信のためにGETベースのフォームを使用しないようにする必要があります。そのデータはリクエストターゲットに配置されるためです。多くの既存のサーバー、プロキシ、およびユーザーエージェントは、リクエストターゲットを第三者が見る可能性のある場所に記録または表示します。そのようなサービスでは、代わりにPOSTベースのフォーム送信を使用する必要があります。 Refererヘッダーフィールドは、リクエストの原因となったコンテキストについてターゲットサイトに通知するため、ユーザーの即時の閲覧履歴に関する情報や、参照リソースのURIにある個人情報を明らかにする可能性があります。 Refererヘッダーフィールドの制限については、 &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2項で&lt;/a&gt;は、セキュリティに関する考慮事項の一部を取り上げます。</target>
        </trans-unit>
        <trans-unit id="3cce85850c1e42a1666b59eb99149f8792f48d3c" translate="yes" xml:space="preserve">
          <source>URIs have been known by many names: WWW addresses, Universal Document
   Identifiers, Universal Resource Identifiers [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], and finally the
   combination of Uniform Resource Locators (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and Names (URN)
   [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted strings which identify--via name, location, or any
   other characteristic--a resource.</source>
          <target state="translated">URIは、WWWアドレス、Universal Document Identifiers、Universal Resource Identifiers [ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]、そして最後にUniform Resource Locator（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]とNames（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ]の多くの名前で知られています。HTTPに関する限り、Uniform Resource Identifierは、名前、場所、またはその他の特性を介してリソースを識別する、単純にフォーマットされた文字列です。</target>
        </trans-unit>
        <trans-unit id="498e7643a14364976970437ebe13915fd4a1000a" translate="yes" xml:space="preserve">
          <source>URIs in HTTP can be represented in absolute form or relative to some
   known base URI [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;], depending upon the context of their use. The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed by a colon. For definitive information on
   URL syntax and semantics, see &quot;Uniform Resource Identifiers (URI):
   Generic Syntax and Semantics,&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;] (which replaces RFCs
   1738 [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]). This specification adopts the
   definitions of &quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;,
   &quot;host&quot;,&quot;abs_path&quot;, &quot;rel_path&quot;, and &quot;authority&quot; from that
   specification.

   The HTTP protocol does not place any a priori limit on the length of
   a URI. Servers MUST be able to handle the URI of any resource they
   serve, and SHOULD be able to handle URIs of unbounded length if they
   provide GET-based forms that could generate such URIs. A server
   SHOULD return 414 (Request-URI Too Long) status if a URI is longer
   than the server can handle (see &lt;a href=&quot;#section-10.4.15&quot;&gt;section 10.4.15&lt;/a&gt;).

      Note: Servers ought to be cautious about depending on URI lengths
      above 255 bytes, because some older client or proxy
      implementations might not properly support these lengths.</source>
          <target state="translated">HTTPのURIは、その使用状況に応じて、絶対形式または既知のベースURI [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt; ]を基準にして表すことができます。 2つの形式は、絶対URIが常にスキーマ名で始まり、その後にコロンが続くという事実によって区別されます。 URL構文とセマンティクスの決定的な情報については、「Uniform Resource Identifiers（URI）：Generic Syntax and Semantics」、&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ]（RFC 1738 [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]および&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]）。この仕様では、「URI参照」、「絶対URI」、「相対URI」、「ポート」、「ホスト」、「abs_path」、「rel_path」、および「権限」の定義をその仕様から採用しています。 HTTPプロトコルでは、URIの長さに事前の制限はありません。サーバーは、サービスを提供するすべてのリソースのURIを処理できなければならず（MUST）、そのようなURIを生成する可能性のあるGETベースのフォームを提供する場合、無制限の長さのURIを処理できる必要があります。サーバーが処理できるよりもURIが長い場合、サーバーは414（Request-URI Too Long）ステータスを返す必要があります（&lt;a href=&quot;#section-10.4.15&quot;&gt;セクション10.4.15を&lt;/a&gt;参照）。注：サーバーは、255バイトを超えるURIの長さに依存することに注意する必要があります。古いクライアントまたはプロキシの実装には、これらの長さを適切にサポートしないものがあるためです。</target>
        </trans-unit>
        <trans-unit id="cfef62af9614810559e1e5b81b8c27fecbab7b5c" translate="yes" xml:space="preserve">
          <source>URL redirection, also known as URL forwarding, is a technique to give a page, a form or a whole Web application, more than one URL address. HTTP provides a special kind of responses, &lt;em&gt;&lt;strong&gt;HTTP redirects&lt;/strong&gt;&lt;/em&gt;, to perform this operation used for numerous goals: temporary redirection while site maintenance is ongoing, permanent redirection to keep external links working after a change of the site's architecture, progress pages when uploading a file, and so on.</source>
          <target state="translated">URLリダイレクトは、URL転送とも呼ばれ、ページ、フォーム、またはWebアプリケーション全体に複数のURLアドレスを与える手法です。HTTPは、この操作を実行するための特別な種類の応答&lt;em&gt;&lt;strong&gt;HTTPリダイレクト&lt;/strong&gt;&lt;/em&gt;を提供します。これは、サイトのメンテナンスが進行中の一時的なリダイレクト、サイトのアーキテクチャの変更後に外部リンクが機能し続けるための永続的なリダイレクト、ファイルのアップロード時の進行状況ページ、等々。</target>
        </trans-unit>
        <trans-unit id="11053b0e7813cb1ccd4cf628421c47a3253d39a1" translate="yes" xml:space="preserve">
          <source>URL-embedded JavaScript code</source>
          <target state="translated">URL 埋め込み JavaScript コード</target>
        </trans-unit>
        <trans-unit id="621894213e70d0f25d538e3e503f261cb1c92c16" translate="yes" xml:space="preserve">
          <source>URL/hostname based conditions</source>
          <target state="translated">URL/ホスト名ベースの条件</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="b9011f5a3d0a8fd5aa8be41c9a2ba56d323a6e48" translate="yes" xml:space="preserve">
          <source>URLs and URNs</source>
          <target state="translated">URLとURN</target>
        </trans-unit>
        <trans-unit id="0d68396d9a72290240763f5089d4a58c9fd02660" translate="yes" xml:space="preserve">
          <source>URLs appear in many places in requests and responses.
   Interoperability experience with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] showed that many clients
   parsing Multi-Status responses did not fully implement the full
   Reference Resolution defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC3986]&lt;/a&gt;.  Thus,
   servers in particular need to be careful in handling URLs in
   responses, to ensure that clients have enough context to be able to
   interpret all the URLs.  The rules in this section apply not only to
   resource URLs in the 'href' element in Multi-Status responses, but
   also to the Destination and If header resource URLs.

   The sender has a choice between two approaches: using a relative
   reference, which is resolved against the Request-URI, or a full URI.
   A server MUST ensure that every 'href' value within a Multi-Status
   response uses the same format.

   WebDAV only uses one form of relative reference in its extensions,
   the absolute path.

      Simple-ref = absolute-URI | ( path-absolute [ &quot;?&quot; query ] )

   The absolute-URI, path-absolute and query productions are defined in
   Sections &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;, &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;, and &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   Within Simple-ref productions, senders MUST NOT:

   o  use dot-segments (&quot;.&quot; or &quot;..&quot;), or

   o  have prefixes that do not match the Request-URI (using the
      comparison rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;Section&amp;nbsp;3.2.3 of [RFC2616]&lt;/a&gt;).

   Identifiers for collections SHOULD end in a '/' character.</source>
          <target state="translated">URLはリクエストとレスポンスの多くの場所に表示されます。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] との相互運用性の経験から、マルチステータス応答を解析する多くのクライアント&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;は、[RFC3986]のセクション5で&lt;/a&gt;定義されている完全な参照解決を完全に実装していないことがわかった。したがって、特にサーバーは、クライアントがすべてのURLを解釈できるように十分なコンテキストを持つように、応答でのURLの処理に注意する必要があります。このセクションのルールは、マルチステータスレスポンスの「href」要素のリソースURLだけでなく、DestinationおよびIfヘッダーのリソースURLにも適用されます。送信者は2つのアプローチから選択できます。Request-URIに対して解決される相対参照を使用するか、完全なURIを使用します。サーバーは、マルチステータス応答内のすべての「href」値が同じ形式を使用することを確認する必要があります。 WebDAVは、絶対パスという拡張子で相対参照の1つの形式のみを使用します。 Simple-ref =絶対URI | （path-absolute [&quot;？&quot; query]）absolute-URI、path-absolute、およびqueryプロダクションは、セクションで定義されています&lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;、&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;、及び&lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;〔の&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]。Simple-refプロダクション内では、送信者は次のことを行ってはなりません：oドットセグメント（ &quot;。&quot;または &quot;..&quot;）を使用するか、またはo Request-URIと一致しないプレフィックスを使用します（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;セクション3.2.3で&lt;/a&gt;定義された比較ルールを使用） [RFC2616]）。コレクションの識別子は「/」文字で終了する必要があります。</target>
        </trans-unit>
        <trans-unit id="2c75d09b30def3f5acce02670c0f8d304787deb1" translate="yes" xml:space="preserve">
          <source>URNs</source>
          <target state="translated">URNs</target>
        </trans-unit>
        <trans-unit id="09716c44992b8bceefcd6d77921ff9ec06e2764d" translate="yes" xml:space="preserve">
          <source>USB</source>
          <target state="translated">USB</target>
        </trans-unit>
        <trans-unit id="463d4baccb11d04bd39b50170d5669b1473a3d3e" translate="yes" xml:space="preserve">
          <source>UTF-8 is now well-supported and the overwhelmingly preferred character encoding. To &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;guarantee better privacy through less configuration-based entropy&lt;/a&gt;, all browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8+, Safari 5+, Opera 11+, Firefox 10+ and Chrome 27+ no longer send it.</source>
          <target state="translated">UTF-8は現在十分にサポートされており、圧倒的に好まれる文字エンコードです。&lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;構成ベースのエントロピーを減らしてプライバシーを保護する&lt;/a&gt;ために、すべてのブラウザーで &lt;code&gt;Accept-Charset&lt;/code&gt; ヘッダーが省略されています。InternetExplorer8以降、Safari 5以降、Opera 11以降、Firefox 10以降、Chrome27以降では送信されなくなりました。</target>
        </trans-unit>
        <trans-unit id="3395f08e982fbccb7c267f1152a8f77ff4f3d2ba" translate="yes" xml:space="preserve">
          <source>Unconstrained multiple range requests are susceptible to denial-of-
   service attacks because the effort required to request many
   overlapping ranges of the same data is tiny compared to the time,
   memory, and bandwidth consumed by attempting to serve the requested
   data in many parts.  Servers ought to ignore, coalesce, or reject
   egregious range requests, such as requests for more than two
   overlapping ranges or for many small ranges in a single set,
   particularly when the ranges are requested out of order for no
   apparent reason.  Multipart range requests are not designed to
   support random access.</source>
          <target state="translated">制約のない複数の範囲要求は、同じデータの多くの重複する範囲を要求するのに必要な労力が、要求されたデータを多くの部分で提供しようとすることで消費される時間、メモリ、および帯域幅に比べてわずかであるため、サービス拒否攻撃の影響を受けやすい。サーバーは、2つ以上の重複する範囲や1つのセット内の多数の小さな範囲への要求など、特に範囲が明らかな理由もなく順不同で要求された場合には、不当な範囲要求を無視するか、合体させるか、または拒否するべきである。マルチパートの範囲リクエストは、ランダムアクセスをサポートするように設計されていません。</target>
        </trans-unit>
        <trans-unit id="87b5a91171602746648bcc818bbb122d7646769d" translate="yes" xml:space="preserve">
          <source>Undeprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; の非推奨化。</target>
        </trans-unit>
        <trans-unit id="7f3058bceb865d591bd6a47330d0826684d098a7" translate="yes" xml:space="preserve">
          <source>Under construction. The origin server is currently testing its communication of tracking status.</source>
          <target state="translated">工事中です。オリジンサーバーは現在、追跡状況の通信をテスト中です。</target>
        </trans-unit>
        <trans-unit id="93bb4b1c6ee8c5d136c3ae4245fe9019094c3bdf" translate="yes" xml:space="preserve">
          <source>Understanding The Vary Header - Smashing Magazine</source>
          <target state="translated">Varyヘッダーを理解する-スマッシングマガジン</target>
        </trans-unit>
        <trans-unit id="4821ae5432f25746ffce2357d74178373c8cf2dd" translate="yes" xml:space="preserve">
          <source>Understanding XSS Auditor &amp;ndash; Virtue Security</source>
          <target state="translated">XSS Auditorの理解&amp;ndash;美徳のセキュリティ</target>
        </trans-unit>
        <trans-unit id="b2f6280ce256054e508e4d6c0d2aed7f16b9ceb5" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page allowing to choose between the available resource, which prevents to easily automatize the process. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">残念ながら、HTTP標準ではページのフォーマットを指定していないため、使用可能なリソースから選択できるため、プロセスを簡単に自動化することができません。&lt;em&gt;サーバー主導のネゴシエーション&lt;/em&gt;に戻る以外に、このメソッドはほとんどの場合、特にJavaScriptリダイレクトでスクリプトと組み合わせて使用​​されます。ネゴシエーション基準を確認した後、スクリプトはリダイレクトを実行します。 2番目の問題は、実際のリソースをフェッチするためにもう1つの要求が必要であり、ユーザーがリソースを利用できないことです。</target>
        </trans-unit>
        <trans-unit id="590261af46ebe2219ba617fed793de6d03379f66" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page for choosing between the available resource, which prevents the process being automated. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">残念ながら、HTTP標準では、使用可能なリソースから選択するためのページの形式が指定されていないため、プロセスが自動化されません。&lt;em&gt;サーバー駆動型ネゴシエーション&lt;/em&gt;にフォールバックすることに加えて、このメソッドはほとんどの場合、スクリプトと組み合わせて使用​​されます。特にJavaScriptリダイレクトでは、ネゴシエーション基準を確認した後、スクリプトがリダイレクトを実行します。 2番目の問題は、実際のリソースをフェッチするためにもう1つのリクエストが必要であり、ユーザーがリソースを利用できるようになるのが遅くなることです。</target>
        </trans-unit>
        <trans-unit id="eba4dbb75ad90a20a4a3d20676386c7ac0143689" translate="yes" xml:space="preserve">
          <source>Unfortunately, things get a little inaccurate as soon as we take into account concurrency. While a client is locally modifying its new copy of the resource, a second client can fetch the same resource and do the same on its copy. What happens next is very unfortunate: when they commit back to the server, the modifications from the first client are discarded by the next client push, as this second client is unaware of the first client's changes to the resource. The decision on who wins, is not communicated to the other party. Which client's changes are to be kept, will vary with the speed they commit; this depends on the performance of the clients, of the server, and even of the human editing the document at the client. The winner will change from one time to the next. This is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;race condition&lt;/a&gt; and leads to problematic behaviors, which are difficult to detect and to debug:</source>
          <target state="translated">残念ながら、同時実行性を考慮するとすぐに状況は少し不正確になります。クライアントがリソースの新しいコピーをローカルで変更している間に、2番目のクライアントが同じリソースをフェッチして、そのコピーに対して同じことを行うことができます。次に発生するのは非常に残念です。サーバーにコミットすると、最初のクライアントからの変更は、次のクライアントプッシュによって破棄されます。この2番目のクライアントは、最初のクライアントによるリソースへの変更を認識していないためです。勝者の決定は、相手には伝えられません。どのクライアントの変更を保持するかは、コミットする速度によって異なります。これは、クライアント、サーバー、およびクライアントでドキュメントを編集する人間のパフォーマンスに依存します。勝者は次から次へと変わります。これは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;競合状態です&lt;/a&gt;検出やデバッグが難しい問題のある動作につながります。</target>
        </trans-unit>
        <trans-unit id="9d6157fa48e6c6221f34d6df81ed35de4c9f2058" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifier (URI): Generic Syntax</source>
          <target state="translated">統一リソース識別子 (URI)。一般的な構文</target>
        </trans-unit>
        <trans-unit id="5331c3d8fb4de87de8b7a5cbf7bd8ea20f192adf" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URIs) [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] are used throughout
   HTTP as the means for identifying resources (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;Section&amp;nbsp;2 of [RFC7231]&lt;/a&gt;).
   URI references are used to target requests, indicate redirects, and
   define relationships.

   The definitions of &quot;URI-reference&quot;, &quot;absolute-URI&quot;, &quot;relative-part&quot;,
   &quot;scheme&quot;, &quot;authority&quot;, &quot;port&quot;, &quot;host&quot;, &quot;path-abempty&quot;, &quot;segment&quot;,
   &quot;query&quot;, and &quot;fragment&quot; are adopted from the URI generic syntax.  An
   &quot;absolute-path&quot; rule is defined for protocol elements that can
   contain a non-empty path component.  (This rule differs slightly from
   the path-abempty rule of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, which allows for an empty path to
   be used in references, and path-absolute rule, which does not allow
   paths that begin with &quot;//&quot;.)  A &quot;partial-URI&quot; rule is defined for
   protocol elements that can contain a relative URI but not a fragment
   component.

     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
     relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
     scheme        = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
     authority     = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt;
     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     path-abempty  = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     segment       = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     query         = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
     fragment      = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

     absolute-path = 1*( &quot;/&quot; segment )
     partial-URI   = relative-part [ &quot;?&quot; query ]

   Each protocol element in HTTP that allows a URI reference will
   indicate in its ABNF production whether the element allows any form
   of reference (URI-reference), only a URI in absolute form
   (absolute-URI), only the path and optional query components, or some
   combination of the above.  Unless otherwise indicated, URI references
   are parsed relative to the effective request URI (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;).</source>
          <target state="translated">Uniform Resource Identifiers（URIs）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]は、リソースを識別する手段としてHTTP全体で使用されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;[RFC7231]のセクション2&lt;/a&gt;）。 URI参照は、リクエストのターゲット設定、リダイレクトの指定、関係の定義に使用されます。 「URI-reference」、「absolute-URI」、「relative-part」、「scheme」、「authority」、「port」、「host」、「path-abempty」、「segment」、「query」の定義、および「フラグメント」は、URIの一般的な構文から採用されています。 「絶対パス」ルールは、空でないパスコンポーネントを含むことができるプロトコル要素に対して定義されます。 （このルールは、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986の&lt;/a&gt;パスが空のルールとは少し異なります参照で空のパスを使用できるようにする、および「//」で始まるパスを許可しないパス絶対ルール。）相対を含むことができるプロトコル要素に対して「部分URI」ルールが定義されていますURIですが、フラグメントコンポーネントではありません。 URI-reference = &amp;lt;URI-reference、see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986]、Section 4.1&lt;/a&gt; &amp;gt;絶対URI = &amp;lt;absolute-URI、see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]、Section 4.3&lt;/a&gt; &amp;gt; relative-part = &amp;lt;relative-part、see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]、Section 4.2&lt;/a&gt; &amp;gt;スキーム= &amp;lt;スキーム、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986]を&lt;/a&gt;参照、セクション3.1 &amp;gt;権限= &amp;lt;権限、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986]を&lt;/a&gt;参照、セクション3.2 &amp;gt; uri-host = &amp;lt;ホスト、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]を&lt;/a&gt;参照、セクション3.2.2 &amp;gt;ポート= &amp;lt;ポート、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986]、セクション3.2.3&lt;/a&gt; &amp;gt; path-abempty = &amp;lt;path-abempty、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]を&lt;/a&gt;参照、セクション3.3 &amp;gt;セグメント= &amp;lt;segment、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]を&lt;/a&gt;参照、セクション3.3 &amp;gt; query = &amp;lt;query、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[[RFC3986]を&lt;/a&gt;参照]、セクション3.4 &amp;gt;フラグメント= &amp;lt;フラグメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]、セクション3.5を&lt;/a&gt;参照&amp;gt;絶対パス= 1 *（ &quot;/&quot;セグメント）部分URI =相対部分[&quot;？&quot; query] URI参照を許可するHTTPの各プロトコル要素は、その要素が任意の形式の参照（URI参照）、絶対形式のURIのみ（absolute-URI）、パスとオプションのクエリのみを許可するかどうかをABNFプロダクションで示します。コンポーネント、または上記のいくつかの組み合わせ。特に明記されていない限り、URI参照は有効なリクエストURIに基づいて解析されます（&lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="326e61a6296432fcad1af300f3c896bd0e9d0435" translate="yes" xml:space="preserve">
          <source>Uniform Resource Names</source>
          <target state="translated">統一されたリソース名</target>
        </trans-unit>
        <trans-unit id="0f25e6e17d90b442b15b6c3491b583d0eb8a4b09" translate="yes" xml:space="preserve">
          <source>Unless dealing with a very old system, which doesn't support a persistent connection, there is no compelling reason to use this model.</source>
          <target state="translated">持続的接続をサポートしていない非常に古いシステムを扱っている場合を除き、このモデルを使用する説得力のある理由はありません。</target>
        </trans-unit>
        <trans-unit id="7df067eefe56c18b36ec5afe619983a9a5702d6c" translate="yes" xml:space="preserve">
          <source>Unless specifically constrained by a cache-control (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;)
   directive, a caching system MAY always store a successful response
   (see &lt;a href=&quot;#section-13.8&quot;&gt;section 13.8&lt;/a&gt;) as a cache entry, MAY return it without validation
   if it is fresh, and MAY return it after successful validation. If
   there is neither a cache validator nor an explicit expiration time
   associated with a response, we do not expect it to be cached, but
   certain caches MAY violate this expectation (for example, when little
   or no network connectivity is available). A client can usually detect
   that such a response was taken from a cache by comparing the Date
   header to the current time.

      Note: some HTTP/1.0 caches are known to violate this expectation
      without providing any Warning.

   However, in some cases it might be inappropriate for a cache to
   retain an entity, or to return it in response to a subsequent
   request. This might be because absolute semantic transparency is
   deemed necessary by the service author, or because of security or
   privacy considerations. Certain cache-control directives are
   therefore provided so that the server can indicate that certain
   resource entities, or portions thereof, are not to be cached
   regardless of other considerations.

   Note that &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt; normally prevents a shared cache from saving
   and returning a response to a previous request if that request
   included an Authorization header.

   A response received with a status code of 200, 203, 206, 300, 301 or
   410 MAY be stored by a cache and used in reply to a subsequent
   request, subject to the expiration mechanism, unless a cache-control
   directive prohibits caching. However, a cache that does not support
   the Range and Content-Range headers MUST NOT cache 206 (Partial
   Content) responses.

   A response received with any other status code (e.g. status codes 302
   and 307) MUST NOT be returned in a reply to a subsequent request
   unless there are cache-control directives or another header(s) that
   explicitly allow it. For example, these include the following: an
   Expires header (&lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;); a &quot;max-age&quot;, &quot;s-maxage&quot;,  &quot;must-
   revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot; or &quot;private&quot; cache-control
   directive (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">特にcache-control（&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;）ディレクティブによる制約がない限り、キャッシングシステムは常に成功した応答を保存できます（&lt;a href=&quot;#section-13.8&quot;&gt;セクション13.8を&lt;/a&gt;参照）。）キャッシュエントリとして、それが新しい場合は検証せずにそれを返し、検証が成功した後にそれを返す場合があります。キャッシュバリデーターも、応答に関連付けられた明示的な有効期限もない場合、キャッシュされるとは想定されていませんが、特定のキャッシュはこの予想に違反する場合があります（たとえば、ネットワーク接続がほとんどまたはまったくない場合）。クライアントは通常、Dateヘッダーを現在の時刻と比較することにより、そのような応答がキャッシュから取得されたことを検出できます。注：一部のHTTP / 1.0キャッシュは、警告を提供せずにこの期待に違反することがわかっています。ただし、場合によっては、キャッシュがエンティティを保持すること、または後続のリクエストに応じてエンティティを返すことが不適切な場合があります。これは、サービスの作成者が絶対的な意味の透明性を必要とするためと考えられます。または、セキュリティまたはプライバシーに関する考慮事項。したがって、特定のリソースエンティティまたはその一部が他の考慮事項に関係なくキャッシュされないことをサーバーが示すことができるように、特定のキャッシュ制御ディレクティブが提供されます。ご了承ください&lt;a href=&quot;#section-14.8&quot;&gt;セクション14.8&lt;/a&gt;は、通常、リクエストにAuthorizationヘッダーが含まれている場合、共有キャッシュが前のリクエストを保存して応答を返すのを防ぎます。ステータスコード200、203、206、300、301、または410で受信した応答は、キャッシュによって保存され、キャッシュ制御ディレクティブがキャッシュを禁止しない限り、有効期限メカニズムに従って、後続の要求に応答して使用される場合があります。ただし、RangeおよびContent-Rangeヘッダーをサポートしないキャッシュは、206（部分コンテンツ）応答をキャッシュしてはなりません（MUST NOT）。他のステータスコード（ステータスコード302や307など）で受信した応答は、明示的に許可するキャッシュ制御ディレクティブまたは別のヘッダーがない限り、後続の要求への応答で返してはなりません（MUST NOT）。たとえば、次のものが含まれます：Expiresヘッダー（&lt;a href=&quot;#section-14.21&quot;&gt;セクション14.21&lt;/a&gt;）; 「max-age」、「s-maxage」、「must- revalidate」、「proxy-revalidate」、「public」、または「private」キャッシュ制御ディレクティブ（&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6575621a518b7b48c43d42321f561d5d0b99d27e" translate="yes" xml:space="preserve">
          <source>Unless the origin server explicitly prohibits the caching of their
   responses, the application of GET and HEAD methods to any resources
   SHOULD NOT have side effects that would lead to erroneous behavior if
   these responses are taken from a cache. They MAY still have side
   effects, but a cache is not required to consider such side effects in
   its caching decisions. Caches are always expected to observe an
   origin server's explicit restrictions on caching.

   We note one exception to this rule: since some applications have
   traditionally used GETs and HEADs with query URLs (those containing a
   &quot;?&quot; in the rel_path part) to perform operations with significant side
   effects, caches MUST NOT treat responses to such URIs as fresh unless
   the server provides an explicit expiration time. This specifically
   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT
   be taken from a cache. See &lt;a href=&quot;#section-9.1.1&quot;&gt;section 9.1.1&lt;/a&gt; for related information.</source>
          <target state="translated">オリジンサーバーがそれらの応答のキャッシュを明示的に禁止していない限り、リソースへのGETおよびHEADメソッドの適用は、これらの応答がキャッシュから取得された場合に誤動作を引き起こすような副作用があってはなりません。それらはまだ副作用を持っているかもしれませんが、キャッシュはキャッシングの決定においてそのような副作用を考慮する必要はありません。キャッシュは常に、オリジンサーバーのキャッシングに関する明示的な制限を遵守する必要があります。このルールの1つの例外に注意してください。一部のアプリケーションでは、クエリURL（rel_path部分に「？」を含むもの）でGETおよびHEADを伝統的に使用して、重大な副作用のある操作を実行しているため、キャッシュはこのようなURIへの応答を新鮮なものとして処理してはなりません（MUST NOT）サーバーが明示的な有効期限を提供しない限り。これは特に、そのようなURIに対するHTTP / 1.0サーバーからの応答がキャッシュから取得されるべきではないことを意味します。見る&lt;a href=&quot;#section-9.1.1&quot;&gt;&lt;/a&gt;関連情報については、セクション9.1.1。</target>
        </trans-unit>
        <trans-unit id="a882eb5ce8619bac0f4ca38a47d118a374f590ac" translate="yes" xml:space="preserve">
          <source>Unless you have a very specific immediate need, don't use this deprecated technique; switch to HTTP/2 instead. In HTTP/2, domain sharding is no longer useful: the HTTP/2 connection is able to handle parallel unprioritized requests very well. Domain sharding is even detrimental to performance. Most HTTP/2 implementations use a technique called &lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;connection coalescing&lt;/a&gt; to revert eventual domain sharding.</source>
          <target state="translated">非常に具体的な緊急の必要がない限り、この非推奨の手法を使用しないでください。代わりにHTTP / 2に切り替えます。HTTP / 2では、ドメインシャーディングは役に立たなくなりました。HTTP/ 2接続は、優先度のない並列リクエストを非常にうまく処理できます。ドメインシャーディングはパフォーマンスにも悪影響を及ぼします。ほとんどのHTTP / 2実装は、&lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;接続合体&lt;/a&gt;と呼ばれる手法を使用して、最終的なドメインシャーディングを元に戻します。</target>
        </trans-unit>
        <trans-unit id="955f79db78c5cf8385c47043fef1a0ffa744352f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, &quot;preflighted&quot; requests first send an HTTP request by the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other domain, in order to determine whether the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">&lt;a href=&quot;#Simple_requests&quot;&gt;「単純なリクエスト」（前述）&lt;/a&gt;とは異なり、「プリフライト」リクエストは、実際のリクエストが安全に送信できるかどうかを判断するために、最初に&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;メソッドによってHTTPリクエストを他のドメインのリソースに送信します。クロスサイトリクエストは、ユーザーデータに影響を与える可能性があるため、このようにプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="d273c3c1c262b7b14dbca55da7ae721b5a1b7cec" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, for &quot;preflighted&quot; requests the browser first sends an HTTP request using the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other origin, in order to determine if the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">&lt;a href=&quot;#Simple_requests&quot;&gt;「単純なリクエスト」（上記で説明）&lt;/a&gt;とは異なり、「プリフライト」リクエストの場合、ブラウザは最初に&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;メソッドを使用してHTTPリクエストを他のオリジンのリソースに送信し、実際のリクエストを安全に送信できるかどうかを判断します。クロスサイトリクエストは、ユーザーデータに影響を与える可能性があるため、このようにプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="b6e7352000385c24773b5c3b97548547d27dfcec" translate="yes" xml:space="preserve">
          <source>Unlike subsequent evolutions, there were no HTTP headers, meaning that only HTML files could be transmitted, but no other type of documents. There were no status or error codes: in case of a problem, a specific HTML file was send back with the description of the problem contained in it, for human consumption.</source>
          <target state="translated">その後の進化とは異なり、HTTPヘッダがなかったため、HTMLファイルだけが送信され、他の種類の文書は送信できませんでした。ステータスやエラーコードはありませんでした。問題が発生した場合には、特定の HTML ファイルに問題の説明が含まれており、人間が利用できるようになっていました。</target>
        </trans-unit>
        <trans-unit id="dcc5e76d5034fe1dc84b95117a89364e895b52d1" translate="yes" xml:space="preserve">
          <source>Unlike the previous case, browser history will consider non-www and www URLs as independent entries.</source>
          <target state="translated">先ほどのケースとは異なり、ブラウザの履歴では、非wwwとwwwのURLを独立したエントリとみなします。</target>
        </trans-unit>
        <trans-unit id="7607e9b76ed3569248e88c3e032d8ff230e82e7b" translate="yes" xml:space="preserve">
          <source>Unoptimized (poorly compressed) images</source>
          <target state="translated">最適化されていない(圧縮されていない)画像</target>
        </trans-unit>
        <trans-unit id="b89f58bc5f8bec30721ee6218fbce69f661ae508" translate="yes" xml:space="preserve">
          <source>Unoptimized images</source>
          <target state="translated">最適化されていない画像</target>
        </trans-unit>
        <trans-unit id="245e0bd02f62833b644643c9a2e8742e64c2dd7a" translate="yes" xml:space="preserve">
          <source>Unrecognized markup in an Atom Publishing Protocol document is
   considered &quot;foreign markup&quot; as defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; of the Atom
   Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Foreign markup can be used anywhere
   within a Category or Service Document unless it is explicitly
   forbidden.  Processors that encounter foreign markup MUST NOT stop
   processing and MUST NOT signal an error.  Clients SHOULD preserve
   foreign markup when transmitting such documents.

   The namespace name &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; is reserved for
   forward-compatible revisions of the Category and Service Document
   types.  This does not exclude the addition of elements and attributes
   that might not be recognized by processors conformant to this
   specification.  Such unrecognized markup from the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace MUST be treated as foreign
   markup.</source>
          <target state="translated">Atom公開プロトコル文書の認識されないマークアップは、Atom &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;配信&lt;/a&gt;フォーマット[ RFC4287 ]の&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;で定義されている「外部マークアップ」と見なされます。外部マークアップは、明示的に禁止されていない限り、カテゴリまたはサービスドキュメント内の任意の場所で使用できます。外部マークアップに遭遇したプロセッサは、処理を停止してはならず、エラーを通知してはなりません。クライアントは、そのようなドキュメントを送信するときに外部マークアップを保持する必要があります。名前空間名 &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;は、カテゴリおよびサービスドキュメントタイプの上位互換リビジョン用に予約されています。これにより、この仕様に準拠したプロセッサで認識されない可能性のある要素や属性の追加が除外されることはありません。&quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http：// www。 w3.org/2007/app&lt;/a&gt; &quot;名前空間は外部マークアップとして扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="de81198fe40f54ca54fd480498f47c5bd2c4979b" translate="yes" xml:space="preserve">
          <source>Unsafe eval expressions</source>
          <target state="translated">安全でない eval 式</target>
        </trans-unit>
        <trans-unit id="83339b270595929064cc25f1d47c8f0230812a35" translate="yes" xml:space="preserve">
          <source>Unsafe inline script</source>
          <target state="translated">安全でないインラインスクリプト</target>
        </trans-unit>
        <trans-unit id="a3661e5b83227307acd4850c07a9aaa4a3205ae7" translate="yes" xml:space="preserve">
          <source>Unsafe inline styles</source>
          <target state="translated">安全でないインラインスタイル</target>
        </trans-unit>
        <trans-unit id="b9c54338e2e3842fa7755217571c1728460781da" translate="yes" xml:space="preserve">
          <source>Unsafe style expressions</source>
          <target state="translated">安全ではないスタイル表現</target>
        </trans-unit>
        <trans-unit id="51e569288fd4c9764275c80909467d65bb077394" translate="yes" xml:space="preserve">
          <source>Unsized media</source>
          <target state="translated">アンサイズメディア</target>
        </trans-unit>
        <trans-unit id="5428a4130e5ace79ec66056cc912fe9f4aab15ba" translate="yes" xml:space="preserve">
          <source>Unsupported digests</source>
          <target state="translated">サポートされていないダイジェスト</target>
        </trans-unit>
        <trans-unit id="03d0f6e963af156d3bbc20c425d63949186d2932" translate="yes" xml:space="preserve">
          <source>Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="translated">ブラウザが仕様に追いつくまでは、以下のいずれかまたは両方を実行することで、この制限を回避できるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f9c20faccf27f6079a0458f999820126675b4735" translate="yes" xml:space="preserve">
          <source>Until version 75, downloads for files with this header would fail in Chrome. See &lt;a href=&quot;https://crbug.com/952834&quot;&gt;bug 952834&lt;/a&gt;.</source>
          <target state="translated">バージョン75までは、このヘッダーを含むファイルのダウンロードはChromeで失敗していました。&lt;a href=&quot;https://crbug.com/952834&quot;&gt;バグ952834を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8eb9592768ded8c17e4696edcc1f40830d0ef453" translate="yes" xml:space="preserve">
          <source>Until version 75, downloads for files with this header would fail in WebView. See &lt;a href=&quot;https://crbug.com/952834&quot;&gt;bug 952834&lt;/a&gt;.</source>
          <target state="translated">バージョン75までは、このヘッダーを含むファイルのダウンロードはWebViewで失敗していました。&lt;a href=&quot;https://crbug.com/952834&quot;&gt;バグ952834を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="56a7c8e0f8f826b048cc60b6edd36eb21796fb60" translate="yes" xml:space="preserve">
          <source>Updated. The request resulted in a potential change to the tracking status applicable to this user, user agent, or device.</source>
          <target state="translated">更新されました。リクエストの結果、このユーザー、ユーザーエージェント、またはデバイスに適用されるトラッキングステータスに変更がある可能性がありました。</target>
        </trans-unit>
        <trans-unit id="a6f47e00e036c5589eb12e237894b37fb015d365" translate="yes" xml:space="preserve">
          <source>Upgrade</source>
          <target state="translated">Upgrade</target>
        </trans-unit>
        <trans-unit id="ac2a73c827836daeaf2402394c054c2277994448" translate="yes" xml:space="preserve">
          <source>Upgrade (RFC 2616)</source>
          <target state="translated">アップグレード (RFC2616)</target>
        </trans-unit>
        <trans-unit id="541adf48138ad8391190feed85e1730b3e897f18" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests</source>
          <target state="translated">安全でないリクエストのアップグレード</target>
        </trans-unit>
        <trans-unit id="03453046fa615930ff26806bfd5e6e667dba241d" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests&lt;br/&gt;&lt;small&gt;The definition of 'upgrade-insecure-requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">安全でない要求&lt;small&gt;のアップグレードその仕様における「&lt;/small&gt;アップグレード安全でない要求」&lt;br/&gt;&lt;small&gt;の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="61c6967492e019e22cb265be59268846e0812c5e" translate="yes" xml:space="preserve">
          <source>Upgrade-Insecure-Requests</source>
          <target state="translated">Upgrade-Insecure-Requests</target>
        </trans-unit>
        <trans-unit id="3b1e9dd129f9691779584493ef0cbd2760709427" translate="yes" xml:space="preserve">
          <source>Upgrading HTTP/1.1 Connections</source>
          <target state="translated">HTTP/1.1接続のアップグレード</target>
        </trans-unit>
        <trans-unit id="373052ca50b595448fddb3ae3555f3abe2335a7b" translate="yes" xml:space="preserve">
          <source>Upgrading an HTTP connection to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with the token &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt;. If the switch is made successfully, the original request (which included &lt;code&gt;Upgrade&lt;/code&gt;) is completed as normal, but on the TLS connection.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLSを&lt;/a&gt;使用するようにHTTP接続をアップグレードするには、トークン &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt; を含む&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーを使用します。切り替えが正常に行われた場合、元の要求（ &lt;code&gt;Upgrade&lt;/code&gt; を含む）は通常どおりに完了しますが、TLS接続上で行われます。</target>
        </trans-unit>
        <trans-unit id="ab6bbb4d08469c650377ccf5de1a9d9d4253b906" translate="yes" xml:space="preserve">
          <source>Upgrading to TLS Within HTTP/1.1</source>
          <target state="translated">HTTP/1.1内のTLSへのアップグレード</target>
        </trans-unit>
        <trans-unit id="4a01efdfa6f7b943dbd14d96f1bbda14ed6ca745" translate="yes" xml:space="preserve">
          <source>Upgrading to a WebSocket connection</source>
          <target state="translated">WebSocket 接続へのアップグレード</target>
        </trans-unit>
        <trans-unit id="0df7fec503cc297ba369a863eb42d823f8a3ecf0" translate="yes" xml:space="preserve">
          <source>Upgrading to an HTTP/2 connection</source>
          <target state="translated">HTTP/2 接続へのアップグレード</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="92d99b032888bf69448943e3813f272f0f43c556" translate="yes" xml:space="preserve">
          <source>Usage notes</source>
          <target state="translated">使用上の注意</target>
        </trans-unit>
        <trans-unit id="206d556a43a2ee8de81319e120005dc792bee741" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="translated">使い方 &lt;code&gt;isInNet()&lt;/code&gt; 、 &lt;code&gt;isResolvable()&lt;/code&gt; および &lt;code&gt;dnsResolve()&lt;/code&gt; 彼らは相談するようにDNSサーバを必要とする機能は慎重に検討する必要があります。他のすべてのautoconfig関連関数は、DNSサーバーの使用を必要としない単なる文字列照合関数です。プロキシが使用されている場合、プロキシはDNSルックアップを実行し、DNSサーバーへの影響を2倍にします。ほとんどの場合、これらの機能は目的の結果を達成するために必要ではありません。</target>
        </trans-unit>
        <trans-unit id="609254f79607923f3629c1a1e3f48cf232c1eba4" translate="yes" xml:space="preserve">
          <source>Use SOCKS if the primary proxy goes down.</source>
          <target state="translated">プライマリプロキシがダウンした場合はSOCKSを使用してください。</target>
        </trans-unit>
        <trans-unit id="8b4ff35cb43293441d2110cc488f4176d62f368d" translate="yes" xml:space="preserve">
          <source>Use and Interpretation of HTTP Version Numbers</source>
          <target state="translated">HTTP バージョン番号の使用と解釈</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
