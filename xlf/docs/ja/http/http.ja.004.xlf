<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="a5c2516af3446d0b014a66cd8335c651bab61880" translate="yes" xml:space="preserve">
          <source>Define the lifetime of a cookie</source>
          <target state="translated">クッキーの寿命を定義する</target>
        </trans-unit>
        <trans-unit id="6dead4f5e7150393c68c21004bedb55c7c195d60" translate="yes" xml:space="preserve">
          <source>Define where cookies are sent</source>
          <target state="translated">クッキーの送信先の定義</target>
        </trans-unit>
        <trans-unit id="245c3e85d7084e6fe802cca877477e7792e1d78f" translate="yes" xml:space="preserve">
          <source>Defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="translated">要求された応答がプロキシによってアクセスされなければならないことを 示すために、以前のバージョンのHTTP仕様で定義された。プロキシのバンド内設定に関するセキュリティ上の懸念のために 非推奨とされています。</target>
        </trans-unit>
        <trans-unit id="ab39d71630263cb06de73047fe986abf13013e75" translate="yes" xml:space="preserve">
          <source>Defines &lt;code&gt;connect-src&lt;/code&gt;, &lt;code&gt;default-src&lt;/code&gt;, &lt;code&gt;font-src&lt;/code&gt;, &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;img-src&lt;/code&gt;, &lt;code&gt;media-src&lt;/code&gt;, &lt;code&gt;object-src&lt;/code&gt;, report-uri, &lt;code&gt;sandbox&lt;/code&gt;, &lt;code&gt;script-src,&lt;/code&gt; and &lt;code&gt;style-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect-src&lt;/code&gt; 、 &lt;code&gt;default-src&lt;/code&gt; 、 &lt;code&gt;font-src&lt;/code&gt; 、 &lt;code&gt;frame-src&lt;/code&gt; 、 &lt;code&gt;img-src&lt;/code&gt; 、 &lt;code&gt;media-src&lt;/code&gt; 、 &lt;code&gt;object-src&lt;/code&gt; 、report-uri、 &lt;code&gt;sandbox&lt;/code&gt; 、 &lt;code&gt;script-src,&lt;/code&gt; および &lt;code&gt;style-src&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="40978ed9d38521abaff2d2262f9c89c7cd595480" translate="yes" xml:space="preserve">
          <source>Defines a mechanism that enables developers to declare a network error reporting policy.</source>
          <target state="translated">開発者がネットワークエラー報告ポリシーを宣言できるようにするメカニズムを定義します。</target>
        </trans-unit>
        <trans-unit id="eacb52986e3e740e8c70b75c3e7482999a612bff" translate="yes" xml:space="preserve">
          <source>Defines the &lt;code&gt;fullscreen&lt;/code&gt; policy.</source>
          <target state="translated">&lt;code&gt;fullscreen&lt;/code&gt; ポリシーを定義します。</target>
        </trans-unit>
        <trans-unit id="d951108d1c6ab12879dc6ad6f06e33639209ba4b" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource behind a proxy server.</source>
          <target state="translated">プロキシサーバの背後にあるリソースへのアクセスに使用する認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="02ebc06a403db3f222282cbfb2aa8be80e23aefc" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource.</source>
          <target state="translated">リソースへのアクセスに使用する認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="34b169a4830ca101a24b3e67607bce56b1c91720" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource behind a Proxy server.</source>
          <target state="translated">プロキシサーバの背後にあるリソースへのアクセスに使用する認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="6543a340c8cdd818ac73a63a94d4fd7de57aba8d" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">リソースへのアクセスを得るために使用する認証方法を定義します。</target>
        </trans-unit>
        <trans-unit id="7826d05e84456b5b15119edee382be8851b9547e" translate="yes" xml:space="preserve">
          <source>Defines the range unit the server supports. Though &lt;code&gt;bytes&lt;/code&gt; is the only range unit formally defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, additional range units may be registered in the&lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt; HTTP Range Unit Registry&lt;/a&gt;.</source>
          <target state="translated">サーバーがサポートする範囲単位を定義します。 &lt;code&gt;bytes&lt;/code&gt; は&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;で正式に定義されている唯一の範囲単位ですが、追加の範囲単位を&lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt;HTTP範囲単位レジストリに登録でき&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f8dcc75b63979f2db11f899a91470adab4ff1cb6" translate="yes" xml:space="preserve">
          <source>Defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;などの要素を使用して読み込まれた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Webワーカー&lt;/a&gt;とネストされたブラウジングコンテキストの有効なソースを定義します。</target>
        </trans-unit>
        <trans-unit id="b64b866be84f841a370d95030a45025c6a3e04e9" translate="yes" xml:space="preserve">
          <source>Denial-of-service attacks are of special concern to WebDAV servers.
   WebDAV plus HTTP enables denial-of-service attacks on every part of a
   system's resources.

   o  The underlying storage can be attacked by PUTting extremely large
      files.

   o  Asking for recursive operations on large collections can attack
      processing time.

   o  Making multiple pipelined requests on multiple connections can
      attack network connections.

   WebDAV servers need to be aware of the possibility of a denial-of-
   service attack at all levels.  The proper response to such an attack
   MAY be to simply drop the connection.  Or, if the server is able to
   make a response, the server MAY use a 400-level status request such
   as 400 (Bad Request) and indicate why the request was refused (a 500-
   level status response would indicate that the problem is with the
   server, whereas unintentional DoS attacks are something the client is
   capable of remedying).</source>
          <target state="translated">サービス拒否攻撃は、WebDAV サーバにとって特別な懸念事項です。WebDAV plus HTTP は、システムのリソースのあらゆる部分に対してサービス拒否攻撃を可能にします。 o 基礎となるストレージは、非常に大きなファイルをPUTすることで攻撃を受ける可能性があります。WebDAV サーバはすべてのレベルでサービス拒否攻撃の可能性を認識しておく必要があります。このような攻撃に対する適切な対応は、単に接続を切断してもよい[MAY]。あるいは、サーバが応答できる場合、サーバは400(Bad Request)のような400レベルのステータスリクエストを使用して、リクエストが拒否された理由を示してもよい[MAY](500レベルのステータスレスポンスは、問題がサーバにあることを示します。</target>
        </trans-unit>
        <trans-unit id="89de95bda785091ad4670c2c51c5dd042349d3eb" translate="yes" xml:space="preserve">
          <source>Deprecate modification of 'secure' cookies from non-secure origins</source>
          <target state="translated">安全でない起源からの「安全な」クッキーの変更を非推奨</target>
        </trans-unit>
        <trans-unit id="efb41926689d64456523d9abd88a8e204ff7906a" translate="yes" xml:space="preserve">
          <source>Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; を非推奨にしました。</target>
        </trans-unit>
        <trans-unit id="e4f0c7b98ab40a4d967b59248a69752d5ae464d4" translate="yes" xml:space="preserve">
          <source>Depth = &quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)

   The Depth request header is used with methods executed on resources
   that could potentially have internal members to indicate whether the
   method is to be applied only to the resource (&quot;Depth: 0&quot;), to the
   resource and its internal members only (&quot;Depth: 1&quot;), or the resource
   and all its members (&quot;Depth: infinity&quot;).

   The Depth header is only supported if a method's definition
   explicitly provides for such support.

   The following rules are the default behavior for any method that
   supports the Depth header.  A method may override these defaults by
   defining different behavior in its definition. 

   Methods that support the Depth header may choose not to support all
   of the header's values and may define, on a case-by-case basis, the
   behavior of the method if a Depth header is not present.  For
   example, the MOVE method only supports &quot;Depth: infinity&quot;, and if a
   Depth header is not present, it will act as if a &quot;Depth: infinity&quot;
   header had been applied.

   Clients MUST NOT rely upon methods executing on members of their
   hierarchies in any particular order or on the execution being atomic
   unless the particular method explicitly provides such guarantees.

   Upon execution, a method with a Depth header will perform as much of
   its assigned task as possible and then return a response specifying
   what it was able to accomplish and what it failed to do.

   So, for example, an attempt to COPY a hierarchy may result in some of
   the members being copied and some not.

   By default, the Depth header does not interact with other headers.
   That is, each header on a request with a Depth header MUST be applied
   only to the Request-URI if it applies to any resource, unless
   specific Depth behavior is defined for that header.

   If a source or destination resource within the scope of the Depth
   header is locked in such a way as to prevent the successful execution
   of the method, then the lock token for that resource MUST be
   submitted with the request in the If request header.

   The Depth header only specifies the behavior of the method with
   regards to internal members.  If a resource does not have internal
   members, then the Depth header MUST be ignored.</source>
          <target state="translated">Depth=&quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)Depth 要求ヘッダは、内部メンバを持つ可能性のあるリソース上で実行されるメソッドで使用され、メソッドがリソースのみに適用されるか (Depth:0)、リソースとその内部メンバのみに適用されるか (Depth:1)、またはリソースとそのすべてのメンバに適用されるか (Depth:infinity)を示すために使用されます。Depthヘッダは、メソッドの定義で明示的にそのようなサポートを規定している場合にのみサポートされます。以下のルールは、Depth ヘッダーをサポートするメソッドの既定の動作です。メソッドは、定義で異なる動作を定義することで、これらの既定の動作をオーバーライドできます。Depth ヘッダをサポートするメソッドは、ヘッダのすべての値をサポートしないことを選択することができ、Depth ヘッダが存在しない場合のメソッドの動作をケースバイケースで定義することができます。例えば、MOVEメソッドは「Depth:infinity」のみをサポートしており、Depthヘッダーが存在しない場合、「Depth:infinity」ヘッダーが適用されたかのように動作する。クライアントは、特定のメソッドが明示的にそのような保証を提供しない限り、特定の順序で階層のメンバ上で実行されるメソッドや、実行がアトミックであることに依存してはなりません(MUST NOT)。実行時に、Depth ヘッダを持つメソッドは、割り当てられたタスクを可能な限り実行し、それが何を達成できたか、何を失敗したかを指定したレスポンスを返します。例えば、階層をCOPYしようとすると、一部のメンバはコピーされ、一部のメンバはコピーされないという結果になるかもしれません。デフォルトでは、Depthヘッダは他のヘッダとは相互作用しません。つまり、Depthヘッダーを持つリクエストの各ヘッダーは、そのヘッダーに対して特定のDepth 動作が定義されていない限り、どのリソースにも適用される場合、Request-URIにのみ 適用されなければならない[MUST]。Depthヘッダーの範囲内のソースまたはデスティネーションリソー スが、メソッドの成功した実行を妨げるような方法でロックされている 場合、そのリソースに対するロックトークンがIfリクエストヘッダーでリク エストとともに提出されなければならない[MUST]。Depthヘッダーは、内部メンバに関するメソッドの動作を指定するだけである。リソースが内部メンバを持たない場合、Depthヘッダーは無視されなければ ならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="c3f35f2651dfb57ad3dbd2465104d1927bb97b16" translate="yes" xml:space="preserve">
          <source>Describes how Web resources are referenced and how to locate them.</source>
          <target state="translated">Web リソースがどのように参照されているか、およびそれらを見つける方法について説明します。</target>
        </trans-unit>
        <trans-unit id="13eefb880344c770ed016914712964de5ecee92a" translate="yes" xml:space="preserve">
          <source>Describes how web resources are referenced and how to locate them.</source>
          <target state="translated">Web リソースがどのように参照されているか、およびそれらを見つける方法について説明します。</target>
        </trans-unit>
        <trans-unit id="932bd93206e0c74c22f35c1fa3ed7a4be6439b83" translate="yes" xml:space="preserve">
          <source>Describes the human language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">聴衆のために意図された人間の言語を記述し、ユーザーがユーザー自身の好みの言語に応じて差別化できるようにします。</target>
        </trans-unit>
        <trans-unit id="70c9f2b9944695efcc3168d72ca8c97f9659ed15" translate="yes" xml:space="preserve">
          <source>Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">聴衆のために意図された言語を説明し、ユーザーがユーザー自身の好みの言語に応じて差別化できるようにします。</target>
        </trans-unit>
        <trans-unit id="d5ca427b8a632e16915ddd1ca200bfe11ba09ba7" translate="yes" xml:space="preserve">
          <source>Describes the three connection management models available in HTTP/1.x, their strengths, and their weaknesses.</source>
          <target state="translated">HTTP/1.xで利用可能な3つの接続管理モデル、その長所と短所について説明します。</target>
        </trans-unit>
        <trans-unit id="a9a26ce3467081341f2f33fd2f385b9b4b5a76b7" translate="yes" xml:space="preserve">
          <source>Describes the type and structure of the different kind of messages of HTTP/1.x and HTTP/2.</source>
          <target state="translated">HTTP/1.x と HTTP/2 の異なる種類のメッセージの種類と構造について説明します。</target>
        </trans-unit>
        <trans-unit id="045b1f4c38aa570756046a04e9ca60247fc160b5" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in the Web architecture, its position in the protocol stack.</source>
          <target state="translated">HTTP とは何か、Web アーキテクチャにおけるその役割、プロトコルスタックにおけるその位置について説明します。</target>
        </trans-unit>
        <trans-unit id="724e541fe26287b5d45feca3f617b30de64a8464" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in web architecture, including its position in the protocol stack.</source>
          <target state="translated">HTTPとは何か、ウェブアーキテクチャにおけるHTTPの役割について、プロトコルスタックの中での位置づけを含めて説明します。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="6011dbf6cfab599fb1f5bc7fc964691bbd1b3180" translate="yes" xml:space="preserve">
          <source>Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;, or over a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.</source>
          <target state="translated">1990年代初頭に設計されたHTTPは、時間とともに進化してきた拡張可能なプロトコルです。これは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;暗号化TCP接続を介して送信されるアプリケーション層プロトコルですが、理論的には信頼性の高いトランスポートプロトコルを使用できます。その拡張性により、ハイパーテキストドキュメントだけでなく、画像やビデオを取得したり、HTMLフォームの結果のようにコンテンツをサーバーに投稿したりするためにも使用されます。HTTPを使用して、ドキュメントの一部をフェッチし、オンデマンドでWebページを更新することもできます。</target>
        </trans-unit>
        <trans-unit id="532c67fe1b5afae15d2d08fba7a78de0f63cc4b5" translate="yes" xml:space="preserve">
          <source>Desktop</source>
          <target state="translated">Desktop</target>
        </trans-unit>
        <trans-unit id="dfd0263c11d50bfbcd6f11a03ba9f3544f34bf13" translate="yes" xml:space="preserve">
          <source>Despite &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; being &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;registered with IANA&lt;/a&gt;, it is largely unsupported, and &lt;code&gt;image/x-icon&lt;/code&gt; is being used instead.</source>
          <target state="translated">&lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;はIANA&lt;/a&gt;に登録されていますが、ほとんどサポートされておらず、代わりに &lt;code&gt;image/x-icon&lt;/code&gt; が使用されています。</target>
        </trans-unit>
        <trans-unit id="2c9a54d2465a44e3b40b84b59d11de3a6c0cadc8" translate="yes" xml:space="preserve">
          <source>Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">将来のリクエストヘッダをどのようにマッチさせるかを決定し、 元のサーバから新しいものをリクエストするのではなく、 キャッシュされた応答を使用できるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="6d8108385e143b7a138219a9ade7a2c3c2bf95f5" translate="yes" xml:space="preserve">
          <source>Determines how to match request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">元のサーバから新しいものをリクエストするのではなく、 キャッシュされたレスポンスを使用できるかどうかを決定するために、 リクエストヘッダをどのようにマッチさせるかを決定します。</target>
        </trans-unit>
        <trans-unit id="2e965db93ca2d2ed880afa222771550e11edd88c" translate="yes" xml:space="preserve">
          <source>Device-specific</source>
          <target state="translated">Device-specific</target>
        </trans-unit>
        <trans-unit id="504f16935ab18165c15c8ac0d71a7134e267a656" translate="yes" xml:space="preserve">
          <source>Device-specific user agent strings</source>
          <target state="translated">デバイス固有のユーザーエージェント文字列</target>
        </trans-unit>
        <trans-unit id="ceb4688658b58abe9c95bf427c98e66f4be1e7a3" translate="yes" xml:space="preserve">
          <source>Different kinds of caches</source>
          <target state="translated">キャッシュの種類の違い</target>
        </trans-unit>
        <trans-unit id="1ca0ed6389159c54076291dfd79987d9f92fb6b6" translate="yes" xml:space="preserve">
          <source>Directive type</source>
          <target state="translated">指令型</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="691c26c4ce33366b87dae4f9e53ebeaaa6a4d716" translate="yes" xml:space="preserve">
          <source>Directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">リクエストとレスポンスの両方でのキャッシュメカニズムのためのディレクティブ。</target>
        </trans-unit>
        <trans-unit id="d32a74ca0f336eef375d6cd3af907aa1d40f0be6" translate="yes" xml:space="preserve">
          <source>Directives that define whether a response/request can be cached, where it may be cached, and whether it must be validated with the origin server before caching.</source>
          <target state="translated">レスポンス/リクエストをキャッシュできるかどうか、どこにキャッシュできるか、キャッシュする前にオリジンサーバで検証しなければならないかどうかを定義するディレクティブです。</target>
        </trans-unit>
        <trans-unit id="f4f4473df8cb59f0a369aebee3d1509adc0151c6" translate="yes" xml:space="preserve">
          <source>Disabled</source>
          <target state="translated">Disabled</target>
        </trans-unit>
        <trans-unit id="787d14cbc3437c5c1be6e012c1af87a9cce09ce1" translate="yes" xml:space="preserve">
          <source>Disabled From version 35 until version 37 (exclusive): this feature is behind the &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;) and the &lt;code&gt;altsvc.oe&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン35からバージョン37（排他的）まで：この機能は、 &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; プリファレンス（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）および &lt;code&gt;altsvc.oe&lt;/code&gt; プリファレンス（trueに設定する必要があります）の背後にあり &lt;code&gt;true&lt;/code&gt; 。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="5f484ad36a1ee3a334bfeaabcdd32d70515f88ee" translate="yes" xml:space="preserve">
          <source>Disabled From version 47: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン47以降：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="e8b112b210a8f4589c98ad826e6212c056804fde" translate="yes" xml:space="preserve">
          <source>Disabled From version 48: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン48以降：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="89947c297946cdea762cd2db19147fd97a643839" translate="yes" xml:space="preserve">
          <source>Disabled From version 49 until version 68 (exclusive): this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン49からバージョン68（排他的）まで：この機能は、 &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="b23e78cd51ef4c7696b73e65f06fc0fba687013d" translate="yes" xml:space="preserve">
          <source>Disabled From version 49: this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン49以降：この機能は &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxの設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="acf361a5483e12203a0c0598d3d3f3664a139585" translate="yes" xml:space="preserve">
          <source>Disabled From version 50: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン50以降：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="f7790dccb9f3d88c21e6418f32f87789fb463366" translate="yes" xml:space="preserve">
          <source>Disabled From version 52: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン52以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="ad350d06e4ae5e37d57c0405b7c8e1fbfca3f705" translate="yes" xml:space="preserve">
          <source>Disabled From version 53: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン53以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="01d0cf4c918a77e56e449b4d149616907d38849e" translate="yes" xml:space="preserve">
          <source>Disabled From version 55: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン55以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="02423b2163f75291aa5854698bba6b1f6a5052f1" translate="yes" xml:space="preserve">
          <source>Disabled From version 56: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン56以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="4b34d34dcaec154df6181d68e5bec4643debe21c" translate="yes" xml:space="preserve">
          <source>Disabled From version 59: this feature is behind the &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン59以降：この機能は &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxの設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="40734bba86a26fa4c0ddd48daccbe4d758349227" translate="yes" xml:space="preserve">
          <source>Disabled From version 60: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン60から：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="73719b598079cc354ff255d41acbbe0b420ae879" translate="yes" xml:space="preserve">
          <source>Disabled From version 62: this feature is behind the &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン62以降：この機能は &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxの設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="7847ec1580ce5ad83ab59a78912ccb3ab21e102b" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン65以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="5a54bae2672ba58fd0d7d8cd35ca056cf1ce8f92" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン65以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスします。</target>
        </trans-unit>
        <trans-unit id="6aac50e494a4685cfa01b409c7700b3851e9f9e7" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン65から：この機能は &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="726ec65869fe460716d9db41541949cae8c24c4e" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン66以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="aebc6632a71f5502b11ed22ad8c5755ec1c88bfe" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン66以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスします。</target>
        </trans-unit>
        <trans-unit id="366e50a33639dd16e2b224c5a3ee5b82578e4e0e" translate="yes" xml:space="preserve">
          <source>Disabled From version 67: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン67から：この機能は &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="56705b66ed39339d0a4b894306b2ecabb3efd7c6" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン68以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="2dcbb985ceab20f02611932df74cc051d6062ad2" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン68以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスします。</target>
        </trans-unit>
        <trans-unit id="d28e2d242fc0c32d88a4828425be70d8d4e9386c" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン69以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="dc43adf822f8071bf38b741b4c8b4ff8caa87dd2" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン69以降：この機能は &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 設定の背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスします。</target>
        </trans-unit>
        <trans-unit id="e63694ea8ef64e459c00d7c0d93772ca98cd8c0d" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン69から：この機能は &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="0e6c448fbfef096f82b450df55d6a46e80c7144a" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン69から：この機能は &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="d2696e5d2f6597ff6db717b5917fe7ef78b21f49" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン72から：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="932bbade750d61ada15f0c29ceb15ac8767a08c2" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">無効バージョン72から：この機能は &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;true&lt;/code&gt; に設定する必要があります）。Firefoxで設定を変更するには、about：configにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="d78775da32cd4aa8691fe3765af5c89229860835" translate="yes" xml:space="preserve">
          <source>Disabled From version 73 until version 76 (exclusive): this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">無効バージョン73からバージョン76（排他的）まで：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。Chromeの設定を変更するには、chrome：// flagsにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="d49a2f2138558d7e247fc15cdf0f8f8e80da02a9" translate="yes" xml:space="preserve">
          <source>Disabled From version 79: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">無効バージョン79から：この機能は、 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; プリファレンスの背後にあります（ &lt;code&gt;Enabled&lt;/code&gt; に設定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="efbf731d4f27dd707439b02e0fcf767655467961" translate="yes" xml:space="preserve">
          <source>Disables DNS prefetching. This is useful if you don't control the link on the pages, or know that you don't want to leak information to these domains.</source>
          <target state="translated">DNS のプリフェッチを無効にします。これは、ページ上のリンクを制御しない場合や、これらのドメインに情報を漏らしたくないことがわかっている場合に便利です。</target>
        </trans-unit>
        <trans-unit id="58f5f4ebc16939ddad056d1835f255075e38be52" translate="yes" xml:space="preserve">
          <source>Disables MIME sniffing and forces browser to use the type given in &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">MIMEスニッフィングを無効にし、ブラウザが&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; で&lt;/a&gt;指定されたタイプを使用するように強制します。</target>
        </trans-unit>
        <trans-unit id="4c27076a7d462b5b7f6f1b44922f1242a3e46ba5" translate="yes" xml:space="preserve">
          <source>Disables XSS filtering.</source>
          <target state="translated">XSSフィルタリングを無効にします。</target>
        </trans-unit>
        <trans-unit id="57822983bbd8b7a6c9f3de16f7fe5eab989d06a5" translate="yes" xml:space="preserve">
          <source>Disabling a feature in a policy is a one-way toggle. If a feature has been disabled for a child frame by its parent frame, the child cannot re-enable it, and neither can any of the child's descendants.</source>
          <target state="translated">ポリシー内の機能を無効にすることは、一方通行のトグルです。親フレームによって子フレームの機能が無効化されている場合、子フレームはその機能を再有効化することはできませんし、子の子孫も無効化することはできません。</target>
        </trans-unit>
        <trans-unit id="b95dd3eb6900d93a418238bf7a5a3a1a746e7c86" translate="yes" xml:space="preserve">
          <source>Disallowing plugins</source>
          <target state="translated">プラグインの禁止</target>
        </trans-unit>
        <trans-unit id="93902c2eda1c4f4fa6e24f3a214f7642478627b6" translate="yes" xml:space="preserve">
          <source>Disconnected Operation</source>
          <target state="translated">切断された操作</target>
        </trans-unit>
        <trans-unit id="c5bdaaa9046da0ea03b3b9660b87425b983b09dd" translate="yes" xml:space="preserve">
          <source>Discrete types</source>
          <target state="translated">離散型</target>
        </trans-unit>
        <trans-unit id="d69e4d6aad6c625810f7014dfc3dfbd01898d5b3" translate="yes" xml:space="preserve">
          <source>Discussion of HTTP headers</source>
          <target state="translated">HTTPヘッダの議論</target>
        </trans-unit>
        <trans-unit id="e7414bd7b2a8ae1b4152a32e27208f6ea5703ede" translate="yes" xml:space="preserve">
          <source>Display security and privacy policies In Firefox Developer Tools</source>
          <target state="translated">セキュリティとプライバシーポリシーを表示する Firefox 開発者ツールで</target>
        </trans-unit>
        <trans-unit id="d78de940f6bf90261043cb8bd08624772df60547" translate="yes" xml:space="preserve">
          <source>Disregarding DNT. The origin server is unable or unwilling to respect a tracking preference received from the requesting user agent.</source>
          <target state="translated">DNTを無視する。オリジンサーバは、要求するユーザエージェントから受信した追跡優先順位を尊重できないか、または尊重したくない。</target>
        </trans-unit>
        <trans-unit id="4a1de6fc43e38e089c17a80c82ba419f8f473962" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; use this meta element like this for stating a document language:</source>
          <target state="translated">ドキュメントの言語を示すために、次のようなこのメタ要素を使用し&lt;strong&gt;ないで&lt;/strong&gt;ください。</target>
        </trans-unit>
        <trans-unit id="2c25376cd1e5d495d8c85d1b29c113dcd4496160" translate="yes" xml:space="preserve">
          <source>Do Not Track</source>
          <target state="translated">追跡しないでください</target>
        </trans-unit>
        <trans-unit id="70f963907a2dc441e4078146477cb1ac975253ce" translate="yes" xml:space="preserve">
          <source>Do Not Track on Wikipedia</source>
          <target state="translated">ウィキペディアで追跡しないでください</target>
        </trans-unit>
        <trans-unit id="5de6d660ffd0c31bb077df9301609dfb8cf69667" translate="yes" xml:space="preserve">
          <source>Do you want to provide different HTML depending on which browser is being used?</source>
          <target state="translated">どのブラウザを使用しているかによって異なるHTMLを提供したいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="96d09f4b8e17c5718c2731ce7ab9928e287257a4" translate="yes" xml:space="preserve">
          <source>Do-Not-Track</source>
          <target state="translated">Do-Not-Track</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="54500ed3527305b0f92d5cf278622f552f491a43" translate="yes" xml:space="preserve">
          <source>Document directive</source>
          <target state="translated">指令書</target>
        </trans-unit>
        <trans-unit id="f2213ce4b36d0f4e6e226bd21f16b5d5bf80dcba" translate="yes" xml:space="preserve">
          <source>Document directives</source>
          <target state="translated">ガイドライン文書</target>
        </trans-unit>
        <trans-unit id="ec6b0754c2e6157428f7e2691227c09de666ec35" translate="yes" xml:space="preserve">
          <source>Document directives govern the properties of a document or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;worker&lt;/a&gt; environment to which a policy applies.</source>
          <target state="translated">ドキュメントディレクティブは、ポリシーが適用されるドキュメントまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;ワーカー&lt;/a&gt;環境のプロパティを管理します。</target>
        </trans-unit>
        <trans-unit id="48b3bb8b0a579c9e6fbd40516291d94dca86d1ba" translate="yes" xml:space="preserve">
          <source>Does not work below Windows 10.</source>
          <target state="translated">Windows10以下では動作しません。</target>
        </trans-unit>
        <trans-unit id="5a6dfa8179f4637130555f525186dd9377736169" translate="yes" xml:space="preserve">
          <source>Does not work on Windows 7 and Windows 8.1.</source>
          <target state="translated">Windows 7、Windows 8.1では動作しません。</target>
        </trans-unit>
        <trans-unit id="ea664539e7e07c3b3cb2d4e3bb71cc99d18e5b5b" translate="yes" xml:space="preserve">
          <source>Domain aliasing</source>
          <target state="translated">ドメインエイリアシング</target>
        </trans-unit>
        <trans-unit id="3b549bffd9a85f8fa78b065a75e77e845bc42471" translate="yes" xml:space="preserve">
          <source>Domain aliasing can be done for several reasons:</source>
          <target state="translated">ドメインエイリアシングは、いくつかの理由で行うことができます。</target>
        </trans-unit>
        <trans-unit id="66a72f8713e4b8fdfa4a8582d2a117d6b82dbadd" translate="yes" xml:space="preserve">
          <source>Domain attribute</source>
          <target state="translated">ドメイン属性</target>
        </trans-unit>
        <trans-unit id="690d7332b26bc38eab02d6b1abf316a940401914" translate="yes" xml:space="preserve">
          <source>Domain sharding</source>
          <target state="translated">ドメインシャーディング</target>
        </trans-unit>
        <trans-unit id="3c61580d55d642952fbec533e8d3f2630a7d8e94" translate="yes" xml:space="preserve">
          <source>Domain=&amp;lt;domain-value&amp;gt; Optional</source>
          <target state="translated">Domain = &amp;lt;domain-value&amp;gt;オプション</target>
        </trans-unit>
        <trans-unit id="dc4653bff510cf1118951874eb552343ce4eeea4" translate="yes" xml:space="preserve">
          <source>Download resumption in Internet Explorer</source>
          <target state="translated">インターネットエクスプローラでの再開のダウンロード</target>
        </trans-unit>
        <trans-unit id="a862c2b21b5e1337de2b76d5e43ae1375117d34d" translate="yes" xml:space="preserve">
          <source>Downloads</source>
          <target state="translated">Downloads</target>
        </trans-unit>
        <trans-unit id="23d33e22acfcb9ecddb4a85f10607dc4ff49e23c" translate="yes" xml:space="preserve">
          <source>Draft</source>
          <target state="translated">Draft</target>
        </trans-unit>
        <trans-unit id="13ae8e0a7cb29b1ff62023de94998bfc639787c9" translate="yes" xml:space="preserve">
          <source>Draft document</source>
          <target state="translated">ドラフト文書</target>
        </trans-unit>
        <trans-unit id="ddc6d4101d699284c4ee49346220f3fb8a444994" translate="yes" xml:space="preserve">
          <source>Draft spec</source>
          <target state="translated">ドラフト仕様</target>
        </trans-unit>
        <trans-unit id="8a8aba5130fcc62311d7ddc3b7380514a11ed8fe" translate="yes" xml:space="preserve">
          <source>Due to the &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;configuration-based entropy&lt;/a&gt; increase, a modified value can be used to fingerprint the user, it is not recommended to change it and a Web site cannot trust this value to reflect the actual wish of the user. Site designers must not be over-zealous by using language detection via this header as it can lead to a poor user experience:</source>
          <target state="translated">以下のために&lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;構成ベースのエントロピー&lt;/a&gt;の増加、変更された値は、ユーザの指紋するために使用することができ、それを変更することは推奨されていないと、Webサイトは、ユーザーの実際の願いを反映するために、この値を信頼することはできません。ユーザーエクスペリエンスの低下につながる可能性があるため、サイト設計者は、このヘッダーを介して言語検出を使用することに熱心すぎてはなりません。</target>
        </trans-unit>
        <trans-unit id="408eba332fcca84c3bed5ec905d05209bce63d2e" translate="yes" xml:space="preserve">
          <source>Due to their emphasis on authoring, WebDAV servers need to use
   authentication technology to protect not just access to a network
   resource, but the integrity of the resource as well.  Furthermore,
   the introduction of locking functionality requires support for
   authentication.

   A password sent in the clear over an insecure channel is an
   inadequate means for protecting the accessibility and integrity of a
   resource as the password may be intercepted.  Since Basic
   authentication for HTTP/1.1 performs essentially clear text
   transmission of a password, Basic authentication MUST NOT be used to
   authenticate a WebDAV client to a server unless the connection is
   secure.  Furthermore, a WebDAV server MUST NOT send a Basic
   authentication challenge in a WWW-Authenticate header unless the
   connection is secure.  An example of a secure connection would be a
   Transport Layer Security (TLS) connection employing a strong cipher
   suite and server authentication. 

   WebDAV applications MUST support the Digest authentication scheme
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].  Since Digest authentication verifies that both parties to
   a communication know a shared secret, a password, without having to
   send that secret in the clear, Digest authentication avoids the
   security problems inherent in Basic authentication while providing a
   level of authentication that is useful in a wide range of scenarios.</source>
          <target state="translated">オーサリングに重点を置いているため、WebDAVサーバーは認証テクノロジを使用して、ネットワークリソースへのアクセスだけでなく、リソースの整合性も保護する必要があります。さらに、ロック機能の導入には認証のサポートが必要です。安全でないチャネルを介して平文で送信されるパスワードは、パスワードが傍受される可能性があるため、リソースのアクセス可能性と整合性を保護するには不十分な手段です。 HTTP / 1.1の基本認証は本質的にパスワードのクリアテキスト送信を実行するため、接続が安全でない限り、基本認証を使用してサーバーへのWebDAVクライアントを認証してはなりません（MUST NOT）。さらに、接続が安全でない限り、WebDAVサーバーはWWW-Authenticateヘッダーで基本認証チャレンジを送信してはなりません（MUST NOT）。安全な接続の例は、強力な暗号スイートとサーバー認証を採用したトランスポート層セキュリティ（TLS）接続です。 WebDAVアプリケーションは、ダイジェスト認証スキームをサポートする必要があります[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。ダイジェスト認証は、通信の両当事者が共有シークレット、パスワードを知っていることを確認するので、そのシークレットを平文で送信する必要はありません。ダイジェスト認証は、基本認証に固有のセキュリティ問題を回避し、幅広いユーザーに役立つ認証レベルを提供します。シナリオの範囲。</target>
        </trans-unit>
        <trans-unit id="997743d612e18993ff8dc7080968428d093101a4" translate="yes" xml:space="preserve">
          <source>During the same time, the need for an encrypted transport layer raised: the Web left the relative trustiness of a mostly academic network, to a jungle where advertisers, random individuals or criminals compete to get as much private information about people, try to impersonate them or even to replace data transmitted by altered ones. As the applications built over HTTP became more and more powerful, having access to more and more private information like address books, e-mail, or the geographic position of the user, the need to have TLS became ubiquitous even outside the e-commerce use case.</source>
          <target state="translated">それと同時に、暗号化されたトランスポート層の必要性が高まりました。ウェブは、ほとんどが学術的なネットワークの相対的な信頼性から離れ、広告主や無作為の個人、犯罪者が、人々の個人情報をできるだけ多く取得したり、彼らになりすましたり、あるいは改ざんされたもので送信されたデータを置き換えるために競い合うジャングルへと変わりました。HTTP で構築されたアプリケーションがますます強力になり、アドレス帳や電子メール、ユーザーの地理的位置など、より多くの個人情報にアクセスできるようになるにつれ、TLS の必要性は、電子商取引のユースケース以外でもどこにでもあるようになりました。</target>
        </trans-unit>
        <trans-unit id="95b3251ec6e19bc2e780b0b452fffbe79113def2" translate="yes" xml:space="preserve">
          <source>Dynamic serving</source>
          <target state="translated">ダイナミックサービング</target>
        </trans-unit>
        <trans-unit id="57313c5dd0c9956db75ecb6a66db1c8dbb3f5fdf" translate="yes" xml:space="preserve">
          <source>Dynamic. The origin server needs more information to determine tracking status.</source>
          <target state="translated">動的です。オリジンサーバーは、トラッキングステータスを判断するために、より多くの情報を必要としています。</target>
        </trans-unit>
        <trans-unit id="705ecd20fdc7a1a80cbce38adda833a8e258328f" translate="yes" xml:space="preserve">
          <source>ECMAScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">ECMAScript（&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt;仕様&lt;/em&gt;&lt;/a&gt;）（&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329セクション8.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="11d00f6ed181afbae6281cf892e585dcee85b274" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="a9cf203d9639d2de24fc7e1aabf9a3f1d1b216fd" translate="yes" xml:space="preserve">
          <source>ETag (RFC 2616)</source>
          <target state="translated">ETag (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="c3c187693ac73afbe58b0355bda0f434ddd57b14" translate="yes" xml:space="preserve">
          <source>ETag (RFC 7232)</source>
          <target state="translated">ETag (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2586de7225abd1a31095cd8e2595f05492c55926" translate="yes" xml:space="preserve">
          <source>ETags</source>
          <target state="translated">ETags</target>
        </trans-unit>
        <trans-unit id="91b64bf36619dc548bb6dc82aa7a3172dcb0fa4a" translate="yes" xml:space="preserve">
          <source>EU cookie directive</source>
          <target state="translated">EUクッキー指令</target>
        </trans-unit>
        <trans-unit id="aacf5c8fecb249d308c1a10d329efa9aa9c43e95" translate="yes" xml:space="preserve">
          <source>Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   HTTP provides a uniform interface for interacting with a resource
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).

   HTTP semantics include the intentions defined by each request method
   (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), extensions to those semantics that might be described in
   request header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), the meaning of status codes to
   indicate a machine-readable response (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;), and the meaning of
   other control data and resource metadata that might be given in
   response header fields (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as &quot;content
   negotiation&quot; (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).</source>
          <target state="translated">各ハイパーテキスト転送プロトコル（HTTP）メッセージは、要求または応答のいずれかです。サーバーは接続で要求をリッスンし、受信した各メッセージを解析し、識別された要求ターゲットに関連するメッセージセマンティクスを解釈し、1つ以上の応答メッセージでその要求に応答します。クライアントは、特定の意図を伝えるための要求メッセージを作成し、受信した応答を調べて意図が実行されたかどうかを確認し、結果を解釈する方法を決定します。このドキュメントは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されたアーキテクチャの観点から、HTTP / 1.1要求および応答のセマンティクスを定義しています。 HTTPは、リソースと対話するための統一されたインターフェースを提供します（&lt;a href=&quot;#section-2&quot;&gt;セクション2&lt;/a&gt;）、そのタイプ、性質、実装に関係なく、表現の操作と転送を介して（&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）。 HTTPセマンティクスには、各リクエストメソッドで定義された意図（&lt;a href=&quot;#section-4&quot;&gt;セクション4&lt;/a&gt;）、リクエストヘッダーフィールドで説明される可能性のあるセマンティクスの拡張（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）、機械可読応答を示すステータスコードの意味（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）、および応答ヘッダーフィールドで提供される可能性がある他の制御データとリソースメタデータの意味（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）。このドキュメントでは、受信者によるペイロードの解釈方法を説明する表現メタデータ、コンテンツ選択に影響を与える可能性のあるリクエストヘッダーフィールド、および「コンテンツネゴシエーション」と総称されるさまざまな選択アルゴリズムも定義しています（&lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="057e4721fb960e50e6bc2f172224db4e1bf70d8b" translate="yes" xml:space="preserve">
          <source>Each Status-Code is described below, including a description of which
   method(s) it can follow and any metainformation required in the
   response.</source>
          <target state="translated">各ステータスコードは、どのような方法に従うことができるのか、および応答に必要なメタ情報の説明を含めて、以下に記述されています。</target>
        </trans-unit>
        <trans-unit id="0bafccf37828f0cf81554847666fb3201e53972e" translate="yes" xml:space="preserve">
          <source>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the &lt;a href=&quot;../headers/x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">各ブラウザは、MIMEスニッフィングをさまざまな状況でさまざまに実行します。（たとえば、送信されたMIMEタイプが適切でない場合、SafariはURLのファイル拡張子を調べます。）一部のMIMEタイプは実行可能なコンテンツを表すため、セキュリティ上の懸念があります。サーバーは&lt;a href=&quot;../headers/x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt;ヘッダーを送信することでMIMEスニッフィングを防止できます。</target>
        </trans-unit>
        <trans-unit id="82fa8700dcf214b80fbd4de6e7bf762e538223a6" translate="yes" xml:space="preserve">
          <source>Each client in the request chain may have its own cache, so it is
   common for a cache at an intermediary to receive conditional requests
   from other (outbound) caches.  Likewise, some user agents make use of
   conditional requests to limit data transfers to recently modified
   representations or to complete the transfer of a partially retrieved
   representation.

   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content) responses, the cache
   SHOULD evaluate any applicable conditional header field preconditions
   received in that request with respect to the corresponding validators
   contained within the selected response.  A cache MUST NOT evaluate 

   conditional header fields that are only applicable to an origin
   server, found in a request with semantics that cannot be satisfied
   with a cached response, or applied to a target resource for which it
   has no stored responses; such preconditions are likely intended for
   some other (inbound) server.

   The proper evaluation of conditional requests by a cache depends on
   the received precondition header fields and their precedence, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7232]&lt;/a&gt;.  The If-Match and
   If-Unmodified-Since conditional header fields are not applicable to a
   cache.

   A request containing an If-None-Match header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7232]&lt;/a&gt;) indicates that the client wants to validate one or more of
   its own stored responses in comparison to whichever stored response
   is selected by the cache.  If the field-value is &quot;*&quot;, or if the
   field-value is a list of entity-tags and at least one of them matches
   the entity-tag of the selected stored response, a cache recipient
   SHOULD generate a 304 (Not Modified) response (using the metadata of
   the selected stored response) instead of sending that stored
   response.

   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags, the cache
   MAY combine the received list with a list of entity-tags from its own
   stored set of responses (fresh or stale) and send the union of the
   two lists as a replacement If-None-Match header field value in the
   forwarded request.  If a stored response contains only partial
   content, the cache MUST NOT include its entity-tag in the union
   unless the request is for a range that would be fully satisfied by
   that partial stored response.  If the response to the forwarded
   request is 304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response
   metadata (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;).

   If an If-None-Match header field is not present, a request containing
   an If-Modified-Since header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt;)
   indicates that the client wants to validate one or more of its own
   stored responses by modification date.  A cache recipient SHOULD
   generate a 304 (Not Modified) response (using the metadata of the
   selected stored response) if one of the following cases is true: 1)
   the selected stored response has a Last-Modified field-value that is
   earlier than or equal to the conditional timestamp; 2) no
   Last-Modified field is present in the selected stored response, but
   it has a Date field-value that is earlier than or equal to the
   conditional timestamp; or, 3) neither Last-Modified nor Date is 

   present in the selected stored response, but the cache recorded it as
   having been received at a time earlier than or equal to the
   conditional timestamp.

   A cache that implements partial responses to range requests, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], also needs to evaluate a received If-Range
   header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;) with respect to its selected
   stored response.</source>
          <target state="translated">リクエストチェーンの各クライアントには独自のキャッシュがあるため、中間のキャッシュが他の（送信）キャッシュから条件付きリクエストを受信するのが一般的です。同様に、一部のユーザーエージェントは条件付きリクエストを使用して、データ転送を最近変更された表現に制限するか、部分的に取得された表現の転送を完了します。キャッシュは、格納されている200（OK）または206（Partial Content）応答のいずれかを再利用することで満たすことができる要求を受信した場合、その要求で受信した該当する条件付きヘッダーフィールドの前提条件を、その中に含まれる対応するバリデーターに関して評価する必要があります（SHOULD）。選択した応答。キャッシュは、オリジンサーバーにのみ適用される条件付きヘッダーフィールドを評価してはなりません。キャッシュされた応答では満足できないセマンティクスの要求で見つかった、または応答が格納されていないターゲットリソースに適用された。このような前提条件は、おそらく他の（受信）サーバーを対象としています。キャッシュによる条件付きリクエストの適切な評価は、で定義されているように、受信した前提条件ヘッダーフィールドとその優先順位に依存します。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;[RFC7232]のセクション6&lt;/a&gt;。 If-MatchおよびIf-Unmodified-Since条件付きヘッダーフィールドは、キャッシュには適用されません。 If-None-Matchヘッダーフィールドを含むリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]のセクション3.2）&lt;/a&gt;）は、キャッシュによって選択された格納済み応答と比較して、クライアントが1つ以上の独自の格納済み応答を検証したいことを示します。 field-valueが &quot;*&quot;の場合、またはfield-valueがエンティティタグのリストであり、それらの少なくとも1つが選択された保存済み応答のエンティティタグと一致する場合、キャッシュ受信者は304（Not Modified ）その保存された応答を送信する代わりに（選択された保存された応答のメタデータを使用して）応答。キャッシュがエンティティタグのIf-None-Matchリストを含むリクエストに対して、保存されている独自の応答を再検証することを決定した場合、キャッシュは、受信したリストを、それ自体の格納された一連の応答（新鮮または古い）のエンティティタグのリストと結合し、2つのリストの和集合を、転送されたリクエストの置換If-None-Matchヘッダーフィールド値として送信できます（MAY）。格納された応答に部分的なコンテンツのみが含まれる場合、リクエストがその部分的な格納された応答によって完全に満たされる範囲に対するものでない限り、キャッシュはそのエンティティタグをユニオンに含めてはなりません（MUST NOT）。転送されたリクエストへの応答が304（Not Modified）であり、クライアントのリストにないエンティティタグを持つETagヘッダーフィールド値がある場合、キャッシュは対応するクライアントを再利用することにより、クライアントに200（OK）応答を生成する必要があります。 304レスポンスメタデータ（リクエストがその部分的に保存された応答によって完全に満たされる範囲に対するものでない限り、キャッシュはそのエンティティタグをユニオンに含めてはなりません（MUST NOT）。転送されたリクエストへの応答が304（Not Modified）であり、クライアントのリストにないエンティティタグを持つETagヘッダーフィールド値がある場合、キャッシュは対応するクライアントを再利用することにより、クライアントに200（OK）応答を生成する必要があります。 304レスポンスメタデータ（リクエストがその部分的に保存された応答によって完全に満たされる範囲に対するものでない限り、キャッシュはそのエンティティタグをユニオンに含めてはなりません（MUST NOT）。転送されたリクエストへの応答が304（Not Modified）であり、クライアントのリストにないエンティティタグを持つETagヘッダーフィールド値がある場合、キャッシュは対応するクライアントを再利用することにより、クライアントに200（OK）応答を生成する必要があります。 304レスポンスメタデータ（キャッシュは、対応する格納された応答を再利用することにより、クライアントの200（OK）応答を生成する必要があります（304応答メタデータによって更新されます（キャッシュは、対応する格納された応答を再利用することにより、クライアントの200（OK）応答を生成する必要があります（304応答メタデータによって更新されます（&lt;a href=&quot;#section-4.3.4&quot;&gt;セクション4.3.4&lt;/a&gt;）。 If-None-Matchヘッダーフィールドが存在しない場合、If-Modified-Sinceヘッダーフィールドを含むリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]のセクション3.3&lt;/a&gt;）は、クライアントが、変更日ごとに、独自に保存された1つ以上の応答を検証したいことを示します。次のいずれかの場合に当てはまる場合、キャッシュ受信者は304（変更されていない）応答を生成する必要があります（選択された格納済み応答のメタデータを使用）：1）選択された格納済み応答のLast-Modifiedフィールド値が条件付きタイムスタンプに等しい。 2）選択した保存済み応答にLast-Modifiedフィールドがありませんが、条件付きタイムスタンプ以前の日付フィールド値があります。または、3）Last-ModifiedもDateも選択された保存済み応答に存在しないが、条件付きタイムスタンプ以前の時間に受信されたものとしてキャッシュが記録した。範囲リクエストへの部分的な応答を実装するキャッシュ、[&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]も、受信したIf-Rangeヘッダーフィールド（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]のセクション3.2&lt;/a&gt;）を、その選択された格納済み応答に関して評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="cdfff658f8638be3f51c025575b0ddaed39961ef" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types are taking a lot of space to store and the need to regain this wasted space appeared very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">各データタイプには冗長性があります。つまり、&lt;em&gt;無駄なスペース&lt;/em&gt;です。通常、テキストの冗長性が60％に達する場合は、オーディオやビデオなどの他のメディアの場合、この比率がはるかに高くなる可能性があります。テキストとは異なり、これらの他のメディアタイプは保存に多くのスペースを使用しており、この無駄なスペースを取り戻す必要性が非常に早く現れました。エンジニアは、この特定の目的のために設計されたファイル形式で使用される最適化された圧縮アルゴリズムを設計しました。ファイルに使用される圧縮アルゴリズムは、次の2つのカテゴリに分類できます。</target>
        </trans-unit>
        <trans-unit id="ae7498ae0f7b36b2dcd84d942c2be51971574fec" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types use lot of space to store their data and the need to optimize storage and regain space was apparent very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">各データ型には、いくらかの冗長性、つまり&lt;em&gt;無駄なスペース&lt;/em&gt;があります。テキストの冗長性が通常60％にもなる場合、オーディオやビデオなどの他のメディアでは、このレートがはるかに高くなる可能性があります。テキストとは異なり、これらの他のメディアタイプは、データを格納するために多くのスペースを使用し、ストレージを最適化してスペースを取り戻す必要性は非常に早い段階で明らかになりました。エンジニアは、この特定の目的のために設計されたファイル形式で使用される最適化された圧縮アルゴリズムを設計しました。ファイルに使用される圧縮アルゴリズムは、大きく2つのカテゴリに分類できます。</target>
        </trans-unit>
        <trans-unit id="8c418e981dde2783c397a4ab8566b1987e0ddccd" translate="yes" xml:space="preserve">
          <source>Each header field consists of a case-insensitive field name followed
   by a colon (&quot;:&quot;), optional leading whitespace, the field value, and
   optional trailing whitespace. 

     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see &lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;

   The field-name token labels the corresponding field-value as having
   the semantics defined by that header field.  For example, the Date
   header field is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&amp;nbsp;7.1.1.2 of [RFC7231]&lt;/a&gt; as containing
   the origination timestamp for the message in which it appears.</source>
          <target state="translated">各ヘッダーフィールドは、大文字と小文字を区別しないフィールド名と、その後に続くコロン（ &quot;：&quot;）、オプションの先頭の空白、フィールド値、およびオプションの末尾の空白で構成されます。 header-field = field-name &quot;：&quot; OWS field-value OWS field-name = token field-value = *（field-content / obs-fold）field-content = field-vchar [1 *（SP / HTAB）field -vchar] field-vchar = VCHAR / obs-text obs-fold = CRLF 1 *（SP / HTAB）;時代遅れのラインフォールディング。&lt;a href=&quot;#section-3.2.4&quot;&gt;セクション3.2.4を&lt;/a&gt;参照してください 。フィールド名トークンは、対応するフィールド値に、そのヘッダーフィールドで定義されたセマンティクスを持つものとしてラベルを付けます。たとえば、Dateヘッダーフィールドは&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;、[RFC7231]のセクション7.1.1.2で&lt;/a&gt;定義されています。 メッセージが発生したメッセージの開始タイムスタンプを含むものとして。</target>
        </trans-unit>
        <trans-unit id="9565e409b5a13cd6eeebcf793281c0c14e6920fb" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which handles it and provides an answer, called the &lt;em&gt;response&lt;/em&gt;. Between the client and the server there are numerous entities, collectively called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">個々の要求はサーバーに送信され、サーバーはそれを処理して、応答と呼ばれる&lt;em&gt;応答&lt;/em&gt;を提供します。クライアントとサーバーの間には、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;と総称される多数のエンティティがあります。これらのエンティティは、たとえば、さまざまな操作を実行し、ゲートウェイまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;キャッシュ&lt;/a&gt;として機能します。</target>
        </trans-unit>
        <trans-unit id="caa9777361801f65cdbd5d095a27001848c440f6" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which will handle it and provide an answer, called the &lt;em&gt;response&lt;/em&gt;. Between this request and response there are numerous entities, collectively designated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">個々の要求はサーバーに送信され、サーバーがそれを処理して、応答と呼ばれる&lt;em&gt;応答&lt;/em&gt;を提供します。この要求と応答の間に、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;としてまとめて指定された多数のエンティティがあり、これらはさまざまな操作を実行し、たとえばゲートウェイや&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;キャッシュ&lt;/a&gt;として機能します。</target>
        </trans-unit>
        <trans-unit id="4d47e568ac317d800ba83293a6e6b145c10f0e3f" translate="yes" xml:space="preserve">
          <source>Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.

   Registrations happen on a &quot;First Come First Served&quot; basis (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC5226]&lt;/a&gt;) and are subject to the following rules:

   1.  A protocol-name token, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       that token.  Such specifications need not be publicly available.

   5.  The registration SHOULD name a set of expected &quot;protocol-version&quot;
       tokens associated with that token at the time of registration. 

   6.  The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.

   7.  The IESG MAY reassign responsibility for a protocol token.  This
       will normally only be used in the case when a responsible party
       cannot be contacted.

   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">登録されている各プロトコル名は、連絡先情報と、アップグレード後の接続の処理方法の詳細を示すオプションの仕様セットに関連付けられています。登録&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;は「先着順&lt;/a&gt;」で行われます（[RFC5226]のセクション4.1を参照 ））および次の規則に従います。1.プロトコル名トークンは、一度登録されると、永久に登録されたままになります。 2.登録では、登録の責任者を指定する必要があります。 3.登録には連絡先を明記する必要があります。 4.登録では、そのトークンに関連付けられた一連の仕様を指定できます（MAY）。そのような仕様は公開されている必要はありません。 5.登録では、登録時にそのトークンに関連付けられた、予想される「プロトコルバージョン」トークンのセットに名前を付ける必要があります（SHOULD）。 6.責任者はいつでも登録を変更できます。 IANAはそのようなすべての変更の記録を保持し、要求に応じてそれらを利用可能にします。 7. IESGは、プロトコルトークンの責任を再割り当てしてもよい（MAY）。これは通常、責任者に連絡できない場合にのみ使用されます。このHTTPアップグレードトークンの登録手順は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]のセクション7.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f681ccf67162d9cff0a908b916182711ed9cc29e" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;no-store&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">URLに対する各リクエストは、一意でキャッシュできないリクエストとして扱われることになっています。これを示すためのより良い方法は、&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;： &lt;code&gt;no-store&lt;/code&gt; を使用することです。これは、読みやすく、オブジェクトを保存してはならないことを通知します。</target>
        </trans-unit>
        <trans-unit id="fbb1874585ee277130e7dcc804818855ef02a2e2" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: private&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">URLに対する各要求は、一意でキャッシュできない要求として扱われることになっています。これを示すより良い方法は、&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: private&lt;/code&gt; を使用することです。これにより、読み取りがより明確になり、オブジェクトを保存する必要がないことを通知できます。</target>
        </trans-unit>
        <trans-unit id="06c0d14065b0e4f4c93db5d7ec072d4c7ca36aee" translate="yes" xml:space="preserve">
          <source>Each type has its own set of possible subtypes, and a MIME type always has both a type and a subtype, never just one or the other.</source>
          <target state="translated">それぞれのタイプには、それ自身の可能なサブタイプのセットがあり、MIME タイプは常にタイプとサブタイプの両方を持ち、どちらか一方だけを持つことはありません。</target>
        </trans-unit>
        <trans-unit id="083351d889941c99f11bdb7f8dc5b5a5a90e3651" translate="yes" xml:space="preserve">
          <source>Early-Data</source>
          <target state="translated">Early-Data</target>
        </trans-unit>
        <trans-unit id="8440b9eb7d03917b2509b5baeab2a299ce257eb0" translate="yes" xml:space="preserve">
          <source>Edge</source>
          <target state="translated">Edge</target>
        </trans-unit>
        <trans-unit id="aa5e3465605004afca0f330dee1d92d60e4608d6" translate="yes" xml:space="preserve">
          <source>Edge 17 skips the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive (&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;).</source>
          <target state="translated">Edge 17は、&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;ディレクティブをスキップします（&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;バグ&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="40943d342558e930e5fd4552c5671ad9d18db865" translate="yes" xml:space="preserve">
          <source>Edge Mobile</source>
          <target state="translated">边缘移动</target>
        </trans-unit>
        <trans-unit id="8186c1b8199a285af780f2cff07d80dbd60cd881" translate="yes" xml:space="preserve">
          <source>Edge has &lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;retired their XSS filter&lt;/a&gt;</source>
          <target state="translated">Edgeは&lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;XSSフィルター&lt;/a&gt;を廃止しました</target>
        </trans-unit>
        <trans-unit id="1594fb58d4be36a563bbf83f00f527da6feeed9b" translate="yes" xml:space="preserve">
          <source>Edge on Windows 10 Mobile</source>
          <target state="translated">Windows 10 MobileでのEdge</target>
        </trans-unit>
        <trans-unit id="d5ed0aee9b31cc8d3563818529b7abccaaaad432" translate="yes" xml:space="preserve">
          <source>Edge/xyz</source>
          <target state="translated">Edge/xyz</target>
        </trans-unit>
        <trans-unit id="d5fbe14f72118336fc25fa625850b0c5c3be431a" translate="yes" xml:space="preserve">
          <source>EdgeHTML</source>
          <target state="translated">EdgeHTML</target>
        </trans-unit>
        <trans-unit id="add94fac827b3ed02fee4c1b72173331645c25b8" translate="yes" xml:space="preserve">
          <source>Edit this page on MDN</source>
          <target state="translated">在MDN上编辑此页</target>
        </trans-unit>
        <trans-unit id="a769fc9fd1bf50a69b3839fd2f92626878d5b626" translate="yes" xml:space="preserve">
          <source>Editor's Draft</source>
          <target state="translated">编辑稿</target>
        </trans-unit>
        <trans-unit id="f0aaf1ff183fe38a130caadf7977863f8e2a59f3" translate="yes" xml:space="preserve">
          <source>Editor's draft</source>
          <target state="translated">エディターズドラフト</target>
        </trans-unit>
        <trans-unit id="90b56ed596b137c9da80b986161d0bd1c8d62cba" translate="yes" xml:space="preserve">
          <source>Editor's draft / Candidate recommendation</source>
          <target state="translated">編集者案・候補者推薦</target>
        </trans-unit>
        <trans-unit id="1c3d5530a42ab230eeb2ce3fa0fa80758453dd56" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーまたは &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; ヘッダーのどちらが使用されているかに応じて、 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; または &lt;code&gt;&quot;report&quot;&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="eb29b12af265782c792c3f30babdfaf626f24932" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダーまたは &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダーのどちらが使用されているかに応じて、 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; または &lt;code&gt;&quot;report&quot;&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="1fcd0c7316a8c31f4e9ceb1db446cf33c197f076" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーまたは &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; ヘッダーが使用されているかどうかに応じて、 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; または &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="d8d9968b1d7df53b6e4cf681453c3df54edc30bf" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダーまたは &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダーのどちらが使用されているかに応じて、 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; または &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="fa29e4650b1639a98c0c8f55d262398a02155fba" translate="yes" xml:space="preserve">
          <source>Either the string &quot;GMT&quot; for GMT timezone, or not specified, for local timezone.</source>
          <target state="translated">GMTタイムゾーンには文字列 &quot;GMT&quot;、ローカルタイムゾーンには指定されていない文字列 &quot;GMT&quot; を指定します。</target>
        </trans-unit>
        <trans-unit id="eec5a0a958a1fbddcf0daab821af65ae5b6cc34b" translate="yes" xml:space="preserve">
          <source>Electronic mail address</source>
          <target state="translated">電子メールアドレス</target>
        </trans-unit>
        <trans-unit id="f98f953a2a328bdea00e564fed7dfd322a69cd6d" translate="yes" xml:space="preserve">
          <source>Electronic publication (EPUB)</source>
          <target state="translated">電子出版(EPUB</target>
        </trans-unit>
        <trans-unit id="5a67bc2ccc5173b788a5682e69fed1656994a358" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and are not receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;strong&gt;recommended&lt;/strong&gt; to restrict this fetch-directive (e.g., explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="translated">制御される要素 &lt;code&gt;object-src&lt;/code&gt; おそらく偶然レガシーHTML要素とみなされ、（セキュリティ属性などの新しい標準化された機能を受けていない &lt;code&gt;sandbox&lt;/code&gt; または &lt;code&gt;allow&lt;/code&gt; ために &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; ）。したがって、このフェッチディレクティブを制限することを&lt;strong&gt;お勧め&lt;/strong&gt;し &lt;code&gt;object-src 'none'&lt;/code&gt; （たとえば、可能であれば、object-src'none 'を明示的に設定します）。</target>
        </trans-unit>
        <trans-unit id="d3465998ffce5d1b11571e20db3e058cd0d4176c" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and aren't receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;recommended&lt;/a&gt; to restrict this fetch-directive (e.g. explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="translated">制御される要素 &lt;code&gt;object-src&lt;/code&gt; おそらく偶然レガシーHTML要素とみなされ、（セキュリティ属性などの新しい標準化された機能を受けていない &lt;code&gt;sandbox&lt;/code&gt; または &lt;code&gt;allow&lt;/code&gt; ために &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; ）。したがって、このフェッチディレクティブを制限することを&lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;お勧め&lt;/a&gt;し &lt;code&gt;object-src 'none'&lt;/code&gt; （たとえば、可能であれば、object-src'none 'を明示的に設定します）。</target>
        </trans-unit>
        <trans-unit id="70620ad9a50dbab17deb7f1669beeb98b33e7dd5" translate="yes" xml:space="preserve">
          <source>Enable CORS: I want to add CORS support to my server</source>
          <target state="translated">CORSを有効にします。サーバーに CORS サポートを追加したい</target>
        </trans-unit>
        <trans-unit id="7060cb09d904d309fcf66579b0dfa0ec89ffc7ea" translate="yes" xml:space="preserve">
          <source>Enables Cross-Origin Read Blocking (CORB) protection for the MIME-types:</source>
          <target state="translated">MIME タイプのクロスオリジンリードブロッキング (CORB)保護を有効にします。</target>
        </trans-unit>
        <trans-unit id="7a23cd75e8cc48555a5cc4d39dc5d353f54219c1" translate="yes" xml:space="preserve">
          <source>Enables DNS prefetching. This is what browsers do, if they support the feature, when this header is not present</source>
          <target state="translated">DNS のプリフェッチを有効にします。このヘッダが存在しない場合、ブラウザがこの機能をサポートしていれば、これを行います。</target>
        </trans-unit>
        <trans-unit id="15f6f232156085ea4d4637fb11cb65dea424795d" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts).</source>
          <target state="translated">XSSフィルタリングを有効にします(通常はブラウザのデフォルト)。クロスサイトスクリプティング攻撃が検出された場合、ブラウザはページをサニタイズ(安全でない部分を削除)します。</target>
        </trans-unit>
        <trans-unit id="2afff7cdf670cfcd98e1bf3804e6db1cd9978584" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive to send a report.</source>
          <target state="translated">XSSフィルタリングを有効にします。クロスサイトスクリプティング攻撃が検出された場合、ブラウザはページをサニタイズして違反を報告します。これは、CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;ディレクティブの機能を使用してレポートを送信します。</target>
        </trans-unit>
        <trans-unit id="04c90c3404283e6479b83c3594ac6645fd7a76cf" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected.</source>
          <target state="translated">XSSフィルタリングを有効にします。ページをサニタイズするのではなく、攻撃が検出された場合にブラウザがページのレンダリングを阻止します。</target>
        </trans-unit>
        <trans-unit id="22ebba1e22e214dfdd20ecfca28bb3fc46c19982" translate="yes" xml:space="preserve">
          <source>Enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性と同様に、要求されたリソースのサンドボックスを有効にします。</target>
        </trans-unit>
        <trans-unit id="d9c536a9d2dc890eb3a315dacecf7bf8af2ea7a0" translate="yes" xml:space="preserve">
          <source>Enables cross-site scripting filtering.</source>
          <target state="translated">クロスサイトスクリプティングのフィルタリングを有効にします。</target>
        </trans-unit>
        <trans-unit id="22f217de833d7c0f4da332bd436a93307529d3b5" translate="yes" xml:space="preserve">
          <source>Enabling HPKP</source>
          <target state="translated">HPKPを有効にする</target>
        </trans-unit>
        <trans-unit id="bd97d929640fde2abf473682141dfee61b906111" translate="yes" xml:space="preserve">
          <source>Enabling reporting</source>
          <target state="translated">レポートを有効にする</target>
        </trans-unit>
        <trans-unit id="d51a5760383324ea2ced3708f0c4f21b3b6433db" translate="yes" xml:space="preserve">
          <source>Encoding data into base64 format</source>
          <target state="translated">データをbase64形式にエンコード</target>
        </trans-unit>
        <trans-unit id="5a526ce1054f67846c014806870479f982067006" translate="yes" xml:space="preserve">
          <source>Encoding in Javascript</source>
          <target state="translated">Javascriptでのエンコーディング</target>
        </trans-unit>
        <trans-unit id="9e1b3d87041d9d3f6d49d001407d5e51e783220a" translate="yes" xml:space="preserve">
          <source>Encoding on Microsoft Windows</source>
          <target state="translated">Microsoft Windowsでのエンコード</target>
        </trans-unit>
        <trans-unit id="9a85145b06e5a569eeab2640e8113603e4dec581" translate="yes" xml:space="preserve">
          <source>Encoding on Windows can be done through powershell or some dedicated tool. It can even be done via bash &lt;code&gt;base64&lt;/code&gt; utility (see section Encoding on a Unix system) if &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt; is activated.</source>
          <target state="translated">Windowsでのエンコードは、PowerShellまたは専用ツールを使用して実行できます。&lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt;がアクティブになっている場合は、bash &lt;code&gt;base64&lt;/code&gt; ユーティリティ（Unixシステムでのエンコードのセクションを参照）を介して実行することもできます。</target>
        </trans-unit>
        <trans-unit id="b9723a9fa3539530df973d9238398c2287f9fc64" translate="yes" xml:space="preserve">
          <source>Encoding on a Unix system</source>
          <target state="translated">Unix システムでのエンコーディング</target>
        </trans-unit>
        <trans-unit id="635fc00ea52427c14323d1d4ec9234a0c136c15e" translate="yes" xml:space="preserve">
          <source>Encrypted Media Extensions&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="translated">暗号化メディア拡張&lt;br/&gt;&lt;small&gt;機能その仕様における「機能ポリシー統合」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f7b844634b78bbf66c2386fb7400b4efd46ba2fc" translate="yes" xml:space="preserve">
          <source>Encrypted media</source>
          <target state="translated">暗号化されたメディア</target>
        </trans-unit>
        <trans-unit id="bb7917263fb0376ecaaebc6aea8b04a067f36021" translate="yes" xml:space="preserve">
          <source>End-to-end compression</source>
          <target state="translated">エンドツーエンド圧縮</target>
        </trans-unit>
        <trans-unit id="a93b3f3b09d62b69cd48fa61fb8317033f43c87d" translate="yes" xml:space="preserve">
          <source>End-to-end headers</source>
          <target state="translated">エンドツーエンドヘッダー</target>
        </trans-unit>
        <trans-unit id="c1f86bbe0ad1ce921865c4c1081ca46c634279dd" translate="yes" xml:space="preserve">
          <source>Enforces &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; at the DOM XSS injection sinks.</source>
          <target state="translated">DOMXSSインジェクションシンクで&lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;信頼できるタイプ&lt;/a&gt;を適用します。</target>
        </trans-unit>
        <trans-unit id="43a78c23ebe3e022d382e262e5bb0fac3b0c04eb" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences</source>
          <target state="translated">優れたユーザー体験のためのベストプラクティスの実施</target>
        </trans-unit>
        <trans-unit id="434a202c7ecffe7d7bd9b742b730a5afd1676889" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences.</source>
          <target state="translated">優れたユーザー体験のためのベストプラクティスの実施</target>
        </trans-unit>
        <trans-unit id="ffa0f5134bbe5f9da939c45f920a197f4634fba1" translate="yes" xml:space="preserve">
          <source>Ensure images are sized properly and are not too big for the viewport.</source>
          <target state="translated">画像のサイズが適切で、ビューポートに対して大きすぎないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="2a6cc6b1ec9b8b2e989114255b4da3ce2b2f166e" translate="yes" xml:space="preserve">
          <source>Ensures a resource will disown its opener when navigated to.</source>
          <target state="translated">リソースに移動したときに、リソースがそのオープナーを破棄することを保証します。</target>
        </trans-unit>
        <trans-unit id="2f61151d2512a5c88d23bfe8d6fbd9a0947b4f37" translate="yes" xml:space="preserve">
          <source>Entity (RFC 2616)</source>
          <target state="translated">エンティティ(RFC2616)</target>
        </trans-unit>
        <trans-unit id="234e8581d4bf52bbea04d4ae883867b5f00f2402" translate="yes" xml:space="preserve">
          <source>Entity header</source>
          <target state="translated">エンティティヘッダ</target>
        </trans-unit>
        <trans-unit id="83a31c55ad20bb3cf7572f62e10bce1fa2085786" translate="yes" xml:space="preserve">
          <source>Entity tag uniquely representing the requested resource. They are a string of ASCII characters placed between double quotes, like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;. The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Often, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hexadecimal hash of the wiki article content.</source>
          <target state="translated">要求されたリソースを一意に表すエンティティタグ。これらは、 &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ように、二重引用符で囲まれたASCII文字の文字列です。 &lt;code&gt;ETag&lt;/code&gt; 値を生成する方法は指定されていません。多くの場合、コンテンツのハッシュ、最終変更タイムスタンプのハッシュ、またはリビジョン番号のみが使用されます。たとえば、MDNはwiki記事コンテンツの16進ハッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="9024c46dde9f89740b2171b9280d89a9caba4424" translate="yes" xml:space="preserve">
          <source>Entity tags are used for comparing two or more entities from the same
   requested resource. HTTP/1.1 uses entity tags in the ETag (&lt;a href=&quot;#section-14.19&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;), If-Match (&lt;a href=&quot;#section-14.24&quot;&gt;section 14.24&lt;/a&gt;), If-None-Match (&lt;a href=&quot;#section-14.26&quot;&gt;section 14.26&lt;/a&gt;), and
   If-Range (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) header fields. The definition of how they
   are used and compared as cache validators is in &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;. An
   entity tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.

      entity-tag = [ weak ] opaque-tag
      weak       = &quot;W/&quot;
      opaque-tag = quoted-string

   A &quot;strong entity tag&quot; MAY be shared by two entities of a resource
   only if they are equivalent by octet equality.

   A &quot;weak entity tag,&quot; indicated by the &quot;W/&quot; prefix, MAY be shared by
   two entities of a resource only if the entities are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity tag can only be used for weak comparison.

   An entity tag MUST be unique across all versions of all entities
   associated with a particular resource. A given entity tag value MAY
   be used for entities obtained by requests on different URIs. The use
   of the same entity tag value in conjunction with entities obtained by
   requests on different URIs does not imply the equivalence of those
   entities.</source>
          <target state="translated">エンティティタグは、同じリクエストされたリソースからの2つ以上のエンティティを比較するために使用されます。 HTTP / 1.1は、ETag（&lt;a href=&quot;#section-14.19&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;）、If-Match（&lt;a href=&quot;#section-14.24&quot;&gt;セクション14.24&lt;/a&gt;）、If-None-Match（&lt;a href=&quot;#section-14.26&quot;&gt;セクション14.26&lt;/a&gt;）、およびIf-Range（&lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt;）ヘッダーフィールドでエンティティタグを使用します。キャッシュバリデーターとして使用および比較する方法の定義は、&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション13.3.3にあります。&lt;/a&gt;。エンティティタグは、不透明な引用符付き文字列で構成され、弱点インジケータが前に付いている可能性があります。 entity-tag = [weak] opaque-tag weak = &quot;W /&quot; opaque-tag = quoted-string「強いエンティティタグ」は、オクテットの等価性によって同等である場合にのみ、リソースの2つのエンティティによって共有される場合があります。接頭辞「W /」で示される「弱いエンティティタグ」は、エンティティが同等であり、セマンティクスを大幅に変更することなく相互に置き換えることができる場合にのみ、リソースの2つのエンティティで共有できます。弱いエンティティタグは、弱い比較にのみ使用できます。エンティティタグは、特定のリソースに関連付けられているすべてのエンティティのすべてのバージョンで一意である必要があります。特定のエンティティタグの値は、さまざまなURIのリクエストによって取得されたエンティティに使用される場合があります。異なるURIでのリクエストによって取得されたエンティティと組み合わせて同じエンティティタグの値を使用しても、それらのエンティティが同等であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="843ca4f28f9ce3aa7d78cfc1dd5d180a8db20d61" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used (This is useless with &lt;code&gt;If-None-Match&lt;/code&gt; as it only uses that algorithm).</source>
          <target state="translated">リクエストされたリソースを一意に表すエンティティタグ。これらは二重引用符で &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; れたASCII文字列（&quot;675af34563dc-tr34&quot;のように）で、 &lt;code&gt;W/&lt;/code&gt; を前に付けると、弱い比較アルゴリズムを使用する必要があることを示します（これは、 &lt;code&gt;If-None-Match&lt;/code&gt; を使用するだけでは意味がないため、役に立ちません）そのアルゴリズム）。</target>
        </trans-unit>
        <trans-unit id="cb4831ed8a07834c227f88278424a465acad3a5a" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">リクエストされたリソースを一意に表すエンティティタグ。これらは、二重引用符で &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; れたASCII文字列（&quot;675af34563dc-tr34&quot;など）であり、 &lt;code&gt;W/&lt;/code&gt; を前に付けると、弱い比較アルゴリズムを使用する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="f511403ebe3ad82f8791c9cc50f7078c288954a3" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Oftentimes, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hash of hexadecimal digits of the wiki content.</source>
          <target state="translated">リクエストされたリソースを一意に表すエンティティタグ。これらは、二重引用符で &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; れたASCII文字列です（「675af34563dc-tr34」のように）。 &lt;code&gt;ETag&lt;/code&gt; 値の生成方法は指定されていません。多くの場合、コンテンツのハッシュ、最終変更のタイムスタンプのハッシュ、または単にリビジョン番号が使用されます。たとえば、MDNはWikiコンテンツの16進数のハッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="3b0aa4ab650e7127575b944e7c4f357507fe1bf6" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). They may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that they are &quot;weak&quot;, i.e. that they represent the resource semantically, but not byte-for-byte. However, in an &lt;code&gt;If-Match&lt;/code&gt; header, weak entity tags will never match.</source>
          <target state="translated">要求されたリソースを一意に表すエンティティタグ。これらは、二重引用符で &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; れたASCII文字の文字列です（「675af34563dc-tr34」など）。それらは「弱い」ことを示すために &lt;code&gt;W/&lt;/code&gt; で始まる場合があります。つまり、それらは意味的にリソースを表しますが、バイトごとではありません。ただし、 &lt;code&gt;If-Match&lt;/code&gt; ヘッダーでは、弱いエンティティタグが一致することはありません。</target>
        </trans-unit>
        <trans-unit id="e2d3b3c670a7def682fbdd286ebd5fcf01de31d4" translate="yes" xml:space="preserve">
          <source>Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is OPTIONAL; some might be REQUIRED by
   portions of this specification.

       entity-header  = Allow                    ; &lt;a href=&quot;#section-14.7&quot;&gt;Section 14.7&lt;/a&gt;
                      | Content-Encoding         ; &lt;a href=&quot;#section-14.11&quot;&gt;Section 14.11&lt;/a&gt;
                      | Content-Language         ; &lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;
                      | Content-Length           ; &lt;a href=&quot;#section-14.13&quot;&gt;Section 14.13&lt;/a&gt;
                      | Content-Location         ; &lt;a href=&quot;#section-14.14&quot;&gt;Section 14.14&lt;/a&gt;
                      | Content-MD5              ; &lt;a href=&quot;#section-14.15&quot;&gt;Section 14.15&lt;/a&gt;
                      | Content-Range            ; &lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;
                      | Content-Type             ; &lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;
                      | Expires                  ; &lt;a href=&quot;#section-14.21&quot;&gt;Section 14.21&lt;/a&gt;
                      | Last-Modified            ; &lt;a href=&quot;#section-14.29&quot;&gt;Section 14.29&lt;/a&gt;
                      | extension-header

       extension-header = message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and MUST be forwarded by
   transparent proxies.</source>
          <target state="translated">エンティティヘッダーフィールドは、エンティティボディに関するメタ情報、またはボディが存在しない場合はリクエストによって識別されるリソースに関するメタ情報を定義します。このメタ情報の一部はオプションです。この仕様の一部では一部が必要になる場合があります。 entity-header = Allow; &lt;a href=&quot;#section-14.7&quot;&gt;セクション14.7&lt;/a&gt; | Content-Encoding; &lt;a href=&quot;#section-14.11&quot;&gt;セクション14.11&lt;/a&gt; | Content-Language; &lt;a href=&quot;#section-14.12&quot;&gt;セクション14.12&lt;/a&gt; | Content-Length; &lt;a href=&quot;#section-14.13&quot;&gt;セクション14.13&lt;/a&gt; | Content-Location; &lt;a href=&quot;#section-14.14&quot;&gt;セクション14.14&lt;/a&gt; | Content-MD5; &lt;a href=&quot;#section-14.15&quot;&gt;セクション14.15&lt;/a&gt; | Content-Range;&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt; | Content-Type; &lt;a href=&quot;#section-14.17&quot;&gt;セクション14.17&lt;/a&gt; | 期限切れ &lt;a href=&quot;#section-14.21&quot;&gt;セクション14.21&lt;/a&gt; | 最終更新日 ; &lt;a href=&quot;#section-14.29&quot;&gt;セクション14.29&lt;/a&gt; | extension-header extension-header = message-header extension-headerメカニズムを使用すると、プロトコルを変更せずに追加のエンティティヘッダーフィールドを定義できますが、これらのフィールドは受信者が認識できると想定できません。認識されないヘッダーフィールドは受信者によって無視されるべきで（SHOULD）、透過的なプロキシによって転送されなければなりません（MUST）。</target>
        </trans-unit>
        <trans-unit id="dc77c92755cf792527e0b3edc88e46b61f8087b7" translate="yes" xml:space="preserve">
          <source>Error responses: a &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; (Not Found) result page.</source>
          <target state="translated">エラー応答：&lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;（見つかりません）結果ページ。</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="ec4322ae064b7f4e2416acd40d4d58f17e5f8f12" translate="yes" xml:space="preserve">
          <source>Errors: CORSAllowOriginNotMatchingOrigin</source>
          <target state="translated">エラー。CORSallowOriginNotMatchingOrigin</target>
        </trans-unit>
        <trans-unit id="4087c6aa16b5abf1735ae9f8137528c87023309b" translate="yes" xml:space="preserve">
          <source>Errors: CORSDidNotSucceed</source>
          <target state="translated">エラーです。CORSDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="1110c379846585f2593a508b8c164b5bd8320b76" translate="yes" xml:space="preserve">
          <source>Errors: CORSDisabled</source>
          <target state="translated">エラーです。CORSDisabled</target>
        </trans-unit>
        <trans-unit id="dac4e756c8a76cbef1b33dca607cb3bc5b771e95" translate="yes" xml:space="preserve">
          <source>Errors: CORSExternalRedirectNotAllowed</source>
          <target state="translated">エラーが発生しました。CORSExternalRedirectNotAllowed</target>
        </trans-unit>
        <trans-unit id="ce973b3c74a1ebbfbbd6d7dec66c6bb20ce1f763" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowHeader</source>
          <target state="translated">エラーが発生しました。CORSInvalidAllowHeader</target>
        </trans-unit>
        <trans-unit id="a282fd28c28a400d13afa18351e51568b54396d2" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowMethod</source>
          <target state="translated">エラーが発生しました。CORSInvalidAllowMethod</target>
        </trans-unit>
        <trans-unit id="b8d43e50964c1cfd887f4afc94b47bcdd5d69570" translate="yes" xml:space="preserve">
          <source>Errors: CORSMIssingAllowCredentials</source>
          <target state="translated">エラーが発生しました。CORSMIssingAllowCredentials</target>
        </trans-unit>
        <trans-unit id="710e0ccb5287b4319b0c5fdee5593e1d13fa6e37" translate="yes" xml:space="preserve">
          <source>Errors: CORSMethodNotFound</source>
          <target state="translated">エラーが発生しました。CORSMethodNotFound</target>
        </trans-unit>
        <trans-unit id="a307f601e16873b1a5a1472fa793e47e1b28b743" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowHeaderFromPreflight</source>
          <target state="translated">エラー。CORSMissingAlllowHeaderFromPreflight</target>
        </trans-unit>
        <trans-unit id="3d47284892dc16fb82eea87c1c413d4b5c528c8b" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowOrigin</source>
          <target state="translated">エラー。CORSMissingAllowOrigin</target>
        </trans-unit>
        <trans-unit id="59e949130b0899712b1a17c6d46a1f58dc1ad38e" translate="yes" xml:space="preserve">
          <source>Errors: CORSMultipleAllowOriginNotAllowed</source>
          <target state="translated">エラーが発生しました。CORSMultipleAllowOriginNotAllowed</target>
        </trans-unit>
        <trans-unit id="fe11294cab619d12140db3bf906980249f0d9b51" translate="yes" xml:space="preserve">
          <source>Errors: CORSNotSupportingCredentials</source>
          <target state="translated">エラーが発生しました。CORSNotSupportingCredentials</target>
        </trans-unit>
        <trans-unit id="9d941c8ccc9202a89b0022d5ed88c86d19e065a4" translate="yes" xml:space="preserve">
          <source>Errors: CORSOriginHeaderNotAdded</source>
          <target state="translated">エラーが発生しました。CORSOriginHeaderNotAdded</target>
        </trans-unit>
        <trans-unit id="4b2583c03a065a201e0c7af7eb778cf128afcc99" translate="yes" xml:space="preserve">
          <source>Errors: CORSPreflightDidNotSucceed</source>
          <target state="translated">エラーが発生しました。CORSPreflightDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="a43f3bb8e46c7f4d0e112510dc95499734debf0d" translate="yes" xml:space="preserve">
          <source>Errors: CORSRequestNotHttp</source>
          <target state="translated">エラーが発生しました。CORSRequestNotHttp</target>
        </trans-unit>
        <trans-unit id="76e3d52572cfb5f282f24af08ceb3c93515e0c23" translate="yes" xml:space="preserve">
          <source>Establishing a connection</source>
          <target state="translated">接続を確立する</target>
        </trans-unit>
        <trans-unit id="d9c2c223b0f7d2f2a1d0a4ab149a50dae5eaf1dd" translate="yes" xml:space="preserve">
          <source>Evaluation (RFC 7232)</source>
          <target state="translated">評価 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="016549bb81a6b73cbdac91b27317bed690bbaf39" translate="yes" xml:space="preserve">
          <source>Even if both the client and the server supports the same compression algorithms, the server may choose not to compress the body of a response, if the identity value is also acceptable. Two common cases lead to this:</source>
          <target state="translated">クライアントとサーバの両方が同じ圧縮アルゴリズムをサポートしている場合でも、ID値も許容できる場合には、サーバは応答の本文を圧縮しないことを選択することがあります。2つの一般的なケースがこれにつながる。</target>
        </trans-unit>
        <trans-unit id="39e1dc57ed79bde6d7d9296899ff80637127740c" translate="yes" xml:space="preserve">
          <source>Even if identity and location are both described using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, they are two different concepts and it is useful sometimes to distinguished between them. This article introduces the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">IDと場所の両方が&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;を使用して記述されている場合でも、これらは2つの異なる概念であり、それらを区別することが役立つ場合があります。この記事では、&lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;ヘッダーを紹介します。</target>
        </trans-unit>
        <trans-unit id="d11701203cf55bb28a83c78028e1b759782a7ab9" translate="yes" xml:space="preserve">
          <source>Even if server-driven content negotiation is the most common way to agree on a specific representation of a resource, it has several drawbacks:</source>
          <target state="translated">サーバー駆動型コンテンツネゴシエーションがリソースの特定の表現に合意する最も一般的な方法であるとしても、いくつかの欠点があります。</target>
        </trans-unit>
        <trans-unit id="d8b58599d2ecd8aca415a34fd71768d962e8e310" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the &lt;code&gt;301&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use the &lt;a href=&quot;308&quot;&gt;&lt;code&gt;308 Permanent Redirect&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; methods instead, as the method change is explicitly prohibited with this status.</source>
          <target state="translated">リダイレクトが実行されるときに仕様でメソッド（および本体）が変更されないようにする必要がある場合でも、すべてのユーザーエージェントが仕様に対応しているわけではありません。この種のバグのあるソフトウェアを見つけることができます。したがって、使用することが推奨される &lt;code&gt;301&lt;/code&gt; のみの応答としてコードを&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法および使用する&lt;a href=&quot;308&quot;&gt; &lt;code&gt;308 Permanent Redirect&lt;/code&gt; &lt;/a&gt;ため&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;メソッドの変更が明示的にこの状態で禁止されているように、代わりの方法。</target>
        </trans-unit>
        <trans-unit id="60e9e00953556ca6c857baf9a61ba9002b374a14" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents conform here - you can still find this type of bugged software out there. It is therefore recommended to set the &lt;code&gt;302&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use &lt;a href=&quot;307&quot;&gt;&lt;code&gt;307 Temporary Redirect&lt;/code&gt;&lt;/a&gt; instead, as the method change is explicitly prohibited in that case.</source>
          <target state="translated">リダイレクトが実行されるときに仕様でメソッド（および本体）が変更されないようにする必要がある場合でも、すべてのユーザーエージェントがここで準拠しているわけではありません。この種のバグのあるソフトウェアを見つけることができます。したがって、メソッドの変更は明示的に禁止されているため、 &lt;code&gt;302&lt;/code&gt; コードを&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッドの応答としてのみ設定し、代わりに&lt;a href=&quot;307&quot;&gt; &lt;code&gt;307 Temporary Redirect&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="41dab3c71327a38803685ef6e3cebc869962fcfb" translate="yes" xml:space="preserve">
          <source>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs performance, and HTTP has a specific header to avoid this scenario: &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">このメソッドが機能しても、ドキュメントが変更されたときに、追加の応答/要求交換が追加されます。これはパフォーマンスを低下させ、HTTPにはこのシナリオを回避するための特定のヘッダーがあります：&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b284eb5d595f914af47d2a8c3a9cef82f913efb4" translate="yes" xml:space="preserve">
          <source>Even if this technique also works for internal links, you should try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request is done) and if you can avoid it by correcting internal links, you should fix these links.</source>
          <target state="translated">このテクニックが内部リンクにも有効だとしても、内部リダイレクトを持たないようにするべきです。リダイレクトは(余分なHTTPリクエストが行われるため)パフォーマンスに大きなコストがかかるので、内部リンクを修正することで回避できるのであれば、これらのリンクを修正しておくべきです。</target>
        </trans-unit>
        <trans-unit id="58665e4007bca0cad4410abfb11d1a4668903330" translate="yes" xml:space="preserve">
          <source>Even with more complexity, introduced in HTTP/2 by encapsulating HTTP messages into frames, HTTP is generally designed to be simple and human readable. HTTP messages can be read and understood by humans, providing easier developer testing, and reduced complexity for new-comers.</source>
          <target state="translated">HTTPメッセージをフレームにカプセル化することで、HTTP/2で導入されたより複雑になっても、HTTPは一般的にシンプルで人間が読めるように設計されています。HTTPメッセージは人間が読んで理解することができるため、開発者のテストが容易になり、新規参入者にとっては複雑さが軽減されます。</target>
        </trans-unit>
        <trans-unit id="8b42fb3b1821d636c208455d3a9009fab5579ed3" translate="yes" xml:space="preserve">
          <source>Evercookie by Samy Kamkar</source>
          <target state="translated">エバークッキー 〜によって Samy Kamkar</target>
        </trans-unit>
        <trans-unit id="f7b5a8683f9a1cf2ee2d67f073ba064ecc576032" translate="yes" xml:space="preserve">
          <source>Everyone, really.</source>
          <target state="translated">みんな、本当に。</target>
        </trans-unit>
        <trans-unit id="f49a3e37d7614909e74abaad869cfa8d5952bf40" translate="yes" xml:space="preserve">
          <source>Evolution of HTTP</source>
          <target state="translated">HTTPの進化</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">例1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">例2</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">例3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">例4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">例5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">例6</target>
        </trans-unit>
        <trans-unit id="fad75d0ce8eb620d0eb8c90ad36bb1d3ba100630" translate="yes" xml:space="preserve">
          <source>Example HPKP Header</source>
          <target state="translated">HPKPヘッダの例</target>
        </trans-unit>
        <trans-unit id="6f262b0de6886f68de9a7f3020d9645e1a46ad07" translate="yes" xml:space="preserve">
          <source>Example of typical subtypes</source>
          <target state="translated">代表的なサブタイプの例</target>
        </trans-unit>
        <trans-unit id="987339acda1c7e11edad694279b3ef232cafa98c" translate="yes" xml:space="preserve">
          <source>Example preflight request</source>
          <target state="translated">プリフライトリクエスト例</target>
        </trans-unit>
        <trans-unit id="1937f18faac9b560d6b0ad0c27d8e5021d3c2ec8" translate="yes" xml:space="preserve">
          <source>Example requests</source>
          <target state="translated">リクエスト例</target>
        </trans-unit>
        <trans-unit id="101e766cdf474de8672fa38603435f2c2f88941b" translate="yes" xml:space="preserve">
          <source>Example response</source>
          <target state="translated">回答例</target>
        </trans-unit>
        <trans-unit id="9e9047fddfc8910797ad5dcc2be127acbfe08b7f" translate="yes" xml:space="preserve">
          <source>Example responses</source>
          <target state="translated">回答例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1391352a916b067bd98f31a68d100a8e123a5170" translate="yes" xml:space="preserve">
          <source>Example: Disable unsafe inline/eval, only allow loading of resources (images, fonts, scripts, etc.) over https:</source>
          <target state="translated">例 安全でないインライン/評価を無効にし、https経由でのリソース(画像、フォント、スクリプトなど)の読み込みのみを許可する。</target>
        </trans-unit>
        <trans-unit id="c7fd2423984ee2e46f44f28ab3c25a81d90c3fd1" translate="yes" xml:space="preserve">
          <source>Example: Do not implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">例:上記のポリシーはまだ実施しないでください。上記のポリシーはまだ実施せず、代わりに発生したであろう違反を報告するだけにしてください。</target>
        </trans-unit>
        <trans-unit id="179aebe7be456d632b5d789d99331eede78b73e3" translate="yes" xml:space="preserve">
          <source>Example: Don't implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">例:上記のポリシーをまだ実施しないでください。上記のポリシーをまだ実施しないで、代わりに発生したであろう違反を報告してください。</target>
        </trans-unit>
        <trans-unit id="6a1a9b351cb6e527d7405905cebedc49fbc528bb" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over HTTPS and to disable plugins:</source>
          <target state="translated">例 インラインコードを多用して修正したいが、リソースの読み込みは HTTPS のみで、プラグインは無効にしたいという既存のサイト。</target>
        </trans-unit>
        <trans-unit id="e17700dcd76dcab4611e46cba8a84a5260c2c790" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over https and disable plugins:</source>
          <target state="translated">例 インラインコードを多用している既存のサイトを修正したいが、リソースの読み込みはhttpsのみにしてプラグインを無効にしたい。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd077131fc10d919fcb4af0bc52b5d5dc3bff60d" translate="yes" xml:space="preserve">
          <source>Examples of Access Control in Action</source>
          <target state="translated">アクセス制御の動作例</target>
        </trans-unit>
        <trans-unit id="42b05d16ad1706c69b98dcd1d0beab7d996df8be" translate="yes" xml:space="preserve">
          <source>Examples of access control scenarios</source>
          <target state="translated">アクセス制御のシナリオ例</target>
        </trans-unit>
        <trans-unit id="8b6959ab8197d951dfd31c9bfb60d608f8853eea" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above.&lt;/a&gt;</source>
          <target state="translated">この使用例は&lt;a href=&quot;#Preflighted_requests&quot;&gt;上記にあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65a7ed9127c8003c7810083e7bbc1569d8b66810" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above&lt;/a&gt;.</source>
          <target state="translated">この使用例は&lt;a href=&quot;#Preflighted_requests&quot;&gt;上記にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="47abb8e5ca6a2e13e7aa85756a29b3a05a3d8d7b" translate="yes" xml:space="preserve">
          <source>Examples of what you can do with Feature Policy:</source>
          <target state="translated">Feature Policyでできることの例。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="57e9b7197782a4e7584bbc9820ab7355aa88a3d3" translate="yes" xml:space="preserve">
          <source>Examples: Common use cases</source>
          <target state="translated">例を紹介します。一般的な使用例</target>
        </trans-unit>
        <trans-unit id="997886ce9b39820b9d7574fbb168082bb6c4cfb9" translate="yes" xml:space="preserve">
          <source>Except for the standard hop-by-hop headers (&lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;), any hop-by-hop headers used by the message must be listed in the &lt;code&gt;Connection&lt;/code&gt; header, so that the first proxy knows it has to consume them and not forward them further. Standard hop-by-hop headers can be listed too (it is often the case of &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, but this is not mandatory).</source>
          <target state="translated">標準のホップバイホップヘッダー（&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;）を除いて、メッセージで使用されるホップバイホップヘッダーをリストする必要があります。 &lt;code&gt;Connection&lt;/code&gt; ヘッダーので、最初のプロキシが、それはそれらを消費し、さらにそれらを転送しないように持って知っています。標準のホップバイホップヘッダーも一覧表示できます（多くの場合、&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;場合です）が、これは必須ではありません）。</target>
        </trans-unit>
        <trans-unit id="7233a11fc2426584ed01a173a4d930d34926020b" translate="yes" xml:space="preserve">
          <source>Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully
   performed its normal request checks and just before it would perform
   the action associated with the request method.  A server MUST ignore
   all received preconditions if its response to the same request
   without those conditions would have been a status code other than a
   2xx (Successful) or 412 (Precondition Failed).  In other words,
   redirects and failures take precedence over the evaluation of
   preconditions in conditional requests. 

   A server that is not the origin server for the target resource and
   cannot act as a cache for requests on the target resource MUST NOT
   evaluate the conditional request header fields defined by this
   specification, and it MUST forward them if the request is forwarded,
   since the generating client intends that they be evaluated by a
   server that can provide a current representation.  Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as CONNECT, OPTIONS, or TRACE.

   Conditional request header fields that are defined by extensions to
   HTTP might place conditions on all recipients, on the state of the
   target resource in general, or on a group of resources.  For
   instance, the &quot;If&quot; header field in WebDAV can make a request
   conditional on various aspects of multiple resources, such as locks,
   if the recipient understands and implements that field (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918],
   Section&amp;nbsp;10.4&lt;/a&gt;).

   Although conditional request header fields are defined as being
   usable with the HEAD method (to keep HEAD's semantics consistent with
   those of GET), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a 304 (Not
   Modified) response and more useful than a 412 (Precondition Failed)
   response.</source>
          <target state="translated">以下で除外する場合を除き、受信者キャッシュまたはオリジンサーバーは、通常のリクエストチェックが正常に実行された後、リクエストメソッドに関連付けられているアクションを実行する直前に、受信したリクエストの前提条件を評価する必要があります。サーバーは、それらの条件なしの同じ要求への応答が2xx（成功）または412（前提条件失敗）以外のステータスコードである場合、受信したすべての前提条件を無視する必要があります。つまり、リダイレクトと失敗は、条件付きリクエストの前提条件の評価よりも優先されます。ターゲットリソースのオリジンサーバーではなく、ターゲットリソース上のリクエストのキャッシュとして機能できないサーバーは、この仕様で定義されている条件付きリクエストヘッダーフィールドを評価してはなりません。要求が転送される場合は、生成クライアントが現在の表現を提供できるサーバーによって評価されることを意図しているため、転送する必要があります。同様に、サーバーは、CONNECT、OPTIONS、またはTRACEなどの選択された表現の選択または変更を含まない要求メソッドで受信された場合、この仕様で定義された条件付き要求ヘッダーフィールドを無視する必要があります。 HTTPの拡張機能によって定義された条件付きリクエストヘッダーフィールドは、すべての受信者、ターゲットリソースの一般的な状態、またはリソースのグループに条件を設定する場合があります。たとえば、WebDAVの「If」ヘッダーフィールドは、受信者がそのフィールドを理解して実装している場合、ロックなどの複数のリソースのさまざまな側面を条件として要求を行うことができます（受信者がそのフィールドを理解して実装した場合（&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918]、セクション10.4&lt;/a&gt;）。条件付きリクエストヘッダーフィールドはHEADメソッドで使用できるように定義されていますが（GETのセマンティクスと一貫したHEADのセマンティクスを維持するため）、成功した応答は304（Not Modified）とほぼ同じサイズであるため、条件付きHEADを送信しても意味がありません。 ）応答であり、412（Precondition Failed）応答よりも有用です。</target>
        </trans-unit>
        <trans-unit id="25c9949f0e8e682737f53bb3d3d209c13c6e1d5b" translate="yes" xml:space="preserve">
          <source>Executable script is only allowed from userscripts.example.com.</source>
          <target state="translated">実行可能なスクリプトは、userscripts.example.comからのみ許可されています。</target>
        </trans-unit>
        <trans-unit id="2d47895b1210b1ebd4fa933059d36aed26cda284" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely.  HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials,
   since the protocol has no awareness of how credentials are obtained 

   or managed by the user agent.  The mechanisms for expiring or
   revoking credentials can be specified as part of an authentication
   scheme definition.

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

   o  Clients that have been idle for an extended period, following
      which the server might wish to cause the client to re-prompt the
      user for credentials.

   o  Applications that include a session termination indication (such
      as a &quot;logout&quot; or &quot;commit&quot; button on a page) after which the server
      side of the application &quot;knows&quot; that there is no further reason
      for the client to retain the credentials.

   User agents that cache credentials are encouraged to provide a
   readily accessible mechanism for discarding cached credentials under
   user control.</source>
          <target state="translated">既存の HTTP クライアントとユーザエージェントは通常、認証情報を無期限に保持します。HTTP は、プロトコルがどのようにしてクレデンシャルがユーザ・エージェントによって取得または管理されているかを認識していないため、オリジン・サーバがクライアントにこれらのキャッシュされたクレデンシャルを破棄するように指示するメカニズムを提供しません。クレデンシャルの期限切れまたは失効のメカニズムは、認証スキーム定義の一部として指定することができます。クレデンシャル・キャッシュがアプリケーションのセキュリティ・モデルに干渉する可能性がある状況には、以下のものがありますが、これらに限定されません。クレデンシャルをキャッシュするユーザ・エージェントは、ユーザの制御下でキャッシュされたクレデンシャルを破棄するために、容易にアクセス可能なメカニズムを提供することが推奨される。</target>
        </trans-unit>
        <trans-unit id="6ccac52b5d4274914636579bf1636b1d5fa966cc" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP/1.1. does not provide a method for a
   server to direct clients to discard these cached credentials. This is
   a significant defect that requires further extensions to HTTP.
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

      - Clients which have been idle for an extended period following
        which the server might wish to cause the client to reprompt the
        user for credentials.

      - Applications which include a session termination indication
        (such as a `logout' or `commit' button on a page) after which
        the server side of the application `knows' that there is no
        further reason for the client to retain the credentials.

   This is currently under separate study. There are a number of work-
   arounds to parts of this problem, and we encourage the use of
   password protection in screen savers, idle time-outs, and other
   methods which mitigate the security problems inherent in this
   problem. In particular, user agents which cache credentials are
   encouraged to provide a readily accessible mechanism for discarding
   cached credentials under user control.</source>
          <target state="translated">既存の HTTP クライアントとユーザエージェントは通常、認証情報を無期限に保持します。HTTP/1.1.1.では、サーバがこれらのキャッシュされた認証情報を破棄するようにクライアントに指示するための方法を提供していません。これは、HTTP のさらなる拡張を必要とする重大な欠陥です。クレデンシャルキャッシュがアプリケーションのセキュリティモデルに干渉する可能性がある状況には、以下のようなものがありますが、これらに限定されません。-長時間アイドル状態が続いたクライアントで、サーバがクライアントにユーザにクレデンシャルの再提示をさせたいと考える可能性があります。-アプリケーションのサーバ側がクライアントがクレデンシャルを保持する理由がこれ以上ないことを「知っている」後に、セッション終了の指示(ページ上の「logout」や「commit」ボタンなど)を含むアプリケーショ ン。これは現在別件で研究中です。この問題の一部には多くの回避策があり、スクリーンセイバーでのパスワード保護、アイドルタイムアウト、およびこの問題に内在するセキュリティ問題を緩和する他の方法の使用を推奨します。特に、クレデンシャルをキャッシュするユーザ・エージェントは、ユーザの制御下でキャッシュされたクレデンシャルを破棄するための容易にアクセス可能なメカニズムを提供するように奨励される。</target>
        </trans-unit>
        <trans-unit id="a57a461722611e40b9d47ce41e5966ee9c0e2bfc" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site</source>
          <target state="translated">サイトのリーチを拡大する</target>
        </trans-unit>
        <trans-unit id="8a76f4ceddd2c24dfba52fcd6415b4a5d7627655" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site. A common case is when your site resides under the &lt;code&gt;www.example.com&lt;/code&gt; domain and accessing your pages from &lt;code&gt;example.com&lt;/code&gt; should be possible, too. Redirections for &lt;code&gt;example.com&lt;/code&gt; pages to &lt;code&gt;www.example.com&lt;/code&gt; are set up in this case. You might also provide commonly used synonym names or frequent typos of your domain names.</source>
          <target state="translated">サイトのリーチを拡大します。一般的なケースは、サイトが &lt;code&gt;www.example.com&lt;/code&gt; ドメインの下にあり、 &lt;code&gt;example.com&lt;/code&gt; からのページへのアクセスも可能である場合です。この場合、 &lt;code&gt;example.com&lt;/code&gt; ページから &lt;code&gt;www.example.com&lt;/code&gt; へのリダイレクトが設定されます。また、よく使用される同義語の名前や、ドメイン名のタイプミスを頻繁に提供することもできます。</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="994027919b14e63b028676f8e18f24f8c3412b5f" translate="yes" xml:space="preserve">
          <source>Expect (RFC 2616)</source>
          <target state="translated">期待しています (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="53f1bb33df8415879d9607269fadc4b08f7884fc" translate="yes" xml:space="preserve">
          <source>Expect (RFC 7231)</source>
          <target state="translated">期待しています (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="dac7eb9f8e739ef71916b8aa6eabe504d21db9ae" translate="yes" xml:space="preserve">
          <source>Expect-CT</source>
          <target state="translated">Expect-CT</target>
        </trans-unit>
        <trans-unit id="1782a86fff7281c9294c0d3eefa4ab6846695cc2" translate="yes" xml:space="preserve">
          <source>Expect-CT Extension for HTTP</source>
          <target state="translated">HTTP用のExpect-CT拡張</target>
        </trans-unit>
        <trans-unit id="79322ef6edc1926ecbca88fd7e24b3ff46c3ac45" translate="yes" xml:space="preserve">
          <source>Experimental spec</source>
          <target state="translated">実験仕様</target>
        </trans-unit>
        <trans-unit id="549fb9eb005687c11bca9c3462372257a7683df5" translate="yes" xml:space="preserve">
          <source>Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; which builds on UDP to provide a more reliable and efficient transport protocol.</source>
          <target state="translated">HTTPにより適したより優れたトランスポートプロトコルを設計するための実験が進行中です。たとえば、GoogleはUDPに基づいて構築された&lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt;を実験しており、より信頼性が高く効率的なトランスポートプロトコルを提供しています。</target>
        </trans-unit>
        <trans-unit id="1c82119c31678afc6233c719096414eef0fb22b6" translate="yes" xml:space="preserve">
          <source>Expiration</source>
          <target state="translated">Expiration</target>
        </trans-unit>
        <trans-unit id="a99be3da0c9da2f3c64500b5ef8a8e48f503d127" translate="yes" xml:space="preserve">
          <source>Expires</source>
          <target state="translated">Expires</target>
        </trans-unit>
        <trans-unit id="cc75acb2b0ea3b677a15b0b6b818f64332802b2f" translate="yes" xml:space="preserve">
          <source>Expires (RFC 2616)</source>
          <target state="translated">Expires (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="668c321a385a7ec5effd27dc4959016e1b54db8c" translate="yes" xml:space="preserve">
          <source>Expires (RFC 7234)</source>
          <target state="translated">Expires (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="798d2fe08024167fc3592a3e1fdd8f0482db3150" translate="yes" xml:space="preserve">
          <source>Expires=&amp;lt;date&amp;gt; Optional</source>
          <target state="translated">Expires = &amp;lt;date&amp;gt;オプション</target>
        </trans-unit>
        <trans-unit id="440f936591556c4ab22d4ca93b07905600bf80fc" translate="yes" xml:space="preserve">
          <source>Explains how a client and a server can negotiate a specific HTTP version and eventually upgrade the protocol version used.</source>
          <target state="translated">クライアントとサーバが特定の HTTP バージョンをネゴシエートし、最終的に使用するプロトコルのバージョンをアップグレードする方法を説明します。</target>
        </trans-unit>
        <trans-unit id="4c04fa2d870e27906bb18e89eabbb66f7bf88805" translate="yes" xml:space="preserve">
          <source>Expresses the user's tracking preference.</source>
          <target state="translated">ユーザーのトラッキングの好みを表現します。</target>
        </trans-unit>
        <trans-unit id="a639e6f336caa1c98ebcd19c35befb40a19c9aca" translate="yes" xml:space="preserve">
          <source>Extending a database through an append operation.</source>
          <target state="translated">append操作によるデータベースの拡張。</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="a5be9d96e47f86f30faca0b0c0d8cd92b6b591df" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives</source>
          <target state="translated">拡張 &lt;code&gt;Cache-Control&lt;/code&gt; ディレクティブ</target>
        </trans-unit>
        <trans-unit id="fef92b354ef2777bc846bf834005b52b7dd4a00e" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Be sure to check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support.</source>
          <target state="translated">Extension &lt;code&gt;Cache-Control&lt;/code&gt; ディレクティブは、コアHTTPキャッシング標準ドキュメントの一部ではありません。サポートについては、&lt;a href=&quot;#Browser_compatibility&quot;&gt;互換性の表&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="790215898ba9547c6ca3b5fc75be3806f3e82b33" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support; user-agents that don't recognize them should ignore them.</source>
          <target state="translated">Extension &lt;code&gt;Cache-Control&lt;/code&gt; ディレクティブは、コアHTTPキャッシング標準ドキュメントの一部ではありません。&lt;a href=&quot;#Browser_compatibility&quot;&gt;互換性テーブル&lt;/a&gt;でサポートを確認してください。それらを認識しないユーザーエージェントはそれらを無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="16b9d10d572cffd131c6e10d79fd13870c1b14e9" translate="yes" xml:space="preserve">
          <source>Extension Cache-Control directives</source>
          <target state="translated">拡張 Cache-Control ディレクティブ</target>
        </trans-unit>
        <trans-unit id="f9618205d36acb2ec9a802339b387cf754ed53de" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;) unless it's overwritten via an HTTP header that is set for a CSS stylesheet specifically.</source>
          <target state="translated">外部CSSスタイルシートは、CSSスタイルシート専用に設定されたHTTPヘッダーで上書きされない限り、デフォルトポリシー（ &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="1f757e53076199141ccd603fa5607cc746399b36" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;), unless it's overwritten via a &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header on the CSS stylesheet&amp;rsquo;s response.</source>
          <target state="translated">外部CSSスタイルシートは、CSSスタイルシートの応答の &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTPヘッダーを介して上書きされない限り、デフォルトのポリシー（ &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="51b4519004830e628fefbfc612f64b245ab37406" translate="yes" xml:space="preserve">
          <source>Extracting the Base64 encoded public key information</source>
          <target state="translated">Base64エンコードされた公開鍵情報の抽出</target>
        </trans-unit>
        <trans-unit id="82ca99fbea5a5ea4d775520c3099a29adbd2bbf4" translate="yes" xml:space="preserve">
          <source>F.1.  Changes for Both Client and Server Implementations</source>
          <target state="translated">F.1.クライアントとサーバーの両方の実装の変更点</target>
        </trans-unit>
        <trans-unit id="e3444e81a7c395eacc8d894f9505a6b6ec9ed898" translate="yes" xml:space="preserve">
          <source>F.2.  Changes for Server Implementations</source>
          <target state="translated">F.2.サーバー実装の変更点</target>
        </trans-unit>
        <trans-unit id="8d6a58de84dd929ed244644a2cc93d7d20768fb2" translate="yes" xml:space="preserve">
          <source>F.3.  Other Changes</source>
          <target state="translated">F.3.その他の変更点</target>
        </trans-unit>
        <trans-unit id="22da6d41863afa4c87a7a2a96539883a5b235c05" translate="yes" xml:space="preserve">
          <source>FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.</source>
          <target state="translated">FTPはトップレベル(ブラウザのURLバーに直接入力したり、リンクのターゲットにしたり)ではまだ許容されますが、ブラウザによってはFTPコンテンツの読み込みを別のアプリケーションに委任する場合もあります。</target>
        </trans-unit>
        <trans-unit id="92fe61c3f61162d432bcc18c5c3c2721f89c4867" translate="yes" xml:space="preserve">
          <source>Faced with this error, browsers usually either abort the operation (for example, a download will be considered as non-resumable) or ask for the whole document again.</source>
          <target state="translated">このエラーに直面した場合、ブラウザは通常、操作を中止するか(例えば、ダウンロードは再開不可能とみなされます)、ドキュメント全体を再度要求します。</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="eba72e67a897b4f1538c1c559bf91bf79d26f8df" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;fullscreen&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.は、特定の&amp;lt;iframe&amp;gt;を除いて、クロスオリジンのすべての子フレームで &lt;code&gt;fullscreen&lt;/code&gt; を無効にしたいと考えています。これを行うには、次のHTTP応答ヘッダーを配信して機能ポリシーを定義します。</target>
        </trans-unit>
        <trans-unit id="30c4b13be3aa4b1468bedb0d443187e381399c80" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;geolocation&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.は、特定の&amp;lt;iframe&amp;gt;を除いて、すべてのクロスオリジン子フレームの &lt;code&gt;geolocation&lt;/code&gt; を無効にしたいと考えています。これを行うには、次のHTTP応答ヘッダーを配信して機能ポリシーを定義します。</target>
        </trans-unit>
        <trans-unit id="2b02ecda0275dbc6a16322d0aa2715bb1b0c7f16" translate="yes" xml:space="preserve">
          <source>Feature Policy</source>
          <target state="translated">機能方針</target>
        </trans-unit>
        <trans-unit id="116ce4ea97fc76a7402a5b9f210f36fadfbb4c2b" translate="yes" xml:space="preserve">
          <source>Feature Policy allows web developers to selectively enable, disable, and modify the behavior of certain features and APIs in the browser. It is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;Content Security Policy&lt;/a&gt; but controls features instead of security behavior.</source>
          <target state="translated">機能ポリシーを使用すると、Web開発者はブラウザで特定の機能とAPIの動作を選択的に有効化、無効化、および変更できます。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;コンテンツセキュリティポリシーに&lt;/a&gt;似ていますが、セキュリティの動作ではなく機能を制御します。</target>
        </trans-unit>
        <trans-unit id="c53bb4cebead9ce42d5d5eff5bdc667fd91758b5" translate="yes" xml:space="preserve">
          <source>Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins.</source>
          <target state="translated">フィーチャーポリシーでは、トップレベルページと埋め込みフレームの両方で、どのオリジンがどのフィーチャーを使用できるかを制御することができます。基本的には、各機能の許可されたオリジンのリストであるポリシーを記述します。フィーチャーポリシーで制御されているすべての機能について、その機能の発信元が許可されている発信元リストに一致している場合にのみ、その機能は現在のドキュメントやフレームで有効になります。</target>
        </trans-unit>
        <trans-unit id="23cd7a78a2dc77e19ba57e025deceab5b480ee5d" translate="yes" xml:space="preserve">
          <source>Feature Policy provides a mechanism to explicitly declare what functionality is used (or not used), throughout your website. This allows you to lock in best practices, even as the codebase evolves over time &amp;mdash; as well as to more safely compose third-party content &amp;mdash; by limiting which features are available.</source>
          <target state="translated">機能ポリシーは、Webサイト全体で使用される（または使用されない）機能を明示的に宣言するメカニズムを提供します。これにより、コードベースが時間の経過とともに進化する場合でも、使用可能な機能を制限することにより、サードパーティのコンテンツをより安全に作成できるように、ベストプラクティスを取り入れることができます。</target>
        </trans-unit>
        <trans-unit id="92799190c0f4fe5ecaee2952ecf286aa6cce9ac3" translate="yes" xml:space="preserve">
          <source>Feature Policy provides two ways to specify policies to control features:</source>
          <target state="translated">フィーチャーポリシーには、フィーチャーを制御するためのポリシーを指定する2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="0847c40e72979da8866a8e8b3f1f0cc411a2dad3" translate="yes" xml:space="preserve">
          <source>Feature Policy: Using Feature Policy</source>
          <target state="translated">フィーチャーポリシー。フィーチャーポリシーの使用</target>
        </trans-unit>
        <trans-unit id="fcae4ecf5da500dd00bf9572a09b7e678697d109" translate="yes" xml:space="preserve">
          <source>Feature Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">機能ポリシー&lt;br/&gt;&lt;small&gt;その仕様における「機能ポリシー」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="294d4d9a4eaac5449bf61242940545b797efd4f7" translate="yes" xml:space="preserve">
          <source>Feature detection</source>
          <target state="translated">特徴検出</target>
        </trans-unit>
        <trans-unit id="6680a4d48c2812c07a01fb3632993e80d45a2200" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. In those rare cases where behavior differs between browsers, instead of checking the user agent string, you should instead implement a test to detect how the browser implements the API and determine how to use it from that. An example of feature detection is as follows. In 2017, Chrome &lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;unflagged experimental lookbehind support in regular expressions&lt;/a&gt;, but no other browser supported it. So, you might have thought to do this:</source>
          <target state="translated">機能検出では、どのブラウザがページをレンダリングしているかを把握しようとはしませんが、代わりに、必要な特定の機能が利用可能かどうかを確認します。そうでない場合は、フォールバックを使用します。ブラウザ間で動作が異なるまれなケースでは、ユーザーエージェント文字列をチェックする代わりに、ブラウザがAPIを実装する方法を検出し、そこからAPIを使用する方法を決定するテストを実装する必要があります。特徴検出の例は次のとおりです。 2017年、Chrome&lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;は正規表現&lt;/a&gt;での実験的な後読みのサポートにフラグを立てていませんでしたが、他のブラウザではサポートされていませんでした。だから、あなたはこれをすることを考えたかもしれません：</target>
        </trans-unit>
        <trans-unit id="4cfcbb2b685a05f07291909f36952c99a4e2fe7b" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. There are never any rare cases where you should use the user agent string, such as to detect a browser which implements the behavior of an API differently. Rather, in such rare cases, you should implement a test to detect how the browser implements the API and then determine when and how to use it instead. A good current example of feature detection is as follows. Recently, Chrome has added experimental look behind support to regular expressions, but no other browser currently supports this. So, you might incorrectly assume you should do this:</source>
          <target state="translated">機能検出とは、どのブラウザがページをレンダリングしているかを調べるのではなく、必要な特定の機能が利用可能かどうかを確認することです。利用できない場合は、フォールバックを使用します。API の動作を異なる方法で実装しているブラウザを検出するなど、ユーザーエージェント文字列を使用する必要がある稀なケースはありません。むしろ、そのような稀なケースでは、ブラウザがどのようにAPIを実装しているかを検出し、代わりにいつ、どのようにAPIを使用するかを決定するためのテストを実装すべきです。現在の機能検出の良い例は以下の通りです。最近、Chromeは正規表現に実験的なルックビハインドのサポートを追加しましたが、現在のところこれをサポートしているブラウザは他にありません。そのため、これを行うべきだと誤って思い込んでしまうかもしれません。</target>
        </trans-unit>
        <trans-unit id="95c726252d0d002492bfb760d3686808998bb8df" translate="yes" xml:space="preserve">
          <source>Feature policies on www.chromestatus.com</source>
          <target state="translated">www.chromestatus.com の特徴的なポリシー</target>
        </trans-unit>
        <trans-unit id="d7fb77650eb9c4f73d9377f06679ca2cd28df471" translate="yes" xml:space="preserve">
          <source>Feature-Policy</source>
          <target state="translated">Feature-Policy</target>
        </trans-unit>
        <trans-unit id="6731078bdcb61e26085f7dc9985790c18e8a240e" translate="yes" xml:space="preserve">
          <source>Feature-Policy Tester (Chrome Developer Tools extension)</source>
          <target state="translated">Feature-Policy Tester (Chrome Developer Tools 拡張機能)</target>
        </trans-unit>
        <trans-unit id="a6ee4ffa583da7bdf223c2ffed9d85ab239371e0" translate="yes" xml:space="preserve">
          <source>Feature-Policy: autoplay</source>
          <target state="translated">機能-ポリシー:自動再生</target>
        </trans-unit>
        <trans-unit id="31f9ca897eb5c9f44de8842f2516fb02a54faa2e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: camera</source>
          <target state="translated">機能-ポリシー:カメラ</target>
        </trans-unit>
        <trans-unit id="bf16c6ee691c8e9ca8e2dbe87a3f347fcb570cc7" translate="yes" xml:space="preserve">
          <source>Feature-Policy: document-domain</source>
          <target state="translated">機能-ポリシー:ドキュメントドメイン</target>
        </trans-unit>
        <trans-unit id="fe796e681d5c63dcc531be776ac43685da71889f" translate="yes" xml:space="preserve">
          <source>Feature-Policy: encrypted-media</source>
          <target state="translated">機能-ポリシー:暗号化されたメディア</target>
        </trans-unit>
        <trans-unit id="37767aecde5e9787909f7866d3735071b1ccad3d" translate="yes" xml:space="preserve">
          <source>Feature-Policy: fullscreen</source>
          <target state="translated">機能-ポリシー:フルスクリーン</target>
        </trans-unit>
        <trans-unit id="9488de5430b2b3fc9fd436b5e2d0c394e296837e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: geolocation</source>
          <target state="translated">機能-ポリシー:ジオロケーション</target>
        </trans-unit>
        <trans-unit id="2c61ebc183f28f44ab1b2b148b5d57942442df26" translate="yes" xml:space="preserve">
          <source>Feature-Policy: microphone</source>
          <target state="translated">機能-ポリシー:マイク</target>
        </trans-unit>
        <trans-unit id="596057da4c0cdcb20ea8b614fd43950671e7a493" translate="yes" xml:space="preserve">
          <source>Feature-Policy: midi</source>
          <target state="translated">機能-ポリシー:midi</target>
        </trans-unit>
        <trans-unit id="6ae2a5e94ce91f2de51637745788fb01a6ad53dc" translate="yes" xml:space="preserve">
          <source>Feature-Policy: payment</source>
          <target state="translated">機能-ポリシー:支払い</target>
        </trans-unit>
        <trans-unit id="6392e975cf7e0435d78f4e6d61f8527537c58cfd" translate="yes" xml:space="preserve">
          <source>Feature-Policy: vr</source>
          <target state="translated">機能-ポリシー:vr</target>
        </trans-unit>
        <trans-unit id="088204f1105dd468d38881f2fd12a0b4aa4c7aab" translate="yes" xml:space="preserve">
          <source>Feature-Policy:fullscreen</source>
          <target state="translated">Feature-Policy:fullscreen</target>
        </trans-unit>
        <trans-unit id="d710338755da08a83c18e218bac6cbaa1e2a4fd1" translate="yes" xml:space="preserve">
          <source>Feature-Policy:geolocation</source>
          <target state="translated">Feature-Policy:geolocation</target>
        </trans-unit>
        <trans-unit id="9d7e13756d87f97651352edd83fe4becad54f376" translate="yes" xml:space="preserve">
          <source>Feature-Policy:microphone</source>
          <target state="translated">Feature-Policy:microphone</target>
        </trans-unit>
        <trans-unit id="e7e6e3dcff550300eec2d95910564a70e893cba4" translate="yes" xml:space="preserve">
          <source>Features are each defined to have a default allowlist, which is one of:</source>
          <target state="translated">機能はそれぞれデフォルトのallowlistを持つように定義されています。</target>
        </trans-unit>
        <trans-unit id="73987c80f34346a88ab75127eefbe27a82362092" translate="yes" xml:space="preserve">
          <source>Features restricted to secure contexts</source>
          <target state="translated">安全なコンテキストに限定された機能</target>
        </trans-unit>
        <trans-unit id="39e28fef517be6e0fc21d5716c7662e4801ad299" translate="yes" xml:space="preserve">
          <source>Fetch API</source>
          <target state="translated">フェッチ API</target>
        </trans-unit>
        <trans-unit id="0c16479e5749d322208146b5b5f7624d72ebd140" translate="yes" xml:space="preserve">
          <source>Fetch directive</source>
          <target state="translated">フェッチディレクティブ</target>
        </trans-unit>
        <trans-unit id="e53b45c9af742d503a22c70314dddb7873195091" translate="yes" xml:space="preserve">
          <source>Fetch directives</source>
          <target state="translated">ディレクティブの取得</target>
        </trans-unit>
        <trans-unit id="7a5dfae050f11fd6283650bfb92f289b86d2ac98" translate="yes" xml:space="preserve">
          <source>Fetch directives control locations from which certain resource types may be loaded.</source>
          <target state="translated">Fetch ディレクティブは、特定のリソースタイプが読み込まれる場所を制御します。</target>
        </trans-unit>
        <trans-unit id="6117c09509a0de56a9b4f6836fda41153fe625f3" translate="yes" xml:space="preserve">
          <source>Fetch directives control the locations from which certain resource types may be loaded.</source>
          <target state="translated">Fetch ディレクティブは、特定のリソースタイプが読み込まれる場所を制御します。</target>
        </trans-unit>
        <trans-unit id="afdd60e438b0416f34aeb50bf03aae713ddb1bda" translate="yes" xml:space="preserve">
          <source>Fetch metadata request headers</source>
          <target state="translated">メタデータ要求ヘッダの取得</target>
        </trans-unit>
        <trans-unit id="916f35ff813a6743346055125d97c6cbba1aaedc" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Credentials' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Allow-Credentials」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0678866e50722f12e36a5dc2fec0748a692fe2ca" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Allow-Headers」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2cf87afd008c8c6a087d3cc6f98ba0277b9043b7" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Methods' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Allow-Methods」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4f7ed2d1134249b47bfd1f0ca53f80515e1563f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Allow-Origin」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b6d65973f43b54eb3f3ef47447a2bae6cff6fe97" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Expose-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Expose-Headers」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8089c31c9e26d8f2db19edbf9e44a130bc5eddd3" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Max-Age' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Max-Age」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9397823a091bbc18047f30f651f6476462ab4fa8" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Request-Headers」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82f6f83e1801614fce5a5524369fe1de50f85da5" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Method' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「Access-Control-Request-Method」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1eb076c3812c097fec7c1be9899bd085c5fbf1" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'CORS' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「CORS」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe63ee35db7f3102d616e69a27e101cdcc18b63a" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Origin header' in that specification.&lt;/small&gt;</source>
          <target state="translated">フェッチ&lt;br/&gt;&lt;small&gt;その仕様における「元のヘッダー」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1446331a1b71bc30148510fc4d99d0e0ec91086f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'X-Content-Type-Options definition' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;その仕様における「X-Content-Type-Options定義」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="918815e8513a9d78892a5b82f5db40dddb1a7f3b" translate="yes" xml:space="preserve">
          <source>Fetching the root page of developer.mozilla.org, i.e. &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;, and telling the server that the user-agent would prefer the page in French, if possible:</source>
          <target state="translated">developer.mozilla.orgのルートページ、つまり&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;を取得し、可能な場合はユーザーエージェントがフランス語のページを好むことをサーバーに伝えます。</target>
        </trans-unit>
        <trans-unit id="3253d0b90d63fd1a7b31fd3494e21aaa52e7e42e" translate="yes" xml:space="preserve">
          <source>File Transfer Protocol</source>
          <target state="translated">ファイル転送プロトコル</target>
        </trans-unit>
        <trans-unit id="5d438ceeae874a432c5e55fd5791a60c59eb0d8f" translate="yes" xml:space="preserve">
          <source>File extension(s)</source>
          <target state="translated">ファイル拡張子</target>
        </trans-unit>
        <trans-unit id="361a82465491c9161713f597566a3f42e5734e1b" translate="yes" xml:space="preserve">
          <source>File format</source>
          <target state="translated">ファイル形式</target>
        </trans-unit>
        <trans-unit id="4a7b57a8f84d5b2b2d5abb274bb773348457c9ea" translate="yes" xml:space="preserve">
          <source>File format compression</source>
          <target state="translated">ファイル形式の圧縮</target>
        </trans-unit>
        <trans-unit id="57fa91ed93807da407d7147d7099ef87d3eef96c" translate="yes" xml:space="preserve">
          <source>Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct.</source>
          <target state="translated">ファイル名の接尾辞は、特に Microsoft Windows で使われることがあります。すべてのオペレーティングシステムがこれらの接尾辞に意味があるとは限りません (Linux や MacOS など)。</target>
        </trans-unit>
        <trans-unit id="b8a4a48235c2528b57fabea0f16e59922544df82" translate="yes" xml:space="preserve">
          <source>Files whose MIME type is &lt;code&gt;image&lt;/code&gt; contain image data. The subtype specifies which specific image file format the data represents. Only a few image types are used commonly enough to be considered safe for use on web pages:</source>
          <target state="translated">MIMEタイプが &lt;code&gt;image&lt;/code&gt; のファイルには、画像データが含まれています。サブタイプは、データが表す特定の画像ファイル形式を指定します。Webページで安全に使用できると見なされるのに十分なほど一般的に使用されている画像タイプはごくわずかです。</target>
        </trans-unit>
        <trans-unit id="d1888d033ef09f73993a1ae6180b384a516770e4" translate="yes" xml:space="preserve">
          <source>Filtration based on &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, if any at all.</source>
          <target state="translated">存在する場合、&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;に基づくろ過。</target>
        </trans-unit>
        <trans-unit id="02b7b1f402f1dad5cba5d5c6f4047891c00d3834" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request. In this case, 86400 seconds is 24 hours. Note that each browser has a &lt;a href=&quot;headers/access-control-max-age&quot;&gt;maximum internal value&lt;/a&gt; that takes precedence when the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; is greater.</source>
          <target state="translated">最後に、&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt;は、別のプリフライト要求を送信せずにプリフライト要求への応答をキャッシュできる期間を秒単位で示します。この場合、86400秒は24時間です。各ブラウザーには、 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; が大きい場合に優先する&lt;a href=&quot;headers/access-control-max-age&quot;&gt;最大内部値&lt;/a&gt;があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c162123e6b08c6245b8c567094309cf3046a7d6" translate="yes" xml:space="preserve">
          <source>Finding insecure requests</source>
          <target state="translated">不安な要望を見つける</target>
        </trans-unit>
        <trans-unit id="b4ee6522335b033249255b4cc1d572993282aafb" translate="yes" xml:space="preserve">
          <source>Firefox</source>
          <target state="translated">Firefox</target>
        </trans-unit>
        <trans-unit id="3d69145991747b3ff98ca2ac235bf9a2b6c0b22b" translate="yes" xml:space="preserve">
          <source>Firefox 3.6 and later</source>
          <target state="translated">Firefox 3.6以降</target>
        </trans-unit>
        <trans-unit id="9a053be79e5c0ac7481cbdffd78827759a3ed9f5" translate="yes" xml:space="preserve">
          <source>Firefox 4</source>
          <target state="translated">Firefox 4</target>
        </trans-unit>
        <trans-unit id="e75eacacb146d953aa91455b2699bff5088fb836" translate="yes" xml:space="preserve">
          <source>Firefox 5 handles the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP response header more effectively if both the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; parameters are provided; it looks through all provided names, using the &lt;code&gt;filename*&lt;/code&gt; parameter if one is available, even if a &lt;code&gt;filename&lt;/code&gt; parameter is included first. Previously, the first matching parameter would be used, thereby preventing a more appropriate name from being used. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;bug 588781&lt;/a&gt;.</source>
          <target state="translated">Firefox 5は、 &lt;code&gt;filename&lt;/code&gt; と &lt;code&gt;filename*&lt;/code&gt; 両方のパラメーターが指定されている場合、 &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP応答ヘッダーをより効果的に処理します。 &lt;code&gt;filename&lt;/code&gt; パラメーターが最初に含まれている場合でも、使用可能な場合は &lt;code&gt;filename*&lt;/code&gt; パラメーターを使用して、指定されたすべての名前を調べます。以前は、最初に一致するパラメータが使用されていたため、より適切な名前が使用されませんでした。&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;バグ588781を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4443afafb8462a4928ffbe0151cd70875fd784c9" translate="yes" xml:space="preserve">
          <source>Firefox 72 enables &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; for top-level documents</source>
          <target state="translated">Firefox 72は、 &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; トップレベルドキュメントのnosniffを有効にします</target>
        </trans-unit>
        <trans-unit id="98488d27ab42c5d6a59371f548c195bffbe9d824" translate="yes" xml:space="preserve">
          <source>Firefox 82 (and later) and Chrome prioritize the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt; element's&lt;/a&gt;&lt;code&gt;download&lt;/code&gt; attribute over the &lt;code&gt;Content-Disposition&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt; parameter (for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin URLs&lt;/a&gt;). Earlier Firefox versions prioritize the header and will display the content inline.</source>
          <target state="translated">Firefox 82（およびそれ以降）とChromeは、HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt;要素の&lt;/a&gt; &lt;code&gt;download&lt;/code&gt; 属性を &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;code&gt;inline&lt;/code&gt; パラメーター（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同一生成元URLの場合&lt;/a&gt;）よりも優先します。以前のバージョンのFirefoxはヘッダーを優先し、コンテンツをインラインで表示します。</target>
        </trans-unit>
        <trans-unit id="389872f22235d2e890d3e24f0e0fb6d81e0c8a59" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds) and Chromium at &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 minutes&lt;/a&gt; (600 seconds). Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Firefoxは&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;これを24時間&lt;/a&gt;（86400秒）で、Chromiumは&lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10分&lt;/a&gt;（600秒）で制限します。Chromiumでは、デフォルト値の5秒も指定されています。</target>
        </trans-unit>
        <trans-unit id="90fb1b1a36a9c036151eeced597d613144d0f291" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds).</source>
          <target state="translated">Firefoxは&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;これを24時間&lt;/a&gt;（86400秒）に制限します。</target>
        </trans-unit>
        <trans-unit id="1444ac74d1094f6f34b49da3ee9966b7b93f1731" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools</source>
          <target state="translated">Firefox開発者ツール</target>
        </trans-unit>
        <trans-unit id="f300fd41a795a419c45aee9c6cb726e738e71b7e" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools: using a source map</source>
          <target state="translated">Firefox 開発者ツール:ソースマップの使用</target>
        </trans-unit>
        <trans-unit id="e4b319de38dd3b5708092c79d821e3e2547bbfeb" translate="yes" xml:space="preserve">
          <source>Firefox OS</source>
          <target state="translated">ファイアフォックスOS</target>
        </trans-unit>
        <trans-unit id="08b98a32baa6ee15d09f718291f659a3f7d5a387" translate="yes" xml:space="preserve">
          <source>Firefox OS devices identify themselves without any operating system indication; for example: &quot;Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0&quot;. The web is the platform.</source>
          <target state="translated">Firefox OS のデバイスは、オペレーティングシステムの表示なしに自分自身を識別します。&quot;Mozilla/5.0 (Mobile;rv:15.0)Gecko/15.0 Firefox/15.0&quot;.ウェブはプラットフォームです。</target>
        </trans-unit>
        <trans-unit id="096d24033e6a963360da3b94208e68f8d97b00a8" translate="yes" xml:space="preserve">
          <source>Firefox OS has a four-digit version number:</source>
          <target state="translated">FirefoxのOSには4桁のバージョン番号があります。</target>
        </trans-unit>
        <trans-unit id="ee0b8d61fb018abae298ec4b7eb6bf2ea815cea8" translate="yes" xml:space="preserve">
          <source>Firefox OS version number</source>
          <target state="translated">Firefox OSのバージョン番号</target>
        </trans-unit>
        <trans-unit id="0b43f7fedde8c737f31357ef6642b9b7dec844af" translate="yes" xml:space="preserve">
          <source>Firefox UA string</source>
          <target state="translated">FirefoxのUA文字列</target>
        </trans-unit>
        <trans-unit id="cd5ecb0a55376afe3b1ad82fbe8b4cecc9e76924" translate="yes" xml:space="preserve">
          <source>Firefox Web Runtime</source>
          <target state="translated">Firefox ウェブランタイム</target>
        </trans-unit>
        <trans-unit id="0c516be8bc16e485b9c5dea3cac5637b2be7f8c3" translate="yes" xml:space="preserve">
          <source>Firefox and Chrome&lt;strong&gt; disable pin validation&lt;/strong&gt; for pinned hosts whose validated certificate chain terminates at a &lt;strong&gt;user-defined trust anchor&lt;/strong&gt; (rather than a built-in trust anchor). This means that for users who imported custom root certificates all pinning violations are ignored.</source>
          <target state="translated">FirefoxおよびChrome は、検証済みの証明書チェーンが（組み込みの&lt;strong&gt;トラストアンカー&lt;/strong&gt;ではなく）&lt;strong&gt;ユーザー定義のトラストアンカーで&lt;/strong&gt;終了する固定ホストの&lt;strong&gt;ピン検証&lt;/strong&gt;を&lt;strong&gt;無効にします&lt;/strong&gt;。つまり、カスタムルート証明書をインポートしたユーザーの場合、すべての固定違反は無視されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f46b1448185527825780f84cfe778a2558ec052f" translate="yes" xml:space="preserve">
          <source>Firefox currently only supports the &lt;code&gt;Large-Allocation&lt;/code&gt; header in our 32-bit Windows builds, as memory fragmentation is not an issue in 64-bit builds. If you are running a non-win32 version of Firefox, this error will appear. This check can be disabled with the &quot;dom.largeAllocation.</source>
          <target state="translated">メモリの断片化は64ビットビルドの問題ではないため、Firefoxは現在、32ビットWindowsビルドの &lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーのみをサポートしています。Win32以外のバージョンのFirefoxを実行している場合、このエラーが表示されます。このチェックは、「dom.largeAllocation。</target>
        </trans-unit>
        <trans-unit id="fd814d6c03ca30a65e6eae11a110b64dbd4091ec" translate="yes" xml:space="preserve">
          <source>Firefox earlier than 3.6</source>
          <target state="translated">3.6以前のFirefox</target>
        </trans-unit>
        <trans-unit id="35e08ebaf6a034e084ac621e4a8de400a08ba9e7" translate="yes" xml:space="preserve">
          <source>Firefox for Android</source>
          <target state="translated">Android用Firefox</target>
        </trans-unit>
        <trans-unit id="6b3b609703588318cf5eddb907cb036af5b8fa9f" translate="yes" xml:space="preserve">
          <source>Firefox for Echo Show</source>
          <target state="translated">エコーショーのためのFirefox</target>
        </trans-unit>
        <trans-unit id="70bde33b11b3ebf831139347906ee55c0954e773" translate="yes" xml:space="preserve">
          <source>Firefox for Fire TV</source>
          <target state="translated">Firefox for Fire TV</target>
        </trans-unit>
        <trans-unit id="aa1b6f07af81be5e73ca90848517f82656d9b533" translate="yes" xml:space="preserve">
          <source>Firefox for Maemo (Nokia N900)</source>
          <target state="translated">Maemo用Firefox (Nokia N900)</target>
        </trans-unit>
        <trans-unit id="d796cd118178bed42189a33b56788596ce709a40" translate="yes" xml:space="preserve">
          <source>Firefox for iOS</source>
          <target state="translated">iOS用Firefox</target>
        </trans-unit>
        <trans-unit id="4a1947cf48de07acf77d4542c741b3b264b1d589" translate="yes" xml:space="preserve">
          <source>Firefox for iOS user agent string</source>
          <target state="translated">iOS版Firefoxのユーザーエージェント文字列</target>
        </trans-unit>
        <trans-unit id="520f59d4c4564c36ce2dffd8248ed3f436481f50" translate="yes" xml:space="preserve">
          <source>Firefox for iOS uses the default Mobile Safari UA string, with an additional &lt;strong&gt;FxiOS/&amp;lt;version&amp;gt;&lt;/strong&gt; token, similar to how &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS identifies itself&lt;/a&gt;.</source>
          <target state="translated">iOS版Firefoxは、デフォルトのMobile Safari UA文字列と、追加の&lt;strong&gt;FxiOS / &amp;lt;version&amp;gt;&lt;/strong&gt;トークンを使用します。これは、iOS &lt;strong&gt;版&lt;/strong&gt;&lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chromeがそれ自体を識別する&lt;/a&gt;方法と似ています。</target>
        </trans-unit>
        <trans-unit id="57d4690e6cf1e25d65d0fd2cf1024daa1be89df4" translate="yes" xml:space="preserve">
          <source>Firefox has detected that the server is redirecting the request for this address in a way that will never complete.</source>
          <target state="translated">Firefoxは、サーバーがこのアドレスへのリクエストを決して完了しない方法でリダイレクトしていることを検出しました。</target>
        </trans-unit>
        <trans-unit id="97d9b72ae732fc5ec0d2b8c7b9205f083804989f" translate="yes" xml:space="preserve">
          <source>Firefox has moved to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess architecture&lt;/a&gt;, and this architecture is required in order to support the &lt;code&gt;Large-Allocation&lt;/code&gt; header. Some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;legacy Addons&lt;/a&gt; can prevent Firefox from using this new, faster, multiprocess architecture. If you have one of these Addons installed, then we will continue to use the old single process architecuture for compatibility, and cannot handle the &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Firefoxは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;マルチプロセスアーキテクチャに&lt;/a&gt;移行しました。このアーキテクチャは、 &lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーをサポートするために必要です。一部の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;レガシーアドオン&lt;/a&gt;は、Firefoxがこの新しい高速なマルチプロセスアーキテクチャを使用できないようにする可能性があります。これらのアドオンのいずれかがインストールされている場合、互換性のために古い単一プロセスアーキテクチャが引き続き使用され、 &lt;code&gt;Large-Allocation&lt;/code&gt; ヘッダーを処理できません。</target>
        </trans-unit>
        <trans-unit id="cea7ce89d775de0cacc4bf3ee3434d91b180561e" translate="yes" xml:space="preserve">
          <source>Firefox has not, and &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt;will not implement &lt;code&gt;X-XSS-Protection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Firefoxは&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt; &lt;code&gt;X-XSS-Protection&lt;/code&gt; を&lt;/a&gt;実装しておらず、今後も実装しません</target>
        </trans-unit>
        <trans-unit id="6ce4010ab4d918ae6e0eb7de27062f406a172591" translate="yes" xml:space="preserve">
          <source>Firefox once used &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="translated">Firefoxはかつて &lt;code&gt;ISO-8859-1&lt;/code&gt; を使用していましたが、他のブラウザと同等であり、&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;バグ1419658で&lt;/a&gt;説明されている潜在的な問題を回避するために、 &lt;code&gt;utf-8&lt;/code&gt; に変更されました。</target>
        </trans-unit>
        <trans-unit id="74fa353bc27c77608b28b6a494fb71634a8d1229" translate="yes" xml:space="preserve">
          <source>Firefox user agent string reference</source>
          <target state="translated">ファイアフォックスユーザーエージェント文字列参照</target>
        </trans-unit>
        <trans-unit id="824138edb7e10e6cc870e036060b42fe43828628" translate="yes" xml:space="preserve">
          <source>Firefox's console displays messages in its console when requests fail due to CORS. Part of the error text is a &quot;reason&quot; message that provides added insight into what went wrong. The reason messages are listed below; click the message to open an article explaining the error in more detail and offering possible solutions.</source>
          <target state="translated">Firefox のコンソールには、CORS が原因でリクエストが失敗したときにメッセージが表示されます。エラーテキストの一部は「理由」メッセージで、何が間違っていたのかを知ることができます。メッセージをクリックすると、エラーの詳細と可能な解決策を説明する記事が開きます。</target>
        </trans-unit>
        <trans-unit id="7d1c6e60d05a2c5211575867279c806da9425465" translate="yes" xml:space="preserve">
          <source>Firefox, Chrome and Safari do not support multiple origins in the Access-Control-Allow-Origin header.</source>
          <target state="translated">Firefox、Chrome、Safariでは、Access-Control-Allow-Originヘッダの複数の起源をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="be168c2fee1a2d9fa42cc62fef4298c4cbcefbf2" translate="yes" xml:space="preserve">
          <source>Firefox/xyz</source>
          <target state="translated">Firefox/xyz</target>
        </trans-unit>
        <trans-unit id="f614dfafdbd42e06d5c689e2cc52f2820578b824" translate="yes" xml:space="preserve">
          <source>Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;bug 1309358&lt;/a&gt;</source>
          <target state="translated">Firefox：&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;バグ1309358&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0200dffc7bdc64d4a349f323b1653382469567" translate="yes" xml:space="preserve">
          <source>Fires a &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt; を発生させます。</target>
        </trans-unit>
        <trans-unit id="b748324a443374f003fb0c40ffc43547df0d368f" translate="yes" xml:space="preserve">
          <source>First you need to extract the public key information from your certificate or key file and encode them using Base64.</source>
          <target state="translated">まず、証明書や鍵ファイルから公開鍵情報を抽出し、Base64でエンコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="72a34e1cd654a785a78eeb2f1af6246aef47a923" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request that includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">まず、リクエスト。プリフライトリクエストは、&lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;の3つのプリフライトリクエストヘッダーの組み合わせを含む&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;リクエストです。</target>
        </trans-unit>
        <trans-unit id="c56777de18c704b8472efc7f29607549036e406b" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request which includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, such as:</source>
          <target state="translated">まず、リクエスト。プリフライト要求は、次のような3つのプリフライト要求ヘッダー&lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; の&lt;/a&gt;いくつかの組み合わせを含む&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;要求です。</target>
        </trans-unit>
        <trans-unit id="1856a70ba04296bbf62c2e423de0fbdcfb0f5adf" translate="yes" xml:space="preserve">
          <source>Flow of an HTTP session</source>
          <target state="translated">HTTPセッションの流れ</target>
        </trans-unit>
        <trans-unit id="bcbad51a46a03dbd80a644d3f941e3c1172162b3" translate="yes" xml:space="preserve">
          <source>Focus Version (Rendering Engine)</source>
          <target state="translated">フォーカスバージョン(レンダリングエンジン</target>
        </trans-unit>
        <trans-unit id="56c6a4ca5cb7ee3279f46162d43efe44a37848d9" translate="yes" xml:space="preserve">
          <source>Focus for Android</source>
          <target state="translated">Android用フォーカス</target>
        </trans-unit>
        <trans-unit id="9c96a14d8cf5e47753d46702539d3958d06bb67a" translate="yes" xml:space="preserve">
          <source>Focus for iOS</source>
          <target state="translated">iOS用フォーカス</target>
        </trans-unit>
        <trans-unit id="aa5bdfcda9154f616d3599ff8019fe359c3f4231" translate="yes" xml:space="preserve">
          <source>Followed by a second connection and request to fetch the image (followed by a response to that request):</source>
          <target state="translated">その後、2回目の接続と画像の取得要求があります(その後、その要求に対する応答があります)。</target>
        </trans-unit>
        <trans-unit id="453b3d513097bbb5dad0b729903f4324d053ad1f" translate="yes" xml:space="preserve">
          <source>Font/typeface data. Common examples include &lt;code&gt;font/woff&lt;/code&gt;, &lt;code&gt;font/ttf&lt;/code&gt;, and &lt;code&gt;font/otf&lt;/code&gt;.</source>
          <target state="translated">フォント/書体データ。一般的な例には、 &lt;code&gt;font/woff&lt;/code&gt; 、 &lt;code&gt;font/ttf&lt;/code&gt; 、および &lt;code&gt;font/otf&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="ce1d332ceb92dcde1fcd283f80c52096a5c624f8" translate="yes" xml:space="preserve">
          <source>Footnote 1</source>
          <target state="translated">脚注1</target>
        </trans-unit>
        <trans-unit id="a2e8427dcb2cd9ff2779aa2b38c7e477133f780c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, to update a cached entity that has an associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;メソッド、関連付けられているキャッシュされたエンティティ更新する&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a4b7f7de1f1cba719e4bebb16b0fc5cf663d900" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt; (Range Not Satisfiable) response is returned.</source>
          <target state="translated">以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;と組み合わせて使用する方法、&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダ、それは要求された新しい範囲が以前のものよりも、同じリソースから来ていることを保証することができます。一致しない場合は、&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt;（Range Not Satisfiable）応答が返されます。</target>
        </trans-unit>
        <trans-unit id="523ad4bead51d0b08a4fff5dbbe8221c7a8666b5" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with an &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;(Range Not Satisfiable) response is returned.</source>
          <target state="translated">以下のために&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;と組み合わせて使用する方法、&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダ、それは要求された新しい範囲が以前のものよりも、同じリソースから来ていることを保証することができます。一致しない場合は、&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt;（Range Not Satisfiable）応答が返されます。</target>
        </trans-unit>
        <trans-unit id="01925d81b53df8220be1ab3b85de00880bc40ace" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt; attributes&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">以下のため&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;要素や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; 属性&lt;/a&gt;、所有者のドキュメントの参照元のポリシーが使用されています。</target>
        </trans-unit>
        <trans-unit id="65a5e026c5b9f4e6d8669a37e565175368c88cdf" translate="yes" xml:space="preserve">
          <source>For DAV properties, the name of the property is also the same as the
   name of the XML element that contains its value.  In the section
   below, the final line of each section gives the element type
   declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).

   A protected property is one that cannot be changed with a PROPPATCH
   request.  There may be other requests that would result in a change
   to a protected property (as when a LOCK request affects the value of
   DAV:lockdiscovery).  Note that a given property could be protected on
   one type of resource, but not protected on another type of resource.

   A computed property is one with a value defined in terms of a
   computation (based on the content and other properties of that
   resource, or even of some other resource).  A computed property is
   always a protected property.

   COPY and MOVE behavior refers to local COPY and MOVE operations.

   For properties defined based on HTTP GET response headers (DAV:get*),
   the header value could include LWS as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;.  Server implementors SHOULD strip LWS from these values before
   using as WebDAV property values.</source>
          <target state="translated">DAVプロパティの場合、プロパティの名前は、その値を含むXML要素の名前と同じです。以下のセクションでは、各セクションの最後の行に、[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]。 「Value」フィールドが存在する場合は、BNFを使用してXMLエレメントの許容されるコンテンツに対する追加の制限を指定します（つまり、PCDATAエレメントの値をさらに制限するため）。保護されたプロパティは、PROPPATCHリクエストで変更できないプロパティです。 （LOCK要求がDAV：lockdiscoveryの値に影響を与える場合のように）保護されたプロパティを変更する結果となる他の要求がある可能性があります。特定のプロパティは、あるタイプのリソースでは保護されているが、別のタイプのリソースでは保護されていない可能性があることに注意してください。計算されたプロパティとは、計算によって定義された値を持つプロパティです（そのリソースのコンテンツや他のプロパティ、または他のリソースのプロパティに基づく）。計算されたプロパティは常に保護されたプロパティです。COPYおよびMOVEの動作は、ローカルのCOPYおよびMOVE操作を指します。 HTTP GET応答ヘッダー（DAV：get *）に基づいて定義されたプロパティの場合、ヘッダー値には、[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、&lt;a href=&quot;#section-4.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。サーバーの実装者は、WebDAVプロパティ値として使用する前に、これらの値からLWSを取り除く必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="7578507963f5f6a92a4ce0b4b4477e8db695266c" translate="yes" xml:space="preserve">
          <source>For Nginx, the command to set up this header is:</source>
          <target state="translated">Nginxの場合、このヘッダを設定するコマンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1714ef110b1269230d283611695b8af7bcd041c3" translate="yes" xml:space="preserve">
          <source>For an example of a custom 404 page, see &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN's 404 page&lt;/a&gt;.</source>
          <target state="translated">カスタム404ページの例については、&lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDNの404ページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1da755a1735ea720fcbdf190446a592e95aff7a8" translate="yes" xml:space="preserve">
          <source>For authoring to commence, a client needs to discover the
   capabilities and locations of the available Collections.  Service
   Documents are designed to support this discovery process.

   How Service Documents are discovered is not defined in this
   specification. 

   Service Documents are identified with the &quot;application/atomsvc+xml&quot;
   media type (see &lt;a href=&quot;#section-16.2&quot;&gt;Section 16.2&lt;/a&gt;).</source>
          <target state="translated">オーサリングを開始するには、クライアントは使用可能なコレクションの機能と場所を発見する必要があります。サービスドキュメントは、この検出プロセスをサポートするように設計されています。サービスドキュメントの検出方法は、この仕様では定義されていません。サービスドキュメントは、「application / atomsvc​​ + xml」メディアタイプで識別されます（&lt;a href=&quot;#section-16.2&quot;&gt;セクション16.2を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="074190f3eb43757a18a5c3d3ad9b48a9217873dc" translate="yes" xml:space="preserve">
          <source>For clients that don't implement cookie prefixes, you cannot count on these additional assurances, and prefixed cookies will always be accepted.</source>
          <target state="translated">クッキーのプレフィックスを実装していないクライアントでは、これらの追加の保証を期待することはできず、プレフィックス付きのクッキーは常に受け入れられます。</target>
        </trans-unit>
        <trans-unit id="5dc6e3c719ad40719899f3731172d36e94077ff2" translate="yes" xml:space="preserve">
          <source>For compression, end-to-end compression is where the largest performance improvements of Web sites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</source>
          <target state="translated">圧縮については、エンドツーエンド圧縮が、Web サイトの最大のパフォーマンス向上を実現します。エンドツーエンド圧縮とは、メッセージの本文の圧縮を指し、サーバーによって行われ、それがクライアントに到達するまで変更されることはありません。中間ノードがどのようなものであれ、本文はそのまま残されます。</target>
        </trans-unit>
        <trans-unit id="f0f988728409b019db831b62218300a55ac3d394" translate="yes" xml:space="preserve">
          <source>For convenience, this protocol can be referred to as the &quot;Atom
   Protocol&quot; or &quot;AtomPub&quot;.  The following terminology is used by this
   specification:

   o  URI - A Uniform Resource Identifier as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].  In
      this specification, the phrase &quot;the URI of a document&quot; is
      shorthand for &quot;a URI which, when dereferenced, is expected to
      produce that document as a representation&quot;.

   o  IRI - An Internationalized Resource Identifier as defined in
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;].  Before an IRI found in a document is used by HTTP, the
      IRI is first converted to a URI.  See &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;.

   o  Resource - A network-accessible data object or service identified
      by an IRI, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  See [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;] for further
      discussion on Resources.

   o  relation (or &quot;relation of&quot;) - Refers to the &quot;rel&quot; attribute value
      of an atom:link element.

   o  Representation - An entity included with a request or response as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   o  Collection - A Resource that contains a set of Member Resources.
      Collections are represented as Atom Feeds.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;. 

   o  Member (or Member Resource) - A Resource whose IRI is listed in a
      Collection by an atom:link element with a relation of &quot;edit&quot; or
      &quot;edit-media&quot;.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;.  The protocol defines two kinds of
      Members:

      *  Entry Resource - Members of a Collection that are represented
         as Atom Entry Documents, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

      *  Media Resource - Members of a Collection that have
         representations other than Atom Entry Documents.

   o  Media Link Entry - An Entry Resource that contains metadata about
      a Media Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.

   o  Workspace - A named group of Collections.  See &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   o  Service Document - A document that describes the location and
      capabilities of one or more Collections, grouped into Workspaces.
      See &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   o  Category Document - A document that describes the categories
      allowed in a Collection.  See &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">便宜上、このプロトコルは「Atomプロトコル」または「AtomPub」と呼ぶことができます。この仕様では、次の用語が使用されています。o URI-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]で定義されているUniform Resource Identifier 。この仕様では、「ドキュメントのURI」というフレーズは、「逆参照されたときに、そのドキュメントを表現として生成することが期待されるURI」の省略形です。 o &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;IRI-&lt;/a&gt; [ RFC3987 ]で定義されている国際化されたリソース識別子。ドキュメントで見つかったIRIがHTTPによって使用される前に、IRIは最初にURIに変換されます。&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1を&lt;/a&gt;参照してください。 oリソース-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されている、IRIによって識別されるネットワークアクセス可能なデータオブジェクトまたはサービス。見る [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;&lt;/a&gt;リソースの詳細については、REC-webarch ]をご覧ください。 o関係（または「関係」）-atom：link要素の「rel」属性値を参照します。 o表現-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]で定義されている要求または応答に含まれるエンティティ。 oコレクション-メンバーリソースのセットを含むリソース。コレクションはAtomフィードとして表されます。&lt;a href=&quot;#section-9&quot;&gt;セクション9を&lt;/a&gt;参照してください。 oメンバー（またはメンバーリソース）-IRIが「編集」または「編集メディア」の関係を持つatom：link要素によってコレクションにリストされているリソース。&lt;a href=&quot;#section-9.1&quot;&gt;セクション9.1を&lt;/a&gt;参照してください。プロトコルは2種類のメンバーを定義します。*エントリーリソース-Atomエントリードキュメントとして表されるコレクションのメンバー、[&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]。*メディアリソース-Atomエントリードキュメント以外の表現を持つコレクションのメンバー。oメディアリンクエントリ-メディアリソースに関するメタデータを含むエントリリソース。&lt;a href=&quot;#section-9.6&quot;&gt;セクション9.6を&lt;/a&gt;参照してください。oワークスペース-コレクションの名前付きグループ。&lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1を&lt;/a&gt;参照してください。oサービスドキュメント-ワークスペースにグループ化された、1つ以上のコレクションの場所と機能を説明するドキュメント。&lt;a href=&quot;#section-8&quot;&gt;セクション8を&lt;/a&gt;参照してください。oカテゴリドキュメント-コレクションで許可されるカテゴリを説明するドキュメント。&lt;a href=&quot;#section-7&quot;&gt;セクション7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="eef31d3a1350a01572c86bb4dfa3d00e0c975e26" translate="yes" xml:space="preserve">
          <source>For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature.</source>
          <target state="translated">ポリシーで制御された各機能について、ブラウザはその機能が有効になっているオリジンのリストを保持します(これは許可リストとして知られています)。機能にポリシーを指定しない場合は、デフォルトの許可リストが使用されます。デフォルトの許可リストは、各機能に固有のものです。</target>
        </trans-unit>
        <trans-unit id="bbfd900d40adcb99301092c21f8010e24f933f46" translate="yes" xml:space="preserve">
          <source>For example when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">たとえば、MDNを編集する場合、現在のWikiコンテンツがハッシュされ、応答の &lt;code&gt;Etag&lt;/code&gt; に入れられます。</target>
        </trans-unit>
        <trans-unit id="9445e49e152cffd5d9a04a8f80bbd49732b55bc8" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;a script on Browserleaks&lt;/a&gt; highlights what Firefox reveals when queried by a simple script running on the site (you can find the code in &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt;).</source>
          <target state="translated">たとえば、&lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;Browserleaksの&lt;/a&gt;スクリプトは、サイトで実行されている単純なスクリプトによって照会されたときにFirefoxが何を明らかにするかを強調表示します（&lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#moreで&lt;/a&gt;コードを見つけることができます）。</target>
        </trans-unit>
        <trans-unit id="8282891590c0b08790018d81b4f472f2cf7db144" translate="yes" xml:space="preserve">
          <source>For example, a document at &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;https://example.com/page.html&lt;/code&gt; //example.com/page.htmlのドキュメントは、リファラー &lt;code&gt;https://example.com/&lt;/code&gt; を送信します。</target>
        </trans-unit>
        <trans-unit id="64b899bc979c38aad573a87de3d6fa69123c484f" translate="yes" xml:space="preserve">
          <source>For example, allow all browsing contexts within this iframe to use fullscreen:</source>
          <target state="translated">例えば、このiframe内のすべてのブラウジングコンテキストがフルスクリーンを使用することを許可します。</target>
        </trans-unit>
        <trans-unit id="eac94e3ce15d79355451ea902d576dd478ad2b17" translate="yes" xml:space="preserve">
          <source>For example, by default all of the following result in a separate request to the origin and a separate cache entry: &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt;. This is true even though the origin server will probably respond with &amp;mdash; and store &amp;mdash; the same resource for all requests (a gzip)!</source>
          <target state="translated">たとえば、デフォルトでは、次のすべてがオリジンへの個別のリクエストと個別のキャッシュエントリになります： &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt; 、 &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt; 、 &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt; 。これは、オリジンサーバーがすべてのリクエストに対して同じリソース（gzip）で応答し、保存する可能性がある場合でも当てはまります。</target>
        </trans-unit>
        <trans-unit id="5100e86095301001726a9dd07582fc20d58ee08d" translate="yes" xml:space="preserve">
          <source>For example, for any MIME type whose main type is &lt;code&gt;text&lt;/code&gt;, the optional &lt;code&gt;charset&lt;/code&gt; parameter can be used to specify the character set used for the characters in the data. If no &lt;code&gt;charset&lt;/code&gt; is specified, the default is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt; (&lt;code&gt;US-ASCII&lt;/code&gt;) unless overridden by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent's&lt;/a&gt; settings. To specify a UTF-8 text file, the MIME type &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; is used.</source>
          <target state="translated">たとえば、メインタイプが &lt;code&gt;text&lt;/code&gt; であるMIMEタイプの場合、オプションの &lt;code&gt;charset&lt;/code&gt; パラメーターを使用して、データ内の文字に使用される文字セットを指定できます。何の場合は &lt;code&gt;charset&lt;/code&gt; 指定されていない、デフォルトは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt;（ &lt;code&gt;US-ASCII&lt;/code&gt; で上書きしない限り）&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェントの&lt;/a&gt;設定。 UTF-8テキストファイルを指定するには、MIMEタイプ &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="08b715bba658a875ffba997c7f848a3f6b1c1f7c" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers).</source>
          <target state="translated">たとえば、「 &lt;code&gt;Content-Language: de-DE&lt;/code&gt; 」が設定されている場合、ドキュメントはドイツ語話者を対象としていることを示します（ただし、ドキュメントがドイツ語で書かれていることを示すものではありません。たとえば、ドイツ語を話す人のための語学コースの一部としての英語）。</target>
        </trans-unit>
        <trans-unit id="7c8d24654bcc03695c4c0562fb4fd4f65c41f354" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers. If you want to indicate which language the document is written in, use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;&lt;code&gt;lang&lt;/code&gt; attribute&lt;/a&gt; instead).</source>
          <target state="translated">たとえば、「 &lt;code&gt;Content-Language: de-DE&lt;/code&gt; 」が設定されている場合、そのドキュメントはドイツ語を話す人を対象としていることを示します（ただし、ドキュメントがドイツ語で書かれていることを示すものではありません。たとえば、ドイツ語を話す人のための言語コースの一部としての英語。ドキュメントがどの言語で書かれているかを示したい場合は、代わりに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt; &lt;code&gt;lang&lt;/code&gt; 属性を&lt;/a&gt;使用してください）。</target>
        </trans-unit>
        <trans-unit id="931c15cbf1cb0d096c2f7f3977e96a703c6efded" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are available on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; が設定されている場合、Cookieは &lt;code&gt;developer.mozilla.org&lt;/code&gt; などのサブドメインで利用できます。</target>
        </trans-unit>
        <trans-unit id="6412826a466b2db302aa194f4e3daf55e5d61efd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are included on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; が設定されている場合、cookieは &lt;code&gt;developer.mozilla.org&lt;/code&gt; のようなサブドメインに含まれます。</target>
        </trans-unit>
        <trans-unit id="f88d60c9d2f02ed6a1a1bf95ce9b557bca2dbed6" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths match:</source>
          <target state="translated">たとえば、 &lt;code&gt;Path=/docs&lt;/code&gt; が設定されている場合、これらのパスは一致します。</target>
        </trans-unit>
        <trans-unit id="8c0625b9fc57344582bbde2ab4696157ad3f42eb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths will match:</source>
          <target state="translated">たとえば、 &lt;code&gt;Path=/docs&lt;/code&gt; が設定されている場合、これらのパスは一致します。</target>
        </trans-unit>
        <trans-unit id="fa9700b85e0e01538fcca2eb77f677f69026288f" translate="yes" xml:space="preserve">
          <source>For example, if the page &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; were requested, and the HTTP response is &quot;301 Moved Permanently&quot;, &quot;307 Temporary Redirect&quot;, or &quot;308 Permanent Redirect&quot; with a &lt;code&gt;Location&lt;/code&gt; of &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt;, the CORS request will fail in this manner.</source>
          <target state="translated">たとえば、ページ &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; がリクエストされ、HTTP応答が「301 Moved Permanently」、「307 Temporary Redirect」、または「308 Permanent Redirect」で、 &lt;code&gt;Location&lt;/code&gt; が &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt; 場合、CORSリクエストはこの方法で失敗します。</target>
        </trans-unit>
        <trans-unit id="7b87738a4c88c7a7b6a1a09e51a26bf1a734d5d4" translate="yes" xml:space="preserve">
          <source>For example, if the response includes:</source>
          <target state="translated">例えば、レスポンスに含まれている場合。</target>
        </trans-unit>
        <trans-unit id="66e0a70fb691c18fbdd0bd050b60e272a1fe413f" translate="yes" xml:space="preserve">
          <source>For example, in Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">たとえば、Apacheでは、次のような行をサーバーの構成に追加します（適切な &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 、または &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; セクション内）。構成は、典型的に見出される &lt;code&gt;.conf&lt;/code&gt; ファイル（ &lt;code&gt;httpd.conf&lt;/code&gt; ファイルと &lt;code&gt;apache.conf&lt;/code&gt; これらのための一般的な名称である）、又はで &lt;code&gt;.htaccess&lt;/code&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="619f3c064cc0ce3bc00c710809c1ce33e001a212" translate="yes" xml:space="preserve">
          <source>For example, sending the result of a form:</source>
          <target state="translated">例えば、フォームの結果を送信すること。</target>
        </trans-unit>
        <trans-unit id="142fdc15f7a89b9c24c2befb228055d091883a52" translate="yes" xml:space="preserve">
          <source>For example, suppose web content at &lt;code&gt;https://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;https://bar.other&lt;/code&gt;. Code of this sort might be used in JavaScript deployed on &lt;code&gt;foo.example&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;https://foo.example&lt;/code&gt; のWebコンテンツがドメイン &lt;code&gt;https://bar.other&lt;/code&gt; のコンテンツを呼び出したいとします。この種のコードは、 &lt;code&gt;foo.example&lt;/code&gt; にデプロイされたJavaScriptで使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b184b5ed58eb6819039876c32250bc43b4bad555" translate="yes" xml:space="preserve">
          <source>For example, suppose web content on domain &lt;code&gt;http://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;http://bar.other&lt;/code&gt;. Code of this sort might be used within JavaScript deployed on foo.example:</source>
          <target state="translated">たとえば、ドメインに、仮定するWebコンテンツ &lt;code&gt;http://foo.example&lt;/code&gt; ドメイン上の呼び出しコンテンツへの希望 &lt;code&gt;http://bar.other&lt;/code&gt; 。この種のコードは、foo.exampleにデプロイされたJavaScript内で使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="ac8d0edbbe6f6a992074ea6f9eb0145ef93102b7" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; to tunnel the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; continues to proxy the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; stream to and from the client.</source>
          <target state="translated">たとえば、 &lt;code&gt;CONNECT&lt;/code&gt; メソッドを使用して、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;）を使用するWebサイトにアクセスできます。クライアントは、HTTP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシサーバー&lt;/a&gt;に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt;接続を目的の宛先にトンネリングするように要求します。次に、サーバーはクライアントに代わって接続を確立します。サーバーによって接続が確立されると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシサーバー&lt;/a&gt;は引き続き&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt;ストリームをクライアントとの間でプロキシします。</target>
        </trans-unit>
        <trans-unit id="d20e4a9531f0f953723ad2bce29ba67c92820b20" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</source>
          <target state="translated">たとえば、 &lt;code&gt;CONNECT&lt;/code&gt; メソッドを使用して、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;）を使用するWebサイトにアクセスできます。クライアントは、HTTPプロキシサーバーにTCP接続を目的の宛先にトンネリングするように要求します。次に、サーバーはクライアントに代わって接続を行います。サーバーによって接続が確立されると、Proxyサーバーは引き続きクライアントとの間でTCPストリームをプロキシします。</target>
        </trans-unit>
        <trans-unit id="71916a917e381d9f4baa72eb7d0f481b27298684" translate="yes" xml:space="preserve">
          <source>For example, the following are equivalent:</source>
          <target state="translated">例えば、以下のようなものが該当します。</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">例えば、以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="e32905633351c047f12f27629c2b7dbcbd3258eb" translate="yes" xml:space="preserve">
          <source>For example, the server may reject a request if its &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; is too large.</source>
          <target state="translated">たとえば、&lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;が大きすぎる場合、サーバーはリクエストを拒否することがあります。</target>
        </trans-unit>
        <trans-unit id="d63752de4fee204887b96a1631e06acc76c5193f" translate="yes" xml:space="preserve">
          <source>For example, this blocks the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; from using the camera and microphone:</source>
          <target state="translated">たとえば、これは &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; がカメラとマイクを使用できないようにします。</target>
        </trans-unit>
        <trans-unit id="667503768ab9f00b3c857611676b705bf222dc50" translate="yes" xml:space="preserve">
          <source>For example, to allow a site at https://amazing.site to access the resource using CORS, the header should be:</source>
          <target state="translated">たとえば、https://amazing.site のサイトが CORS を使用してリソースにアクセスできるようにするには、ヘッダーは次のようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="dc1f722176891e42941f464101332b2ba20f6189" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;http://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">たとえば、オリジン &lt;code&gt;http://mozilla.org&lt;/code&gt; のコードがリソースにアクセスできるようにするには、次のように指定できます。</target>
        </trans-unit>
        <trans-unit id="74f296365850776cc0a36afe6f2ae5336b6c5ffa" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;https://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">たとえば、オリジン &lt;code&gt;https://mozilla.org&lt;/code&gt; のコードがリソースにアクセスできるようにするには、次のように指定できます。</target>
        </trans-unit>
        <trans-unit id="8c8dcd604f2bec51e5cc439af7d8b146ce60c0ce" translate="yes" xml:space="preserve">
          <source>For example, to block all content from using the Geolocation API across your site:</source>
          <target state="translated">たとえば、サイト全体で Geolocation API を使用するすべてのコンテンツをブロックするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="b10aebfe3ed1f1d241d8fb042922d4cfda18c68c" translate="yes" xml:space="preserve">
          <source>For example, when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">たとえば、MDNを編集する場合、現在のWikiコンテンツはハッシュ化され、応答の &lt;code&gt;Etag&lt;/code&gt; に配置されます。</target>
        </trans-unit>
        <trans-unit id="4c2c26aca152b85331257eaf1e9e80e1fb0d82dc" translate="yes" xml:space="preserve">
          <source>For example, your company was renamed, but you want existing links or bookmarks to still find you under the new name.</source>
          <target state="translated">例えば、あなたの会社は名前が変更されましたが、既存のリンクやブックマークが新しい名前の下であなたを見つけて欲しいとします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="de2cc7afb113653239fadefd58531368ab6e0fde" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt; (the definition of how browsers should interpret media types and figure out what to do with content that doesn't have a valid one) allows JavaScript to be served using any MIME type that essentially matches any of the following:</source>
          <target state="translated">歴史的な理由から、&lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIMEスニッフィング標準&lt;/a&gt;（ブラウザがメディアタイプを解釈し、有効なメディアタイプがないコンテンツをどう処理するかを理解する方法の定義）では、JavaScriptは、基本的にいずれかに一致する任意のMIMEタイプを使用して提供できます。以下：</target>
        </trans-unit>
        <trans-unit id="4cc7ca2973a124b54e9384bba7dd4138b39eb2ca" translate="yes" xml:space="preserve">
          <source>For images, &lt;code&gt;gif&lt;/code&gt; or &lt;code&gt;png&lt;/code&gt; are using loss-less compression.</source>
          <target state="translated">画像の場合、 &lt;code&gt;gif&lt;/code&gt; または &lt;code&gt;png&lt;/code&gt; はロスレス圧縮を使用しています。</target>
        </trans-unit>
        <trans-unit id="f96d0e055aab7967e098e229f35a70f7d0cf4499" translate="yes" xml:space="preserve">
          <source>For inline styles or styles created from APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;HTMLElement.style&lt;/code&gt;&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">インラインスタイルまたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;HTMLElement.style&lt;/code&gt; &lt;/a&gt;などのAPIから作成されたスタイルの場合、所有者ドキュメントの参照ポリシーが使用されます。</target>
        </trans-unit>
        <trans-unit id="84bf50840f620c842f8d504aeebea80f2ae78a0a" translate="yes" xml:space="preserve">
          <source>For locking mechanisms, it is the opposite: Web developers need to issue a request with the proper headers, while webmasters can mostly rely on the application to carry out the checks for them.</source>
          <target state="translated">ロック機構については、それは逆です。ウェブ開発者は適切なヘッダでリクエストを発行する必要がありますが、ウェブマスターはそのためのチェックをアプリケーションに頼ることができます。</target>
        </trans-unit>
        <trans-unit id="05bc2f18a1040cbebb023b0b22da7d3057050814" translate="yes" xml:space="preserve">
          <source>For more details on Firefox and Gecko based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">FirefoxおよびGeckoベースのユーザーエージェント文字列の詳細については、&lt;a href=&quot;user-agent/firefox&quot;&gt;Firefoxユーザーエージェント文字列リファレンスを&lt;/a&gt;ご覧ください。Firefox自体のUA文字列は、4つのコンポーネントに分かれています。</target>
        </trans-unit>
        <trans-unit id="1512d2a0f3572c16865118ba125042228226dfbe" translate="yes" xml:space="preserve">
          <source>For more details on autoplay and autoplay blocking, see the article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;Autoplay guide for media and Web Audio APIs&lt;/a&gt;.</source>
          <target state="translated">自動再生と自動再生のブロックの詳細については&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;、メディアおよびWebオーディオAPIの&lt;/a&gt;自動再生ガイドの記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="d7d24847af6c0b28f664c1b1ecd25eca36f5dc16" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Using Feature Policy&lt;/a&gt;.</source>
          <target state="translated">詳細については、「&lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;機能ポリシーの使用&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="6f2fd29856862ed0ab79e6861cc4858f4155a7dc" translate="yes" xml:space="preserve">
          <source>For more details, see also the &lt;a href=&quot;#Freshness&quot;&gt;Freshness&lt;/a&gt; section below.</source>
          <target state="translated">詳細については、以下の「&lt;a href=&quot;#Freshness&quot;&gt;鮮度」&lt;/a&gt;セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="5761c54fb5552b444dde1792f6afdb1a5c918baa" translate="yes" xml:space="preserve">
          <source>For more information about cookie prefixes and the current state of browser support, see the &lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;Prefixes section of the Set-Cookie reference article&lt;/a&gt;.</source>
          <target state="translated">Cookieプレフィックスとブラウザサポートの現在の状態の詳細について&lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;は、Set-Cookieリファレンス記事の「プレフィックス」セクションを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72a6b38e5e421526b3d5933f3b867e718bd90436" translate="yes" xml:space="preserve">
          <source>For more information, see also this article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../csp&quot;&gt;コンテンツセキュリティポリシー（CSP）に関する&lt;/a&gt;この記事も参照してください。</target>
        </trans-unit>
        <trans-unit id="07a2c7640b2fa8de34fac3055d8b39541b74752f" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../cookies&quot;&gt;guide on HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../cookies&quot;&gt;HTTPCookieに関するガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3aa6b680bc6518edc5c36b2eb482864b073f5d2" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP公開キーのピン留め&lt;/a&gt;に関する記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6388d0122d4c6699e1cf73b26f4fab54e1e4ece" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header reference page and the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">詳細については、&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;ヘッダーのリファレンスページと&lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP公開キーのピン留め&lt;/a&gt;に関する記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="16d858e940de2d5add12c93eacce99796fbd8dc3" translate="yes" xml:space="preserve">
          <source>For more information, see the guide on &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../cookies&quot;&gt;HTTP Cookie&lt;/a&gt;に関するガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="6025b5f65ce2bedee9e205665e9c4e24e2e5b2f7" translate="yes" xml:space="preserve">
          <source>For more information, see the introductory article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;../csp&quot;&gt;コンテンツセキュリティポリシー（CSP）&lt;/a&gt;の紹介記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="abf003bb7d49f08a37fe6d4505f868da1702a5d5" translate="yes" xml:space="preserve">
          <source>For more information, see the main &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;Feature Policy&lt;/a&gt; article.</source>
          <target state="translated">詳細については、メインの&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;機能ポリシー&lt;/a&gt;に関する記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="0e6566bd07adb3ff65425532a199412494bb4520" translate="yes" xml:space="preserve">
          <source>For more on Firefox- and Gecko-based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox is broken down into 4 components:</source>
          <target state="translated">&lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox&lt;/a&gt;ベースおよびGeckoベースのユーザーエージェント文字列の詳細については、Firefoxユーザーエージェント文字列リファレンスを参照してください。FirefoxのUA文字列は、次の4つのコンポーネントに分類されます。</target>
        </trans-unit>
        <trans-unit id="2c13a01882beedd60ef040f694851d73933cf613" translate="yes" xml:space="preserve">
          <source>For more prevention tips, see the &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;.</source>
          <target state="translated">防止のヒントについては、&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF防止チートシートを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b991665d6c852df1848b14e1c2237629d3e471a4" translate="yes" xml:space="preserve">
          <source>For more, see &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;this Wikipedia section&lt;/a&gt; and consult state laws for the latest and most accurate information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;このウィキペディアのセクション&lt;/a&gt;を参照し、最新かつ最も正確な情報について州法を参照してください。</target>
        </trans-unit>
        <trans-unit id="16bc316a5e9428e01ce42d164953682ad4eeadaf" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often the header boundary is prepended by two dashes in the body and the final boundary also have a two dashes appended to it.</source>
          <target state="translated">マルチパートエンティティの場合、 &lt;code&gt;boundary&lt;/code&gt; ディレクティブが必要です。これは、電子メールゲートウェイを介して非常に堅牢であることがわかっている一連の文字の1〜70文字で構成され、空白で終わっていません。メッセージの複数の部分の境界をカプセル化するために使用されます。多くの場合、ヘッダー境界の前に本文の2つのダッシュが追加され、最後の境界にも2つのダッシュが追加されます。</target>
        </trans-unit>
        <trans-unit id="7c3aed89e6dab97831be498c22ad6502ef3a5cd6" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often, the header boundary is prepended with two dashes and the final boundary has two dashes appended at the end.</source>
          <target state="translated">マルチパートエンティティの場合、 &lt;code&gt;boundary&lt;/code&gt; ディレクティブが必要です。これは、電子メールゲートウェイを介して非常に堅牢であることがわかっており、空白で終わらないことがわかっている文字セットの1〜70文字で構成されます。これは、メッセージの複数の部分の境界をカプセル化するために使用されます。多くの場合、ヘッダー境界には2つのダッシュが付加され、最後の境界には最後に2つのダッシュが付加されます。</target>
        </trans-unit>
        <trans-unit id="093b1094cde6e7f4f4d8f8b971af7a8990963019" translate="yes" xml:space="preserve">
          <source>For new content, you can start developing with a policy that disables all the features. This approach ensures that none of the functionality is introduced. When applying a policy to existing content, testing is likely required to verify it continues to work as expected. This is especially important for embedded or third-party content that you do not control.</source>
          <target state="translated">新しいコンテンツについては、すべての機能を無効にするポリシーで開発を開始することができます。このアプローチでは、どの機能も導入されないことが保証されます。既存のコンテンツにポリシーを適用する場合は、期待通りに動作するかどうかを確認するためのテストが必要になります。これは、自分で管理していない埋め込みコンテンツやサードパーティ製のコンテンツの場合に特に重要です。</target>
        </trans-unit>
        <trans-unit id="2f39ad9de038e309432fa2abc7e02992cadbd96a" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a .htpasswd file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">nginxの場合、保護する場所と、パスワードで保護された領域に名前を提供する &lt;code&gt;auth_basic&lt;/code&gt; ディレクティブを指定する必要があります。 &lt;code&gt;auth_basic_user_file&lt;/code&gt; のディレクティブは、すぐ上のApacheの例のように、暗号化されたユーザーの資格情報を含むの.htpasswdファイルを指します。</target>
        </trans-unit>
        <trans-unit id="b60310977b1322aae7188c84f1d2bec064596b5e" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a &lt;code&gt;.htpasswd&lt;/code&gt; file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">nginxの場合、保護する場所と、パスワードで保護された領域に名前を提供する &lt;code&gt;auth_basic&lt;/code&gt; ディレクティブを指定する必要があります。次に、 &lt;code&gt;auth_basic_user_file&lt;/code&gt; ディレクティブは、上記のApacheの例のように、暗号化されたユーザー資格情報を含む &lt;code&gt;.htpasswd&lt;/code&gt; ファイルを指します。</target>
        </trans-unit>
        <trans-unit id="70553b80e8be103814c1eb5f51fa3a904090e239" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Match&lt;/code&gt; can be used to prevent the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) response is returned.</source>
          <target state="translated">他の方法、特に&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;If-Match&lt;/code&gt; 、If-Matchを使用して、&lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;失われた更新の問題&lt;/a&gt;を防ぐことができます。ユーザーがアップロードしたいリソースの変更が、元のリソースのフェッチ以降に行われた別の変更を上書きしないかどうかを確認できます。要求を実行できない場合は、&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（前提条件の失敗）応答が返されます。</target>
        </trans-unit>
        <trans-unit id="538225086d2d3b055913158dd5b4c3b9bfc1f097" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; used with the &lt;code&gt;*&lt;/code&gt; value can be used to save a file not known to exist, guaranteeing that another upload didn't happen before, losing the data of the previous put; this problem is a variation of the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;.</source>
          <target state="translated">その他の方法については、特にために&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;If-None-Match&lt;/code&gt; 一緒に使用 &lt;code&gt;*&lt;/code&gt; 値は、前のプットのデータを失うこと、他のアップロードは前に実現しなかったことを保証する、存在することが知られていないファイルを保存するために使用することができます。この問題は、&lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;失われた更新の問題の&lt;/a&gt;バリエーションです。</target>
        </trans-unit>
        <trans-unit id="89936fcb3c720f2a1e2c92027641b334e9357ffd" translate="yes" xml:space="preserve">
          <source>For other products based on Gecko, the string can take one of two forms, where the tokens have the same meaning except those noted below:</source>
          <target state="translated">Gecko をベースにした他の製品では、文字列は 2 つの形式のうちの 1 つを取ることができ、以下に記載されているものを除いて、トークンは同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="907135173500e7b45556d497127edb70bd3fb716" translate="yes" xml:space="preserve">
          <source>For reasons of security and privacy, it is necessary to make a
   distinction between &quot;shared&quot; and &quot;non-shared&quot; caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case SHOULD be enforced by appropriate security mechanisms.
   All other caches are considered to be &quot;shared.&quot; Other sections of 

   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.</source>
          <target state="translated">セキュリティとプライバシーの理由から、「共有された」キャッシュと「非共有」キャッシュを区別する必要があります。非共有キャッシュは一人のユーザだけがアクセスできるキャッシュです。この場合のアクセス性は適切なセキュリティメカニズムによって強制されるべきである[SHOULD]。他の全てのキャッシュは「共有」されていると考えられます。この仕様の他のセクションでは、プライバシーの損失又はアクセス制御の失敗を防ぐために、共有キャッシュの操作に一定の制約を設ける。</target>
        </trans-unit>
        <trans-unit id="257548a557c142ce44b1aa876c1f52d0b2cfeb6c" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;*&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;資格情報のない&lt;/em&gt;リクエストの場合、リテラル値「*」をワイルドカードとして指定できます。この値は、任意のオリジンからのリクエストコードがリソースにアクセスすることを許可するようにブラウザに指示します。資格情報でワイルドカードを使用しようとする&lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;と、エラーが発生します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5ca72995d97f0458eaf84378300b9b55e7ea55" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;&lt;code&gt;*&lt;/code&gt;&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;資格情報のない&lt;/em&gt;リクエストの場合、リテラル値「 &lt;code&gt;*&lt;/code&gt; 」をワイルドカードとして指定できます。この値は、任意のオリジンからのコードの要求がリソースにアクセスできるようにすることをブラウザーに指示します。資格情報でワイルドカードを使用しようとする&lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;と、エラーが発生します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2a1bfce12feb1fb720a7fe1100883e79f123be1" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.</source>
          <target state="translated">セキュリティ上の理由から、ブラウザはスクリプトから開始されるクロスオリジンHTTPリクエストを制限します。たとえば、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同一生成元ポリシーに&lt;/a&gt;従います。つまり、これらのAPIを使用するWebアプリケーションは、他のオリジンからの応答に適切なCORSヘッダーが含まれていない限り、アプリケーションがロードされたのと同じオリジンからのリソースのみを要求できます。</target>
        </trans-unit>
        <trans-unit id="351e6c404b20eecdc808fd67608ccc7928ea6386" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers.</source>
          <target state="translated">セキュリティ上の理由から、ブラウザはスクリプト内から開始されたクロスオリジンHTTPリクエストを制限します。たとえば、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同じ生成元のポリシーに&lt;/a&gt;従います。つまり、これらのAPIを使用するWebアプリケーションは、他のオリジンからの応答に正しいCORSヘッダーが含まれていない限り、アプリケーションのロード元と同じオリジンからのみHTTPリソースをリクエストできます。</target>
        </trans-unit>
        <trans-unit id="ee3a9635da3f4811be8395ffd6f2c7c100ed7868" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used.</source>
          <target state="translated">特定のサブタイプのないテキストドキュメントの場合、 &lt;code&gt;text/plain&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8cb9d98048f241ce3bdc766680c13b98ba44670c" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used. Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="translated">特定のサブタイプのないテキストドキュメントの場合は、 &lt;code&gt;text/plain&lt;/code&gt; を使用する必要があります。同様に、特定のサブタイプまたは既知のサブタイプのないバイナリドキュメントの場合は、 &lt;code&gt;application/octet-stream&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="01fd2dd2707385a8305b768f33bb65eb7bcb3f6d" translate="yes" xml:space="preserve">
          <source>For the files in the application that will not change, you can usually add aggressive caching by sending the response header below. This includes static files that are served by the application such as images, CSS files and JavaScript files, for example. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; header.</source>
          <target state="translated">変更されないアプリケーション内のファイルについては、通常、以下の応答ヘッダーを送信することにより、積極的なキャッシュを追加できます。これには、画像、CSSファイル、JavaScriptファイルなど、アプリケーションによって提供される静的ファイルが含まれます。さらに、 &lt;code&gt;Expires&lt;/code&gt; ヘッダーも参照してください。</target>
        </trans-unit>
        <trans-unit id="47f9208ec82cf7fb7519a3acacb255f0ed8d2472" translate="yes" xml:space="preserve">
          <source>For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:

      - End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses MUST be stored as part of a cache entry and MUST be
        transmitted in any response formed from a cache entry.

      - Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.

   The following HTTP/1.1 headers are hop-by-hop headers:

      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade

   All other headers defined by HTTP/1.1 are end-to-end headers.

   Other hop-by-hop headers MUST be listed in a Connection header,
   (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) to be introduced into HTTP/1.1 (or later).</source>
          <target state="translated">キャッシュと非キャッシングプロキシの動作を定義する目的で、HTTPヘッダーを2つのカテゴリに分類します。-要求または応答の最終的な受信者に送信されるエンドツーエンドヘッダー。応答のエンドツーエンドヘッダーは、キャッシュエントリの一部として格納する必要があり、キャッシュエントリから形成される応答で送信する必要があります。 -ホップバイホップヘッダー。これは、単一のトランスポートレベル接続でのみ意味があり、キャッシュに格納されたり、プロキシによって転送されたりしません。次のHTTP / 1.1ヘッダーはホップバイホップヘッダーです。-接続-キープアライブ-プロキシ認証-プロキシ認証-TE-トレーラー-転送エンコード-アップグレードHTTP / 1.1で定義されている他のすべてのヘッダーはエンドツーです-endヘッダー。その他のホップバイホップヘッダーは、接続ヘッダーにリストする必要があります（&lt;a href=&quot;#section-14.10&quot;&gt;セクション14.10&lt;/a&gt;）は、HTTP / 1.1以降に導入されます。</target>
        </trans-unit>
        <trans-unit id="21bafa062922688ae091d5ac581f85b2253ab9b7" translate="yes" xml:space="preserve">
          <source>For these reasons, pipelining has been superseded by a better algorithm, &lt;em&gt;multiplexing&lt;/em&gt;, that is used by HTTP/2.</source>
          <target state="translated">これらの理由により、パイプライン処理は、HTTP / 2で使用されるより良いアルゴリズムである&lt;em&gt;多重化&lt;/em&gt;に取って代わられました。</target>
        </trans-unit>
        <trans-unit id="e0fe7bfcb91231799d489fc2723d6dd4bbc0c043" translate="yes" xml:space="preserve">
          <source>Forbidden header name</source>
          <target state="translated">禁断のヘッダー名</target>
        </trans-unit>
        <trans-unit id="f09e76e0b403d1bc7b01b5a7432c7aadcdb4a81e" translate="yes" xml:space="preserve">
          <source>Forbidden response-header name</source>
          <target state="translated">禁断のレスポンスヘッダ名</target>
        </trans-unit>
        <trans-unit id="ecdbc655eb3ebf83109410af71e822cca4455369" translate="yes" xml:space="preserve">
          <source>Forbids JavaScript from accessing the cookie, for example, through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property. Note that a cookie that has been created with HttpOnly will still be sent with JavaScript-initiated requests, e.g. when calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt;&lt;code&gt;XMLHttpRequest.send()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;. This mitigates attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;プロパティを介してJavaScriptがCookieにアクセスすることを禁止します。HttpOnlyで作成されたCookieは、たとえば&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt; &lt;code&gt;XMLHttpRequest.send()&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt; &lt;code&gt;fetch()&lt;/code&gt; を&lt;/a&gt;呼び出す場合など、JavaScriptで開始されたリクエストとともに送信されることに注意してください。これにより、クロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）に対する攻撃が軽減されます。</target>
        </trans-unit>
        <trans-unit id="b412bc69411dace0d04398d6ef301aa1c667a968" translate="yes" xml:space="preserve">
          <source>Force communication using HTTPS instead of HTTP.</source>
          <target state="translated">HTTPではなく、HTTPSを使って強制的に通信を行います。</target>
        </trans-unit>
        <trans-unit id="eef9c57759e4f6a908b3d969fe32e4b1fa5c2a10" translate="yes" xml:space="preserve">
          <source>Forced prefetching of hostnames might be useful, for example, on the homepage of a site to force pre-resolution of domain names that are referenced frequently throughout the site even though they are not used on the home page itself. This will improve the overall performance of site even though the performance of the home page may not be affected.</source>
          <target state="translated">ホスト名の強制的なプリフェッチは、例えば、ホームページ自体では使用されていないにもかかわらず、サイト全体で頻繁に参照されるドメイン名を強制的にプリ解決するために、サイトのホームページ上で有用かもしれません。これは、ホームページのパフォーマンスには影響しないかもしれませんが、 サイトの全体的なパフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="07c90eda5719a0767b7585d1fae63b890d2df734" translate="yes" xml:space="preserve">
          <source>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">キャッシュされたコピーをリリースする前に、検証のために元のサーバーにリクエストを送信するようにキャッシュを強制します。</target>
        </trans-unit>
        <trans-unit id="5e4ea8df1ce37991d82f8682bf378d09968f9b0d" translate="yes" xml:space="preserve">
          <source>Forcing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPS&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPSを&lt;/a&gt;強制する</target>
        </trans-unit>
        <trans-unit id="4634694667d40eda0bbe0a5024383a25099b93b8" translate="yes" xml:space="preserve">
          <source>Forcing HTTPS. Requests to the HTTP version of your site will be redirected to the HTTPS version of your site.</source>
          <target state="translated">強制的にHTTPS化する。あなたのサイトの HTTP バージョンへのリクエストは、あなたのサイトの HTTPS バージョンにリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="e65113ef7489ad2e3e6bcd61586a5a6e130fc3a1" translate="yes" xml:space="preserve">
          <source>Forcing lookup of specific hostnames</source>
          <target state="translated">特定のホスト名を強制的に検索する</target>
        </trans-unit>
        <trans-unit id="ab88e44a21e56a74ea52f9806dd114accfebc6fd" translate="yes" xml:space="preserve">
          <source>Form factor</source>
          <target state="translated">フォームファクター</target>
        </trans-unit>
        <trans-unit id="d4287342eaedf156edc375518b5469130015c5b1" translate="yes" xml:space="preserve">
          <source>Formatting in HTML</source>
          <target state="translated">HTMLでの書式設定</target>
        </trans-unit>
        <trans-unit id="72574aaae0c03841c4924b83ccaa181535815a29" translate="yes" xml:space="preserve">
          <source>Fortunately, as long as you have access to the server's configuration, fixing this is easy. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header supports multiple origins, separated by commas, like this:</source>
          <target state="translated">幸い、サーバーの設定にアクセスできる限り、これを修正するのは簡単です。 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダがサポートこのようなカンマで区切られた複数の起源：</target>
        </trans-unit>
        <trans-unit id="88300ac449331e8942e45db76cb6c950d0433ba5" translate="yes" xml:space="preserve">
          <source>Forward proxies</source>
          <target state="translated">フォワードプロキシ</target>
        </trans-unit>
        <trans-unit id="f39bbf5e0d44588e0ee44ca9d11dbdff07723664" translate="yes" xml:space="preserve">
          <source>Forward proxies can also be anonymous proxies and allow users to hide their IP address while browsing the Web or using other Internet services. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (The Onion Router), routes internet traffic through multiple proxies for anonymity.</source>
          <target state="translated">フォワードプロキシは匿名プロキシにすることもでき、ユーザーはWebの閲覧中または他のインターネットサービスの使用中にIPアドレスを非表示にできます。&lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt;（オニオンルーター）は、匿名性のために複数のプロキシを経由してインターネットトラフィックをルーティングします。</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="879b7cb814cbc842f6566b4b5009e2ae4c5e4256" translate="yes" xml:space="preserve">
          <source>Forwarded HTTP Extension</source>
          <target state="translated">転送型HTTP拡張</target>
        </trans-unit>
        <trans-unit id="a751a7c6f5ebc769cdda2c0d60519a9100785f00" translate="yes" xml:space="preserve">
          <source>Forwarding client information through proxies</source>
          <target state="translated">プロキシを介したクライアント情報の転送</target>
        </trans-unit>
        <trans-unit id="3f19d616ab1973eab54443edad1f469f67e51a95" translate="yes" xml:space="preserve">
          <source>Fragment</source>
          <target state="translated">Fragment</target>
        </trans-unit>
        <trans-unit id="7bf6780ba1203e0c37a2bbe6f2b29b2481023856" translate="yes" xml:space="preserve">
          <source>Frame and message structure in HTTP/2</source>
          <target state="translated">HTTP/2 のフレームとメッセージ構造</target>
        </trans-unit>
        <trans-unit id="5b968bd2c47b3621328bcde661b5d00bbb234e51" translate="yes" xml:space="preserve">
          <source>Freshness</source>
          <target state="translated">Freshness</target>
        </trans-unit>
        <trans-unit id="71fec796b8ce84752a371f57c6e5fa7e23101e6f" translate="yes" xml:space="preserve">
          <source>Freshness (RFC 7234)</source>
          <target state="translated">鮮度(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="061140cd8957c1a20500ec4735145a4823d87854" translate="yes" xml:space="preserve">
          <source>From (RFC 2616)</source>
          <target state="translated">(RFC 2616)より</target>
        </trans-unit>
        <trans-unit id="ab25ccd00949ff6aec782bce24f64f443ae8183b" translate="yes" xml:space="preserve">
          <source>From (RFC 7231)</source>
          <target state="translated">(RFC 7231)より</target>
        </trans-unit>
        <trans-unit id="fc8df84d4beeac0f9b5f8d6d828c77f7b287a76a" translate="yes" xml:space="preserve">
          <source>From the beginnings of HTTP, the protocol allowed another negotiation type: &lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;. In this negotiation, when facing an ambiguous request, the server sends back a page containing links to the available alternative resources. The user is presented the resources and choose the one to use.</source>
          <target state="translated">HTTPの初めから、プロトコルは別のネゴシエーションタイプを許可しました：&lt;em&gt;エージェント駆動ネゴシエーション&lt;/em&gt;または&lt;em&gt;リアクティブネゴシエーション&lt;/em&gt;。このネゴシエーションでは、あいまいな要求に直面すると、サーバーは使用可能な代替リソースへのリンクを含むページを送り返します。ユーザーにリソースが提示され、使用するリソースを選択します。</target>
        </trans-unit>
        <trans-unit id="2a0830997625a669017113736869c02cdf00c6fb" translate="yes" xml:space="preserve">
          <source>From version 1, Focus is powered by Android WebView and uses the following user agent string format:</source>
          <target state="translated">バージョン1から、FocusはAndroid WebViewを搭載しており、以下のユーザーエージェント文字列フォーマットを使用しています。</target>
        </trans-unit>
        <trans-unit id="bf2dddbd41ffb807d3f91b7c00d45658b62cbe7d" translate="yes" xml:space="preserve">
          <source>From version 1.1, Firefox for Echo Show uses a user agent string with the following format:</source>
          <target state="translated">バージョン1.1から、Firefox for Echo Showでは、以下の形式のユーザーエージェント文字列を使用しています。</target>
        </trans-unit>
        <trans-unit id="b65dd0e7d73eba5ec8f68b41e102211c26e17c9c" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">以降バージョン53からは、Geckoは県利用可能であり &lt;code&gt;about:config&lt;/code&gt; とし、ユーザーが自分のデフォルト設定できるように &lt;code&gt;Referrer-Policy&lt;/code&gt; - &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="634b1e47168d224b18cc5d200468a1a666ff4f5b" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt;&amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">バージョン53以降、Geckoの &lt;code&gt;about:config&lt;/code&gt; でユーザーがデフォルトの &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; を設定できるようにする設定を利用できます。</target>
        </trans-unit>
        <trans-unit id="f46e7fd368eae55073e0a8f47aee34fcd932ec29" translate="yes" xml:space="preserve">
          <source>From version 59 onwards (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;#587523&lt;/a&gt;), this has been replaced by &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; and &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt;.</source>
          <target state="translated">バージョン59以降（&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;＃587523を&lt;/a&gt;参照）以降、これは &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; および &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt; に置き換えられました。</target>
        </trans-unit>
        <trans-unit id="4d0bf1cf951361338f44d3f633af3e9f659dd546" translate="yes" xml:space="preserve">
          <source>From version 82, if an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element's &lt;code&gt;download&lt;/code&gt; attribute is set (for a same-origin URL) then the &lt;code&gt;inline&lt;/code&gt; directive is ignored. Earlier versions did not match the specification and respected the header directive over the attribute. See &lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;bug 1658877&lt;/a&gt;.</source>
          <target state="translated">バージョン82以降、 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 要素の &lt;code&gt;download&lt;/code&gt; 属性が（同一生成元URLに対して）設定されている場合、 &lt;code&gt;inline&lt;/code&gt; ディレクティブは無視されます。以前のバージョンは仕様と一致せず、属性のヘッダーディレクティブを尊重していました。&lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;バグ1658877を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bb08d10b00a6114f53ac03b662cd5c0fa2fadf2c" translate="yes" xml:space="preserve">
          <source>Fullscreen</source>
          <target state="translated">Fullscreen</target>
        </trans-unit>
        <trans-unit id="d1c21c81f5e9278875fd7faba9e8ce5fee900412" translate="yes" xml:space="preserve">
          <source>Fullscreen API&lt;br/&gt;&lt;small&gt;The definition of 'Fullscreen' in that specification.&lt;/small&gt;</source>
          <target state="translated">フルスクリーンAPI &lt;br/&gt;&lt;small&gt;その仕様における「フルスクリーン」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4076ad8ca1d493e56ac7306efcb34aa07f0cd" translate="yes" xml:space="preserve">
          <source>Fully qualified hostname to match against.</source>
          <target state="translated">完全に修飾されたホスト名をマッチさせます。</target>
        </trans-unit>
        <trans-unit id="70e18d39d91b0bb23213a714597ec6ac0a18898d" translate="yes" xml:space="preserve">
          <source>Functional overview</source>
          <target state="translated">機能概要</target>
        </trans-unit>
        <trans-unit id="d121b74dc433c61707ecf2145f14c0087235e9c1" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfil it.</source>
          <target state="translated">サーバーがリクエストを満たすためには、リクエストをさらに拡張する必要があります。</target>
        </trans-unit>
        <trans-unit id="859debff3eb6a95e21550e12eaa3e9501db63349" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfill it.</source>
          <target state="translated">サーバーがリクエストを満たすためには、リクエストのさらなる拡張が必要です。</target>
        </trans-unit>
        <trans-unit id="c09cf39e0efd384b99059d76f22ce0c68ab74478" translate="yes" xml:space="preserve">
          <source>Furthermore, some default values of preferences differ between build configurations, such as platform and locale, which means web sites could identify individual users using this information.</source>
          <target state="translated">さらに、環境設定のデフォルト値の中には、プラットフォームやロケールなど、ビルド構成によって異なるものがあり、ウェブサイトではこの情報を使用して個々のユーザーを特定できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="828d617ffbd78d6822f9aa5a1a25e2e9a6f4041d" translate="yes" xml:space="preserve">
          <source>GET (RFC 7231)</source>
          <target state="translated">GET (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="889241fb06a8d7a9634f3ef3d8c354487e92626b" translate="yes" xml:space="preserve">
          <source>GET: The resource has been fetched and is transmitted in the message body.</source>
          <target state="translated">GETしました。リソースがフェッチされ、メッセージ本文で送信されました。</target>
        </trans-unit>
        <trans-unit id="758f6c9347b91091c38ad698a8eba6aeac47b9c4" translate="yes" xml:space="preserve">
          <source>GIF</source>
          <target state="translated">GIF</target>
        </trans-unit>
        <trans-unit id="ad6e940d0a1449c3f043c3a92ac96eacb89d1691" translate="yes" xml:space="preserve">
          <source>GIF images (lossless compression, superseded by PNG)</source>
          <target state="translated">GIF 画像 (ロスレス圧縮、PNG に置き換わる)</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="352e09ef4c24f106ac21c027ee173d9c89b53400" translate="yes" xml:space="preserve">
          <source>GZip Compressed Archive</source>
          <target state="translated">GZip圧縮アーカイブ</target>
        </trans-unit>
        <trans-unit id="30b0db79f60240a0079907f498493dc26899f285" translate="yes" xml:space="preserve">
          <source>Gateway or multiple parties. The server is acting as a gateway to an exchange involving multiple parties.</source>
          <target state="translated">ゲートウェイまたは複数の当事者 サーバーは、複数のパーティが関与する交換のゲートウェイとして機能しています。</target>
        </trans-unit>
        <trans-unit id="75402c80a4e4ffb05b2e1744866544933eef7e16" translate="yes" xml:space="preserve">
          <source>Gecko</source>
          <target state="translated">Gecko</target>
        </trans-unit>
        <trans-unit id="d377c8358e2e4b422fb5f7dadb1f64fb8c95cca2" translate="yes" xml:space="preserve">
          <source>Gecko user agent string</source>
          <target state="translated">Gecko ユーザエージェント文字列</target>
        </trans-unit>
        <trans-unit id="64f2d81db08b8b5b6d065aef938e7abd5e149546" translate="yes" xml:space="preserve">
          <source>Gecko version number</source>
          <target state="translated">ヤモリのバージョン番号</target>
        </trans-unit>
        <trans-unit id="ab051d4c4633073d92cf5eecdf9929aa43fd1d4b" translate="yes" xml:space="preserve">
          <source>Gecko/xyz</source>
          <target state="translated">Gecko/xyz</target>
        </trans-unit>
        <trans-unit id="40fe0205052be8e7ff127e8675aa5f542d969bde" translate="yes" xml:space="preserve">
          <source>General example</source>
          <target state="translated">一般的な例</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">一般的な形態</target>
        </trans-unit>
        <trans-unit id="c1e2a5611d6d492bfc81f68a60efadd4f6151c4e" translate="yes" xml:space="preserve">
          <source>General header</source>
          <target state="translated">一般ヘッダ</target>
        </trans-unit>
        <trans-unit id="ce7515fe427724c3a8ec1e689f1513ade3494a01" translate="yes" xml:space="preserve">
          <source>General structure</source>
          <target state="translated">一般的な構造</target>
        </trans-unit>
        <trans-unit id="5739e547142aa8443b5825e26cdfefcbe00318e3" translate="yes" xml:space="preserve">
          <source>General warning information about possible problems.</source>
          <target state="translated">起こりうる問題についての一般的な警告情報。</target>
        </trans-unit>
        <trans-unit id="2ee8f734456eeec6f1528c29e7b9dd676c82ba5c" translate="yes" xml:space="preserve">
          <source>Geolocation</source>
          <target state="translated">Geolocation</target>
        </trans-unit>
        <trans-unit id="85b8d61e7354b7736b7ec8ca91e1105f85435b65" translate="yes" xml:space="preserve">
          <source>Given this CSP header:</source>
          <target state="translated">このCSPヘッダが与えられると</target>
        </trans-unit>
        <trans-unit id="4e8b70f78453a41b0760bb603aa5281fa0436163" translate="yes" xml:space="preserve">
          <source>Glossary: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</source>
          <target state="translated">用語集：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="bad9e9df904c73f497b664b045343bef194565df" translate="yes" xml:space="preserve">
          <source>Google Chrome handles DNS prefetching control</source>
          <target state="translated">Google Chrome は DNS のプリフェッチ制御を処理する</target>
        </trans-unit>
        <trans-unit id="4d6910e3810a19ca345b6c8578f0e4ba472ba3b8" translate="yes" xml:space="preserve">
          <source>Google Docs CORB explainer</source>
          <target state="translated">Google Docs CORBの説明者</target>
        </trans-unit>
        <trans-unit id="3e389ee93fcba3ef467be442186c13f4427744a6" translate="yes" xml:space="preserve">
          <source>Google Webmaster blog: How to deal with planned site downtime</source>
          <target state="translated">Googleウェブマスターブログ。計画的なサイトダウンタイムの対処法</target>
        </trans-unit>
        <trans-unit id="ea0c0aed6cf9a0c5b577d1e3a89cbf79500b4710" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;はHSTSプリロードサービスを&lt;/a&gt;維持しています。ガイドラインに従ってドメインを正常に送信すると、ブラウザは安全でない接続を使用してドメインに接続することはありません。サービスはGoogleによってホストされていますが、すべてのブラウザーはプリロードリストを使用する（または実際に使用を開始する）意図を表明しています。ただし、これはHSTS仕様の一部ではなく、公式として扱われるべきではありません。</target>
        </trans-unit>
        <trans-unit id="60827ebdcf1686e9d01ea4b0e1ab1925903a2c9b" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.org/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google&lt;a href=&quot;https://hstspreload.org/&quot;&gt;はHSTSプリロードサービスを&lt;/a&gt;維持しています。ガイドラインに従い、ドメインを正常に送信することにより、ブラウザが安全でない接続を使用してドメインに接続することはありません。このサービスはGoogleによってホストされていますが、すべてのブラウザはプリロードリストを使用する（または実際に使用を開始する）意図を表明しています。ただし、これはHSTS仕様の一部ではないため、公式として扱うべきではありません。</target>
        </trans-unit>
        <trans-unit id="ef239b0e9b523a211062dd9a992489254f2934aa" translate="yes" xml:space="preserve">
          <source>Governs which referrer information sent in the &lt;a href=&quot;headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header should be included with requests made.</source>
          <target state="translated">で送信された支配リファラ情報&lt;a href=&quot;headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;ヘッダーが行われた要求に含まれるべきです。</target>
        </trans-unit>
        <trans-unit id="360bdb2acc65ada59d8a23e434964675641d9c45" translate="yes" xml:space="preserve">
          <source>Graceful degradation</source>
          <target state="translated">潔い劣化</target>
        </trans-unit>
        <trans-unit id="14d1e14f4035027adcdfb20a1541aae1745796ae" translate="yes" xml:space="preserve">
          <source>Granular control over certain features</source>
          <target state="translated">特定の機能の粒度制御</target>
        </trans-unit>
        <trans-unit id="acdb09fe43197ccedd1630af2f50c572c32d3061" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format</source>
          <target state="translated">グラフィックスインターチェンジフォーマット</target>
        </trans-unit>
        <trans-unit id="94265c1a4efc21014ed0c288b4d4deab23d58e6c" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format (GIF)</source>
          <target state="translated">グラフィックスインターチェンジフォーマット(GIF)</target>
        </trans-unit>
        <trans-unit id="07dad8754dab2f22b2c67d2717531b2161e04c97" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time. HTTP dates are always expressed in GMT, never in local time.</source>
          <target state="translated">グリニッジ標準時。HTTP の日付は常に GMT で表示され、決して現地時間ではありません。</target>
        </trans-unit>
        <trans-unit id="fac27197d986ea2b588d07c83185f5503eea7d94" translate="yes" xml:space="preserve">
          <source>Guide to media types used on the web</source>
          <target state="translated">ウェブ上で使用されるメディアの種類のガイド</target>
        </trans-unit>
        <trans-unit id="63172a5d2ab37e128a6f6cf25b0335129725a21c" translate="yes" xml:space="preserve">
          <source>Guide: &lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt; for civilians&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">ガイド：&lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;民間人のための&lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="82ee9a2ace2ff133591d7f8cb5b72ca9b839fcd4" translate="yes" xml:space="preserve">
          <source>Guides: Basics</source>
          <target state="translated">ガイド 基本</target>
        </trans-unit>
        <trans-unit id="6e029883c1d4de187688b7e7b2376708429e4061" translate="yes" xml:space="preserve">
          <source>Gyroscope</source>
          <target state="translated">Gyroscope</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="780c90e89bccb7fed5c8548e6fe499017ad97ffb" translate="yes" xml:space="preserve">
          <source>HEAD (RFC 7231)</source>
          <target state="translated">HEAD (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="562b472b05f04a6dd479541dc3fcef670a17fed9" translate="yes" xml:space="preserve">
          <source>HEAD: The entity headers are in the message body.</source>
          <target state="translated">HEAD:エンティティヘッダはメッセージ本文にあります。</target>
        </trans-unit>
        <trans-unit id="c194c3625b9314d21fe00e2a5b33960d2235d75a" translate="yes" xml:space="preserve">
          <source>HPACK: Header Compression for HTTP/2</source>
          <target state="translated">HPACK:HTTP/2 のヘッダ圧縮</target>
        </trans-unit>
        <trans-unit id="f4ce8cef0273faa8edf023797bff38c190bc758e" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommend.</source>
          <target state="translated">HPKPは間違った使い方をすると、ユーザーを長時間ロックアウトする可能性があります。バックアップ証明書の使用やCA証明書の固定化を推奨します。</target>
        </trans-unit>
        <trans-unit id="fc0a0d888f6e163542c2141a305027befded2018" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommended.</source>
          <target state="translated">HPKPは間違った使い方をすると、ユーザーを長時間ロックアウトする可能性があります。バックアップ証明書の使用やCA証明書の固定化を推奨します。</target>
        </trans-unit>
        <trans-unit id="f7a71b290916b9c6df149f326df62ff64346f837" translate="yes" xml:space="preserve">
          <source>HPKP is a &lt;em&gt;Trust on First Use&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;) technique. The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time. When the client visits the server again, it expects at least one certificate in the certificate chain to contain a public key whose fingerprint is already known via HPKP. If the server delivers an unknown public key, the client should present a warning to the user.</source>
          <target state="translated">HPKPは、&lt;em&gt;最初の使用&lt;/em&gt;に対する&lt;em&gt;信頼&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;）テクニックです。Webサーバーが最初にクライアントに特別なHTTPヘッダーを介してどの公開キーが属しているかを伝えるとき、クライアントはこの情報を一定期間保存します。クライアントが再びサーバーにアクセスするとき、クライアントは、証明書チェーン内の少なくとも1つの証明書に、HPKPを介してフィンガープリントが既知の公開鍵が含まれていることを期待しています。サーバーが不明な公開鍵を配信する場合、クライアントはユーザーに警告を表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f23df8f2db7fa54c086120949c75120681957c68" translate="yes" xml:space="preserve">
          <source>HTML &lt;code&gt;lang&lt;/code&gt; attribute</source>
          <target state="translated">HTML &lt;code&gt;lang&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="57b74ec0b3fb709ed009e59e071a8ce0a9039c38" translate="yes" xml:space="preserve">
          <source>HTML Forms</source>
          <target state="translated">HTMLフォーム</target>
        </trans-unit>
        <trans-unit id="2abbe4c282803f8a491f6e980e7fc519bd5a7483" translate="yes" xml:space="preserve">
          <source>HTML Living Standard</source>
          <target state="translated">HTMLリビングスタンダード</target>
        </trans-unit>
        <trans-unit id="b7098c07bc2151e34df998ef11bad7237b20c9ba" translate="yes" xml:space="preserve">
          <source>HTML Living Standard&lt;br/&gt;&lt;small&gt;The definition of 'document-domain' in that specification.&lt;/small&gt;</source>
          <target state="translated">HTML Living Standard &lt;br/&gt;&lt;small&gt;その仕様における「ドキュメントドメイン」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="18d5d7015a5c0d8f94531cdc381221d904d7cbf2" translate="yes" xml:space="preserve">
          <source>HTML files</source>
          <target state="translated">HTMLファイル</target>
        </trans-unit>
        <trans-unit id="6390be00d32679564fc38130d4ea8471a4d82c91" translate="yes" xml:space="preserve">
          <source>HTML redirections</source>
          <target state="translated">HTMLリダイレクト</target>
        </trans-unit>
        <trans-unit id="f66adf007a33a0423e5b7102cdbe9c27c03d133c" translate="yes" xml:space="preserve">
          <source>HTML redirections with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用したHTMLリダイレクト</target>
        </trans-unit>
        <trans-unit id="7508e59dac25653bfafc78c94cdfff1f91c75f89" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) are executed if there weren't any HTTP redirects.</source>
          <target state="translated">HTMLリダイレクト（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;）は、HTTPリダイレクトがなかった場合に実行されます。</target>
        </trans-unit>
        <trans-unit id="8486d6ebac41d1efb6780b5d1b64cf90fff3aae8" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) execute if there weren't any HTTP redirects.</source>
          <target state="translated">HTMLリダイレクト（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;）は、HTTPリダイレクトがなかった場合に実行されます。</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="83ef326d5040783a2304cd9c3d4b2741d50432d8" translate="yes" xml:space="preserve">
          <source>HTTP 1.1 recommends the use of ETags rather than modification dates,
   for cache control, and there are even stronger reasons to prefer
   ETags for authoring.  Correct use of ETags is even more important in
   a distributed authoring environment, because ETags are necessary
   along with locks to avoid the lost-update problem.  A client might
   fail to renew a lock, for example, when the lock times out and the
   client is accidentally offline or in the middle of a long upload.
   When a client fails to renew the lock, it's quite possible the
   resource can still be relocked and the user can go on editing, as
   long as no changes were made in the meantime.  ETags are required for
   the client to be able to distinguish this case.  Otherwise, the 

   client is forced to ask the user whether to overwrite the resource on
   the server without even being able to tell the user if it has
   changed.  Timestamps do not solve this problem nearly as well as
   ETags.

   Strong ETags are much more useful for authoring use cases than weak
   ETags (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of [RFC2616]&lt;/a&gt;).  Semantic equivalence can be
   a useful concept but that depends on the document type and the
   application type, and interoperability might require some agreement
   or standard outside the scope of this specification and HTTP.  Note
   also that weak ETags have certain restrictions in HTTP, e.g., these
   cannot be used in If-Match headers.

   Note that the meaning of an ETag in a PUT response is not clearly
   defined either in this document or in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; (i.e., whether the
   ETag means that the resource is octet-for-octet equivalent to the
   body of the PUT request, or whether the server could have made minor
   changes in the formatting or content of the document upon storage).
   This is an HTTP issue, not purely a WebDAV issue.

   Because clients may be forced to prompt users or throw away changed
   content if the ETag changes, a WebDAV server SHOULD NOT change the
   ETag (or the Last-Modified time) for a resource that has an unchanged
   body and location.  The ETag represents the state of the body or
   contents of the resource.  There is no similar way to tell if
   properties have changed.</source>
          <target state="translated">HTTP 1.1では、キャッシュ制御のために変更日ではなくETagの使用を推奨しており、オーサリングにETagを使用するほうがより強力な理由があります。 ETagを正しく使用することは、分散型オーサリング環境ではさらに重要です。なぜなら、更新の消失の問題を回避するには、ロックとともにETagが必要だからです。たとえば、ロックがタイムアウトし、クライアントが誤ってオフラインになったり、長いアップロードの最中にクライアントがロックを更新できなかったりする場合があります。クライアントがロックの更新に失敗した場合、その間に変更が行われていない限り、リソースを再ロックしてユーザーが編集を続行できる可能性は十分にあります。 ETagは、クライアントがこのケースを区別できるようにするために必要です。さもないと、クライアントは、サーバー上のリソースを上書きするかどうかをユーザーに尋ねますが、リソースが変更されたかどうかをユーザーに伝えることさえできません。タイムスタンプは、ETagと同様にこの問題をほぼ解決しません。強力なETagは、弱いETagよりもユースケースの作成に非常に役立ちます（参照&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;[RFC2616]のセクション13.3.3&lt;/a&gt;）。セマンティック同値化は有用な概念ですが、それはドキュメントタイプとアプリケーションタイプに依存し、相互運用性には、この仕様とHTTPの範囲外の合意または標準が必要になる場合があります。弱いETagにはHTTPで特定の制限があることにも注意してください。たとえば、これらはIf-Matchヘッダーでは使用できません。 PUT応答のETagの意味は、このドキュメントでも&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;でも明確に定義されていないことに注意してください。（つまり、ETagが、リソースがPUTリクエストの本文と同等のオクテット単位であることを意味するか、またはサーバーが保存時にドキュメントのフォーマットまたはコンテンツに小さな変更を加えることができたかどうか）これはHTTPの問題であり、純粋にWebDAVの問題ではありません。ETagが変更された場合、クライアントはユーザーにプロンプ​​トを表示したり、変更されたコンテンツを破棄したりする可能性があるため、WebDAVサーバーは、ボディと場所が変更されていないリソースのETag（または最終変更時刻）を変更してはなりません（SHOULD NOT）。ETagは、リソースの本文またはコンテンツの状態を表します。プロパティが変更されたかどうかを確認する同様の方法はありません。</target>
        </trans-unit>
        <trans-unit id="056cc5e9a537351fb174e8ebbb3ca2b1700c2d47" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;</source>
          <target state="translated">HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;コンテンツネゴシエーション&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="392079fd3fa793eb6c0e1335885b8cddafea9ef8" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt;, like those for requests.</source>
          <target state="translated">リクエストの&lt;a href=&quot;headers&quot;&gt;ヘッダーの&lt;/a&gt;ようなHTTP ヘッダー。</target>
        </trans-unit>
        <trans-unit id="c6a6635bbee752fe5fb0f3784e33cdf15bd75ab6" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client hints&lt;/a&gt; are a work in progress. Actual documentation can be found on the &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;website of the HTTP working group&lt;/a&gt;.</source>
          <target state="translated">HTTP&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;クライアントヒント&lt;/a&gt;は進行中の作業です。実際のドキュメント&lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;は、HTTPワーキンググループのWebサイトにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a2ed3fe8a3093e057602abdf74477e83473a214" translate="yes" xml:space="preserve">
          <source>HTTP &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTP &lt;em&gt;ホスト：ポート&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae47637ce45f4b16c54404dff4cb129bfbe68800" translate="yes" xml:space="preserve">
          <source>HTTP Access Control covering the HTTP headers</source>
          <target state="translated">HTTPヘッダをカバーするHTTPアクセス制御</target>
        </trans-unit>
        <trans-unit id="d601b5bb2c1cad46bb9aa46a3ee39b64315236e7" translate="yes" xml:space="preserve">
          <source>HTTP Alternative Services</source>
          <target state="translated">HTTP代替サービス</target>
        </trans-unit>
        <trans-unit id="965e2184c8e7927a43f2bee90d3f5ececba434b6" translate="yes" xml:space="preserve">
          <source>HTTP Cache</source>
          <target state="translated">HTTPキャッシュ</target>
        </trans-unit>
        <trans-unit id="f54d56b271b9875e48fe27b600b0dc067a9f284e" translate="yes" xml:space="preserve">
          <source>HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">古くなったコンテンツのための HTTP Cache-Control 拡張機能</target>
        </trans-unit>
        <trans-unit id="6c1e735662c0178e6f3fe960f4930ffeabb6f7fe" translate="yes" xml:space="preserve">
          <source>HTTP Caching FAQ</source>
          <target state="translated">HTTP キャッシングFAQ</target>
        </trans-unit>
        <trans-unit id="0b0260299fa380d7d3a7ccc7edbf8a208c829f61" translate="yes" xml:space="preserve">
          <source>HTTP Client Hints</source>
          <target state="translated">HTTP クライアントヒント</target>
        </trans-unit>
        <trans-unit id="17e0afd9e45a02ae60f6b6aed60a68bef13f3af0" translate="yes" xml:space="preserve">
          <source>HTTP Conditional Requests</source>
          <target state="translated">HTTP 条件付き要求</target>
        </trans-unit>
        <trans-unit id="186213537e6fba63d1dd994c6c9b358b6f840caf" translate="yes" xml:space="preserve">
          <source>HTTP Cookies</source>
          <target state="translated">HTTPクッキー</target>
        </trans-unit>
        <trans-unit id="ae2fa3648597031d5a833b5724263dbfd920c241" translate="yes" xml:space="preserve">
          <source>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</source>
          <target state="translated">ウェブ分散オーサリングとバージョン管理のための HTTP 拡張機能 (WebDAV)</target>
        </trans-unit>
        <trans-unit id="6cee8a3bc57d158b257c68ed73852449cb27b716" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options</source>
          <target state="translated">HTTP ヘッダー フィールド X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="f88eb2164f3dbd137bca83f451898992e6e6b039" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options - RFC 7034</source>
          <target state="translated">HTTPヘッダフィールドX-Frame-Options-RFC 7034</target>
        </trans-unit>
        <trans-unit id="cc46670cd995848df63f3703c3400f81060dd482" translate="yes" xml:space="preserve">
          <source>HTTP Headers</source>
          <target state="translated">HTTPヘッダ</target>
        </trans-unit>
        <trans-unit id="d5d09479cf8d4e2b8c35798b4a19c06e1f5461b3" translate="yes" xml:space="preserve">
          <source>HTTP Immutable Responses</source>
          <target state="translated">HTTP 不変のレスポンス</target>
        </trans-unit>
        <trans-unit id="d1d0c4dbc1b360b38cb5161612b50b3934e501fa" translate="yes" xml:space="preserve">
          <source>HTTP Keep-Alive Header</source>
          <target state="translated">HTTPキープアライブヘッダー</target>
        </trans-unit>
        <trans-unit id="dc68b45ed9f862b4a9cd7aa0be2cfbc7e016a6ef" translate="yes" xml:space="preserve">
          <source>HTTP Message (RFC 2616)</source>
          <target state="translated">HTTP メッセージ (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="645acbbc29e90c2c68542670b051cdcea02987bc" translate="yes" xml:space="preserve">
          <source>HTTP Messages</source>
          <target state="translated">HTTPメッセージ</target>
        </trans-unit>
        <trans-unit id="3ccf0b57b902eafdb8fbf2b560f880d3eb800cc2" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure. This introductory article describes this structure, its purpose, and its possibilities.</source>
          <target state="translated">リクエストやレスポンスの間に送信される HTTP メッセージには、非常に明確な構造があります。この入門的な記事では、この構造とその目的、そしてその可能性について説明します。</target>
        </trans-unit>
        <trans-unit id="583d9f510824dc860b8faad49ebe7579ffd29c0b" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure; this introductory article describes this structure, its purpose and its possibilities.</source>
          <target state="translated">リクエストやレスポンスの際に送信される HTTP メッセージは非常に明確な構造を持っています。</target>
        </trans-unit>
        <trans-unit id="1b57e4650aa38c4a92f3b3fc02ea7dab930ee663" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;HPKP&lt;/a&gt;)</source>
          <target state="translated">HTTP公開鍵&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;ピンニング&lt;/a&gt;（HPKP）</target>
        </trans-unit>
        <trans-unit id="d34a93534eb1b632f2a799adfc1786464f6439f8" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning has been deprecated and removed in favor of Certificate Transparency and &lt;a href=&quot;headers/expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP公開鍵ピンニングは非推奨になり、証明書の透明性と&lt;a href=&quot;headers/expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; を&lt;/a&gt;優先して削除されました。</target>
        </trans-unit>
        <trans-unit id="94fdc3e6f5c751d82295ac7ade9d715a4814c0d4" translate="yes" xml:space="preserve">
          <source>HTTP Request Methods</source>
          <target state="translated">HTTP リクエストメソッド</target>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="translated">HTTPリクエスト</target>
        </trans-unit>
        <trans-unit id="7402660b7ec42f5008e637f7d416a9463ae2ce2f" translate="yes" xml:space="preserve">
          <source>HTTP Responses</source>
          <target state="translated">HTTP レスポンス</target>
        </trans-unit>
        <trans-unit id="1e3c49a8c708be92f5037401d92246426a46dc11" translate="yes" xml:space="preserve">
          <source>HTTP State Management Mechanism</source>
          <target state="translated">HTTTP状態管理機構</target>
        </trans-unit>
        <trans-unit id="a5fc269de1ce9034a5e3e1936288b84520462ea3" translate="yes" xml:space="preserve">
          <source>HTTP Status Response Codes</source>
          <target state="translated">HTTPステータスレスポンスコード</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HTTP ストリクト トランスポート セキュリティ (HSTS)</target>
        </trans-unit>
        <trans-unit id="30491b8aa76d328aca84cd3704d383ab97b03407" translate="yes" xml:space="preserve">
          <source>HTTP Working Group</source>
          <target state="translated">HTTPワーキンググループ</target>
        </trans-unit>
        <trans-unit id="cbc09a66647a44074ee04da1ac1771e8479c9d8b" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to a communicate with different &lt;em&gt;resources&lt;/em&gt; on Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTPを使用すると、ブラウザまたは別の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;がインターネット上のさまざまな&lt;em&gt;リソース&lt;/em&gt;と通信できます。これを行うには、ブラウザがリソースの&lt;em&gt;ID&lt;/em&gt;と&lt;em&gt;場所の&lt;/em&gt;両方を必要とし&lt;em&gt;ます&lt;/em&gt;。これらの2つの情報は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;によって記述されます。</target>
        </trans-unit>
        <trans-unit id="1cc8c4caf634d96aa87067b5477aecd5ac3e698e" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to communicate with different &lt;em&gt;resources&lt;/em&gt; on the Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTPを使用すると、ブラウザまたは別の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;がインターネット上のさまざまな&lt;em&gt;リソース&lt;/em&gt;と通信できます。これを行うには、ブラウザにリソースの&lt;em&gt;ID&lt;/em&gt;と&lt;em&gt;場所の&lt;/em&gt;両方が必要です。これらの2ビットの情報は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;によって記述されます。</target>
        </trans-unit>
        <trans-unit id="2d82f24e44e689920296a131052df78d102bbaff" translate="yes" xml:space="preserve">
          <source>HTTP and WebDAV did not use the bodies of most error responses for
   machine-parsable information until the specification for Versioning
   Extensions to WebDAV introduced a mechanism to include more specific
   information in the body of an error response (&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;Section&amp;nbsp;1.6 of
   [RFC3253]&lt;/a&gt;).  The error body mechanism is appropriate to use with any
   error response that may take a body but does not already have a body
   defined.  The mechanism is particularly appropriate when a status
   code can mean many things (for example, 400 Bad Request can mean
   required headers are missing, headers are incorrectly formatted, or
   much more).  This error body mechanism is covered in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;.</source>
          <target state="translated">HTTPとWebDAVは、WebDAVのバージョン管理拡張機能の仕様がエラー応答の本文にさらに具体的な情報を含めるメカニズムを導入するまで（&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;[RFC3253]のセクション1.6）、機械で解析&lt;/a&gt;可能な情報のほとんどのエラー応答の本文を使用しませんでした。エラー本文のメカニズムは、本文を取得する可能性があるが、まだ本文が定義されていないエラー応答での使用に適しています。このメカニズムは、ステータスコードが多くのことを意味する場合に特に適しています（たとえば、400 Bad Requestは、必要なヘッダーが欠落している、ヘッダーの形式が正しくない、などなど）。このエラー本文のメカニズムについては、&lt;a href=&quot;#section-16&quot;&gt;セクション16で説明し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="170502bb0d853c3d72e45f0eef9c00311f2253c6" translate="yes" xml:space="preserve">
          <source>HTTP and connections</source>
          <target state="translated">HTTP と接続</target>
        </trans-unit>
        <trans-unit id="70e2789624d7913484672252eb44130b859ad66a" translate="yes" xml:space="preserve">
          <source>HTTP applications have historically allowed three different formats
   for the representation of date/time stamps:

      Sun, 06 Nov 1994 08:49:37 GMT  ; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;
      Sunday, 06-Nov-94 08:49:37 GMT ; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

   The first format is preferred as an Internet standard and represents
   a fixed-length subset of that defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;] (an update to
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]). The second format is in common use, but is based on the
   obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [&lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] date format and lacks a four-digit year.
   HTTP/1.1 clients and servers that parse the date value MUST accept
   all three formats (for compatibility with HTTP/1.0), though they MUST
   only generate the &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; format for representing HTTP-date values
   in header fields. See &lt;a href=&quot;#section-19.3&quot;&gt;section 19.3&lt;/a&gt; for further information.

      Note: Recipients of date values are encouraged to be robust in
      accepting date values that may have been sent by non-HTTP
      applications, as is sometimes the case when retrieving or posting
      messages via proxies/gateways to SMTP or NNTP. 

   All HTTP date/time stamps MUST be represented in Greenwich Mean Time
   (GMT), without exception. For the purposes of HTTP, GMT is exactly
   equal to UTC (Coordinated Universal Time). This is indicated in the
   first two formats by the inclusion of &quot;GMT&quot; as the three-letter
   abbreviation for time zone, and MUST be assumed when reading the
   asctime format. HTTP-date is case sensitive and MUST NOT include
   additional LWS beyond that specifically included as SP in the
   grammar.

       HTTP-date    = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date | &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date | asctime-date
       &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                    | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
       weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                    | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
       month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                    | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                    | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream. Clients and servers are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">HTTPアプリケーションはこれまで、日付/時刻スタンプの表現に3つの異なる形式を許可してきました。Sun、1994年11月6日08:49:37 GMT。&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 日曜、06-Nov-94 08:49:37 GMT に更新。&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt; Sun Nov 6 08:49:37 1994 に廃止。 ANSI Cのasctime（）形式最初の形式はインターネット標準として推奨され、&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ]（&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]の更新版） によって定義された固定長サブセットを表します。 2番目の形式は一般的に使用されてい&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;ます&lt;/a&gt;が、廃止されたRFC 850 [ &lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;]日付形式で、4桁の年がありません。日付フィールドを解析するHTTP / 1.1クライアントとサーバーは、HTTP / 1.0との互換性のために3つの形式すべてを受け入れる必要がありますが、ヘッダーフィールドでHTTP日付値を表すための&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;形式のみを生成する必要があります。見る&lt;a href=&quot;#section-19.3&quot;&gt;セクション19.3を&lt;/a&gt;詳細については。注：日付/値の受信者は、プロキシ/ゲートウェイ経由でSMTPまたはNNTPにメッセージを取得または投稿する場合によくあるように、HTTP以外のアプリケーションから送信された可能性のある日付値を確実に受け入れるようにしてください。すべてのHTTP日付/タイムスタンプは、例外なくグリニッジ標準時（GMT）で表す必要があります。 HTTPの目的では、GMTはUTC（協定世界時）とまったく同じです。これは、タイムゾーンの3文字の省略形として「GMT」を含めることによって最初の2つの形式で示され、asctime形式を読み取るときに想定する必要があります。 HTTP-dateは大文字と小文字を区別し、文法にSPとして具体的に含まれているものを超える追加のLWSを含めてはなりません（MUST NOT）。HTTP-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date |&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date | asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date = wkday &quot;、&quot; SP日付1 SP時間SP &quot;GMT&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date =平日 &quot;、&quot; SP日付2 SP時間SP &quot;GMT&quot; asctime-date = wkday SP日付3 SP時間SP 4DIGIT日付1 = 2DIGIT SP月SP 4DIGIT;日月年（たとえば、1982年6月2日）date2 = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT;日-月-年（例：02-Jun-82）date3 =月SP（2DIGIT |（SP 1DIGIT））;月日（例：6月2日）時間= 2DIGIT &quot;：&quot; 2DIGIT &quot;：&quot; 2DIGIT; 00:00:00-23:59:59 wkday = &quot;月&quot; | 「火」| 「水」| 「木」| 「金」| 「土」| &quot;Sun&quot;曜日= &quot;Monday&quot; | 「火曜日」| 「水曜日」| 」木曜日」|「金曜日」|「土曜日」|「日曜日」月=「1月」|「2月」|「3月」|「4月」|「5月」|「6月」|「7月」|「8月」|「9月」 &quot;|&quot; Oct &quot;|&quot; Nov &quot;|&quot; Dec &quot;注：日付/タイムスタンプ形式のHTTP要件は、プロトコルストリーム内での使用にのみ適用されます。クライアントおよびサーバーは、ユーザーの表示、要求のログにこれらの形式を使用する必要はありません。 、など| 「9月」| 「10月」| 「11月」| &quot;Dec&quot;注：日付/タイムスタンプ形式のHTTP要件は、プロトコルストリーム内での使用にのみ適用されます。クライアントとサーバーは、ユーザーの表示、要求のロギングなどにこれらの形式を使用する必要はありません。| 「9月」| 「10月」| 「11月」| &quot;Dec&quot;注：日付/タイムスタンプ形式のHTTP要件は、プロトコルストリーム内での使用にのみ適用されます。クライアントとサーバーは、ユーザーの表示、要求のロギングなどにこれらの形式を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3cd45603fb781257153f9081597101ece177c7d0" translate="yes" xml:space="preserve">
          <source>HTTP authentication</source>
          <target state="translated">HTTP認証</target>
        </trans-unit>
        <trans-unit id="ab4ed2ef5f3094275f004bff5889feddcf0ad10a" translate="yes" xml:space="preserve">
          <source>HTTP caching &amp;ndash; Ilya Grigorik</source>
          <target state="translated">HTTPキャッシング&amp;ndash; Ilya Grigorik</target>
        </trans-unit>
        <trans-unit id="d4978c013ac3d81e858ff3f4bb1b87778fc8087f" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional but usually desirable. HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;; they may decline other methods. The primary cache key consists of the request method and target URI (often only the URI is used &amp;mdash; this is because only &lt;code&gt;GET&lt;/code&gt; requests are caching targets).</source>
          <target state="translated">HTTPキャッシングはオプションですが、通常は望ましいです。HTTPキャッシュは通常、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;への応答のキャッシュに制限されています。他の方法を拒否する場合があります。プライマリキャッシュキーは、リクエストメソッドとターゲットURIで構成されます（多くの場合、URIのみが使用されます。これは、 &lt;code&gt;GET&lt;/code&gt; リクエストのみがターゲットをキャッシュしているためです）。</target>
        </trans-unit>
        <trans-unit id="bc0f4dfb9b0a4bec403f49cd2c2239e560902813" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</source>
          <target state="translated">HTTPキャッシングはオプションですが、キャッシュされたリソースを再利用することが通常望ましいです。ただし、一般的なHTTPキャッシュは通常、&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;への応答のキャッシュに限定されており、他のメソッドを拒否する可能性があります。プライマリキャッシュキーは、リクエストメソッドとターゲットURIで構成されます（多くの場合、GETリクエストのみがターゲットをキャッシュしているため、URIのみが使用されます）。キャッシュエントリの一般的な形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="64f23433ac676ea06e9a1900351a7ac4a13f68a1" translate="yes" xml:space="preserve">
          <source>HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response MAY be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.

   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen. 

   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.

   If an origin server wishes to force a semantically transparent cache
   to validate every request, it MAY assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache SHOULD validate it before using it for subsequent requests. See
   &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt; for a more restrictive way to force revalidation.

   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it SHOULD use the &quot;must-
   revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.

   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See &lt;a href=&quot;#section-13.13&quot;&gt;section 13.13&lt;/a&gt; for an explanation of the difference between caches
   and history mechanisms.</source>
          <target state="translated">HTTPキャッシングは、キャッシュが元のサーバーへのリクエストを完全に回避できる場合に最適に機能します。リクエストを回避するための主要なメカニズムは、オリジンサーバーが将来の明示的な有効期限を提供することです。これは、後続のリクエストを満たすためにレスポンスが使用される可能性があることを示します。言い換えれば、キャッシュは最初にサーバーに接続せずに新しい応答を返すことができます。私たちの期待は、有効期限に達する前に、意味的に重要な方法でエンティティが変更される可能性は低いと考えて、サーバーが将来の明示的な有効期限を応答に割り当てることです。サーバーの有効期限が注意深く選択されている限り、これは通常、意味の透明性を保持します。有効期限メカニズムは、キャッシュから取得された応答にのみ適用され、要求元のクライアントに直ちに転送される直接的な応答には適用されません。オリジンサーバーが意味的に透過的なキャッシュにすべてのリクエストを検証させたい場合、過去の有効期限を明示的に割り当てることができます。これは、応答が常に古くなっていることを意味します。したがって、キャッシュは、後続の要求に使用する前にそれを検証する必要があります（SHOULD）。見る &lt;a href=&quot;#section-14.9.4&quot;&gt;&lt;/a&gt;再検証を強制するより制限的な方法については、セクション14.9.4を参照してください。オリジンサーバーが、どのように構成されていても、すべてのリクエストを検証するためにHTTP / 1.1キャッシュを強制したい場合は、「必須の再検証」キャッシュ制御ディレクティブを使用する必要があります（&lt;a href=&quot;#section-14.9&quot;&gt;セクション14.9を&lt;/a&gt;参照）。サーバーは、ExpiresヘッダーまたはCache-Controlヘッダーのmax-ageディレクティブを使用して、有効期限を明示的に指定します。有効期限を使用して、ユーザーエージェントに表示の更新やリソースの再読み込みを強制することはできません。そのセマンティクスはキャッシングメカニズムにのみ適用され、そのようなメカニズムは、そのリソースに対する新しいリクエストが開始されたときに、リソースの有効期限ステータスをチェックするだけで済みます。&lt;a href=&quot;#section-13.13&quot;&gt;セクション13.13を&lt;/a&gt;参照 キャッシュと履歴メカニズムの違いについては、</target>
        </trans-unit>
        <trans-unit id="7f76c971673910b6c1b10deaca8522002aada40e" translate="yes" xml:space="preserve">
          <source>HTTP clients are often privy to large amounts of personal information
   (e.g. the user's name, location, mail address, passwords, encryption
   keys, etc.), and SHOULD be very careful to prevent unintentional
   leakage of this information via the HTTP protocol to other sources.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.</source>
          <target state="translated">HTTP クライアントはしばしば大量の個人情報(ユーザの名前、場所、メールアドレス、パスワード、暗号化キーなど)を 扱うことがあり、HTTP プロトコルを介してこの情報が他のソースに意図せずに漏れることを 防ぐために細心の注意を払うべきである[SHOULD]。このような情報の拡散を制御するために、ユーザが便利なインタフェースを提供することを強く推奨し、設計者や実装者はこの分野で特に注意する必要があります。歴史的に見ても、この分野での誤りは、しばしば深刻なセキュリティやプライバシーの問題を引き起こし、実装者の会社に非常に不利な宣伝をもたらすことがわかっています。</target>
        </trans-unit>
        <trans-unit id="0593fb953516cec3cb50e486b7c0cd80aa7ff135" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests</source>
          <target state="translated">HTTP 条件付き要求</target>
        </trans-unit>
        <trans-unit id="a24d61eed6303644578268bb7ece0c747329e619" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.</source>
          <target state="translated">HTTP 条件付きリクエストは、特定のヘッダの値に応じて異なる実行をするリクエストです。これらのヘッダは前提条件を定義しており、前提条件にマッチした場合としなかった場合では、 リクエストの結果は異なります。</target>
        </trans-unit>
        <trans-unit id="7cb9523b16d3c9a97f6ddd095333da9f953ccd3f" translate="yes" xml:space="preserve">
          <source>HTTP content negotiation (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) uses short &quot;floating point&quot;
   numbers to indicate the relative importance (&quot;weight&quot;) of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications MUST NOT generate more than three digits after the
   decimal point. User configuration of these values SHOULD also be
   limited in this fashion.

       qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                      | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   &quot;Quality values&quot; is a misnomer, since these values merely represent
   relative degradation in desired quality.</source>
          <target state="translated">HTTPコンテンツネゴシエーション（&lt;a href=&quot;#section-12&quot;&gt;セクション12&lt;/a&gt;）は、短い「浮動小数点」数を使用して、さまざまなネゴシエート可能なパラメーターの相対的な重要度（「重み」）を示します。重みは0から1の範囲の実数に正規化されます。0が最小値、1が最大値です。パラメータの品質値が0の場合、このパラメータのコンテンツはクライアントには「受け入れられません」。 HTTP / 1.1アプリケーションは、小数点以下4桁を生成してはなりません。これらの値のユーザー構成も、この方法で制限する必要があります。 qvalue =（ &quot;0&quot; [&quot;。&quot; 0 * 3DIGIT]）| （ &quot;1&quot; [&quot;。&quot; 0 * 3（ &quot;0&quot;）]） &quot;品質値&quot;は誤称です。これらの値は、単に望ましい品質の相対的な低下を表すためです。</target>
        </trans-unit>
        <trans-unit id="7b89b9e50093443d13f8d95c6b289f93dce89159" translate="yes" xml:space="preserve">
          <source>HTTP cookie</source>
          <target state="translated">HTTPクッキー</target>
        </trans-unit>
        <trans-unit id="49bceea2f43dd4ce87f70babc4ac786f9373fb9b" translate="yes" xml:space="preserve">
          <source>HTTP cookie on Wikipedia</source>
          <target state="translated">ウィキペディアのHTTPクッキー</target>
        </trans-unit>
        <trans-unit id="d913ef28f4b5c9d1334d825b1c91fdfabe426299" translate="yes" xml:space="preserve">
          <source>HTTP cookies</source>
          <target state="translated">HTTTPクッキー</target>
        </trans-unit>
        <trans-unit id="d449bb5c3598a5a64c8ae94493892b59bad9bafe" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;a href=&quot;methods&quot;&gt;request methods&lt;/a&gt; indicating the desired action to be performed upon a resource. Although they can also be nouns, these requests methods are sometimes referred as HTTP verbs. The most common requests are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;:</source>
          <target state="translated">HTTPは、リソースに対して実行する必要なアクションを示す一連の&lt;a href=&quot;methods&quot;&gt;要求メソッド&lt;/a&gt;を定義します。これらは名詞にすることもできますが、これらの要求メソッドはHTTP動詞と呼ばれることもあります。最も一般的なリクエストは &lt;code&gt;GET&lt;/code&gt; および &lt;code&gt;POST&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="30ad447e6db12c17885856bdde1f5bd54513584a" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTPは一連の&lt;strong&gt;リクエストメソッド&lt;/strong&gt;を定義して、特定のリソースに対して実行する必要のあるアクションを示します。これらは名詞にもなりますが、これらのリクエストメソッドは&lt;em&gt;HTTP動詞&lt;/em&gt;と呼ばれることもあり&lt;em&gt;ます&lt;/em&gt;。それぞれが異なるセマンティクスを実装しますが、いくつかの一般的な機能はそれらのグループによって共有されます。たとえば、リクエストメソッドは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全&lt;/a&gt;、べき&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;等&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;キャッシュ可能など&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="98d83c5b67ede465177980174dae53107f9fcd36" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTPは、特定のリソースに対して実行する必要のあるアクションを示す一連の&lt;strong&gt;要求メソッド&lt;/strong&gt;を定義します。名詞にすることもできますが、これらのリクエストメソッドは&lt;em&gt;HTTP動詞&lt;/em&gt;と呼ばれることもあり&lt;em&gt;ます&lt;/em&gt;。それらのそれぞれは異なるセマンティクスを実装しますが、いくつかの共通の機能はそれらのグループによって共有されます。たとえば、リクエストメソッドは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全&lt;/a&gt;、べき&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;等&lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;キャッシュ可能&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4b3823907860c4fbcb228c6adf9d8a7633b5e997" translate="yes" xml:space="preserve">
          <source>HTTP defines many headers that can be used in WebDAV requests and
   responses.  Not all of these are appropriate in all situations and
   some interactions may be undefined.  Note that HTTP 1.1 requires the
   Date header in all responses if possible (see &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).

   The server MUST do authorization checks before checking any HTTP
   conditional header.</source>
          <target state="translated">HTTPは、WebDAV要求および応答で使用できる多くのヘッダーを定義します。これらのすべてがすべての状況に適しているわけではなく、一部の相互作用は未定義である場合があります。 HTTP 1.1では、可​​能であればすべての応答にDateヘッダーが必要であることに注意してください（&lt;a href=&quot;#section-14.18&quot;&gt;セクション14.18&lt;/a&gt;、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]を参照）。サーバーは、HTTP条件付きヘッダーをチェックする前に、承認チェックを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a133de8128e059a1d8a37cda84e730f09f27e2d" translate="yes" xml:space="preserve">
          <source>HTTP defines the Location header to indicate a preferred URL for the
   resource that was addressed in the Request-URI (e.g., in response to
   successful PUT requests or in redirect responses).  However, use of
   this header creates ambiguity when there are URLs in the body of the
   response, as with Multi-Status.  Thus, use of the Location header
   with the Multi-Status response is intentionally undefined.</source>
          <target state="translated">HTTP は、Request-URI で指定されたリソースの優先 URL を示すために Location ヘッダを定義している (例えば、PUT リクエストに成功した場合やリダイレクト応答の場合)。しかし、このヘッダを使用すると、Multi-Statusのように、応答の本文にURLがある場合には、 曖昧さが生じる。したがって、Multi-Status レスポンスで Location ヘッダを使用することは意図的に定義されていない。</target>
        </trans-unit>
        <trans-unit id="3a87bd3891b7e9c3d201f6e5eb6fa13e129baa69" translate="yes" xml:space="preserve">
          <source>HTTP didn't stop evolving upon the release of HTTP/2. Like with HTTP/1.x previously, HTTP's extensibility is still being used to add new features. Notably, we can cite new extensions of the HTTP protocol appearing in 2016:</source>
          <target state="translated">HTTPはHTTP/2がリリースされても進化を止めませんでした。以前のHTTP/1.xと同様に、HTTPの拡張性は今でも新しい機能を追加するために利用されています。注目すべきは、2016年に登場したHTTPプロトコルの新しい拡張機能を挙げることができます。</target>
        </trans-unit>
        <trans-unit id="b88a5eff6f325b12d08c43e0aa22f6a60e181d3d" translate="yes" xml:space="preserve">
          <source>HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completeness.  Additional integrity
   mechanisms, such as hash functions or digital signatures applied to
   the content, can be selectively added to messages via extensible 

   metadata header fields.  Historically, the lack of a single integrity
   mechanism has been justified by the informal nature of most HTTP
   communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within
   environments where verification of message integrity is crucial.

   User agents are encouraged to implement configurable means for
   detecting and reporting failures of message integrity such that those
   means can be enabled within environments for which integrity is
   necessary.  For example, a browser being used to view medical history
   or drug interaction information needs to indicate to the user when
   such information is detected by the protocol to be incomplete,
   expired, or corrupted during transfer.  Such mechanisms might be
   selectively enabled via user agent extensions or the presence of
   message integrity metadata in a response.  At a minimum, user agents
   ought to provide some indication that allows a user to distinguish
   between a complete and incomplete response message (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;) when
   such verification is desired.</source>
          <target state="translated">HTTPは、メッセージの整合性を保証するための特定のメカニズムを定義していません。代わりに、基礎となるトランスポートプロトコルのエラー検出機能と、完全性を検出するための長さまたはチャンク区切りのフレーミングの使用に依存しています。コンテンツに適用されるハッシュ関数やデジタル署名などの追加の整合性メカニズムは、拡張可能なメタデータヘッダーフィールドを介してメッセージに選択的に追加できます。歴史的に、単一の整合性メカニズムの欠如は、ほとんどのHTTP通信の非公式な性質によって正当化されてきました。ただし、情報アクセスメカニズムとしてのHTTPの普及により、メッセージの整合性の検証が重要な環境での使用が増加しています。ユーザーエージェントは、メッセージの整合性の障害を検出および報告する構成可能な手段を実装して、整合性が必要な環境内でそれらの手段を有効にできるようにすることをお勧めします。たとえば、病歴または薬物相互作用情報を表示するために使用されているブラウザは、転送中にそのような情報がプロトコルによって検出されたときに、不完全、期限切れ、または破損していることをユーザーに示す必要があります。このようなメカニズムは、ユーザーエージェント拡張機能や応答のメッセージ整合性メタデータの存在を介して選択的に有効にすることができます。少なくとも、ユーザーエージェントは、ユーザーが完全な応答メッセージと不完全な応答メッセージを区別できるようにする何らかの指示を提供する必要があります（たとえば、病歴または薬物相互作用情報を表示するために使用されているブラウザは、転送中にそのような情報がプロトコルによって検出されたときに、不完全、期限切れ、または破損していることをユーザーに示す必要があります。このようなメカニズムは、ユーザーエージェント拡張機能や応答のメッセージ整合性メタデータの存在を介して選択的に有効にすることができます。少なくとも、ユーザーエージェントは、ユーザーが完全な応答メッセージと不完全な応答メッセージを区別できるようにする何らかの指示を提供する必要があります（たとえば、病歴または薬物相互作用情報を表示するために使用されているブラウザは、転送中にそのような情報がプロトコルによって検出されたときに、不完全、期限切れ、または破損していることをユーザーに示す必要があります。このようなメカニズムは、ユーザーエージェント拡張機能や応答のメッセージ整合性メタデータの存在を介して選択的に有効にすることができます。少なくとも、ユーザーエージェントは、ユーザーが完全な応答メッセージと不完全な応答メッセージを区別できるようにする何らかの指示を提供する必要があります（このようなメカニズムは、ユーザーエージェント拡張機能や応答のメッセージ整合性メタデータの存在を介して選択的に有効にすることができます。少なくとも、ユーザーエージェントは、ユーザーが完全な応答メッセージと不完全な応答メッセージを区別できるようにする何らかの指示を提供する必要があります（このようなメカニズムは、ユーザーエージェント拡張機能や応答のメッセージ整合性メタデータの存在を介して選択的に有効にすることができます。少なくとも、ユーザーエージェントは、ユーザーが完全な応答メッセージと不完全な応答メッセージを区別できるようにする何らかの指示を提供する必要があります（&lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4&lt;/a&gt;）このような検証が必要な場合。</target>
        </trans-unit>
        <trans-unit id="87d2894d742e24a75af2f1ab57c0987684b7ec4b" translate="yes" xml:space="preserve">
          <source>HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond
   exactly to the order in which requests are made on the same
   connection.  More than one response message per request only occurs
   when one or more informational responses (1xx, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Section&amp;nbsp;6.2 of
   [RFC7231]&lt;/a&gt;) precede a final response to the same request. 

   A client that has more than one outstanding request on a connection
   MUST maintain a list of outstanding requests in the order sent and
   MUST associate each received response message on that connection to
   the highest ordered request that has not yet received a final
   (non-1xx) response.</source>
          <target state="translated">HTTPには、特定の要求メッセージを対応する1つ以上の応答メッセージに関連付けるための要求識別子は含まれていません。したがって、同じ接続で要求が行われた順序に正確に対応するために、応答の到着順序に依存しています。リクエストごとに複数の応答メッセージが発生するのは、1つ以上の情報応答（1xx、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231]のセクション6.2を&lt;/a&gt;参照）が同じリクエストに対する最終応答の前にある場合のみです。接続上に複数の未処理の要求があるクライアントは、送信された順序で未処理の要求のリストを維持しなければならず、その接続で受信した各応答メッセージを、まだ最終（1xx以外）を受信して​​いない最上位の要求に関連付けなければなりません（MUST）。応答。</target>
        </trans-unit>
        <trans-unit id="125fe50c360004e5dcd111f8af56cce35d120574" translate="yes" xml:space="preserve">
          <source>HTTP does not place a predefined limit on the length of each header
   field or on the length of the header section as a whole, as described
   in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  Various ad hoc limitations on individual header
   field length are found in practice, often depending on the specific
   field semantics.

   A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   A client MAY discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are
   such that the dropped value(s) can be safely ignored without changing
   the message framing or response semantics.</source>
          <target state="translated">&lt;a href=&quot;#section-2.5&quot;&gt;セクション2.5で&lt;/a&gt;説明されているように、HTTPは、各ヘッダーフィールドの長さやヘッダーセクション全体の長さを事前に定義しません。個々のヘッダーフィールドの長さに関するさまざまなアドホック制限が実際に見られます。多くの場合、特定のフィールドセマンティクスによって異なります。処理したいサイズより大きいリクエストヘッダーフィールドまたはフィールドセットを受信するサーバーは、適切な4xx（クライアントエラー）ステータスコードで応答する必要があります。このようなヘッダーフィールドを無視すると、サーバーの脆弱性が高まり、密輸攻撃がリクエストされます（&lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt;）。クライアントは、フィールドのセマンティクスがメッセージのフレーミングまたは応答のセマンティクスを変更せずにドロップされた値を安全に無視できるようなものである場合、クライアントが処理したいより大きい受信ヘッダーフィールドを破棄または切り捨てることができます。</target>
        </trans-unit>
        <trans-unit id="7af78e2e7197dc15cd8324e0e4f1f29b3b33d7e4" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding (CTE) field of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways from MIME-compliant protocols to HTTP MUST
   remove any non-identity CTE (&quot;quoted-printable&quot; or &quot;base64&quot;) encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe 

   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway SHOULD label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.</source>
          <target state="translated">HTTPは&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;のContent-Transfer-Encoding（CTE）フィールドを使用しません。 MIME準拠プロトコルからHTTPへのプロキシとゲートウェイは、応答メッセージをHTTPクライアントに配信する前に、非ID CTE（ &quot;quoted-printable&quot;または &quot;base64&quot;）エンコーディングを削除する必要があります。 HTTPからMIME準拠のプロトコルへのプロキシとゲートウェイは、メッセージがそのプロトコルでの安全なトランスポートのための正しい形式とエンコーディングであることを保証する責任があります。「安全なトランスポート」は、使用されるプロトコルの制限によって定義されます。このようなプロキシまたはゲートウェイは、適切なContent-Transfer-Encodingでデータにラベルを付ける必要があります（SHOULD）。そうすることで、宛先プロトコルを介した安全な転送の可能性が向上します。</target>
        </trans-unit>
        <trans-unit id="983fa6dde64a744fecec4d6eaeb6ead62114677a" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe
   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.</source>
          <target state="translated">HTTP は MIME の Content-Transfer-Encoding フィールドを使用しません。MIME 準拠プロトコルから HTTP へのプロキシとゲートウェイは、HTTP クライアントに応答メッセージを配信する前に、任意の Content-Transfer-Encoding を削除する必要があります。HTTPからMIME準拠プロトコルへのプロキシとゲートウェイは、メッセージがそのプロトコル上の安全なトランスポートのための正しいフォーマットとエンコーディングであることを保証する責任がありますが、「安全なトランスポート」は使用されるプロトコルの制限によって定義されます。そのようなプロキシやゲートウェイは、そうすることで宛先プロトコル上の 安全なトランスポートの可能性が向上する場合、適切なContent-Transfer-Encodingで データを変換してラベルを付けるべきである。</target>
        </trans-unit>
        <trans-unit id="b9046bf180bf7e78db825b7e37fce06636dac2f9" translate="yes" xml:space="preserve">
          <source>HTTP enables the use of intermediaries to satisfy requests through a
   chain of connections.  There are three common forms of HTTP
   intermediary: proxy, gateway, and tunnel.  In some cases, a single
   intermediary might act as an origin server, proxy, gateway, or
   tunnel, switching behavior based on the nature of each request.

            &amp;gt;             &amp;gt;             &amp;gt;             &amp;gt;
       UA =========== A =========== B =========== C =========== O
                  &amp;lt;             &amp;lt;             &amp;lt;             &amp;lt;

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server.  A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options might apply only to the connection
   with the nearest, non-tunnel neighbor, only to the endpoints of the
   chain, or to all connections along the chain.  Although the diagram
   is linear, each participant might be engaged in multiple,
   simultaneous communications.  For example, B might be receiving
   requests from many clients other than A, and/or forwarding requests
   to servers other than C, at the same time that it is handling A's 

   request.  Likewise, later requests might be sent through a different
   path of connections, often based on dynamic configuration for load
   balancing.

   The terms &quot;upstream&quot; and &quot;downstream&quot; are used to describe
   directional requirements in relation to the message flow: all
   messages flow from upstream to downstream.  The terms &quot;inbound&quot; and
   &quot;outbound&quot; are used to describe directional requirements in relation
   to the request route: &quot;inbound&quot; means toward the origin server and
   &quot;outbound&quot; means toward the user agent.

   A &quot;proxy&quot; is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some
   translations are minimal, such as for proxy requests for &quot;http&quot; URIs,
   whereas other requests might require translation to and from entirely
   different application-level protocols.  Proxies are often used to
   group an organization's HTTP requests through a common intermediary
   for the sake of security, annotation services, or shared caching.
   Some proxies are designed to apply transformations to selected
   messages or payloads while they are being forwarded, as described in
   &lt;a href=&quot;#section-5.7.2&quot;&gt;Section 5.7.2&lt;/a&gt;.

   A &quot;gateway&quot; (a.k.a. &quot;reverse proxy&quot;) is an intermediary that acts as
   an origin server for the outbound connection but translates received
   requests and forwards them inbound to another server or servers.
   Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   &quot;accelerator&quot; caching, and to enable partitioning or load balancing
   of HTTP services across multiple machines.

   All HTTP requirements applicable to an origin server also apply to
   the outbound communication of a gateway.  A gateway communicates with
   inbound servers using any protocol that it desires, including private
   extensions to HTTP that are outside the scope of this specification.
   However, an HTTP-to-HTTP gateway that wishes to interoperate with
   third-party HTTP servers ought to conform to user agent requirements
   on the gateway's inbound connection.

   A &quot;tunnel&quot; acts as a blind relay between two connections without
   changing the messages.  Once active, a tunnel is not considered a
   party to the HTTP communication, though the tunnel might have been
   initiated by an HTTP request.  A tunnel ceases to exist when both
   ends of the relayed connection are closed.  Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) is used to establish
   confidential communication through a shared firewall proxy. 

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also
   intermediaries that can act on lower layers of the network protocol
   stack, filtering or redirecting HTTP traffic without the knowledge or
   permission of message senders.  Network intermediaries are
   indistinguishable (at a protocol level) from a man-in-the-middle
   attack, often introducing security flaws or interoperability problems
   due to mistakenly violating HTTP semantics.

   For example, an &quot;interception proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt;] (also commonly known
   as a &quot;transparent proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] or &quot;captive portal&quot;) differs from
   an HTTP proxy because it is not selected by the client.  Instead, an
   interception proxy filters or redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic).  Interception proxies
   are commonly found on public network access points, as a means of
   enforcing account subscription prior to allowing use of non-local
   Internet services, and within corporate firewalls to enforce network
   usage policies.

   HTTP is defined as a stateless protocol, meaning that each request
   message can be understood in isolation.  Many implementations depend
   on HTTP's stateless design in order to reuse proxied connections or
   dynamically load balance requests across multiple servers.  Hence, a
   server MUST NOT assume that two requests on the same connection are
   from the same user agent unless the connection is secured and
   specific to that agent.  Some non-standard HTTP extensions (e.g.,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt;]) have been known to violate this requirement, resulting in
   security and interoperability problems.</source>
          <target state="translated">HTTPを使用すると、仲介者を使用して、一連の接続を通じて要求を満たすことができます。 HTTP仲介には、プロキシ、ゲートウェイ、トンネルの3つの一般的な形式があります。場合によっては、単一の仲介者がオリジンサーバー、プロキシ、ゲートウェイ、またはトンネルとして機能し、各リクエストの性質に基づいて動作を切り替えます。 &amp;gt;&amp;gt;&amp;gt;&amp;gt; UA =========== A =========== B =========== C ========= == O &amp;lt;&amp;lt;&amp;lt;&amp;lt;上の図は、ユーザーエージェントと配信元サーバーの間の3つの仲介者（A、B、C）を示しています。チェーン全体を移動する要求または応答メッセージは、4つの個別の接続を通過します。一部のHTTP通信オプションは、最も近いものとの接続にのみ適用される場合があります。非トンネルネイバー、チェーンのエンドポイントのみ、またはチェーンに沿ったすべての接続。図は直線的ですが、各参加者は複数の同時通信に従事している場合があります。たとえば、Bは、A以外の多くのクライアントからの要求を受信したり、C以外のサーバーに要求を転送したりすると同時に、Aの要求を処理している可能性があります。同様に、後の要求は、多くの場合、ロードバランシングの動的構成に基づいて、別の接続パスを介して送信される可能性があります。 「アップストリーム」および「ダウンストリーム」という用語は、メッセージフローに関連する方向要件を説明するために使用されます。すべてのメッセージは、アップストリームからダウンストリームに流れます。 「インバウンド」と「アウトバウンド」という用語要求ルートに関連する方向要件を説明するために使用されます。「インバウンド」はオリジンサーバーに向かうことを意味し、「アウトバウンド」はユーザーエージェントに向かうことを意味します。 「プロキシ」は、クライアントによって選択されたメッセージ転送エージェントであり、通常はローカル構成ルールを介して、特定のタイプの絶対URIの要求を受信し、HTTPインターフェースを介した変換を介してそれらの要求を満たすことを試みます。 「http」URIのプロキシ要求など、一部の変換は最小限ですが、他の要求では、まったく異なるアプリケーションレベルのプロトコルとの間の変換が必要になる場合があります。プロキシは、セキュリティ、注釈サービス、または共有キャッシュのために、一般的な中間手段を介して組織のHTTPリクエストをグループ化するためによく使用されます。一部のプロキシは、転送中に選択されたメッセージまたはペイロードに変換を適用するように設計されています。 &lt;a href=&quot;#section-5.7.2&quot;&gt;セクション5.7.2&lt;/a&gt;。 「ゲートウェイ」（別名「リバースプロキシ」）は、アウトバウンド接続のオリジンサーバーとして機能しますが、受信したリクエストを変換し、インバウンドで別のサーバーに転送します。ゲートウェイは、多くの場合、レガシーまたは信頼できない情報サービスをカプセル化し、「アクセラレータ」キャッシングを通じてサーバーのパフォーマンスを向上させ、複数のマシン間でのHTTPサービスのパーティショニングまたはロードバランシングを可能にするために使用されます。オリジンサーバーに適用されるすべてのHTTP要件は、ゲートウェイのアウトバウンド通信にも適用されます。ゲートウェイは、この仕様の範囲外であるHTTPへのプライベート拡張を含め、必要なプロトコルを使用してインバウンドサーバーと通信します。しかしながら、サードパーティのHTTPサーバーと相互運用するHTTP-to-HTTPゲートウェイは、ゲートウェイのインバウンド接続のユーザーエージェント要件に準拠する必要があります。 「トンネル」は、メッセージを変更せずに2つの接続間のブラインドリレーとして機能します。いったんアクティブになると、トンネルはHTTP通信の当事者とは見なされませんが、トンネルはHTTP要求によって開始された可能性があります。リレーされた接続の両端が閉じられると、トンネルは存在しなくなります。トンネルは、トランスポート層セキュリティ（TLS、[トンネルはHTTP要求によって開始された可能性がありますが、トンネルはHTTP通信の当事者とは見なされません。リレーされた接続の両端が閉じられると、トンネルは存在しなくなります。トンネルは、トランスポート層セキュリティ（TLS、[トンネルはHTTP要求によって開始された可能性がありますが、トンネルはHTTP通信の当事者とは見なされません。リレーされた接続の両端が閉じられると、トンネルは存在しなくなります。トンネルは、トランスポート層セキュリティ（TLS、[&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）は、共有ファイアウォールプロキシを介して機密通信を確立するために使用されます。上記の仲介者のカテゴリは、HTTP通信の参加者として機能するもののみを考慮しています。ネットワークプロトコルスタックの下位層で動作し、メッセージ送信者の知識や許可なしにHTTPトラフィックをフィルタリングまたはリダイレクトできる仲介者もいます。ネットワーク仲介者は、中間者攻撃と（プロトコルレベルで）区別がつかず、誤ってHTTPセマンティクスに違反することにより、セキュリティの欠陥や相互運用性の問題を引き起こすことがよくあります。たとえば、「インターセプトプロキシ」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ]（「トランスペアレントプロキシ」とも呼ばれる[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;]または「キャプティブポータル」）は、クライアントによって選択されないため、HTTPプロキシとは異なります。代わりに、代行受信プロキシが発信TCPポート80パケット（および場合によっては他の一般的なポートトラフィック）をフィルタリングまたはリダイレクトします。傍受プロキシは一般に、非ローカルインターネットサービスの使用を許可する前にアカウントサブスクリプションを適用する手段として、および企業ファイアウォール内でネットワーク使用ポリシーを実施する手段として、パブリックネットワークアクセスポイントにあります。 HTTPはステートレスプロトコルとして定義されています。つまり、各要求メッセージを個別に理解できます。多くの実装は、プロキシされた接続を再利用したり、複数のサーバー間で要求を動的に負荷分散したりするために、HTTPのステートレス設計に依存しています。したがって、サーバーは、接続が保護され、そのエージェントに固有でない限り、同じ接続の2つの要求が同じユーザーエージェントからのものであると想定してはなりません（MUST NOT）。一部の非標準のHTTP拡張（例：[&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt; ]）はこの要件に違反し、セキュリティと相互運用性の問題を引き起こすことが知られています。</target>
        </trans-unit>
        <trans-unit id="8db8a2b5c25cf2c27eaf8a47b284cc3768fbc846" translate="yes" xml:space="preserve">
          <source>HTTP flow</source>
          <target state="translated">HTTPフロー</target>
        </trans-unit>
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP フレームは Web 開発者にとって透過的になりました。これは HTTP/1.1 メッセージと基礎となるトランスポートプロトコルの間にある HTTP/2 の追加ステップです。Web 開発者が HTTP フレームを利用するために使用する API に変更は必要ありません。ブラウザとサーバの両方で利用可能な場合、HTTP/2 はスイッチを入れて使用されます。</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTPには&lt;em&gt;条件付きリクエストの&lt;/em&gt;概念があり、影響を受けるリソースを&lt;em&gt;バリデーターの&lt;/em&gt;値と比較することで、結果、さらにはリクエストの成功を変更できます。このようなリクエストは、キャッシュの内容を検証し、役に立たないコントロールを節約し、ダウンロードを再開するときや、サーバーでドキュメントをアップロードまたは変更するときに更新が失われないようにする場合などに、ドキュメントの整合性を検証するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTPは1990年から使用されています。最初のバージョン（後でHTTP / 0.9と呼ばれる）は、単一の要求メソッド（GET）のみを使用し、メタデータを使用しない、インターネットを介したハイパーテキストデータ転送用のシンプルなプロトコルでした。 HTTP / 1.0、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]、一連のリクエストメソッドとMIMEのようなメッセージングを追加し、メタデータを転送し、リクエスト/レスポンスのセマンティクスに修飾子を配置できるようにしました。ただし、HTTP / 1.0では、階層プロキシ、キャッシュ、永続的な接続の必要性、または名前ベースの仮想ホストの影響を十分に考慮していませんでした。 「HTTP / 1.0」と呼ばれる不完全に実装されたアプリケーションの急増により、通信している2つのアプリケーションが互いの真の機能を判断するために、プロトコルバージョンの変更がさらに必要になりました。 HTTP / 1.1は、信頼性の高い実装を可能にするより厳しい要件を含め、HTTP / 1と安全に無視できる機能のみを追加することにより、HTTP / 1.0との互換性を維持しています。受信者0人、またはHTTP / 1.1への適合を宣伝する当事者と通信するときにのみ送信されます。 HTTP / 1.1は、以前のバージョンを簡単にサポートできるように設計されています。汎用のHTTP / 1.1サーバーは、HTTP / 1.0の形式で有効なリクエストを理解でき、HTTP / 1.0クライアントが理解した（または安全に無視した）機能のみを使用するHTTP / 1.1メッセージで適切に応答する必要があります。同様に、HTTP / 1.1クライアントは、有効なHTTP / 1.0応答を理解することが期待できます。 HTTP / 0.9はリクエストのヘッダーフィールドをサポートしていなかったため、名前ベースの仮想ホスト（ホストヘッダーフィールドの検査によるリソースの選択）をサポートするメカニズムはありません。名前ベースの仮想ホストを実装するサーバーは、HTTP / 0.9のサポートを無効にする必要があります。 HTTP / 0のように見えるほとんどのリクエスト。実際、9つは、クライアントがリクエストターゲットを適切にエンコードできなかったために発生した、正しく構成されていないHTTP / 1.xリクエストです。</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP は、クライアントマシン上で実行されるプログラムをホストする機能を持っています。これらのプログラムは、Web スクリプト、実行可能ファイル、プラグインモジュール、ドキュメント内のマクロなど、多くの形態をとることができます。WebDAV はこれらのプログラムに関するセキュリティ上の懸念事項を変更するものではありませんが、多くの場合、WebDAV は幅広いユーザがサーバ上で文書を公開できるような文脈で使用されています。サーバーは、ドキュメントを公開している作者と密接な信頼関係を持っていないかもしれません。クライアントが任意のコンテンツを公開することを許可しているサーバは、サーバに公開されたコンテンツが他のクライアントに有害でないことを確認するための予防措置を実装することが有用です。サーバーでは、公開を許可するコンテンツの種類を制限したり、公開されたコンテンツに対してウイルスやマルウェアの検出ソフトウェアを実行したりすることで、このような対策を講じることができます。また、サーバーは、適切なアクセス制限と、サーバーへのコンテンツの公開を許可されたユーザーの認証を行うことで、リスクを軽減することができます。</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">HTTPヘッダーフィールドは、[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]で定義されているように、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt;にある「メッセージヘッダー」レジストリ内に登録されます。</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + ------------------- + ---------- + ---------- + ------- -------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- -------- + |接続| http |標準| &lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt; | |コンテンツの長さ| http |標準| &lt;a href=&quot;#section-3.3.2&quot;&gt;セクション3.3.2&lt;/a&gt; | |ホスト| http |標準| &lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt; | | TE | http |標準| &lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt; | |トレーラー| http |標準| &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt; | |転送エンコーディング| http |標準| &lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt; | |アップグレード| http |標準| &lt;a href=&quot;#section-6.7&quot;&gt;セクション6.7&lt;/a&gt; | |経由| http |標準| &lt;a href=&quot;#section-5.7.1&quot;&gt;セクション5.7.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- +さらに、HTTPヘッダーフィールドとしてその名前を使用すると、接続ヘッダーフィールドの「閉じる」接続オプションと競合する可能性があるため、ヘッダーフィールド名「Close」は「予約済み」として登録されています。 （&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）。 + ------------------- + ---------- + ---------- + ------- ------ + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + |閉じる| http |予約済み| &lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + --------------------- + ---------- + ---------- + ----- -------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + --------------------- + ---------- + ---------- + ----- -------- + |認可| http |標準| &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt; | |プロキシ認証| http |標準| &lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt; | |プロキシ認証| http |標準| &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;| | WWW-Authenticate | http |標準| &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、関連するレジストリエントリは、以下の永続的な登録に従って更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）：+ ------------------- + ---------- + ---------- + ------------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + | Accept-Ranges | http |標準| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | |コンテンツ範囲| http |標準| &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt; | | If-Range | http |標準| &lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;| |範囲| http |標準| &lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、関連するレジストリエントリは、以下の永続的な登録に従って更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）：+ ------------------- -+ ---------- + ---------- + ------------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http |標準| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | |イフマッチ| http |標準| &lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt; | | If-Modified-Since | http |標準| &lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;| | If-None-Match | http |標準| &lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt; | | If-Unmodified-Since | http |標準| &lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4&lt;/a&gt; | |最終変更| http |標準| &lt;a href=&quot;#section-2.2&quot;&gt;セクション2.2&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + ------------------- + ---------- + ---------- + ------- ------ + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + |年齢| http |標準| &lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt; | |キャッシュ制御| http |標準| &lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt; | |期限切れ| http |標準| &lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;| | プラグマ| http | 標準| &lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt; | | 警告| http | 標準| &lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">チャンクメッセージのトレーラー部分に存在するHTTPヘッダーフィールド。次のヘッダーフィールドは&lt;strong&gt;許可されていません&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">一般的なヘッダを含むHTTPヘッダフィールドは、（&lt;a href=&quot;#section-4.5&quot;&gt;セクション4.5&lt;/a&gt;）、リクエストヘッダ（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）、応答ヘッダ（&lt;a href=&quot;#section-6.2&quot;&gt;セクション6.2&lt;/a&gt;）、およびエンティティヘッダ（&lt;a href=&quot;#section-7.1&quot;&gt;セクション7.1&lt;/a&gt;）フィールドで与えられたものと同じ一般的なフォーマットに従う&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;セクションRFC 822の3.1&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]。各ヘッダーフィールドは、名前とそれに続くコロン（ &quot;：&quot;）およびフィールド値で構成されます。フィールド名は大文字と小文字を区別しません。フィールド値の前に任意の量のLWSを付けることができますが、単一のSPが推奨されます。ヘッダーフィールドは、追加の各行の前に少なくとも1つのSPまたはHTを付けることにより、複数行に拡張できます。 HTTP構造を生成するとき、アプリケーションは「共通の形式」に従う必要があります。これは、共通の形式以外のものを受け入れない実装が存在する可能性があるためです。メッセージヘッダー=フィールド名 &quot;：&quot; [フィールド値]フィールド名=トークンフィールド値= *（フィールドコンテンツ| LWS）フィールドコンテンツ= &amp;lt;* TEXTまたはトークン、セパレーター、引用符付き文字列の組み合わせで構成されるフィールド値を構成するOCTET&amp;gt;フィールドコンテンツには、先頭または末尾のLWSは含まれません。最初の非空白文字の前に発生する線形空白フィールド値の、またはフィールド値の最後の非空白文字の後。このような先頭または末尾のLWSは、フィールド値のセマンティクスを変更せずに削除できます。フィールドコンテンツ間で発生するすべてのLWSは、フィールド値を解釈したり、メッセージをダウンストリームに転送したりする前に、単一のSPで置き換えることができます。異なるフィールド名を持つヘッダーフィールドが受信される順序は重要ではありません。ただし、最初に一般ヘッダーフィールドを送信することは「適切な方法」です。続いてリクエストヘッダーまたはレスポンスヘッダーフィールドがあり、エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））にのみ、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」のペアに結合することが可能でなければなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））にのみ、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」のペアに結合することが可能でなければなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">HTTPヘッダ</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">HTTPヘッダーを使用すると、クライアントとサーバーは要求または応答とともに追加情報を渡すことができます。 HTTPヘッダーは、大文字と小文字を区別しない名前と、その後に続くコロン「 &lt;code&gt;:&lt;/code&gt; 」、およびその値（改行なし）で構成されます。値の前の空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP ヘッダ、メタ要素、言語情報</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ]実装とコードを共有するHTTP実装は、MIME行の長さの制限に注意する必要があります。 HTTPにはこの制限がないため、HTTPは長い行を折り返しません。 HTTPによって転送されるMHTMLメッセージは、行の長さの制限や折りたたみ、正規化などを含むMHTMLのすべての規則に従います。これは、HTTPがメッセージ本体をペイロードとして転送するため、「multipart / byteranges」タイプは別です（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233の&lt;/a&gt;付録A ] ）、コンテンツまたはそこに含まれる可能性のあるMIMEヘッダー行を解釈しません。</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ]実装とコードを共有するHTTP実装は、MIME行の長さの制限に注意する必要があります。 HTTPにはこの制限がないため、HTTPは長い行を折り返しません。 HTTPはすべてのメッセージ本文をペイロードとして転送し（&lt;a href=&quot;#section-3.7.2&quot;&gt;セクション3.7.2を&lt;/a&gt;参照）、コンテンツやMIMEヘッダーを解釈しないため、HTTPによって転送されるMHTMLメッセージは、行の長さの制限や折りたたみ、正規化など、MHTMLのすべての規則に従います。その中に含まれる可能性のある行。</target>
        </trans-unit>
        <trans-unit id="4924be195f30ae39945dc7a126df600856cfafd8" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response.</source>
          <target state="translated">HTTPは、ブラウザーが好みの形式、言語、またはエンコードをアナウンスする方法として &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; で始まる、一連のヘッダーを導入します。この記事では、このアドバタイズメントがどのように発生するか、サーバーがどのように反応すると予想されるか、およびサーバーが最も適切な応答を選択する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTPでは、ブラウザが好みの形式、言語、またはエンコーディングを通知する方法として、 &lt;code&gt;Accept-&lt;/code&gt; で始まる一連のヘッダーが導入されています。この記事では、このアドバタイズメントがどのように発生するか、サーバーがどのように反応することが期待されるか、サーバーが最も適切な応答を選択する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP はクライアント・サーバ・プロトコルです:リクエストはユーザーエージェント(またはその代理のプロキシ)という1つのエンティティによって送信されます。ほとんどの場合、ユーザーエージェントは Web ブラウザですが、検索エンジンのインデックスを作成・維持するために Web をクロールするロボットなど、どんなものでも構いません。</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP はかなり拡張性の高いプロトコルです。リソースや URI の概念、メッセージのシンプルな構造、通信フローのためのクライアント-サーバ構造など、いくつかの基本的な概念に依存しています。これらの基本的な概念の上に、新しい HTTP メソッドやヘッダを作成することで新しい機能や新しいセマンティクスが追加され、長年にわたって多数の拡張機能が登場してきました。</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTPは、信頼できるトランスポート層またはセッション層の「接続」（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）全体でメッセージを交換することによって動作するステートレスの要求/応答プロトコル（&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）です。）。 HTTP「クライアント」は、1つ以上のHTTP要求を送信する目的でサーバーへの接続を確立するプログラムです。 HTTP「サーバー」は、HTTP応答を送信してHTTP要求を処理するために接続を受け入れるプログラムです。 「クライアント」および「サーバー」という用語は、これらのプログラムが特定の接続に対して実行する役割のみを指します。同じプログラムが一部の接続ではクライアントとして機能し、別の接続ではサーバーとして機能する場合があります。 「ユーザーエージェント」という用語は、ブラウザー、スパイダー（Webベースのロボット）、コマンドラインツール、カスタムアプリケーション、モバイルアプリ（これらに限定されない）を含む、要求を開始するさまざまなクライアントプログラムのいずれかを指します。 「元のサーバー」という用語特定のターゲットリソースに対して信頼できる応答を発信できるプログラムを指します。 「送信者」および「受信者」という用語は、それぞれ特定のメッセージを送信または受信する実装を指します。 HTTPはURI（Uniform Resource Identifier）標準に依存しています[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]ターゲットリソース（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）とリソース間の関係を示す。メッセージは、インターネットメール[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]および多目的インターネットメール拡張（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] で使用されるものと同様の形式で渡されます（[ RFC7231 ]の&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;付録Aを&lt;/a&gt;参照）。HTTPメッセージとMIMEメッセージの違いについて）。ほとんどのHTTP通信は、URIで識別されるリソースの表現に対する取得要求（GET）で構成されています。最も単純なケースでは、これはユーザーエージェント（UA）とオリジンサーバー（O）間の単一の双方向接続（===）を介して行われる可能性があります。リクエスト&amp;gt; UA ======================================= O &amp;lt;応答クライアントがHTTPを送信メソッド、URI、プロトコルバージョンを含むrequest-lineで始まり（&lt;a href=&quot;#section-3.1.1&quot;&gt;セクション3.1.1&lt;/a&gt;）、リクエスト修飾子、クライアント情報、表現メタデータを含むヘッダーフィールドが後に続く、リクエストメッセージの形式でサーバーにリクエストします（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、ヘッダーセクションの終わりを示す空の行、最後にペイロードボディを含むメッセージボディ（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3がある&lt;/a&gt;場合）。サーバーは、1つ以上のHTTP応答メッセージを送信することにより、クライアントの要求に応答します。各メッセージは、プロトコルバージョン、成功またはエラーコード、およびテキストの理由句（&lt;a href=&quot;#section-3.1.2&quot;&gt;セクション3.1.2&lt;/a&gt;）を含むステータス行で始まり、ヘッダーフィールドが続く場合があります。サーバー情報、リソースメタデータ、表現メタデータ（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、ヘッダーセクションの終わりを示す空の行、ペイロード本文を含むメッセージ本文（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3）&lt;/a&gt;）。&lt;a href=&quot;#section-6.3&quot;&gt;セクション6.3で&lt;/a&gt;定義されているように、接続は複数の要求/応答交換に使用される場合があります。次の例は、URI &quot;http://www.example.com/hello.txt&quot; でのGETリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]のセクション4.3.1&lt;/a&gt;）の一般的なメッセージ交換を示しています。クライアントリクエスト：GET /hello.txt HTTP /1.1 User-Agent：curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3 Host：www.example.com Accept-Language：en、miサーバーの応答：HTTP / 1.1 200 OK日付： 2009年7月27日月曜日12:28:53 GMTサーバー：Apache最終変更日：2009年7月22日水曜日19:15:56 GMT ETag： &quot;34aa387-d-1568eb00&quot; Accept-Ranges：bytes Content-Length：51 Vary： Accept-Encoding Content-Type：text / plain Hello World！ペイロードに末尾のCRLFが含まれています。</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP は使いやすい拡張可能なプロトコルです。クライアントとサーバの構造と、ヘッダを簡単に追加できる機能を組み合わせることで、HTTP はウェブの拡張機能に合わせて進化していきます。</target>
        </trans-unit>
        <trans-unit id="bbcb125f3701fe50926501831f8f7ee161444b57" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), simple message structure, and client-server communication flow. On top of these basic concepts, numerous extensions have been developed over the years that add updated functionality and semantics with new HTTP methods or headers.</source>
          <target state="translated">HTTP は、リソースや URI (Uniform Resource Identifiers)のような概念、シンプルなメッセージ構造、クライアントとサーバの通信フローに依存した拡張可能なプロトコルです。これらの基本的な概念の上に、新しい HTTP メソッドやヘッダで更新された機能やセマンティクスを追加する多数の拡張機能が長年にわたって開発されてきました。</target>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP は拡張可能</target>
        </trans-unit>
        <trans-unit id="18ad92cc7b82eb0d0efdfdb9ee61c4c2a39d270e" translate="yes" xml:space="preserve">
          <source>HTTP is generally designed to be simple and human readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.</source>
          <target state="translated">HTTPは一般的に、HTTPメッセージをフレームにカプセル化することでHTTP/2で導入された複雑さを考慮しても、シンプルで人間が読めるように設計されています。HTTPメッセージは人間が読んで理解することができるので、開発者にとってはテストが容易になり、新規参入者にとっては複雑さが軽減されます。</target>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTPは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同じ生成元のポリシー&lt;/a&gt;であるWebのセキュリティモデルから独立しています。実際、現在のWebセキュリティモデルは、HTTPの作成後に開発されました。長年にわたり、特定の制約の下でこのポリシーの制限の一部を解除できるようにすることで、より寛大になることができることが有用であることが証明されています。そのような制限が解除される量と時期は、新しい一連のHTTPヘッダーを使用してサーバーからクライアントに送信されます。これらは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;クロスオリジンリソースシェアリング&lt;/a&gt;（CORS）や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;コンテンツセキュリティポリシー&lt;/a&gt;（CSP）などの仕様で定義されています。</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTPはMIME準拠のプロトコルではありません。ただし、メッセージには、メッセージの作成に使用されたMIMEプロトコルのバージョンを示す単一のMIME-Versionヘッダーフィールドを含めることができます。 MIME-Versionヘッダーフィールドの使用は、メッセージがMIMEプロトコル（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]で定義されている）に完全に準拠していることを示します。送信者は、HTTPメッセージを厳密なMIME環境にエクスポートするときに、（可能な場合）完全な準拠を保証する責任があります。</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTPはMIME準拠のプロトコルではありません。ただし、HTTP / 1.1メッセージには、メッセージの作成に使用されたMIMEプロトコルのバージョンを示す単一のMIME-Version general-headerフィールドが含まれる場合があります。 MIME-Versionヘッダーフィールドの使用は、メッセージがMIMEプロトコル（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]で定義されている）に完全に準拠していることを示します。プロキシ/ゲートウェイは、HTTPメッセージを厳密なMIME環境にエクスポートするときに、（可能な場合）完全なコンプライアンスを保証する責任があります。 MIME-Version = &quot;MIME-Version&quot; &quot;：&quot; 1 * DIGIT &quot;。&quot; 1 * DIGIT MIMEバージョン &quot;1.0&quot;は、HTTP / 1.1で使用するデフォルトです。ただし、HTTP / 1.1メッセージの解析とセマンティクスは、MIME仕様ではなく、このドキュメントで定義されています。</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTPは簡単です。</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP はステートレスですが、セッションレスではありません。</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP はステートレスです:2 つのリクエストが同じ接続上で連続して実行される間のリンクはありません。これは、例えば e コマースのショッピングバスケットを使って特定のページを一貫して操作しようとするユーザーにとっては、すぐに問題となる可能性があります。しかし、HTTP のコアはステートレスですが、HTTP クッキーはステートフルなセッションの使用を可能にします。ヘッダの拡張性を利用して、HTTP クッキーがワークフローに追加され、各 HTTP リクエストで同じコンテキストや同じ状態を共有してセッションを作成できるようになりました。</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTPは通常、応答キャッシュを使用することでパフォーマンスを向上できる分散情報システムに使用されます。このドキュメントでは、応答メッセージのキャッシュと再利用に関連するHTTP / 1.1の側面を定義します。 HTTPキャッシュは、応答メッセージのローカルストアであり、その中のメッセージの格納、取得、および削除を制御するサブシステムです。キャッシュは、将来の同等の要求での応答時間とネットワーク帯域幅の消費を削減するために、キャッシュ可能な応答を格納します。トンネルとして機能しているサーバーはキャッシュを使用できませんが、クライアントまたはサーバーはキャッシュを使用できます（MAY）。共有キャッシュは、複数のユーザーが再利用する応答を格納するキャッシュです。共有キャッシュは通常（常にではありませんが）仲介者の一部として配備されます。対照的に、プライベートキャッシュシングルユーザー専用です。多くの場合、これらはユーザーエージェントのコンポーネントとして展開されます。 HTTP / 1.1でのキャッシングの目的は、現在の要求を満たすために以前の応答メッセージを再利用することにより、パフォーマンスを大幅に改善することです。保存された応答は、「新しい」と見なされます。 &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt;、「検証」なしで応答を再利用できる場合（キャッシュされた応答がこの要求に対して有効であるかどうかをオリジンサーバーに確認する）。したがって、新しい応答は、再利用されるたびにレイテンシとネットワークオーバーヘッドの両方を削減できます。キャッシュされた応答が最新でない場合でも、検証によって更新できる場合（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）、または発信元が使用できない場合（&lt;a href=&quot;#section-4.2.4&quot;&gt;セクション4.2.4&lt;/a&gt;）は、再利用できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTPは通常、応答キャッシュを使用することでパフォーマンスを向上できる分散情報システムに使用されます。 HTTP / 1.1プロトコルには、キャッシングを可能な限り機能させることを目的とした多数の要素が含まれています。これらの要素はプロトコルの他の側面から切り離せないため、また相互にやり取りするため、メソッド、ヘッダー、応答コードなどの詳細な説明とは別に、HTTPの基本的なキャッシングデザインを説明すると便利です。キャッシングは役に立ちませんパフォーマンスが大幅に改善されなかった場合。 HTTP / 1.1でのキャッシングの目標は、多くの場合に要求を送信する必要をなくし、他の多くの場合に完全な応答を送信する必要をなくすことです。前者は、多くの操作に必要なネットワークラウンドトリップの数を減らします。この目的のために「有効期限」メカニズムを使用します（&lt;a href=&quot;#section-13.2&quot;&gt;セクション13.2&lt;/a&gt;）。後者は、ネットワーク帯域幅の要件を軽減します。この目的のために「検証」メカニズムを使用します（&lt;a href=&quot;#section-13.3&quot;&gt;セクション13.3を&lt;/a&gt;参照））。パフォーマンス、可用性、非接続操作の要件により、セマンティックの透明性の目標を緩和できる必要があります。 HTTP / 1.1プロトコルにより、オリジンサーバー、キャッシュ、およびクライアントは、必要に応じて透過性を明示的に減らすことができます。ただし、非透過的な操作は、専門家以外のユーザーを混乱させ、特定のサーバーアプリケーション（商品の注文など）と互換性がない場合があるため、プロトコルは透過性を緩和する必要があります。クライアントまたはオリジンサーバー-キャッシュまたはクライアントによって緩和されたときにエンドユーザーに明示的な警告のみが表示されるため、HTTP / 1.1プロトコルは次の重要な要素を提供します。すべての関係者が必要とする場合に、完全なセマンティックの透過性を提供するプロトコル機能。 2.オリジンサーバーまたはユーザーエージェントが非透過的な操作を明示的に要求および制御できるようにするプロトコル機能。 3.要求されたセマンティック透明度の近似を保持しない応答にキャッシュが警告を添付できるようにするプロトコル機能。基本的な原則は、クライアントが意味の透明性の潜在的な緩和を検出できる必要があることです。注：サーバー、キャッシュ、またはクライアントの実装者は、この仕様で明示的に説明されていない設計上の決定に直面する可能性があります。決定が意味の透明性に影響を与える可能性がある場合、実装者は、慎重かつ完全な分析が透明性を破る上で重要な利点を示さない限り、透明性を維持する側で誤りを犯すべきです。</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTPは、汎用コンピュータから家電製品まで、さまざまなアプリケーションで使用されています。場合によっては、通信オプションはクライアントの構成にハードコーディングされます。ただし、ほとんどのHTTPクライアントは、汎用のWebブラウザーと同じリソース識別メカニズムと構成手法に依存しています。 HTTP通信は、何らかの目的でユーザーエージェントによって開始されます。その目的は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]で定義されている要求のセマンティクスと、それらのセマンティクスを適用するターゲットリソースの組み合わせです。 URI参照（&lt;a href=&quot;#section-2.7&quot;&gt;セクション2.7&lt;/a&gt;）は通常、「ターゲットリソース」の識別子として使用されます。ユーザーエージェントは、「ターゲットURI」を取得するためにその絶対形式に解決します。フラグメント識別子はクライアント側の処理用に予約されているため（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]、セクション3.5&lt;/a&gt;）、ターゲットURIは参照のフラグメントコンポーネントを除外します（ある場合）。</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">HTTPメッセージヘッダーは、リソース、またはサーバーやクライアントの動作を記述するために使用されます。 &lt;code&gt;X-&lt;/code&gt; プレフィックスを使用して、独自のカスタムヘッダーを追加できます。&lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANAレジストリの&lt;/a&gt;その他のもの。元のコンテンツは&lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229で&lt;/a&gt;定義されています。IANA &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;は、提案された新しいHTTPメッセージヘッダーのレジストリ&lt;/a&gt;も維持します。</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">HTTP メッセージは ASCII でエンコードされたテキスト情報で構成されており、複数行にわたっています。HTTP/1.1やそれ以前のバージョンのプロトコルでは、これらのメッセージは接続を介してオープンに送信されていました。HTTP/2では、かつては人間が読めるメッセージがHTTPフレームに分割され、最適化とパフォーマンスの向上が図られています。</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">HTTPメッセージは、サーバーとクライアント間でデータが交換される方法です。メッセージには2つのタイプがあります。サーバーからのアクションをトリガーするためにクライアントから送信される&lt;em&gt;要求&lt;/em&gt;と、サーバーからの&lt;em&gt;応答&lt;/em&gt;である応答です。</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP メッセージは HTTP を使う上で重要なものです。HTTP/2 フレーム機構は、HTTP/1.x 構文と基本的なトランスポートプロトコルの間に新しい中間層を追加しますが、根本的に変更することはありません。</target>
        </trans-unit>
        <trans-unit id="891aa548a3155a7bc116f727c4c9e489c435ed0b" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple, and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP メッセージは HTTP を使う上で重要なものです。HTTP/2 フレーム機構は、HTTP/1.x 構文と基本的なトランスポートプロトコルの間に新しい中間層を追加しますが、根本的に変更することはありません。</target>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">HTTPメッセージは、クライアントからサーバーへの要求とサーバーからクライアントへの応答で構成されます。HTTPメッセージ=リクエスト| 応答; HTTP / 1.1メッセージの要求（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）および応答（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）メッセージは、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]エンティティ（メッセージのペイロード）を転送します。どちらのタイプのメッセージも、開始行、0個以上のヘッダーフィールド（「ヘッダー」とも呼ばれます）、ヘッダーフィールドの終わりを示す空の行（CRLFの前に何もない行）、および場合によってはメッセージ本文。 generic-message = start-line *（message-header CRLF）CRLF [message-body] start-line = Request-Line | Status-Line堅牢性のために、サーバーは、Request-Lineが期待される場所で受信された空の行を無視する必要があります（SHOULD）。つまり、サーバーがメッセージの先頭でプロトコルストリームを読み取り、最初にCRLFを受信した場合、そのCRLFを無視する必要があります。特定のバグのあるHTTP / 1。0クライアントの実装では、POST要求の後に追加のCRLFが生成されます。 BNFによって明示的に禁止されていることを再説明するために、HTTP / 1.1クライアントは、追加のCRLFを使用して要求の前置または後続してはなりません。</target>
        </trans-unit>
        <trans-unit id="a514b96da0b4952018a9659e3ae2424d71abef2e" translate="yes" xml:space="preserve">
          <source>HTTP messages, as defined in HTTP/1.1 and earlier, are human-readable. In HTTP/2, these messages are embedded into a binary structure, a &lt;em&gt;frame&lt;/em&gt;, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP / 1.1以前で定義されているHTTPメッセージは、人間が読める形式です。HTTP / 2では、これらのメッセージはバイナリ構造である&lt;em&gt;フレーム&lt;/em&gt;に埋め込まれているため、ヘッダーの圧縮や多重化などの最適化が可能です。このバージョンのHTTPで元のHTTPメッセージの一部のみが送信された場合でも、各メッセージのセマンティクスは変更されず、クライアントは元のHTTP / 1.1要求を（事実上）再構成します。したがって、HTTP /1.1形式のHTTP / 2メッセージを理解すると便利です。</target>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">HTTPメッセージングは​​、基になるトランスポート層またはセッション層の接続プロトコルには依存しません。 HTTPは、要求の順序どおりの配信と対応する応答の順序どおりの配信を伴う信頼性の高いトランスポートのみを前提としています。 HTTPリクエストおよびレスポンス構造の、基盤となるトランスポートプロトコルのデータユニットへのマッピングは、この仕様の範囲外です。&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;で説明されているように、HTTP対話に使用される特定の接続プロトコルは、クライアント構成とターゲットURIによって決定されます。たとえば、「http」URIスキーム（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）は、TCP over IPのデフォルト接続を示し、デフォルトのTCPポートは80ですが、クライアントは他の接続、ポート、またはプロトコルを介してプロキシを使用するように構成されている場合があります。 HTTP実装は、現在の接続の状態の維持、新しい接続の確立または既存の接続の再利用、接続で受信したメッセージの処理、接続障害の検出、各接続のクローズなどの接続管理に従事することが期待されます。ほとんどのクライアントは、サーバーエンドポイントごとに複数の接続を含め、複数の接続を並行して維持します。ほとんどのサーバーは、リクエストキューを制御してフェアユースを可能にし、サービス拒否攻撃を検出する一方で、数千の同時接続を維持するように設計されています。</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTPメソッドの登録には、次のフィールドを含める必要があります。oメソッド名（&lt;a href=&quot;#section-4&quot;&gt;セクション4を&lt;/a&gt;参照）o安全（ &quot;yes&quot;または &quot;no&quot;、&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1を&lt;/a&gt;参照）oべき等（ &quot;yes&quot;または &quot;no&quot;、&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2を&lt;/a&gt;参照））o仕様テキストへのポインターこの名前空間に追加される値には、IETFレビューが必要です（ &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]、セクション4.1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTPメソッド</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP は、クライアントとサーバ間の接続を提供するトランスポートプロトコルとして、ほとんどの場合 TCP に依存しています。初期の頃、HTTP はこのような接続を処理するために単一のモデルを使用していました。これらの接続は短命でした。リクエストを送信するたびに新しい接続が作成され、応答を受信したら閉じます。</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP パイプライン</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">最近のブラウザでは、HTTP パイプラインはデフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTPは、サーバーがクライアント要求にチャレンジし、クライアントが認証情報を提供するために使用できる、拡張可能なチャレンジ/レスポンス認証スキームのセットを介して、アクセス制御と認証のための一般的なフレームワークを提供します。このドキュメントでは、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されたアーキテクチャの観点から、HTTP / 1.1認証を定義します。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]、および「ハイパーテキスト転送プロトコル&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;-HTTP&lt;/a&gt; / 1.1」[ RFC2616 ]で以前に定義された関連フィールドおよびステータスコード。IANA認証方式レジストリ（ &lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1）&lt;/a&gt;）は、以前に&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617で&lt;/a&gt;定義された「基本」および「ダイジェスト」認証スキームを含む、登録済み認証スキームとそれらに対応する仕様をリストしています。</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTPは、アクセス制御と認証のための一般的なフレームワークを提供します。最も一般的な HTTP 認証は、「基本」スキーマに基づいています。このページでは、認証のためのHTTPフレームワークの紹介と、HTTP &quot;Basic &quot;スキーマを使用してサーバへのアクセスを制限する方法を示します。</target>
        </trans-unit>
        <trans-unit id="f0b556a167d090c37ed069f694278c1d0f8c8b55" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. This page is an introduction to the HTTP framework for authentication, and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP はアクセス制御と認証のための一般的なフレームワークを提供します。このページでは、認証のためのHTTPフレームワークを紹介し、HTTP &quot;Basic &quot;スキーマを使用してサーバへのアクセスを制限する方法を示します。</target>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTPはシンプルなチャレンジ/レスポンス認証フレームワークを提供します。これは、サーバーがクライアント要求にチャレンジするために使用でき、クライアントが認証情報を提供するために使用できます。認証方式を識別する手段として大文字と小文字を区別しないトークンを使用し、その後、その方式で認証を行うために必要な追加情報が続きます。後者は、コンマで区切られたパラメーターのリスト、またはbase64でエンコードされた情報を保持できる単一の文字シーケンスのいずれかです。認証パラメーターは名前=値のペアであり、名前トークンは大文字と小文字を区別せずに照合され、各パラメーター名はチャレンジごとに1回だけ出現する必要があります。 auth-scheme =トークンauth-param =トークンBWS &quot;=&quot;BWS（token / quoted-string）token68 = 1 *（ALPHA / DIGIT / &quot;-&quot; / &quot;。&quot; / &quot;_&quot; / &quot;〜&quot; / &quot;+&quot; / &quot;/&quot;）* &quot;=&quot; token68構文では、 66の予約されていないURI文字（[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]）とその他のいくつかの機能により、base64、base64url（URLとファイル名の安全なアルファベット）、base32、またはbase16（16進数）エンコーディングを保持できます。パディングあり、またはパディングなしで、空白は除きます（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]）。要求されたリソースに適用可能なチャレンジを少なくとも1つ含むWWW-Authenticateヘッダーフィールドを含む、ユーザーエージェントの承認を要求するために、オリジンサーバーは401（無許可）応答メッセージを使用します。 407（Proxy Authentication Required）応答メッセージは、要求されたリソースのプロキシに適用可能な少なくとも1つのチャレンジを含むProxy-Authenticateヘッダーフィールドを含む、クライアントの承認を要求するためにプロキシによって使用されます。 challenge = auth-scheme [1 * SP（token68 /＃auth-param）]注：多くのクライアントは、不明なスキームを含むチャレンジの解析に失敗します。この問題の回避策は、サポートされているスキーム（「基本」など）を最初にリストすることです。オリジンサーバーで自身を認証したいユーザーエージェント-通常、必須ではありませんが、401（Unauthorized）を受け取った後、リクエストにAuthorizationヘッダーフィールドを含めることでそれを行うことができます。 407（プロキシ認証が必要）を受信した後、通常は、プロキシで認証することを希望するクライアントは、リクエストにProxy-Authorizationヘッダーフィールドを含めることで認証できます。 Authorizationフィールド値とProxy-Authorizationフィールド値の両方に、応答で受信したチャレンジ（おそらく過去のある時点）に基づいて、要求されているリソースのレルムに対するクライアントの資格情報が含まれています。それらの値を作成するとき、ユーザーエージェントは、それが理解する最も安全な認証方式であると考えるものを使用してチャレンジを選択し、必要に応じてユーザーから資格情報を取得することによって、それを行う必要があります。ヘッダーフィールド値内の資格情報の送信は、基本的な接続の機密性に関する重要なセキュリティ上の考慮事項を意味します。&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;。 credentials = auth-scheme [1 * SP（token68 /＃auth-param）]資格情報を省略し、無効な資格情報（たとえば、不正なパスワード）または部分的な資格情報（たとえば、スキームは複数のラウンドトリップを必要とします）、オリジンサーバーは、要求されたリソースに適用可能な少なくとも1つの（おそらく新しい）チャレンジを含むWWW-Authenticateヘッダーフィールドを含む401（無許可）応答を送信する必要があります（SHOULD）。同様に、プロキシ資格情報を省略したり、無効または部分的なプロキシ資格情報を含む要求を受信すると、認証を必要とするプロキシは、少なくとも1つ（おそらく新しい）のProxy-Authenticateヘッダーフィールドを含む407（Proxy Authentication Required）応答を生成する必要があります（SHOULD）。プロキシに適用可能なチャレンジ。アクセスを取得するのに適切ではない有効な資格情報を受信するサーバーは、403（禁止）ステータスコード（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;[RFC7231]のセクション6.5.3&lt;/a&gt;）。 HTTPは、アプリケーションをアクセス認証のためのこの単純なチャレンジ/レスポンスフレームワークに制限しません。トランスポートレベルでの認証やメッセージのカプセル化による認証など、追加のメカニズムを使用したり、追加のヘッダーフィールドで認証情報を指定したりできます。ただし、このような追加のメカニズムは、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTPはいくつかのオプションのチャレンジ/レスポンス認証メカニズムを提供します。これはサーバーがクライアント要求にチャレンジするために使用でき、クライアントが認証情報を提供するために使用できます。アクセス認証の一般的なフレームワーク、および「基本」および「ダイジェスト」認証の仕様は、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で指定されています。この仕様では、その仕様からの「チャレンジ」と「クレデンシャル」の定義を採用しています。</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">HTTP 範囲リクエストでは、サーバからクライアントに HTTP メッセージの一部のみを送信することができます。部分的なリクエストは、大きなメディアや一時停止や再開機能のあるファイルのダウンロードなどに便利です。</target>
        </trans-unit>
        <trans-unit id="f0381d73cd3211cb7f1d5c958b65d38f42cff6af" translate="yes" xml:space="preserve">
          <source>HTTP redirects always execute first &amp;mdash; they exist when there is not even a transmitted page.</source>
          <target state="translated">HTTPリダイレクトは常に最初に実行されます&amp;mdash;送信されたページすら存在しない場合に存在します。</target>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">HTTPのリダイレクトは、送信されたページすらないときには必ず最初に実行されますし、もちろん読み込みもしません。</target>
        </trans-unit>
        <trans-unit id="7fcfef93fd3c40ba7ae279fc8feebbaed226cca1" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the best way to create redirections, but sometimes you don't have control over the server. In that case, try a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;Refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will go to the indicated URL.</source>
          <target state="translated">HTTPリダイレクトはリダイレクトを作成するための最良の方法ですが、サーバーを制御できない場合があります。その場合は、ページの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 属性が &lt;code&gt;Refresh&lt;/code&gt; に設定された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を試してください。ページを表示すると、ブラウザは指定されたURLに移動します。</target>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">HTTPリダイレクトはリダイレクトを作成するための推奨される方法ですが、Web開発者がサーバーを制御できないか、サーバーを構成できない場合があります。これらの特定のケースでは、Web開発者は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と、ページの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;refresh&lt;/code&gt; に設定された &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 属性を使用してHTMLページを作成できます。ページを表示すると、ブラウザはこの要素を見つけて、指定されたページに移動します。</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">HTTPリダイレクトは、リダイレクトを定義する唯一の方法ではありません。他に2つの方法があり&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;ます&lt;/a&gt;。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用するHTMLリダイレクトと、DOMを使用するJavaScriptリダイレクトです。</target>
        </trans-unit>
        <trans-unit id="862c8627d2b4f34ae450a4e001c8246586866cf8" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two others:</source>
          <target state="translated">HTTPリダイレクトはリダイレクトを定義する唯一の方法ではありません。他にも二つあります。</target>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">ウィキペディアのHTTP参照元</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTPは、信頼できる応答の概念に依存しています。つまり、ターゲットURI内で識別された（またはその方向で）権限によって、その時点でターゲットリソースの状態が与えられた要求に最も適した応答であると判断された応答です。応答メッセージの発信。共有キャッシュなどの信頼できないソースからの応答を提供することは、多くの場合、パフォーマンスと可用性を向上させるのに役立ちますが、ソースが信頼できるか、信頼できない応答を安全に使用できる場合に限られます。残念ながら、権限の確立は難しい場合があります。たとえば、フィッシングは、ユーザーの権限に対する認識に対する攻撃であり、ハイパーテキストで同様のブランドを提示することにより、その認識を誤解させることができます。userinfoが権限コンポーネントを難読化することで支援される可能性があります（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）。ユーザーエージェントは、ユーザーがアクションを実行する前にターゲットURIを簡単に検査できるようにし、存在する場合はユーザー情報を目立つように区別（または拒否）し、参照ドキュメントがからのものである場合は保存された資格情報とCookieを送信しないことで、フィッシング攻撃の影響を軽減できます。不明または信頼できないソース。登録された名前が権限コンポーネントで使用される場合、「http」URIスキーム（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）ユーザーのローカルの名前解決サービスに依存して、信頼できる応答を見つけることができる場所を決定します。つまり、ユーザーのネットワークホストテーブル、キャッシュされた名前、または名前解決ライブラリへの攻撃は、権限の確立に対する攻撃の手段となります。同様に、ドメインネームサービス（DNS）用のユーザーのサーバーの選択、およびサーバーが解決結果を取得するサーバーの階層は、アドレスマッピングの信頼性に影響を与える可能性があります。 DNSセキュリティ拡張機能（DNSSEC、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ]）は、信頼性を向上させる1つの方法です。さらに、IPアドレスが取得された後、「http」URIの認証局を確立することは、インターネットプロトコルルーティングに対する攻撃に対して脆弱です。 「https」スキーム（&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt;）ネゴシエートされたTLS接続が保護され、クライアントが通信しているサーバーのIDがターゲットURIのオーソリティコンポーネントと一致することをクライアントが適切に検証する場合（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]を参照）、オーソリティの確立に対するこれらの潜在的な攻撃の多くを防止（または少なくとも明らかに）することを目的としています。このような検証を正しく実装することは難しい場合があります（[ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt; ]を参照）。</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTPは、必要なときにメッセージの機密性を提供するために、基礎となるトランスポートプロトコルに依存しています。HTTPは、トランスポートプロトコルに依存しないように特別に設計されており、さまざまな形式の暗号化接続で使用でき、そのようなトランスポートの選択は、URIスキームの選択またはユーザーエージェント構成内で識別されます。「https」スキームは、&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2で&lt;/a&gt;説明されているように、機密接続が必要なリソースを識別するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTPリクエストメッセージのルーティングは、ターゲットリソース、クライアントのプロキシ設定、およびインバウンド接続の確立または再利用に基づいて、各クライアントによって決定されます。対応する応答のルーティングは、クライアントに戻る同じ接続チェーンに従う。</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTTP要求方式</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP要求は、サーバーでアクションを開始するためにクライアントによって送信されるメッセージです。彼らの&lt;em&gt;スタートライン&lt;/em&gt;は3つの要素を含みます：</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP のリクエストとレスポンスは、似たような構造を共有しており、構成されています。</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP レスポンスコードは、特定の HTTP リクエストが正常に完了したかどうかを示します。レスポンスは 5 つのクラスに分類されます:情報応答、成功した応答、リダイレクト、クライアントエラー、サーバエラー。</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP応答ヘッダーフィールドは、オリジンのレポートエンドポイントを格納するようにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP レスポンスステータスコード</target>
        </trans-unit>
        <trans-unit id="b57d1200b41d22a049735dbac8f54f4cf988cf0d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes:</source>
          <target state="translated">HTTP応答ステータスコードは、特定の&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;要求が正常に完了したかどうかを示します。応答は5つのクラスにグループ化されます。</target>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP応答ステータスコードは、特定の&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;要求が正常に完了したかどうかを示します。応答は、情報応答、成功応答、リダイレクト、クライアントエラー、サーバーエラーの5つのクラスにグループ化されます。ステータスコードは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;、RFC 2616のセクション10で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">条件付きまたは無条件のGETメソッドを使用するHTTP取得リクエストは、リクエストの結果として返されたエンティティに適用されるRangeリクエストヘッダーを使用して、エンティティ全体ではなく、エンティティの1つ以上のサブ範囲をリクエストできます：Range = &quot;Range &quot;&quot;： &quot;ranges-specifierサーバーはRangeヘッダーを無視してもよい（MAY）。ただし、範囲は部分的に失敗した転送からの効率的な回復をサポートし、大きなエンティティの効率的な部分的な取得をサポートするため、HTTP / 1.1オリジンサーバーと中間キャッシュは、可能な場合はバイト範囲をサポートする必要があります。サーバーがRangeヘッダーをサポートし、指定された1つまたは複数の範囲がエンティティに適している場合：-無条件のGETにRangeヘッダーが存在すると、GETが成功した場合に返されるものが変更されます。つまり、応答には200（OK）ではなく206（Partial Content）のステータスコードが含まれます。 -条件付きGET（If-Modified-SinceとIf-None-Matchの一方または両方、またはIf-Unmodified-SinceとIf-Matchの一方または両方を使用する要求）にRangeヘッダーが存在すると、返されるものが変更されますGETが成功し、条件が真の場合。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（または、If-Unmodified-SinceとIf-Matchのいずれかまたは両方が、GETが成功し、条件がtrueの場合に返される内容を変更します。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（または、If-Unmodified-SinceとIf-Matchのいずれかまたは両方が、GETが成功し、条件がtrueの場合に返される内容を変更します。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（&lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt;）とRangeヘッダーに加えて。範囲をサポートするプロキシが範囲要求を受信し、その要求を受信サーバーに転送し、応答としてエンティティ全体を受信する場合、要求された範囲のみをクライアントに返す必要があります（SHOULD）。キャッシュ割り当てポリシーと一致する場合は、受信した応答全体をキャッシュに格納する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTPステータス：&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP トンネリング</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTPは、オープンで拡張可能なデータタイプとタイプネゴシエーションを提供するために、Content-Type（&lt;a href=&quot;#section-14.17&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;）およびAccept（&lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt;）ヘッダーフィールドでインターネットメディアタイプ[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]を使用します。メディアタイプ=タイプ &quot;/&quot;サブタイプ*（ &quot;;&quot;パラメータ）タイプ=トークンサブタイプ=トークンパラメータは、タイプ/サブタイプの後に属性/値のペアの形式で続くことができます（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;定義））。タイプ、サブタイプ、およびパラメーターの属性名では、大文字と小文字は区別されません。パラメータ名のセマンティクスに応じて、パラメータ値は大文字と小文字を区別する場合としない場合があります。タイプとサブタイプの間、または属性とその値の間では線形空白（LWS）を使用してはなりません（MUST NOT）。メディアタイプレジストリ内の定義によっては、パラメータの有無がメディアタイプの処理にとって重要になる場合があります。一部の古いHTTPアプリケーションはメディアタイプパラメータを認識しないことに注意してください。古いHTTPアプリケーションにデータを送信する場合、実装では、そのタイプ/サブタイプの定義で必要な場合にのみメディアタイプパラメータを使用する必要があります（SHOULD）。メディアタイプの値は、Internet Assigned Number Authority（IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]）。メディアタイプ登録プロセスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]で概説されています。登録されていないメディアタイプの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTPは、Content-Type（&lt;a href=&quot;#section-3.1.1.5&quot;&gt;セクション3.1.1.5&lt;/a&gt;）およびAccept（&lt;a href=&quot;#section-5.3.2&quot;&gt;セクション5.3.2&lt;/a&gt;）でインターネットメディアタイプ[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]を使用します。）ヘッダーフィールド。オープンで拡張可能なデータタイプとタイプネゴシエーションを提供します。メディアタイプは、データ形式とさまざまな処理モデルの両方を定義します。つまり、受信した各コンテキストに従ってデータを処理する方法です。 media-type = type &quot;/&quot; subtype *（OWS &quot;;&quot; OWS parameter）type = token subtype = token type / subtypeの後には、name = valueペアの形式のパラメータが続く場合があります。 parameter = token &quot;=&quot;（token / quoted-string）タイプ、サブタイプ、およびパラメータ名のトークンは、大文字と小文字を区別しません。パラメータ名のセマンティクスに応じて、パラメータ値は大文字と小文字を区別する場合としない場合があります。パラメータの有無は、メディアタイプの処理にとって重要な場合があります。メディアタイプレジストリ内の定義に応じて。トークンの生成と一致するパラメーター値は、トークンとして、または引用文字列内で送信できます。引用符で囲まれた値と引用符で囲まれていない値は同等です。たとえば、次の例はすべて同等ですが、一貫性を保つために最初の例が推奨されます：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html ; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。ただし、一貫性を保つために最初のものが推奨されます。text/ html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。ただし、一貫性を保つために最初のものが推奨されます。text/ html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]。注：他のヘッダーフィールドのいくつかの同様の構成要素とは異なり、メディアタイプパラメーターでは、「=」文字の前後に空白（「悪い」空白であっても）を使用できません。</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTPは &quot;&amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&quot;番号付けスキームを使用して、プロトコルのバージョンを示します。この仕様はバージョン「1.1」を定義しています。全体としてのプロトコルバージョンは、送信者がそのバージョンの対応するHTTP仕様で規定されている一連の要件に準拠していることを示します。 HTTPメッセージのバージョンは、メッセージの最初の行のHTTP-versionフィールドで示されます。 HTTPバージョンでは大文字と小文字が区別されます。 HTTP-version = HTTP-name &quot;/&quot; DIGIT &quot;。&quot; DIGIT HTTP-name =％x48.54.54.50; 「HTTP」、大文字と小文字を区別HTTPバージョン番号は、「。」で区切られた2つの10進数で構成されます。 （ピリオドまたは小数点）。最初の数字（「メジャーバージョン」）は、HTTPメッセージング構文を示します。一方、2番目の数字（「マイナーバージョン」）は、送信者が準拠し、将来の通信のために理解できるメジャーバージョン内の最高のマイナーバージョンを示します。マイナーバージョンは、送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、送信者の通信機能をアドバタイズします。これにより、より高度な機能が応答（サーバー）または将来の要求（クライアント）で使用できることを受信者に通知します。 。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、通信機能。これにより、受信者は、より高度な機能を応答（サーバー）または将来の要求（クライアント）で使用できることを認識できます。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、通信機能。これにより、受信者は、より高度な機能を応答（サーバー）または将来の要求（クライアント）で使用できることを認識できます。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]またはバージョンが不明な受信者である場合、HTTP / 1.1メッセージは、新しい機能がすべて無視された場合に有効なHTTP / 1.0メッセージとして解釈されるように構築されます。この仕様では、受信者バージョンの要件をいくつかの新機能に課しているため、構成またはメッセージの受信を通じて、受信者がHTTP / 1.1をサポートしていると判断するまで、適合送信者は互換機能のみを使用します。ヘッダーフィールドの解釈は、同じメジャーHTTPバージョンのマイナーバージョン間では変わりませんが、そのようなフィールドがない場合の受信者のデフォルトの動作は変わる可能性があります。特に明記されていない限り、HTTP / 1.1で定義されているヘッダーフィールドは、HTTP / 1.xのすべてのバージョンに対して定義されています。特に、HostおよびConnectionヘッダーフィールドは、HTTP / 1.1への準拠をアドバタイズするかどうかに関係なく、すべてのHTTP / 1.x実装によって実装される必要があります。定義されたセマンティクスにより、それらを認識しない受信者が安全に無視できる場合、プロトコルバージョンを変更せずに新しいヘッダーフィールドを導入できます。ヘッダーフィールドの拡張性については、&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション3.2.1&lt;/a&gt;。 HTTPメッセージを処理する仲介者（つまり、トンネルとして機能する仲介者以外のすべての仲介者）は、転送されたメッセージで独自のHTTPバージョンを送信する必要があります。つまり、メッセージのプロトコルバージョンが、メッセージの受信と送信の両方で仲介者が準拠しているバージョンと一致していることを確認せずに、HTTPメッセージの最初の行を盲目的に転送することはできません。 HTTPバージョンを書き換えずにHTTPメッセージを転送すると、ダウンストリーム受信者がメッセージ送信者のバージョンを使用して、その送信者と後で通信するために安全に使用できる機能を判断するときに、通信エラーが発生する可能性があります。クライアントは、クライアントが準拠している最高バージョンに等しいリクエストバージョンを送信する必要があります（SHOULD）。そのメジャーバージョンは、サーバーでサポートされている最高バージョン（既知の場合）以下です。クライアントは、準拠していないバージョンを送信してはなりません（MUST NOT）。サーバーが誤ってHTTP仕様を実装していることがわかっている場合、クライアントはより低い要求バージョンを送信できますが、クライアントが少なくとも1つの通常の要求を試み、応答ステータスコードまたはヘッダーフィールド（例：サーバー）からサーバーは、より高いリクエストバージョンを不適切に処理します。サーバーは、サーバーが準拠している最も高いバージョンに等しい応答バージョンを送信する必要があります（SHOULDは、要求で受信したメジャーバージョン以下のメジャーバージョンを持っています）。サーバーは、準拠していないバージョンを送信してはなりません（MUST NOT）。サーバーは、何らかの理由でクライアントのメジャープロトコルバージョンのサービスを拒否したい場合は、505（HTTPバージョンはサポートされていません）応答を送信できます。クライアントがHTTP仕様を誤って実装していて、クライアントがバージョン番号を正しく解析できない場合や、クライアントがバージョン番号を正しく解析できない場合など、後のバージョンの応答を正しく処理できないことがわかっているか疑われる場合、サーバーは要求にHTTP / 1.0応答を送信できます（MAY）仲介者は、指定されたマイナーバージョンのプロトコルに準拠していない場合でも、HTTPバージョンを盲目的に転送することが知られています。そのようなプロトコルのダウングレードは、1つ以上のリクエストヘッダーフィールド（たとえば、User-Agent）は、エラーのあることがわかっているクライアントから送信された値と一意に一致します。 HTTPのバージョン管理設計の意図は、互換性のないメッセージ構文が導入された場合にのみメジャー番号が増分されること、およびプロトコルに加えられた変更がメッセージセマンティクスに追加または追加を示唆する効果を持つ場合にのみマイナー番号が増分されることです。送信者の機能。ただし、マイナーバージョンは、[そして、マイナー番号は、プロトコルに加えられた変更がメッセージの意味に追加する、または送信者の追加機能を示唆する効果を持つ場合にのみ増加します。ただし、マイナーバージョンは、[そして、マイナー番号は、プロトコルに加えられた変更がメッセージの意味に追加する、または送信者の追加機能を示唆する効果を持つ場合にのみ増加します。ただし、マイナーバージョンは、[&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ]と[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、およびこの改訂では、プロトコルに対するこのような変更は特に回避されています。受信者が実装するメジャーバージョン番号を含むHTTPメッセージが受信されたが、受信者が実装するものよりも大きいマイナーバージョン番号である場合、受信者は、そのメジャーバージョンの中で最も高いマイナーバージョンであるかのようにメッセージを処理する必要があります（SHOULD）。受信者は適合しています。受信者は、より高いマイナーバージョンのメッセージが、そのより高いバージョンのサポートをまだ示していない受信者に送信された場合、同じメジャーバージョンの実装で安全に処理できるように十分な下位互換性があると想定できます。</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTPは &quot;&amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&quot;番号付けスキームを使用して、プロトコルのバージョンを示します。プロトコルのバージョン管理ポリシーは、送信者がメッセージの形式と、HTTP通信を介して取得される機能ではなく、HTTP通信をさらに理解するための容量を示すことを目的としています。通信動作に影響を与えない、または拡張可能なフィールド値のみを追加するメッセージコンポーネントを追加しても、バージョン番号は変更されません。 &amp;lt;マイナー&amp;gt;番号は、プロトコルに加えられた変更により、一般的なメッセージ解析アルゴリズムを変更しない機能が追加された場合に増加しますが、メッセージのセマンティクスに追加され、送信者の追加機能を意味する場合があります。 &amp;lt;メジャー&amp;gt;プロトコル内のメッセージのフォーマットが変更されると、番号が増加します。見る&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]詳細な説明については。 HTTPメッセージのバージョンは、メッセージの最初の行のHTTP-Versionフィールドで示されます。 HTTP-Version = &quot;HTTP&quot; &quot;/&quot; 1 * DIGIT &quot;。&quot; 1 * DIGITメジャー番号とマイナー番号は別々の整数として扱われる必要があり、各桁が1桁より大きくなる場合があることに注意してください。したがって、HTTP / 2.4はHTTP / 2.13よりも下位のバージョンであり、HTTP / 2.13はHTTP / 12.3よりも下位です。先行ゼロは受信者によって無視されなければならず、送信されてはなりません。 「HTTP / 1.1」のHTTPバージョンを含む要求または応答メッセージを送信するアプリケーションは、少なくともこの条件に条件付きで準拠している必要があります。この仕様に少なくとも条件付きで準拠しているアプリケーションは、「HTTP / 1.1」のHTTPバージョンを使用する必要があります（SHOULD）。メッセージで、HTTP / 1.0と互換性のないすべてのメッセージに対してそのようにする必要があります。特定のHTTP-Version値を送信するタイミングの詳細については、を参照してください。&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]。アプリケーションのHTTPバージョンは、アプリケーションが少なくとも条件付きで準拠している最も高いHTTPバージョンです。プロキシおよびゲートウェイアプリケーションは、アプリケーションのプロトコルバージョンとは異なるプロトコルバージョンでメッセージを転送する場合は注意が必要です。プロトコルバージョンは送信者のプロトコル機能を示すため、プロキシ/ゲートウェイは、実際のバージョンよりも大きいバージョンインジケータを含むメッセージを送信してはなりません（MUST NOT）。より高いバージョンのリクエストを受信した場合、プロキシ/ゲートウェイは、リクエストのバージョンをダウングレードするか、エラーで応答するか、トンネルの動作に切り替える必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33の&lt;/a&gt;公開以降に発見されたHTTP / 1.0プロキシとの相互運用性の問題のため]、キャッシングプロキシは、MUST、ゲートウェイはMAY、トンネルは、サポートする最新バージョンにリクエストをアップグレードしてはなりません（MUST NOT）。そのリクエストに対するプロキシ/ゲートウェイの応答は、リクエストと同じメジャーバージョンである必要があります。注：HTTPのバージョン間の変換には、関連するバージョンで必要または禁止されているヘッダーフィールドの変更が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTPは文字セット名を使用して、テキスト表現の文字エンコーディングスキームを示したり、ネゴシエートしたりします[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]。文字セットは、大文字と小文字を区別しないトークンによって識別されます。charset =トークン文字セット名は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]で定義されている手順に従って、IANAの「文字セット」レジストリ（&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;）に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTPは、MIMEについて説明したものと同じ「文字セット」という用語の定義を使用します。このドキュメントでは、「文字セット」という用語は、1つまたは複数のテーブルで使用され、オクテットのシーケンスを文字。すべての文字が特定の文字セットで使用できるわけではなく、文字セットが特定の文字を表すオクテットの複数のシーケンスを提供する場合があるため、逆方向の無条件変換は必要ありません。この定義は、US-ASCIIなどの単純な単一テーブルマッピングからISO-2022の手法を使用するような複雑なテーブルスイッチング方法まで、さまざまな種類の文字エンコーディングを可能にすることを目的としています。しかしながら、MIME文字セット名に関連付けられた定義では、オクテットから文字へのマッピングを完全に指定する必要があります。特に、正確なマッピングを決定するための外部プロファイリング情報の使用は許可されていません。注：この「文字セット」という用語の使用法は、より一般的には「文字エンコーディング」と呼ばれています。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[より一般的には「文字エンコーディング」と呼ばれます。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[より一般的には「文字エンコーディング」と呼ばれます。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]。 charset = token HTTPでは任意のトークンを文字セット値として使用できますが、IANA文字セットレジストリ[ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 内に事前定義された値を持つトークンは、そのレジストリで定義された文字セットを表す必要があります。アプリケーションは、文字セットの使用をIANAレジストリで定義されているものに制限する必要があります（SHOULD）。実装者は、IETF文字セットの要件を認識する必要があります[ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP は World Wide Web (WWW)アーキテクチャのために作られ、世界的なハイパーテキストシステムのスケーラビリティのニーズをサポートするために時間をかけて進化してきました。そのアーキテクチャの多くは、HTTP を定義するために使用される用語や構文に反映されています。</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP は 1990 年代初頭に作られ、何度か拡張されてきました。この記事では、その歴史を辿り、HTTP/0.9、HTTP/1.0、HTTP/1.1、そして現代のHTTP/2と、その間に導入されたマイナーな新機能について説明します。</target>
        </trans-unit>
        <trans-unit id="6691219872cf8222b135471124cba8cce6315df4" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2, as well as novelties introduced over the years.</source>
          <target state="translated">HTTP は 1990 年代初頭に作られ、何度か拡張されてきました。この記事では、その歴史を辿り、HTTP/0.9、HTTP/1.0、HTTP/1.1、そして現代のHTTP/2と、その間に導入された新機能について説明します。</target>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP が最初に規定されたのは 1990 年代初頭のことです。拡張性を念頭に置いて設計されていますが、何年にもわたって何度も追加されてきました。このページでは、HTTP に関連するリソースをリストアップしています。</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">エラー処理に対するHTTPのアプローチについて説明しました。 （&lt;a href=&quot;#section-2.5&quot;&gt;セクション2.5&lt;/a&gt;）HTTPバージョンのABNFプロダクションでは、大文字と小文字が区別されることが明確になっています。さらに、実装は複数桁のバージョン番号を誤って処理することが知られているため、バージョン番号は1桁に制限されています。 （&lt;a href=&quot;#section-2.6&quot;&gt;2.6節&lt;/a&gt;）HTTPとHTTPSのURIで、ユーザー情報（つまり、ユーザー名とパスワード）は、ネットワーク上での送信に関連するセキュリティ問題のため、許可されなくなりました。 （&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）HTTPS URIスキームがこの仕様で定義されるようになりました。以前は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;[RFC2818]のセクション2.4で&lt;/a&gt;行われていました。さらに、エンドツーエンドのセキュリティを意味します。 （&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt;）HTTPメッセージは、実装によってバッファリングできます（多くの場合、バッファリングされます）。ストリームとして利用できることもありますが、HTTPは基本的にメッセージ指向プロトコルです。相互運用性を向上させるために、さまざまなプロトコル要素でサポートされる最小サイズが提案されています。 （&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）フィールド名を囲む無効な空白は、受け入れるとセキュリティの脆弱性を表すため、拒否する必要があります。ヘッダーフィールドを定義するABNFプロダクションは、フィールド値のみをリストするようになりました。 （&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）特定の文法プロダクション間の暗黙的な線形空白に関するルールが削除されました。現在、空白は、ABNFで明確に定義されている場合にのみ許可されます。 （&lt;a href=&quot;#section-3.2.3&quot;&gt;セクション3.2.3&lt;/a&gt;）複数の行にまたがるヘッダーフィールド（「行の折り返し」）は非推奨になりました。 （&lt;a href=&quot;#section-3.2.4&quot;&gt;セクション3.2.4&lt;/a&gt;）NULオクテットはコメントおよび引用符付きテキストで許可されなくなり、バックスラッシュエスケープの取り扱いが明確になりました。クォートペアルールでは、HTAB以外の制御文字をエスケープすることはできなくなりました。ヘッダーフィールドのUS-ASCII以外のコンテンツと理由フレーズが廃止され、不透明になりました（TEXTルールは削除されました）。 （&lt;a href=&quot;#section-3.2.6&quot;&gt;セクション3.2.6&lt;/a&gt;）偽のContent-Lengthヘッダーフィールドは、受信者によってエラーとして処理される必要があります。 （&lt;a href=&quot;#section-3.3.2&quot;&gt;セクション3.3.2&lt;/a&gt;）メッセージ本文の長さを決定するためのアルゴリズムが明確になり、それに影響するすべての特殊なケース（たとえば、メソッドまたはステータスコードによって駆動される）を示し、新しいプロトコル要素はそのような特殊なケースを定義できません。 CONNECTは、メッセージ本文の長さを決定する際の新しい特別なケースです。 「multipart / byteranges」は、メッセージ本文の長さの検出を決定する方法ではなくなりました。 （&lt;a href=&quot;#section-3.3.3&quot;&gt;セクション3.3.3&lt;/a&gt;）「ID」転送コーディングトークンが削除されました。 （セクション&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; および4）チャンク長には、チャンクヘッダーとトレーラーのオクテットの数は含まれません。チャンク拡張での行折りたたみは許可されていません。 （&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）「deflate」コンテンツコーディングの意味が明確になりました。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;のabs_pathの代わりに、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;のセグメント+クエリコンポーネントを使用して要求ターゲットを定義しました。 request-targetのアスタリスク形式は、OPTIONSメソッドでのみ使用できます。 （&lt;a href=&quot;#section-5.3&quot;&gt;5.3項&lt;/a&gt;）「Effective Request URI」という用語が導入されました。 （&lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt;）ゲートウェイは、Viaヘッダーフィールドを生成する必要がなくなりました。 （&lt;a href=&quot;#section-5.7.1&quot;&gt;セクション5.7.1&lt;/a&gt;）「閉じる」接続オプションを送信する必要がある正確なタイミングが明確になりました。また、「ホップバイホップ」ヘッダーフィールドは、接続ヘッダーフィールドに表示される必要があります。この仕様でホップバイホップとして定義されているからといって、それらは免除されません。（ &lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）サーバーごとの2つの接続の制限が削除されました。べき等の一連の要求を再試行する必要がなくなりました。サーバーが途中で接続を閉じるときに、特定の状況下で要求を再試行する必要がなくなりました。また、サーバーが時期尚早に接続を閉じることが許可される時期に関するいくつかの無関係な要件が削除されました。 （&lt;a href=&quot;#section-6.3&quot;&gt;セクション6.3&lt;/a&gt;）101以外の応答でUpgradeヘッダーフィールドのセマンティクスが定義されるようになりました（これは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] から組み込まれました）。さらに、フィールド値の順序は重要です。 （&lt;a href=&quot;#section-6.7&quot;&gt;6.7節&lt;/a&gt;）リスト生成における空のリスト要素（たとえば、「、」を含むリストヘッダーフィールド）は非推奨になりました。 （&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）転送コーディングの登録にはIETFレビューが必要になりました（&lt;a href=&quot;#section-8.4&quot;&gt;セクション8.4&lt;/a&gt;）。この仕様では、以前&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]のセクション7.2で&lt;/a&gt;定義されたアップグレードトークンレジストリを定義するようになりました。（&lt;a href=&quot;#section-8.6&quot;&gt;セクション8.6&lt;/a&gt;）HTTP / 0.9リクエストをサポートするという期待は削除されました。（付録A）リクエストのKeep-AliveおよびProxy-Connectionヘッダーフィールドの問題が指摘されていますが、後者の使用は完全に推奨されません。（付録A.1.2）</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">クロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）に対する攻撃を緩和するために、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;プロパティ、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; APIを介してJavaScript経由でHTTPのみのCookieにアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash;単一行プロトコル</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP/0.9は非常に限られたもので、ブラウザもサーバもすぐに拡張して、より汎用性の高いものにしました。</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash;拡張性の構築</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">HTTP / 1.0接続は、デフォルトでは永続的ではありません。&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;close&lt;/code&gt; 以外、通常は &lt;code&gt;retry-after&lt;/code&gt; 以外に設定すると、永続的になります。</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0は、要求/応答交換ごとにTCP接続を開き、2つの大きな欠陥をもたらしました。接続を開くには、メッセージのいくつかのラウンドトリップが必要であり、そのために遅くなりますが、複数のメッセージが送信され、定期的に送信されるとより効率的になります。&lt;em&gt;ウォーム&lt;/em&gt;接続は&lt;em&gt;冷たい&lt;/em&gt;ものよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash;標準化されたプロトコル</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1を使用すると、クライアントは応答エンティティの一部（範囲）のみを応答に含めるように要求できます。 HTTP / 1.1は、範囲（&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;）およびコンテンツ範囲（&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt;）ヘッダーフィールドで範囲単位を使用します。エンティティは、さまざまな構造単位に従ってサブレンジに分割できます。範囲単位=バイト単位| other-range-unit bytes-unit = &quot;bytes&quot; other-range-unit = token HTTP / 1.1で定義されている唯一の範囲単位は &quot;bytes&quot;です。 HTTP / 1.1実装は、他の単位を使用して指定された範囲を無視してもよい（MAY）。 HTTP / 1.1は、範囲の知識に依存しないアプリケーションの実装を可能にするように設計されています。</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP/1.1 およびそれ以前の HTTP メッセージは人間が読むことができます。HTTP/2 では、これらのメッセージはフレームという新しいバイナリ構造に組み込まれており、ヘッダの圧縮や多重化などの最適化が可能になっています。このバージョンの HTTP では、元の HTTP メッセージの一部だけが送信されたとしても、各メッセージのセマンティクスは変更されず、クライアントは元の HTTP/1.1 リクエストを (事実上)再構成します。したがって、HTTP/1.1 形式の HTTP/2 メッセージを理解することは有用です。</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP/1.1の曖昧さを明確にし、多数の改善点を紹介しました。</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1では、デフォルトで「持続的接続」が使用され、複数の要求と応答を1つの接続で伝送できます。 「閉じる」接続オプションは、現在の要求/応答後に接続が持続しないことを通知するために使用されます。 HTTP実装は永続的な接続をサポートする必要があります（SHOULD）。受信者は、最後に受信したメッセージのプロトコルバージョンと接続ヘッダーフィールド（存在する場合）に基づいて、接続が永続的かどうかを判断します。o「閉じる」接続オプションが存在する場合、現在の応答後に接続は永続化されません。それ以外の場合、o受信したプロトコルがHTTP / 1.1（またはそれ以降）の場合、接続は現在の応答後も持続します。それ以外の場合、o受信したプロトコルがHTTP / 1.0の場合、「keep-alive &quot;接続オプションが存在し、受信者がプロキシではなく、受信者がHTTP / 1.0の&quot; keep-alive &quot;メカニズムを尊重したい場合、接続は現在の応答後も持続します。それ以外の場合は、o接続は終了します現在の応答。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続に追加の要求を送信できます（MAY）。永続性を維持するために、すべてのメッセージで説明されているように、接続では自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）が必要です。メカニズム、接続は現在の応答後も持続します。それ以外の場合、o現在の応答後に接続が閉じます。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続で追加の要求を送信する場合があります。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。メカニズム、接続は現在の応答後も持続します。それ以外の場合、o現在の応答後に接続が閉じます。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続で追加の要求を送信する場合があります。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。「キープアライブ」接続オプションなしの0応答。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。「キープアライブ」接続オプションなしの0応答。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;。サーバーは、要求メッセージ本文全体を読み取るか、応答を送信した後で接続を閉じる必要があります。そうしないと、永続的な接続の残りのデータが次の要求として誤って解釈されます。同様に、クライアントは、後続の要求で同じ接続を再利用する場合は、応答メッセージ本文全体を読み取る必要があります。プロキシサーバーは、HTTP / 1.0クライアントとの永続的な接続を維持してはなりません（多くのHTTP / 1.0クライアントによって実装されたKeep-Aliveヘッダーフィールドの問題と情報については、&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;[RFC2068]のセクション19.7.1を&lt;/a&gt;参照してください）。HTTP / 1.0クライアントとの下位互換性の詳細については、&lt;a href=&quot;#appendix-A.1.2&quot;&gt;付録A.1.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1では、Transfer-Encodingヘッダーフィールドが導入されています（&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt;）。MIME準拠のプロトコルでHTTPメッセージを転送する前に、転送コーディングをデコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1では、Transfer-Encodingヘッダーフィールドが導入されています（&lt;a href=&quot;#section-14.41&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;）。プロキシ/ゲートウェイは、MIME準拠のプロトコルを介してメッセージを転送する前に、転送コーディングを削除する必要があります。「チャンク」転送コーディングをデコードするプロセス（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）擬似コードでは次のように表すことができます：length：= 0チャンクサイズ、チャンク拡張（存在する場合）、CRLFを読み取りながら（チャンクサイズ&amp;gt; 0）{チャンクデータを読み取り、CRLFがエンティティにチャンクデータを追加します。 body length：= length + chunk-size read chunk-size and CRLF} entity-header while（entity-header not empty）{entity-header to existing header fields read entity-header} Content-Length：= length Remove &quot; Transfer-Encodingからチャンク化</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP/1.1 サーバは持続的な接続を維持し、クライアントが再試行することを期待して接続を終了するのではなく、一時的な過負荷を解決するために TCP のフロー制御メカニズムを使用すべきである[SHOULD]。後者の技術はネットワークの混雑を悪化させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1は、日付比較のプロセスを簡素化するために、日付フォーマットの制限されたセット（&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt;）を使用します。他のプロトコルからのプロキシとゲートウェイは、メッセージに存在するすべての日付ヘッダーフィールドがHTTP / 1.1形式のいずれかに準拠していることを確認し、必要に応じて日付を書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1は、日付比較のプロセスを簡素化するために、制限された一連の日付フォーマット（&lt;a href=&quot;#section-7.1.1.1&quot;&gt;セクション7.1.1.1&lt;/a&gt;）を使用します。他のプロトコルのプロキシとゲートウェイは、メッセージに存在する日付ヘッダーフィールドがHTTP / 1.1形式のいずれかに準拠していることを確認し、必要に応じて日付を書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1は、インターネットメール（&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]）および多目的インターネットメール拡張（MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]）用に定義された多くの構成を使用して、エンティティをさまざまな表現で拡張可能なメカニズムで送信できるようにします。ただし、&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; はメールについて説明しており、HTTPには&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045で&lt;/a&gt;説明されているものとは異なるいくつかの機能があります。これらの違いは、バイナリ接続でのパフォーマンスを最適化し、新しいメディアタイプをより自由に使用できるようにし、日付の比較を容易にし、一部の初期のHTTPサーバーとクライアントの慣行を認めるために慎重に選択されました。この付録では、HTTPが異なる特定の領域について説明します&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;。厳密なMIME環境へのプロキシとゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります（SHOULD）。MIME環境からHTTPへのプロキシとゲートウェイも、一部の変換が必要になる場合があるため、違いを認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1は、インターネットメッセージフォーマット[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]および多目的インターネットメール拡張（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]に定義されている多くの構造を使用して、メッセージ本文をさまざまな表現で、拡張可能なヘッダーフィールドで送信できるようにします。ただし、&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;メールのみに焦点を当てています。HTTPのアプリケーションには、電子メールとは異なる多くの特性があります。したがって、HTTPにはMIMEとは異なる機能があります。これらの違いは、バイナリ接続でのパフォーマンスを最適化し、新しいメディアタイプをより自由に使用できるようにし、日付の比較を容易にし、一部の初期のHTTPサーバーとクライアントの慣行を認めるために慎重に選択されました。この付録では、HTTPがMIMEと異なる特定の領域について説明します。厳密なMIME環境との間のプロキシおよびゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1は、1997年1月に&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;として最初に公開されました。</target>
        </trans-unit>
        <trans-unit id="d5072f3723c431d48c51e0f349be99684fbc90ba" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains both concepts.</source>
          <target state="translated">HTTP/1.1はHTTPの最初のバージョンで、永続的な接続とパイプラインをサポートしました。この記事では、両方の概念について説明します。</target>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP/1.1はHTTPの最初のバージョンで、永続的な接続とパイプラインをサポートしていました。この記事では、この2つの概念について説明します。</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP/1.1.認証</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP/1.1.セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="c0b298b6e63b8ce602677a51d4f1e6436079232f" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Status Code Definitions</source>
          <target state="translated">HTTP/1.1:ステータスコードの定義</target>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP/1.xのメッセージは、パフォーマンスの面でいくつかの欠点があります。</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash;パフォーマンスを向上させるプロトコル</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP/2 フレーム</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP/2では、接続管理のためのモデルが追加されています。</target>
        </trans-unit>
        <trans-unit id="de5c597058c2601a65efadc88f948c586a1ffe49" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained. This article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2は、接続がどのように作成され、維持されるかを完全に見直しました。この記事では、HTTPフレームがどのように多重化を可能にするのかを説明し、以前のHTTPバージョンの「頭文字」ブロッキングの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2は接続がどのように作成され、維持されるかを完全に見直しました:この記事では、HTTPフレームがどのように多重化を可能にするかを説明し、以前のHTTPバージョンの「行頭」ブロッキングの問題を解決しています。</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP/2 は HTTP/1.x のメッセージをバイナリフレームでカプセル化して表現します。この記事では、フレームの構造、その目的、エンコードの方法について説明します。</target>
        </trans-unit>
        <trans-unit id="8b89d94c6825e208193b0c3215145db1ad533fe7" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose, and the way it's encoded.</source>
          <target state="translated">HTTP/2 は HTTP/1.x のメッセージをバイナリフレームでカプセル化して表現します。この記事では、フレームの構造、目的、エンコードの仕方を説明します。</target>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2は追加のステップを導入します：HTTP / 1.xメッセージをストリームに埋め込まれたフレームに分割します。データフレームとヘッダーフレームが分離されているため、ヘッダーを圧縮できます。複数のストリームを組み合わせることができます。このプロセスは&lt;em&gt;多重化&lt;/em&gt;と呼ばれ、基礎となるより効率的なTCP接続を可能にします。</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP/3-HTTP over QUIC</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;ホスト：ポート&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">サーバー上でのCORSの処理(Javaの例</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">ヘッダーフィールド名：SLUG該当するプロトコル：http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]ステータス：標準。作成者/変更コントローラー：IETF（iesg@ietf.org）インターネット技術特別調査委員会の仕様書： &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;。関連情報：なし。</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：DAV該当プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：深さ適用プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.2&quot;&gt;セクション10.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：宛先該当するプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.3&quot;&gt;セクション10.3&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：該当するプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.4&quot;&gt;10.4項&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：Lock-Token該当プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.5&quot;&gt;セクション10.5&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：上書き適用可能なプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.6&quot;&gt;セクション10.6&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：タイムアウト適用可能なプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.7&quot;&gt;セクション10.7&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">ヘッダーフィールドは完全に拡張可能です。新しいフィールド名の導入、それぞれがおそらく新しいセマンティクスを定義していること、および特定のメッセージで使用されるヘッダーフィールドの数に制限はありません。既存のフィールドは、この仕様の各部分およびこのドキュメントセット以外の多くの仕様で定義されています。新しいヘッダーフィールドを定義して、受信者が理解したときに、以前に定義されたヘッダーフィールドの解釈を上書きまたは強化したり、要求評価の前提条件を定義したり、応答の意味を調整したりできます。接続ヘッダーフィールドにフィールド名がリストされていない限り、プロキシは、認識されないヘッダーフィールドを転送する必要があります（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）または、プロキシはそのようなフィールドをブロックするか、そうでなければ変換するように特別に構成されています。他の受信者は、認識されないヘッダーフィールドを無視する必要があります。これらの要件により、デプロイされた仲介者を事前に更新することなく、HTTPの機能を拡張できます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;[RFC7231]のセクション8.3で&lt;/a&gt;説明されているように、定義されたすべてのヘッダーフィールドは、「メッセージヘッダー」レジストリのIANAに登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">ヘッダーフィールドは、メッセージ、そのペイロード、ターゲットリソース、または接続に関するデータ（つまり、制御データ）の通信に使用できるキーと値のペアです。HTTPメッセージのヘッダーフィールド構文の一般的な定義については、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2を&lt;/a&gt;参照してください。ヘッダーフィールド名の要件は、[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]。新しいフィールドを定義する仕様の作成者は、名前をできるだけ短くし、ヘッダーフィールドがインターネットで使用されない限り、名前の前に「X-」を付けないことをお勧めします。 （「X-」接頭辞のイディオムは、実際には広く誤用されています。これは、独自のソフトウェアまたはイントラネット処理内での名前の衝突を回避するメカニズムとしてのみ使用することを目的としていました。インターネット名。詳細については、[ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ]を参照してください）。新しいヘッダーフィールド値は通常&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;、[RFC7230]のセクション7で&lt;/a&gt;定義されている拡張を使用して、ABNF（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]）を使用して定義された構文を持っています必要に応じて、通常はUS-ASCII文字の範囲に制限されます。より広い範囲の文字を必要とするヘッダーフィールドは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]で定義されているようなエンコーディングを使用できます。生のフィールド値の先頭と末尾の空白は、フィールドの解析時に削除されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]のセクション3.2.4&lt;/a&gt;）。値の先頭または末尾の空白が重要なフィールド定義では、quoted-string（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]のセクション3.2.6）&lt;/a&gt;などのコンテナ構文を使用する必要があります。）。コンマ（ &quot;、&quot;）はフィールド値間の一般的な区切り文字として使用されるため、フィールド値で許可されている場合は慎重に扱う必要があります。通常、コンマを含む可能性のあるコンポーネントは、引用文字列ABNFプロダクションを使用して二重引用符で保護されます。たとえば、テキストの日付とURI（どちらもカンマが含まれている可能性があります）は、次のようなフィールド値で安全に運ぶことができます。Example-URI-Field： &quot;http://example.com/a.html,foo&quot; 、 &quot;http://without-a-comma.example.com/&quot; Example-Date-Field： &quot;Sat、04 May 1996&quot;、 &quot;Wed、14 Sep 2005&quot;二重引用符区切り文字は、ほとんどの場合、引用文字列の生成。二重引用符内で異なる構文を使用すると、不要な混乱を招く可能性があります。多くのヘッダーフィールドは、（大文字と小文字を区別せずに）名前付きパラメーターを含む形式を使用します（たとえば、Content-Type、&lt;a href=&quot;#section-3.1.1.5&quot;&gt;セクション3.1.1.5&lt;/a&gt;）。パラメータ値に引用符なし（トークン）と引用符付き（引用符付き文字列）の両方の構文を許可すると、受信者は既存のパーサーコンポーネントを使用できます。両方の形式を許可する場合、パラメーター値の意味は、使用される構文とは無関係である必要があります（例については、&lt;a href=&quot;#section-3.1.1.1&quot;&gt;セクション3.1.1.1の&lt;/a&gt;メディアタイプのパラメーター処理に関する注記を参照してください ）。新しいヘッダーフィールドを定義する仕様の作成者は、文書化を検討することをお勧めします。oフィールドが単一の値であるか、それがリストであるか（コンマで区切られるかどうか。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2を&lt;/a&gt;参照））。リスト構文を使用しない場合は、フィールドが複数回発生するメッセージの処理方法を文書化します（適切なデフォルトはフィールドを無視することですが、これが常に正しい選択であるとは限りません）。フィールドの定義でリスト構文が許可されていなくても、仲介者とソフトウェアライブラリは複数のヘッダーフィールドインスタンスを1つのインスタンスに結合する場合があることに注意してください。堅牢なフォーマットにより、受信者はこれらの状況を発見できます（コンマは引用符付きの文字列内にのみ表示できるため、「Content-Type」、URI内にはコンマが発生する可能性があるため、「Location」など）。 oヘッダーフィールドを使用できる条件。たとえば、応答または要求のみ、すべてのメッセージ、特定の要求メソッドへの応答のみなど。o PUTリクエストでそれを理解するオリジンサーバーがフィールドを保存するかどうか。 oフィールドのセマンティクスが、既存のリクエストメソッドやステータスコードなどのコンテキストによってさらに洗練されているかどうか。 o Connectionヘッダーフィールドにフィールド名をリストすることが適切かどうか（つまり、ヘッダーフィールドをホップバイホップにする場合;を参照） &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]のセクション6.1&lt;/a&gt;）。 o仲介者がフィールドの値を挿入、削除、または変更することが許可される状況。 oフィールド名をVary応答ヘッダーフィールドにリストすることが適切かどうか（たとえば、要求ヘッダーフィールドがオリジンサーバーのコンテンツ選択アルゴリズムによって使用される場合。&lt;a href=&quot;#section-7.1.4&quot;&gt;セクション7.1.4を&lt;/a&gt;参照 ）。 oヘッダーフィールドがトレーラーで有用か許容されるか（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;[RFC7230]のセクション4.1を&lt;/a&gt;参照 ）。 oヘッダーフィールドをリダイレクト間で保持する必要があるかどうか。 oプライバシー関連データの開示など、セキュリティに関する追加の考慮事項が導入されているかどうか。</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">トレーラーの使用を規制するヘッダーフィールド：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;（要求）および&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;（応答）。</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">ヘッダーの種類</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">ヘッダーは、あるメッセージから次のメッセージまで非常によく似ていますが、それでも接続をまたいで繰り返されます。</target>
        </trans-unit>
        <trans-unit id="b9f5a636b75216c81304804a9a45004630234515" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt; handle them:</source>
          <target state="translated">ヘッダーは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;プロキシ&lt;/a&gt;がヘッダーを処理する方法に従ってグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">ヘッダーは、プロキシがどのように処理するかによってグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">ヘッダーは、その文脈に応じてグループ化することができます。</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">ヘッダーはボディとは異なり、圧縮されていません。</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">HTTP の理解とデバッグに役立つツールやリソース。</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">ここでも、他の人が有効な番号を含むことを保証するものではないので、あなたが探しているブラウザのために正しいトークンを取ることを確認してください。</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">ここでは、UA文字列にデバイスIDを持つデバイスを含むすべてのモバイルデバイスを検出するJavaScriptの正規表現を示します。</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">ここでは、ドキュメントのタイプ別に関連付けられた MIME タイプのリストを、共通の拡張子の順に並べています。</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">ここでは、HTTP で制御可能な一般的な機能のリストを示します。</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">ここでは、クライアントとサーバ間のやりとりのサンプルを紹介します。</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">以下は、&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;プリフライトされたリクエスト&lt;/a&gt;を処理するPHPの例です。</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">以下は、パーセントエンコーディングを使用してUnicode文字U + 00E8（ラテン文字の小文字EとGRAVE）を表すSlugヘッダーの例です。POST / myblog / entries HTTP / 1.1ホスト：example.org Content-Type：image / png Slug：S％C3％A8teのビーチAuthorization：Basic ZGFmZnk6c2VjZXJldA == Content-Length：nnn ... binary data Entry Resourceの作成に適用されるSlugヘッダーの例については、&lt;a href=&quot;#section-9.2.1&quot;&gt;セクション9.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">ここでは、共有キャッシュプロキシを使用した処理の例を示します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">ここでは、クレデンシャル付きのリクエストを処理するPHPを紹介します。</target>
        </trans-unit>
        <trans-unit id="8ef8c73e17b07ff09f65fb9ccc55b532e81935c5" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">ここでは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーの最も一般的な使用例を見ていきます。</target>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">ここでは、 &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーの最も一般的な使用例を示します。</target>
        </trans-unit>
        <trans-unit id="9ab6627dc7da6cad243b3faca054a977b46dce0f" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server (in addition to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt;).</source>
          <target state="translated">これは、 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダーがどのように見えるかの例です。これは、 &lt;code&gt;X-Custom-Header&lt;/code&gt; という名前のカスタムヘッダーが、サーバーへのCORSリクエストによってサポートされていることを示しています（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORSセーフリストのリクエストヘッダー&lt;/a&gt;に加えて）。</target>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダーの例を次に示します。これは、「単純な」ヘッダーに加えて、 &lt;code&gt;X-Custom-Header&lt;/code&gt; という名前のカスタムヘッダーがサーバーへのCORSリクエストでサポートされていることを示しています。</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">ここで、 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; は認証スキームです（「Basic」は最も一般的なスキームであり、&lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;以下&lt;/a&gt;で紹介します）。&lt;em&gt;レルムは、&lt;/em&gt;保護された領域を記述するために、または保護の範囲を示すために使用されます。これは、「ステージングサイトへのアクセス」などのメッセージである可能性があります。これにより、ユーザーは、アクセスしようとしているスペースを知ることができます。</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">ここで、 &lt;code&gt;base64EncodedSettings&lt;/code&gt; は、HTTP64の &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; フレームのペイロードであり、base64urlエンコードされており、このテキストヘッダー形式に安全に含めるために、末尾の &lt;code&gt;&quot;=&quot;&lt;/code&gt; （等しい）文字がすべて削除されています。</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">ここで、&lt;em&gt;xy&lt;/em&gt;はMac OS Xのバージョンです（たとえば、Mac OS X 10.6）。</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">ここでは、デフォルトでは、以下の例外を除いて、コンテンツはドキュメントの元の場所からのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">ここでは、クロスオリジンリソースシェアリングがどのように機能するかを示す3つのシナリオを示します。これらの例はすべて、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;オブジェクトを使用しています。このオブジェクトを使用して、サポートされている任意のブラウザーでクロスサイト呼び出しを行うことができます。</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">HerokuのプロキシライブラリVegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">ヒューリスティック満了</target>
        </trans-unit>
        <trans-unit id="f2bddb211b435d77bdcd54be12a624bcbd764aed" translate="yes" xml:space="preserve">
          <source>Heuristic freshness checking</source>
          <target state="translated">ヒューリスティックな鮮度検査</target>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;によって廃止されたHTTP状態管理メカニズムの歴史的な仕様</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">履歴リスト (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="2b89425faff6de6dc314db782d45b8bad9965067" translate="yes" xml:space="preserve">
          <source>History and implementation</source>
          <target state="translated">歴史と実装</target>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">ホップバイホップ圧縮</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">ホップバイホップ圧縮は、エンドツーエンド圧縮と似ていますが、1つの基本的な要素が異なります。圧縮はサーバー内のリソースでは発生せず、送信される特定の表現を作成しますが、クライアントとサーバー間のパス上の任意の2つのノード間のメッセージ。連続する中間ノード間の接続では、&lt;em&gt;異なる&lt;/em&gt;圧縮が適用される場合があります。</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">ホップバイホップヘッダー</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">ホスト(RFC2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">リバースプロキシ（ロードバランサー、CDN）のホスト名とポートは、リクエストを処理するオリジンサーバーと異なる場合があります。その場合、 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; ヘッダーは、どのホストが最初に使用されたかを判断するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f4b4c2643126c467ddef65e6b67d5f8c8b5bdc1a" translate="yes" xml:space="preserve">
          <source>Host to which the cookie will be sent.</source>
          <target state="translated">クッキーが送信されるホスト。</target>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">ホスト固有のファイル名</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">HTTPS移行のためのホスト型CSPレポート</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">ホスト名に基づく条件</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">ブラウザの仕組み</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">Cookieの仕組みは&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265で&lt;/a&gt;定義されています。HTTP要求を処理するとき、サーバーは応答とともに &lt;code&gt;Set-Cookie&lt;/code&gt; HTTPヘッダーを送信できます。次に、クライアントは、すべてのリクエストでCookieの値を &lt;code&gt;Cookie&lt;/code&gt; リクエストヘッダーの形式で同じサーバーに返します。Cookieは、特定の日付で期限切れになるように設定したり、特定のドメインおよびパスに制限したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="326d6840506a3e0e685440ecd35aff457aa45373" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies and clients, about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">ドキュメントをどのようにキャッシュするかは HTTP で制御できます。サーバはプロキシとクライアントに対して、何をどのくらいの期間キャッシュするかを指示することができます。クライアントは中間キャッシュプロキシに保存されたドキュメントを無視するように指示することができます。</target>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">ドキュメントをどのようにキャッシュするかは HTTP で制御できます。サーバはプロキシやクライアントに何をどのくらいの期間キャッシュするかを指示できます。クライアントは、中間キャッシュプロキシに保存されたドキュメントを無視するように指示することができます。</target>
        </trans-unit>
        <trans-unit id="9a92fcc6dda054aa8ba041f16e995c47ecf3e087" translate="yes" xml:space="preserve">
          <source>How much detail to include is an interesting balance to strike; exposing the OS version is probably a bad idea, as mentioned in the earlier warning about overly-detailed values. However, exposed Apache versions helped browsers work around a bug those versions had with &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">どの程度の詳細を含めるかは、興味深いバランスです。過度に詳細な値に関する以前の警告で述べたように、OSバージョンを公開することはおそらく悪い考えです。ただし、公開されたApacheバージョンは、ブラウザーが&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; を&lt;/a&gt;組み合わせた場合に発生したバグを回避するのに役立ちました。</target>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">ブラウザの扱い方</target>
        </trans-unit>
        <trans-unit id="68bee7ceae58ef9dd68bebd7e8624e01362fe458" translate="yes" xml:space="preserve">
          <source>How to Fix 405 Method Not Allowed</source>
          <target state="translated">405メソッドが許可されていないのを修正する方法</target>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">CORSのプリフライトを回避する方法</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「Access-Control-Allow-Originヘッダーをワイルドカードにすることはできません」&lt;/em&gt;を修正する方法&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">CORSの問題を修正するには?</target>
        </trans-unit>
        <trans-unit id="c305fbaf8d1dd662dd884c22cf15416371345003" translate="yes" xml:space="preserve">
          <source>How to run Chrome browser without CORS</source>
          <target state="translated">CORSなしでChromeブラウザを起動する方法</target>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">CORSプロキシを使用して&lt;em&gt;「No Access-Control-Allow-Originヘッダー」を&lt;/em&gt;回避する方法&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">ただし、リクエストに &lt;code&gt;Authorization&lt;/code&gt; ヘッダーが存在するためにリクエストがプリフライトをトリガーするリクエストである場合、上記の手順を使用して制限を回避することはできません。また、リクエストが送信されるサーバーを制御できない限り、この問題を回避することはできません。</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">しかし、整合性のないスクリプトはロードされなくなりました。</target>
        </trans-unit>
        <trans-unit id="4784e9a56ee26ccc58e9b47e0384d44d80f5b536" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via JavaScript:</source>
          <target state="translated">ただし、要素の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;プロパティに直接設定されているstylesプロパティはブロックされないため、ユーザーはJavaScriptを介してスタイルを安全に操作できます。</target>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">ただし、要素の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;プロパティに直接設定されたスタイルプロパティはブロックされないため、ユーザーはJavascriptを介して安全にスタイルを操作できます。</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">ただし、上記のコードは絶対にひどく、考えも悪いです。Chromeがこの後読み機能を削除するとどうなりますか？別のブラウザが正規表現の背後にあるルックアップを実装している場合はどうなりますか？別のブラウザがユーザーエージェント文字列で&lt;em&gt;Chrome&lt;/em&gt;を使用している場合はどうなりますか？ひどく間違っている可能性のあるもののリストはどんどん続きます。したがって、代わりに次のような特徴検出を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e339ee7e7a8e7da017468304e92dc515e180b71" translate="yes" xml:space="preserve">
          <source>However, this won't wildcard the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header, so if you need to expose that, you will need to list it explicitly:</source>
          <target state="translated">ただし、これは&lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;ヘッダーをワイルドカード化しないため、公開する必要がある場合は、明示的にリストする必要があります。</target>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly オプション</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">ハイパーテキストコーヒーポット制御プロトコル(HTCPCP/1.0</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">ハイパーテキストコーヒーポット制御プロトコル(HTCPCP/1.0)。セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">ハイパーテキスト転送プロトコル(セキュア</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">ハイパーテキストマークアップげんご</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">ハイパーテキストトランスポートプロトコルキープアライブヘッダー</target>
        </trans-unit>
        <trans-unit id="caec6dcaeb81aa6d4af95da6ddc9afca1f3451f8" translate="yes" xml:space="preserve">
          <source>Hypertext Preprocessor (&lt;strong&gt;Personal Home Page&lt;/strong&gt;)</source>
          <target state="translated">ハイパーテキストプリプロセッサ（&lt;strong&gt;個人のホームページ&lt;/strong&gt;）</target>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP)キープアライブヘッダー</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP)クライアントでは、キャンセルされたリクエストや接続の切断の結果、データ転送が中断されることがよくあります。クライアントが部分的な表現を保存している場合、表現全体を転送するのではなく、後続のリクエストでその表現の残りをリクエストすることが望ましい。同様に、ローカルストレージが限られているデバイスでは、非常に大きな文書の単一ページや埋め込み画像の寸法など、より大きな表現のサブセットのみを要求できることが利点となるかもしれません。このドキュメントでは、HTTP/1.1 の範囲要求、部分応答、および multipart/byteranges メディアタイプを定義しています。範囲要求は HTTP の OPTIONAL 機能であり、この機能を実装していない (あるいはターゲットリソースに対してこの機能をサポートしていない)受信者が、相互運用性に影響を与えることなく、通常の GET 要求のように応答できるように設計されています。部分的な応答は、この機能を実装していない可能性のあるキャッシュによって完全な応答と間違われないように、別個のステータスコードによって示されます。範囲リクエストメカニズムは拡張可能な範囲タイプを可能にするように設計されていますが、この仕様ではバイト範囲のリクエストのみを定義しています。</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1)。認証</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):キャッシング</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP/1.1)。条件付きリクエスト</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):メッセージ構文とルーティング</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):範囲リクエスト</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1)。セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP/1.1)。セマンティクスとコンテキスト</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">ハイパーテキスト転送プロトコル --HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">ハイパーテキスト転送プロトコルバージョン2(HTTP/2</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA の考慮事項 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA の考慮事項 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA の考慮事項 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANAの考慮事項(RFC7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA の考慮事項 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA の考慮事項 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="4bb8022eff5067ab10c4c96ad85499b49bef742d" translate="yes" xml:space="preserve">
          <source>IANA HTTP Range Unit Registry</source>
          <target state="translated">IANA HTTP範囲単位レジストリ</target>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANAは、'application/atom+xml'メディアタイプ登録において、この仕様への参照を追加しました。</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANAはMIMEメディアタイプの公式レジストリで&lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;あり、すべての公式MIMEタイプのリストを&lt;/a&gt;保持しています。次の表に、Webの重要なMIMEタイプをいくつか示します。</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">URIスキームのIANAリスト</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANAは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; で「HTTPコンテンツコーディングレジストリ」を維持しています。 「HTTPコンテンツコーディングレジストリ」は、以下の登録で更新されています。+ ------------ + --------------------- ----------------- + --------------- + |名前|説明|リファレンス| + ------------ + ------------------------------------ -+ --------------- + |圧縮| UNIXの「圧縮」データ形式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | |しぼむ|圧縮データを「デフレート」する| &lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）「zlib」データ内| | | |形式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIPファイル形式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | | x-compress | 非推奨（圧縮のエイリアス）| &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | | x-gzip | 非推奨（gzipのエイリアス）| &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANAは、インターネットメディアタイプ[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] のレジストリを&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;で管理しています。このドキュメントは、インターネットメディアタイプ「message / http」および「application / http」の仕様として機能します。以下はIANAに登録されています。</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANAは、インターネットメディアタイプ[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] のレジストリを&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;で管理しています。このドキュメントは、インターネットメディアタイプ「multipart / byteranges」の仕様となります。以下はIANAに登録されています。</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANAは、URIスキームのレジストリ[ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ]を&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;に維持しています。このドキュメントでは次のURIスキームを定義しているため、「Permanent URI Schemes」レジストリはそれに応じて更新されています。 + ------------ + ------------------------------------ + --------------- + | URIスキーム|説明|リファレンス| + ------------ + ------------------------------------ + --------------- + | http |ハイパーテキスト転送プロトコル| &lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt; | | https |安全なハイパーテキスト転送プロトコル| &lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">HTTPステータスコードのIANA公式レジストリ</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">イアナレジストリ</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">認証スキームのIANAレジストリ</target>
        </trans-unit>
        <trans-unit id="433dbaf6332943984d6516e68b5f7fa26960c972" translate="yes" xml:space="preserve">
          <source>ICO</source>
          <target state="translated">ICO</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">アイイーティーエフドラフト</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">アイイーティーエフアールエフ</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">アイコン形式</target>
        </trans-unit>
        <trans-unit id="ca9f65841299353702f59413c67b4d41e934a6e4" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for each resource. But there are reasons for alternative names for a resource:</source>
          <target state="translated">理想的には、各リソースに対して一つの場所、つまり一つの URL が存在します。しかし、リソースの代替名には理由があります。</target>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">理想的には、1つのリソースに対して1つの場所、つまり1つのURLが存在します。ただし、リソースに別の名前を付けたい理由があります（wwwプレフィックスがある場合とない場合、または短くて覚えやすいURLなど、いくつかのドメイン）。このような場合、リソースを複製するのではなく、1つの真の（正規の）URLへのリダイレクトを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">アイデムポテントメソッド (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">クライアントがプロキシやロードバランサーに接続するために使用した元のホストを識別します。</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">HTTP プロキシまたはロードバランサーを介してウェブサーバに接続するクライアントの発信元 IP アドレスを識別します。</target>
        </trans-unit>
        <trans-unit id="4728d359ae99afe818be6f9dc7667972f09461f4" translate="yes" xml:space="preserve">
          <source>Identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">クライアントがプロキシやロードバランサーに接続するために使用したプロトコル (HTTP または HTTPS)を識別します。</target>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">許可されたリクエスト方法の識別</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">ウェブ上のリソースを特定する</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">課題の特定</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">場合は&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（関連項目）応答は常にの使用につながる&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッド、&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;（一時的なリダイレクト）と&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;（パーマネントリダイレクト）は、元の要求に使用される方法を変更しないでください。</target>
        </trans-unit>
        <trans-unit id="203f83a39c006e96b0372879695a48c384f5a98d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Viewport-Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences.</source>
          <target state="translated">場合は &lt;code&gt;Viewport-Width&lt;/code&gt; 複数回のメッセージで発生し、最後の値が以前のすべての出現を上書きします。</target>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If = &quot;If&quot; &quot;：&quot;（1 *タグなしリスト| 1 *タグ付きリスト）タグなしリスト=リストタグ付きリスト=リソースタグ1 *リストリスト= &quot;（&quot; 1 *条件 &quot;） &quot;Condition = [&quot; Not &quot;]（State-token |&quot; [&quot;entity-tag&quot;] &quot;）; entity-tag：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]のセクション3.11を&lt;/a&gt;参照してください 。 「[」、エンティティタグ、「]」の間でLWSを許可しないState-token = Coded-URL Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;; simple-ref：&lt;a href=&quot;#section-8.3&quot;&gt;セクション8.3を&lt;/a&gt;参照 ; Resource-TagでLWSを許可しない構文は、タグなしリスト（「No-tag-list」）とタグ付きリスト（「Tagged-list」）を区別します。タグなしリストはRequest-URIで識別されるリソースに適用され、タグ付きリストは先行するResource-Tagで識別されるリソースに適用されます。リソースタグは、次のリソースタグまで、後続のすべてのリストに適用されます。 2つのリストタイプをIfヘッダー内で混在させることはできません。 No-tag-list構文は、Request-URIを参照するResource-Tagを使用したタグ付きリストプロダクションの略記であるため、これは機能上の制限ではありません。各リストは、1つ以上の条件で構成されています。各条件は、エンティティタグまたはステートトークンの観点から定義され、接頭辞「Not」によって潜在的に否定されます。Ifヘッダー構文では、単一のリクエストでIfヘッダーの複数のインスタンスを使用できないことに注意してください。ただし、HTTPヘッダー構文では、改行の後に空白を挿入することで、単一のヘッダー値を複数行に拡張できます（[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、&lt;a href=&quot;#section-4.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">HTTP パイプラインを有効にすると、最初のレスポンスが完全に受信されるのを待たずに、いくつかのリクエストを送信することができます。HTTP パイプラインは、古いソフトウェアが最新のバージョンと共存している既存のネットワークでは実装が難しいことが証明されています。HTTP パイプラインは HTTP/2 に取って代わられ、フレーム内のリクエストをより強固に多重化するようになりました。</target>
        </trans-unit>
        <trans-unit id="748bef436e961cb49a985af369e84e4c57fb5faa" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are inadequate to access a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">（プロキシ）サーバが特定のリソースにアクセスするには不十分である有効な資格情報を受信した場合、サーバが応答しなければならないと&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; ステータスコード。異なり、&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; または&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 、認証がこのユーザーのために不可能です。</target>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">（プロキシ）サーバーが、特定のリソースへのアクセスを取得するのに適切ではない有効な資格情報を受信した場合、サーバーは&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; ステータスコードで応答する必要があります。&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; または&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; とは異なり、このユーザーの認証は不可能です。</target>
        </trans-unit>
        <trans-unit id="9c01487d51a7abfed59147d7589b11bd17b56929" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/a&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">場合&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt; &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; &lt;/a&gt;ヘッダを用意し、このヘッダーの値をとり、文字列「258EAFA5-E914-47DA-95CA-C5AB0DC85B11」それにを連結し、キーの値をとることによって計算される&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;のハッシュをその連結された文字列は、20バイトの値になります。次に、その値は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64で&lt;/a&gt;エンコードされ、このプロパティの値を取得します。</target>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; メソッドが正常に適用された場合、いくつかの応答ステータスコードが考えられます。</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">場合 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; ヘッダを用意し、このヘッダーの値をとり、文字列「258EAFA5-E914-47DA-95CA-C5AB0DC85B11」それにを連結し、キーの値をとることによって計算される&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;のハッシュをその連結された文字列は、20バイトの値になります。次に、その値を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64で&lt;/a&gt;エンコードして、このプロパティの値を取得します。</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">COPYリクエストに「F」の値を持つOverwriteヘッダーがあり、リソースが宛先URLに存在する場合、サーバーはリクエストを失敗させる必要があります。サーバーがCOPYリクエストを実行して宛先リソースを上書きする場合、正確な動作はWebDAV拡張機能を含む多くの要因に依存する可能性があります（特に[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253を&lt;/a&gt;参照]]）。たとえば、通常のリソースが上書きされると、サーバーはコピーを実行する前にターゲットリソースを削除したり、ライブプロパティを保持するために上書きしたりできます。コレクションが上書きされる場合、COPYリクエストが成功した後の宛先コレクションのメンバーシップは、COPYの直前のソースコレクションと同じメンバーシップである必要があります。したがって、ソースコレクションと宛先コレクションのメンバーシップを宛先でマージすることは、準拠した動作ではありません。一般に、クライアントがCOPYの前に宛先URLの状態を消去する必要がある場合（たとえば、ライブプロパティを強制的にリセットするため）、クライアントはCOPYリクエストの前にDELETEを宛先に送信して、このリセットを確認できます。 。</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">キャッシュが表現可能な値よりも大きい値を受け取った場合、またはその後の計算でオーバーフローした場合、キャッシュはその値を 2147483648 (2^31)または都合よく表現可能な最大の正の整数のいずれかであるとみなします。</target>
        </trans-unit>
        <trans-unit id="f48cab758bf32db6fab20e2d919807414feba7e5" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider this value to be either 2,147,483,648 (2&lt;sup&gt;31&lt;/sup&gt;) or the greatest positive integer it can represent.</source>
          <target state="translated">キャッシュが表現できる値よりも大きい値を受け取った場合、または後続の計算のいずれかがオーバーフローした場合、キャッシュはこの値を2,147,483,648（2 &lt;sup&gt;31&lt;/sup&gt;）または表現できる最大の正の整数と見なします。</target>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">クライアントが表現の部分的なコピーを持っていて、表現全体の最新のコピーを持ちたい場合、条件付きGETでRangeヘッダーフィールドを使用できます（If-Unmodified-SinceとIfのいずれかまたは両方を使用） -一致。）ただし、表現が変更されたために前提条件が満たされない場合、クライアントは現在の表現全体を取得するために2番目の要求を行う必要があります。 「If-Range」ヘッダーフィールドを使用すると、クライアントは2番目のリクエストを「短絡」できます。非公式には、その意味は次のとおりです。表現が変更されていない場合は、範囲で要求しているパーツを送ってください。それ以外の場合は、表現全体を送ってください。If-Range = entity-tag / HTTP-dateクライアントは、Rangeヘッダーフィールドを含まないリクエストでIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]のセクション2.2.2&lt;/a&gt;。 If-Range前提条件を評価するサーバーは、エンティティタグを比較するときに強力な比較関数を使用する必要があり（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]のセクション2.3.2&lt;/a&gt;）、強力ではないHTTP日付バリデーターが提供される場合、条件をfalseとして評価する必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]のセクション2.2.2で&lt;/a&gt;定義されている意味でのバリデータ。有効なエンティティタグは、DQUOTEの最初の2文字を調べることにより、有効なHTTP日付と区別できます。 If-Rangeヘッダーフィールドで指定されたバリデーターが、ターゲットリソースの選択された表現の現在のバリデーターと一致する場合、サーバーは要求に応じてRangeヘッダーフィールドを処理する必要があります（SHOULD）。バリデーターが一致しない場合、サーバーはRangeヘッダーフィールドを無視する必要があります。完全一致によるこの比較は、バリデーターがHTTP日付の場合も含めて、If-Unmodified-Since条件を評価するときに使用される「以前の値または等しい」比較とは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">クライアントがキャッシュ内にあるエンティティの部分的なコピーを持っていて、キャッシュ内のエンティティ全体の最新のコピーを取得したい場合、条件付きGET(If-Unmodified-SinceとIf-Matchのどちらか、または両方を使用)でRangeリクエストヘッダを使用することができます。If-Rangeヘッダーは、クライアントが2回目のリクエストを「短絡」させることを可能にする。非公式には、その意味は「エンティティが変更されていなければ、私が見落としている部分を送ってください。If-Range=&quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date)クライアントがエンティティに対してエンティティタグを持たないが、Last-Modifiedの日付を持っている場合、その日付をIf-Rangeヘッダーで使用してもよい[MAY]。(サーバーは、有効なHTTP-dateといかなる形式のエンティティタグを 2文字以下の文字を調べることで区別することができる)。If-RangeヘッダーはRangeヘッダーと共にのみ使用されるべきであり[SHOULD]、 リクエストがRangeヘッダーを含まない場合、またはサーバーが サブレンジ操作をサポートしない場合は無視されなければならない[MUST]。If-Rangeヘッダーで与えられたエンティティタグがそのエンティティの現在の エンティティタグにマッチする場合、サーバーは206(Partial content)応答を使用してエンティティの指定されたサブレンジを提供するべきである[SHOULD]。エンティティタグがマッチしない場合、サーバーは200(OK)応答を使用して エンティティ全体を返すべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="3088b6387af36bd48fbfec162964786d9f1bdf8a" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is also marked with the &lt;code&gt;Secure&lt;/code&gt; attribute, was sent from a secure origin, does &lt;em&gt;not&lt;/em&gt; include a &lt;code&gt;Domain&lt;/code&gt; attribute, and has the &lt;code&gt;Path&lt;/code&gt; attribute set to &lt;code&gt;/&lt;/code&gt;. In this way, these cookies can be seen as &quot;domain-locked&quot;.</source>
          <target state="translated">Cookie名にこのプレフィックスが付いている場合、&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーで受け入れられるのは、 &lt;code&gt;Secure&lt;/code&gt; 属性もマークされており、安全なオリジンから送信され、 &lt;code&gt;Domain&lt;/code&gt; 属性が含まれておら&lt;em&gt;ず&lt;/em&gt;、 &lt;code&gt;Path&lt;/code&gt; 属性が &lt;code&gt;/&lt;/code&gt; に設定されている場合のみです。。このように、これらのCookieは「ドメインロック」と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="c034021e921f0e666de945c6149637ed216dc323" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is marked with the &lt;code&gt;Secure&lt;/code&gt; attribute and was sent from a secure origin. This is weaker than the &lt;code&gt;__Host-&lt;/code&gt; prefix.</source>
          <target state="translated">Cookie名にこのプレフィックスが付いている場合、 &lt;code&gt;Secure&lt;/code&gt; 属性でマークされ、安全な発信元から送信された場合にのみ、&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーで受け入れられます。これは &lt;code&gt;__Host-&lt;/code&gt; プレフィックスよりも弱いです。</target>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">新しいキャッシュ可能に（セクションを参照した場合&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;、&lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;、&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;および&lt;a href=&quot;#section-13.8&quot;&gt;13.8を&lt;/a&gt;同じリソースに対する既存のレスポンスがキャッシュされている間に）レスポンスがリソースから受信され、キャッシュは現在に返信する新しいレスポンスを使用すべきですリクエスト。それをキャッシュストレージに挿入してもよいし、他のすべての要件を満たしている場合は、それを使用して、以前に古い応答が返される原因となっていた将来の要求に応答してもよい。新しい応答をキャッシュストレージに挿入する場合、&lt;a href=&quot;#section-13.5.3&quot;&gt;セクション13.5.3の&lt;/a&gt;ルールが適用されます。注：既存のキャッシュされた応答よりも古い日付ヘッダー値を持つ新しい応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">リクエストが複数のプロキシを経由する場合、各プロキシのIPアドレスがリストされます。つまり、一番右のIPアドレスが一番新しいプロキシのIPアドレスで、 一番左のIPアドレスが発信元のクライアントのIPアドレスである。</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">宛先にリソースが存在し、Overwriteヘッダーが「T」である場合、移動を実行する前に、サーバーは宛先リソースに対して「Depth:infinity」でDELETEを実行しなければならない[MUST]。上書きヘッダーが「F」に設定されている場合、操作は失敗する。</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">同じサイトのCookieにこの属性がある場合、Cookieを設定したWebサイトから要求が発信された場合にのみ、ブラウザーはCookieを送信します。リクエストが現在の場所のURLとは異なるURLから発生した場合、 &lt;code&gt;strict&lt;/code&gt; 属性でタグ付けされたcookie は含まれません。</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">サーバがこのようなエラーステータスを返す場合、メッセージの本文には、利用可能なリソースの表現のリストが含まれ、ユーザがそれらの中から選択できるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">単一のサーバが、互いに信頼できない複数の組織をサポートしている場合、その組織が権限のないリソースを無効にしようとしないことを 確認するために、その組織の管理下で生成される応答の中のLocationおよびContent-Locationヘッダの値を チェックしなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">ユーザーがWebサイトまたはサービスからサインアウトした場合、ローカルに保存されたデータを削除することができます。これは、https：//example.com/logoutの応答に &lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダーを追加することで実現できます。</target>
        </trans-unit>
        <trans-unit id="28708bd5ed063a05bc0c1ffae01007cff1ddad84" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header when sending the page confirming that logging out from the site has been accomplished successfully (https://example.com/logout, for example):</source>
          <target state="translated">ユーザーがWebサイトまたはサービスからサインアウトした場合、ローカルに保存されているデータを削除することをお勧めします。これは、サイトからのログアウトが正常に完了したことを確認するページを送信するときに &lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダーを追加することで実現できます（https://example.com/logoutなど）。</target>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">Web サイトが HTTP で接続を受け付けて HTTPS にリダイレクトすると、訪問者が最初に暗号化されていないバージョンのサイトと通信してからリダイレクトされる可能性があります。これは、中間者攻撃の機会を生み出します。リダイレクトは、訪問者を元のサイトの安全なバージョンではなく、悪意のあるサイトに誘導するために悪用される可能性がある。</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">すべてのプロキシがダウンしており、DIRECT オプションが指定されていない場合、ブラウザはプロキシを一時的に無視して直接接続を試みるべきかどうかを尋ねます。20 分後、ブラウザはプロキシを再試行すべきかどうかを尋ね、さらに 40 分後に再度尋ねます。クエリは継続され、クエリ間の経過時間に常に 20 分が加算されます。</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">HTTP/1.1クライアントが、リクエストボディを含むが「100-continue」の期待値を持つ Expectリクエストヘッダーフィールドを含まないリクエストを送る場合、クライアントがHTTP/1.1オリジンサー バーに直接接続されておらず、クライアントがサーバーから何らかのステータスを受け取る前 に接続が終了するのを見る場合、クライアントはリクエストを再試行するべきである[SHOULD]。クライアントがこのリクエストを再試行する場合、信頼できる応答を確実に得るために、 以下の「バイナリ指数バックオフ(binary exponential backoff)」アルゴリズムを使用してもよい[MAY]。1.1.サーバーへの新しい接続を開始する。2.リクエストヘッダーを送信する 3.3.変数Rをサーバーへの推定往復時間(例えば、接続を確立するのにかかった時間に基づ く)に初期化するか、往復時間が利用できない場合は5秒の定数値に初期化する。4.4.T=R*(2**N)を計算する。Nはこのリクエストの前回の再試行回数である。5.5.サーバからのエラー応答を待つか、T秒待つ(どちらか早い方)6.6.エラー応答を受け取らない場合、T秒後にリクエストの本文を送信する。7.7.クライアントが接続が早々に終了したことを確認した場合は、リクエストが受理されるか、エラー応答を受信するか、ユーザーが焦ってリトライ処理を終了するまで、ステップ1から繰り返す。どの時点でもエラーステータスを受け取った場合、クライアントは -続行すべきではなく[SHOULD NOT]、 リクエストメッセージの送信が完了していない場合は接続を閉じるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="787c64d4a2d625599ff698430e64f8f08ddeb6a2" translate="yes" xml:space="preserve">
          <source>If an origin server does not explicitly specify freshness (e.g. using &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header) then a heuristic approach may be used.</source>
          <target state="translated">オリジンサーバーが鮮度を明示的に指定していない場合（たとえば、&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーを使用）、ヒューリスティックアプローチを使用できます。</target>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">別のプリンシパルがプリンシパルがアクセスしたいリソースをロックした場合、第二のプリンシパルが第一のプリンシパルが誰であるかを知ることができると便利です。この目的のために DAV:lockdiscovery プロパティが提供されています。このプロパティは、すべての未解決のロックをリストアップし、そのタイプを記述し、ロックトークンを提供してもよいでしょう(MAY)。LOCK メソッドをサポートする DAV 準拠のリソースはすべて DAV:lockdiscovery プロパティをサポートしなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">&lt;strong&gt;wd1&lt;/strong&gt;と&lt;strong&gt;wd1の&lt;/strong&gt;両方が定義されている場合、現在の平日が&lt;em&gt;順序付けられた&lt;/em&gt; 2つの平日の間にある場合、条件は真です。&lt;em&gt;境界&lt;/em&gt;は包括的です&lt;em&gt;が、境界は順序付けられてい&lt;/em&gt;ます。「GMT」パラメーターが指定されている場合、時刻はGMTであると見なされます。それ以外の場合は、ローカルのタイムゾーンが使用されます。</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">両方の場合は&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダと&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーが同じ応答で存在している、両方のポリシーが優先されます。 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; ポリシーがレポートを生成する間、 &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダーで指定されたポリシーが適用されますが、適用されません。</target>
        </trans-unit>
        <trans-unit id="d126e6f1349def738aa84d3d7ade4189f1674e03" translate="yes" xml:space="preserve">
          <source>If both this directive (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence. There was a bug whereby the &lt;code&gt;fullscreen&lt;/code&gt; directive didn't work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute was also present, but this has been fixed as of Firefox 80 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;bug 1608358&lt;/a&gt;).</source>
          <target state="translated">このディレクティブ（つまり、 &lt;code&gt;allow&lt;/code&gt; 属性を介して）と &lt;code&gt;allowfullscreen&lt;/code&gt; 属性の両方が &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 要素に存在する場合、このディレクティブが優先されます。そこせるバグだった &lt;code&gt;fullscreen&lt;/code&gt; ない限り、ディレクティブは動作しませんでした &lt;code&gt;allowfullscreen&lt;/code&gt; の属性も存在していたが、これは、Firefox 80（のように固定されている&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;バグ1608358&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">このディレクティブと &lt;code&gt;allowfullscreen&lt;/code&gt; 属性の両方が &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 要素に存在する場合、このディレクティブが優先されます。</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; が指定されていない場合、デフォルトでは、コンテンツはすべての言語の対象ユーザーを対象としています。複数の言語タグも可能であり、 &lt;code&gt;Content-Language&lt;/code&gt; ヘッダーをテキストドキュメントだけでなくさまざまなメディアタイプに適用することもできます。</target>
        </trans-unit>
        <trans-unit id="5f0faef3900e1d15f4d91c1fcfcd5a68d9578e75" translate="yes" xml:space="preserve">
          <source>If no URL scheme is specified for a &lt;code&gt;host-source&lt;/code&gt; and the iframe is loaded from an &lt;code&gt;https&lt;/code&gt; URL, the URL for the page loading the iframe must also be &lt;code&gt;https&lt;/code&gt;, per the W3C spec on &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;matching source expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host-source&lt;/code&gt; URLスキームが指定されておらず、iframeが &lt;code&gt;https&lt;/code&gt; URLからロードされる場合、&lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;一致するソース式&lt;/a&gt;に関するW3C仕様に従って、iframeをロードするページのURLも &lt;code&gt;https&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">ポートが指定されていない場合は、要求されたサービスのデフォルトポート(例えば、HTTP URLの場合は &quot;80 &quot;など)が暗示されます。</target>
        </trans-unit>
        <trans-unit id="9619fd8159a262a6e7f8b156f3e9ea6322194094" translate="yes" xml:space="preserve">
          <source>If no port is included, the default port for the service requested (e.g., &lt;code&gt;443&lt;/code&gt; for an HTTPS URL, and &lt;code&gt;80&lt;/code&gt; for an HTTP URL) is implied.</source>
          <target state="translated">ポートが含まれていない場合、要求されたサービスのデフォルトポート（たとえば、HTTPS URLの場合は &lt;code&gt;443&lt;/code&gt; 、HTTP URLの場合は &lt;code&gt;80&lt;/code&gt; ）が暗黙指定されます。</target>
        </trans-unit>
        <trans-unit id="e478b06858c696e70a28213656753916abc92ba3" translate="yes" xml:space="preserve">
          <source>If omitted, defaults to the host of the current document URL, not including subdomains.</source>
          <target state="translated">省略した場合は、サブドメインを含まない、現在のドキュメントURLのホストがデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">単一の値のみが指定されている場合（各カテゴリーから：日、月、年）、関数はその指定に一致する日にのみtrue値を返します。両方の値が指定されている場合&lt;em&gt;、境界&lt;/em&gt;を含むそれらの時間の間の結果はtrueです&lt;em&gt;が、境界は順序付けられ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">単一の値のみが指定されている場合（各カテゴリーから：時間、分、秒）、関数はその指定に一致する場合にのみ真の値を返します。両方の値が指定されている場合&lt;em&gt;、境界&lt;/em&gt;を含むそれらの時間の間の結果はtrueです&lt;em&gt;が、境界は順序付けられ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">パラメータが1つだけ指定された場合、関数はパラメータが表す平日にtrueを返します。2番目のパラメータとして文字列 &quot;GMT&quot; が指定された場合、時刻はGMTとみなされます。それ以外の場合は、ローカルタイムゾーンであるとみなされます。</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">複数の範囲が返送される場合、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;multipart/byteranges&lt;/code&gt; に設定され、各フラグメントは1つの範囲をカバーし、&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;はそれを記述します。</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">サイトが &lt;code&gt;Accept-Ranges&lt;/code&gt; ヘッダーを省略した場合、それらはおそらく部分的なリクエストをサポートしません。一部のサイトでは、値として「 &lt;code&gt;none&lt;/code&gt; 」を明示的に送信しており、サポートがないことを示しています。その場合、一部のアプリでは、ダウンロードマネージャーが一時停止ボタンを無効にします。</target>
        </trans-unit>
        <trans-unit id="c8a2e2bc49a74014d19dc3e20faf6d47f4b2c5fb" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">サイトが &lt;code&gt;Accept-Ranges&lt;/code&gt; ヘッダーを省略している場合、部分的なリクエストをサポートしていない可能性があります。一部のサイトでは、値として「 &lt;code&gt;none&lt;/code&gt; 」を明示的に送信し、サポートがないことを示しています。一部のアプリでは、その場合、ダウンロードマネージャーは一時停止ボタンを無効にします。</target>
        </trans-unit>
        <trans-unit id="091a0218219abd0cdbbefc8a401d17bce706512c" translate="yes" xml:space="preserve">
          <source>If that's not possible, then another way is to:</source>
          <target state="translated">それができないのであれば、別の方法があります。</target>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">Basic」認証スキームを使用している場合、クレデンシャルはこのように構成されます。</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">場合は&lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; HTTPレスポンスに存在している（と、その値が「ではないん &lt;code&gt;none&lt;/code&gt; 」）、サーバーがサポートは、要求の範囲。たとえば、&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;リクエストとcURLを発行してこれを確認できます。</target>
        </trans-unit>
        <trans-unit id="1e2bd82bb2d016fc76410dd12a3b0342a93316e7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request with cURL, for example.</source>
          <target state="translated">場合は&lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; HTTPレスポンスに存在している（と、その値が「ではないん &lt;code&gt;none&lt;/code&gt; 」）、サーバーがサポートは、要求の範囲。これは、たとえばcURLを使用して&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;リクエストを発行することで確認できます。</target>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">ヘッダーが応答に含まれている場合でも、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;がこのヘッダーに指定された値を検出できない場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">CORS構成が正しく設定されていない場合、ブラウザーコンソールに &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; ようなエラーが表示され、CORSセキュリティに違反したために要求がブロックされたことを示しますルール。ただし、これは必ずしもセットアップの間違いではない可能性があります。ユーザーのウェブアプリケーションとリモートの外部サービスによって、リクエストが実際に意図的に拒否されている可能性があります。ただし、エンドポイントを使用できるようにする場合は、成功するためにいくつかのデバッグが必要です。</target>
        </trans-unit>
        <trans-unit id="dc9c7b7249ed9c2cd26babda62bc7a605dd20286" translate="yes" xml:space="preserve">
          <source>If the CORS request indicated by the preflight request is authorized, the server will respond to the preflight request with a message that indicates the allowed origin, methods and headers. Below we see that &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; includes the headers that were requested.</source>
          <target state="translated">プリフライトリクエストで示されたCORSリクエストが承認された場合、サーバーはプリフライトリクエストに応答して、許可されたオリジン、メソッド、ヘッダーを示すメッセージを表示します。以下に、&lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;に要求されたヘッダーが含まれていることがわかります。</target>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">属性が緩く設定されている場合、同じサイトのクッキーは、画像やフレームを読み込むための呼び出しなどのクロスドメインのサブリクエストでは保留されますが、ユーザーがリンクをたどるなどして外部サイトからURLにナビした場合には送信されます。</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">クライアントが条件付きGETリクエストを実行し、アクセスは許可されているが、ドキュメントが変更されていない場合、サーバーはこのステータスコードで応答する必要があります（SHOULD）。 304応答にはメッセージ本文を含めることはできません。したがって、常にヘッダーフィールドの後の最初の空行で終了します。応答には次のヘッダーフィールドを含める必要があり&lt;a href=&quot;#section-14.18.1&quot;&gt;ます。-セクション14.18.1で&lt;/a&gt;省略が必要な場合を除いて、日付。 クロックレスオリジンサーバーがこれらのルールに従い、プロキシとクライアントが独自の日付を、応答なしで受信した応答に追加した場合（すでに&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068]、セクション14.19&lt;/a&gt;）、キャッシュは正しく動作します。 -ヘッダーが同じリクエストへの200応答で送信された場合、ETagおよび/またはContent-Location-Expires、Cache-Control、および/またはVary、以前の応答で送信されたものとフィールド値が異なる場合同じバリアントの場合条件付きGETが強力なキャッシュバリデーターを使用した場合（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3を&lt;/a&gt;参照））、応答には他のエンティティヘッダーを含めないでください。それ以外の場合（つまり、条件付きGETが弱いバリデーターを使用した場合）、応答に他のエンティティヘッダーを含めてはなりません（MUST NOT）。これにより、キャッシュされたエンティティ本体と更新されたヘッダーの間の不整合が防止されます。304応答が、現在キャッシュされていないエンティティを示している場合、キャッシュは応答を無視し、条件なしで要求を繰り返す必要があります。キャッシュが受信した304応答を使用してキャッシュエントリを更新する場合、キャッシュはエントリを更新して、応答で指定された新しいフィールド値を反映する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 応答を受け取ったクライアントがTLSにアップグレードできる場合、クライアントが開始したTLSへのアップグレードで説明した同じプロセスを&lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;開始する必要があります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">データがテキストの場合、テキストを埋め込むことができます（適切なエンティティを使用するか、囲んでいるドキュメントのタイプに基づいてエスケープします）。それ以外の場合は、 &lt;code&gt;base64&lt;/code&gt; を指定して、base64でエンコードされたバイナリデータを埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="32b1f46a0b7b90a86ae9e9f167e9ef7cf8038c9c" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data. You can find more info on MIME types &lt;a href=&quot;mime_types&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">データがテキストの場合は、単にテキストを埋め込むことができます（適切なエンティティを使用するか、囲んでいるドキュメントのタイプに基づいてエスケープします）。それ以外の場合は、 &lt;code&gt;base64&lt;/code&gt; を指定してbase64でエンコードされたバイナリデータを埋め込むことができます。MIMEタイプの詳細については、&lt;a href=&quot;mime_types&quot;&gt;ここ&lt;/a&gt;と&lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;ここを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b8559d1d219606090271c33a621201ee02497f80" translate="yes" xml:space="preserve">
          <source>If the desired resource width is not known at the time of the request or the resource does not have a display width, the &lt;code&gt;Width&lt;/code&gt; header field can be omitted. If &lt;code&gt;Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences</source>
          <target state="translated">リクエスト時に目的のリソース幅がわからない場合、またはリソースに表示幅がない場合は、 &lt;code&gt;Width&lt;/code&gt; ヘッダーフィールドを省略できます。場合は &lt;code&gt;Width&lt;/code&gt; 複数回のメッセージで発生し、最後の値が以前のすべての出現を上書きします</target>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">「Mobi」のマークが付いていないほどデバイスが大きい場合は、デスクトップサイトを提供する必要があります（ベストプラクティスとして、タッチスクリーンが表示されるデスクトップマシンが増えるため、とにかくタッチ入力をサポートする必要があります）。</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">ハッシュが一致しない場合、ドキュメントが &lt;code&gt; Precondition Failed&lt;/code&gt; 編集されており、&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; Precondition Failedエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="277939955257bc43f4243fef87536e0654d15a25" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">ハッシュが一致しない場合は、ドキュメントがその間に編集され、&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; エラーがスローされたことを意味します。</target>
        </trans-unit>
        <trans-unit id="3fd651b3de41c4c0939b139c2bcd1ec691c3efd5" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">ハッシュが一致しない場合は、ドキュメントがその間に編集され、&lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; エラーがスローされたことを意味します。</target>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">リクエストが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;を使用して発行されている場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;true&lt;/code&gt; に設定していないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">要求されたメソッドがサポートされていない場合、サーバはエラーで応答します。</target>
        </trans-unit>
        <trans-unit id="bd63754e6e7fd0ed5e66293b22c5760094fd4fcf" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value &lt;em&gt;must&lt;/em&gt; be generated. A comparison of them can determine whether two representations of a resource are the same. Etags are therefore similar to fingerprints, and might also be used for tracking purposes by some servers. They might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">特定のURLのリソースが変更された場合、新しい &lt;code&gt;Etag&lt;/code&gt; 値を生成する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。それらを比較することで、リソースの2つの表現が同じであるかどうかを判断できます。したがって、Etagは指紋に似ており、一部のサーバーでは追跡目的で使用される場合もあります。また、追跡サーバーによって無期限に存続するように設定されている場合もあります。</target>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">特定のURLのリソースが変更された場合、新しい &lt;code&gt;Etag&lt;/code&gt; 値を生成する必要があります。したがって、etagsは指紋に似ており、一部のサーバーでは追跡目的で使用されることもあります。それらを比較することで、リソースの2つの表現が同じであるかどうかをすばやく判別できますが、追跡サーバーによって無期限に永続化するように設定することもできます。</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">リソースが変更された場合、サーバーは、リクエストが条件付きではなく、クライアントがこの新しいリソースを使用（およびキャッシュ）する場合と同様に、リソースの新しいバージョンで&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 応答を返します。</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">リソースが変更されていない場合、サーバーは&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 応答を返します。これにより、キャッシュが再びフレッシュになり、クライアントはキャッシュされたリソースを使用します。一部のリソースを消費する応答/要求のラウンドトリップがありますが、これは、リソース全体を再びネットワーク経由で送信するよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">問題のリソースが広くアクセスされることを意図している場合（GETによってアクセスされるHTTPリソースと同様に）、リソースが&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;やHTTP などの資格情報を必要とし&lt;strong&gt;ない限り&lt;/strong&gt;、&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; ヘッダーを送り返すだけで十分です。認証情報。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">リソースをリクエスタドメインに基づいて制限する必要がある場合、&lt;strong&gt;または&lt;/strong&gt;リソースに認証情報でアクセスする必要がある場合（または認証情報を設定する場合）、リクエストの&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダーによるフィルタリングが必要になるか、少なくともリクエスタの &lt;code&gt;Origin&lt;/code&gt; をエコーバックする必要があります（例：&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.com）。さらに、&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; ヘッダーを送信する必要があります。これについては、&lt;a href=&quot;#Credentialed_Requests&quot;&gt;次のセクションで&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="9c8e2ffc70a619ab233773bc1539c19cb10a2bc1" translate="yes" xml:space="preserve">
          <source>If the response to a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached URL response is now outdated, the cached copy is invalidated even if no &lt;code&gt;GET&lt;/code&gt; request was made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 要求への応答で、キャッシュされたURL応答が古くなっていることが示された場合、 &lt;code&gt;GET&lt;/code&gt; 要求が行われていなくても、キャッシュされたコピーは無効になります。</target>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; リクエストの結果が、&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;リクエスト後にキャッシュされたリソースが古くなっていることを示している場合、 &lt;code&gt;GET&lt;/code&gt; リクエストが行われていなくても、キャッシュは無効になります。</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">応答の最適な表現の選択がサーバーにあるアルゴリズムによって行われる場合、それはサーバー駆動のネゴシエーションと呼ばれます。選択は、応答の利用可能な表現（変化する可能性のある次元、たとえば言語、コンテンツコーディングなど）と、要求メッセージ内の特定のヘッダーフィールドの内容、または要求に関連するその他の情報（たとえば、クライアントのネットワークアドレスとして）。サーバー主導のネゴシエーションは、利用可能な表現から選択するためのアルゴリズムをユーザーエージェントに説明することが難しい場合、またはサーバーが最初の応答と一緒にその「最良の推測」をクライアントに送信することを望む場合に有利です（ 「最良の推測」の場合、後続のリクエストの往復遅延ユーザーにとって十分です）。サーバーの推測を改善するために、ユーザーエージェントは、そのような応答の設定を記述する要求ヘッダーフィールド（Accept、Accept-Language、Accept-Encodingなど）を含めることができます（MAY）。サーバー主導のネゴシエーションには欠点があります。1。ユーザーエージェントの機能と応答の使用目的の両方について完全な知識が必要になるため、サーバーが特定のユーザーにとって何が「最適」かを正確に判断することは不可能です。 （例えば、ユーザーはそれを画面に表示したり、紙に印刷したりしますか？） 2。ユーザーエージェントにすべてのリクエストでその機能を説明させることは非常に非効率的であり（応答のごく一部のみが複数の表現を持つ場合）、ユーザーのプライバシーの潜在的な違反となる可能性があります。 3.オリジンサーバーの実装と、要求に対する応答を生成するためのアルゴリズムが複雑になります。 4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。&lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt;）、Accept- Charset（&lt;a href=&quot;#section-14.2&quot;&gt;セクション14.2&lt;/a&gt;）、Accept-Encoding（&lt;a href=&quot;#section-14.3&quot;&gt;セクション14.3&lt;/a&gt;）、Accept- Language（&lt;a href=&quot;#section-14.4&quot;&gt;セクション14.4&lt;/a&gt;）、およびUser-Agent（&lt;a href=&quot;#section-14.43&quot;&gt;セクション14.43&lt;/a&gt;）。ただし、オリジンサーバーはこれらのディメンションに限定されず、リクエストヘッダーフィールドの外側またはこの仕様で定義されていない拡張ヘッダーフィールド内の情報を含む、リクエストのあらゆる側面に基づいて応答を変更する場合があります。Varyヘッダーフィールドは、サーバー主導のネゴシエーションの対象となる表現を選択するためにサーバーが使用するパラメーターを表すために使用できます。キャッシュによるVaryヘッダーフィールドの使用と&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44&lt;/a&gt;については、&lt;a href=&quot;#section-13.6&quot;&gt;セクション13.6&lt;/a&gt;を参照してください。 サーバーによるVaryヘッダーフィールドの使用。</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">サーバー&lt;em&gt;が&lt;/em&gt; TLSアップグレードをサポート&lt;em&gt;していない&lt;/em&gt;場合、またはその時点でTLSにアップグレードでき&lt;em&gt;ない&lt;/em&gt;場合、サーバー&lt;em&gt;は次の&lt;/em&gt;ような標準のHTTP / 1.1応答で応答します。</target>
        </trans-unit>
        <trans-unit id="2c4956e2baa89a364f68e36f2540d46e391032b0" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; recognize the method, but intentionally does not support it, the appropriate response is &lt;a href=&quot;405&quot;&gt;&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">サーバー&lt;em&gt;が&lt;/em&gt;メソッドを認識しているが、意図的にサポートしていない場合、適切な応答は&lt;a href=&quot;405&quot;&gt; &lt;code&gt;405 Method Not Allowed&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">サーバー&lt;em&gt;が&lt;/em&gt; TLSアップグレードをサポートしており、アップグレードを許可する場合は、次のように &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 応答コードで応答します。</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">サーバーがCORSリクエストに&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;メソッドの使用を許可する場合、サーバーは&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;レスポンスヘッダーで応答します。このヘッダーには、 &lt;code&gt;DELETE&lt;/code&gt; とサポートする他のメソッドがリストされています。</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">サーバーが指定されたバージョンのWebSocketプロトコルを使用して通信できない場合、ヘッダーに &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; ヘッダーが含まれるエラー（426アップグレードが必要など）が返され、サポートされているコンマ区切りのリストが含まれます。プロトコルのバージョン。サーバーが要求されたプロトコルバージョンをサポートしていない場合、 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; ヘッダーは応答に含まれません。</target>
        </trans-unit>
        <trans-unit id="8bfc654fb667ab7a47e06dc70b7def2a7620c972" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any character encoding from this request header, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406 Not Acceptable&lt;/code&gt;&lt;/a&gt; error code. But for a better user experience, this is rarely done and the &lt;code&gt;Accept-Charset&lt;/code&gt; header is ignored.</source>
          <target state="translated">サーバーがこの要求ヘッダーから文字エンコードを提供できない場合、理論的には&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406 Not Acceptable&lt;/code&gt; &lt;/a&gt;エラーコードを送り返すことができます。ただし、ユーザーエクスペリエンスを向上させるために、これが行われることはめったになく、 &lt;code&gt;Accept-Charset&lt;/code&gt; ヘッダーは無視されます。</target>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">サーバーが一致する文字セットを提供できない場合、理論上は&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（Not Acceptable）エラーコードを返すことができます。ただし、ユーザーエクスペリエンスを向上させるために、これが行われることはめったにありません。この場合、より一般的な方法は &lt;code&gt;Accept-Charset&lt;/code&gt; ヘッダーを無視することです。</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">サーバーが一致する言語を処理できない場合、理論的には&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（受け入れられない）エラーコードを返すことができます。ただし、ユーザーエクスペリエンスを向上させるために、これはめったに行われません。この場合、より一般的な方法は &lt;code&gt;Accept-Language&lt;/code&gt; ヘッダーを無視することです。</target>
        </trans-unit>
        <trans-unit id="5785d405909bd735e16eff8d00e42ade5e8499d9" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it sends back a &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an Upgrade header that specifies the protocol(s) being switched to. If it does not (or cannot) upgrade the connection, it ignores the &lt;code&gt;Upgrade&lt;/code&gt; header and sends back a regular response (for example, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">サーバーが接続をアップグレードすることを決定した場合、サーバーは、&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101 Switching Protocols&lt;/code&gt; &lt;/a&gt;を指定するUpgradeヘッダーを含む101 SwitchingProtocols応答ステータスを送り返します。接続をアップグレードしない（またはアップグレードできない）場合、 &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーを無視し、通常の応答（たとえば、&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200 OK&lt;/code&gt; &lt;/a&gt;）を返します。</target>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">サーバーに適切な選択肢がある場合は、&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">サーバーが何らかの理由でHTTP / 2に切り替えることができない場合、サーバーは要求を通常どおり処理した後、標準のHTTP / 1応答で応答します。したがって、実際に存在するWebページをフェッチする要求の場合、ヘッダーの残りの部分に続くWebページを含む標準の &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 応答が返されます。サーバーがHTTP / 2に切り替えることができる場合、「 &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 応答が送信されます。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">サーバーが管理下にある場合は、要求サイトの起点を &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーの値に追加して、アクセスを許可する一連のドメインに追加します。</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">サーバーが（ &quot; &lt;code&gt;*&lt;/code&gt; &quot;ワイルドカードではなく）明示的な &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; であるAccess-Control-Allow-Origin値を含む応答を送信する場合、応答には、値 &lt;code&gt;Origin&lt;/code&gt; を持つ&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;応答ヘッダーも含まれ、ブラウザーに示されます。サーバーの応答は、 &lt;code&gt;Origin&lt;/code&gt; リクエストヘッダーの値によって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="40ae9d31a1c63c02ebcd60debd2f8b97d5dd7ac9" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">サーバーが「 &lt;code&gt;*&lt;/code&gt; 」ワイルドカードではなく単一のオリジン（ホワイトリストの一部として要求元のオリジンに基づいて動的に変更される可能性がある）を指定する場合、サーバーは&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;応答ヘッダーに &lt;code&gt;Origin&lt;/code&gt; も含める必要があります&amp;mdash;クライアントに示しますそのサーバーの応答は、&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;要求ヘッダーの値に基づいて異なります。</target>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">サーバーが &quot; &lt;code&gt;*&lt;/code&gt; &quot;ワイルドカードではなく単一の起点を指定する場合、サーバーは&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;応答ヘッダーに &lt;code&gt;Origin&lt;/code&gt; も含める必要があります。これは、サーバー応答が&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;要求ヘッダーの値に基づいて異なることをクライアントに示します。</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">サーバーが範囲要求をサポートしている場合は、&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してそのような要求を発行できます。サーバーが返す必要があるドキュメントの部分を示します。</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">サーバーがより高速なWebサイトまたはアプリケーションの応答を望む場合、サーバーがより多くの接続を強制的に開くことが可能です。たとえば、すべてのリソースを同じドメイン（たとえば &lt;code&gt;www.example.com&lt;/code&gt; ）に &lt;code&gt;www1.example.com&lt;/code&gt; 、複数のドメイン（www1.example.com、 &lt;code&gt;www2.example.com&lt;/code&gt; 、 &lt;code&gt;www3.example.com&lt;/code&gt; )に分割できます。これらの各ドメインは&lt;em&gt;同じ&lt;/em&gt;サーバーに解決され、Webブラウザーはそれぞれに6つの接続を開きます（この例では、接続を18に増やします）。この手法は&lt;em&gt;ドメインシャーディング&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">CORSリクエストを使用してコードがアクセスしているサービスが管理下にある場合は、その &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーにオリジンを含めるように設定されていること、およびそのようなヘッダーが1つだけレスポンスに含まれていることを確認してください。ヘッダー自体は、起点のコンマ区切りのリストを受け入れるため、新しい起点の追加は難しくありません。</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">文字列が NULL の場合、プロキシは使用されません。</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">ターゲットリソースに現在の表現があり、その表現が囲まれた表現の状態に従って正常に変更された場合、配信元サーバーは&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）または&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;No Content&lt;/code&gt; ）応答のいずれかを送信して、リクエスト。</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">ターゲットリソースに現在の表現がなく、 &lt;code&gt;PUT&lt;/code&gt; リクエストがそれを正常に作成した場合、オリジンサーバーは&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;Created&lt;/code&gt; ）応答を送信してユーザーエージェントに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">TLSへのアップグレードが成功すると、サーバーは前のセクションで説明したように &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 応答します。アップグレードが失敗した場合、HTTP / 1.1接続は失敗します。</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">ローカルドメインに属しているがファイアウォールの外側にあり、プロキシサーバー経由でのみ到達可能なホスト（メインWebサーバーなど）がある場合、これらの例外は &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 関数を使用して処理できます。</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">セミコロンで区切られた設定が複数ある場合、Firefox がプロキシとの接続に失敗するまでは、一番左の設定が使用されます。その場合、次の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">他のディレクティブが指定されている場合、 &lt;code&gt;default-src&lt;/code&gt; はそれらに影響を与えません。次のヘッダー</target>
        </trans-unit>
        <trans-unit id="f3a3fb9e88e16c02dae3ebc873862c5294ca1f14" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header:</source>
          <target state="translated">他のディレクティブが指定されている場合、 &lt;code&gt;default-src&lt;/code&gt; はそれらに影響を与えません。次のヘッダー：</target>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">応答に「max-age」または「s-maxage」ディレクティブを含む&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;ヘッダーがある場合、 &lt;code&gt;Expires&lt;/code&gt; ヘッダーは無視されます。</target>
        </trans-unit>
        <trans-unit id="3dc7a417b9985cacb686b59815968d89411858de" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &lt;code&gt;max-age&lt;/code&gt; or &lt;code&gt;s-maxage&lt;/code&gt; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">応答に &lt;code&gt;max-age&lt;/code&gt; または &lt;code&gt;s-maxage&lt;/code&gt; ディレクティブを含む&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;ヘッダーがある場合、 &lt;code&gt;Expires&lt;/code&gt; ヘッダーは無視されます。</target>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">範囲が1つしかない場合は、応答全体の&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;がドキュメントのタイプに設定され、&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;が提供されます。</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">このディレクティブがない場合、ユーザーエージェントは最初に&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探し、次に&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探し、最後に&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探して、ワーカーの実行を制御します。</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探します（これは&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;ディレクティブにフォールバックします）。</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">このヘッダが https://example.com/clear-cookies でのレスポンスで配信された場合、同じドメイン https://example.com 上のすべてのクッキーと、サブドメイン(https://stage.example.com など)上のすべてのクッキーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">このオプションのパラメータを指定すると、ピンの検証に失敗した場合は、指定された URL に報告されます。</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">このオプションのパラメータを指定した場合、このルールはサイトのすべてのサブドメインにも適用されます。</target>
        </trans-unit>
        <trans-unit id="bbeccd91304096ae1ada0d103a494be1d6ecd504" translate="yes" xml:space="preserve">
          <source>If unspecified, the cookie becomes a &lt;strong&gt;session cookie&lt;/strong&gt;. A session finishes when the client shuts down, and session cookies will be removed.</source>
          <target state="translated">指定しない場合、Cookieは&lt;strong&gt;セッションCookieになり&lt;/strong&gt;ます。クライアントがシャットダウンするとセッションが終了し、セッションCookieが削除されます。</target>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;サーバー送信イベント&lt;/a&gt;を使用する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;false&lt;/code&gt; （デフォルト値）であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;を使用する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;&quot;omit&quot;&lt;/code&gt; であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">サードパーティのCookieを開示していない場合、Cookieの使用が発見されると、消費者の信頼が損なわれる可能性があります。（プライバシーポリシーなどの）明確な開示は、Cookieの検出による悪影響を排除する傾向があります。一部の国ではCookieに関する法律もあります。たとえば、ウィキメディア財団の&lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;Cookieステートメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">ロボットユーザーエージェント（クローラーなど）を実行している場合は、 &lt;code&gt;From&lt;/code&gt; ヘッダーを送信する必要があります。これにより、ロボットが過剰な要求、望ましくない要求、または無効な要求を送信しているなど、サーバーで問題が発生した場合に連絡できます。</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">この状態が一時的なものか永続的なものかわからない場合は、代わりに&lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;ステータスコードを使用してください。</target>
        </trans-unit>
        <trans-unit id="b65a6981b33c89d11ed83bceadd2cf2695bfb77d" translate="yes" xml:space="preserve">
          <source>If you don't want a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">一時的なリダイレクトが必要ない場合は、追加のパラメーター（使用するHTTPステータスコードまたは &lt;code&gt;permanent&lt;/code&gt; キーワード）を使用して、別のリダイレクトを設定できます。</target>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">一時的なリダイレクトを設定したくない場合は、追加のパラメーター（使用するHTTPステータスコードまたは &lt;code&gt;permanent&lt;/code&gt; キーワード）を使用して、別のリダイレクトを設定できます。</target>
        </trans-unit>
        <trans-unit id="bbff3207b07c23fc192059f1baabdc3df63a21a1" translate="yes" xml:space="preserve">
          <source>If you have access to the server you can change your implementation to echo back an origin in the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header. You cannot send back a list of origins, because browsers only accept a value that is either a single origin or null</source>
          <target state="translated">サーバーにアクセスできる場合は、実装を変更して、 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーのオリジンをエコーバックできます。ブラウザは単一のオリジンまたはnullのいずれかの値のみを受け入れるため、オリジンのリストを返送することはできません。</target>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">WebSocket接続を最初から作成する必要がある場合は、ハンドシェイクプロセスを自分で処理する必要があります。最初のHTTP / 1.1セッションを作成した後、次のように、標準リクエストに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーと&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを追加して、アップグレードをリクエストする必要があります。</target>
        </trans-unit>
        <trans-unit id="95ee0117fd829b54190ed2ff0616a236aeb84cf5" translate="yes" xml:space="preserve">
          <source>If you receive a response that is not in this list, it is a non-standard response, possibly custom to the server's software.</source>
          <target state="translated">このリストにないレスポンスを受信した場合、それは標準外のレスポンスであり、サーバのソフトウェアにカスタムされている可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">このディレクティブを使ってスクリプトやスタイルに SRI を要求するようにサイトを設定している場合。</target>
        </trans-unit>
        <trans-unit id="4990c5b1cf1cb465433d28094a3e92abdf6422d0" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;DENY&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;SAMEORIGIN&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;DENY&lt;/code&gt; を指定すると、他のサイトからロードしたときにフレーム内のページのロードが失敗するだけでなく、同じサイトからロードしたときに失敗します。一方、 &lt;code&gt;SAMEORIGIN&lt;/code&gt; を指定した場合でも、フレームに含まれるサイトがページを提供するサイトと同じである限り、フレーム内でページを使用できます。</target>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;deny&lt;/code&gt; を指定すると、他のサイトからロードされたときにフレーム内のページをロードしようとすると失敗するだけでなく、同じサイトからロードされたときに失敗します。一方、 &lt;code&gt;sameorigin&lt;/code&gt; を指定した場合、ページをフレームで提供しているサイトがページを提供しているサイトと同じである限り、フレームでページを使用できます。</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">それでもレポートを受け取りたいが、ポリシーを適用したい場合は、&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;ディレクティブで&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">クライアントが他のヘッダーにアクセスできるようにするには、 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; ヘッダーを使用してそれらを一覧表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea06dd402f2e9e7e165d67b2c899ce9957d05866" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header. &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; was not part of the original set safelisted response headers [&lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt;].</source>
          <target state="translated">クライアントが他のヘッダーにアクセスできるようにする場合は、 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; ヘッダーを使用してクライアントを一覧表示する必要があります。&lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;は、元のセットのセーフリストされた応答ヘッダーの一部ではありませんでした[ &lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="29f7d5936f9e8e985a3e0dca82679038018eac65" translate="yes" xml:space="preserve">
          <source>If you want to avoid using user agent detection, you have options!</source>
          <target state="translated">ユーザーエージェント検出を使用しないようにしたい場合は、オプションがあります!</target>
        </trans-unit>
        <trans-unit id="c4dd6049dead6031953d458d3c0344045b4e4cbe" translate="yes" xml:space="preserve">
          <source>If you want to specify a fallback policy in any case the desired policy hasn't got wide enough browser support, use a comma-separated list with the desired policy specified last:</source>
          <target state="translated">ブラウザのサポートが十分に広くない場合にフォールバックポリシーを指定したい場合は、最後に指定したポリシーをカンマで区切ったリストを使用してください。</target>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">ユーザーエージェント検出を使用しないようにしたい場合は、場合によってはオプションがあります!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">アプリケーション、サーバー、またはプロキシが標準化された &lt;code&gt;Forwarded&lt;/code&gt; ヘッダーをサポートしている場合、&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;ヘッダーを置き換えることができます。IPv6アドレスは引用符で囲まれ、 &lt;code&gt;Forwarded&lt;/code&gt; では角括弧で囲まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="90a08b947a2957fe434f390c98a9142e831d9a0f" translate="yes" xml:space="preserve">
          <source>If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever the user authenticates. This technique helps prevent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation attacks&lt;/a&gt;, where a third party can reuse a user's session.</source>
          <target state="translated">サイトがユーザーを認証する場合、ユーザーが認証するたびに、既存のCookieであっても、セッションCookieを再生成して再送信する必要があります。この手法は、サードパーティがユーザーのセッションを再利用できる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;セッション固定攻撃&lt;/a&gt;を防ぐのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">代わりに、サーバーの動作を調整する必要がある場合は、 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; の値を変更して、クライアントの読み込み元へのアクセスを許可する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">If-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">If-None-None-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">If-None-None-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">If-Range (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">If-Range (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">If-Range (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
