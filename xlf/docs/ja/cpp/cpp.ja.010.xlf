<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="5de0dced78d11272f963c83043ebca189594c138" translate="yes" xml:space="preserve">
          <source>A member of a class &lt;code&gt;T&lt;/code&gt; cannot use &lt;code&gt;T&lt;/code&gt; as its name if the member is a static data member, a member function, a member type, a member template , an enumerator of an unscoped enumeration, a member of a member anonymous union. However, a non-static data member may use the name &lt;code&gt;T&lt;/code&gt; as long as there are no user-declared constructors.</source>
          <target state="translated">メンバーが静的データメンバー、メンバー関数、メンバータイプ、メンバーテンプレート、対象範囲外の列挙の列挙子、メンバーの匿名ユニオンのメンバーである場合、クラス &lt;code&gt;T&lt;/code&gt; のメンバーは &lt;code&gt;T&lt;/code&gt; を名前として使用できません。ただし、非静的データメンバーは、ユーザーが宣言したコンストラクターがない限り、名前 &lt;code&gt;T&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="b4ca9ae096395091286ce2f97b84c334ccf6644c" translate="yes" xml:space="preserve">
          <source>A member or a member template of a class template may be explicitly specialized for a given implicit instantiation of the class template, even if the member or member template is defined in the class template definition.</source>
          <target state="translated">クラス・テンプレートのメンバまたはメンバ・テンプレートは、そのメンバまたはメンバ・テンプレートがクラス・テンプレート定義で定義されている場合でも、クラス・テンプレートの与えられた暗黙のインスタンス化に対して明示的に特化されている場合があります。</target>
        </trans-unit>
        <trans-unit id="3cc4194447e3feb7759961528ba2acc170fa12c7" translate="yes" xml:space="preserve">
          <source>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</source>
          <target state="translated">修正可能なlvalueは、組み込みの代入および複合代入演算子の左手オペランドとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="8c00f6a72efb6556fa9292b04ea6629a5f0cab13" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month_day&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt; / 1などの &lt;code&gt;operator/&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e596eb0f0194c2c2e4167ab358138e5b60c14287" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month_day_last&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;operator/&lt;/code&gt; 。たとえば、 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1a8c5116dd01717b8a1f75b9620c596b6f5367a7" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;operator/&lt;/code&gt; （例： &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4752a9f37cdb6658a9a8728cdd2291f0b5ec64d6" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday_last&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;operator/&lt;/code&gt; 。たとえば、 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7327a074e15b5c31502879c12e39a884355916ba" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_indexed&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[index]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weekday_indexed&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;weekday&lt;/code&gt; の &lt;code&gt;operator[]&lt;/code&gt; 、つまり &lt;code&gt;wd[index]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c209a7c3ca3ab0475649b12caaff743d2fbd1dd1" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_last&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weekday_last&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;weekday&lt;/code&gt; の &lt;code&gt;operator[]&lt;/code&gt; 、つまり &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="653ca78a80e72fd3496d4da44b432d7ef45908d8" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;year_month&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;year_month&lt;/code&gt; を作成するより便利な方法は、 &lt;code&gt;operator/&lt;/code&gt; （例： &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f1d73be6c54e98a146e6c453de6dea68f79b357" translate="yes" xml:space="preserve">
          <source>A move assignment operator of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt; with the name &lt;code&gt;operator=&lt;/code&gt; that takes exactly one parameter of type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の移動割り当て演算子は、名前が &lt;code&gt;operator=&lt;/code&gt; &lt;a href=&quot;member_functions&quot;&gt;非&lt;/a&gt;テンプレート非静的メンバー関数で、型 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; 、または &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; パラメーターを1つだけ受け取ります。</target>
        </trans-unit>
        <trans-unit id="7677c3fc7a7f1b5d05a4ba8d65de62c8c77ad6c9" translate="yes" xml:space="preserve">
          <source>A move constructor of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; whose first parameter is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;, and either there are no other parameters, or the rest of the parameters all have default values.</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の移動コンストラクターは、最初のパラメーターが &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; 、または &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; である非テンプレート&lt;a href=&quot;constructor&quot;&gt;コンストラクター&lt;/a&gt;であり、他のパラメーターがないか、残りのパラメーターがすべてデフォルト値を持っています。</target>
        </trans-unit>
        <trans-unit id="16af80cf4cdc5acb425ed5fb5f2a532dceaaf925" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; member functions, &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;, or the following locale-dependent conversion functions:</source>
          <target state="translated">マルチバイト文字列は、ヌル終了バイト文字列（NTBS）とレイアウト互換です。つまり、文字数の計算を除いて、同じ機能を使用して、保存、コピー、および検査できます。正しいロケールが有効な場合、I / O関数はマルチバイト文字列も処理します。マルチバイト文字列は、 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; メンバー関数、 &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 、または次のロケール依存の変換関数を使用して、ワイド文字列との間で変換できます。</target>
        </trans-unit>
        <trans-unit id="d98fb2bdc836fccaa6d115487be59107743d4bcc" translate="yes" xml:space="preserve">
          <source>A name declared non-deprecated may be redeclared deprecated. A name declared deprecated cannot be un-deprecated by redeclaring it without this attribute.</source>
          <target state="translated">非非非推奨と宣言された名前は、非推奨と再宣言することができます。非推奨と宣言された名前は、この属性なしで再宣言しても非推奨にすることはできません。</target>
        </trans-unit>
        <trans-unit id="9645e04714e8aeab4e16fb75044a74252ed38005" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided - see &lt;a href=&quot;namespace#Namespaces&quot;&gt;namespaces&lt;/a&gt; for details.</source>
          <target state="translated">クラスまたはクラステンプレートX内のフレンド宣言で最初に宣言された名前は、Xの最も内側を囲む名前空間のメンバーになりますが、名前空間スコープでの一致する宣言がない限り、ルックアップでは表示されません（Xを考慮する引数依存ルックアップを除く）。提供-詳細は&lt;a href=&quot;namespace#Namespaces&quot;&gt;名前空間&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3933fe1919f27704fb38fb769004562260d8099c" translate="yes" xml:space="preserve">
          <source>A name is classified as a member of the current instantiation if it is.</source>
          <target state="translated">名前は、現在のインスタンス化のメンバーであれば分類されます。</target>
        </trans-unit>
        <trans-unit id="9ddc18654271b83daffe509c6b14c3572df5edd8" translate="yes" xml:space="preserve">
          <source>A name that denotes object, reference, function, type, template, namespace, or value, may have</source>
          <target state="translated">オブジェクト、参照、関数、型、テンプレート、名前空間、または値を表す名前には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="853d1578fabbd2c82d82a0fe09f5702733aba960" translate="yes" xml:space="preserve">
          <source>A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access:</source>
          <target state="translated">継承グラフ内の複数のパスからアクセス可能な名前は、最もアクセス数の多いパスのアクセスを持つ。</target>
        </trans-unit>
        <trans-unit id="6e45514825dadadd15b3e67c603ee32f7155b58a" translate="yes" xml:space="preserve">
          <source>A name that is private according to unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, may be accessible through qualified name lookup:</source>
          <target state="translated">修飾されていない&lt;a href=&quot;lookup&quot;&gt;名前のルックアップ&lt;/a&gt;に従ってプライベートな名前は、修飾された名前のルックアップを通じてアクセスできます。</target>
        </trans-unit>
        <trans-unit id="39b86d73926de6a377e6b550b9b013a7e40df60f" translate="yes" xml:space="preserve">
          <source>A namespace member that was declared within a namespace body may be defined or redeclared outside of it using explicit qualification.</source>
          <target state="translated">名前空間ボディ内で宣言された名前空間メンバは、明示的な資格を使用して、名前空間ボディ外で定義または再宣言することができます。</target>
        </trans-unit>
        <trans-unit id="039345001a9866dd339fc34b017f987d45772976" translate="yes" xml:space="preserve">
          <source>A narrow character string is created as if by a call to &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; in the &quot;C&quot; locale, where &lt;code&gt;spec&lt;/code&gt; is the chosen conversion specifier.</source>
          <target state="translated">狭い文字列は、 &quot;C&quot;ロケールで &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; を呼び出したかのように作成されます &lt;code&gt;spec&lt;/code&gt; は選択された変換指定子です。</target>
        </trans-unit>
        <trans-unit id="105e80128937d46ea748308c3640f225aa1f1163" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect.</source>
          <target state="translated">&lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; の負の値により、 &lt;code&gt;mktime&lt;/code&gt; は夏時間が有効であったかどうかを判別しようとします。</target>
        </trans-unit>
        <trans-unit id="93b6295b9130f095206e2ffbf6e1a198ffb81cdb" translate="yes" xml:space="preserve">
          <source>A nested requirement has the form.</source>
          <target state="translated">入れ子になっている要件には、次のような形式があります。</target>
        </trans-unit>
        <trans-unit id="aab04a416d50d68103518e61edffcc3d876b52d0" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; object, constructed from correctly copied allocators.</source>
          <target state="translated">正しくコピーされたアロケーターから構築された新しい &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="b3fea0735582c1d92ba9ca4265c504066694d506" translate="yes" xml:space="preserve">
          <source>A newly constructed object of type &lt;code&gt;pos_type&lt;/code&gt; which stores the resulting file position, or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">結果のファイル位置を格納するタイプ &lt;code&gt;pos_type&lt;/code&gt; の新しく構築されたオブジェクト、または &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; 場合はpos_type（off_type（-1））。</target>
        </trans-unit>
        <trans-unit id="7812e17881f85045a11332d843939ff143d1510b" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;std::fwide&lt;/code&gt; or to any I/O function establishes the orientation: wide I/O function makes the stream wide-oriented, narrow I/O function makes the stream narrow-oriented. Once set, orientation can only be changed with &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream, wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte characters in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">新しく開いたストリームには方向性がありません。 &lt;code&gt;std::fwide&lt;/code&gt; または任意のI / O関数への最初の呼び出しは方向を確立します。ワイドI / O関数はストリームをワイド指向にし、ナローI / O関数はストリームをナロー指向にします。一度設定すると、向きは &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt; でのみ変更できます。ナローI / O関数をワイド指向のストリームで呼び出すことはできません。ワイドI / O関数をナロー指向のストリームで呼び出すことはできません。ワイドI / O関数は、 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt; wcrtombを呼び出すのと同じように、ワイド文字とマルチバイト文字の間で変換します。プログラムで有効なマルチバイト文字ストリングとは異なり、ファイル内のマルチバイト文字にはヌルが埋め込まれている場合があり、初期シフト状態で開始または終了する必要はありません。</target>
        </trans-unit>
        <trans-unit id="869a3424851c79242efec3e07d77e356612111d6" translate="yes" xml:space="preserve">
          <source>A noexcept-specification of a function is considered to be</source>
          <target state="translated">関数の noexcept-指定は</target>
        </trans-unit>
        <trans-unit id="6aee1e7c886fbccbfdc8526a802aa2e4e5e0f970" translate="yes" xml:space="preserve">
          <source>A non-class non-array prvalue cannot be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</source>
          <target state="translated">非クラスの非配列のprvalueは&lt;a href=&quot;cv&quot;&gt;cv修飾&lt;/a&gt;できません。（注：関数呼び出しまたはキャスト式は、クラスではないcv修飾型のprvalueになる可能性がありますが、cv修飾子はすぐに取り除かれます。）</target>
        </trans-unit>
        <trans-unit id="9c16e8da66b88facf18bcff094f8898640478943" translate="yes" xml:space="preserve">
          <source>A non-const rvalue of type &lt;code&gt;X::node_type&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X::node_type&lt;/code&gt; 非const rvalue</target>
        </trans-unit>
        <trans-unit id="cbfbc01b79d14846f146d50d1446c4035f6cd1b8" translate="yes" xml:space="preserve">
          <source>A non-explicit constructor that accepts an argument of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, which stores that offset and and value-initializes the state object. This constructor must also accept the special value &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt;: the &lt;code&gt;std::fpos&lt;/code&gt; constructed in this manner is returned by some stream operations to indicate errors.</source>
          <target state="translated">型オブジェクト（おそらくconst） &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 引数を受け入れる非明示的なコンストラクター。そのオフセットを保存し、状態オブジェクトを値で初期化します。このコンストラクタは、特別な値 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt; も受け入れる必要があります。この方法で構築された &lt;code&gt;std::fpos&lt;/code&gt; は、エラーを示すために一部のストリーム操作によって返されます。</target>
        </trans-unit>
        <trans-unit id="7c5f2f406d4c6d5a6be68be9a352e598e29e63cd" translate="yes" xml:space="preserve">
          <source>A non-member function definition may appear at namespace scope only (there are no nested functions). A &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; definition may also appear in the body of a &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;. They have the following syntax:</source>
          <target state="translated">非メンバー関数定義は、名前空間スコープでのみ表示される場合があります（ネストされた関数はありません）。&lt;a href=&quot;member_functions&quot;&gt;メンバ関数の&lt;/a&gt;定義もの本体に表示される場合があります&lt;a href=&quot;class&quot;&gt;クラス定義&lt;/a&gt;。これらの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a8537e5e8c50ad3a4da6590cf63b9c692c279951" translate="yes" xml:space="preserve">
          <source>A non-placement allocation or deallocation function for a class is odr-used by the definition of a constructor of that class.</source>
          <target state="translated">クラスの非配置割り当てまたは解放関数は、そのクラスのコンストラクタの定義で使用されます。</target>
        </trans-unit>
        <trans-unit id="54709ac99fdc50ecc6383b09c5e6260c6f17f5a9" translate="yes" xml:space="preserve">
          <source>A non-placement deallocation function for a class is odr-used by the definition of the destructor of that class, or by being selected by the lookup at the point of definition of a virtual destructor</source>
          <target state="translated">クラスの非配置解放関数は、そのクラスのデストラクタの定義で使用されるか、仮想デストラクタの定義時にルックアップで選択されることで使用されます。</target>
        </trans-unit>
        <trans-unit id="57427d16d98090f308df82f3319c4bb23d4b400e" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with a const, volatile, or const volatile qualifier (this qualifier appears after the parameter list in the &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;). Differently cv-qualified functions have different types and so may overload each other.</source>
          <target state="translated">非静的メンバー関数は、const、volatile、またはconst volatile修飾子で宣言できます（この修飾子は、&lt;a href=&quot;function&quot;&gt;関数宣言の&lt;/a&gt;パラメーターリストの後に表示されます）。cvで修飾された関数はタイプが異なるため、相互にオーバーロードする可能性があります。</target>
        </trans-unit>
        <trans-unit id="6269d14f99ea7d83ea3dec1f28326b8c6d5c5ecd" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with no ref-qualifier, with an lvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&lt;/code&gt; after the parameter list) or the rvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; after the parameter list). During &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, non-static cv-qualified member function of class X is treated as follows:</source>
          <target state="translated">非静的メンバー関数は、参照修飾子なし、左辺値参照修飾子（パラメーターリストの後のトークン &lt;code&gt;&amp;amp;&lt;/code&gt; ）または右辺値参照修飾子（パラメーターリストの後のトークン &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ）を使用して宣言できます。&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;中に、クラスXの非静的cv修飾メンバー関数は次のように扱われます。</target>
        </trans-unit>
        <trans-unit id="c58ef98b1f97443f7f30d89e9dea4b508149bdcf" translate="yes" xml:space="preserve">
          <source>A non-static member function is a function that is declared in a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of a class without a &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; or &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; specifier.</source>
          <target state="translated">非静的メンバー関数は、&lt;a href=&quot;static&quot;&gt;静的&lt;/a&gt;または&lt;a href=&quot;friend&quot;&gt;フレンド&lt;/a&gt;指定子なしでクラスの&lt;a href=&quot;class&quot;&gt;メンバー仕様&lt;/a&gt;で宣言された関数です。</target>
        </trans-unit>
        <trans-unit id="327b4ee07e641d05a96006e2735a0db3601ea014" translate="yes" xml:space="preserve">
          <source>A non-static member function may be declared</source>
          <target state="translated">非静的なメンバ関数は</target>
        </trans-unit>
        <trans-unit id="8309388308c23f79d7667a2481e8485faf7c4b76" translate="yes" xml:space="preserve">
          <source>A non-static member function of class X may be called.</source>
          <target state="translated">クラスXの非静的メンバ関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="3dd8b8cff9d7f40f60c773d5633d2a93e250abe4" translate="yes" xml:space="preserve">
          <source>A non-template function is always distinct from a template specialization with the same type. Specializations of different function templates are always distinct from each other even if they have the same type. Two function templates with the same return type and the same parameter list are distinct and can be distinguished with explicit template argument list.</source>
          <target state="translated">テンプレート以外の関数は、同じ型を持つテンプレートの特殊化とは常に区別されます。異なる関数テンプレートの特殊化は、同じ型を持っていても常に互いに区別されます。同じ戻り値型で同じパラメータリストを持つ 2 つの関数テンプレートは区別され、明示的なテンプレート引数リストで区別することができます。</target>
        </trans-unit>
        <trans-unit id="ec8d1e0238ca169189cb132939968a32e225940d" translate="yes" xml:space="preserve">
          <source>A non-template member function and a template member function with the same name may be declared. In case of conflict (when some template specialization matches the non-template function signature exactly), use of that name and type refers to the non-template member unless an explicit template argument list is supplied.</source>
          <target state="translated">このような場合は、「Century」という名前を使用して、「Century」という名前を使用します。競合が発生した場合(あるテンプレートの特殊化が非テンプレート関数のシグネチャと正確に一致した場合)、明示的なテンプレート引数リストが与えられない限り、その名前と型の使用は非テンプレート・メンバを参照します。</target>
        </trans-unit>
        <trans-unit id="1d14804af608dab04a2318dab2393b02651d54c9" translate="yes" xml:space="preserve">
          <source>A notable implementation where &lt;code&gt;std::random_device&lt;/code&gt; is deterministic is MinGW (&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;bug 338&lt;/a&gt;), although replacement implementations exist, such as &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; が確定的である注目すべき実装はMinGW（&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;バグ338&lt;/a&gt;）ですが、&lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;などの代替実装が存在します。</target>
        </trans-unit>
        <trans-unit id="d97541bdffeb4e63b35a3a02617d21fc06220467" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type. If a null pointer constant has integer type, it may be converted to a prvalue of type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">nullポインター定数は、&lt;a href=&quot;../language/implicit_cast&quot;&gt;暗黙的&lt;/a&gt;に任意のポインター型に変換できます。そのような変換の結果、その型のnullポインター値になります。nullポインタ定数が整数型の場合、それは &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 型のprvalueに変換される場合があります。</target>
        </trans-unit>
        <trans-unit id="f1572c78e938eb0e97af4e78573d5ecf38073eb0" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">NULLで終了するバイト文字列（NTBS）は、ゼロ以外のバイトのシーケンスで、その後に値が0のバイト（終了するNULL文字）が続きます。バイト文字列の各バイトは、ある文字セットの1文字をエンコードします。たとえば、文字配列 &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; は、文字列 &lt;code&gt;&quot;cat&quot;&lt;/code&gt; をASCIIエンコーディングで保持するNTBS です。</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">ヌル終端マルチバイト文字列(NTMBS)、または「マルチバイト文字列」とは、ゼロではないバイトの後に、値ゼロのバイト(ヌル文字の終端)が続くシーケンスのことです。</target>
        </trans-unit>
        <trans-unit id="d3f369b83e123d7a5137bbdf57df583877994fe3" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null character.</source>
          <target state="translated">ヌル文字で終わるワイド文字列は、ヌル文字で終わる有効なワイド文字のシーケンスです。</target>
        </trans-unit>
        <trans-unit id="f262d7c58008e0145d059876c3647b11a00b98dc" translate="yes" xml:space="preserve">
          <source>A numeric array containing elements with values obtained by applying corresponding operator to the values in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; の値に対応する演算子を適用することによって取得された値を持つ要素を含む数値配列。</target>
        </trans-unit>
        <trans-unit id="477cf9e2034b21d56b53532edeb5fa0ff54341d3" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of computation of inverse tangent.</source>
          <target state="translated">逆正接の計算結果を含む数値配列.</target>
        </trans-unit>
        <trans-unit id="d991ad4854aaf7bce85259a803aef1efb1b7db52" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of exponentiation.</source>
          <target state="translated">指数の結果を含む数値配列。</target>
        </trans-unit>
        <trans-unit id="2b3cfb0c9df6711008dfe1dd42137fa47903d378" translate="yes" xml:space="preserve">
          <source>A numeric array of &lt;code&gt;bool&lt;/code&gt; containing comparison results of corresponding elements.</source>
          <target state="translated">対応する要素の比較結果を含む &lt;code&gt;bool&lt;/code&gt; 数値配列。</target>
        </trans-unit>
        <trans-unit id="bd2bad531f6152b88c43bb2fbb72d8dcd8b7df39" translate="yes" xml:space="preserve">
          <source>A numeric value &lt;code&gt;n&lt;/code&gt; can be converted to a byte value using &lt;code&gt;std::byte{n}&lt;/code&gt;, due to C++17 relaxed enum class initialization rules.</source>
          <target state="translated">C ++ 17のenumクラスの初期化ルールが緩和されているため、数値 &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;std::byte{n}&lt;/code&gt; を使用してバイト値に変換できます。</target>
        </trans-unit>
        <trans-unit id="c9a28ea00b0028d881fe812f3c217cb4fc954bd0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a &lt;a href=&quot;direct_initialization&quot;&gt;direct initializer&lt;/a&gt;, a &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt;, and other contexts (&lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, etc) in which case the rules are identical to the rules for a function call expression above.</source>
          <target state="translated">パック展開は、&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化子&lt;/a&gt;、&lt;a href=&quot;explicit_cast&quot;&gt;関数スタイルのキャスト&lt;/a&gt;、およびその他のコンテキスト（&lt;a href=&quot;constructor&quot;&gt;メンバー初期化子&lt;/a&gt;、&lt;a href=&quot;new&quot;&gt;新しい式&lt;/a&gt;など）の括弧内に現れる場合があります。この場合、ルールは上記の関数呼び出し式のルールと同じです。</target>
        </trans-unit>
        <trans-unit id="2677c415425384fd8d2e20b4d33138e46186a2e0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</source>
          <target state="translated">関数呼び出し演算子の括弧内にパック展開が現れることがありますが、その場合、楕円の左にある最大の式または括弧付きのinit-listが展開されるパターンとなります。</target>
        </trans-unit>
        <trans-unit id="e1ace690cd25f5f4ab9e5665bb9125a09841bb96" translate="yes" xml:space="preserve">
          <source>A pack expansion may designate the list of base classes in a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. Typically, this also means that the constructor needs to use a pack expansion in the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; to call the constructors of these bases:</source>
          <target state="translated">パック展開では、&lt;a href=&quot;class&quot;&gt;クラス宣言&lt;/a&gt;で基本クラスのリストを指定できます。通常、これは、コンストラクターがこれらのベースのコンストラクターを呼び出すために、&lt;a href=&quot;constructor&quot;&gt;メンバー初期化子リストの&lt;/a&gt;パック展開を使用する必要があることも意味します。</target>
        </trans-unit>
        <trans-unit id="d479119249c5408ac797bae6fd07fa8962b62780" translate="yes" xml:space="preserve">
          <source>A pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or a pair of copies of &lt;code&gt;last&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; で定義されている[pat_first、pat_last）と等しいサブシーケンスが配置されている[first、last）の最初と1つ前の最後の位置への反復子のペア、またはそれ以外の場合は &lt;code&gt;last&lt;/code&gt; のコピーのペア。</target>
        </trans-unit>
        <trans-unit id="92fbc534b58c32d1abb15ac3dd6e84d9ec347ad8" translate="yes" xml:space="preserve">
          <source>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</source>
          <target state="translated">1番目の要素が移動元の範囲内で最後に移動した要素の過去の要素へのイテレータであり、2番目の要素が移動先の範囲内で最後に移動した要素の過去の要素へのイテレータであるペア。</target>
        </trans-unit>
        <trans-unit id="2e2beaabd453f4099778dc9501c74c786e364ee1" translate="yes" xml:space="preserve">
          <source>A parameter declaration in a function declaration that isn't a definition</source>
          <target state="translated">定義ではない関数宣言のパラメータ宣言</target>
        </trans-unit>
        <trans-unit id="0076d34b706ead6a1662fb14d4690ea4e30b8030" translate="yes" xml:space="preserve">
          <source>A parameter pack may appear in the capture clause of a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; expression.</source>
          <target state="translated">パラメータパックは、&lt;a href=&quot;lambda&quot;&gt;ラムダ&lt;/a&gt;式のキャプチャ句に表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="9b45675f6742158d4e1ce1e4e41d58001eb61fb1" translate="yes" xml:space="preserve">
          <source>A path can be</source>
          <target state="translated">パスは、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="8d3919f5b58d9be3b1d118858e1954d6017bb744" translate="yes" xml:space="preserve">
          <source>A path of execution is deemed to include a label if and only if it contains a jump to that label:</source>
          <target state="translated">実行パスにラベルへのジャンプが含まれている場合に限り、実行パスにラベルが含まれているとみなされます。</target>
        </trans-unit>
        <trans-unit id="cc3d18d57e43e7c1a9f4ffb652c5171bd83b4d2f" translate="yes" xml:space="preserve">
          <source>A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.</source>
          <target state="translated">符号の後に桁のない符号で構成されるパターンは、何も一致しなかったパターンとして扱われます。</target>
        </trans-unit>
        <trans-unit id="8746ca0afe0288d6db6ce87470f68b70a4fdf43e" translate="yes" xml:space="preserve">
          <source>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is</source>
          <target state="translated">少なくとも 1 つのパラメータパックの名前が 1 回以上現れる楕円記号が続くパターンは、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="9ca2d1d59088c7c3b22db69dff86c0c2b3191b10" translate="yes" xml:space="preserve">
          <source>A placeholder type specifier may appear in the following contexts:</source>
          <target state="translated">プレースホルダ型指定子は、以下のコンテキストで表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="cbee5c61daad736bbf4e77a8621940e9b34e3473" translate="yes" xml:space="preserve">
          <source>A plain integer is accepted if its meaning is unambiguous from the types of other operands: &lt;code&gt;2005y/4/5&lt;/code&gt; is allowed, but &lt;code&gt;5/April/2005&lt;/code&gt; is not.</source>
          <target state="translated">意味が他のオペランドのタイプから明白である場合、プレーン整数は受け入れられます： &lt;code&gt;2005y/4/5&lt;/code&gt; は許可されますが、 &lt;code&gt;5/April/2005&lt;/code&gt; は許可されません。</target>
        </trans-unit>
        <trans-unit id="fec8de0bf924bd134d73493ee3f200fd0ba8a2d5" translate="yes" xml:space="preserve">
          <source>A pointer declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">ポインター宣言は、&lt;a href=&quot;declarations&quot;&gt;宣言子&lt;/a&gt;が次の形式を持つ任意の単純な宣言です。</target>
        </trans-unit>
        <trans-unit id="e616d2d8a65fe8ffec77841c511375e1b8f9b0c3" translate="yes" xml:space="preserve">
          <source>A pointer or a reference to the current element.</source>
          <target state="translated">現在の要素へのポインタまたは参照。</target>
        </trans-unit>
        <trans-unit id="76ac2aea4079c4a955b7660eae02edd433a9fd7c" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the current match.</source>
          <target state="translated">現在のマッチへのポインタまたは参照。</target>
        </trans-unit>
        <trans-unit id="ab95db86866612e103ecab472411fe9d5d6b7a23" translate="yes" xml:space="preserve">
          <source>A pointer that points to an object</source>
          <target state="translated">オブジェクトを指すポインタ</target>
        </trans-unit>
        <trans-unit id="4c96343afd2f0777da9cdc63088d337b0fc36123" translate="yes" xml:space="preserve">
          <source>A pointer to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; cannot be dereferenced. Pointers to other incomplete types can be dereferenced, but the resulting lvalue can only be used in contexts that allow an lvalue of incomplete type, e.g. when initializing a reference.</source>
          <target state="translated">（おそらく&lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;修飾された） &lt;code&gt;void&lt;/code&gt; へのポインタは逆参照できません。他の不完全な型へのポインターは逆参照できますが、結果の左辺値は、たとえば参照を初期化するときなど、不完全な型の左辺値を許可するコンテキストでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="d01181d4498df4cf0f8003b09ba8e09b3c553181" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; cannot be deleted because it is not a pointer to a complete object type.</source>
          <target state="translated">ポインタ &lt;code&gt;void&lt;/code&gt; 、それは完全なオブジェクト型へのポインタではないため、削除することはできません。</target>
        </trans-unit>
        <trans-unit id="9f73f5e3d4de4e157b8dccf9da808fedaf2b59de" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout class may be converted (with reinterpret_cast) to a pointer to its first non-static data member and vice versa.</source>
          <target state="translated">標準レイアウトクラスへのポインタは、(reinterpret_castを用いて)その最初の非静的データメンバへのポインタに変換され、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="705e66bb80cbfe8e2e8b61352ddc175ed95890e9" translate="yes" xml:space="preserve">
          <source>A pointer to allocated storage of at least &lt;code&gt;bytes&lt;/code&gt; bytes in size, aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">サイズが少なくとも &lt;code&gt;bytes&lt;/code&gt; バイトの割り当てられたストレージへのポインター。そのようなアライメントがサポートされている場合は指定された &lt;code&gt;alignment&lt;/code&gt; 、そうでない場合は &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; アライメントされます。</target>
        </trans-unit>
        <trans-unit id="a9e5f21a34ce522aab5ca357e2281d794f6f56ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator.</source>
          <target state="translated">配列の要素へのポインタは、LegacyContiguousIterator のすべての要件を満たします。</target>
        </trans-unit>
        <trans-unit id="2dabfa7c1aee6ff19a8d014db29f4e03389ef1ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator.</source>
          <target state="translated">配列の要素へのポインタは LegacyRandomAccessIterator のすべての要件を満たします。</target>
        </trans-unit>
        <trans-unit id="bf53771350311775a7859918261dd7a4cabe6a6f" translate="yes" xml:space="preserve">
          <source>A pointer to an object of standard-layout class type can be &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; to pointer to its first non-static non-bitfield data member (if it has non-static data members) or otherwise any of its base class subobjects (if it has any), and vice versa. In other words, padding is not allowed before the first data member of a standard-layout type. Note that &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;strict aliasing&lt;/a&gt; rules still apply to the result of such cast.</source>
          <target state="translated">標準レイアウトのクラスタイプのオブジェクトへのポインタとすることができる&lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_castは&lt;/a&gt;、それがいずれかを持っている場合、その最初の非静的非ビットフィールドデータメンバ（それは非静的データメンバを持つ場合）、またはその他任意のそのベースクラスサブオブジェクトの（へのポインタに）、 およびその逆。つまり、標準レイアウトタイプの最初のデータメンバーの前にパディングを入れることはできません。&lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;厳密なエイリアシング&lt;/a&gt;規則は、そのようなキャストの結果にも適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c433adb64c0845bb1339f1da97f3f437a44c4418" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the &lt;a href=&quot;implicit_cast&quot;&gt;function-to-pointer&lt;/a&gt; implicit conversion, the address-of operator is optional:</source>
          <target state="translated">関数へのポインタは、非メンバー関数または静的メンバー関数のアドレスで初期化できます。ための&lt;a href=&quot;implicit_cast&quot;&gt;機能へのポインタ&lt;/a&gt;の暗黙の変換、アドレスのオペレータは任意です。</target>
        </trans-unit>
        <trans-unit id="fee552ad23a470ee0488c57dc099836dec669c19" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used as the left-hand operand of the &lt;a href=&quot;operator_other&quot;&gt;function call operator&lt;/a&gt;, this invokes the pointed-to function:</source>
          <target state="translated">関数へのポインタは、&lt;a href=&quot;operator_other&quot;&gt;関数呼び出し演算子の&lt;/a&gt;左側のオペランドとして使用できます。これにより、ポイントされた関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="099c10c4969aca0ed60f063fd0510673f35f2754" translate="yes" xml:space="preserve">
          <source>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see &lt;a href=&quot;overloaded_address&quot;&gt;address of an overloaded function&lt;/a&gt; for more detail):</source>
          <target state="translated">関数へのポインタは、1つのオーバーロードのみがポインタのタイプと一致する場合、関数、関数テンプレートの特殊化、および関数テンプレートを含むことができるオーバーロードセットから初期化できます（詳細について&lt;a href=&quot;overloaded_address&quot;&gt;は、オーバーロードされた関数のアドレスを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="8f1bfae7aedabc69e7b7058df026de700a35db9f" translate="yes" xml:space="preserve">
          <source>A pointer to non-array object is treated as a pointer to the first element of an array with size 1.</source>
          <target state="translated">非配列オブジェクトへのポインタは、サイズ1の配列の最初の要素へのポインタとして扱われます。</target>
        </trans-unit>
        <trans-unit id="cb38a2b02a68bb7fc07ad522e4391fd787512883" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member function &lt;code&gt;f&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; or &lt;code&gt;&amp;amp;f&lt;/code&gt; inside C's member function do not form pointers to member functions.</source>
          <target state="translated">クラス &lt;code&gt;C&lt;/code&gt; のメンバーである非静的メンバー関数 &lt;code&gt;f&lt;/code&gt; へのポインターは、式 &lt;code&gt;&amp;amp;C::f&lt;/code&gt; 正確に初期化できます。Cのメンバー関数内の &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; や &lt;code&gt;&amp;amp;f&lt;/code&gt; などの式は、メンバー関数へのポインターを形成しません。</target>
        </trans-unit>
        <trans-unit id="53cf9e67e880a7f25905f2424504dd5b25bc02f1" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member object &lt;code&gt;m&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; or &lt;code&gt;&amp;amp;m&lt;/code&gt; inside C's member function do not form pointers to members.</source>
          <target state="translated">クラス &lt;code&gt;C&lt;/code&gt; のメンバーである非静的メンバーオブジェクト &lt;code&gt;m&lt;/code&gt; へのポインターは、式 &lt;code&gt;&amp;amp;C::m&lt;/code&gt; 正確に初期化できます。Cのメンバー関数内の &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; や &lt;code&gt;&amp;amp;m&lt;/code&gt; などの式は、メンバーへのポインターを形成しません。</target>
        </trans-unit>
        <trans-unit id="4605388fefbc6745ad5fb4ab3501853f9b2e59ca" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the return value of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to any expression of object type, including another pointer type:</source>
          <target state="translated">オブジェクトへのポインターは、別のポインター型を含むオブジェクト型の任意の式に適用される&lt;a href=&quot;operator_member_access&quot;&gt;アドレス演算子&lt;/a&gt;の戻り値で初期化できます。</target>
        </trans-unit>
        <trans-unit id="cb0b45c2fb8692553e4131bcd61d0db96c449b86" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="translated">コンピューターのローカルタイムゾーンを表す、このデータベース内の &lt;code&gt;std::chrono::time_zone&lt;/code&gt; へのポインター。</target>
        </trans-unit>
        <trans-unit id="109ab033a06ddd191eedf4e6243ebdbfa781c50d" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tz_name&lt;/code&gt; で指定されたタイムゾーンを表す、このデータベース内の &lt;code&gt;std::chrono::time_zone&lt;/code&gt; へのポインター。</target>
        </trans-unit>
        <trans-unit id="7186294424331f7f2da77bb5b939c2393a738e08" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated and constructed object.</source>
          <target state="translated">割り当てられ、構築されたオブジェクトへのポインタ。</target>
        </trans-unit>
        <trans-unit id="90fab4aff09dede56fdb6d84059c3624b3b99e4c" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated storage.</source>
          <target state="translated">割り当てられたストレージへのポインタ。</target>
        </trans-unit>
        <trans-unit id="84ca1216b138fa1171353f37562e84b5694e8e55" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the sequence.</source>
          <target state="translated">シーケンスの先頭へのポインタ。</target>
        </trans-unit>
        <trans-unit id="34743a200c5640f215061cfae8958c69a6b3ced4" translate="yes" xml:space="preserve">
          <source>A pointer to the block of memory containing the elements of the container.</source>
          <target state="translated">コンテナの要素を含むメモリブロックへのポインタ。</target>
        </trans-unit>
        <trans-unit id="a8d3f2979c65ac771376f7686ffa1017464bd622" translate="yes" xml:space="preserve">
          <source>A pointer to the first character in the range specified by &lt;code&gt;[p, p + count)&lt;/code&gt; that compares equal to &lt;code&gt;ch&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if not found.</source>
          <target state="translated">指定された範囲内の最初の文字へのポインタ &lt;code&gt;[p, p + count)&lt;/code&gt; と等しい &lt;code&gt;ch&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 見つからない場合。</target>
        </trans-unit>
        <trans-unit id="85748d7d2f8b08c1130cce69c2693bdbf36686d5" translate="yes" xml:space="preserve">
          <source>A pointer to the first element in the classification table (which an array of size &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt;).</source>
          <target state="translated">分類テーブルの最初の要素へのポインター（これはサイズ &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6d6f48b5d05090c0288e98d43d8a863e8b2c04b8" translate="yes" xml:space="preserve">
          <source>A pointer to the owned deleter or &lt;code&gt;nullptr&lt;/code&gt;. The returned pointer is valid at least as long as there remains at least one &lt;code&gt;shared_ptr&lt;/code&gt; instance that owns it.</source>
          <target state="translated">所有されているdeleterまたは &lt;code&gt;nullptr&lt;/code&gt; へのポインター。返されたポインタは、それを所有する少なくとも1つの &lt;code&gt;shared_ptr&lt;/code&gt; インスタンスが残っている限り有効です。</target>
        </trans-unit>
        <trans-unit id="b50fe0059480635f66a814d6c4000336f99ae375" translate="yes" xml:space="preserve">
          <source>A pointer to the stored function if &lt;code&gt;target_type() == typeid(T)&lt;/code&gt;, otherwise a null pointer.</source>
          <target state="translated">&lt;code&gt;target_type() == typeid(T)&lt;/code&gt; 場合はストアード関数へのポインター、それ以外の場合はNULLポインター。</target>
        </trans-unit>
        <trans-unit id="fe7ecdbac553ec91128d6f72f68f35f00624e049" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character array.</source>
          <target state="translated">下位の文字配列へのポインタ。</target>
        </trans-unit>
        <trans-unit id="890ea029c831a738d852daab1692736f467e7a47" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character storage.</source>
          <target state="translated">下位の文字ストレージへのポインタ。</target>
        </trans-unit>
        <trans-unit id="7a202c804155efff22e9a4e471438c6dbf2d98d3" translate="yes" xml:space="preserve">
          <source>A possible implementation of this class is.</source>
          <target state="translated">このクラスの可能性のある実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bc77f50c4833701227ea3422c38b612aa4fdfe9d" translate="yes" xml:space="preserve">
          <source>A possible use for &lt;code&gt;std::condition_variable_any&lt;/code&gt; with custom &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; types is to provide convenient interruptible waits: the custom lock operation would both lock the associated mutex as expected, and also perform the necessary setup to notify this condition variable when the interrupting signal is received.&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">カスタム&lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt;型での &lt;code&gt;std::condition_variable_any&lt;/code&gt; 可能な使用法は、便利な割り込み可能な待機を提供することです。カスタムロック操作は、関連付けられたミューテックスを期待どおりにロックし、割り込み信号が受信されたときにこの条件変数に通知するために必要なセットアップも実行します。&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0c4ca9f04ce9075912ba0b19bfb872f73c52baa7" translate="yes" xml:space="preserve">
          <source>A possibly const value of type &lt;code&gt;X::key_compare&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X::key_compare&lt;/code&gt; おそらくconst値</target>
        </trans-unit>
        <trans-unit id="7916eb952414b9a1c31b5a2dafada3b876f5ad6e" translate="yes" xml:space="preserve">
          <source>A precondition of this function is that &lt;code&gt;[first, n_first)&lt;/code&gt; and &lt;code&gt;[n_first, last)&lt;/code&gt; are valid ranges.</source>
          <target state="translated">この関数の前提条件は、 &lt;code&gt;[first, n_first)&lt;/code&gt; および &lt;code&gt;[n_first, last)&lt;/code&gt; が有効な範囲であることです。</target>
        </trans-unit>
        <trans-unit id="b6b696e16fd55d74c0cbd8840d4be4cbde76e009" translate="yes" xml:space="preserve">
          <source>A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage.</source>
          <target state="translated">プリミティブな静的ベクトルクラスで、整列されたストレージ内のオブジェクトの作成、アクセス、破壊を示します。</target>
        </trans-unit>
        <trans-unit id="9f03356025d9d886dc6751b026e010eaa4c75c65" translate="yes" xml:space="preserve">
          <source>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</source>
          <target state="translated">優先度キューは、対数的な挿入と抽出を犠牲にして、最大の (デフォルトでは)要素の一定時間のルックアップを提供するコンテナアダプタです。</target>
        </trans-unit>
        <trans-unit id="aa89f91f3d3f3e8b505f31100bf86fa2ca7b655c" translate="yes" xml:space="preserve">
          <source>A private member of a class can only be accessed by the members and friends of that class, regardless of whether the members are on the same or different instances:</source>
          <target state="translated">クラスのプライベート・メンバーは、同じインスタンス上にいるか異なるインスタンス上にいるかに関わらず、そのクラスのメンバーと友人のみがアクセスできます。</target>
        </trans-unit>
        <trans-unit id="da9d03016a24905e53207d2ba428a1b8e9a9aaf7" translate="yes" xml:space="preserve">
          <source>A program is not required to call the destructor of an object to end its lifetime if the object is &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivially-destructible&lt;/a&gt; or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</source>
          <target state="translated">オブジェクトが&lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;自明に破壊可能である&lt;/a&gt;場合、またはプログラムがデストラクタの副作用に依存していない場合、プログラムはオブジェクトのデストラクタを呼び出してその寿命を終了する必要はありません。ただし、プログラムが重要なオブジェクトの有効期間を明示的に終了する場合、デストラクタが暗黙的に呼び出される前に、つまりスコープが原因で、同じタイプの新しいオブジェクトがインプレースで（たとえば、プレースメントnewを介して）構築されるようにする必要があります。スレッドローカルオブジェクトのスレッド終了、または静的オブジェクトのプログラム終了による、自動オブジェクトの終了または例外。それ以外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="03089f15ead7ca5ed65d816afebaddda671b3974" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of three</source>
          <target state="translated">プログラムは以下の3つのうちの1つで翻訳することができます。</target>
        </trans-unit>
        <trans-unit id="66c3ecf22ff81745bed14260f746ab81e7c0d0a2" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of two</source>
          <target state="translated">プログラムは以下の2つのうちの1つで翻訳することができます。</target>
        </trans-unit>
        <trans-unit id="5a764d00cd6118dc37146370c6388538e41d1085" translate="yes" xml:space="preserve">
          <source>A program may not specialize &lt;code&gt;basic_common_reference&lt;/code&gt; on the third or fourth parameters, nor may it specialize &lt;code&gt;common_reference&lt;/code&gt; itself. A program that adds specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">プログラムは、専門ではないかもしれ &lt;code&gt;basic_common_reference&lt;/code&gt; を第三または第四のパラメータに、またそれは専門できる &lt;code&gt;common_reference&lt;/code&gt; 自体。これらの規則に違反して特殊化を追加するプログラムには、未定義の動作があります。</target>
        </trans-unit>
        <trans-unit id="17328f55bfa3f5f5c88fbe4c9f98cf4b5f272bc0" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; on the first two parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; are both true and at least one of them depends on a program-defined type.</source>
          <target state="translated">プログラムは、 &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;T、&lt;a href=&quot;decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;T &amp;gt;&amp;gt;および &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;U、&lt;a href=&quot;decay&quot;&gt;std :: decay_tの&lt;/a&gt;場合、最初の2つのパラメーター &lt;code&gt;T&lt;/code&gt; および &lt;code&gt;U&lt;/code&gt; で &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; を特化できます。&amp;lt;U &amp;gt;&amp;gt;は両方とも真であり、少なくとも1つはプログラム定義の型に依存します。</target>
        </trans-unit>
        <trans-unit id="8e61a356e3234eed06fa2f0f5dee899601ee82c6" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;clock_time_conversion&lt;/code&gt; if at least one of the template parameters is a user-defined clock type.</source>
          <target state="translated">テンプレートパラメータの少なくとも1つがユーザー定義のクロックタイプである場合、プログラムは &lt;code&gt;clock_time_conversion&lt;/code&gt; を特化できます。</target>
        </trans-unit>
        <trans-unit id="97b63352c2d736a021395385f10f9bb467d6e3fd" translate="yes" xml:space="preserve">
          <source>A program shall contain a global function named &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program. It shall have one of the following forms:</source>
          <target state="translated">プログラムには、プログラムの指定された開始点である &lt;code&gt;main&lt;/code&gt; という名前のグローバル関数が含まれます。次のいずれかの形式になります。</target>
        </trans-unit>
        <trans-unit id="5437280a6191901c16079ac8f80aff7f070d8c2f" translate="yes" xml:space="preserve">
          <source>A program that adds &lt;code&gt;common_type&lt;/code&gt; specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">これらのルールに違反して &lt;code&gt;common_type&lt;/code&gt; 特殊化を追加するプログラムには、未定義の動作があります。</target>
        </trans-unit>
        <trans-unit id="7fee44e17e3a13581354a330d85e96728e00f4bd" translate="yes" xml:space="preserve">
          <source>A protected member of a class &lt;code&gt;Base&lt;/code&gt; can only be accessed.</source>
          <target state="translated">クラス &lt;code&gt;Base&lt;/code&gt; の保護されたメンバーにのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="87b080a926e158a236034e081054063e31488155" translate="yes" xml:space="preserve">
          <source>A prvalue cannot be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;: the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of the object it identifies is always the type of the expression.</source>
          <target state="translated">prvalueはできません&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;多型&lt;/a&gt;：&lt;a href=&quot;type-id#Dynamic_type&quot;&gt;ダイナミック型&lt;/a&gt;が識別するオブジェクトのは、常に、式の型です。</target>
        </trans-unit>
        <trans-unit id="948c7440ba50ed3eb424033ba764365ffa6afd0f" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt; or an array thereof.</source>
          <target state="translated">prvalueは、&lt;a href=&quot;abstract_class&quot;&gt;抽象クラス型&lt;/a&gt;またはその配列を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="9922e8eeb154c6c0744ee9e4ba026d8fb5b557df" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (except for type void, see below, or when used in &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt;)</source>
          <target state="translated">prvalueに&lt;a href=&quot;type-id#Incomplete_type&quot;&gt;不完全な型を&lt;/a&gt;含めることはできません（型voidを除く、以下を参照、または&lt;a href=&quot;decltype&quot;&gt;decltype指定子で&lt;/a&gt;使用する場合）</target>
        </trans-unit>
        <trans-unit id="89adcc7246c411786e22055f1d4bc6dc797ab523" translate="yes" xml:space="preserve">
          <source>A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. If the value cannot be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;. If the value cannot fit into the destination type, the behavior is undefined. If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero, and the value &lt;code&gt;true&lt;/code&gt; is converted to one.</source>
          <target state="translated">整数またはスコープのない列挙型のprvalueは、任意の浮動小数点型のprvalueに変換できます。値を正しく表現できない場合、最も近い上位の表現可能な値または最も近い下位の表現可能な値のどちらが選択されるかは、実装によって定義されます。ただし、IEEE演算がサポートされている場合、丸めはデフォルト&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;でnearestに&lt;/a&gt;設定されます。値が宛先タイプに収まらない場合の動作は未定義です。ソースタイプが &lt;code&gt;bool&lt;/code&gt; の場合、値 &lt;code&gt;false&lt;/code&gt; はゼロに変換され、値 &lt;code&gt;true&lt;/code&gt; は1に変換されます。</target>
        </trans-unit>
        <trans-unit id="1cc331b941fd7c1d4179b58d5442419123db000e" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to member of cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt; can be converted to a prvalue pointer to member of more cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">CV修飾型のメンバへのポインタ型のprvalue &lt;code&gt;T&lt;/code&gt; クラスにおける &lt;code&gt;X&lt;/code&gt; は、よりCV修飾型のメンバへprvalueポインタに変換することができる &lt;code&gt;T&lt;/code&gt; クラスで &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3def19238902e53ffc0e7c4199b58d0948a3fce" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function.</source>
          <target state="translated">非投球メンバ関数へのポインタ型のprvalueは、潜在的に投球メンバ関数へのポインタ型のprvalueに変換することができます。</target>
        </trans-unit>
        <trans-unit id="e4ca3c60807a21440fb680870f4faa7d3f0b6ab5" translate="yes" xml:space="preserve">
          <source>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type.</source>
          <target state="translated">派生クラス型(オプションで cv-qualified)への prvalue ポインタは,その派生クラス型(同じように cv-qualified)の基底クラスへの prvalue ポインタに変換できます.基底クラスがアクセスできなかったり,曖昧だったりすると,変換は不正な形式になります(コンパイルされません).変換の結果は,pointed-toオブジェクト内の基底クラスサブオブジェクトへのポインタとなります.NULLポインタの値は,変換先の型のNULLポインタの値に変換されます。</target>
        </trans-unit>
        <trans-unit id="b68c522f33b2f282c51184b2111938ab2a45c6a2" translate="yes" xml:space="preserve">
          <source>A pseudo-random number in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;min()&lt;/code&gt; 、 &lt;code&gt;max()&lt;/code&gt; ] の疑似乱数。</target>
        </trans-unit>
        <trans-unit id="518c2995944086d5bc64a89e68ef8ff2eda028d4" translate="yes" xml:space="preserve">
          <source>A public member of a class is accessible everywhere.</source>
          <target state="translated">クラスのパブリックメンバはどこからでもアクセス可能です。</target>
        </trans-unit>
        <trans-unit id="a237039e9334b0659fe3de5e7abb2fcf04116a22" translate="yes" xml:space="preserve">
          <source>A pure virtual function is a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; whose &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; has the following syntax:</source>
          <target state="translated">純粋仮想関数は、&lt;a href=&quot;function&quot;&gt;宣言子の&lt;/a&gt;構文が次の&lt;a href=&quot;virtual&quot;&gt;仮想関数&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d2a131b189a54243081396040bed210dca58fe18" translate="yes" xml:space="preserve">
          <source>A qualified name that appears in</source>
          <target state="translated">に表示される修飾名。</target>
        </trans-unit>
        <trans-unit id="f00c1c26af032f164f98a00ceb65858c99c608e2" translate="yes" xml:space="preserve">
          <source>A qualified name that is used as a &lt;a href=&quot;declarations#Specifiers&quot;&gt;declaration specifier&lt;/a&gt; in the (top-level) decl-specifier-seq of:</source>
          <target state="translated">以下の（トップレベルの）decl-specifier-seqで&lt;a href=&quot;declarations#Specifiers&quot;&gt;宣言指定子&lt;/a&gt;として使用される修飾名：</target>
        </trans-unit>
        <trans-unit id="234e75018942daa7d9ddc6b7ab239081b75bbb61" translate="yes" xml:space="preserve">
          <source>A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.</source>
          <target state="translated">乱数分布は、URBGの出力が定義された統計的確率密度関数に従って分布するように、URBGの出力を後処理します。</target>
        </trans-unit>
        <trans-unit id="63c005a6e5fbfc7dc8af621e2d17685667135352" translate="yes" xml:space="preserve">
          <source>A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">乱数エンジンは、可能な結果の範囲内の各値が(理想的には)等しい確率であるように、符号なし整数値を返す関数オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="218114a7bf5a72fb79f4bcfba1ca863f66fc080d" translate="yes" xml:space="preserve">
          <source>A random number generator may satisfy &lt;code&gt;Invocable&lt;/code&gt; but cannot satisfy &lt;code&gt;RegularInvocable&lt;/code&gt; (&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;comical&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ones&lt;/a&gt; excluded).</source>
          <target state="translated">乱数ジェネレーターは &lt;code&gt;Invocable&lt;/code&gt; を満たすことはできますが、 &lt;code&gt;RegularInvocable&lt;/code&gt; （&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;コミカルな&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ものを&lt;/a&gt;除く）を満たすことはできません。</target>
        </trans-unit>
        <trans-unit id="c8740cda35197e3b7986bfb9d3958a23da53121b" translate="yes" xml:space="preserve">
          <source>A random number uniformly distributed in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;min()&lt;/code&gt; 、 &lt;code&gt;max()&lt;/code&gt; ] に均一に分布された乱数。</target>
        </trans-unit>
        <trans-unit id="c6c8fb5e09b78d7ba8993d92c01b80b6ecf577e7" translate="yes" xml:space="preserve">
          <source>A range adaptor that returns a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of its &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;引数のすべての要素を含む&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;を返す範囲アダプター。</target>
        </trans-unit>
        <trans-unit id="4b161bf3c0670ce52a5c8049eec7a861c20295c5" translate="yes" xml:space="preserve">
          <source>A raw pointer of the type &lt;code&gt;element_type*&lt;/code&gt; that references the same memory location as the argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;p&lt;/code&gt; と同じメモリ位置を参照する &lt;code&gt;element_type*&lt;/code&gt; 型の生のポインタ。</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">このメモリオーダーでのリード・モディファイ・ライト操作は</target>
        </trans-unit>
        <trans-unit id="e3862e525cd9728a75bb86198e817c0be834e74b" translate="yes" xml:space="preserve">
          <source>A reference is required to be initialized to refer to a valid object or function: see &lt;a href=&quot;reference_initialization&quot;&gt;reference initialization&lt;/a&gt;.</source>
          <target state="translated">参照：参照が有効なオブジェクトまたは関数を参照するように初期化する必要がある&lt;a href=&quot;reference_initialization&quot;&gt;参照を初期化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8168313a358c53144732f59b7b55f79bc0d83aa" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;OuterAlloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OuterAlloc&lt;/code&gt; への参照。</target>
        </trans-unit>
        <trans-unit id="804797fdb54fd58e448bcbbb5edeb1965dd46ac6" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;T&lt;/code&gt; can be initialized with an object of type &lt;code&gt;T&lt;/code&gt;, a function of type &lt;code&gt;T&lt;/code&gt;, or an object implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Once initialized, a reference cannot be changed to refer to another object.</source>
          <target state="translated">参照 &lt;code&gt;T&lt;/code&gt; はタイプのオブジェクトで初期化することができる &lt;code&gt;T&lt;/code&gt; 型の関数 &lt;code&gt;T&lt;/code&gt; 、または暗黙的に変換可能なオブジェクト &lt;code&gt;T&lt;/code&gt; 。いったん初期化すると、別のオブジェクトを参照するように参照を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="96effaa229108956b87eaa0ef7506c4b68779cfb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">参照 &lt;code&gt;Ith&lt;/code&gt; の要素。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed9a57692255e9193120495f8b304740d5643ee" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の &lt;code&gt;Ith&lt;/code&gt; 要素への参照。</target>
        </trans-unit>
        <trans-unit id="8587a8972573baad1abe654df486c02df1c78add" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the array, i.e., &lt;code&gt;get()[idx]&lt;/code&gt;</source>
          <target state="translated">配列の &lt;code&gt;idx&lt;/code&gt; 番目の要素への参照、つまり &lt;code&gt;get()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d8ef7aa332a08ad1749e9a36b2ab00fe12b221" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the sequence, i.e., &lt;code&gt;data()[idx]&lt;/code&gt;</source>
          <target state="translated">シーケンスの &lt;code&gt;idx&lt;/code&gt; 番目の要素への参照、つまり &lt;code&gt;data()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1efc2484e454ad9728eae87f942a799f403462" translate="yes" xml:space="preserve">
          <source>A reference to the back element.</source>
          <target state="translated">バックエレメントへの参照。</target>
        </trans-unit>
        <trans-unit id="932b2a1f1d48ceff1483626d393c48deb6ec133d" translate="yes" xml:space="preserve">
          <source>A reference to the contained value.</source>
          <target state="translated">含まれる値への参照。</target>
        </trans-unit>
        <trans-unit id="8de78a95776c196427cb50ef2308786df9feaa77" translate="yes" xml:space="preserve">
          <source>A reference to the element at relative location, that is, &lt;code&gt;base()[-n-1]&lt;/code&gt;.</source>
          <target state="translated">相対位置にある要素への参照、つまり &lt;code&gt;base()[-n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed2f64858c4b136043374a81f773f2bb47825288" translate="yes" xml:space="preserve">
          <source>A reference to the element.</source>
          <target state="translated">要素への参照。</target>
        </trans-unit>
        <trans-unit id="1b47ff083eea09f7ebfc57e29aa6a19dcffb7f4b" translate="yes" xml:space="preserve">
          <source>A reference to the first element.</source>
          <target state="translated">最初の要素への参照。</target>
        </trans-unit>
        <trans-unit id="a0df3de2b33596434eabf885b30512aa4bd9a7f7" translate="yes" xml:space="preserve">
          <source>A reference to the inner allocator, which is itself a &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="translated">それ自体が &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; である内部アロケーターへの参照。</target>
        </trans-unit>
        <trans-unit id="6d12739b00cf675a6ba691cc42cc3b54b7c86c25" translate="yes" xml:space="preserve">
          <source>A reference to the inserted element.</source>
          <target state="translated">挿入された要素への参照。</target>
        </trans-unit>
        <trans-unit id="9b728bf8ae3f8f1afb3d2c134ee7f6175d648f5b" translate="yes" xml:space="preserve">
          <source>A reference to the new contained object.</source>
          <target state="translated">新しく含まれるオブジェクトへの参照。</target>
        </trans-unit>
        <trans-unit id="695dad725bff816bf70ec1a1e915658d83c47722" translate="yes" xml:space="preserve">
          <source>A reference to the new contained value.</source>
          <target state="translated">新しい値への参照。</target>
        </trans-unit>
        <trans-unit id="1f840389ee6e69a00e4361ae4f5b87b0602e4e15" translate="yes" xml:space="preserve">
          <source>A reference to the selected element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; の選択された要素への参照。</target>
        </trans-unit>
        <trans-unit id="215a738f7f92427350a124e8545beaf159690b56" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; から派生した、指定されていないランタイムタイプの静的オブジェクトへの参照。</target>
        </trans-unit>
        <trans-unit id="2dce474f5e611fdd344ca6f78607a960539b8d24" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; から派生した、指定されていないランタイムタイプの静的オブジェクトへの参照。</target>
        </trans-unit>
        <trans-unit id="52beb0ba5b037a0cd1d9ec162abace30f7074fd0" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; から派生した、指定されていないランタイムタイプの静的オブジェクトへの参照。</target>
        </trans-unit>
        <trans-unit id="b9ad010ef7d281736e175c6e04e6e45d80ea96e8" translate="yes" xml:space="preserve">
          <source>A reference to the stream, i.e., &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">ストリームへの参照、つまり &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b519975029bcddb7935a1938c71b85de5a9aa395" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;day&lt;/code&gt; after modification.</source>
          <target state="translated">変更後のこの &lt;code&gt;day&lt;/code&gt; 参照。</target>
        </trans-unit>
        <trans-unit id="fd1b8fb4c67bb93024d4c080ffbd107e8a00646c" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;month&lt;/code&gt; after modification.</source>
          <target state="translated">変更後の &lt;code&gt;month&lt;/code&gt; への参照。</target>
        </trans-unit>
        <trans-unit id="77d42f71b8ba36af0d80129ce3320e59f448b88f" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;weekday&lt;/code&gt; after modification.</source>
          <target state="translated">変更後のこの &lt;code&gt;weekday&lt;/code&gt; 参照。</target>
        </trans-unit>
        <trans-unit id="30e2b7de4724355804f01b061a5218dcca673f33" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;year&lt;/code&gt; after modification.</source>
          <target state="translated">変更後の &lt;code&gt;year&lt;/code&gt; 参照。</target>
        </trans-unit>
        <trans-unit id="c42d3cc108e10a5c0d961e89275a7b7e304370ef" translate="yes" xml:space="preserve">
          <source>A reference to this duration after modification.</source>
          <target state="translated">修正後のこの期間への参照。</target>
        </trans-unit>
        <trans-unit id="477f7a0da5713d89a4c5a2b12679f4b4532b6576" translate="yes" xml:space="preserve">
          <source>A reference variable declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">参照変数宣言は、&lt;a href=&quot;declarations&quot;&gt;宣言子&lt;/a&gt;が次の形式を持つ任意の単純な宣言です。</target>
        </trans-unit>
        <trans-unit id="071394746753f76fda55bbb1f2d7273768e4c96d" translate="yes" xml:space="preserve">
          <source>A release fence F in thread A synchronizes-with atomic &lt;a href=&quot;memory_order&quot;&gt;acquire operation&lt;/a&gt; Y in thread B, if.</source>
          <target state="translated">スレッドAの解放フェンスFは、スレッドBのアトミック&lt;a href=&quot;memory_order&quot;&gt;取得操作&lt;/a&gt; Y と同期します。</target>
        </trans-unit>
        <trans-unit id="6aafba41a946d2b0a19753067d04e0ec8318ec66" translate="yes" xml:space="preserve">
          <source>A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.</source>
          <target state="translated">スレッドAのリリースフェンスFAは、スレッドBの獲得フェンスFBと同期している場合、スレッドBの獲得フェンスFBと同期しています。</target>
        </trans-unit>
        <trans-unit id="00a2a5eb93eeb9be0332c1c8673603beb7ab0223" translate="yes" xml:space="preserve">
          <source>A safely-derived copy of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">安全に派生した &lt;code&gt;p&lt;/code&gt; のコピー。</target>
        </trans-unit>
        <trans-unit id="34d713d3ce9641e15f0083875fa82da7295cd6d0" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool文字列検索アルゴリズム&lt;/a&gt;を実装する &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; Searcher&lt;/a&gt;オーバーロードでの使用に適したサーチャー。</target>
        </trans-unit>
        <trans-unit id="a4aca9528474448c3c240ea5a50dac0f70fee741" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore文字列検索アルゴリズム&lt;/a&gt;を実装する &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; Searcher&lt;/a&gt;オーバーロードでの使用に適したサーチャー。</target>
        </trans-unit>
        <trans-unit id="7c73f721b6023bb7d94aabb383e7afe39aad3eff" translate="yes" xml:space="preserve">
          <source>A separate stored pointer is necessary to ensure that converting a &lt;code&gt;shared_ptr&lt;/code&gt; to &lt;code&gt;weak_ptr&lt;/code&gt; and then back works correctly, even for aliased &lt;code&gt;shared_ptr&lt;/code&gt;s. It is not possible to access the stored pointer in a &lt;code&gt;weak_ptr&lt;/code&gt; without locking it into a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">エイリアスされた &lt;code&gt;shared_ptr&lt;/code&gt; の場合でも、 &lt;code&gt;shared_ptr&lt;/code&gt; を &lt;code&gt;weak_ptr&lt;/code&gt; に変換してから正常に機能するようにするには、別のストアドポインタが必要です。 &lt;code&gt;shared_ptr&lt;/code&gt; にロックせずに、 &lt;code&gt;weak_ptr&lt;/code&gt; に格納されているポインターにアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="25e507c2060a3cafdcda35e0bc4aa2552b49e574" translate="yes" xml:space="preserve">
          <source>A sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range &lt;code&gt;[F1, F2)&lt;/code&gt; otherwise</source>
          <target state="translated">イテレーター範囲 &lt;code&gt;[F1, F2)&lt;/code&gt; で指定された文字シーケンスで構成される照合要素を表す文字シーケンス。それ以外の場合</target>
        </trans-unit>
        <trans-unit id="3a4ef167623ed9faf9a94eff09dae4f596aaaa70" translate="yes" xml:space="preserve">
          <source>A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.</source>
          <target state="translated">単純な宣言とは、1つまたは複数の識別子(通常は変数)を導入、作成、およびオプションで初期化する文のことです。</target>
        </trans-unit>
        <trans-unit id="555b8933650b3bb84b4b7b35f14e9c321630ac4d" translate="yes" xml:space="preserve">
          <source>A simple requirement is an arbitrary expression statement. It asserts that the expression is valid. The expression is an unevaluated operand; only language correctness is checked.</source>
          <target state="translated">単純な要件としては、任意の式の文があります。これは、式が有効であることを主張します。式は評価されないオペランドであり、言語の正しさだけがチェックされます。</target>
        </trans-unit>
        <trans-unit id="3a6977f0304e9c21ebecd390f1670f86c4119c3c" translate="yes" xml:space="preserve">
          <source>A simple-template-id that names a class template specialization names a class.</source>
          <target state="translated">クラスのテンプレート特化がクラスの名前を付けるsimple-template-id。</target>
        </trans-unit>
        <trans-unit id="8fa198408b5d0cb7b3044995aa1b61b2fdf97bfa" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of alternative names of time zones (links)</source>
          <target state="translated">タイムゾーン（リンク）の代替名の説明を含む、ソートされた &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="457d45e0af075f01765307d373a69c2a8d94815f" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of time zones</source>
          <target state="translated">タイムゾーンの説明を含む、ソートされた &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="967914ef26dbd68948b66b13d60e30b85ed85a3c" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; containing description of leap seconds</source>
          <target state="translated">うるう秒の説明を含む、ソートされた &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eee524fe2ac982c4dd9f9a32a0c582f50eef3782" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; の最初の &lt;code&gt;Count&lt;/code&gt; 要素のビューであるスパン &lt;code&gt;r&lt;/code&gt; 。たとえば、 &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="65c54f136c4760893800380e5b0c393d21d23647" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; の最後の &lt;code&gt;Count&lt;/code&gt; 要素のビューであるスパン &lt;code&gt;r&lt;/code&gt; 。たとえば、 &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5074592fbba4772cb532096c90f531b3f380c17b" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化</target>
        </trans-unit>
        <trans-unit id="9ee495551d56b04a23dc52fb815bb43b2e18e8c4" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;conjunction&lt;/code&gt; does not necessarily inherit from either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to bool, is false, or from the very last &lt;code&gt;B&lt;/code&gt; when all of them convert to true. For example, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conjunction&lt;/code&gt; の特殊化は、必ずしも &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; から継承する必要はありません。 &lt;code&gt;::value&lt;/code&gt; が明示的にboolに変換された最初の &lt;code&gt;B&lt;/code&gt; から継承するか、最後の &lt;code&gt;B&lt;/code&gt; から継承します。 trueに変換します。たとえば、 &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int、2&amp;gt;、&lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int、4 &amp;gt;&amp;gt; :: value is &lt;code&gt;4&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f9e9b49b2bead30b9efc6f23cbdc32fd0fd8ce60" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;disjunction&lt;/code&gt; does not necessarily inherit from of either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to &lt;code&gt;bool&lt;/code&gt;, is true, or from the very last B when all of them convert to false. For example, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disjunction&lt;/code&gt; の特殊化は、必ずしも &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; のいずれかから継承する必要はありません。それは、 &lt;code&gt;::value&lt;/code&gt; が明示的に &lt;code&gt;bool&lt;/code&gt; に変換された最初の &lt;code&gt;B&lt;/code&gt; から継承するか、またはすべての場合、最後のBから継承します。それらはfalseに変換されます。たとえば、 &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int、2&amp;gt;、&lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int、4 &amp;gt;&amp;gt; :: value is &lt;code&gt;2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9f9e5d495b1b862008c29e72aac873442799f4b0" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::greater&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">組み込みの &lt;code&gt;operator&amp;gt;&lt;/code&gt; が行わない場合でも、任意のポインター型に対して &lt;code&gt;std::greater&lt;/code&gt; を特殊化すると、厳密な合計順序が得られます。厳密な合計順序は、そのポインタ型の &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;std::greater&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; で一貫しており、対応する組み込み演算子によって課される部分的な順序とも一貫しています（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4d8a4b2d55428dedbd5dbf627f7b5d8550161022" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">組み込み &lt;code&gt;operator&amp;gt;=&lt;/code&gt; がそうでなくても、任意のポインター型の &lt;code&gt;std::greater_equal&lt;/code&gt; を特殊化すると、厳密な合計順序が得られます。厳密な合計順序は、そのポインタ型の &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;std::greater_equal&lt;/code&gt; で一貫しており、対応する組み込み演算子によって課される部分的な順序とも一貫しています（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="475b3cfac8883fd0a588f09dae13ae24eea6b2df" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;std::less&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::less&lt;/code&gt; 特殊化は、組み込みの &lt;code&gt;operator&amp;lt;&lt;/code&gt; がそうでなくても、厳密な合計順序を生成します。厳密な合計順序は、そのポインタ型の &lt;code&gt;std::less&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; で一貫しており、対応する組み込み演算子によって課される部分的な順序とも一貫しています（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5040d1c9db6502c777c18889e5250a72b8267c2f" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">組み込みの &lt;code&gt;operator&amp;lt;=&lt;/code&gt; がそうでない場合でも、任意のポインター型の &lt;code&gt;std::less_equal&lt;/code&gt; 特殊化は、厳密な合計順序を生成します。厳密な合計順序は、そのポインタ型の &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;std::less_equal&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; で一貫しており、対応する組み込み演算子によって課される部分的な順序とも一貫しています（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="92e25a120740f5ad5adbba2aabed8d933eb3d5e4" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">スピンロックmutexは、 &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt; と同様に、アトミック交換操作を使用してユーザー空間に実装できます。</target>
        </trans-unit>
        <trans-unit id="9515057fe6328dc05919c4cf02d9006061787a0c" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic_flag.</source>
          <target state="translated">スピンロックミューテックスは、atomic_flagを使用してユーザ空間に実装することができます。</target>
        </trans-unit>
        <trans-unit id="901d05a2e6ec5ffbcf6b01e787bf262ebced94a5" translate="yes" xml:space="preserve">
          <source>A standard conversion sequence consists of the following, in this order:</source>
          <target state="translated">標準的な変換シーケンスは、この順に以下のように構成されています。</target>
        </trans-unit>
        <trans-unit id="d4c338c0450a24104d97679430b5532160d82771" translate="yes" xml:space="preserve">
          <source>A static assert declaration may appear at namespace and block scope (as a &lt;a href=&quot;declarations&quot;&gt;block declaration&lt;/a&gt;) and inside a class body (as a &lt;a href=&quot;class&quot;&gt;member declaration&lt;/a&gt;).</source>
          <target state="translated">静的アサート宣言は、名前空間とブロックスコープ（&lt;a href=&quot;declarations&quot;&gt;ブロック宣言&lt;/a&gt;として）およびクラス本体の内部（&lt;a href=&quot;class&quot;&gt;メンバー宣言&lt;/a&gt;として）に表示されます。</target>
        </trans-unit>
        <trans-unit id="f33f270773f2dc3de0fd0352e32cf33418d9b8c0" translate="yes" xml:space="preserve">
          <source>A static data member may be declared &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:</source>
          <target state="translated">静的データメンバーは&lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt;で宣言できます。インライン静的データメンバーはクラス定義で定義でき、初期化子を指定できます。クラス外の定義は必要ありません。</target>
        </trans-unit>
        <trans-unit id="5da97780b140e6a47935295d4e1ee4870bfe1e89" translate="yes" xml:space="preserve">
          <source>A static member variable (but not a namespace-scope variable) declared &lt;code&gt;constexpr&lt;/code&gt; is implicitly an inline variable.</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; として宣言された静的メンバー変数（名前空間スコープ変数ではない）は、暗黙的にインライン変数です。</target>
        </trans-unit>
        <trans-unit id="4b6d0fdd7d7607c01a896d9094690fc14c51a0b3" translate="yes" xml:space="preserve">
          <source>A steady clock is used to measure the duration. This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">持続時間の測定には、安定したクロックが使用されます。この関数は、スケジューリングまたはリソース競合の遅延が原因で、 &lt;code&gt;timeout_duration&lt;/code&gt; よりも長くブロックする場合があります。</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">このメモリオーダーでのストア操作は</target>
        </trans-unit>
        <trans-unit id="c6bc48899775e9a6c5f0a1a15785f5ee33b9cf7b" translate="yes" xml:space="preserve">
          <source>A string describing the given error condition.</source>
          <target state="translated">与えられたエラー条件を記述する文字列。</target>
        </trans-unit>
        <trans-unit id="46b19b69118bd315cdfc683d15a6fa75436b64bc" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a C string: if a string literal has embedded null characters, it represents an array which contains more than one string.</source>
          <target state="translated">文字列リテラルは必ずしもC言語の文字列とは限りません:文字列リテラルにヌル文字が埋め込まれている場合、それは複数の文字列を含む配列を表します。</target>
        </trans-unit>
        <trans-unit id="1550cc2a5436eb99f071dfa4dcf0dd47ccf4c825" translate="yes" xml:space="preserve">
          <source>A string view representing the entire contents of the string.</source>
          <target state="translated">文字列の内容全体を表す文字列ビュー。</target>
        </trans-unit>
        <trans-unit id="32570ac03b4c2c47cffb2bbc021cc0ca86dcc629" translate="yes" xml:space="preserve">
          <source>A structured binding declaration first introduces a uniquely-named variable (here denoted by &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;) to hold the value of the initializer, as follows:</source>
          <target state="translated">構造化バインディング宣言では、最初に、次のように初期化子の値を保持するための一意の名前が付けられた変数（ここでは &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; と表記）を導入します。</target>
        </trans-unit>
        <trans-unit id="144f71d00798ee052aabd4ddb5c24678262a6ae1" translate="yes" xml:space="preserve">
          <source>A structured binding declaration introduces all identifiers in the identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called</source>
          <target state="translated">構造化バインディング宣言は、識別子リストに含まれるすべての識別子を周囲のスコープに名前として導入し、それらを式で示されるオブジェクトのサブオブジェクトまたは要素にバインディングします。このようにして導入されたバインディングは</target>
        </trans-unit>
        <trans-unit id="835974f7bef28e4dff1c1ff405518b0bb98087eb" translate="yes" xml:space="preserve">
          <source>A structured binding declaration then performs the binding in one of three possible ways, depending on &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;:</source>
          <target state="translated">次に、構造化バインディング宣言は、 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; に応じて、3つの可能な方法のいずれかでバインディングを実行します。</target>
        </trans-unit>
        <trans-unit id="5ebdd31b80b554a53c87eaf8af1247d0cf95b1cf" translate="yes" xml:space="preserve">
          <source>A subobject is</source>
          <target state="translated">サブオブジェクトは</target>
        </trans-unit>
        <trans-unit id="7a0f0cf82fd7a9695235dbab61201c1151c693d9" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;operator()&lt;/code&gt; synchronizes with a call to any member function of a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; that share their shared state with &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator()&lt;/code&gt; への正常な呼び出しは、 &lt;code&gt;*this&lt;/code&gt; と共有状態を共有する &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; メンバー関数の呼び出しと同期します。</target>
        </trans-unit>
        <trans-unit id="5e5e13088bac64880bbd1d92f74dea1c546eae32" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetc&lt;/code&gt; の呼び出しが成功すると、ファイルの終わりステータスフラグ &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt; がクリアされます。</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">バイナリストリームで &lt;code&gt;ungetc&lt;/code&gt; への呼び出しが成功すると、ストリーム位置インジケーターが1つ減少します（ストリーム位置インジケーターがゼロの場合の動作は不確定です）。</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">テキストストリームで &lt;code&gt;ungetc&lt;/code&gt; への呼び出しが成功すると、ストリーム位置インジケーターが不特定の方法で変更されますが、すべてのプッシュバックされた文字が読み取り操作で取得された後、ストリーム位置インジケーターが &lt;code&gt;ungetc&lt;/code&gt; の前の値と等しいことが保証されます。</target>
        </trans-unit>
        <trans-unit id="a28d7859e6f4fcb6db1df05cff06566fff5a4e72" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;feof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetwc&lt;/code&gt; の呼び出しが成功すると、ファイルの終わりステータスフラグ &lt;code&gt;feof&lt;/code&gt; がクリアされます。</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">ストリーム（テキストまたはバイナリ）で &lt;code&gt;ungetwc&lt;/code&gt; を正常に呼び出すと、ストリーム位置インジケーターが不特定の方法で変更されますが、すべてのプッシュバックされたワイド文字が読み取り操作で取得された後、ストリーム位置インジケーターが &lt;code&gt;ungetwc&lt;/code&gt; の前の値と等しいことが保証されます。。</target>
        </trans-unit>
        <trans-unit id="4438ef6f7a0682bb256998449673a26881f7a072" translate="yes" xml:space="preserve">
          <source>A template argument for a template template parameter must be an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; which names a class template or a template alias.</source>
          <target state="translated">テンプレートテンプレートパラメータのテンプレート引数は、クラステンプレートまたはテンプレートエイリアスを指定する&lt;a href=&quot;name#In_expressions&quot;&gt;id式で&lt;/a&gt;ある必要があります。</target>
        </trans-unit>
        <trans-unit id="0cbe97ed8a5079b18bed67f0b987c6e75304c3a6" translate="yes" xml:space="preserve">
          <source>A template argument for a type template parameter must be a &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;, which may name an incomplete type:</source>
          <target state="translated">タイプテンプレートパラメータのテンプレート引数は&lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;である必要があります。これは不完全なタイプを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="b77575f13c55d5afb76807a44c03b42f3be5cca3" translate="yes" xml:space="preserve">
          <source>A template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header may be instantiated with an incomplete type unless otherwise specified, notwithstanding the general prohibition against instantiating standard library templates with incomplete types.</source>
          <target state="translated">&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; ヘッダーで定義されたテンプレートは、特に指定されていない限り、不完全な型で標準ライブラリテンプレートをインスタンス化することに対する一般的な禁止にもかかわらず、不完全な型でインスタンス化される場合があります。</target>
        </trans-unit>
        <trans-unit id="3db9cfde6b359f0a7eac7446ebfcb7cabe3498b5" translate="yes" xml:space="preserve">
          <source>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last &lt;code&gt;::&lt;/code&gt;) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</source>
          <target state="translated">テンプレートフレンド宣言では、クラステンプレートAのメンバーに名前を付けることができます。これは、メンバー関数またはメンバータイプのいずれかになります（タイプは&lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifierを&lt;/a&gt;使用する必要があります）。そのような宣言は、その入れ子の名前指定子の最後のコンポーネント（最後の &lt;code&gt;::&lt;/code&gt; の左側にある名前）が名前を付けるsimple-template-id（テンプレート名の後に引数リストが続く）である場合にのみ整形式ですクラステンプレート。このようなテンプレートフレンド宣言のテンプレートパラメータは、simple-template-idから推定できる必要があります。</target>
        </trans-unit>
        <trans-unit id="b8cbfd05ed876a96f58d914b20aab64f29b86a74" translate="yes" xml:space="preserve">
          <source>A template is a C++ entity that defines one of the following:</source>
          <target state="translated">テンプレートは、以下のいずれかを定義する C++エンティティです。</target>
        </trans-unit>
        <trans-unit id="59d81713cfdc4799ddf46175f8d61401bcd90683" translate="yes" xml:space="preserve">
          <source>A template parameter of the form &lt;code&gt;class Foo&lt;/code&gt; is not an unnamed non-type template parameter of type &lt;code&gt;Foo&lt;/code&gt;, even if otherwise &lt;code&gt;class Foo&lt;/code&gt; is an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; and &lt;code&gt;class Foo x;&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be of type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">フォームのテンプレートパラメータ &lt;code&gt;class Foo&lt;/code&gt; 型の名前非型テンプレートパラメータはない &lt;code&gt;Foo&lt;/code&gt; そうでない場合でも、 &lt;code&gt;class Foo&lt;/code&gt; ある&lt;a href=&quot;elaborated_type_specifier&quot;&gt;精巧な型指定&lt;/a&gt;と &lt;code&gt;class Foo x;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;Foo&lt;/code&gt; 型であることを宣言します。</target>
        </trans-unit>
        <trans-unit id="d85241f2bc54602e57c2582a6ecab6b9f660f5f6" translate="yes" xml:space="preserve">
          <source>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</source>
          <target state="translated">テンプレート・パラメータ・パックは、0個以上のテンプレート引数(非タイプ、タイプ、またはテンプレート)を受け付けるテンプレート・パラメータです。関数パラメータパックは、0個以上の関数引数を受け付ける関数パラメータです。</target>
        </trans-unit>
        <trans-unit id="eb2fa05aae2cb5737143f68053260c6a62f41e74" translate="yes" xml:space="preserve">
          <source>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:</source>
          <target state="translated">明示的に指定されたテンプレートパラメータパックは、追加の引数がある場合には、テンプレート引数推論によって拡張することができます。</target>
        </trans-unit>
        <trans-unit id="f41dfabc2328a29181220b5113304c48aad61703" translate="yes" xml:space="preserve">
          <source>A template specialization that was declared but not defined can be used just like any other &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (e.g. pointers and references to it may be used).</source>
          <target state="translated">宣言されたが定義されていないテンプレート特殊化は、他の&lt;a href=&quot;incomplete_type&quot;&gt;不完全な型と&lt;/a&gt;同じように使用できます（たとえば、ポインターとその参照を使用できます）。</target>
        </trans-unit>
        <trans-unit id="344b2caa5e5fe345b5eddc1d5d915de3d6be2db2" translate="yes" xml:space="preserve">
          <source>A template with at least one parameter pack is called a</source>
          <target state="translated">少なくとも1つのパラメータパックを持つテンプレートを</target>
        </trans-unit>
        <trans-unit id="673816c6497404faf247ef589f1b122b3a14f807" translate="yes" xml:space="preserve">
          <source>A template-id is only valid if.</source>
          <target state="translated">テンプレートIDは以下の場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="10655830c19a77e3e63f7c59d226efb3c807b9e8" translate="yes" xml:space="preserve">
          <source>A template-id that names an alias template specialization names a type.</source>
          <target state="translated">エイリアステンプレートの特殊化が型を名付けるテンプレートID。</target>
        </trans-unit>
        <trans-unit id="df2b079308f3eca647407b9397b352dc670c7a81" translate="yes" xml:space="preserve">
          <source>A template-id that names an function template specialization names a function.</source>
          <target state="translated">関数のテンプレート特化の名前を付けるテンプレートID。</target>
        </trans-unit>
        <trans-unit id="3c85feec0c63ebeca50f678f352ffcc3928d1b88" translate="yes" xml:space="preserve">
          <source>A templated entity (or, in some sources, &quot;temploid&quot;) is any entity that is defined (or, for a lambda-expression, created) within a template definition. All of the following are templated entities:</source>
          <target state="translated">このような場合は、「Element Import」(要素)は、「Element Import」(要素)と呼ばれ、「Element Import」(要素)は、「Element Import」(要素)と呼ばれ、「Element Import」(要素)は、「Element Import」(要素)と呼ばれます。以下のすべてがテンプレート化されたエンティティです。</target>
        </trans-unit>
        <trans-unit id="97a674e12e96df448607046bf1ea74819514e29d" translate="yes" xml:space="preserve">
          <source>A temporary object of type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の一時オブジェクトは、&lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;または&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="33f18c53306de042e4c98fc4f2ec71d92fc7452f" translate="yes" xml:space="preserve">
          <source>A test for self-reset, i.e. whether &lt;code&gt;ptr&lt;/code&gt; points to an object already managed by &lt;code&gt;*this&lt;/code&gt;, is not performed, except where provided as a compiler extension or as a debugging assert. Note that code such as &lt;code&gt;p.reset(p.release())&lt;/code&gt; does not involve self-reset, only code like &lt;code&gt;p.reset(p.get())&lt;/code&gt; does.</source>
          <target state="translated">コンパイラー拡張またはデバッグアサートとして提供されている場合を除いて、セルフリセットのテスト、つまり &lt;code&gt;ptr&lt;/code&gt; が &lt;code&gt;*this&lt;/code&gt; によってすでに管理されているオブジェクトを指しているかどうかのテストは実行されません。 &lt;code&gt;p.reset(p.release())&lt;/code&gt; などのコードは自己リセットを含まず、 &lt;code&gt;p.reset(p.get())&lt;/code&gt; のようなコードのみを含むことに注意してください。</target>
        </trans-unit>
        <trans-unit id="69a493f42c2d5d0a3d7b1e06a1285a10bdbe7061" translate="yes" xml:space="preserve">
          <source>A thread is said to</source>
          <target state="translated">スレッドはというと</target>
        </trans-unit>
        <trans-unit id="ba9c13c0f9167e54bcbaf88e115f4167e83660c0" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;lock&lt;/code&gt; on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to &lt;code&gt;unlock&lt;/code&gt;.</source>
          <target state="translated">スレッドは、再帰的mutexの &lt;code&gt;lock&lt;/code&gt; を繰り返し呼び出す場合があります。所有権は、スレッドが同じ数の &lt;code&gt;unlock&lt;/code&gt; を解除する呼び出しを行った後にのみ解放されます。</target>
        </trans-unit>
        <trans-unit id="7f432eae50bd789012a099dcf2a13f431564693f" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock&lt;/code&gt; increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スレッドは、再帰的mutexで &lt;code&gt;try_lock&lt;/code&gt; を繰り返し呼び出す場合があります。 &lt;code&gt;try_lock&lt;/code&gt; の呼び出しが成功すると、所有者数が増加します。mutexは、スレッドが &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; を呼び出すために一致する数の呼び出しを行った後にのみ解放されます。</target>
        </trans-unit>
        <trans-unit id="37671f46b069e4bce5a6c704520d4965568d9f60" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_for&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_for&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スレッドは、再帰的mutexで &lt;code&gt;try_lock_for&lt;/code&gt; を繰り返し呼び出す場合があります。 &lt;code&gt;try_lock_for&lt;/code&gt; の呼び出しが成功すると、所有権のカウントが増加します。mutexは、スレッドが &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; を呼び出すために一致する数の呼び出しを行った後にのみ解放されます。</target>
        </trans-unit>
        <trans-unit id="892016f3791df53a75393a4054de36f6670ede74" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_until&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_until&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スレッドは、再帰的mutexで &lt;code&gt;try_lock_until&lt;/code&gt; を繰り返し呼び出す場合があります。 &lt;code&gt;try_lock_until&lt;/code&gt; の呼び出しが成功すると、所有権のカウントが増加します。mutexは、スレッドが &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; の呼び出しと一致する数の呼び出しを行った後にのみ解放されます。</target>
        </trans-unit>
        <trans-unit id="6b4560e93294ed5a9703378d1e170be75de3f418" translate="yes" xml:space="preserve">
          <source>A thread object does not have an associated thread (and is safe to destroy) after.</source>
          <target state="translated">スレッドオブジェクトは、その後、関連付けられたスレッドを持っていません(破棄しても安全です)。</target>
        </trans-unit>
        <trans-unit id="bac126fd4b2160e8de884ee506093cb6e1453d7a" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, or other means.</source>
          <target state="translated">実行のスレッドとは、 &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; などの手段によるトップレベルの関数の呼び出しで始まるプログラム内の制御フローです。</target>
        </trans-unit>
        <trans-unit id="13fb085a74dd9fd867bcbeeeed6c63aa5ff60cd7" translate="yes" xml:space="preserve">
          <source>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</source>
          <target state="translated">コードの実行が終了したが、まだ結合されていないスレッドは、まだ実行中のアクティブなスレッドとみなされ、したがって結合可能です。</target>
        </trans-unit>
        <trans-unit id="d83b1a24d6c356fdf4f8f81bf30022c94f556e0c" translate="yes" xml:space="preserve">
          <source>A time point is a duration of time that has passed since the epoch of a specific clock.</source>
          <target state="translated">タイムポイントとは、特定の時計のエポックから経過した時間のことです。</target>
        </trans-unit>
        <trans-unit id="842ecf6d69cdbeaddd28ab48c6e44b247497210b" translate="yes" xml:space="preserve">
          <source>A time point representing the current time.</source>
          <target state="translated">現在の時刻を表すタイムポイント。</target>
        </trans-unit>
        <trans-unit id="482e88b6e7ea3206c3e62b40431b9801a98e659f" translate="yes" xml:space="preserve">
          <source>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from the function parameter.</source>
          <target state="translated">後続のテンプレート引数は、関数テンプレートの特殊化、または関数パラメーターから&lt;a href=&quot;template_argument_deduction&quot;&gt;推定&lt;/a&gt;できる場合はメンバー関数テンプレートの特殊化の明示的なインスタンス化で指定しないでおくことができます。</target>
        </trans-unit>
        <trans-unit id="1744e51348fac7204c6560fe5f680fd02436a4e6" translate="yes" xml:space="preserve">
          <source>A translation unit that includes a standard library header may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names declared in any standard library header.</source>
          <target state="translated">標準ライブラリヘッダーを含む変換単位は、標準ライブラリヘッダーで宣言された &lt;code&gt;#define&lt;/code&gt; または &lt;code&gt;#undef&lt;/code&gt; 名を使用できません。</target>
        </trans-unit>
        <trans-unit id="e8a16a40cb320ca82f7aab312a29ceda1b14f739" translate="yes" xml:space="preserve">
          <source>A translation unit that uses any part of the standard library may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names lexically identical to:</source>
          <target state="translated">標準ライブラリの任意の部分を使用する翻訳単位は、次と同じように &lt;code&gt;#define&lt;/code&gt; または &lt;code&gt;#undef&lt;/code&gt; の名前を使用できません。</target>
        </trans-unit>
        <trans-unit id="d317f7a0ab3e788267489e0fc1532ddec6c12c38" translate="yes" xml:space="preserve">
          <source>A trivial copy assignment operator makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially copy-assignable.</source>
          <target state="translated">自明なコピー代入演算子は、 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; よるかのようにオブジェクト表現のコピーを作成します。C言語と互換性のあるすべてのデータ型（POD型）は、簡単にコピー割り当て可能です。</target>
        </trans-unit>
        <trans-unit id="dd6abf8a66d91871c0f211e838354255f118cc43" translate="yes" xml:space="preserve">
          <source>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</source>
          <target state="translated">非組合わないクラスのための些細なコピー・コンストラクタは、引数のすべてのスカラ部分オブジェクト(再帰的にサブオブジェクトのサブオブジェクトなどを含む)を効果的にコピーし、他のアクションを実行しません。しかし、パディング・バイトはコピーされる必要はなく、コピーされたサブオブジェクトのオブジェクト表現も、値が同じである限り同じである必要はありません。</target>
        </trans-unit>
        <trans-unit id="53f265b51a6ad6bc29b0d13aa314fdd06dcfce6a" translate="yes" xml:space="preserve">
          <source>A trivial default constructor is a constructor that performs no action. All data types compatible with the C language (POD types) are trivially default-constructible. Unlike &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;in C&lt;/a&gt;, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;: placement-new is required to formally &lt;a href=&quot;objects&quot;&gt;introduce a new object&lt;/a&gt; and avoid potential undefined behavior.</source>
          <target state="translated">単純なデフォルトコンストラクターは、アクションを実行しないコンストラクターです。C言語と互換性のあるすべてのデータ型（POD型）は、簡単にデフォルトで構築できます。ただし、&lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;C&lt;/a&gt;とは異なり、単純なデフォルトコンストラクターを持つオブジェクトは、 &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 割り当てられたメモリなど、適切に配置されたストレージを単に再解釈するだけでは作成できません。&lt;a href=&quot;objects&quot;&gt;新しいオブジェクト&lt;/a&gt;を正式に導入して未定義の動作の可能性を回避するには、placement-newが必要です。</target>
        </trans-unit>
        <trans-unit id="033337ca5c4ad7c5b77be1ecaa5de6acda3c11c8" translate="yes" xml:space="preserve">
          <source>A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete-expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible.</source>
          <target state="translated">trivial デストラクタとは、何のアクションも行わないデストラクタのことです。トリビアルデストラクタを持つオブジェクトは削除式を必要とせず、単にストレージを解放するだけで廃棄することができます。C言語と互換性のあるデータ型(POD型)はすべてtrivially destructibleです。</target>
        </trans-unit>
        <trans-unit id="d79042321968ff405b9eb41b02f03841f248eb8b" translate="yes" xml:space="preserve">
          <source>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially move-assignable.</source>
          <target state="translated">ささいな移動代入演算子は、ささいなコピー代入演算子と同じアクションを実行します。つまり、 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; よるかのようにオブジェクト表現のコピーを作成します。C言語と互換性のあるすべてのデータ型（POD型）は、簡単に移動して割り当て可能です。</target>
        </trans-unit>
        <trans-unit id="0ceb73134e634232cb9fed5b06967cd8af551fd6" translate="yes" xml:space="preserve">
          <source>A trivial move constructor is a constructor that performs the same action as the trivial copy constructor, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially movable.</source>
          <target state="translated">トリビアルムーブコンストラクターは、トリビアルコピーコンストラクターと同じアクションを実行するコンストラクターです。つまり、 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; よるかのようにオブジェクト表現のコピーを作成します。C言語と互換性のあるすべてのデータ型（POD型）は簡単に移動できます。</target>
        </trans-unit>
        <trans-unit id="4362f0ff877083bd05b03790df742e70f948b72d" translate="yes" xml:space="preserve">
          <source>A try-block is a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, and as such, can appear anywhere a statement can appear (that is, as one of the statements in a compound statement, including the function body compound statement). See &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for the try blocks around function bodies. The following description applies to both try-blocks and &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt;.</source>
          <target state="translated">try-blockは&lt;a href=&quot;statements&quot;&gt;ステートメント&lt;/a&gt;であり、そのため、ステートメントを記述できる場所ならどこでも（つまり、関数本体の複合ステートメントを含む複合ステートメント内のステートメントの1つとして）出現できます。関数本体の周りのtry &lt;a href=&quot;function-try-block&quot;&gt;ブロック&lt;/a&gt;については、function-try-blockを参照してください。次の説明は、try-blocksと&lt;a href=&quot;function-try-block&quot;&gt;function-try-blocksの&lt;/a&gt;両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="19834a31076ba08c517eaff630de5e748d366c53" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;E&lt;/code&gt; satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; will additionally satisfy RandomNumberEngine if, given.</source>
          <target state="translated">与えられた場合、&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;を満たすタイプ &lt;code&gt;E&lt;/code&gt; は、RandomNumberEngineをさらに満たします。</target>
        </trans-unit>
        <trans-unit id="ca6cf0688a958e8a7bf6dc59cfc4cfb1df147a82" translate="yes" xml:space="preserve">
          <source>A type T is ValueSwappable if.</source>
          <target state="translated">T型がValueSwappableなのは、以下の場合です。</target>
        </trans-unit>
        <trans-unit id="a7bc09bb961fc3d44a04b48c1111a1a318bd62fe" translate="yes" xml:space="preserve">
          <source>A type has</source>
          <target state="translated">型には</target>
        </trans-unit>
        <trans-unit id="1816dc600e8b7d025987ab256efe8b9a53ee4eb9" translate="yes" xml:space="preserve">
          <source>A type requirement is the keyword &lt;code&gt;typename&lt;/code&gt; followed by a type name, optionally qualified. The requirement is that the named type is valid: this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete.</source>
          <target state="translated">タイプ要件は、キーワード &lt;code&gt;typename&lt;/code&gt; の後にタイプ名が続き、オプションで修飾されます。要件は、名前付きタイプが有効であることです。これは、特定の名前付きネストタイプが存在すること、クラステンプレート特殊化がタイプに名前を付けること、またはエイリアステンプレート特殊化がタイプに名前を付けることを確認するために使用できます。クラステンプレートの特殊化に名前を付けるタイプ要件では、タイプが完全である必要はありません。</target>
        </trans-unit>
        <trans-unit id="15ef01c2ad4973128037ff3072f4151a78c62933" translate="yes" xml:space="preserve">
          <source>A type that can hold all valid values of &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::char_type&lt;/code&gt; と &lt;code&gt;X::eof()&lt;/code&gt; すべての有効な値を保持できる型</target>
        </trans-unit>
        <trans-unit id="03ac68cf57c6c426934400170b4271e37c362fbe" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;std::puts&lt;/code&gt; is running out of space on the file system, when &lt;code&gt;stdout&lt;/code&gt; is redirected to a file.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; がファイルにリダイレクトされたときに、 &lt;code&gt;std::puts&lt;/code&gt; の一般的な失敗の原因がファイルシステムのスペース不足です。</target>
        </trans-unit>
        <trans-unit id="ae95c3cb82eea0b19d5fa37c3903de19a5db5a6a" translate="yes" xml:space="preserve">
          <source>A typical example of such situation is the naive implementation of &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derived from the empty base &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;), which holds the underlying iterator (also derived from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;) as its first non-static data member.</source>
          <target state="translated">そのような状況の典型的な例は、空の基本 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; から派生した &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 単純な実装であり、最初の非静的データメンバーとして基本となるイテレーター（ &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; からも派生）を保持します。</target>
        </trans-unit>
        <trans-unit id="0734374c55a399a52d1410a4e6f7c1c0d057f16d" translate="yes" xml:space="preserve">
          <source>A typical generator's yield_value would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the co_await) its argument into the generator object and return &lt;code&gt;std::suspend_always&lt;/code&gt;, transferring control to the caller/resumer.</source>
          <target state="translated">一般的なジェネレーターのyield_valueは、その引数をジェネレーターオブジェクトに格納（コピー/移動、またはアドレスを格納します。引数の有効期間はco_await内の中断ポイントを横切るため）、その引数をジェネレーターオブジェクトに返し、 &lt;code&gt;std::suspend_always&lt;/code&gt; を返し、呼び出し元/再開者に制御を転送します。</target>
        </trans-unit>
        <trans-unit id="51f160ce423fd83704df3a5cb0174dbe3220c314" translate="yes" xml:space="preserve">
          <source>A typical implementation holds one integer data member (the value) and a pointer to an &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一般的な実装では、1つの整数データメンバー（値）と &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; へのポインターを保持します。</target>
        </trans-unit>
        <trans-unit id="1aa218a5c2f20a77c0b0ce98af0029f85ebd7ae1" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to &lt;code&gt;T&lt;/code&gt; and a size.</source>
          <target state="translated">典型的な実装では、 &lt;code&gt;T&lt;/code&gt; へのポインタとサイズの2つのメンバーしか保持しません。</target>
        </trans-unit>
        <trans-unit id="b1049a0bd6d2b817dcdf4dbacf6924d39c59809b" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to constant &lt;code&gt;CharT&lt;/code&gt; and a size.</source>
          <target state="translated">典型的な実装は2つのメンバーのみを保持します。定数 &lt;code&gt;CharT&lt;/code&gt; へのポインターとサイズです。</target>
        </trans-unit>
        <trans-unit id="2c4f9d8e2fe4e7c12c1285e532e5570e4bb48e5d" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_fstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_fstream&lt;/code&gt; 一般的な実装は、非派生データメンバーを1つだけ保持します： &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; インスタンス。</target>
        </trans-unit>
        <trans-unit id="b8130838cccfdb668dc1da70d0ff806b7225abc0" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ifstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ifstream&lt;/code&gt; 一般的な実装は、非派生データメンバーを1つだけ保持します &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; インスタンス&amp;lt;CharT、Traits&amp;gt;です。</target>
        </trans-unit>
        <trans-unit id="7183d62923a8e947e2f0e103df21cd2904d87891" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ofstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ofstream&lt;/code&gt; 典型的な実装は、1つの非派生データメンバー、 &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; インスタンスのみを保持します。</target>
        </trans-unit>
        <trans-unit id="217f99906b2120be1fba7713f69e991a00815576" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::istream_iterator&lt;/code&gt; holds two data members: a pointer to the associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object and the most recently read value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; 一般的な実装は2つのデータメンバーを保持します。関連する &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; オブジェクトへのポインターと、最後に読み取られた型 &lt;code&gt;T&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="ad3a71fd17c76f0ee62dee1d66ae5633a375fd68" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_iterator&lt;/code&gt; holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (&lt;code&gt;const regex_type*&lt;/code&gt;), the match flags (&lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt;), and the current match (&lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; 一般的な実装は、基になるシーケンス（BidirItの2つのインスタンス）の開始および終了反復子、正規表現へのポインター（ &lt;code&gt;const regex_type*&lt;/code&gt; ）、一致フラグ（ &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt; ）を保持します。 、および現在の一致（ &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5594f6466e9c627a309f191d1d21416131d6dcaa" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_token_iterator&lt;/code&gt; holds the underlying &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, a container (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;, pointing at the current submatch of the current match, and a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; object containing the last non-matched character sequence (used in tokenizer mode).</source>
          <target state="translated">&lt;code&gt;std::regex_token_iterator&lt;/code&gt; 一般的な実装は、基になる &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 、要求されたサブマッチインデックスのコンテナー（例： &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; ）、サブマッチのインデックスに等しい内部カウンター、 &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; へのポインターを保持します。 ：sub_matchは、現在のマッチの現在の &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 、最後の一致しない文字シーケンスを含むstd :: match_resultsオブジェクト（トークン化モードで使用）を指します。</target>
        </trans-unit>
        <trans-unit id="ec993624f290f31f38642161da480cca7738a5b4" translate="yes" xml:space="preserve">
          <source>A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">一様ランダムビット生成器は、可能な結果の範囲内の各値が(理想的には)等しい確率であるような符号なし整数値を返す関数オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="5b1045e71b04fce292271774a5a72bec6686a37d" translate="yes" xml:space="preserve">
          <source>A union can have member functions (including constructors and destructors), but not virtual functions.</source>
          <target state="translated">ユニオンはメンバ関数(コンストラクタやデストラクタを含む)を持つことができますが、仮想関数を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="a2abfe76729a7513736cb7faa5d5ce5576166784" translate="yes" xml:space="preserve">
          <source>A union cannot have base classes and cannot be used as a base class.</source>
          <target state="translated">ユニオンは基底クラスを持つことはできず、基底クラスとして使用することはできません。</target>
        </trans-unit>
        <trans-unit id="d044e7ff18d6370026b7cb48f5515536c724fbdc" translate="yes" xml:space="preserve">
          <source>A union cannot have non-static data members of reference types.</source>
          <target state="translated">ユニオンは、参照型の非静的データメンバを持つことはできません。</target>
        </trans-unit>
        <trans-unit id="8c914c20794cb64933a85898ab023cc57498cff6" translate="yes" xml:space="preserve">
          <source>A union is a special class type that can hold only one of its non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; at a time.</source>
          <target state="translated">unionは、一度に1つの非静的&lt;a href=&quot;data_members&quot;&gt;データメンバー&lt;/a&gt;のみを保持できる特別なクラス型です。</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">ナロー文字列リテラルまたは16ビット文字列リテラルのユニバーサル文字名は、複数の文字にマップされる場合があります。たとえば、 &lt;code&gt;\U0001f34c&lt;/code&gt; は、UTF-8（ &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ）の4 &lt;code&gt;char&lt;/code&gt; コードユニットおよび2 &lt;code&gt;char16_t&lt;/code&gt; コードです。 UTF-16の単位（ &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="416c36a6fa82a246cd095bd156c7aaf5425291a8" translate="yes" xml:space="preserve">
          <source>A useful guideline is that the destructor of any base class must be &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public and virtual or protected and non-virtual&lt;/a&gt;.</source>
          <target state="translated">便利なガイドラインとして、基本クラスのデストラクタは&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;パブリックかつ仮想であるか、保護されていて非仮想である&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="83e4b1da3b5d3236546ebba09aeb934da81e6f4f" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; can be a template.</source>
          <target state="translated">ユーザー定義の&lt;a href=&quot;cast_operator&quot;&gt;変換関数&lt;/a&gt;をテンプレートにすることができます。</target>
        </trans-unit>
        <trans-unit id="5d638bfd657359641307f2e7271f6931cb2015b9" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;code&gt;std::unexpected_handler&lt;/code&gt; is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:</source>
          <target state="translated">ユーザー定義の &lt;code&gt;std::unexpected_handler&lt;/code&gt; は、プログラムを終了するか、例外をスローする必要があります。例外がスローされると、次の3つの状況のいずれかが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="73f25ff036d8280e869a001e21e48bbeb542c334" translate="yes" xml:space="preserve">
          <source>A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; call.</source>
          <target state="translated">ユーザー定義の変換は、ゼロまたは1つの非明示的な単一引数コンストラクターまたは非明示的な&lt;a href=&quot;cast_operator&quot;&gt;変換関数&lt;/a&gt;呼び出しで構成されます。</target>
        </trans-unit>
        <trans-unit id="d0e1aabd13d35e1072413a4e56940753290b1935" translate="yes" xml:space="preserve">
          <source>A user-defined conversion function template cannot have a deduced return type.</source>
          <target state="translated">ユーザ定義の変換関数テンプレートは,推論された戻り値の型を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="1e6c06935ba93da6b0506db32bcdb2cfcdba4051" translate="yes" xml:space="preserve">
          <source>A user-defined literal is an expression of any of the following forms.</source>
          <target state="translated">ユーザー定義リテラルは、以下の形式のいずれかの式です。</target>
        </trans-unit>
        <trans-unit id="3054b1de584f16f3593abd57817b8a39cfd5c191" translate="yes" xml:space="preserve">
          <source>A user-provided &lt;code&gt;Compare&lt;/code&gt; can be supplied to change the ordering, e.g. using &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; would cause the smallest element to appear as the &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザー提供の &lt;code&gt;Compare&lt;/code&gt; を使用して順序を変更できます。たとえば、 &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; すると、最小の要素が &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="640dc08af4538f2be62eb03eb3dd195df49a90d2" translate="yes" xml:space="preserve">
          <source>A using-declaration also can't be used to introduce the name of a dependent member template as a</source>
          <target state="translated">また、使用宣言は、従属メンバテンプレートの名前を</target>
        </trans-unit>
        <trans-unit id="4bae902040c5ab2ebd693033e3fed94dda49e2af" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot name a member template specialization (&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; is not permitted by the grammar):</source>
          <target state="translated">using宣言では、メンバーテンプレートの特殊化を指定できません（&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;は文法では許可されていません）。</target>
        </trans-unit>
        <trans-unit id="ef90b2e3eff9b374774e4a806f69699ec8e2d794" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot refer to a namespace, to a scoped enumerator, to a destructor of a base class or to a specialization of a member template for a user-defined conversion function.</source>
          <target state="translated">使用宣言は、名前空間、スコープ付き列挙子、基底クラスのデストラクタ、またはユーザ定義の変換関数のメンバテンプレートの特殊化を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="b03fbcaa0bf1071b311fbaae0c5ce6b26d0a8ede" translate="yes" xml:space="preserve">
          <source>A using-declaration with more than one using-declarator is equivalent to a corresponding sequence of using-declarations with one using-declarator.</source>
          <target state="translated">つ以上の使用宣言子を持つ使用宣言子は、1つの使用宣言子を持つ使用宣言子の対応するシーケンスと同等である。</target>
        </trans-unit>
        <trans-unit id="20d0f9a0bea74c92ad5ff18da1b24cd553bbba2b" translate="yes" xml:space="preserve">
          <source>A valarray with the same size as the parameter.</source>
          <target state="translated">パラメータと同じサイズの配列。</target>
        </trans-unit>
        <trans-unit id="9b0aa598587fc3cc855c9c9ccc2c85d04dd3b0d5" translate="yes" xml:space="preserve">
          <source>A valid const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">に有効なのconstイテレータ &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14a30aab0776a047f20feb27371310d867438a4f" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">への有効なdereferenceableのconstイテレータ &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5ba5e3ccd5588e225779b9a36ab64c069c240a" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">への有効なdereferenceableイテレータ &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28223fe6cd5ada49f5862218ac60de143b2567db" translate="yes" xml:space="preserve">
          <source>A value equal to 0 if the path is lexicographically equal to the given path.</source>
          <target state="translated">パスが与えられたパスと辞書的に等しい場合は0に等しい値。</target>
        </trans-unit>
        <trans-unit id="a50061555eec54932403da5e038843403742ee9c" translate="yes" xml:space="preserve">
          <source>A value equivalent to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; と同等の値。</target>
        </trans-unit>
        <trans-unit id="de1ab572a1a705bc1af0966dac1fe26f7ab37241" translate="yes" xml:space="preserve">
          <source>A value greater than 0 if the path is lexicographically greater than the given path.</source>
          <target state="translated">パスが与えられたパスよりも辞書的に大きい場合は、0よりも大きい値を指定します。</target>
        </trans-unit>
        <trans-unit id="59605f92ecf81d222cf73bc53f88e408d0be42bc" translate="yes" xml:space="preserve">
          <source>A value less than 0 if the path is lexicographically less than the given path.</source>
          <target state="translated">パスが与えられたパスよりも辞書的に小さい場合、0よりも小さい値。</target>
        </trans-unit>
        <trans-unit id="772e15e1bdd5eccbbc37f434f301068fa5b598a7" translate="yes" xml:space="preserve">
          <source>A value less than zero if this sub_match is</source>
          <target state="translated">このサブマッチが</target>
        </trans-unit>
        <trans-unit id="32241575a78d789ffd0a6260e7ef09d51214c2a4" translate="yes" xml:space="preserve">
          <source>A value not equivalent to any valid value of type &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; 型の有効な値と同等ではない値。</target>
        </trans-unit>
        <trans-unit id="6b19e1b2f4ff9e9aafad05b04d18d7cec329645b" translate="yes" xml:space="preserve">
          <source>A value of a floating-point type can also be converted to any complete enumeration type.</source>
          <target state="translated">浮動小数点型の値は、任意の完全な列挙型に変換することもできます。</target>
        </trans-unit>
        <trans-unit id="63a22bbd341be0d94948a8da39b757c96e4a822a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">エラーカテゴリ &lt;code&gt;&quot;future&quot;&lt;/code&gt; に関連付けられた &lt;code&gt;e&lt;/code&gt; からのエラーコード番号を保持する、タイプ &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="8d689f1f7f9107c84de7e9e6a91164c4d8d448b7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">エラーカテゴリ &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 関連付けられた &lt;code&gt;e&lt;/code&gt; からのエラーコード番号を保持する &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="d85edc98c1d148807f1167309444da367dce2885" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">エラーカテゴリ &lt;code&gt;&quot;future&quot;&lt;/code&gt; に関連付けられた &lt;code&gt;e&lt;/code&gt; からのエラーコード番号を保持する &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="db29599a3ec1300b12f7cddbf4961efd2a438f2c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">エラーカテゴリ &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 関連付けられた &lt;code&gt;e&lt;/code&gt; からのエラーコード番号を保持する &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="d4716864d7aecb12710c82c5051f8f56cfc5d9f6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt;, indicating the success status as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt; タイプの値。次のように成功ステータスを示します。</target>
        </trans-unit>
        <trans-unit id="32fad6cd0042895426d631ee6330654d50fdd26f" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifying the thread associated with &lt;code&gt;*this&lt;/code&gt;. If there is no thread associated, default constructed &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に関連付けられているスレッドを識別する &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; タイプの値。関連付けられているスレッドがない場合は、デフォルトで構築された &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4007ab79efb7d58184f823559bcab8f2c0fe4508" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X::key_type&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="072712158f85df6191a61fbd61f9b1af57edb2a6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X::value_type&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="c9fa2a7989928288a59b9d1061cab281384dc7d7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;dateorder&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;dateorder&lt;/code&gt; の値。</target>
        </trans-unit>
        <trans-unit id="e52779b1e6c9706944a08739b4d2e94ab73e1ebe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representing &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; を表す &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; タイプの値。</target>
        </trans-unit>
        <trans-unit id="372178480f2f29b6cd4a1502b1b12fa8b61b4a68" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::partial_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">上記のように、 &lt;code&gt;std::partial_ordering&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="f50da534940de9fa538b0344ec2f07e991732fc7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">上記の &lt;code&gt;std::strong_equality&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="1240d3098b2313d3e38b4e6524a3981c2caf173b" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">上記の &lt;code&gt;std::strong_ordering&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="d920da1ed499cf59fb8f2ff084478f87888ebedf" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">上記のように、 &lt;code&gt;std::weak_equality&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="84362b6647406e2ba1f03eb0961d6929e28947bb" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">上記のように、 &lt;code&gt;std::weak_ordering&lt;/code&gt; 型の値。</target>
        </trans-unit>
        <trans-unit id="d92cb041f91a75157fbd95d555f69774c1ab1976" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">タイプ &lt;code&gt;void (*)(int)&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; によって返された場合、エラーが発生したことを示します。</target>
        </trans-unit>
        <trans-unit id="03d7158f8947427f81b002e1dd1993eed28a9ff7" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;!c(ku, r)&lt;/code&gt;</source>
          <target state="translated">ような値に対して分配された &lt;code&gt;!c(ku, r)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450945ae5d73489824ccfb0cd773638c26cd3654" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r, ke)&lt;/code&gt; and &lt;code&gt;!c(ke, r)&lt;/code&gt;, with &lt;code&gt;c(r, ke)&lt;/code&gt; implying &lt;code&gt;!c(ke, r)&lt;/code&gt;</source>
          <target state="translated">ような値に対して分配された &lt;code&gt;c(r, ke)&lt;/code&gt; と &lt;code&gt;!c(ke, r)&lt;/code&gt; と、 &lt;code&gt;c(r, ke)&lt;/code&gt; 暗示 &lt;code&gt;!c(ke, r)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66162c2a5d40aef1c22e1f7994ce56c76783a955" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r,kl)&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; the key value of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">ような値に対して分配された &lt;code&gt;c(r,kl)&lt;/code&gt; を用いて、 &lt;code&gt;r&lt;/code&gt; のキー値 &lt;code&gt;e&lt;/code&gt; 及び &lt;code&gt;e&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a71e388e98e2de2ca1e6729afcd2caf02f4c95" translate="yes" xml:space="preserve">
          <source>A value that is identical for all &lt;code&gt;type_info&lt;/code&gt; objects referring to the same type.</source>
          <target state="translated">同じタイプを参照するすべての &lt;code&gt;type_info&lt;/code&gt; オブジェクトで同一の値。</target>
        </trans-unit>
        <trans-unit id="79bfc8c0189d75c8cec44ecc8d6396e58c45af93" translate="yes" xml:space="preserve">
          <source>A variable template declaration may appear at class scope, in which case it declares a static data member template. See &lt;a href=&quot;variable_template&quot;&gt;variable templates&lt;/a&gt; for details.</source>
          <target state="translated">変数テンプレート宣言は、クラススコープで表示される場合があります。その場合、静的データメンバーテンプレートが宣言されます。詳細については、&lt;a href=&quot;variable_template&quot;&gt;変数テンプレート&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a00357cf9d6e102b6c1e5ad12063c42c54ad2ce7" translate="yes" xml:space="preserve">
          <source>A variable template defines a family of variables or static data members.</source>
          <target state="translated">変数テンプレートは、変数または静的データメンバーのファミリーを定義します。</target>
        </trans-unit>
        <trans-unit id="aff896d1642161992d5991ac4ba8de8003708a52" translate="yes" xml:space="preserve">
          <source>A variable template may be introduced by a template declaration at namespace scope, where declaration declares a variable.</source>
          <target state="translated">変数テンプレートは、名前空間スコープのテンプレート宣言によって導入されることがあります。</target>
        </trans-unit>
        <trans-unit id="09fc623a5cbacf9a90a9e712a74ec555cda701fd" translate="yes" xml:space="preserve">
          <source>A variadic class template can be instantiated with any number of template arguments:</source>
          <target state="translated">可変クラスのテンプレートは、任意の数のテンプレート引数でインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="1fb3820743def9d88fa6123aad6fc9bce3f38a75" translate="yes" xml:space="preserve">
          <source>A variadic function template can be called with any number of function arguments (the template arguments are deduced through &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;):</source>
          <target state="translated">可変個関数テンプレートは、任意の数の関数引数を使用して呼び出すことができます（テンプレート引数は、テンプレート引数の演繹によって演繹され&lt;a href=&quot;template_argument_deduction&quot;&gt;ます&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bb6e304c2616213d182d17fab4792e56d3349945" translate="yes" xml:space="preserve">
          <source>A variant is not permitted to hold references, arrays, or the type &lt;code&gt;void&lt;/code&gt;. Empty variants are also ill-formed (&lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; can be used instead).</source>
          <target state="translated">バリアントは、参照、配列、または &lt;code&gt;void&lt;/code&gt; 型を保持することはできません。空のバリアントも &lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; です（代わりにstd :: variant &amp;lt; std :: monostate &amp;gt;を使用できます）。</target>
        </trans-unit>
        <trans-unit id="ce4af0ae9360b0d87edd912329cc74243aa60def" translate="yes" xml:space="preserve">
          <source>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</source>
          <target state="translated">変形体は,同じ型を複数回保持したり,同じ型の異なる cv-qualified バージョンを保持したりすることが許されています.</target>
        </trans-unit>
        <trans-unit id="ea9112a4205a8e149b6d870c2538c2387fcc45a2" translate="yes" xml:space="preserve">
          <source>A variant may become valueless in the following situations:</source>
          <target state="translated">以下のような状況では、バリアントは無価値になることがあります。</target>
        </trans-unit>
        <trans-unit id="360ab0f56da776d903fad4cd3c7802b6cff86bff" translate="yes" xml:space="preserve">
          <source>A variant that is valueless by exception is treated as being in an invalid state: &lt;a href=&quot;index&quot;&gt;index&lt;/a&gt; returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;, &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;.</source>
          <target state="translated">例外によって値のないバリアントは無効な状態として扱われます：&lt;a href=&quot;index&quot;&gt;インデックス&lt;/a&gt;が返されます&lt;a href=&quot;variant_npos&quot;&gt; variant_nposを&lt;/a&gt;、&lt;a href=&quot;get&quot;&gt;get&lt;/a&gt;と&lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt;は&lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_accessを&lt;/a&gt;スローします。</target>
        </trans-unit>
        <trans-unit id="d13acd0a8aed6cefb7c9972fe8dbd4991eb6d5ec" translate="yes" xml:space="preserve">
          <source>A vector of strings can be sorted according to a non-default locale by using the locale object as comparator:</source>
          <target state="translated">文字列のベクトルは、比較器として locale オブジェクトを用いることで、デフォルトではないロケールに応じてソートすることができます。</target>
        </trans-unit>
        <trans-unit id="c3e281fb8afe5cc3b522bbdd748cec3c0126f3da" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">main（）の非常に一般的な実装定義形式には、（ &lt;code&gt;argc&lt;/code&gt; に加えて）3番目の引数があります。と &lt;code&gt;argv&lt;/code&gt; ）、タイプの &lt;code&gt;char*[]&lt;/code&gt; を指し、&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;実行環境変数へのポインタの配列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ec66bbac0bdedd0761cb72a1751288a98eb028c" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">非常に一般的な実装定義形式のmain（）には&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;、実行環境変数へのポインターの配列を&lt;/a&gt;指す、 &lt;code&gt;char*[]&lt;/code&gt; 型の3番目の引数（ &lt;code&gt;argc&lt;/code&gt; および &lt;code&gt;argv&lt;/code&gt; に加えて）があります。</target>
        </trans-unit>
        <trans-unit id="6cef77f8c0ffb4916f8bc0498dc7440820ca8d36" translate="yes" xml:space="preserve">
          <source>A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.</source>
          <target state="translated">ゼロ初期化されたポインタは、NULLポインタの値が積分ゼロでなくても、その型のNULLポインタの値になります。</target>
        </trans-unit>
        <trans-unit id="7be129f416228534857a690cd4c38374c5515373" translate="yes" xml:space="preserve">
          <source>A, and B</source>
          <target state="translated">A,and B</target>
        </trans-unit>
        <trans-unit id="a5e35ae614f82259bcebce61eb00073751f2e388" translate="yes" xml:space="preserve">
          <source>A, and B is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, then X precedes B in S d) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">A、およびBは、 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作であり、 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; フェンスX</target>
        </trans-unit>
        <trans-unit id="48a01a12d57f9009c8dea86e8610f3bdea642dd4" translate="yes" xml:space="preserve">
          <source>A. Williams (2012), &quot;C++ concurrency in action&quot; 9.2.4 Interrupting a wait on std::condition_variable_any</source>
          <target state="translated">A.Williams (2012),&quot;C++同時実行&quot; 9.2.4 std::condition_variable_any での待ち時間の中断</target>
        </trans-unit>
        <trans-unit id="6b4fe715ea89fb871c5a975d173f10a5adf57e7c" translate="yes" xml:space="preserve">
          <source>A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.</source>
          <target state="translated">A1,A2,A3,A3,...は、曖昧さを避けるためにトップレベルでカンマ演算子を使用できないことを除いて、任意の式の空リストの可能性があります。</target>
        </trans-unit>
        <trans-unit id="de2c49eaafb50b14e68d760cacef2f0ba0ba8f45" translate="yes" xml:space="preserve">
          <source>ADL</source>
          <target state="translated">ADL</target>
        </trans-unit>
        <trans-unit id="cd5086cb4e7d0efbc40ccb220af4c1d024f33775" translate="yes" xml:space="preserve">
          <source>ADL can find a &lt;a href=&quot;friend&quot;&gt;friend function&lt;/a&gt; (typically, an overloaded operator) that is defined entirely within a class or class template, even if it was never declared at namespace level.</source>
          <target state="translated">ADL は、名前空間レベルで宣言されたことがない場合でも、完全にクラスまたはクラステンプレート内で定義されている&lt;a href=&quot;friend&quot;&gt;フレンド関数&lt;/a&gt;（通常、オーバーロードされた演算子）を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="daf2a98f5077d337e35a18a770cad80d218e9ca5" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORM</source>
          <target state="translated">ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORMAL</target>
        </trans-unit>
        <trans-unit id="5f8c72f94f6217e6dad861d24c88516ef9cd816b" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE SALLA USED AS KORANIC STOP SIGN ISOLATED FORM -</source>
          <target state="translated">コロニア語のストップサインとして使用されるアラビア文字のサラ-アイソレイテッド・フォーム</target>
        </trans-unit>
        <trans-unit id="af1d8ae2aa108f95b9b57f28478231da2a606638" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM -</source>
          <target state="translated">ARABIC LIGATURE TEH WITH JEEM WITH MEEM 最初のフォーム-ARABIC LIGATURE TEH WITH JEEM WITH MEEM 最初のフォーム-ARABIC LIGATURE TEH WITH JEEM WITH MEEM</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">アスキーチャート</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">アスキーチャート</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">アスキー値</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="435b6099910c97d9bc8e078e332560e92819291f" translate="yes" xml:space="preserve">
          <source>Abandons the shared state and destroys the stored task object.</source>
          <target state="translated">共有状態を放棄し、格納されたタスクオブジェクトを破棄します。</target>
        </trans-unit>
        <trans-unit id="36e1c539cc780bc605cb01b3fddc5d8db9c3b6ab" translate="yes" xml:space="preserve">
          <source>Abandons the shared state:</source>
          <target state="translated">共有状態を放棄します。</target>
        </trans-unit>
        <trans-unit id="e7becc73c7eaff031859fb120395433f96283795" translate="yes" xml:space="preserve">
          <source>Abbreviated function template</source>
          <target state="translated">省略された機能テンプレート</target>
        </trans-unit>
        <trans-unit id="019202b59ca73881cfaab35533cb5a7033c39a80" translate="yes" xml:space="preserve">
          <source>Abbreviated function templates can be specialized like all function templates.</source>
          <target state="translated">省略された関数テンプレートは、他の関数テンプレートと同様に特化することができます。</target>
        </trans-unit>
        <trans-unit id="fd2f1ad3f3e244485410235abcc0dcd9d528402f" translate="yes" xml:space="preserve">
          <source>Absolute value of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; の絶対値。</target>
        </trans-unit>
        <trans-unit id="1b11f0b716439740a7eef7b0954e8e03f2442de7" translate="yes" xml:space="preserve">
          <source>Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).</source>
          <target state="translated">抽象クラスは、一般的な概念(例えば、Shape、Animal)を表現するために使用され、具体的なクラス(例えば、Circle、Dog)の基底クラスとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="496f013275ea0cccdde9e4ce5e27272837e636f5" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).</source>
          <target state="translated">抽象型は,パラメータ型,関数の戻り値型,明示的な変換の型として使用することはできません(関数宣言の時点でパラメータと戻り値型が不完全である可能性があるため,これは定義と関数呼び出しの時点でチェックされることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="fe89f3fca6949588976c79493bd13c9b36f00658" translate="yes" xml:space="preserve">
          <source>Access checking for the names used in &lt;a href=&quot;default_arguments&quot;&gt;default function arguments&lt;/a&gt; as well as in the default &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;template parameters&lt;/a&gt; is performed at the point of declaration, not at the point of use.</source>
          <target state="translated">&lt;a href=&quot;default_arguments&quot;&gt;デフォルトの関数引数で&lt;/a&gt;使用される名前のアクセスチェックとデフォルトの&lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;テンプレートパラメータで&lt;/a&gt;時ではなく宣言時に実行されます。</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">圏外アクセス</target>
        </trans-unit>
        <trans-unit id="64d102e911590ffe48aba24684384d363cf0b36b" translate="yes" xml:space="preserve">
          <source>Access outside of lifetime</source>
          <target state="translated">ライフタイム以外のアクセス</target>
        </trans-unit>
        <trans-unit id="ff2202db9230ee307101c952851e1360ff1ce903" translate="yes" xml:space="preserve">
          <source>Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.</source>
          <target state="translated">アクセスオーバーヘッド。pImplでは、プライベート・メンバ関数を呼び出すたびにポインタを介して間接的に呼び出されます。プライベート・メンバからパブリック・メンバへのアクセスは、別のポインターを介して間接的に行われます。どちらの間接操作も翻訳ユニットの境界を越えているため、リンク時間の最適化によってのみ最適化することができます。OO factoryでは、公開データと実装の詳細の両方にアクセスするために、翻訳ユニットをまたいで間接的にアクセスする必要があり、仮想ディスパッチのためにリンク時間のオプティマイザの機会がさらに少なくなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="41dcddad26f26d0b23476e3af19f8e0cff1f9f7e" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">アクセス許可モデル&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX許可ビット&lt;/a&gt;、および個々のファイルの許可（&lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;によって報告される）は、以下のビットのいくつかの組み合わせです。</target>
        </trans-unit>
        <trans-unit id="ff48fcdd36448626dfca91c0959a95a136068169" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">アクセス許可モデル&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX許可ビット&lt;/a&gt;、および個々のファイル許可（&lt;a href=&quot;status&quot;&gt;ステータス&lt;/a&gt;によって報告される）は、次のビットのいくつかの組み合わせです。</target>
        </trans-unit>
        <trans-unit id="b29695d27ada4464e68e5f7e3d3cd693fa6cadcf" translate="yes" xml:space="preserve">
          <source>Access rules for the names of &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored.</source>
          <target state="translated">の名前のアクセス規則 &lt;a href=&quot;virtual&quot;&gt;仮想関数&lt;/a&gt;メンバー関数が呼び出されるオブジェクトを示すために使用される式のタイプを使用して、呼び出しポイントでチェックされます。最終オーバーライドのアクセスは無視されます。</target>
        </trans-unit>
        <trans-unit id="172f15fcb1759434b4e5cac298998c9f90e5367d" translate="yes" xml:space="preserve">
          <source>Access specifiers</source>
          <target state="translated">アクセス指定子</target>
        </trans-unit>
        <trans-unit id="fd9b61139d61fe4a3ad562d5c3fb1467d5f0fb25" translate="yes" xml:space="preserve">
          <source>Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the</source>
          <target state="translated">アクセス指定子は、クラスの作成者に、クラスのユーザがどのクラスのメンバにアクセスできるかを決定する能力を与えます(つまり</target>
        </trans-unit>
        <trans-unit id="b5f1627a2f9ef35b0cad78d685d46c26ac79a8ba" translate="yes" xml:space="preserve">
          <source>Access to a non-static data member or a call to a non-static member function.</source>
          <target state="translated">非静的データ・メンバへのアクセス、または非静的メンバ関数への呼び出し。</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">reallocに渡されたポインタへのアクセス</target>
        </trans-unit>
        <trans-unit id="27559787dd122b923d06b7298557d1cd2c568a23" translate="yes" xml:space="preserve">
          <source>Access to the &lt;code&gt;p&lt;/code&gt;'s deleter. If the shared pointer &lt;code&gt;p&lt;/code&gt; owns a deleter of type cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の削除機能へのアクセス。共有ポインター &lt;code&gt;p&lt;/code&gt; がcv-unqualifiedタイプの削除者を所有している場合 &lt;code&gt;Deleter&lt;/code&gt; の場合（たとえば、削除者をパラメーターとして取るコンストラクターの1つで作成された場合）、削除者へのポインターを返します。それ以外の場合は、nullポインタを返します。</target>
        </trans-unit>
        <trans-unit id="5c1d13d1c544b3feecb6e442b5b9a73c51c6b267" translate="yes" xml:space="preserve">
          <source>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a &lt;code&gt;shared_future&lt;/code&gt; object.</source>
          <target state="translated">複数のスレッドから同じ共有状態へのアクセスは、各スレッドが独自の &lt;code&gt;shared_future&lt;/code&gt; オブジェクトの。</target>
        </trans-unit>
        <trans-unit id="f563d2f693e12ab63ee51309db6c0dd439835d3c" translate="yes" xml:space="preserve">
          <source>Accesses a member of its operand.</source>
          <target state="translated">オペランドのメンバにアクセスします。</target>
        </trans-unit>
        <trans-unit id="a42b2fe3c4d5fcc9a9d311beb7c3efb130c09b8a" translate="yes" xml:space="preserve">
          <source>Accesses the bit at position &lt;code&gt;pos&lt;/code&gt;. The first version returns the value of the bit, the second version returns an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; that allows modification of the value.</source>
          <target state="translated">位置 &lt;code&gt;pos&lt;/code&gt; のビットにアクセスします。最初のバージョンはビットの値を返し、2番目のバージョンは &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; タイプのオブジェクトを返します値を変更できるます。</target>
        </trans-unit>
        <trans-unit id="d60917183a0203e125a2a367082f7e505a1b54cc" translate="yes" xml:space="preserve">
          <source>Accesses the contained value.</source>
          <target state="translated">含まれる値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="5ffc054a82694395488926c5d88d20377f2fee4f" translate="yes" xml:space="preserve">
          <source>Accesses the file permissions information.</source>
          <target state="translated">ファイルのパーミッション情報にアクセスします。</target>
        </trans-unit>
        <trans-unit id="0faa3d14d648895a9103231a47e67306cf3658f8" translate="yes" xml:space="preserve">
          <source>Accesses the file type information.</source>
          <target state="translated">ファイルタイプ情報にアクセスします。</target>
        </trans-unit>
        <trans-unit id="9ab9ff8b7be4b7d40eb92e8afba99b14b56097f9" translate="yes" xml:space="preserve">
          <source>Accesses the imaginary part of the complex number.</source>
          <target state="translated">複素数の虚数部にアクセスします。</target>
        </trans-unit>
        <trans-unit id="6c9900004652bab063edd448abb4e13e10ff694e" translate="yes" xml:space="preserve">
          <source>Accesses the index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">に格納されているインデックスにアクセスします &lt;code&gt;*this&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="f3c82d4ce7723e142d0946770db58f80f216a936" translate="yes" xml:space="preserve">
          <source>Accesses the name and target of this &lt;code&gt;link&lt;/code&gt; object.</source>
          <target state="translated">この名前とターゲットにアクセスします &lt;code&gt;link&lt;/code&gt; オブジェクトます。</target>
        </trans-unit>
        <trans-unit id="ad5cf92f478d0439f59cdb4880f47ebacaf46e23" translate="yes" xml:space="preserve">
          <source>Accesses the native handle of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">のネイティブハンドルにアクセスします &lt;code&gt;*this&lt;/code&gt; のます。</target>
        </trans-unit>
        <trans-unit id="9d7d833d3713305bce90c91948acf875f0c20ba4" translate="yes" xml:space="preserve">
          <source>Accesses the native path name as a character string.</source>
          <target state="translated">ネイティブパス名に文字列としてアクセスします。</target>
        </trans-unit>
        <trans-unit id="3ae496a866ebcdc4db51cd8794d1e50d8d500069" translate="yes" xml:space="preserve">
          <source>Accesses the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; に&lt;/a&gt;アクセスしますます。</target>
        </trans-unit>
        <trans-unit id="9823697b16ef01bf1ebfdd504cd02cc048fbff41" translate="yes" xml:space="preserve">
          <source>Accesses the real part of the complex number.</source>
          <target state="translated">複素数の実数部分にアクセスします。</target>
        </trans-unit>
        <trans-unit id="bbd2d3ce5c26cd90201155a08a10040ce8faa66b" translate="yes" xml:space="preserve">
          <source>Accessibility applies to all names with no regard to their origin, so a name introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;using_declaration&quot;&gt;using declarations&lt;/a&gt; is checked, not the name it refers to.</source>
          <target state="translated">アクセシビリティは、その起源に関係なくすべての名前に適用されるため、&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;または&lt;a href=&quot;using_declaration&quot;&gt;宣言を使用して&lt;/a&gt;がチェックされます。参照する名前ではありません。</target>
        </trans-unit>
        <trans-unit id="db5f1eeeca9d3c68907d330e642c8ec9d5a0116f" translate="yes" xml:space="preserve">
          <source>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; for the list of exceptions and examples.</source>
          <target state="translated">オブジェクトが作成されたタイプ以外のタイプの式を使用してオブジェクトにアクセスすることは、多くの場合、未定義の動作です。 &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;&lt;/a&gt;です。例外と例のリストについては、reinterpret_castを。</target>
        </trans-unit>
        <trans-unit id="43edbdec6f4616d56db2ed67623f9b6b877668ea" translate="yes" xml:space="preserve">
          <source>Accessing the variable during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">初期化中に別のスレッドからアトミック操作を介しても変数にアクセスすると、データ競合が発生します（アドレスが &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 操作で別のスレッドにすぐに渡される場合に発生する可能性があります）。</target>
        </trans-unit>
        <trans-unit id="bd21f9aade4e041d6127535e2103b7265328e814" translate="yes" xml:space="preserve">
          <source>Acquire operation</source>
          <target state="translated">操作を取得する</target>
        </trans-unit>
        <trans-unit id="336eaf1465ee3c86483dca958f5b3f81e8c35309" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutex &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">指定されたミューテックス &lt;code&gt;m&lt;/code&gt; の所有権を取得します。</target>
        </trans-unit>
        <trans-unit id="a0bfcec1da334e9014a69ecff78b70a46245c533" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutexes &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">与えられたミューテックス &lt;code&gt;m&lt;/code&gt; の所有権を取得します。</target>
        </trans-unit>
        <trans-unit id="c865fe856f24b54f5a468d814de44d24b3ad8da2" translate="yes" xml:space="preserve">
          <source>Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to &lt;code&gt;lock_shared&lt;/code&gt; will block execution until shared ownership can be acquired.</source>
          <target state="translated">mutexの共有所有権を取得します。別のスレッドが排他的所有権でミューテックスを保持している場合、 &lt;code&gt;lock_shared&lt;/code&gt; を呼び出すと、共有所有権を取得できるまで実行がブロックされます。</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">ファイルがある場合のアクション</target>
        </trans-unit>
        <trans-unit id="5405a9d57e6b63ab5821d9588dde26920a308e00" translate="yes" xml:space="preserve">
          <source>Action if file already exists</source>
          <target state="translated">ファイルが既に存在する場合のアクション</target>
        </trans-unit>
        <trans-unit id="c3c1db410576ecf3d85988b0535501a3dc1d020f" translate="yes" xml:space="preserve">
          <source>Action if file does not exist</source>
          <target state="translated">ファイルが存在しない場合の動作</target>
        </trans-unit>
        <trans-unit id="a7817b78f6b68e579f4e4537bfed1875e7ae184f" translate="yes" xml:space="preserve">
          <source>Actual implementations vary:</source>
          <target state="translated">実際の実装は様々です。</target>
        </trans-unit>
        <trans-unit id="3ca7e3d2e4ac34bc514652447560887a72b3f649" translate="yes" xml:space="preserve">
          <source>Adaptors</source>
          <target state="translated">Adaptors</target>
        </trans-unit>
        <trans-unit id="fb414d455da6b9468629ebcfdfce20d9ea740f72" translate="yes" xml:space="preserve">
          <source>Adding constexpr modifiers to &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</source>
          <target state="translated">constexprの修飾子を追加する &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; と&lt;a href=&quot;iterator#Container_access&quot;&gt;範囲アクセス&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9c64c7ebe5a611a1f12ffc12fb7a8366d9e1fdc" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to associative containers</source>
          <target state="translated">連想コンテナへの異種比較ルックアップの追加</target>
        </trans-unit>
        <trans-unit id="ad005a38d417aa5d21ad05bcc3397517559e1e10" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to unordered associative containers</source>
          <target state="translated">順番のない連想コンテナへの異種比較ルックアップの追加</target>
        </trans-unit>
        <trans-unit id="a6dea03cb51c5650f791a12987ca0df26adb5602" translate="yes" xml:space="preserve">
          <source>Adding pre-calculated hash value lookup to unordered associative containers</source>
          <target state="translated">順番のない連想コンテナに事前に計算されたハッシュ値のルックアップを追加しました。</target>
        </trans-unit>
        <trans-unit id="87ed11c26edf58b14803d392bf82cd48a91e96b8" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</source>
          <target state="translated">リスト内や複数のリストをまたいで要素を追加、削除、移動しても、イテレータや参照は無効になりません。イテレータが無効になるのは、対応する要素が削除された場合のみです。</target>
        </trans-unit>
        <trans-unit id="98f2660c67411bcd6814bc7ce1f2e850dfc897be" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt;) from the list.</source>
          <target state="translated">リスト内または複数のリスト間で要素を追加、削除、移動しても、現在リスト内の他の要素を参照しているイテレータが無効になることはありません。ただし、要素を参照するイテレータまたは参照は、対応する要素が削除されると（ &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt; を介して）無効になります。）リストからなります。</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">加減算</target>
        </trans-unit>
        <trans-unit id="5c20b1f1d3dccc5fc33df625c9821015eb0d18af" translate="yes" xml:space="preserve">
          <source>Additional basic types and macros</source>
          <target state="translated">追加の基本タイプとマクロ</target>
        </trans-unit>
        <trans-unit id="dc459b3781fd1c39294a64216e4b94c9615d87b0" translate="yes" xml:space="preserve">
          <source>Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions.</source>
          <target state="translated">拡張子に追加要素(代替データストリームや分割されたデータセット名など)を追加するファイルシステムの実装によって、追加の動作が定義されている場合があります。</target>
        </trans-unit>
        <trans-unit id="a9a945aa19333f0b54ff5676b6d9de2643f1b76b" translate="yes" xml:space="preserve">
          <source>Additional classifications such as &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; or &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; may be provided by system-supplied locales (in which case they are also accessible through &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; または &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; などの追加の分類は、システム提供のロケールによって提供される場合があります（この場合、 &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt; からもアクセスできます））。</target>
        </trans-unit>
        <trans-unit id="ed64694f365b81d351dbd520c43964630a71e79f" translate="yes" xml:space="preserve">
          <source>Additional concepts can be found in &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;the algorithms library&lt;/a&gt; and &lt;a href=&quot;ranges#Range_concepts&quot;&gt;the ranges library&lt;/a&gt;.</source>
          <target state="translated">追加の概念は&lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;、アルゴリズムライブラリ&lt;/a&gt;と&lt;a href=&quot;ranges#Range_concepts&quot;&gt;範囲ライブラリにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="655988b4d376c12072cf6c9cdb9826fe22ae3e28" translate="yes" xml:space="preserve">
          <source>Additional execution policies may be provided by a standard library implementation (possible future additions may include &lt;code&gt;std::parallel::cuda&lt;/code&gt; and &lt;code&gt;std::parallel::opencl&lt;/code&gt;).</source>
          <target state="translated">追加の実行ポリシーは、標準ライブラリの実装によって提供される場合があります（将来追加される可能性があるのは、 &lt;code&gt;std::parallel::cuda&lt;/code&gt; および &lt;code&gt;std::parallel::opencl&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0b037de42fdfdd2746ba0eff4076bb78f7f07fda" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined preparation may take place, which may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">追加の実装定義の準備が行われる場合があり、 &lt;code&gt;setstate(failbit)&lt;/code&gt; を呼び出す可能性があります（ &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; スローする可能性があります）ます）。</target>
        </trans-unit>
        <trans-unit id="96549f1325a6bd11423df1587b53f51b1bda1aee" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">&lt;code&gt;LC_&lt;/code&gt; で始まり、その後に少なくとも1つの大文字が続く名前を持つ追加のマクロ定数は、 &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt; で定義できます。たとえば、POSIX仕様ではLC_MESSAGES（ &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; を制御）、ISO / IEC 30112：2014（&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt; 2014 draft&lt;/a&gt;）はさらにLC_IDENTIFICATION、LC_XLITERATE、LC_NAME、LC_ADDRESS、LC_TELEPHONE、LC_PAPER、LC_MEASUREMENT、およびLC_KEYBOARDを定義します、GNU Cライブラリでサポートされています（LC_XLITERATEを除く）。</target>
        </trans-unit>
        <trans-unit id="99f91b99c0d1f5963361dc127f6dbe9e38bb8903" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">&lt;code&gt;FE_&lt;/code&gt; で始まり、その後に大文字が続き、タイプが &lt;code&gt;const std::fenv_t*&lt;/code&gt; である追加のマクロは、実装によってサポートされる場合があります。</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">現在インストールされているC &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; は、追加の数値形式を受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="0a5c5be417cfb6cd7d9118d383daf9f4ffd160e0" translate="yes" xml:space="preserve">
          <source>Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">追加のオーバーロードが &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、 &lt;code&gt;long double&lt;/code&gt; 、およびすべての整数型ており、虚数成分がゼロの複素数として扱われます。</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">追加の丸めモードは、実装によってサポートされていてもよい。</target>
        </trans-unit>
        <trans-unit id="c51476def7086889d71b363945c5ad2e8649c02e" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">追加の信号名&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;はPOSIXで指定されています&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b8e3f88a4fb1a893c72eb1c76430bba45d521493" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">追加の信号名&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;はPOSIXで指定されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7e1faa5440a863d95ba8c415f20385dfa4af6d4b" translate="yes" xml:space="preserve">
          <source>Additional support</source>
          <target state="translated">追加サポート</target>
        </trans-unit>
        <trans-unit id="04f95216581ee9c47e04240f25828352cba16ddc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; may be used to indicate conformance to the iterator concepts.</source>
          <target state="translated">さらに、 &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; イテレータの概念への適合性を示すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="f2e0dd9b924004af0072e53510ae5406eb8b489b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; are provided, either as members or as non-members, as required by &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">さらに、&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIteratorの&lt;/a&gt;必要に応じて、 &lt;code&gt;operator==&lt;/code&gt; および &lt;code&gt;operator!=&lt;/code&gt; がメンバーまたは非メンバーとして提供されます。。</target>
        </trans-unit>
        <trans-unit id="ce53b9c5df0fcfe1d1195f17fc25165a98c09650" translate="yes" xml:space="preserve">
          <source>Additionally, O(N) calls to the constructor of &lt;code&gt;value_type&lt;/code&gt;, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">さらに、O（N）は &lt;code&gt;value_type&lt;/code&gt; のコンストラクターを呼び出します。ここで、Nは &lt;code&gt;cont.size()&lt;/code&gt; です。。です。</target>
        </trans-unit>
        <trans-unit id="7bee97038914dbaf49097462be0b6fa3a27587e0" translate="yes" xml:space="preserve">
          <source>Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt;, &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; are provided and are equivalent to &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、各算術型のすべてのcv修飾バージョンには、非修飾の特殊化と同じ特殊化が存在します。たとえば、 &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt; 、 &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt; 、および &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; が提供され、 &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="234e939fc46f7fc9566afc50a39f23e96624b23f" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedMutex type supports another mode of ownership: shared. Multiple threads (or, more generally, execution agents) can simultaneously own this mutex in shared mode, but no thread may obtain shared ownership if there is a thread that owns it in exclusive mode and no thread may obtain exclusive ownership if there is a thread that owns it in shared mode. If more than implementation-defined number of threads (no less than 10000) hold a shared lock, another attempt to acquire the mutex in shared mode blocks until the number of shared owners drops down below that threshold.</source>
          <target state="translated">さらに、オブジェクト &lt;code&gt;m&lt;/code&gt; SharedMutexタイプのは、共有の別のモードである共有をサポートします。複数のスレッド（より一般的には実行エージェント）は、共有モードでこのミューテックスを同時に所有できますが、排他モードでそれを所有するスレッドが存在する場合、どのスレッドも共有所有権を取得できません。また、スレッドがある場合、どのスレッドも排他所有権を取得できません。共有モードでそれを所有しています。実装で定義されたスレッド数（10000以上）を超えるスレッドが共有ロックを保持している場合、共有所有者の数がそのしきい値を下回るまで、共有モードでmutexを取得する別の試行がブロックされます。</target>
        </trans-unit>
        <trans-unit id="4c21e2edf0f81a97ef8a624494e0c5a7e8d14423" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedTimedMutex type supports timed shared operations:</source>
          <target state="translated">さらに、SharedTimedMutexタイプのオブジェクト &lt;code&gt;m&lt;/code&gt; は、時限共有操作をサポートします。</target>
        </trans-unit>
        <trans-unit id="6981bc51ea468df1e5cb432a395ddfc2e5d78804" translate="yes" xml:space="preserve">
          <source>Additionally, for an object &lt;code&gt;m&lt;/code&gt; of TimedMutex type:</source>
          <target state="translated">さらに、TimedMutexタイプのオブジェクト &lt;code&gt;m&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="ceefa22c95a1f23f16745529c429d1edf71f2d45" translate="yes" xml:space="preserve">
          <source>Additionally, for every sequence container, the constructor template that takes two input iterators and the member function template overloads of &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;, &lt;code&gt;assign()&lt;/code&gt;, &lt;code&gt;replace()&lt;/code&gt; that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">さらに、すべてのシーケンスコンテナーで、2つの入力イテレーターを使用するコンストラクターテンプレートと、2つの入力イテレーターを使用する &lt;code&gt;insert()&lt;/code&gt; 、 &lt;code&gt;append()&lt;/code&gt; 、 &lt;code&gt;assign()&lt;/code&gt; 、 &lt;code&gt;replace()&lt;/code&gt; のメンバー関数テンプレートオーバーロードは、対応するテンプレート引数は&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIteratorを&lt;/a&gt;満たしていません。</target>
        </trans-unit>
        <trans-unit id="80407204b5613c93f4ff9eeeca0d87435272db5c" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt;, then(since C++11) precision modifier is added, set to &lt;code&gt;str.precision()&lt;/code&gt;</source>
          <target state="translated">さらに、 &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt; 場合、（C ++ 11以降）精度修飾子が追加され、 &lt;code&gt;str.precision()&lt;/code&gt; に設定されます</target>
        </trans-unit>
        <trans-unit id="92ec030910d3cd27bfd60a9308eb60d240987aa3" translate="yes" xml:space="preserve">
          <source>Additionally, in order for the type &lt;code&gt;A&lt;/code&gt; to satisfy Allocator.</source>
          <target state="translated">さらに、タイプ &lt;code&gt;A&lt;/code&gt; がAllocatorを満たすため。</target>
        </trans-unit>
        <trans-unit id="e4c633a25d8deae1fd83be48e6f21fc0579f3bfe" translate="yes" xml:space="preserve">
          <source>Additionally, the following constants of this type are defined, which do not represent permissions:</source>
          <target state="translated">さらに、この型の以下の定数が定義されていますが、これらはパーミッションを表しません。</target>
        </trans-unit>
        <trans-unit id="e3b85cc6377c854375953c6897c361f957b07ce5" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor.</source>
          <target state="translated">さらに、結果の &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; 特殊化には、標準のレイアウト、簡単なデフォルトコンストラクター、および簡単なデストラクタがあります。</target>
        </trans-unit>
        <trans-unit id="e8aaea245aabbd553929a2dc8693fcb475a09d9c" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">さらに、結果の &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; 特殊化には、標準のレイアウト、簡単なデフォルトコンストラクター、および簡単なデストラクタがあります。符号付き整数演算は、2の補数を使用するように定義されています。未定義の結果はありません。</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">加法演算子</target>
        </trans-unit>
        <trans-unit id="ce6e9db4782a94f83450a756f42238c060b97d77" translate="yes" xml:space="preserve">
          <source>Address constant expression</source>
          <target state="translated">アドレス定数式</target>
        </trans-unit>
        <trans-unit id="38ee922cd750ff4631c23d9b88d00633994c2466" translate="yes" xml:space="preserve">
          <source>Address family not supported</source>
          <target state="translated">サポートされていないアドレスファミリ</target>
        </trans-unit>
        <trans-unit id="9e53f7cf7661710ec98f0a6e7a65398f5e81f0be" translate="yes" xml:space="preserve">
          <source>Address in use</source>
          <target state="translated">使用中の住所</target>
        </trans-unit>
        <trans-unit id="a645d07371a2ce45ebb0b375f8787a4fc425584d" translate="yes" xml:space="preserve">
          <source>Address not available</source>
          <target state="translated">住所はご利用いただけません。</target>
        </trans-unit>
        <trans-unit id="f282d429f8e10c6e8f6cc685119b79f7b98f8d4a" translate="yes" xml:space="preserve">
          <source>Address of an lvalue may be taken: &lt;code&gt;&amp;amp;++i&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; are valid expressions.</source>
          <target state="translated">左辺値のアドレスを取得できます： &lt;code&gt;&amp;amp;++i&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;および &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; は有効な式です。</target>
        </trans-unit>
        <trans-unit id="1a289481f4bde8e8211ad9ffe17faa98c7f5cb4e" translate="yes" xml:space="preserve">
          <source>Address of an overload set</source>
          <target state="translated">オーバーロードセットのアドレス</target>
        </trans-unit>
        <trans-unit id="b68e9b443504394c722ff5e4129a8d602ab42051" translate="yes" xml:space="preserve">
          <source>Address of an overloaded function</source>
          <target state="translated">オーバーロードされた関数のアドレス</target>
        </trans-unit>
        <trans-unit id="50d8d3dd04846c597735fdea066d1202471e00ac" translate="yes" xml:space="preserve">
          <source>Address of an rvalue may not be taken: &lt;code&gt;&amp;amp;int()&lt;/code&gt;, &lt;code&gt;&amp;amp;i++&lt;/code&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;amp;42&lt;/code&gt;, and &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; are invalid.</source>
          <target state="translated">右辺値のアドレスは取得できません： &lt;code&gt;&amp;amp;int()&lt;/code&gt; 、 &lt;code&gt;&amp;amp;i++&lt;/code&gt; &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;、 &lt;code&gt;&amp;amp;42&lt;/code&gt; 、および &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="d8e9fb4e567ee2aa8c62d2ac99954b60bc22db70" translate="yes" xml:space="preserve">
          <source>Addressing tuples by type</source>
          <target state="translated">型によるタプルのアドレス指定</target>
        </trans-unit>
        <trans-unit id="b0ef7d67a5935e3fe8af11cd7847c8809d95a854" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the day value.</source>
          <target state="translated">日の値から1を加算または減算します。</target>
        </trans-unit>
        <trans-unit id="e43efbbed96f261cc9549f2681044676631d009f" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">月の値から1を加算または減算し、結果のモジュロ12を[1,12]の範囲の整数に減らします。</target>
        </trans-unit>
        <trans-unit id="fa3ef2c3e28e35bbf2cbd5aafea835fc3ea7a3ef" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">平日の値から1を加算または減算し、結果のmodulo 7を[0,6]の範囲の整数に減らします。</target>
        </trans-unit>
        <trans-unit id="640e675cb46fdd695967fccbbef63e0607e284a0" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the year value.</source>
          <target state="translated">年値から1を加算または減算します。</target>
        </trans-unit>
        <trans-unit id="4153c4972fd500059ef400485fdf85b87aceaa00" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; days from the day value.</source>
          <target state="translated">日の値から &lt;code&gt;d.count()&lt;/code&gt; 日を加算または減算します。</target>
        </trans-unit>
        <trans-unit id="678a7c04a10343a84658ffb12634bd9ee9456301" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">曜日の値に &lt;code&gt;d.count()&lt;/code&gt; を加算または減算して、結果をモジュロ7で[ 0、6 ]の範囲の整数に減らします。</target>
        </trans-unit>
        <trans-unit id="3230fc75b04ac3e6ea29e55230fe30dd1c203bfe" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;m.count()&lt;/code&gt; from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">月の値から &lt;code&gt;m.count()&lt;/code&gt; を加算または減算し、12を法とする結果を[ 1、12 ]の範囲の整数に減らします。</target>
        </trans-unit>
        <trans-unit id="25e4a09fe7696cac408ac8a894a8ff1b27aa44b2" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;y.count()&lt;/code&gt; years from the year value.</source>
          <target state="translated">年の値から &lt;code&gt;y.count()&lt;/code&gt; 年を加算または減算します。</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">隣接する&lt;a href=&quot;string_literal&quot;&gt;文字列リテラル&lt;/a&gt;は連結されます。</target>
        </trans-unit>
        <trans-unit id="9932bec15aa8c818ed7b8796dbd6ed7ef02aab26" translate="yes" xml:space="preserve">
          <source>Adopt the Parallelism TS for C++17</source>
          <target state="translated">C++17 の並列化 TS を採用</target>
        </trans-unit>
        <trans-unit id="03e5621c572270086c95471651dc888f07bc2da9" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;e&lt;/code&gt;'s state as if by &lt;code&gt;z&lt;/code&gt; consecutive calls to &lt;code&gt;e()&lt;/code&gt;.</source>
          <target state="translated">進歩が &lt;code&gt;e&lt;/code&gt; によって場合と同様の状態を &lt;code&gt;z&lt;/code&gt; に連続コール &lt;code&gt;e()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="135dd9fae6bf561e041334e7723bb57b90c62cf2" translate="yes" xml:space="preserve">
          <source>Advances the input sequence by one character and reads one character.</source>
          <target state="translated">入力シーケンスを1文字進めて1文字読み込みます。</target>
        </trans-unit>
        <trans-unit id="50499158101997cf6bc049268a358d31d71424e8" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result.</source>
          <target state="translated">内部状態を &lt;code&gt;z&lt;/code&gt; 回進めます。 &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;z&lt;/code&gt; 回呼び出して結果を破棄するのと同じです。</target>
        </trans-unit>
        <trans-unit id="efa9b27cb8a086b18bbe299b9e1c46a036172d58" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result. The state of the underlying engine may be advanced by more than &lt;code&gt;z&lt;/code&gt; times.</source>
          <target state="translated">内部状態を &lt;code&gt;z&lt;/code&gt; 回進めます。 &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;z&lt;/code&gt; 回呼び出して結果を破棄することと同じです。基になるエンジンの状態は、 &lt;code&gt;z&lt;/code&gt; 倍以上進んでいる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b9ef5cc9bbd2286407c3e7b628e2c0232b990d29" translate="yes" xml:space="preserve">
          <source>Advances the iterator by calling &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; where &lt;code&gt;sbuf_&lt;/code&gt; is the stored pointer to the stream buffer.</source>
          <target state="translated">呼び出すことにより、反復子を進める &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; ここで &lt;code&gt;sbuf_&lt;/code&gt; がストリームバッファに格納されたポインタです。</target>
        </trans-unit>
        <trans-unit id="141cb43c20eeabe7572fd03d0044e60b4fa23f86" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next match.</source>
          <target state="translated">次のマッチのイテレータを進めます。</target>
        </trans-unit>
        <trans-unit id="041d757eb7a9bbdbe12db3d41c780db95f87a90c" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next sub match.</source>
          <target state="translated">次のサブマッチのイテレータを進めます。</target>
        </trans-unit>
        <trans-unit id="6539ad1eea9dd55e8e95ccfb1b1a314e60e23185" translate="yes" xml:space="preserve">
          <source>Advances the iterator to the next entry. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">イテレータを次のエントリに進めます。以前の &lt;code&gt;*this&lt;/code&gt; の値のすべてのコピーを無効にします。</target>
        </trans-unit>
        <trans-unit id="78b5c8f29ae07de10df28f52834a61b1bdbbd82b" translate="yes" xml:space="preserve">
          <source>Advances the iterator.</source>
          <target state="translated">イテレータを進めます。</target>
        </trans-unit>
        <trans-unit id="207287a093e89e5bc03f0303474f506b39d8c2b3" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;erasure&lt;/b&gt;, are...</source>
          <target state="translated">&lt;b&gt;消去&lt;/b&gt;後、&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="4f0adbf879d7bad6224d512c2918e8643c30107f" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;insertion&lt;/b&gt;, are...</source>
          <target state="translated">&lt;b&gt;挿入&lt;/b&gt;後、&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="88341f67098f03a0da3cea31a839663a0bc13b2c" translate="yes" xml:space="preserve">
          <source>After a</source>
          <target state="translated">の後に</target>
        </trans-unit>
        <trans-unit id="a061077fb09465352c22016448276d1996de8a86" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; の呼び出し後、動的ストリームは自動的にフリーズします。この &lt;code&gt;ostrstream&lt;/code&gt; オブジェクトが作成されたスコープを終了する前に、 &lt;code&gt;freeze(false)&lt;/code&gt; の呼び出しが必要です。そうしないと、デストラクタがメモリをリークします。また、凍結されたストリームへの追加の出力は、割り当てられたバッファの最後に到達すると切り捨てられる場合があります。</target>
        </trans-unit>
        <trans-unit id="a539ff8b097686cd8f474897e86e0367fc84dba2" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; の呼び出し後、動的ストリームは自動的にフリーズします。この &lt;code&gt;strstream&lt;/code&gt; オブジェクトが作成されたスコープを終了する前に、 &lt;code&gt;freeze(false)&lt;/code&gt; の呼び出しが必要です。そうしないと、デストラクタがメモリをリークします。また、凍結されたストリームへの追加の出力は、割り当てられたバッファの最後に到達すると切り捨てられる場合があります。</target>
        </trans-unit>
        <trans-unit id="5eb647e196d16c21c41ab1c8527d9b7e8b2a6ba0" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; の呼び出し後、動的ストリームはフリーズします。この &lt;code&gt;ostrstream&lt;/code&gt; オブジェクトが作成されたスコープを終了する前に、 &lt;code&gt;freeze(false)&lt;/code&gt; の呼び出しが必要です。そうしないと、デストラクタがメモリをリークします。また、凍結されたストリームへの追加の出力は、割り当てられたバッファーの最後に到達すると切り捨てられる可能性があり、バッファーがnullで終了しないままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="44cdb0260695b6e760f2d33d6208f4bfff7fe216" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; の呼び出し後、動的ストリームはフリーズします。この &lt;code&gt;strstream&lt;/code&gt; オブジェクトが作成されたスコープを終了する前に、 &lt;code&gt;freeze(false)&lt;/code&gt; の呼び出しが必要です。そうしないと、デストラクタがメモリをリークします。また、凍結されたストリームへの追加の出力は、割り当てられたバッファーの最後に到達すると切り捨てられる可能性があり、バッファーがnullで終了しないままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b9daa7be1c203f1734014387e6ddd71754a92603" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true if no overflow occurred during the operation.</source>
          <target state="translated">これらの関数の1つを呼び出した後、操作中にオーバーフローが発生しなかった場合、 &lt;code&gt;ok()&lt;/code&gt; は常にtrueになります。</target>
        </trans-unit>
        <trans-unit id="85753ca571347a3ec5bab8ac7f1155da1ea5f3fa" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true.</source>
          <target state="translated">これらの関数の1つを呼び出した後、 &lt;code&gt;ok()&lt;/code&gt; は常にtrueになります。</target>
        </trans-unit>
        <trans-unit id="b0d14c1273920c43e0727fafe465d22e6d51d0cb" translate="yes" xml:space="preserve">
          <source>After all macro expansion and evaluation of &lt;code&gt;defined&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) expressions, any identifier which is not a &lt;a href=&quot;../language/bool_literal&quot;&gt;boolean literal&lt;/a&gt; is replaced with the number &lt;code&gt;​0​&lt;/code&gt; (this includes identifiers that are lexically keywords, but not alternative tokens like &lt;code&gt;and&lt;/code&gt;).</source>
          <target state="translated">すべてのマクロ展開と評価の後 &lt;code&gt;defined&lt;/code&gt; と &lt;code&gt;__has_include&lt;/code&gt; （C ++ 17以降）式でない任意の識別子&lt;a href=&quot;../language/bool_literal&quot;&gt;のブールリテラルは&lt;/a&gt;数に置き換えられ &lt;code&gt;​0​&lt;/code&gt; （これは字句キーワードである識別子ではなく、等の代替トークンを含み、 &lt;code&gt;and&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b09013ce3cd67396c7277e3bcafa2ffe1562348b" translate="yes" xml:space="preserve">
          <source>After all static initialization is completed, dynamic initialization of non-local variables occurs in the following situations:</source>
          <target state="translated">すべての静的な初期化が完了した後、非ローカル変数の動的な初期化は以下のような状況で発生します。</target>
        </trans-unit>
        <trans-unit id="35dd559617a4f18a5460a7d2ed6280a6a78170b4" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt; on a stream with a dynamic buffer, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the &lt;code&gt;strstreambuf&lt;/code&gt; destructor to deallocate the buffer when necessary.</source>
          <target state="translated">動的バッファを使用したスト​​リームで &lt;code&gt;str()&lt;/code&gt; を呼び出した後、 &lt;code&gt;strstreambuf&lt;/code&gt; デストラクタが必要に応じてバッファの割り当てを解除できるように、 &lt;code&gt;freeze(false)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="1bff9fbc15a1512d56427c0bac69b8131756695d" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt;, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the destructor to deallocate the buffer as necessary.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; を呼び出した後、必要に応じてデストラクタがバッファの割り当てを解除できるように、 &lt;code&gt;freeze(false)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a783411c667be5aeca25a2e7d260e7d91749c14d" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;detach&lt;/code&gt;&lt;code&gt;*this&lt;/code&gt; no longer owns any thread.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; を呼び出した後、 &lt;code&gt;*this&lt;/code&gt; はもはやスレッドを所有していません。</target>
        </trans-unit>
        <trans-unit id="d81c3a85f42719a311033e306e37b8e8b9fb3c51" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;share&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;share&lt;/code&gt; を呼び出した後、&lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a56377919a429bed8801b85b079d1d09d9b97f" translate="yes" xml:space="preserve">
          <source>After calling the rvalue overloads (2,4,6,8), &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.get() == nullptr&lt;/code&gt;, except that &lt;code&gt;r&lt;/code&gt; is not modified for &lt;code&gt;dynamic_pointer_cast&lt;/code&gt;(4) if the &lt;code&gt;dynamic_cast&lt;/code&gt; fails.</source>
          <target state="translated">rvalueオーバーロード（2,4,6,8）を呼び出した後、 &lt;code&gt;r&lt;/code&gt; は空で &lt;code&gt;r.get() == nullptr&lt;/code&gt; 。ただし、 &lt;code&gt;dynamic_cast&lt;/code&gt; が失敗した場合、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; （4）に対して変更されません。</target>
        </trans-unit>
        <trans-unit id="a43ab890db9a9d7fd099d5804cec46453734ffa7" translate="yes" xml:space="preserve">
          <source>After considering every P and A in both directions, if, for each type that was considered,</source>
          <target state="translated">両方向のすべてのPとAを考慮した後、もし、考慮された各タイプについて</target>
        </trans-unit>
        <trans-unit id="cde16484b3a6dce1a5a73f1d71d4d5f94eda1f7f" translate="yes" xml:space="preserve">
          <source>After container move assignment (overload (2)), unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">コンテナの移動の割り当て後（過負荷（2））、要素ごと移動割り当ては、互換性のないアロケータ、参照、ポインタ、およびへのイテレータ（エンドイテレータ以外）によって強制されない限り、 &lt;code&gt;other&lt;/code&gt; 有効なままですが、中に今ある要素を参照してください &lt;code&gt;*this&lt;/code&gt; 。現在の標準では、&amp;sect;23.2.1[container.requirements.general] / 12の包括的ステートメントを介してこの保証が行われており、&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321を&lt;/a&gt;介してより直接的な保証が検討されています。</target>
        </trans-unit>
        <trans-unit id="1efd3ba5fab7d922cddedab135cbf68623f0fbb3" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (4)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">コンテナの移動工事（オーバーロード（4））した後、への参照、ポインタ、および（終了イテレータを除く）イテレータ &lt;code&gt;other&lt;/code&gt; 有効なままですが、今にしている要素を参照してください &lt;code&gt;*this&lt;/code&gt; 。現在の標準では、&amp;sect;23.2.1[container.requirements.general] / 12の包括的ステートメントを介してこの保証が行われており、&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321を&lt;/a&gt;介してより直接的な保証が検討されています。</target>
        </trans-unit>
        <trans-unit id="eaca101a515420f6158015d9049a7c61e1020372" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">コンテナーの移動構築（オーバーロード（6））の後、他への参照、ポインター、およびイテレーター（終了イテレーター &lt;code&gt;other&lt;/code&gt; は有効なままですが、現在 &lt;code&gt;*this&lt;/code&gt; にある要素を参照します。現在の標準では、&amp;sect;23.2.1[container.requirements.general] / 12の包括的ステートメントを介してこの保証が行われており、&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321を&lt;/a&gt;介してより直接的な保証が検討されています。</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">&lt;code&gt;#error&lt;/code&gt; ディレクティブに遭遇した後、実装は診断メッセージerror_messageを表示し、プログラムを不正な形式にします（コンパイルは停止します）。</target>
        </trans-unit>
        <trans-unit id="1d2d75b0b4cf172aa9246ff178f69aced36a5e9c" translate="yes" xml:space="preserve">
          <source>After evaluating &lt;code&gt;lhs = rhs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;lhs = rhs&lt;/code&gt; 評価した後：</target>
        </trans-unit>
        <trans-unit id="45a5bba2318081758d338e6bc0ad55114ce64350" translate="yes" xml:space="preserve">
          <source>After one of the two templates was transformed as described above, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.</source>
          <target state="translated">2つのテンプレートの一方が上記のように変換された後、変換された&lt;a href=&quot;template_argument_deduction&quot;&gt;テンプレートを引数&lt;/a&gt;テンプレートとして使用し、もう一方のテンプレートの元のテンプレートタイプをパラメーターテンプレートとして使用して、テンプレート引数の推定が実行されます。次に、変換として2番目のテンプレートを引数として使用し、最初のテンプレートを元の形式でパラメーターとして使用して、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">ワイドストリーム内の非終端位置を求めた後、任意の出力関数への次の呼び出しは、例えば、異なる長さのマルチバイトシーケンスを出力することによって、ファイルの残りの部分を未定義にすることができる。</target>
        </trans-unit>
        <trans-unit id="6723da668a7284d1e0d9c856af9a4e60e17d6599" translate="yes" xml:space="preserve">
          <source>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular &lt;a href=&quot;function#Function_declaration&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">置換後、配列と関数タイプのすべての関数パラメーターがポインターに調整され、すべてのトップレベルのcv修飾子が（通常の&lt;a href=&quot;function#Function_declaration&quot;&gt;関数宣言のように&lt;/a&gt;）関数パラメーターから削除されます。</target>
        </trans-unit>
        <trans-unit id="799039415462a10354f545fe871b500eacc988ea" translate="yes" xml:space="preserve">
          <source>After that, whether or not an exception was thrown by any destructor, the delete expression invokes the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt;: either &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (for the first version of the expression) or &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (for the second version of the expression), unless the matching new-expression was combined with another new-expression(since C++14).</source>
          <target state="translated">その後、例外が任意デストラクタによってスローされたか否か、削除発現が呼び出し&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;解放機能&lt;/a&gt;：いずれかの &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; または（第1の表現のバージョンの） &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; （式の第2のバージョンのため）、場合を除き一致するnew-expressionが別のnew-expressionと結合されました（C ++ 14以降）。</target>
        </trans-unit>
        <trans-unit id="e0b82e4b58314156b84c6c073fedd13df3c06173" translate="yes" xml:space="preserve">
          <source>After the associated set of classes and namespaces is determined, all declarations found in classes of this set are discarded for the purpose of further ADL processing, except namespace-scoped friend functions and function templates, as stated in point 2 below .</source>
          <target state="translated">関連するクラスとネームスペースのセットが決定された後、このセットのクラスで見つかったすべての宣言は、以下のポイント2で述べられているように、ネームスペース・スコープされたフレンド関数と関数テンプレートを除いて、更なるADL処理の目的のために破棄されます。</target>
        </trans-unit>
        <trans-unit id="a30be8c196cfecdbad0fc0881a76a52f9af12d23" translate="yes" xml:space="preserve">
          <source>After the call &lt;code&gt;getloc() == loc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getloc() == loc&lt;/code&gt; 呼び出し後。</target>
        </trans-unit>
        <trans-unit id="5b157835cfa6ec4fc0f1fce8dc684fe4a88600d3" translate="yes" xml:space="preserve">
          <source>After the call, the value of &lt;code&gt;t&lt;/code&gt; is the value held by &lt;code&gt;u&lt;/code&gt; before the call, and the value of &lt;code&gt;u&lt;/code&gt; is the value held by &lt;code&gt;t&lt;/code&gt; before the call.</source>
          <target state="translated">呼び出し後の値 &lt;code&gt;t&lt;/code&gt; が保持する値である &lt;code&gt;u&lt;/code&gt; 呼び出しの前、との値 &lt;code&gt;u&lt;/code&gt; が保持する値であり、 &lt;code&gt;t&lt;/code&gt; 呼び出しの前。</target>
        </trans-unit>
        <trans-unit id="4cd3511e0d8d14569c23c73c7b91dc33ab8e711e" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = rv;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;u2&lt;/code&gt;;</source>
          <target state="translated">定義後 &lt;code&gt;T u = rv;&lt;/code&gt; 、 &lt;code&gt;u&lt;/code&gt; は &lt;code&gt;u2&lt;/code&gt; に等しい。</target>
        </trans-unit>
        <trans-unit id="3d30d64981287500c819b1f90ccbf12490e9f92c" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = v;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;v&lt;/code&gt;;</source>
          <target state="translated">定義後 &lt;code&gt;T u = v;&lt;/code&gt; 、 &lt;code&gt;u&lt;/code&gt; は &lt;code&gt;v&lt;/code&gt; に等しい。</target>
        </trans-unit>
        <trans-unit id="0c6c90fd32023a18a6a7da6b1f777294338454a9" translate="yes" xml:space="preserve">
          <source>After the destruction, the smart pointers that shared ownership with &lt;code&gt;*this&lt;/code&gt;, if any, will report a &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; that is one less than its previous value.</source>
          <target state="translated">破棄後、所有権を &lt;code&gt;*this&lt;/code&gt; と共有したスマートポインタは、存在する場合、以前の値より1つ少ない &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; を報告します。</target>
        </trans-unit>
        <trans-unit id="d2d0310f3096791666afb21ddf68713192d5f5d5" translate="yes" xml:space="preserve">
          <source>After the error condition is reported by a function, additional guarantees may be provided with regards to the state of the program. The following four levels of exception guarantee are generally recognized&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;, which are strict supersets of each other:</source>
          <target state="translated">関数によってエラー状態が報告された後、プログラムの状態に関して追加の保証が提供される場合があります。以下の4つのレベルの例外保証が一般的に認識されています&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;。これらは互いに厳密なスーパーセットです。</target>
        </trans-unit>
        <trans-unit id="5b29961c177bd98d620f93782ce1efd7215c74a8" translate="yes" xml:space="preserve">
          <source>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</source>
          <target state="translated">標準ライブラリの deallocation 関数が戻ると、deallocated されたストレージの任意の部分を参照するすべてのポインタは無効になります。</target>
        </trans-unit>
        <trans-unit id="d0f96cdce258dfc61390cebc0e99878ba570d5a1" translate="yes" xml:space="preserve">
          <source>After these adjustments, deduction of &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; is done following &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;template argument deduction from a type&lt;/a&gt;.</source>
          <target state="translated">これらの調整後、 &lt;code&gt;A&lt;/code&gt; からの &lt;code&gt;P&lt;/code&gt; の&lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;演繹は、型からのテンプレート引数の演繹&lt;/a&gt;に従って行われます。</target>
        </trans-unit>
        <trans-unit id="2d3d82b04f2207d9d6bcf7a9bbc105dd774ee13b" translate="yes" xml:space="preserve">
          <source>After these transformations, the deduction processes as described below (cf. section &quot;Deduction from type&quot;) and attempts to find such template arguments that would make the deduced &lt;code&gt;A&lt;/code&gt; (that is, &lt;code&gt;P&lt;/code&gt; after adjustments listed above and the substitution of the deduced template parameters) identical to the</source>
          <target state="translated">これらの変換の後、演繹は以下に説明するように処理され（セクション「型からの演繹」を参照）、演繹された &lt;code&gt;A&lt;/code&gt; （つまり、上記の調整と演繹されたテンプレートパラメーターの置換後の &lt;code&gt;P&lt;/code&gt; ）を作成するようなテンプレート引数を見つけようとします。 ）と同じ</target>
        </trans-unit>
        <trans-unit id="cbfa05ba4a64164c2c06108c94e66a0d15618966" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;other&lt;/code&gt; has no associated mutex.</source>
          <target state="translated">この呼び出しの後、 &lt;code&gt;other&lt;/code&gt; には関連するmutexがありません。</target>
        </trans-unit>
        <trans-unit id="09e6d08a70617f303ffde1bea6a795b13dc7771a" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; is equal to the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the call, and &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">この呼び出し後、 &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; の値に等しい &lt;code&gt;other.get_id()&lt;/code&gt; 呼び出しの前に、及び &lt;code&gt;other&lt;/code&gt; もはや実行のスレッドを表します。</target>
        </trans-unit>
        <trans-unit id="8c87604fd723b0f75058b0139b052da68fd8a53e" translate="yes" xml:space="preserve">
          <source>After this function completes, &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">この関数が完了すると、&lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="af11ceb4dfc69bc2e19a600385c6a2e921b44982" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be dereferenceable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">この操作の後に &lt;code&gt;r&lt;/code&gt; dereferenceableである必要はなく、以前の値のコピー &lt;code&gt;r&lt;/code&gt; もはやdereferenceable又はincrementableことが必要とされません。</target>
        </trans-unit>
        <trans-unit id="d6b3e4110c978c6c966e175d0fb21c24d0cb55b2" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be incrementable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">この操作の後、 &lt;code&gt;r&lt;/code&gt; は増分可能である必要はなく、以前の &lt;code&gt;r&lt;/code&gt; の値のコピーは逆参照可能または増分可能である必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="5cb3c3ab15a7948ac9776fc01389be53890f7bf1" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement immediately following the enclosing loop or switch. As with any block exit, all automatic storage objects declared in enclosing compound statement or in the condition of a loop/switch are destroyed, in reverse order of construction, before the execution of the first line following the enclosing loop.</source>
          <target state="translated">この文の後、制御は、囲い込みループまたはスイッチの直後の文に転送されます。任意のブロック終了と同様に、囲い込み複合文やループ/スイッチの条件で宣言されたすべての自動格納オブジェクトは、囲い込みループに続く最初の行が実行される前に、構造の逆順に破棄されます。</target>
        </trans-unit>
        <trans-unit id="fd175daec3ba5a5ff832d7613dfb6df9054a3994" translate="yes" xml:space="preserve">
          <source>After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">この後、数字のグループ化がチェックされます。ステージ2で破棄された桁区切り記号のいずれかの位置が、 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; によって提供されるグループ化と一致しない場合： ：failbitが &lt;code&gt;err&lt;/code&gt; に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="7d93b73971332d0c3efd8634484908552ab34c9a" translate="yes" xml:space="preserve">
          <source>Afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">その後、 &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;nullptr&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="795da143b5dbe81dcf8c6232ccf436d09b14c393" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
          <target state="translated">集計の初期化</target>
        </trans-unit>
        <trans-unit id="32f6926454c3165c26d9dc05c16b8b6e9f95c8bb" translate="yes" xml:space="preserve">
          <source>Aggregate initialization initializes</source>
          <target state="translated">集計初期化は</target>
        </trans-unit>
        <trans-unit id="ce0cf7c09d177b646d6d216478f49a68396c308c" translate="yes" xml:space="preserve">
          <source>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</source>
          <target state="translated">アグレゲートは、同じ型の単一要素の中括弧付き初期化リストから直接初期化をコピー/移動しますが、非アグレゲートは最初に initializer_list コンストラクタを考慮します。</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="e8a0f2b8083d5e86992465667615250c3f737a35" translate="yes" xml:space="preserve">
          <source>Algorithm concepts and utilities</source>
          <target state="translated">アルゴリズムの概念とユーティリティ</target>
        </trans-unit>
        <trans-unit id="b03f71c0b2a6d1e175830b00066b005660a7079a" translate="yes" xml:space="preserve">
          <source>Algorithm utilities</source>
          <target state="translated">アルゴリズムユーティリティ</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="6886e87f506cf00f362a34227ad744fd6fcd6652" translate="yes" xml:space="preserve">
          <source>Algorithms library</source>
          <target state="translated">アルゴリズムライブラリ</target>
        </trans-unit>
        <trans-unit id="b1d4c8b0854335cb6dc181f5d361a3a9a6c77f1d" translate="yes" xml:space="preserve">
          <source>Algorithms that operate on ranges</source>
          <target state="translated">範囲で動作するアルゴリズム</target>
        </trans-unit>
        <trans-unit id="8d55ef673ad6d9815c8fe83971681410e8111110" translate="yes" xml:space="preserve">
          <source>Alias declarations are &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; with the following syntax:</source>
          <target state="translated">エイリアス宣言は、次の構文の&lt;a href=&quot;declarations&quot;&gt;宣言&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ac7adb6d456a732926b16ac92fea1efb425fa68c" translate="yes" xml:space="preserve">
          <source>Alias template is a name that refers to a family of types.</source>
          <target state="translated">エイリアステンプレートとは、型のファミリーを参照する名前です。</target>
        </trans-unit>
        <trans-unit id="536ee4b3a1593a51e4e7a02e531109ebfa1e7aa5" translate="yes" xml:space="preserve">
          <source>Alias templates</source>
          <target state="translated">テンプレートエイリアス</target>
        </trans-unit>
        <trans-unit id="81fdfe39ee9314fa8adbdd24c8cefa9e67062042" translate="yes" xml:space="preserve">
          <source>Alias templates are never deduced by &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; when deducing a template template parameter.  It is not possible to &lt;a href=&quot;partial_specialization&quot;&gt;partially&lt;/a&gt; or &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialize&lt;/a&gt; an alias template.</source>
          <target state="translated">テンプレートテンプレートパラメーターを推定するときに、エイリアステンプレートが&lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;テンプレート引数の&lt;/a&gt;推定によって推定されることはありません。エイリアステンプレートを&lt;a href=&quot;partial_specialization&quot;&gt;部分的&lt;/a&gt;または&lt;a href=&quot;template_specialization&quot;&gt;明示的に特化&lt;/a&gt;することはできません。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a2aba61989bb9dc7a1e9fe034611bf7295de52c9" translate="yes" xml:space="preserve">
          <source>Alignment (as obtained by &lt;code&gt;alignof&lt;/code&gt;) has the type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, but placement forms of allocation and deallocation functions that take &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; as an additional parameter are already in use, so this type is used instead.</source>
          <target state="translated">アラインメント（ &lt;code&gt;alignof&lt;/code&gt; によって取得される）のタイプは &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ですが、 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; を追加パラメーターとして取る割り当ておよび割り当て解除関数の配置形式がすでに使用されているため、代わりにこのタイプが使用されます。</target>
        </trans-unit>
        <trans-unit id="1284e78e088763e07d38bdc498c7ac19fcd9faaa" translate="yes" xml:space="preserve">
          <source>Alignment specifier</source>
          <target state="translated">アライメント指定子</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c533be78046b2b7438a7f5af4856db7635ad0dde" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../container&quot;&gt;standard library containers&lt;/a&gt; require that their element type satisfies Erasable.</source>
          <target state="translated">すべての&lt;a href=&quot;../container&quot;&gt;標準ライブラリコンテナで&lt;/a&gt;は、その要素タイプが消去可能を満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="ad583fce81393d0c4c343ed80041c1cf855fb389" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;pointers to functions&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">&lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;関数への&lt;/a&gt;すべてのポインタはこの要件を満たします。</target>
        </trans-unit>
        <trans-unit id="85e52ab157feeaab3392116ff6342f562d88a7b4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;objects&quot;&gt;objects&lt;/a&gt; in a program have one of the following storage durations:</source>
          <target state="translated">プログラム内のすべての&lt;a href=&quot;objects&quot;&gt;オブジェクト&lt;/a&gt;には、次のいずれかの保存期間があります。</target>
        </trans-unit>
        <trans-unit id="2be019deb6ca8794e180ab1025f12fa6403846db" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">すべての&lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt;はこの要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="5586b0fcd654b42e2d7df9c2c898d38125873577" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions can be called concurrently by different threads on the same container. In addition, the member functions &lt;code&gt;begin()&lt;/code&gt;, &lt;code&gt;end()&lt;/code&gt;, &lt;code&gt;rbegin()&lt;/code&gt;, &lt;code&gt;rend()&lt;/code&gt;, &lt;code&gt;front()&lt;/code&gt;, &lt;code&gt;back()&lt;/code&gt;, &lt;code&gt;data()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;lower_bound()&lt;/code&gt;, &lt;code&gt;upper_bound()&lt;/code&gt;, &lt;code&gt;equal_range()&lt;/code&gt;, &lt;code&gt;at()&lt;/code&gt;, and, except in associative containers, &lt;code&gt;operator[]&lt;/code&gt;, behave as &lt;code&gt;const&lt;/code&gt; for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.</source>
          <target state="translated">すべての &lt;code&gt;const&lt;/code&gt; メンバー関数は、同じコンテナー上の異なるスレッドによって同時に呼び出すことができます。さらに、メンバー関数 &lt;code&gt;begin()&lt;/code&gt; 、 &lt;code&gt;end()&lt;/code&gt; 、 &lt;code&gt;rbegin()&lt;/code&gt; 、 &lt;code&gt;rend()&lt;/code&gt; 、 &lt;code&gt;front()&lt;/code&gt; 、 &lt;code&gt;back()&lt;/code&gt; 、 &lt;code&gt;data()&lt;/code&gt; 、 &lt;code&gt;find()&lt;/code&gt; 、 &lt;code&gt;lower_bound()&lt;/code&gt; 、 &lt;code&gt;upper_bound()&lt;/code&gt; 、 &lt;code&gt;equal_range()&lt;/code&gt; 、 &lt;code&gt;at()&lt;/code&gt; 、および連想コンテナを除く &lt;code&gt;operator[]&lt;/code&gt; 、 &lt;code&gt;const&lt;/code&gt; として動作します。スレッドセーフのために（つまり、同じコンテナー上の異なるスレッドから同時に呼び出すこともできます）。より一般的には、C ++標準ライブラリ関数は、thisポインターを含む関数の非const引数を介して直接または間接的にアクセスできない限り、オブジェクトを変更しません。</target>
        </trans-unit>
        <trans-unit id="4ce574fe03a26ad67fb18ae15f6d204f756c8e28" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; are provided.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; すべての &lt;code&gt;const&lt;/code&gt; メンバー関数が提供されます。</target>
        </trans-unit>
        <trans-unit id="e4c5afaf4fff1d58306c2cfe530397e8446742a3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;emit()&lt;/code&gt; calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each &lt;code&gt;emit()&lt;/code&gt; call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;synchronizes-with&lt;/a&gt; subsequent &lt;code&gt;emit()&lt;/code&gt; calls in that total order, even if these calls are made through difference instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;/&lt;code&gt;std::basic_osyncstream&lt;/code&gt;. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.</source>
          <target state="translated">同じラップされたストリームバッファオブジェクトに文字を転送 &lt;code&gt;emit()&lt;/code&gt; すべてのemit（）呼び出しは、合計の順序で実行されているように見えます。各 &lt;code&gt;emit()&lt;/code&gt; 呼び出しは、これらの呼び出しが異なるインスタンスを介して行われた場合でも、その合計の順序&lt;a href=&quot;../../atomic/memory_order&quot;&gt;で&lt;/a&gt;後続の &lt;code&gt;emit()&lt;/code&gt; 呼び出しと同期します。の &lt;code&gt;std::basic_syncbuf&lt;/code&gt; / &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 。実際には、これは、emit（）がラップされたストリームオブジェクトに一意に関連付けられたロックを取得することを意味します。たとえば、ラップされたストリームのアドレスがキーとして使用される静的ハッシュマップに保持することができます。</target>
        </trans-unit>
        <trans-unit id="08e7989631f4fa0b7b123c5eceab25241a651d43" translate="yes" xml:space="preserve">
          <source>All Function objects defined in &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; で&lt;/a&gt;定義されているすべてのFunctionオブジェクト</target>
        </trans-unit>
        <trans-unit id="267678e718109eec99ac63d1e0c78b1e78e6bc72" translate="yes" xml:space="preserve">
          <source>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</source>
          <target state="translated">すべての算術演算子は、特定の算術演算の結果を計算し、その結果を返します。引数は変更されません。</target>
        </trans-unit>
        <trans-unit id="2196ca16119493aee11e0e86a9a7193062fd552b" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; を除くすべてのアトミック型は、ロックフリーのアトミックCPU命令を使用するのではなく、ミューテックスまたは他のロック操作を使用して実装できます。原子タイプも許可されます</target>
        </trans-unit>
        <trans-unit id="acf874c1ced8a0f3cff5567518c467d553d7b81d" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; を除くすべてのアトミック型は、ロックフリーのアトミックCPU命令を使用するのではなく、ミューテックスまたは他のロック操作を使用して実装できます。原子タイプも許可されます</target>
        </trans-unit>
        <trans-unit id="1c6a82095fc35876e8565ece289c3317d10e940b" translate="yes" xml:space="preserve">
          <source>All built-in assignment operators return &lt;code&gt;*this&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;*this&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">すべての組み込み代入演算子は &lt;code&gt;*this&lt;/code&gt; を返し、ほとんどの&lt;a href=&quot;operators&quot;&gt;ユーザー定義のオーバーロード&lt;/a&gt;も &lt;code&gt;*this&lt;/code&gt; を返すため、ユーザー定義演算子を組み込みと同じように使用できます。ただし、ユーザー定義の演算子オーバーロードでは、任意の型を戻り型として使用できます（ &lt;code&gt;void&lt;/code&gt; を含む）。</target>
        </trans-unit>
        <trans-unit id="1e3f7702614f1e201b0d2d7ca9cab6129fd842e0" translate="yes" xml:space="preserve">
          <source>All built-in operators return &lt;code&gt;bool&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">すべての組み込み演算子は &lt;code&gt;bool&lt;/code&gt; を返し、ほとんどの&lt;a href=&quot;operators&quot;&gt;ユーザー定義のオーバーロード&lt;/a&gt;も &lt;code&gt;bool&lt;/code&gt; を返すため、ユーザー定義演算子を組み込みと同じように使用できます。ただし、ユーザー定義の演算子オーバーロードでは、任意の型を戻り値の型（ &lt;code&gt;void&lt;/code&gt; を含む）として使用できます。</target>
        </trans-unit>
        <trans-unit id="ad44cda1026b661b30b82e23a1cc8e4adc8dad82" translate="yes" xml:space="preserve">
          <source>All built-in operators return values, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). In particular, stream insertion and stream extraction overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; return &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">すべての組み込み演算子は値を返し、ほとんどの&lt;a href=&quot;operators&quot;&gt;ユーザー定義のオーバーロード&lt;/a&gt;も値を返すため、ユーザー定義演算子を組み込みと同じように使用できます。ただし、ユーザー定義の演算子オーバーロードでは、任意の型を戻り値の型（ &lt;code&gt;void&lt;/code&gt; を含む）として使用できます。特に、 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; および &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ストリーム挿入およびストリーム抽出オーバーロードは &lt;code&gt;T&amp;amp;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">すべてのコメントは、各コメントを単一の空白文字で置き換えることにより、&lt;a href=&quot;language/translation_phases&quot;&gt;翻訳フェーズ3で&lt;/a&gt;プログラムから削除されます。</target>
        </trans-unit>
        <trans-unit id="bf78ad8fede01661fec9052125328b1508f2f4d8" translate="yes" xml:space="preserve">
          <source>All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.</source>
          <target state="translated">すべての比較演算子は短絡されており、比較結果を決定するために必要な範囲を超えてタプル要素にアクセスすることはありません。</target>
        </trans-unit>
        <trans-unit id="d086b64161b8d9aca02f8348f6309d2102ee1278" translate="yes" xml:space="preserve">
          <source>All comparisons are done via the &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; member function (which itself is defined in terms of &lt;code&gt;Traits::compare()&lt;/code&gt;):</source>
          <target state="translated">すべての比較は、 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; メンバー関数（それ自体が &lt;code&gt;Traits::compare()&lt;/code&gt; で定義されている）を介して行われます。</target>
        </trans-unit>
        <trans-unit id="b8289f337cbc9bd64fef53be2978b84bf37ef44f" translate="yes" xml:space="preserve">
          <source>All constants, except for &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt;, are bitmask elements. The &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt; constants are empty bitmasks.</source>
          <target state="translated">&lt;code&gt;match_default&lt;/code&gt; と &lt;code&gt;format_default&lt;/code&gt; を除くすべての定数はビットマスク要素です。 &lt;code&gt;match_default&lt;/code&gt; と &lt;code&gt;format_default&lt;/code&gt; 定数は、空のビットマスクです。</target>
        </trans-unit>
        <trans-unit id="dc168f2bceb154961bb7ed9909031e74d78d43a5" translate="yes" xml:space="preserve">
          <source>All constructors that take &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; against a single argument of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; を唯一の引数として、または残りの引数にデフォルト値がある場合は最初の引数として取るすべてのコンストラクターが検査され、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;によって型 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 単一の引数と照合されます</target>
        </trans-unit>
        <trans-unit id="2bcfde28187d671e9cbf776fb85caf9d73bb4df9" translate="yes" xml:space="preserve">
          <source>All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</source>
          <target state="translated">すべてのコンテナ関数は、異なるコンテナ上の異なるスレッドから同時に呼び出すことができます。より一般的には、C++標準ライブラリ関数は、他のスレッドからアクセス可能なオブジェクトを読み取ることはありませんが、そのオブジェクトがこのポインタを含む関数引数を介して直接または間接的にアクセス可能である場合を除きます。</target>
        </trans-unit>
        <trans-unit id="36bd3ae32477cc666c63b1b73c2d5eb0bca71c31" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、および &lt;code&gt;n&lt;/code&gt; 以外のすべての変換指定子は、入力の解析を試みる前に、先頭の空白文字（&lt;a href=&quot;../../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;を呼び出した場合と同じように判別）をすべて消費して破棄します。これらの消費された文字は、指定された最大フィールド幅にカウントされません。</target>
        </trans-unit>
        <trans-unit id="a2b014357acb5001a9291cf56269f10b96493516" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、および &lt;code&gt;n&lt;/code&gt; 以外のすべての変換指定子は、入力の解析を試みる前に、先頭の空白文字（&lt;a href=&quot;../../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt;を呼び出した場合と同様に決定）をすべて消費して破棄します。これらの消費された文字は、指定された最大フィールド幅にカウントされません。</target>
        </trans-unit>
        <trans-unit id="cbea028682ce84815358b5aa6eda3b614cfe993e" translate="yes" xml:space="preserve">
          <source>All custom allocators also must be stateless.</source>
          <target state="translated">すべてのカスタムアロケータもステートレスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e99bcc0ededa138f077034c407c38f0bfa9cb54b" translate="yes" xml:space="preserve">
          <source>All deallocation functions are &lt;code&gt;noexcept(true)&lt;/code&gt; unless specified otherwise in the declaration.</source>
          <target state="translated">宣言で特に指定されていない限り、すべての割り当て解除関数は &lt;code&gt;noexcept(true)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7590e38178794abe168d1f61e5e605ebedab40ca" translate="yes" xml:space="preserve">
          <source>All direct base classes have trivial destructors</source>
          <target state="translated">すべての直接基底クラスには、トリビアルなデストラクタがあります。</target>
        </trans-unit>
        <trans-unit id="d1644548c66e07081be823b1a24493d9cfc6d493" translate="yes" xml:space="preserve">
          <source>All error codes are distinct and non-zero.</source>
          <target state="translated">すべてのエラーコードは明確でゼロではありません。</target>
        </trans-unit>
        <trans-unit id="4eb9393603f7bb0528b986591eb39bc9de40a1c4" translate="yes" xml:space="preserve">
          <source>All evaluations of &lt;code&gt;h(k)&lt;/code&gt;executed within a given execution of a program(since C++14) yield the same result for the same value of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">プログラムの特定の実行内で実行された &lt;code&gt;h(k)&lt;/code&gt; のすべての評価（C ++ 14以降）は、同じ &lt;code&gt;k&lt;/code&gt; の値に対して同じ結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="615556c95cd2277e3f2551bbe6ac5d7b7503c6b8" translate="yes" xml:space="preserve">
          <source>All exceptions generated by the standard library inherit from &lt;code&gt;std::exception&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリによって生成されるすべての例外は、 &lt;code&gt;std::exception&lt;/code&gt; から継承されます。</target>
        </trans-unit>
        <trans-unit id="47496370c3026a6d2335b4c07d2899c2bfd0a9f8" translate="yes" xml:space="preserve">
          <source>All existing elements of &lt;code&gt;a&lt;/code&gt; are either move assigned to or destroyed; &lt;code&gt;a&lt;/code&gt; is equal to the value that &lt;code&gt;rv&lt;/code&gt; had before the assignment</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の既存の要素はすべて、移動割り当てまたは破棄されます。 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;rv&lt;/code&gt; が割り当て前に持っていた値に等しい</target>
        </trans-unit>
        <trans-unit id="9b1c1c57702fcbfb1474e82ce403b1688060d643" translate="yes" xml:space="preserve">
          <source>All explicit and partial specializations of &lt;code&gt;hash&lt;/code&gt; provided by the standard library are &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;. User-provided specializations of &lt;code&gt;hash&lt;/code&gt; also must meet those requirements.</source>
          <target state="translated">すべての明示的および部分的な特殊 &lt;code&gt;hash&lt;/code&gt; 標準ライブラリで提供されているが&lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;、&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;、&lt;a href=&quot;../named_req/swappable&quot;&gt;スワップ&lt;/a&gt;および&lt;a href=&quot;../named_req/destructible&quot;&gt;破壊可能&lt;/a&gt;。ユーザーが提供する &lt;code&gt;hash&lt;/code&gt; 特殊化も、これらの要件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="d3caef46757d5c781ce31db0ab1b1d011a7c9448" translate="yes" xml:space="preserve">
          <source>All functions accepting an argument of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;end2&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt;(since C++11) should also accept the replacement type.</source>
          <target state="translated">型 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 引数を受け入れるすべての関数（C ++ 11以降&lt;a href=&quot;end2&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;begin2&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt;およびend（）を除いて、置換型も受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="0179673daad25aa9537982f33e1688378d0b8b34" translate="yes" xml:space="preserve">
          <source>All functions accepting two arguments of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; should accept every combination of &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; and the replacement type.</source>
          <target state="translated">&lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 型の2つの引数を受け入れるすべての関数は、 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; と置換型のすべての組み合わせを受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="c84866185eebd1e3d3c0bd203de655735b81b728" translate="yes" xml:space="preserve">
          <source>All functions from &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;の&lt;/a&gt;すべての関数</target>
        </trans-unit>
        <trans-unit id="eacdccc0ff89286560bd5447dd6d3e5754738868" translate="yes" xml:space="preserve">
          <source>All implicitly-captured variables must be declared within the</source>
          <target state="translated">すべての暗黙的に捕捉された変数は</target>
        </trans-unit>
        <trans-unit id="ee4038fb61cddc0d5aee00559af689e67143f4cb" translate="yes" xml:space="preserve">
          <source>All implicitly-declared member functions (and inheriting constructors) have exception specifications, selected as follows:</source>
          <target state="translated">暗黙的に宣言されたすべてのメンバ関数(および継承コンストラクタ)には例外指定があり、以下のように選択されています。</target>
        </trans-unit>
        <trans-unit id="73a8920376f49ed06b9320f4b183b14d1b56c59a" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;std::monostate&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;std::monostate&lt;/code&gt; すべてのインスタンスは等しいと比較します。</target>
        </trans-unit>
        <trans-unit id="6f36973910215a95c48be1c361c474c6abda5dfd" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</source>
          <target state="translated">消去された要素がコンテナの末尾または先頭にある場合を除き、すべてのイテレータと参照は無効となり、その場合は消去された要素のイテレータと参照のみが無効となります。</target>
        </trans-unit>
        <trans-unit id="3ff58822fed4cebf575b53176b537d16617bfe40" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated. Past-the-end iterator is also invalidated.</source>
          <target state="translated">すべてのイテレータと参照が無効になります。過去終了イテレータも無効です。</target>
        </trans-unit>
        <trans-unit id="b6bfeb63a7689b81c8714600b9a0261d56188882" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation.</source>
          <target state="translated">すべてのイテレータと参照は有効なままです。このコンテナ内の過去の終了値を保持するイテレータが、操作後にこのコンテナを参照するのか、他のコンテナを参照するのかは不定です。</target>
        </trans-unit>
        <trans-unit id="c94adb4871f7b21a7fe1f80a6cb316845a106fd2" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. The past-the-end iterator is invalidated.</source>
          <target state="translated">すべてのイテレータと参照は有効なままです。過去終了イテレータは無効になります。</target>
        </trans-unit>
        <trans-unit id="ca555a6b3c340c88a2973a4408368f43f4dc4831" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.</source>
          <target state="translated">過去終了イテレータを含むすべてのイテレータは無効です。参照は無効になりません。</target>
        </trans-unit>
        <trans-unit id="cf1ebdb0694902a0ff8fae76c426f9dc6a20dead" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless &lt;code&gt;pos == begin()&lt;/code&gt; or &lt;code&gt;pos == end()&lt;/code&gt;, in which case they are not invalidated.</source>
          <target state="translated">過去のイテレータを含むすべてのイテレータは無効になります。参照も無効化されます。ただし、 &lt;code&gt;pos == begin()&lt;/code&gt; または &lt;code&gt;pos == end()&lt;/code&gt; 場合は無効化されません。</target>
        </trans-unit>
        <trans-unit id="40ad628bf4f34bdc58de5f589d209eea4731620e" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated.</source>
          <target state="translated">コンテナの要素へのイテレータ、ポインタ、および参照はすべて無効になります。</target>
        </trans-unit>
        <trans-unit id="94cae0bd78bc02d0cb18bf7254756a408b83ca8f" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</source>
          <target state="translated">コンテナの要素へのイテレータ、ポインタ、参照はすべて無効になります。過去終了イテレータも無効になります。</target>
        </trans-unit>
        <trans-unit id="1aa2eedbbbd254c0a4f9a58cb63ee4b66a5cdbf4" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order</source>
          <target state="translated">1つのミューテックス上のすべてのロックとアンロック操作は、1つの合計順序で行われます。</target>
        </trans-unit>
        <trans-unit id="178cdfec76dc5f4d6166a9e91517e1f3fec12bff" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order that can be viewed as &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual mutex.</source>
          <target state="translated">単一のミューテックスに対するすべてのロックおよびアンロック操作は、アトミック変数の&lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;変更順序&lt;/a&gt;と見なすことができる単一の合計順序で発生します。順序は、この個々のミューテックスに固有です。</target>
        </trans-unit>
        <trans-unit id="34930fdb8cc73ddd310f600e059433705d8a684e" translate="yes" xml:space="preserve">
          <source>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of &lt;code&gt;shared_ptr&lt;/code&gt; without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same &lt;code&gt;shared_ptr&lt;/code&gt; without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur; the &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr overloads of atomic functions&lt;/a&gt; can be used to prevent the data race.</source>
          <target state="translated">すべてのメンバー関数（コピーコンストラクターとコピー割り当てを含む）は、たとえそれらのインスタンスがコピーで同じオブジェクトの所有権を共有している場合でも、追加の同期なしで &lt;code&gt;shared_ptr&lt;/code&gt; の異なるインスタンス上の複数のスレッドによって呼び出すことができます。実行アクセスの複数のスレッドが同じ場合 &lt;code&gt;shared_ptr&lt;/code&gt; 同期せずに、それらのアクセスのいずれかがの非constメンバ関数使用 &lt;code&gt;shared_ptr&lt;/code&gt; 、データレースが発生します。&lt;a href=&quot;shared_ptr/atomic&quot;&gt;アトミック機能のshared_ptrのオーバーロードは、&lt;/a&gt;データ競合を防ぐために使用することができます。</target>
        </trans-unit>
        <trans-unit id="35b76e83898bb18b9a2f37898e8607d37cde7935" translate="yes" xml:space="preserve">
          <source>All member functions of all standard library specializations of this template are &lt;code&gt;noexcept&lt;/code&gt; except for the member functions of &lt;a href=&quot;optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variant/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">このテンプレートのすべての標準ライブラリ特殊化のすべてのメンバー関数は、&lt;a href=&quot;optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;variant/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; &lt;/a&gt;のメンバー関数を除いて、例外ではあり &lt;code&gt;noexcept&lt;/code&gt; unique_ptr&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8504e2abc83d5c2fab9fb5538bf231a69f226b05" translate="yes" xml:space="preserve">
          <source>All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces).</source>
          <target state="translated">すべてのメンバはクラス定義で一度に定義され、すでに定義されているクラスに追加することはできません (名前空間のメンバとは異なります)。</target>
        </trans-unit>
        <trans-unit id="5302fa5db09bb78acbca4f2b6c8fda7d03161a35" translate="yes" xml:space="preserve">
          <source>All members of a class (bodies of &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, initializers of member objects, and the entire &lt;a href=&quot;nested_classes&quot;&gt;nested class definitions&lt;/a&gt;) have access to all names the class can access. A local class within a member function has access to all names the member function can access.</source>
          <target state="translated">クラスのすべてのメンバー（&lt;a href=&quot;member_functions&quot;&gt;メンバー関数の&lt;/a&gt;ボディ、メンバーオブジェクトの初期化子、および&lt;a href=&quot;nested_classes&quot;&gt;ネストされたクラス定義&lt;/a&gt;全体）は、クラスがアクセスできるすべての名前にアクセスできます。メンバー関数内のローカルクラスは、メンバー関数がアクセスできるすべての名前にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="59ab18ea391c2d9b328f2f7d982b4ad982485409" translate="yes" xml:space="preserve">
          <source>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.</source>
          <target state="translated">任意の特定の原子変数に対するすべての変更は、この1つの原子変数に固有の合計順序で発生します。</target>
        </trans-unit>
        <trans-unit id="d28efff2a0fb864afdef01249aa565cd9c9d0c3a" translate="yes" xml:space="preserve">
          <source>All names introduced by the declarations that appear within namespace-body (including nested namespace definitions) become members of the namespace identifier, whether this namespace definition is the original namespace definition (which introduced identifier), or an extension namespace definition (which &quot;reopened&quot; the already defined namespace).</source>
          <target state="translated">名前空間ボディ内に現れる宣言によって導入されたすべての名前(入れ子になった名前空間定義を含む)は、この名前空間定義が元の名前空間定義(識別子を導入した)であっても、拡張名前空間定義(既に定義されている名前空間を &quot;再オープン &quot;した)であっても、名前空間識別子のメンバになります。</target>
        </trans-unit>
        <trans-unit id="b08c863ba714f38d0d860de01117473b44bbbe86" translate="yes" xml:space="preserve">
          <source>All non-local variables with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are initialized as part of program startup, before the execution of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; begins (unless deferred, see below). All variables with thread-local storage duration are initialized as part of thread launch, sequenced-before the execution of the thread function begins. For both of these classes of variables, initialization occurs in two distinct stages:</source>
          <target state="translated">静的&lt;a href=&quot;storage_duration&quot;&gt;ストレージ期間を&lt;/a&gt;持つすべての非ローカル変数は、&lt;a href=&quot;main_function&quot;&gt;メイン関数の&lt;/a&gt;実行が開始する前に、プログラムの起動の一部として初期化されます（据え置きがない限り、以下を参照してください）。スレッドローカルストレージ期間を持つすべての変数は、スレッド起動の一部として初期化され、スレッド関数の実行が始まる前にシーケンスされます。これらの変数のクラスの両方について、初期化は2つの異なる段階で行われます。</target>
        </trans-unit>
        <trans-unit id="55481c71bd011e1fe7bc3e43733da57362a61783" translate="yes" xml:space="preserve">
          <source>All non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; functions are also provided by this specialization, and no additional member functions.</source>
          <target state="translated">特殊化されていないすべての &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 関数もこの特殊化によって提供され、追加のメンバー関数はありません。</target>
        </trans-unit>
        <trans-unit id="0557b920b1069437438d197127c5136f3ee6adf1" translate="yes" xml:space="preserve">
          <source>All non-static data members and base classes are themselves standard layout types</source>
          <target state="translated">すべての非静的データメンバと基底クラスは、それ自体が標準的なレイアウトタイプです。</target>
        </trans-unit>
        <trans-unit id="e4dcf520b0bb3c172727a71b79681a5d16c241c8" translate="yes" xml:space="preserve">
          <source>All non-static data members have the same &lt;a href=&quot;../language/access&quot;&gt;access control&lt;/a&gt;</source>
          <target state="translated">すべての非静的データメンバーは同じ&lt;a href=&quot;../language/access&quot;&gt;アクセス制御を&lt;/a&gt;持っています</target>
        </trans-unit>
        <trans-unit id="624a5b6de90948456f868c89c51c9329989f3cb3" translate="yes" xml:space="preserve">
          <source>All non-static data members of class type (or array of class type) have trivial destructors</source>
          <target state="translated">クラス型(またはクラス型の配列)のすべての非静的データメンバは、トリビアルなデストラクタを持っています。</target>
        </trans-unit>
        <trans-unit id="f485616a097e8c940e99a2d2edb5c6f19158253d" translate="yes" xml:space="preserve">
          <source>All of the elements before this new &lt;code&gt;nth&lt;/code&gt; element are less than or equal to the elements after the new &lt;code&gt;nth&lt;/code&gt; element.</source>
          <target state="translated">この新しい &lt;code&gt;nth&lt;/code&gt; 要素の前のすべての要素は、新しい &lt;code&gt;nth&lt;/code&gt; 要素の後の要素以下です。</target>
        </trans-unit>
        <trans-unit id="d5ea57823ac6ced06c326c70fd59fde6fcce0fad" translate="yes" xml:space="preserve">
          <source>All of the iterator categories (except &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;) can be organized into a hierarchy, where more powerful iterator categories (e.g. &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;) support the operations of less powerful categories (e.g. &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;). If an iterator falls into one of these categories and also satisfies the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, then it is called a</source>
          <target state="translated">すべてのイテレータカテゴリ（&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;および&lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;を除く）は階層に編成でき、より強力なイテレータカテゴリ（&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorなど&lt;/a&gt;）は、それほど強力でないカテゴリ（&lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIteratorなど&lt;/a&gt;）の操作をサポートします。イテレータがこれらのカテゴリのいずれかに分類され、&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;の要件も満たしている場合、イテレータは</target>
        </trans-unit>
        <trans-unit id="f4c48696f28287567f830764d3d2f6d6181a4365" translate="yes" xml:space="preserve">
          <source>All other constructors take an allocator parameter.</source>
          <target state="translated">他のすべてのコンストラクタはアロケータパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="9051dde370d80e8aba9af3637e2fe2a4c637ddb2" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated</source>
          <target state="translated">すべてのポインタは有効であるとみなされ、参照を解除したり解放したりすることができます。</target>
        </trans-unit>
        <trans-unit id="06db46d40762e7a049233b69f344ddc40172814b" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated. A reachability-based leak detector may be active</source>
          <target state="translated">すべてのポインタは有効とみなされ、参照を解除したり解放したりすることができます。到達可能性に基づいたリーク検出器がアクティブになっている可能性があります。</target>
        </trans-unit>
        <trans-unit id="bdcfa55217ac64f8db8a5cf75b2b3e2a7b2b589f" translate="yes" xml:space="preserve">
          <source>All pointers, references, and iterators are invalidated.</source>
          <target state="translated">すべてのポインタ、参照、イテレータは無効です。</target>
        </trans-unit>
        <trans-unit id="cae4dbc2c6705f38175037741cbe2272cd9f0a9e" translate="yes" xml:space="preserve">
          <source>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW #100&lt;/a&gt; for the discussion of the alternatives).</source>
          <target state="translated">すべてのプライベートデータメンバーとすべてのプライベート非仮想メンバー関数は、実装クラスに配置されます。すべてのパブリック、保護、および仮想メンバーは、インターフェイスクラスに残ります（代替の説明については、&lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW＃100&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="6ad08b1a1866207c625f156796d23145d807041c" translate="yes" xml:space="preserve">
          <source>All read only operations</source>
          <target state="translated">すべての読み取り専用操作</target>
        </trans-unit>
        <trans-unit id="51f454bbf261c865ca3eafaca5186949d522a16c" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">すべての読み取り専用操作、 &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d0ff23cc747ee3f2c2cacda30dad2daf43fc67d" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">すべての読み取り専用操作、 &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a67df5b26d67f230c41a225f6f4807b01737d6" translate="yes" xml:space="preserve">
          <source>All references, pointers, and iterators are invalidated, including the end iterator. &lt;code&gt;a.empty() == true&lt;/code&gt;.</source>
          <target state="translated">終了反復子を含め、すべての参照、ポインタ、および反復子は無効化されます。 &lt;code&gt;a.empty() == true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe67501a1ba3ff0b54181ac0c20ec517abdc3e4" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;basic_string_view&lt;/code&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;../named_req/container&quot;&gt;コンテナの&lt;/a&gt;イテレータタイプに関するすべての要件は、 &lt;code&gt;basic_string_view&lt;/code&gt; の &lt;code&gt;iterator&lt;/code&gt; タイプと &lt;code&gt;const_iterator&lt;/code&gt; タイプにも適用されます。</target>
        </trans-unit>
        <trans-unit id="2f7b5a1e5c99b2a9bb4697e1dc9787334111a47c" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;span&lt;/code&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;../named_req/container&quot;&gt;コンテナの&lt;/a&gt;イテレータタイプに関するすべての要件は、 &lt;code&gt;span&lt;/code&gt; &lt;code&gt;iterator&lt;/code&gt; タイプと &lt;code&gt;const_iterator&lt;/code&gt; タイプにも適用されます。</target>
        </trans-unit>
        <trans-unit id="38eb211404e95dd1fe2352aec53428f8cadc5999" translate="yes" xml:space="preserve">
          <source>All resources owned by &lt;code&gt;u&lt;/code&gt; are reclaimed, no exceptions are thrown.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; が所有するすべてのリソースは再利用され、例外はスローされません。</target>
        </trans-unit>
        <trans-unit id="67f929817d9ab7c1515c103b3dec94699f49b916" translate="yes" xml:space="preserve">
          <source>All restrictions on regular declarations of the same names, hiding, and overloading rules apply to using-declarations:</source>
          <target state="translated">同名の正規宣言、非表示、オーバーロードの規則に関するすべての制限は、使用宣言に適用されます。</target>
        </trans-unit>
        <trans-unit id="be8b6e7136fa8d596cfda90d7fa7d28938ef27cd" translate="yes" xml:space="preserve">
          <source>All six relational operators are automatically generated by the compiler if the three-way comparison operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</source>
          <target state="translated">6種類の関係演算子はすべて、3者間比較演算子 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; が定義されている場合はコンパイラによって自動的に生成され、その演算子は、デフォルトとして定義されている場合はコンパイラによって生成されます。</target>
        </trans-unit>
        <trans-unit id="0d9fb7dc61944bda88f1835dd4562a6f28a100a2" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;fpos&lt;/code&gt; meet the &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;fpos&lt;/code&gt; のすべての特殊化は、&lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;、&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;、&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;、&lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;、および&lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparableの&lt;/a&gt;要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="672a39cb4d9a7dc48c3d594e3812033e46d14edc" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;polymorphic_allocator&lt;/code&gt; meet the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; のすべての特殊化は、&lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocatorの完全性要件を満たしています&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="211f03dbec01e5b6570f235c7176b37d2a2a79b5" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;shared_ptr&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; and are &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">すべての専門 &lt;code&gt;shared_ptr&lt;/code&gt; 会うの要件&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;コピーコンストラクト&lt;/a&gt;、&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;、および&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;とされている&lt;a href=&quot;../language/implicit_cast&quot;&gt;文脈的に転換&lt;/a&gt;する &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1031f9406b312c985a6ae796719a2a8d26efc31e" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::tuple_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">すべての専門 &lt;code&gt;std::tuple_size&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;と</target>
        </trans-unit>
        <trans-unit id="743934d87daadcc6d9d31370a3db4d5504aa0fb9" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::variant_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">すべての専門 &lt;code&gt;std::variant_size&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;と</target>
        </trans-unit>
        <trans-unit id="63c53895a6870cc913e144b2578bac2d714b260c" translate="yes" xml:space="preserve">
          <source>All standard containers (&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;, etc.) value-initialize their elements when constructed with a single &lt;code&gt;size_type&lt;/code&gt; argument or when grown by a call to &lt;code&gt;resize()&lt;/code&gt;.</source>
          <target state="translated">すべての標準コンテナ（ &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; など）は、単一の &lt;code&gt;size_type&lt;/code&gt; 引数を使用して構築されたとき、または &lt;code&gt;resize()&lt;/code&gt; の呼び出しによって拡張されたときに、要素を値で初期化します。</target>
        </trans-unit>
        <trans-unit id="358e40d1bfabb9461fdcb4d0a347855e7c412649" translate="yes" xml:space="preserve">
          <source>All standard library containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; are AllocatorAwareContainers:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; を除くすべての標準ライブラリコンテナーはAllocatorAwareContainersです。</target>
        </trans-unit>
        <trans-unit id="ffcd9ca742b4542ddb772e7d60b22b2039e3de22" translate="yes" xml:space="preserve">
          <source>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</source>
          <target state="translated">すべての一時オブジェクトは、それらが作成された点を(語彙的に)含む完全式を評価する最後のステップとして破壊され、複数の一時オブジェクトが作成された場合、それらは作成された順序とは逆の順序で破壊されます。これは、その評価が例外を投げることで終わったとしても、真です。</target>
        </trans-unit>
        <trans-unit id="32f475507fbff7c599c3fd139abea98403ae6343" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">呼び出しすべてのこれらの機能 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; の値は、少なくとも、一度 &lt;code&gt;arg&lt;/code&gt; が復帰後は不定です。これらの関数は &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; を呼び出さないため、呼び出し元が実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="176f5f0946a06ebe297b8c8ddf38982989abc5aa" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">呼び出しすべてのこれらの機能 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; の値は、少なくとも、一度 &lt;code&gt;arg&lt;/code&gt; が復帰後は不定です。これらの関数は &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; を呼び出さず、呼び出し側で実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe267d2b83e7299286bdf1b9c5aac0a7f499c7ed" translate="yes" xml:space="preserve">
          <source>All these functions invoke undefined behavior if &lt;code&gt;p&lt;/code&gt; is a null pointer.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; がnullポインターの場合、これらの関数はすべて未定義の動作を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">これらのすべてのマクロ定数（ &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; を除く）は、2のべき乗である整数定数式に展開され、サポートされるすべての浮動小数点例外を一意に識別します。各マクロは、サポートされている場合にのみ定義されます。</target>
        </trans-unit>
        <trans-unit id="18f14072e9d32bbf324c49cf31c0caf2c548ae29" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</source>
          <target state="translated">3つのオーバーロードはすべて &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt; &amp;lt;CharT、Traits&amp;gt;（data（）、size（））。ends_with（x）;を効果的に返します。</target>
        </trans-unit>
        <trans-unit id="3ae0f95f4fd5fb1e59f705f02f6b13547bc8d638" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</source>
          <target state="translated">3つのオーバーロードはすべて &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt; &amp;lt;CharT、Traits&amp;gt;（data（）、size（））。starts_with（x）;を効果的に返します。</target>
        </trans-unit>
        <trans-unit id="41dbcf1025fbada0bb806a90ae80be55d2ccdbc3" translate="yes" xml:space="preserve">
          <source>All uniform random bit generators meet the &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; requirements. C++20 also defines a &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt;&lt;code&gt;UniformRandomBitGenerator&lt;/code&gt;&lt;/a&gt; concept.</source>
          <target state="translated">すべての均一ランダムビットジェネレーターは、&lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;要件を満たしています。C ++ 20は、&lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt; &lt;code&gt;UniformRandomBitGenerator&lt;/code&gt; の&lt;/a&gt;概念も定義しています。</target>
        </trans-unit>
        <trans-unit id="8d23b28c0c5980cc7718a01e280ed03d0685c95f" translate="yes" xml:space="preserve">
          <source>All users have read, write, and execute/search permissions</source>
          <target state="translated">すべてのユーザが読み取り、書き込み、実行/検索の権限を持っています。</target>
        </trans-unit>
        <trans-unit id="a57778f1822ccdd378e7db95391c602549921f33" translate="yes" xml:space="preserve">
          <source>All valid permission bits.</source>
          <target state="translated">すべての有効な許可ビット。</target>
        </trans-unit>
        <trans-unit id="49247714c9e6a1264921f2f7061610f5ebfc233f" translate="yes" xml:space="preserve">
          <source>All values are required to be unique except that the values of &lt;code&gt;EOPNOTSUPP&lt;/code&gt; and &lt;code&gt;ENOTSUP&lt;/code&gt; may be identical and the values of &lt;code&gt;EAGAIN&lt;/code&gt; and &lt;code&gt;EWOULDBLOCK&lt;/code&gt; may be identical.</source>
          <target state="translated">&lt;code&gt;EOPNOTSUPP&lt;/code&gt; と &lt;code&gt;ENOTSUP&lt;/code&gt; の値が同一で、 &lt;code&gt;EAGAIN&lt;/code&gt; と &lt;code&gt;EWOULDBLOCK&lt;/code&gt; の値が同一である場合を除いて、すべての値は一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="9c56cddca11b01528f10a9f07f26dc5bec9d8e2f" translate="yes" xml:space="preserve">
          <source>All versions behave as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;. After constructing and checking the sentry object, these functions perform the following:</source>
          <target state="translated">すべてのバージョンは&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;として動作します。監視オブジェクトを構築およびチェックした後、これらの関数は以下を実行します。</target>
        </trans-unit>
        <trans-unit id="fe817f9833c1ccda48652b1e96a5f243b7b8c465" translate="yes" xml:space="preserve">
          <source>All versions set the value of &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; to the number of characters extracted.</source>
          <target state="translated">すべてのバージョンで、 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; の値は抽出された文字数に設定されます。</target>
        </trans-unit>
        <trans-unit id="7c49bcb1867689918b55a1779cbc5e6907f7117d" translate="yes" xml:space="preserve">
          <source>All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;:</source>
          <target state="translated">すべての仮想ベースサブオブジェクトは、非仮想ベースサブオブジェクトの前に初期化されるため、最も派生したクラスのみが、その&lt;a href=&quot;constructor&quot;&gt;メンバー初期化子リスト&lt;/a&gt;内の仮想ベースのコンストラクターを呼び出します。</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">割り当て &lt;code&gt;size&lt;/code&gt; アラインメントによって指定される初期化されていないストレージのバイト &lt;code&gt;alignment&lt;/code&gt; 。 &lt;code&gt;size&lt;/code&gt; パラメータは、の整数倍でなければならない &lt;code&gt;alignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3713458c26ce42a8beb1ed61bfb66555a6fd00bb" translate="yes" xml:space="preserve">
          <source>Allocate memory</source>
          <target state="translated">メモリの割り当て</target>
        </trans-unit>
        <trans-unit id="c69536036834933fadf93bcfad2311dd91d4b772" translate="yes" xml:space="preserve">
          <source>Allocate raw aligned memory from the underlying resource</source>
          <target state="translated">基盤となるリソースから生のアラインドメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="8c90ccd007d394557e735c7fe5d3753ec43eedf6" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes of uninitialized storage by calling &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how this function is called. The pointer &lt;code&gt;hint&lt;/code&gt; may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;（&lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt;）または &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;（&lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt;、&lt;a href=&quot;../new/align_val_t&quot;&gt;std :: align_val_t&lt;/a&gt;）（C ++ 17以降）を呼び出すことにより、初期化されていないストレージの &lt;code&gt;n * sizeof(T)&lt;/code&gt; バイトを割り当てますが、この関数が呼び出されるタイミングと方法は指定されていません。ポインタ &lt;code&gt;hint&lt;/code&gt; は、参照の局所性を提供するために使用できます。実装でサポートされている場合、アロケータは、 &lt;code&gt;hint&lt;/code&gt; できるだけ近い場所に新しいメモリブロックを割り当てようとします。</target>
        </trans-unit>
        <trans-unit id="e4fd50aabe78c29ec16f5fd9d57b662c1d7d801a" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;nbytes&lt;/code&gt; bytes of storage at specified alignment &lt;code&gt;alignment&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</source>
          <target state="translated">基になるメモリリソースを使用して、 &lt;code&gt;nbytes&lt;/code&gt; バイトのストレージを指定されたアライメント &lt;code&gt;alignment&lt;/code&gt; 割り当てます。同等の &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">初期化されていないストレージの &lt;code&gt;size&lt;/code&gt; バイトを割り当てます。</target>
        </trans-unit>
        <trans-unit id="deda37c663ffd540f8cba4cf2e2cde12e85c7e4b" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object</source>
          <target state="translated">オブジェクトの割り当てと構築</target>
        </trans-unit>
        <trans-unit id="37d6f4ac7e329233b5c6cfd53ae16c6539bab6fd" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;U&lt;/code&gt; のオブジェクトを割り当て、構築します。</target>
        </trans-unit>
        <trans-unit id="eec2cf410629d96a9a943a9c58f28ac54a41b535" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes it to all bits zero.</source>
          <target state="translated">サイズ &lt;code&gt;size&lt;/code&gt; の &lt;code&gt;num&lt;/code&gt; オブジェクトの配列にメモリを割り当て、それをすべてのビット0に初期化します。</target>
        </trans-unit>
        <trans-unit id="9d033c92aaed0cd6d702cbb7cedf1b4eeff6647d" translate="yes" xml:space="preserve">
          <source>Allocates raw memory suitable for an object or an array</source>
          <target state="translated">オブジェクトまたは配列に適した生のメモリを確保します.</target>
        </trans-unit>
        <trans-unit id="cf91bb95384027fe5328e00c00aaeaa013321358" translate="yes" xml:space="preserve">
          <source>Allocates requested number of bytes. These allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</source>
          <target state="translated">要求されたバイト数を割り当てます。これらの割り当て関数は、&lt;a href=&quot;../../language/new&quot;&gt;新しい式&lt;/a&gt;によって呼び出され、新しいオブジェクトが初期化されるメモリを割り当てます。通常の関数呼び出し構文を使用して呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="d2fc2b0dfd842a7e3a00d1f42dd3c72c9a40aeb4" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt;.</source>
          <target state="translated">基礎となるメモリリソースを使用して、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 個のオブジェクトにストレージを割り当てます。同等 &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef1e5d4c9fecdb8c77f2367b414e8a2ebe079e5f" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;U&lt;/code&gt; using the underlying memory resource.</source>
          <target state="translated">基礎となるメモリリソースを使用して、タイプ &lt;code&gt;U&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 個のオブジェクトにストレージを割り当てます。</target>
        </trans-unit>
        <trans-unit id="c8d51dfb7cc15d733b905081816cec434af6b924" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes, aligned to the specified &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;alignment&lt;/code&gt; 合わせて、少なくとも &lt;code&gt;bytes&lt;/code&gt; バイトのサイズでストレージを割り当てます。</target>
        </trans-unit>
        <trans-unit id="1719b83d89f242ab75b869949fb55eef6c5d0e25" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes. The returned storage is aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">少なくとも &lt;code&gt;bytes&lt;/code&gt; バイトのサイズでストレージを割り当てます。返されるストレージは、指定された配置がサポートされている場合は指定された &lt;code&gt;alignment&lt;/code&gt; 配置され、そうでない場合は &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5fa0c7f2ed7e5ab17575514af95c1b4726f6491b" translate="yes" xml:space="preserve">
          <source>Allocates storage.</source>
          <target state="translated">ストレージを割り当てます。</target>
        </trans-unit>
        <trans-unit id="a4cd37a2b2f79389364650460bd02f87e623f6b0" translate="yes" xml:space="preserve">
          <source>Allocates uninitialized contiguous storage, which should be sufficient to store up to &lt;code&gt;count&lt;/code&gt; adjacent objects of type &lt;code&gt;T&lt;/code&gt;. The request is non-binding and the implementation may allocate less or more than necessary to store &lt;code&gt;count&lt;/code&gt; adjacent objects.</source>
          <target state="translated">初期化されていない連続したストレージを割り当てます。これは、タイプ &lt;code&gt;T&lt;/code&gt; の隣接オブジェクトを &lt;code&gt;count&lt;/code&gt; するまで保存するのに十分でなければなりません。リクエストは拘束力がなく、実装では、隣接するオブジェクトの &lt;code&gt;count&lt;/code&gt; を格納するために必要な数よりも多くまたは多く割り当てる場合があります。</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="7e5a93aa2050aa67c4b2a8fa0227ec2d570a5f78" translate="yes" xml:space="preserve">
          <source>Allocation functions</source>
          <target state="translated">割当機能</target>
        </trans-unit>
        <trans-unit id="bcdc03b4788456846d38f2b2c7a10637d4ba865e" translate="yes" xml:space="preserve">
          <source>Allocations requests that exceed the largest block size are served from the</source>
          <target state="translated">最大ブロックサイズを超える割り当てリクエストは</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="c26087d42681b7f6e496369e9c820f3e757778ab" translate="yes" xml:space="preserve">
          <source>Allocator completeness requirements</source>
          <target state="translated">アロケータの完全性要件</target>
        </trans-unit>
        <trans-unit id="006db541d4a947093a399166c59d14c227c66a14" translate="yes" xml:space="preserve">
          <source>Allocator for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のアロケータ</target>
        </trans-unit>
        <trans-unit id="a14116cd7defc5cfe1008ae088831e83125981b1" translate="yes" xml:space="preserve">
          <source>Allocator of a type convertible to &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に変換可能な型のアロケーター</target>
        </trans-unit>
        <trans-unit id="71d3d89dd86b8060b5c2c3dff2ad831f3f7d33f4" translate="yes" xml:space="preserve">
          <source>Allocator type</source>
          <target state="translated">アロケータタイプ</target>
        </trans-unit>
        <trans-unit id="c5e06a85490c85e6350aa5bd28390e1ead65f231" translate="yes" xml:space="preserve">
          <source>Allocator-aware containers always call &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; to construct an object of type &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;p&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt;, with &lt;code&gt;m == get_allocator()&lt;/code&gt;. The default &lt;code&gt;construct&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt;, but specialized allocators may choose a different definition.</source>
          <target state="translated">アロケータ対応コンテナは、常に &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; を &lt;code&gt;m == get_allocator()&lt;/code&gt; 、m == get_allocator（）で &lt;code&gt;args&lt;/code&gt; を使用して &lt;code&gt;p&lt;/code&gt; でタイプ &lt;code&gt;A&lt;/code&gt; のオブジェクトを構築します。デフォルトの &lt;code&gt;construct&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 呼び出し &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt; が、専門アロケータは異なる定義を選択することができます。</target>
        </trans-unit>
        <trans-unit id="34acd9339509e4e1e31704ab4c073ecbdafd1f25" translate="yes" xml:space="preserve">
          <source>AllocatorAwareContainer</source>
          <target state="translated">AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="5ceb7c7c9f3657e9513254564292abfe012cfefb" translate="yes" xml:space="preserve">
          <source>Allocators</source>
          <target state="translated">Allocators</target>
        </trans-unit>
        <trans-unit id="629f37bb798c36a67317aa9ec0378bd852ec9f11" translate="yes" xml:space="preserve">
          <source>Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.</source>
          <target state="translated">アロケータは、メモリ割り当て戦略をカプセル化したクラステンプレートです。これにより、汎用コンテナはメモリ管理をデータ自体から切り離すことができます。</target>
        </trans-unit>
        <trans-unit id="095c1a8ff16049f04c3471ba9a37d8292cb9648d" translate="yes" xml:space="preserve">
          <source>Allow constant evaluation for all &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;non-type template arguments&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;タイプではない&lt;/a&gt;すべてのテンプレート引数の定数評価を許可する</target>
        </trans-unit>
        <trans-unit id="8672315bab526e017a0da6b4db8394d5643bd21c" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize for the case where paths of execution including that statement are more or less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">コンパイラが、そのステートメントを含む実行パスが、そのようなステートメントを含まない実行パスよりも多いか少ないかの可能性が高い場合に最適化できるようにします。</target>
        </trans-unit>
        <trans-unit id="03388373add47a2fa22bbeb6dede9123b781ba3f" translate="yes" xml:space="preserve">
          <source>Allows a function to accept any number of arguments.</source>
          <target state="translated">関数が任意の数の引数を受け付けることを可能にします。</target>
        </trans-unit>
        <trans-unit id="411787b050d38051721728f3a87d5174918b5c69" translate="yes" xml:space="preserve">
          <source>Allows a function to be called without providing one or more trailing arguments.</source>
          <target state="translated">1つ以上の末尾の引数を与えずに関数を呼び出せるようにします。</target>
        </trans-unit>
        <trans-unit id="459d9517d5603efba94121b4d2acec3f8491a657" translate="yes" xml:space="preserve">
          <source>Allows any and all code transformations that do not change the observable behavior of the program.</source>
          <target state="translated">プログラムの観測可能な動作を変更しない、すべてのコード変換を許可します。</target>
        </trans-unit>
        <trans-unit id="f7fd47c92a72794dea3d8bd7149aab52470581d7" translate="yes" xml:space="preserve">
          <source>Allows customizing class and variable(since C++14) templates for a given category of template arguments.</source>
          <target state="translated">テンプレート引数の指定されたカテゴリのクラスおよび変数(C++14 以降)テンプレートをカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="36e28bc484be80710ded433fdd6ceb2b32b730fd" translate="yes" xml:space="preserve">
          <source>Allows customizing the template code for a given set of template arguments.</source>
          <target state="translated">与えられたテンプレート引数のセットに対してテンプレートコードをカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="a8bf676764b0183a61de1aa7f44f4c55b945bd3c" translate="yes" xml:space="preserve">
          <source>Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.</source>
          <target state="translated">CSVやXMLにあるような引用符付きの文字列の挿入と抽出を許可します。</target>
        </trans-unit>
        <trans-unit id="1433f306e640197740511f48680f25d7413dc2e9" translate="yes" xml:space="preserve">
          <source>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</source>
          <target state="translated">整数、浮動小数点、文字、文字列リテラルで、ユーザー定義のサフィックスを定義することで、ユーザー定義の型のオブジェクトを生成できるようにします。</target>
        </trans-unit>
        <trans-unit id="714a3428d46162788e491e8dc3208e88274f1f2f" translate="yes" xml:space="preserve">
          <source>Allows the size of an empty base subobject to be zero.</source>
          <target state="translated">空のベースサブオブジェクトのサイズをゼロにすることができます。</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">整数型の値を直接式で使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="9a0c4d0005f924626f07462db95d58f6067b54a8" translate="yes" xml:space="preserve">
          <source>Also because braced-init-list has no type, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;special rules for overload resolution&lt;/a&gt; apply when it is used as an argument to an overloaded function call.</source>
          <target state="translated">また、braced-init-listにはタイプがない&lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;ため、オーバーロード&lt;/a&gt;された関数呼び出しの引数として使用される場合、オーバーロードの解決に関する特別なルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="3b587e48dc1be81684dc5d496c6af85f6a461578" translate="yes" xml:space="preserve">
          <source>Also provided are the C-style date and time functions, such as &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">また、提供されるような、Cスタイルの日付と時刻関数です &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="729da59cb6e707c89f461faec986a483c428299a" translate="yes" xml:space="preserve">
          <source>Also, all &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; for more details.</source>
          <target state="translated">また、任意の位置に二重下線__を含むすべての&lt;a href=&quot;language/name&quot;&gt;識別子&lt;/a&gt;と、アンダースコアで始まり、その後に大文字が続く各識別子は常に予約されており、アンダースコアで始まるすべての識別子は、グローバル名前空間での名前として使用するために予約されています。詳細については、&lt;a href=&quot;language/name&quot;&gt;識別子&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8790a9cbd433decb4fdf7491221b8bbc56822f99" translate="yes" xml:space="preserve">
          <source>Also, on some platforms, bit fields are packed left-to-right, on others right-to-left</source>
          <target state="translated">また、いくつかのプラットフォームでは、ビットフィールドは左から右に、他のプラットフォームでは右から左に詰められています。</target>
        </trans-unit>
        <trans-unit id="5b07b0bdeb35442e306edb6a6d7347901e47e660" translate="yes" xml:space="preserve">
          <source>Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with &lt;code&gt;std::move&lt;/code&gt;, no aliasing checks are made. In particular, this means that standard library move assignment operators do not have to perform self-assignment checks:</source>
          <target state="translated">また、xvalue引数で呼び出された標準ライブラリ関数は、引数がオブジェクトへの唯一の参照であると想定する場合があります。 &lt;code&gt;std::move&lt;/code&gt; を使用して左辺値から作成された場合、エイリアスチェックは行われません。特に、これは標準のライブラリ移動割り当て演算子が自己割り当てチェックを実行する必要がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="9465911da185e318d4f902c965db53e7bdd827fb" translate="yes" xml:space="preserve">
          <source>Also, unlike the formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; on failure.</source>
          <target state="translated">また、フォーマットされた出力関数とは異なり、この関数は失敗 &lt;code&gt;failbit&lt;/code&gt; にフェイルビットを設定しません。</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="2e4d959d6a71905b14d43661b5387037b9b586bd" translate="yes" xml:space="preserve">
          <source>Alternative operator representations</source>
          <target state="translated">代替演算子表現</target>
        </trans-unit>
        <trans-unit id="c8b93e0cfffeb74171554b62200f1f073639dd68" translate="yes" xml:space="preserve">
          <source>Alternative operator syntax</source>
          <target state="translated">代替演算子構文</target>
        </trans-unit>
        <trans-unit id="e32467443dfa96c0777ac9526ba4d4884bea25fb" translate="yes" xml:space="preserve">
          <source>Alternative tokens</source>
          <target state="translated">代替トークン</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="f33a42489881f94fe215353e72be54816924c644" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; and &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;, which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary.</source>
          <target state="translated">が &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; 時々進行中の巻き戻しスタックを検出するために使用することができる、それが一般的に任意のデストラクタが例外をスローすることによって終了させることを可能にする悪い習慣と考えられています。それでも、この機能は&lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt;や&lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;などの一部のライブラリで使用されます。これらのライブラリは、無名の一時オブジェクトのデストラクタが一時ファイルを構築する完全な式の最後に例外をスローする機能に依存しています。</target>
        </trans-unit>
        <trans-unit id="ea2b684e4b095592200988c7ab99debb5b70a888" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exp&lt;/code&gt; is 1/3.</source>
          <target state="translated">が &lt;code&gt;std::pow&lt;/code&gt; 負の数の平方根を得るために使用することができない、 &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; 一般的なケースのために提供される &lt;code&gt;exp&lt;/code&gt; が 1/3です。</target>
        </trans-unit>
        <trans-unit id="b0bbe9c54239a7325e443792536d8b4342054835" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::scalbn&lt;/code&gt; and &lt;code&gt;std::scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">なお &lt;code&gt;std::scalbn&lt;/code&gt; と &lt;code&gt;std::scalbln&lt;/code&gt; 効率的に操作を実行するように指定されている、多くの実装にそれらが算術演算子を使用して、2のべき乗の乗算又は除算未満で効率的です。</target>
        </trans-unit>
        <trans-unit id="3d1825778acdae18596af041fff74b7b10c86289" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; with the default deleter may be constructed with &lt;a href=&quot;../../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, the type &lt;code&gt;T&lt;/code&gt; must be complete at the point of code where the destructor is called.</source>
          <target state="translated">が &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; デフォルトの削除手段とを用いて構成することができる&lt;a href=&quot;../../language/incomplete_type&quot;&gt;不完全なタイプ&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 、タイプ &lt;code&gt;T&lt;/code&gt; はデストラクタが呼び出されるコードの時点で完了しなければなりません。</target>
        </trans-unit>
        <trans-unit id="439c84aa6d4f184555f03b26b3fb02df31f3c81c" translate="yes" xml:space="preserve">
          <source>Although a function call can be resolved through ADL even if ordinary lookup finds nothing, a function call to a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; with explicitly-specified template arguments requires that there is a declaration of the template found by ordinary lookup (otherwise, it is a syntax error to encounter an unknown name followed by a less-than character).</source>
          <target state="translated">通常のルックアップで何も見つからない場合でも、ADLを介して関数呼び出しを解決できますが、明示的に指定されたテンプレート引数を使用した&lt;a href=&quot;function_template&quot;&gt;関数テンプレート&lt;/a&gt;への関数呼び出しでは、通常のルックアップで見つかったテンプレートの宣言が必要です（それ以外の場合、構文エラーです）不明な名前の後に小なり記号が続く場合）。</target>
        </trans-unit>
        <trans-unit id="f1ebb0e824901f4ec3f02ea57f64d9e4828306f2" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">ゼロで初期化された &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 常に初期変換状態を表しますが、 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; は他にも初期変換状態を表す値がある場合があります。</target>
        </trans-unit>
        <trans-unit id="f708528328b72807fc0654354970ef41ee70cd4b" translate="yes" xml:space="preserve">
          <source>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; may be formed by using a type alias to construct an array temporary using &lt;a href=&quot;explicit_cast&quot;&gt;brace-initialized functional cast&lt;/a&gt;.</source>
          <target state="translated">配列は値によって関数から返されることができず、ほとんどのキャスト式のターゲットにすることはできませんが、配列&lt;a href=&quot;value_category&quot;&gt;prvaluesを&lt;/a&gt;用いて一時的アレイ構築するタイプのエイリアスを使用して形成することができる&lt;a href=&quot;explicit_cast&quot;&gt;ブレース初期化機能キャスト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fd9b3c6d07c5655b399e6be4424fee0edae9357" translate="yes" xml:space="preserve">
          <source>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</source>
          <target state="translated">プレインクリメント/プレデクリメントの正規形式は参照を返しますが、演算子のオーバーロードと同様に、戻り値の型はユーザー定義です。たとえば、値による &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 戻り値のこれらの演算子のオーバーロード。</target>
        </trans-unit>
        <trans-unit id="2de2491baa0eb4945c698a40f7cf02c5b5ff7ca9" translate="yes" xml:space="preserve">
          <source>Although decl-specifier-seq implies there can exist &lt;a href=&quot;declarations#Specifiers&quot;&gt;specifiers&lt;/a&gt; other than type specifiers, the only other specifier allowed is &lt;code&gt;register&lt;/code&gt;as well as &lt;code&gt;auto&lt;/code&gt;(until C++11), and it has no effect.</source>
          <target state="translated">decl-specifier-seq は、型指定&lt;a href=&quot;declarations#Specifiers&quot;&gt;子&lt;/a&gt;以外の指定子が存在する可能性があることを意味しますが、許可 &lt;code&gt;register&lt;/code&gt; れる他の指定子は、 &lt;code&gt;auto&lt;/code&gt; およびC ++ 11までであり、効果はありません。</target>
        </trans-unit>
        <trans-unit id="14b7b14235553f3b91083c0b71081ba75f07e98f" translate="yes" xml:space="preserve">
          <source>Although no class is its own base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; is true because the intent of the trait is to model the &quot;is-a&quot; relationship, and T is a T. Despite that, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; is false because only classes participate in the relationship that this trait models.</source>
          <target state="translated">独自のベースとなるクラスはありませんが、特性の目的は「is-a」関係をモデル化することであり、TはTであるため、 &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; はtrueです。それにもかかわらず、 &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; は、この特性がモデル化する関係に参加するのはクラスだけであるため、falseです。</target>
        </trans-unit>
        <trans-unit id="119fa9e7db8c27df8ae932b0248b04e4bfefb226" translate="yes" xml:space="preserve">
          <source>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">定義されていませんが、これはほとんどの場合、&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;POSIX時間&lt;/a&gt;に対応する、UTC 1970年1月1日00:00からの秒数（うるう秒は含まない）を保持する整数値です。</target>
        </trans-unit>
        <trans-unit id="ac8975eb41b5df62d74c9b6ae1a1689383a4d797" translate="yes" xml:space="preserve">
          <source>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of the referred-to object ends, but the reference remains accessible (</source>
          <target state="translated">参照は、初期化されると常に有効なオブジェクトまたは関数を参照しますが、参照先オブジェクトの&lt;a href=&quot;lifetime&quot;&gt;存続期間&lt;/a&gt;が終了するプログラムを作成することは可能ですが、参照はアクセス可能なままです（</target>
        </trans-unit>
        <trans-unit id="6c367e67cfae5a3c20e167ab56108c7704f6c4ad" translate="yes" xml:space="preserve">
          <source>Although synchronized blocks execute as-if under a global lock, the implementations are expected to examine the code within each block and use optimistic concurrency (backed up by hardware transactional memory where available) for transaction-safe code and minimal locking for non-transaction safe code. When a synchronized block makes a call to a non-inlined function, the compiler may have to drop out of speculative execution and hold a lock around the entire call unless the function is declared &lt;code&gt;transaction_safe&lt;/code&gt; (see below) or the attribute &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (see below) is used.</source>
          <target state="translated">同期されたブロックはグローバルロックのもとで実行されますが、実装は各ブロック内のコードを検査し、トランザクションセーフなコードには楽観的同時実行性（ハードウェアトランザクショナルメモリによってバックアップされます）を使用し、非トランザクションセーフには最小限のロックを使用することが期待されますコード。同期ブロックが非インライン関数を呼び出す場合、関数が &lt;code&gt;transaction_safe&lt;/code&gt; （以下を参照）または属性 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; と宣言されていない限り、コンパイラーは投機的実行から抜け出し、呼び出し全体をロックする必要がある場合があります。（下記参照）が使用されます。</target>
        </trans-unit>
        <trans-unit id="dad5173c2001f38e75509fd69dc64ba3e87866b3" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">C標準(C++がこの関数を参照している)では、この関数を「円弧双曲余弦」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクタの面積であり、円弧ではありません。正しい名前は、&quot;inverse hyperbolic cosine&quot;(POSIXで使用)または &quot;area hyperbolic cosine &quot;です。</target>
        </trans-unit>
        <trans-unit id="a1733c8cc2a0d050132b6b9364d6944323c32b74" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">C標準(C++がこの関数を参照している)では、この関数を「円弧双曲サイン」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクタの面積であり、円弧ではありません。正しい名前は、&quot;inverse hyperbolic sine&quot;(POSIXで使用)または &quot;area hyperbolic sine &quot;です。</target>
        </trans-unit>
        <trans-unit id="4277fd8c5f429dde16accb19c538a3e9d0e882ce" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">C標準(C++がこの関数を参照している)では、この関数を「円弧双曲正接」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクターの面積であり、円弧ではありません。正しい名前は、&quot;inverse hyperbolic tangent&quot;(POSIXで使用)または &quot;area hyperbolic tangent &quot;です。</target>
        </trans-unit>
        <trans-unit id="91479e7f0ee3ff1337daf6434e5f71cdfdc3c6a6" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">C++標準ではこの関数を「複素円弧双曲余弦」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクタの面積であり、円弧ではありません。正しい名前は「複素逆双曲余弦」であり、あまり一般的ではありませんが「複素面積双曲余弦」です。</target>
        </trans-unit>
        <trans-unit id="6a7e68fe75439346aeaad1f6906c84e17daadb3b" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">C++標準ではこの関数を「複素円弧双曲サイン」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクタの面積であり、円弧ではありません。正しい名前は「複素逆双曲線サイン」であり、あまり一般的ではありませんが「複素面積双曲線サイン」です。</target>
        </trans-unit>
        <trans-unit id="8d2c788effcf0da46c782a95d9a9fd3b66474139" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">C++標準ではこの関数を「複素円弧双曲正接」と呼んでいますが、双曲関数の逆関数は面積関数です。その引数は双曲セクタの面積であり、円弧ではありません。正しい名前は「複素逆双曲正接」であり、あまり一般的ではありませんが「複素面積双曲正接」です。</target>
        </trans-unit>
        <trans-unit id="fd70e10e04c4727c7eb398861b7b422e51e53f42" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">C ++ 11標準にはまだ「ほとんどのマシンでは、これは符号付き整数についても当てはまる」と書かれていますが、これは欠陥であり、修正されています。正確な表現はC ++ 03からC ++ 11に変更され、 &lt;code&gt;true&lt;/code&gt; 値は&lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;符号付き整数オーバーフロー&lt;/a&gt;での未定義の動作と互換性がなくなりました。そのため、（最適化の機会のために）符号付きオーバーフローが未定義であることに依存する実装では、符号付き整数の &lt;code&gt;is_modulo&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定するようになりました。たとえば、&lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="73c3fb8cae35d1afdb844e48a3d68c51dd534493" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">C ++ 11標準では、「ほとんどのマシンで、これは符号付き整数に当てはまります。」と書かれていますが、これは欠陥であり、修正されています。正確な表現がC ++ 03からC ++ 11に変更され、 &lt;code&gt;true&lt;/code&gt; 値が&lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;符号付き整数オーバーフローの未定義の動作&lt;/a&gt;と互換性がなくなるようになりました。そのため、（最適化の機会のために）符号付きオーバーフローが未定義であることに依存する実装は、符号付き整数に対して &lt;code&gt;is_modulo&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定するようになりました。たとえば、&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR22200を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="661de5137e7e9dcc1cb0c7e5d23a45a40d059e70" translate="yes" xml:space="preserve">
          <source>Although the definition uses &lt;code&gt;-1&lt;/code&gt;, &lt;a href=&quot;../basic_string&quot;&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/a&gt; is an unsigned integer type, and the value of &lt;code&gt;npos&lt;/code&gt; is the largest positive value it can hold, due to &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;signed-to-unsigned implicit conversion&lt;/a&gt;. This is a portable way to specify the largest value of any unsigned type.</source>
          <target state="translated">定義では &lt;code&gt;-1&lt;/code&gt; を使用していますが、&lt;a href=&quot;../basic_string&quot;&gt; &lt;code&gt;size_type&lt;/code&gt; &lt;/a&gt;は符号なし整数型であり、 &lt;code&gt;npos&lt;/code&gt; の値は、&lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;符号付きから符号なしへの暗黙的な変換の&lt;/a&gt;ため、保持できる最大の正の値です。これは、符号なしの型の最大値を指定するための移植可能な方法です。</target>
        </trans-unit>
        <trans-unit id="1abd2f0bb23531226358684e90cc6818e8f8598e" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;++c.begin()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.begin()&lt;/code&gt; is an rvalue expression, and there is no &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;++c.begin()&lt;/code&gt; does not compile, while &lt;code&gt;std::next(c.begin())&lt;/code&gt; does.</source>
          <target state="translated">式 &lt;code&gt;++c.begin()&lt;/code&gt; はしばしばコンパイルされますが、コンパイルが保証されるわけではありません &lt;code&gt;c.begin()&lt;/code&gt; は右辺値式であり、右辺値の増分が確実に機能することを指定する&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;要件はありません。特に、イテレーターがポインターとして実装されている場合、 &lt;code&gt;++c.begin()&lt;/code&gt; はコンパイルされませんが、 &lt;code&gt;std::next(c.begin())&lt;/code&gt; はコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="55ffdbc2010bd6fba5315668a01fc1d2cb4bf01d" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;--c.end()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.end()&lt;/code&gt; is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;--c.end()&lt;/code&gt; does not compile, while &lt;code&gt;std::prev(c.end())&lt;/code&gt; does.</source>
          <target state="translated">式 &lt;code&gt;--c.end()&lt;/code&gt; はしばしばコンパイルされますが、コンパイルが保証されるわけではありません &lt;code&gt;c.end()&lt;/code&gt; は右辺値式であり、右辺値のデクリメントが機能することが保証されていることを指定する反復子の要件はありません。特に、イテレーターがポインターとして実装されている場合、 &lt;code&gt;--c.end()&lt;/code&gt; はコンパイルされませんが、 &lt;code&gt;std::prev(c.end())&lt;/code&gt; はコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="562d3af0d04be2de0b30b637809f27a622e04faf" translate="yes" xml:space="preserve">
          <source>Although the header &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; is based on the C standard library header &lt;code&gt;errno.h&lt;/code&gt;, the majority of the macros defined by &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; were adopted by C++ from the POSIX standard, rather than the C standard library.</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; はC標準ライブラリヘッダー &lt;code&gt;errno.h&lt;/code&gt; に基づいていますが、 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; で定義されているマクロの大部分は、C標準ライブラリではなく、POSIX標準のC ++で採用されています。</target>
        </trans-unit>
        <trans-unit id="3db5014665fd46dd8e252214316aa47507ad7ef2" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::tmpnam&lt;/code&gt; によって生成された名前は推測が困難ですが、 &lt;code&gt;std::tmpnam&lt;/code&gt; が戻った瞬間と、このプログラムが返された名前を使用してファイルを作成しようとする瞬間の間に、その名前のファイルが別のプロセスによって作成される可能性がありますファイル。標準関数 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; およびPOSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstempに&lt;/a&gt;はこの問題はありません（標準Cライブラリのみを使用して一意のディレクトリを作成するには、 &lt;code&gt;tmpnam&lt;/code&gt; を使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="9d5994bfdfeb1041b6398f05b2f8f3e33b52a975" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::tmpnam&lt;/code&gt; によって生成された名前を推測するのは困難ですが、 &lt;code&gt;std::tmpnam&lt;/code&gt; が返される瞬間から、このプログラムが返された名前を使用してファイル。標準関数 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; およびPOSIX関数&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstempに&lt;/a&gt;は、この問題はありません（標準Cライブラリのみを使用して一意のディレクトリを作成するには、引き続き &lt;code&gt;tmpnam&lt;/code&gt; を使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="c9f3db27755b0d585a653f2d5f3657aa1f21c81b" translate="yes" xml:space="preserve">
          <source>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランダムな起点のポインターを比較した結果（たとえば、すべてが同じ配列のメンバーを指しているわけではない）は特定されていませんが、多くの実装では、ポインターが連続した仮想アドレス空間内のアドレスとして実装されている場合など、ポインターの&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;完全な順序&lt;/a&gt;を提供しています。そうでない実装（たとえば、ポインタのすべてのビットがメモリアドレスの一部ではなく、比較のために無視する必要がある場合、または追加の計算が必要な場合、またはポインタと整数が1対1の関係ではない場合）は、 &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 特殊化は、それが保証されているポインタには適していません。これにより、 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; などの標準的な連想コンテナで、ランダムな原点のすべてのポインタをキーとして使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">戻り値の型は &lt;code&gt;char*&lt;/code&gt; ですが、ポイントされた文字を変更することは未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="1a131648c16bdab1f4ad67b397e73af609dc5ab0" translate="yes" xml:space="preserve">
          <source>Although the return type is not allowed in the declaration of a user-defined conversion function, the decl-specifier-seq of &lt;a href=&quot;declarations#Specifiers&quot;&gt;the declaration grammar&lt;/a&gt; may be present and may include any specifier other than type-specifier or the keyword static, In particular, besides &lt;code&gt;explicit&lt;/code&gt;, the specifiers &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;, &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;, and &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; are also allowed (note that &lt;code&gt;friend&lt;/code&gt; requires a qualified name: &lt;code&gt;friend A::operator B();&lt;/code&gt;).</source>
          <target state="translated">ユーザー定義の変換関数の宣言では戻り値の型は許可されていませんが&lt;a href=&quot;declarations#Specifiers&quot;&gt;、宣言文法&lt;/a&gt;のdecl-specifier-seq が存在する可能性があり、型指定子またはキーワードstatic以外の任意の指定子を含めることができます。 &lt;code&gt;explicit&lt;/code&gt; 、指定子&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;、&lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;、&lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;、および&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;も使用できます（ &lt;code&gt;friend&lt;/code&gt; には修飾名が必要です： &lt;code&gt;friend A::operator B();&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d77898594331af7d94d8805113c2ae7cc96df8a5" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">標準では、 &lt;code&gt;Elem&lt;/code&gt; のサイズが16ビットの場合にこのファセットがUCS2で機能することを要求していますが、一部の実装では代わりにUTF-16を使用しているため、これは非変換ロケールになります。「UCS2」という用語は廃止され、Unicode標準から削除されました。</target>
        </trans-unit>
        <trans-unit id="3eafdced96881df5338499ac356a8e8f50b8bc53" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">&lt;code&gt;Elem&lt;/code&gt; のサイズが16ビットの場合、規格ではこのファセットがUCS2で機能することが要求されていますが、一部の実装では代わりにUTF-16を使用しています。「UCS2」という用語は廃止され、Unicode標準から削除されました。</target>
        </trans-unit>
        <trans-unit id="a91bcce893b5de905ecbd22a99a03889cdcc2544" translate="yes" xml:space="preserve">
          <source>Always</source>
          <target state="translated">Always</target>
        </trans-unit>
        <trans-unit id="fe09758345685e241df672635cfac946bfc561d8" translate="yes" xml:space="preserve">
          <source>Always-throwing functions</source>
          <target state="translated">常投機能</target>
        </trans-unit>
        <trans-unit id="4df6b8083eb91bc6a923cb0c4bf5c1ae0e994985" translate="yes" xml:space="preserve">
          <source>Ambiguous and nonexistent local times can occur as a result of time zone transitions (such as daylight saving time). For example, &quot;2016-03-13 02:30:00&quot; does not exist in the &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; time zone, while &quot;2016-11-06 01:30:00&quot; in that time zone can correspond to two UTC time points: 2016-11-06 05:30:00 UTC and 2016-11-06 06:30:00 UTC.</source>
          <target state="translated">タイムゾーンの遷移（夏時間など）の結果として、あいまいで存在しない現地時間が発生する可能性があります。たとえば、「2016-03-13 02:30:00」は &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; タイムゾーンには存在しませんが、そのタイムゾーンの「2016-11-06 01:30:00」は2つのUTCに対応できますタイムポイント：2016-11-06 05:30:00 UTCおよび2016-11-06 06:30:00 UTC。</target>
        </trans-unit>
        <trans-unit id="c067979f83933e6c4d89a2c1e0fb562a0f280310" translate="yes" xml:space="preserve">
          <source>Ambiguous conversion sequences are ranked as user-defined conversion sequences because multiple conversion sequences for an argument can exist only if they involve different user-defined conversions:</source>
          <target state="translated">曖昧な変換シーケンスは、引数に対する複数の変換シーケンスは、それらが異なるユーザ定義の変換を含む場合にのみ存在することができるため、ユーザ定義の変換シーケンスとしてランク付けされます。</target>
        </trans-unit>
        <trans-unit id="5aa47b263945205f7df82cf554dee097502b0d78" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g.operator()&lt;/code&gt; の呼び出しの償却済み定数数。</target>
        </trans-unit>
        <trans-unit id="128bb665ca4a35fff2ef43cce127f6f8f60033b5" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; の一定数の呼び出しの償却</target>
        </trans-unit>
        <trans-unit id="1cbb525f8d6525a8ab447903dfd14ddbdc0818e6" translate="yes" xml:space="preserve">
          <source>Amortized constant on average, worst case linear in the size of the container.</source>
          <target state="translated">償却定数は平均で、最悪の場合は容器の大きさで線形。</target>
        </trans-unit>
        <trans-unit id="50471dc8ecc10f0a607efbdd965811e70e031a13" translate="yes" xml:space="preserve">
          <source>Amortized constant.</source>
          <target state="translated">償却定数です。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="45ea68905c72735578b243d8c992010c73dd2b71" translate="yes" xml:space="preserve">
          <source>An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of &lt;code&gt;digits10&lt;/code&gt; for an 8-bit type is 2 (&lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 2.41).</source>
          <target state="translated">8ビットのバイナリ型は、2桁の10進数を正確に表すことができますが、3桁の10進数256..999は表すことができません。8ビットタイプの &lt;code&gt;digits10&lt;/code&gt; の値は2です（ &lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; は2.41）。</target>
        </trans-unit>
        <trans-unit id="b70a29f58335fff2ae0f72bb6d64b3b5da9003ef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../language/type-id&quot;&gt;arithmetic type&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../language/type-id&quot;&gt;算術型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="807382b205cd61b4e07e059d92477e9e7b450d4d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; or deallocation function for a class is odr-used by a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt; appearing in a potentially-evaluated expression</source>
          <target state="translated">クラスの&lt;a href=&quot;../memory/new/operator_new&quot;&gt;割り当て&lt;/a&gt;または割り当て解除関数が、潜在的に評価された&lt;a href=&quot;new&quot;&gt;式に&lt;/a&gt;現れる新しい式によってodrで使用されている</target>
        </trans-unit>
        <trans-unit id="8d5b39fd5f28e44fd4cbe7c1a6e4527324fdb198" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;asm&quot;&gt;asm declaration&lt;/a&gt; does not define any entities, but it is classified as a definition.</source>
          <target state="translated">&lt;a href=&quot;asm&quot;&gt;ASMの宣言は、&lt;/a&gt;任意のエンティティを定義していませんが、それは定義として分類されています。</target>
        </trans-unit>
        <trans-unit id="d3db36c93422d5b474b182b8149fdd0c74f76e94" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; sequence attr may appear just before the label (in which case it applies to the label), or just before any statement itself, in which case it applies to the entire statement. A statement may carry multiple labels. Labels (and only labels) have &lt;a href=&quot;scope#Function_scope&quot;&gt;function scope&lt;/a&gt;. Labels are ignored by &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt;: a label can have the same name as any other entity in the program.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;シーケンスattrが、それは、文全体に適用された場合には、（それがラベルに適用された場合には）ちょうどラベルの前に現れ、あるいは単に任意の文自体の前にあります。ステートメントには複数のラベルを付けることができます。ラベル（およびラベルのみ）には&lt;a href=&quot;scope#Function_scope&quot;&gt;関数スコープがあり&lt;/a&gt;ます。&lt;a href=&quot;unqualified_lookup&quot;&gt;非修飾ルックアップで&lt;/a&gt;はラベルは無視されます。ラベルは、プログラム内の他のエンティティと同じ名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="67d8f4f0c409d53bf6fc239c4572103225de8737" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;explicit instantiation declaration&lt;/a&gt; (an &quot;extern template&quot;)</source>
          <target state="translated">&lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;明示的なインスタンス宣言&lt;/a&gt;（「のexternテンプレート」）</target>
        </trans-unit>
        <trans-unit id="e8d07ab60f03237d43aaac774ff0a48905536383" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;attribute declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;属性宣言&lt;/a&gt;（任意のエンティティを定義していません）</target>
        </trans-unit>
        <trans-unit id="8250bcb5d0e5dcdf0fb994dd06a03c09d7251e75" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;empty declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;空の宣言&lt;/a&gt;（任意のエンティティを定義していません）</target>
        </trans-unit>
        <trans-unit id="1cae5b3ce33128b19eacc0658479be44746e7c43" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;enum&quot;&gt;opaque declaration&lt;/a&gt; of an enumeration</source>
          <target state="translated">列挙の&lt;a href=&quot;enum&quot;&gt;不透明な宣言&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97e3c29d16d88a0e096a7e69f7173bded9fa122e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::const_iterator&lt;/code&gt;</source>
          <target state="translated">アン&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;そのカテゴリとタイプと同じであり &lt;code&gt;X::const_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf13631c6d364b349a268bbd81c204b7997b1947" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::iterator&lt;/code&gt;</source>
          <target state="translated">アン&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;そのカテゴリとタイプと同じであり &lt;code&gt;X::iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c036f0c614197c69e50ff0747f60db77d1ca80a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name&quot;&gt;identifier&lt;/a&gt; that names a non-type template parameter of class type &lt;code&gt;T&lt;/code&gt; denotes a static storage duration object of type &lt;code&gt;const T&lt;/code&gt;, called a</source>
          <target state="translated">&lt;a href=&quot;name&quot;&gt;識別子&lt;/a&gt;クラス型の名前非型テンプレートパラメータこと &lt;code&gt;T&lt;/code&gt; はタイプの静的記憶期間オブジェクトを表す &lt;code&gt;const T&lt;/code&gt; Aと呼ばれ、</target>
        </trans-unit>
        <trans-unit id="c6fbfbd5514da52daf4588bb104a4a85d038970e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name#In_expressions&quot;&gt;identifier expression&lt;/a&gt; that denotes an immediate function may only appear within a subexpression of an immediate invocation or within an immediate function context. A pointer or reference to an immediate function can be taken but cannot escape constant expression evaluation:</source>
          <target state="translated">&lt;a href=&quot;name#In_expressions&quot;&gt;識別子発現&lt;/a&gt;即時関数であるだけ即時呼び出しの部分式内または即時関数のコンテキスト内で表示されてもよいです。即時関数へのポインタまたは参照を取得できますが、定数式の評価をエスケープすることはできません。</target>
        </trans-unit>
        <trans-unit id="4835e23540157d178506c76dbed3585b131cd6c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; whose declaration is not a definition.</source>
          <target state="translated">&lt;a href=&quot;template_specialization&quot;&gt;明示的な特殊&lt;/a&gt;その宣言の定義ではありません。</target>
        </trans-unit>
        <trans-unit id="0476037f5a01ed84f4c68efe6578d34ee836c695" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;type_alias&quot;&gt;alias-declaration&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;エイリアス宣言&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec273bcf1f66db0db9b6197343f94ba32b5eec31" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; of function type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to that function&lt;/a&gt;. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</source>
          <target state="translated">関数型 &lt;code&gt;T&lt;/code&gt; の&lt;a href=&quot;value_category#lvalue&quot;&gt;左辺値&lt;/a&gt;は&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;、その関数&lt;/a&gt;への&lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue &lt;/a&gt;ポインタに暗黙的に変換できます。非静的メンバー関数を参照する左辺値が存在しないため、これは非静的メンバー関数には適用されません。</target>
        </trans-unit>
        <trans-unit id="7ba6cc034ab70817b81a34ed74af74dd8855a970" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; or &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; of type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot; or &quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; of type &quot;pointer to &lt;code&gt;T&lt;/code&gt;&quot;. If the array is a prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.(since C++17) The resulting pointer refers to the first element of the array (see &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;array to pointer decay&lt;/a&gt; for details).</source>
          <target state="translated">&lt;a href=&quot;value_category#lvalue&quot;&gt;左辺&lt;/a&gt;または&lt;a href=&quot;value_category#rvalue&quot;&gt;右辺値&lt;/a&gt;型「の配列の &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 」または「の結合未知の配列 &lt;code&gt;T&lt;/code&gt; は、」暗黙的に変換することができる&lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;タイプ「へのポインタの &lt;code&gt;T&lt;/code&gt; 」。配列がprvalueの場合、&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;一時的な実体化&lt;/a&gt;が発生します。（C ++ 17以降）結果のポインターは、配列の最初の要素を参照&lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;します&lt;/a&gt;（詳細については、配列からポインターへの減衰を参照）。</target>
        </trans-unit>
        <trans-unit id="3b75a307aa52c5825d1730c4cdd4f9a558685208" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; object containing the given values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 所定の値を含むオブジェクト。</target>
        </trans-unit>
        <trans-unit id="d6c35561be6c0db7de52088fd8b63305b7a7d8f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; holding a pointer to the beginning of the allocated storage and the number of objects that fit in the storage that was actually allocated.</source>
          <target state="translated">割り当てられたストレージの先頭へのポインタと、実際に割り当てられたストレージに収まるオブジェクトの数を保持する &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64c0acf093e82ca7c2d56259ef132c09f1d727d8" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; is a &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that holds an instance of an &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).</source>
          <target state="translated">AN &lt;strong&gt;AllocatorAwareContainerは、&lt;/strong&gt;ある&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt;のインスタンス保持&lt;a href=&quot;allocator&quot;&gt;アロケータ&lt;/a&gt;とそのすべてのメンバ関数でインスタンスが割り当てと割り当て解除メモリ及び構築すると、このようなオブジェクトが順序付けられていないコンテナのコンテナエレメント、ノード、または、であってもよい（すなわち、メモリ内のオブジェクトを破壊することに用途を、バケット配列）。</target>
        </trans-unit>
        <trans-unit id="eaa15e16e5ec0c95afc353328fbb4fb678121869" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AssociativeContainer&lt;/strong&gt; is an ordered &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that provides fast lookup of objects based on keys.</source>
          <target state="translated">アン&lt;strong&gt;AssociativeContainerは&lt;/strong&gt;命じている&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt;のキーに基づいてオブジェクトの高速検索を提供します。</target>
        </trans-unit>
        <trans-unit id="b5c5d4aca5ec3c0868d0e700b371604b1ec448c3" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; is an &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator &lt;code&gt;i&lt;/code&gt; has been incremented, all copies of its previous value may be invalidated.</source>
          <target state="translated">アン&lt;strong&gt;LegacyInputIteratorが&lt;/strong&gt;ある&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;尖った-に要素から読み取ることができます。LegacyInputIteratorsは、単一パス・アルゴリズムのための妥当性を保証する：LegacyInputIteratorたら、 &lt;code&gt;i&lt;/code&gt; その前の値のすべてのコピーを無効化することができ、増加しています。</target>
        </trans-unit>
        <trans-unit id="a021125aae1a0c5f6666fbd70ad3091d5eaf4be5" translate="yes" xml:space="preserve">
          <source>An UnformattedInputFunction is a stream input function that performs the following:</source>
          <target state="translated">UnformattedInputFunctionは、以下の処理を行うストリーム入力関数です。</target>
        </trans-unit>
        <trans-unit id="ce56470376a6a1e9f7a374ada94b689a0ac77bd6" translate="yes" xml:space="preserve">
          <source>An abstract class is a class that either defines or inherits at least one function for which &lt;a href=&quot;virtual&quot;&gt;the final overrider&lt;/a&gt; is pure virtual.</source>
          <target state="translated">抽象クラスは&lt;a href=&quot;virtual&quot;&gt;、最終的なオーバーライド&lt;/a&gt;が純粋に仮想である関数を少なくとも1つ定義または継承するクラスです。</target>
        </trans-unit>
        <trans-unit id="908b2d8b11e075496d08f7d7d4b01d8354d7a3e1" translate="yes" xml:space="preserve">
          <source>An additional class template &lt;code&gt;auto_ptr_ref&lt;/code&gt; is referred to throughout the documentation. It is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.</source>
          <target state="translated">追加のクラステンプレート &lt;code&gt;auto_ptr_ref&lt;/code&gt; は、ドキュメント全体で参照されます。これは、 &lt;code&gt;auto_ptr&lt;/code&gt; への参照を保持する実装定義型です。実装では、テンプレートに別の名前を付けたり、テンプレートを返したり、他の方法でパラメーターとして受け取ったりする関数を実装できます。</target>
        </trans-unit>
        <trans-unit id="492bf377c49f20efce1a6cebadb795c9f43e068d" translate="yes" xml:space="preserve">
          <source>An additional rule is applied to the deduction in this case: when comparing function parameters &lt;code&gt;P&lt;/code&gt;i and &lt;code&gt;A&lt;/code&gt;i, if any &lt;code&gt;P&lt;/code&gt;i is an rvalue reference to cv-unqualified template parameter (a &quot;forwarding reference&quot;) and the corresponding &lt;code&gt;A&lt;/code&gt;i is an lvalue reference, then &lt;code&gt;P&lt;/code&gt;i is adjusted to the template parameter type (T&amp;amp;&amp;amp; becomes T).</source>
          <target state="translated">この場合、追加のルールが控除に適用されます。関数パラメーター &lt;code&gt;P&lt;/code&gt; iと &lt;code&gt;A&lt;/code&gt; iを比較するとき、いずれかの &lt;code&gt;P&lt;/code&gt; iがcv非修飾テンプレートパラメーターへの右辺値参照（「転送参照」）であり、対応する &lt;code&gt;A&lt;/code&gt; iがlvalue参照の場合、 &lt;code&gt;P&lt;/code&gt; iはテンプレートパラメータタイプに調整されます（T &amp;amp;&amp;amp;はTになります）。</target>
        </trans-unit>
        <trans-unit id="39f1e2f1f4a1f2712c275be633629814179e5046" translate="yes" xml:space="preserve">
          <source>An aggregate class or array may include non-aggregate public bases(since C++17), members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</source>
          <target state="translated">集約クラスまたは配列には、非集約的な公開ベース(C++17 以降)、メンバー、または要素を含めることができ、これらは上述のように初期化されます(例えば、対応する初期化句からのコピー初期化)。</target>
        </trans-unit>
        <trans-unit id="b197d6cc29c7895c847275964c7060dca3357d57" translate="yes" xml:space="preserve">
          <source>An aggregate is one of the following types:</source>
          <target state="translated">アグリゲートは、次のいずれかのタイプです。</target>
        </trans-unit>
        <trans-unit id="12db35057383aa0593fc91fb24bea2072f9fc5b7" translate="yes" xml:space="preserve">
          <source>An algorithm to &quot;clamp&quot; a value between a pair of boundary values (&lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">境界値のペアの間の値を「クランプ」するアルゴリズム（ &lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6a4c8075a51ee48f2fc8e9678f381d4c2cc5cd9e" translate="yes" xml:space="preserve">
          <source>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The behavior is undefined if &lt;code&gt;Allocator::value_type&lt;/code&gt; is not the same as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">メモリを取得/解放し、そのメモリ内の要素を構築/破棄するために使用されるアロケータ。タイプは&lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;の要件を満たしている必要があります。 &lt;code&gt;Allocator::value_type&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; と同じでない場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="2b7e6c1744a360683380fca88796315c08727ff6" translate="yes" xml:space="preserve">
          <source>An allocator type &lt;code&gt;X&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt; additionally satisfies the</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のアロケータタイプ &lt;code&gt;X&lt;/code&gt; は、さらに</target>
        </trans-unit>
        <trans-unit id="8d97370574b17753b94ede73aa5e362da9eb3aac" translate="yes" xml:space="preserve">
          <source>An arithmetic type or a class emulating an arithmetic type</source>
          <target state="translated">算術型または算術型をエミュレートしたクラス</target>
        </trans-unit>
        <trans-unit id="c52cf5a897774b32a3cc4643437d36a5b1792813" translate="yes" xml:space="preserve">
          <source>An array can also be used as a tuple of &lt;code&gt;N&lt;/code&gt; elements of the same type.</source>
          <target state="translated">配列は、同じタイプの &lt;code&gt;N&lt;/code&gt; 要素のタプルとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="5ac3648865a50f77bee68245b1bc8d2b8af79b49" translate="yes" xml:space="preserve">
          <source>An array declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">配列宣言は、&lt;a href=&quot;declarations&quot;&gt;宣言子&lt;/a&gt;の形式を持つ単純な宣言です。</target>
        </trans-unit>
        <trans-unit id="f97a7d14a3134d2ce52774abf33446e4a447d088" translate="yes" xml:space="preserve">
          <source>An assignment operator in a class &lt;code&gt;T&lt;/code&gt; that is a member or base of another class &lt;code&gt;U&lt;/code&gt; is odr-used by an implicitly-defined copy-assignment or move-assignment functions of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">クラスの代入演算子 &lt;code&gt;T&lt;/code&gt; 別のクラスのメンバー又は塩基である &lt;code&gt;U&lt;/code&gt; は ODR-使用の暗黙的に定義されたコピー割り当てまたは移動割り当て関数である &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc87d164b8e7f6ecde4c668667f3c0239908e17" translate="yes" xml:space="preserve">
          <source>An associative container &lt;code&gt;X&lt;/code&gt; that is either &lt;code&gt;std::map&lt;/code&gt; and &lt;code&gt;std::multimap&lt;/code&gt; additionally supports the expression X::mapped_type, which has a return type of T, with the requirement that &lt;code&gt;T&lt;/code&gt; be &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and compile time complexity.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; と &lt;code&gt;std::multimap&lt;/code&gt; いずれかである連想コンテナ &lt;code&gt;X&lt;/code&gt; は、戻り値の型がTである式X :: mapped_typeを追加でサポートし、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;である必要があり、コンパイル時間が複雑になります。</target>
        </trans-unit>
        <trans-unit id="864fa04b4ed98eae74afcfaa9ef56bb780bc69ce" translate="yes" xml:space="preserve">
          <source>An asynchronous operation (created via &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;) can provide a &lt;code&gt;std::future&lt;/code&gt; object to the creator of that asynchronous operation.</source>
          <target state="translated">非同期操作（ &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 作成）は、その非同期操作の作成者に &lt;code&gt;std::future&lt;/code&gt; オブジェクトを提供できます。</target>
        </trans-unit>
        <trans-unit id="9e8f8230bc284edbfa18713cf06662ed31c603fb" translate="yes" xml:space="preserve">
          <source>An atomic &lt;a href=&quot;memory_order&quot;&gt;release operation&lt;/a&gt; X in thread A synchronizes-with an acquire fence F in thread B, if.</source>
          <target state="translated">スレッドA のアトミック&lt;a href=&quot;memory_order&quot;&gt;解放操作&lt;/a&gt; Xは、スレッドBの取得フェンスFと同期します。</target>
        </trans-unit>
        <trans-unit id="928fdce82eda51be195710313098b2223ec96c39" translate="yes" xml:space="preserve">
          <source>An atomic constraint consists of an expression &lt;code&gt;E&lt;/code&gt; and a mapping from the template parameters that appear within &lt;code&gt;E&lt;/code&gt; to template arguments involving the template parameters of the constrained entity, called its</source>
          <target state="translated">アトミック制約式で構成さ &lt;code&gt;E&lt;/code&gt; と内に表示されるテンプレートパラメータのマッピング &lt;code&gt;E&lt;/code&gt; のと呼ばれる拘束されたエンティティのテンプレートパラメータを含むテンプレート引数に、</target>
        </trans-unit>
        <trans-unit id="5a79829f8c7b85fe4e4638dfbea954acbd0eda02" translate="yes" xml:space="preserve">
          <source>An atomic operation A on some atomic object M is</source>
          <target state="translated">ある原子物体Mに対する原子操作Aは</target>
        </trans-unit>
        <trans-unit id="5a5310902368573c36e555b627b994b235e68248" translate="yes" xml:space="preserve">
          <source>An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: &lt;code&gt;[[expect_true]]&lt;/code&gt; could be an attribute that can only be used with an &lt;code&gt;if&lt;/code&gt;, and not with a class declaration. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; could be an attribute that applies to a code block or to a &lt;code&gt;for&lt;/code&gt; loop, but not to the type &lt;code&gt;int&lt;/code&gt;, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes).</source>
          <target state="translated">属性はC ++プログラムのほぼすべての場所で使用でき、型、変数、関数、名前、コードブロック、変換単位全体に適用できますが、特定の各属性はその属性でのみ有効です実装によって許可されています： &lt;code&gt;[[expect_true]]&lt;/code&gt; は、クラス宣言ではなく、 &lt;code&gt;if&lt;/code&gt; でのみ使用できる属性である可能性があります。 &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; は、コードブロックまたは &lt;code&gt;for&lt;/code&gt; ループに適用されるが、 &lt;code&gt;int&lt;/code&gt; 型などには適用されない属性である可能性があります（これら2つの属性は架空の例であり、以下の標準と一部の非標準属性）。</target>
        </trans-unit>
        <trans-unit id="3b30276e5eb22d8f2d82beaa0982183267864ede" translate="yes" xml:space="preserve">
          <source>An ellipsis &lt;code&gt;...&lt;/code&gt; may appear at the end of the parameter list; this declares a &lt;a href=&quot;variadic_arguments&quot;&gt;variadic function&lt;/a&gt;:</source>
          <target state="translated">省略記号 &lt;code&gt;...&lt;/code&gt; がパラメーターリストの最後に表示されることがあります。これは&lt;a href=&quot;variadic_arguments&quot;&gt;可変関数を&lt;/a&gt;宣言します：</target>
        </trans-unit>
        <trans-unit id="7b28c53044424dbd671a0a292fff9b11ed2f240c" translate="yes" xml:space="preserve">
          <source>An empty path can be obtained by calling &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; and by default-constructing a &lt;code&gt;path&lt;/code&gt;. It can also be returned by a path decomposition function (such as &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension&lt;/code&gt;&lt;/a&gt;) if the corresponding component is not present in the path.</source>
          <target state="translated">空のパスを取得するには、&lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;を呼び出し、デフォルトで &lt;code&gt;path&lt;/code&gt; 作成します。また、対応するコンポーネントがパスに存在しない場合、パス分解関数（&lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension&lt;/code&gt; &lt;/a&gt;など）によって返されることもあります。</target>
        </trans-unit>
        <trans-unit id="2ecc5a9f5ce0682a542e5d3a7d4ffa7f954c9836" translate="yes" xml:space="preserve">
          <source>An empty path is classified as a relative path.</source>
          <target state="translated">空のパスは相対パスに分類されます。</target>
        </trans-unit>
        <trans-unit id="96c80c138bff7aa336c0c80903e065616c06546c" translate="yes" xml:space="preserve">
          <source>An empty range is lexicographically</source>
          <target state="translated">空の範囲は語彙的に</target>
        </trans-unit>
        <trans-unit id="c5d73f72c6721b75502428576903171289a2fc14" translate="yes" xml:space="preserve">
          <source>An empty shared_ptr (where &lt;code&gt;use_count() == 0&lt;/code&gt;) may store a non-null pointer accessible by &lt;code&gt;get()&lt;/code&gt;, e.g. if it were created using the aliasing constructor.</source>
          <target state="translated">空のshared_ptr（ &lt;code&gt;use_count() == 0&lt;/code&gt; ）は、たとえばエイリアスコンストラクタを使用して作成された場合など、 &lt;code&gt;get()&lt;/code&gt; によってアクセス可能なnull以外のポインタを格納できます。</target>
        </trans-unit>
        <trans-unit id="bf3e0e6688aa2181023a253a9e87db009478a78e" translate="yes" xml:space="preserve">
          <source>An empty string if the character sequence is not a valid collating element</source>
          <target state="translated">文字列が有効な照合要素でない場合は空文字列。</target>
        </trans-unit>
        <trans-unit id="3d82664471aad182109ca58741b1d45d1271d6cf" translate="yes" xml:space="preserve">
          <source>An enumeration is defined by</source>
          <target state="translated">列挙は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="afe5baa45aa238529a9d9f5521326fb55bc4227f" translate="yes" xml:space="preserve">
          <source>An equivalent effect may be achieved with the facilities provided by &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; によって提供される機能を使用して、同等の効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="26b27f109fdc73d104fb47c91bb0233ff5e7c5ad" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares every member of a class, except in order that is different from the default (here: last name first).</source>
          <target state="translated">&lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt;を返すカスタム演算子&amp;lt;=&amp;gt;の例は、デフォルト（ここでは姓が最初）とは異なる順序を除いて、クラスのすべてのメンバーを比較する演算子です。</target>
        </trans-unit>
        <trans-unit id="e794383d64707bd6aee1a7ffa3033ac34c3317b6" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares string members of a class in case-insensitive manner: this is different from the default comparison (so a custom operator is required) and it's possible to distinguish two strings that compare equal under this comparison.</source>
          <target state="translated">&lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt;を返すカスタム演算子&amp;lt;=&amp;gt;の例は、大文字と小文字を区別しない方法でクラスの文字列メンバーを比較する演算子です。これはデフォルトの比較とは異なり（したがって、カスタム演算子が必要です）、次のことが可能です。この比較で等しいと比較する2つの文字列を区別します。</target>
        </trans-unit>
        <trans-unit id="bc3fdebc617a723576859b7b78597b5a6e61e62e" translate="yes" xml:space="preserve">
          <source>An example of a type that implements LegacyOutputIterator is &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std::ostream_iterator&lt;/a&gt;.</source>
          <target state="translated">LegacyOutputIteratorを実装する型の例は&lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std :: ostream_iterator&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="831c258222c425472a6e48db4facf3170a3cef28" translate="yes" xml:space="preserve">
          <source>An example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; using virtual inheritance. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; is derived from both &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;, so every instance of &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contains a &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobject, a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobject, and just one &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobject (and, consequently, one &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">仮想基本クラスの継承階層の例は、標準ライブラリのiostream階層です &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; は、仮想継承を使用して &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; から派生しています。 &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 由来する両方 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; のすべてのインスタンスに &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 含ま &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; サブオブジェクト、A &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; サブオブジェクトとをひとつ &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; サブオブジェクト（その結果、1つの &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41464d61485a2aac603dadcdf39c0ce3781751e5" translate="yes" xml:space="preserve">
          <source>An example of when such declaration is used is the implementation of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">そのような宣言が使用される場合の例は、 &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt; 実装です。</target>
        </trans-unit>
        <trans-unit id="bdba113faa387d1ab71c87afef4ec469f4cc925c" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">intを返す &lt;code&gt;uncaught_exceptions&lt;/code&gt; が使用される例は、&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt;ライブラリです。式 &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; 最初にガードオブジェクトを作成し、キャッチされなかった例外の数をコンストラクターに記録します。出力は、foo（）がスローしない限り、ガードオブジェクトのデストラクタによって実行されます（この場合、デストラクタで捕捉されなかった例外の数は、コンストラクタが監視した数よりも多くなります）。</target>
        </trans-unit>
        <trans-unit id="3c376fdb08a2c546d5e0e5f8f44feb92df5bc392" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">intを返す &lt;code&gt;uncaught_exceptions&lt;/code&gt; が使用される例は、&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt;ライブラリです。式 &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; 最初にガードオブジェクトを作成し、キャッチされなかった例外の数をコンストラクターに記録します。foo（）がスローされない限り、出力はガードオブジェクトのデストラクタによって実行されます（この場合、デストラクタでキャッチされなかった例外の数は、コンストラクタが観察した数よりも多くなります）。</target>
        </trans-unit>
        <trans-unit id="2b085b3ecbb54c70910e25f3896da20b2a187a73" translate="yes" xml:space="preserve">
          <source>An exception can be thrown by a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;, and any of the standard library functions that are specified to throw exceptions to signal certain error conditions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt;, etc).</source>
          <target state="translated">例外は、&lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;、&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;、&lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;、&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;、&lt;a href=&quot;../memory/new/operator_new&quot;&gt;割り当て関数&lt;/a&gt;、および特定のエラー条件を通知するために例外をスローするように指定されている標準ライブラリ関数（例： &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="734db5e27654b7a1a090879aa79155ed3b4b2a8b" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;*this&lt;/code&gt; has no shared state or &lt;code&gt;get_future&lt;/code&gt; has already been called. To get multiple &quot;pop&quot; ends of the promise-future communication channel, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に共有状態がない場合、または &lt;code&gt;get_future&lt;/code&gt; がすでに呼び出されている場合は、例外がスローされます。promise-futureコミュニケーションチャネルの複数の「ポップ」エンドを取得するには、 &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="44db7b4c1aff9b2986166f1068a5b7109c799860" translate="yes" xml:space="preserve">
          <source>An exception is thrown if there is no shared state or the shared state already stores a value or exception.</source>
          <target state="translated">共有状態が存在しない場合や、共有状態が既に値や例外を格納している場合に例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="400934141b26ebdcfa01b232809e28da4e1614d3" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; if the requested facet does not exist in the locale.</source>
          <target state="translated">このタイプの例外は、参照タイプへの&lt;a href=&quot;../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt;がランタイムチェックに失敗した場合（たとえば、タイプが継承によって関連付けられていないため）、要求されたファセットがロケールに存在しない場合は &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; からもスローされます。</target>
        </trans-unit>
        <trans-unit id="3e10eeb3d50b8941ecde1bf2d5b08ad5eba672d1" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator is applied to a dereferenced null pointer value of a polymorphic type.</source>
          <target state="translated">この型の例外は、&lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt;演算子が多相型の逆参照されたnullポインター値に適用された場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="392a7913172c4bf28f4342b2ce3e240403f2f75f" translate="yes" xml:space="preserve">
          <source>An explanatory message for the stored error code and error category.</source>
          <target state="translated">保存されているエラーコードとエラーカテゴリの説明メッセージ。</target>
        </trans-unit>
        <trans-unit id="d5eabc2515cac7175770538d9fd2aca675f84744" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.</source>
          <target state="translated">明示的なインスタンス化宣言(extern テンプレート)は暗黙のインスタンス化を防ぎます。</target>
        </trans-unit>
        <trans-unit id="33cd7a0177e9f7ec5c231dde735e35e1a0d3fb00" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.</source>
          <target state="translated">明示的なインスタンス化宣言(extern テンプレート)は、暗黙のインスタンス化ステップをスキップします。これは、テンプレートのインスタンス化を使用しているソースファイルのうち1つ以外のすべてで明示的に宣言し、残りのファイルで明示的に定義することで、コンパイル時間を短縮するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="133c2fb50577da662edeff998e62d6b70b901935" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the entire program.</source>
          <target state="translated">明示的なインスタンス化定義は、それらが参照するクラス、構造体、またはユニオンのインスタンス化を強制します。これは、テンプレート定義の後のプログラム内のどこにでも現れることができ、与えられた引数リストに対しては、プログラム全体で一度だけ現れることが許されています。</target>
        </trans-unit>
        <trans-unit id="c3fb00f7b63425b442d1cc0c31f1edb4322117c1" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.</source>
          <target state="translated">明示的なインスタンス化定義は、それらが参照する関数またはメンバ関数のインスタンス化を強制します。この定義は、テンプレート定義の後のプログラム内のどこにでも現れることができ、与えられた引数リストに対しては、プログラム内に一度だけ現れることが許されています。</target>
        </trans-unit>
        <trans-unit id="c9c128e72c9b832e8384315ba572027dc359efd3" translate="yes" xml:space="preserve">
          <source>An explicit specialization cannot be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">明示的な特化は&lt;a href=&quot;friend&quot;&gt;フレンド宣言に&lt;/a&gt;はなりません。</target>
        </trans-unit>
        <trans-unit id="5a4ebeb793310cf18619b24eeafbc2e6fd5d0c1f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a function template is inline only if it is declared with the &lt;a href=&quot;inline&quot;&gt;inline specifier&lt;/a&gt; (or defined as deleted), it doesn't matter if the primary template is inline.</source>
          <target state="translated">関数テンプレートの明示的な特殊化は、&lt;a href=&quot;inline&quot;&gt;インライン指定子で&lt;/a&gt;宣言された（または削除されたものとして定義された）場合にのみインラインで行われ、プライマリテンプレートがインラインであるかどうかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="ad7859780f7fda205f962953901c88030d43e65f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. These definitions must use braces for default initialization:</source>
          <target state="translated">テンプレートの静的データ・メンバの明示的な特殊化は、宣言にイニシャライザが含まれている場合は定義となり、そうでない場合は宣言となります。これらの定義は、デフォルトの初期化のために中括弧を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f5646484a04d1f69f62bdf5309c5a9d249438cc5" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">式 &lt;code&gt;e&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="11f8c98f192821781cccabf62455469b73d17864" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">式 &lt;code&gt;e&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">式の後にセミコロンが続くものが文です。</target>
        </trans-unit>
        <trans-unit id="f703e5af31c537ec73c27f6089a222ac20a91c8b" translate="yes" xml:space="preserve">
          <source>An expression is</source>
          <target state="translated">式は</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">式は</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">式のない式文は</target>
        </trans-unit>
        <trans-unit id="ba931ef941c10e68e24584826bf3e7b5e908486f" translate="yes" xml:space="preserve">
          <source>An expression that designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; (e.g. &lt;code&gt;a.m&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an lvalue of type &lt;code&gt;struct A { int m: 3; }&lt;/code&gt;) is an lvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference can be initialized from a bit-field lvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;ビットフィールド&lt;/a&gt;を指定する式（たとえば、 &lt;code&gt;a.m&lt;/code&gt; 、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;struct A { int m: 3; }&lt;/code&gt; の左辺値）は左辺値式です。代入演算子の左側のオペランドとして使用できますが、アドレスを取得できず、非const lvalue参照をそれにバインドできません。const lvalue参照はビットフィールドlvalueから初期化できますが、ビットフィールドの一時的なコピーが作成されます。ビットフィールドに直接バインドされません。</target>
        </trans-unit>
        <trans-unit id="95fcc97496d0a23551b56ed465f2ec32a136ce51" translate="yes" xml:space="preserve">
          <source>An identifier can be used &lt;a href=&quot;declarations&quot;&gt;to name&lt;/a&gt; objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:</source>
          <target state="translated">識別子を使用&lt;a href=&quot;declarations&quot;&gt;して&lt;/a&gt;、オブジェクト、参照、関数、列挙子、型、クラスメンバー、名前空間、テンプレート、テンプレート特殊化、パラメーターパック、gotoラベル、およびその他のエンティティに名前を付けることができますが、以下の例外があります。</target>
        </trans-unit>
        <trans-unit id="f6eb1c54d1e440abd120bdddffed4feee0d07b20" translate="yes" xml:space="preserve">
          <source>An identifier that names a variable, a function, specialization of a &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) or an enumerator can be used as an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;. The result of an expression consisting of just the identifier is the entity named by the identifier. The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the expression is</source>
          <target state="translated">変数、関数、&lt;a href=&quot;constraints&quot;&gt;概念の&lt;/a&gt;特殊化（C ++ 20以降）または列挙子を指定する識別子を&lt;a href=&quot;expressions&quot;&gt;式&lt;/a&gt;として使用できます。識別子のみで構成される式の結果は、識別子によって名前が付けられたエンティティです。式の&lt;a href=&quot;value_category&quot;&gt;値のカテゴリ&lt;/a&gt;は</target>
        </trans-unit>
        <trans-unit id="2bea22f245aad6a1bbd96dbe721e6bfbb9cba55e" translate="yes" xml:space="preserve">
          <source>An immediate function is a constexpr function, and must satisfy the requirements applicable to &lt;a href=&quot;constexpr&quot;&gt;constexpr functions or constexpr constructors&lt;/a&gt;, as the case may be.</source>
          <target state="translated">即時関数はconstexpr関数であり、場合によっては&lt;a href=&quot;constexpr&quot;&gt;constexpr関数またはconstexprコンストラクター&lt;/a&gt;に適用可能な要件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="252a155693a85c4513362e41870c607628599139" translate="yes" xml:space="preserve">
          <source>An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary components, and must ensure that the class template specialization does not contain any padding. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to &lt;code&gt;value_type&lt;/code&gt; may be aliasing a &lt;code&gt;std::complex&lt;/code&gt; specialization or array thereof.</source>
          <target state="translated">実装は、実数部と虚数部から切り離されたストレージを占有する追加の非静的データメンバーを宣言できず、クラステンプレートの特殊化にパディングが含まれていないことを確認する必要があります。実装では、 &lt;code&gt;value_type&lt;/code&gt; へのポインタが &lt;code&gt;std::complex&lt;/code&gt; 特殊化またはその配列にエイリアスを設定している可能性を考慮して、配列アクセスの最適化も考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="b36215737bc9acc94a1181b9b9fc0edbe7c6e8eb" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">ユーザー定義型の &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="5f56c2af44fa6aea68d66ab4f981e253c1870786" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">ユーザー定義型の &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="8e1b5b99aec49dc279b82a189df1e4e71765f759" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">球面調和関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;boost.math&lt;/a&gt;で使用でき、パラメーターphiをゼロに設定して呼び出されると、この関数に削減されます。</target>
        </trans-unit>
        <trans-unit id="6ef6f4ff8cf4b3091eca3ca55f5f34c2dba25629" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">球面調和関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;boost.math&lt;/a&gt;で利用可能であり、パラメーターphiをゼロに設定して呼び出されるとこの関数になります。</target>
        </trans-unit>
        <trans-unit id="05f3d51d05cc3d2c938b7773b2a75528f0f533a8" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="e8a80dd8b49b57fd0af28cb5b6f9eab92b003670" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="463a45be898237901d9e95795630e24b7725815f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="a328d339a02fcd8f09757618757e341adcf6caf4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="05afb78eee87d60d6affed2bb5d378e94152fda4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="14e04477fae2c219d4ca4910e671ec277e96650f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="23aab2406e44d22254e76892b9bb67f949035f8f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="6d6d6fb65c08ea8df15db6341e3a63d4c3b1cb08" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="a8f1f0a1677f6760e20f47ca31a1260d73446bbf" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="172a3359b3bc94067fe1ce4e3994c6fccab63962" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="c3f9ea786832c07ac6ee8f2a1cf1bab37d07067f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="023d43dc101a8f0e0055a1bbe7ca05f32647f8f2" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="1416c6c581d2a16bec76ecd9c479fdd72d0c8646" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="b7a97e935596f5c5ad772a94c524a08ecf79d480" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;、boost.math&lt;/a&gt;で &lt;code&gt;boost::math::legendre_p&lt;/code&gt; としても使用できますが、boost.mathの定義にCondon-Shortley位相項が含まれている点が異なります。</target>
        </trans-unit>
        <trans-unit id="1b94dc33e3c2677817a24c87c5ae3eefdf3888b7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="a4376b52a3b698d01342890c645e63be771774af" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="b60467ab6c0631a5664cf0494d5a0ca49e6e52f1" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="52edf4f2bf1751043ad31c41a6c11b35f270bfcb" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="5a7b5eda0bb25aa403ce524620df1896aebc5bcd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="5aeeb2ecef2e098cd110869669dbedfb641d1e82" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="b4bbb817d2363546432c72ec47562034e62b930c" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="f5bcaa2e77d6da4f3fa4ce84e311bb065df9b7be" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="583558c1ff06b0561d4406d21632ee55c2b6f356" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="2c47a9490a77b892440d4dd4af49e877b2a9df1a" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="659dcb29046fa05710b38a8fb1931ec898ae5519" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="bf8d66df175707d6c72a60a41c20ae8c99e0d86e" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="39da4171238400ac3f8feb8e52e5f753d1bd1fb7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="dbdbc8151f3002ecfb8833c5c5c3125beb8e1447" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="4e14b6f00e0b4e1eb1ae3b23159f9339d5a211c3" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">この関数の実装は、boost.math定義にCondon-Shortley位相項が含まれていることを除いて、 &lt;code&gt;boost::math::legendre_p&lt;/code&gt; として&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;boost.math&lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="dde4c238b03e2f7efad8438d5c040e7628566cfd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;、boost.math&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="6484905546dbda0376c3234e4af32b4774ac948c" translate="yes" xml:space="preserve">
          <source>An incompletely-defined object type can be completed:</source>
          <target state="translated">未定義のオブジェクト型が完成することがあります。</target>
        </trans-unit>
        <trans-unit id="034496cba173d751719f86a31427ebfaf5a3c429" translate="yes" xml:space="preserve">
          <source>An inline namespace is a namespace that uses the optional keyword &lt;code&gt;inline&lt;/code&gt; in its</source>
          <target state="translated">インライン名前空間は、オプションのキーワード &lt;code&gt;inline&lt;/code&gt; をその中で使用する名前空間です。</target>
        </trans-unit>
        <trans-unit id="14113ff7972f0e79ae2bcb3f11df635a03888186" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the copy of &lt;code&gt;e&lt;/code&gt;, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">インスタンス &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; のコピーへの参照を保持して &lt;code&gt;e&lt;/code&gt; 、またはインスタンスに &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; またはインスタンスへ &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; （参照 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ba236b1f1a8d82abf0083dac8c36782f2303388c" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the exception object, or a copy of the exception object, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">インスタンス &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 例外オブジェクト、または例外オブジェクトのコピーへの参照を保持する、またはインスタンスに &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; またはインスタンスへ &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">この呼び出しの後にストリームがワイド指向の場合は0より大きく、この呼び出しの後にストリームがバイト指向の場合は0より小さく、ストリームが無指向の場合は0より大きい整数。</target>
        </trans-unit>
        <trans-unit id="27a4b795995133a65c00f00e3a5c86747c696bf8" translate="yes" xml:space="preserve">
          <source>An integer literal is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt; of the form.</source>
          <target state="translated">整数リテラルは、フォームの&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;主要な式&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">シグナルによる非同期割り込みがあっても、アトミックエンティティとしてアクセスできる整数型。</target>
        </trans-unit>
        <trans-unit id="5018516b14deb056aa79dc2efd7d50ff7637de58" translate="yes" xml:space="preserve">
          <source>An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">(現在の C ロケールでは)無効なマルチバイト文字が検出されました。</target>
        </trans-unit>
        <trans-unit id="6a1cb2e740b1d006f9942d3f948b281b6ec84075" translate="yes" xml:space="preserve">
          <source>An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">（現在のCロケールによる）無効なマルチバイト文字が検出されました。 &lt;code&gt;src&lt;/code&gt; は、変換されていない最初のマルチバイト文字の先頭を指すように設定されます。</target>
        </trans-unit>
        <trans-unit id="e0fbbc7a96cda105d7e43e6ea9e384c88eb8bd01" translate="yes" xml:space="preserve">
          <source>An invalid simple-template-id is a compile-time error, unless it names a function template specialization (in which case &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; may apply).</source>
          <target state="translated">無効なsimple-template-idは、関数テンプレートの特殊化を指定しない限り、コンパイル時エラーです（この場合、&lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;が適用される場合があります）。</target>
        </trans-unit>
        <trans-unit id="738a0c3fdce4b2a8db1475951201c5a23036b195" translate="yes" xml:space="preserve">
          <source>An invariant of &lt;code&gt;zoned_time&lt;/code&gt; is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, &lt;code&gt;zoned_time&lt;/code&gt; has no move constructor or move assignment operator; attempts to move a &lt;code&gt;zoned_time&lt;/code&gt; will perform a copy.</source>
          <target state="translated">&lt;code&gt;zoned_time&lt;/code&gt; の不変条件は、常に有効なタイムゾーンを参照し、そのタイムゾーン内の既存の明確な時点を表すことです。この不変 &lt;code&gt;zoned_time&lt;/code&gt; と一致して、zoned_timeには移動コンストラクターも移動割り当て演算子もありません。 &lt;code&gt;zoned_time&lt;/code&gt; を移動しようとすると、コピーが実行されます。</target>
        </trans-unit>
        <trans-unit id="ff8ec771a3e408dd089882b2303398b60f16d16a" translate="yes" xml:space="preserve">
          <source>An invocation of an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; is always evaluated, even in an unevaluated operand.</source>
          <target state="translated">&lt;a href=&quot;consteval&quot;&gt;即時関数&lt;/a&gt;の呼び出しは、未評価のオペランドであっても常に評価されます。</target>
        </trans-unit>
        <trans-unit id="30e4b56dc9d38cfe9d66956b6e4aed328bf1c204" translate="yes" xml:space="preserve">
          <source>An invocation of an immediate function whose innermost non-block scope is not a &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;function parameter scope&lt;/a&gt; of an immediate function must produce a constant expression; such an invocation (known as an</source>
          <target state="translated">最も内側の非ブロックスコープが即時関数の&lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;関数パラメータースコープ&lt;/a&gt;ではない即時関数の呼び出しは、定数式を生成する必要があります。そのような呼び出し（として知られています</target>
        </trans-unit>
        <trans-unit id="4706ad1f00d621a48d2e07b2a350e165dc71b6e6" translate="yes" xml:space="preserve">
          <source>An iterator pointing at the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; と同じオブジェクトを指すイテレータ。</target>
        </trans-unit>
        <trans-unit id="7ef94e98b9aecdcf5a48dda0b6d175cdca4869ff" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character produced.</source>
          <target state="translated">生成された最後の文字の直後を指すイテレータ。</target>
        </trans-unit>
        <trans-unit id="a6f7df894c8448a1c11979a004ebd6ace3d75b98" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character recognized as a valid part of the monetary string input.</source>
          <target state="translated">入力された通貨文字列の有効部分として認識された最後の文字の直後を指すイテレータ。</target>
        </trans-unit>
        <trans-unit id="2ae3748a0356e1b6e535e66f5c4ffa0cfaff3539" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the element following the erased element, or &lt;code&gt;end()&lt;/code&gt; if no such element exists.</source>
          <target state="translated">消去された要素に続く要素を指すイテレータ、またはそのような要素が存在しない場合は &lt;code&gt;end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e831682f27c4215fd3d51adc3ab282760afa70fa" translate="yes" xml:space="preserve">
          <source>An iterator referring to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the container.</source>
          <target state="translated">&lt;code&gt;std::chrono::tzdb&lt;/code&gt; 内の最初のstd :: chrono :: tzdbを参照するイテレーター。</target>
        </trans-unit>
        <trans-unit id="7a63b694e4a7d314c8d05c5417ebc4bb1f31eb30" translate="yes" xml:space="preserve">
          <source>An iterator to the beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; の先頭への反復子。</target>
        </trans-unit>
        <trans-unit id="02479c246c44225a9035a0d45997e83cce8420db" translate="yes" xml:space="preserve">
          <source>An iterator to the end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;. Note that the end of a container or array is defined as the element following the last valid element.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; 末尾への反復子。コンテナまたは配列の終わりは、最後の有効な要素に続く要素として定義されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a11a64a7066be12c5192b1c7d9f47275f39b47d8" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; の逆始まりのイテレーター。</target>
        </trans-unit>
        <trans-unit id="e7197d58fc54a43b495f2accaea0f6922ad829bd" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; の逆端のイテレーター。</target>
        </trans-unit>
        <trans-unit id="625c5f2464c30593f74840f1bd907c2068776afc" translate="yes" xml:space="preserve">
          <source>An iterator type whose category, value, difference, pointer and</source>
          <target state="translated">カテゴリ、値、差分、ポインタ、および</target>
        </trans-unit>
        <trans-unit id="19a75628cf6442d77f6648e9556c5bb263d28280" translate="yes" xml:space="preserve">
          <source>An lvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an lvalue reference&lt;/a&gt;; this associates a new name with the object identified by the expression.</source>
          <target state="translated">左辺値は&lt;a href=&quot;reference_initialization&quot;&gt;、左辺値参照&lt;/a&gt;を初期化するために使用できます。これにより、式によって識別されるオブジェクトに新しい名前が関連付けられます。</target>
        </trans-unit>
        <trans-unit id="ca62ca28732e81cc9d1b6aa1ed666a055a48eb41" translate="yes" xml:space="preserve">
          <source>An object can contain other objects, which are called</source>
          <target state="translated">オブジェクトは、他のオブジェクトを含むことができます。</target>
        </trans-unit>
        <trans-unit id="83df7119bca64cfa6a0dedb8658d0ab00a4eaf95" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_istream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless &lt;code&gt;noskipws&lt;/code&gt; flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input.</source>
          <target state="translated">クラス &lt;code&gt;basic_istream::sentry&lt;/code&gt; のオブジェクトは、入力（フォーマット済みとフォーマットなしの両方）を実行する &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; の各メンバー関数の先頭にあるローカルスコープで構築されます。そのコンストラクターは入力ストリームを準備します：ストリームがすでに &lt;code&gt;noskipws&lt;/code&gt; 状態にあるかどうかを確認し、tie（）で出力ストリームをフラッシュし、noskipwsフラグが設定されていない限り先頭の空白をスキップし、必要に応じて他の実装定義タスクを実行します。必要に応じて、すべてのクリーンアップはデストラクタで実行されるため、入力中に例外がスローされた場合に実行されることが保証されます。</target>
        </trans-unit>
        <trans-unit id="823634b581a9cede4fd0ccc574bd7fa0bc24d634" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_ostream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output.</source>
          <target state="translated">クラス &lt;code&gt;basic_ostream::sentry&lt;/code&gt; のオブジェクトは、出力（フォーマット済みとフォーマットなしの両方）を実行する &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; の各メンバー関数の先頭にあるローカルスコープで構築されます。そのコンストラクターは、出力ストリームを準備します。ストリームが既に障害状態にあるかどうかを確認し、tie（）で出力ストリームをフラッシュし、必要に応じて他の実装定義のタスクを実行します。実装によって定義されたクリーンアップ、および必要に応じて出力ストリームのフラッシュがデストラクタで実行されるため、出力中に例外がスローされた場合に必ず実行されます。</target>
        </trans-unit>
        <trans-unit id="0455f9161322806dadb1a5a0172793f044ae30ea" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;std::locale&lt;/code&gt; is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an &lt;code&gt;std::locale&lt;/code&gt; object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.</source>
          <target state="translated">クラス &lt;code&gt;std::locale&lt;/code&gt; のオブジェクトは、不変のインデックス付きの不変のファセットのセットです。C ++入出力ライブラリの各ストリームオブジェクトは &lt;code&gt;std::locale&lt;/code&gt; オブジェクトに関連付けられ、すべてのデータの解析とフォーマットにそのファセットを使用します。さらに、各 &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; オブジェクトにはロケールオブジェクトが関連付けられています。Localeオブジェクトは、標準のコンテナーおよびアルゴリズムで文字列照合を実行する述語として使用することもでき、それらに保持されているファセットを取得または変更するために直接アクセスできます。</target>
        </trans-unit>
        <trans-unit id="d66af98d41f06cecefd4af58c7d9c0ca924bcff6" translate="yes" xml:space="preserve">
          <source>An object of the type must be contextually convertible to bool. The effect of this conversion returns false if the value is equivalent to its null value and true otherwise.</source>
          <target state="translated">この型のオブジェクトは、文脈上、boolに変換可能でなければなりません。この変換の効果は、値がそのnull値と同等であればfalseを返し、そうでなければtrueを返します。</target>
        </trans-unit>
        <trans-unit id="7bacce28d1059e82c9739033111e220b4d8671d7" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; &amp;lt;double&amp;gt;のオブジェクト</target>
        </trans-unit>
        <trans-unit id="f0e2760523dc7073d44af20a277e7f5a90698df4" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;&amp;lt;value_type&amp;gt;</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &amp;lt;value_type&amp;gt; のオブジェクト</target>
        </trans-unit>
        <trans-unit id="7bd18a30dbdab573b7c39639752708407fb37b52" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;To&lt;/code&gt; whose value representation is as described above.</source>
          <target state="translated">値の表現が上記のとおりである &lt;code&gt;To&lt;/code&gt; タイプのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="e81f259c6d82e8e50d80fae74008b6a20cb6f607" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;X::value_compare&lt;/code&gt; constructed out of the comparison object is returned.</source>
          <target state="translated">比較オブジェクトから構築された &lt;code&gt;X::value_compare&lt;/code&gt; タイプのオブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="7cce6a193570a048de83246c7b511f63641f001b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; is a lightweight proxy object that provides access to an array of objects of type &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; のオブジェクトは、タイプ &lt;code&gt;const T&lt;/code&gt; のオブジェクトの配列へのアクセスを提供する軽量プロキシオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="9033aa603f097747fd262291447f23ece9703946" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::once_flag&lt;/code&gt; that is passed to multiple calls to &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; allows those calls to coordinate with each other such that only one of the calls will actually run to completion.</source>
          <target state="translated">&lt;code&gt;std::once_flag&lt;/code&gt; への複数の呼び出しに渡されるタイプstd :: once_flagのオブジェクトを使用すると、これらの呼び出しを相互に調整して、1つの呼び出しだけが実際に &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; まで実行されるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="3bdae20fade93232b05ba74a9d73283a7dcdf8dd" translate="yes" xml:space="preserve">
          <source>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; when unpacking a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, as a placeholder for the arguments that are not used.</source>
          <target state="translated">指定されていないタイプのオブジェクトで、値を割り当てても効果はありません。使用されない引数のプレースホルダーとして、 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; アンパックするときに &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; で使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="26b9967510dc89a341fa42ca83cfa44ef6ebf576" translate="yes" xml:space="preserve">
          <source>An object that is not a subobject of another object is called</source>
          <target state="translated">他のオブジェクトのサブオブジェクトではないオブジェクトを</target>
        </trans-unit>
        <trans-unit id="858015fdff20dfb1bcca98de775349cd0072b086" translate="yes" xml:space="preserve">
          <source>An object, in C++, is a</source>
          <target state="translated">オブジェクトは、C++では</target>
        </trans-unit>
        <trans-unit id="2f63388a843dce76eb6b22f8810249f3b38a691e" translate="yes" xml:space="preserve">
          <source>An optional object &lt;code&gt;op&lt;/code&gt; may be turned into an empty optional with both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt;. The first expression constructs an empty &lt;code&gt;optional&lt;/code&gt; object with &lt;code&gt;{}&lt;/code&gt; and assigns it to &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">オプションのオブジェクト &lt;code&gt;op&lt;/code&gt; は、 &lt;code&gt;op = {};&lt;/code&gt; 両方で空のオプションに変換できます。および &lt;code&gt;op = nullopt;&lt;/code&gt; 。最初の式は、 &lt;code&gt;{}&lt;/code&gt; を &lt;code&gt;optional&lt;/code&gt; て空のオプションオブジェクトを作成し、それを &lt;code&gt;op&lt;/code&gt; に割り当てます。</target>
        </trans-unit>
        <trans-unit id="eb6a5327aa18d2bb8b350958dde2d290354f8030" translate="yes" xml:space="preserve">
          <source>An out-of-class definition of a member function template must be</source>
          <target state="translated">メンバ関数テンプレートのクラス外定義は、以下のようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="7a79aaf703db97b5a7b0d58031c37912c2d8149a" translate="yes" xml:space="preserve">
          <source>An output iterator that writes successive elements into an output stream, separating adjacent elements with a delimiter</source>
          <target state="translated">連続した要素を出力ストリームに書き込む出力イテレータ.</target>
        </trans-unit>
        <trans-unit id="7c1bcb6f6b9e1950eeb340e7b5a97c8ee444cb42" translate="yes" xml:space="preserve">
          <source>An output iterator to element past the last element copied.</source>
          <target state="translated">最後にコピーされた要素の過去の要素への出力イテレータ。</target>
        </trans-unit>
        <trans-unit id="dc7304d0df5442d14acbaafb1a4c43fd8d0d9ec3" translate="yes" xml:space="preserve">
          <source>An overload &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if the declaration &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; is valid for some invented variable &lt;code&gt;x&lt;/code&gt;;</source>
          <target state="translated">オーバーロード &lt;code&gt;F(T_i)&lt;/code&gt; は、宣言 &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; 場合にのみ考慮されます。いくつかの発明された変数 &lt;code&gt;x&lt;/code&gt; に対して有効です。</target>
        </trans-unit>
        <trans-unit id="31a89ff54bf0a65e07ec5e6290a30f27bf9c83bf" translate="yes" xml:space="preserve">
          <source>An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators.</source>
          <target state="translated">rvalueは、組み込みの代入演算子や複合代入演算子の左手オペランドとして使用することはできません。</target>
        </trans-unit>
        <trans-unit id="df8a77695e43a01d35ff3833e595deae1c70885b" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize a const lvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">右辺値を使用し&lt;a href=&quot;reference_initialization&quot;&gt;てconst lvalue参照&lt;/a&gt;を初期化できます。その場合、右辺値によって識別されるオブジェクトの存続期間は、参照のスコープが終了するまで&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;延長され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="0e072674017d2ac839c66e65b949d44d2466050e" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an rvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">右辺値は&lt;a href=&quot;reference_initialization&quot;&gt;、右辺値参照&lt;/a&gt;を初期化するために使用できます。その場合、右辺値によって識別されるオブジェクトの存続期間は、参照のスコープが終了するまで&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;延長され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9223b2493a48ecf49ed1c32238f5defa3e17a1e2" translate="yes" xml:space="preserve">
          <source>An rvalue reference to a cv-unqualified template parameter is not a &lt;a href=&quot;template_argument_deduction&quot;&gt;forwarding reference&lt;/a&gt; if that parameter is a class template parameter:</source>
          <target state="translated">cv修飾されていないテンプレートパラメーターへの右辺値参照は、そのパラメーターがクラステンプレートパラメーターである場合、&lt;a href=&quot;template_argument_deduction&quot;&gt;転送参照で&lt;/a&gt;はありません。</target>
        </trans-unit>
        <trans-unit id="06c47888799c4beade0a1c880e7969d048a047e7" translate="yes" xml:space="preserve">
          <source>An rvalue reference to the element at relative location, that is, &lt;code&gt;std::move(base()[n])&lt;/code&gt;.</source>
          <target state="translated">相対位置にある要素への右辺値参照、つまり &lt;code&gt;std::move(base()[n])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4431ce6b5c54a2464689bcd2649d6be6a6d6edb5" translate="yes" xml:space="preserve">
          <source>Analyzes the character sequence &lt;code&gt;[first,last)&lt;/code&gt; for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">以下で説明するパターンの文字シーケンス &lt;code&gt;[first,last)&lt;/code&gt; を分析します。パターンに一致する文字がない場合、または一致した文字を解析して得られた &lt;code&gt;value&lt;/code&gt; が &lt;code&gt;value&lt;/code&gt; のタイプで表現できない場合、値は変更されません。そうでない場合、パターンに一致する文字は、算術値のテキスト表現として解釈され、 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ffd735c77a58f5bee4802f3701c7f6fda3f232e" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value formerly held by &lt;code&gt;rv&lt;/code&gt; (&lt;code&gt;rv&lt;/code&gt; remains valid, but is in an unspecified state.).</source>
          <target state="translated">そして、評価後の値 &lt;code&gt;*p&lt;/code&gt; は以前に保持されている値と等価である &lt;code&gt;rv&lt;/code&gt; （ &lt;code&gt;rv&lt;/code&gt; 有効なままですが、未指定の状態になっています。）。</target>
        </trans-unit>
        <trans-unit id="a5b3b63e68ab039e5e9a76fb79b51bc5995bb988" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;. The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">そして評価後、 &lt;code&gt;*p&lt;/code&gt; の値は &lt;code&gt;v&lt;/code&gt; の値と同等になります。 &lt;code&gt;v&lt;/code&gt; の値は変更されません。</target>
        </trans-unit>
        <trans-unit id="56b1a77f4fe21b0570e2813c8d454db94a7cb374" translate="yes" xml:space="preserve">
          <source>And if any &lt;a href=&quot;reference_initialization&quot;&gt;reference binding&lt;/a&gt; takes place, it is direct binding (not one that constructs a temporary object)</source>
          <target state="translated">そして、&lt;a href=&quot;reference_initialization&quot;&gt;参照バインディング&lt;/a&gt;が発生した場合、それは直接バインディングです（一時オブジェクトを構成するものではありません）。</target>
        </trans-unit>
        <trans-unit id="c4c1b28f8418245c8009d38e2fd06aa2b822e70b" translate="yes" xml:space="preserve">
          <source>And, for every.</source>
          <target state="translated">そして、すべての人のために。</target>
        </trans-unit>
        <trans-unit id="c8cb4cc17edf8c49a6c05da36754f248647a5429" translate="yes" xml:space="preserve">
          <source>And, given.</source>
          <target state="translated">そして、与えられた。</target>
        </trans-unit>
        <trans-unit id="78f82f2df8d5e45692f017f6cf128f97529f9a02" translate="yes" xml:space="preserve">
          <source>Anonymous unions</source>
          <target state="translated">匿名組合</target>
        </trans-unit>
        <trans-unit id="f39f69aff078c2dee33a0b3c3af4837d3936bb7c" translate="yes" xml:space="preserve">
          <source>Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations(since C++14).</source>
          <target state="translated">匿名ユニオンにはさらに制限があります。メンバー関数を持つことはできず、静的データメンバーを持つことはできません。また、すべてのデータメンバーはパブリックでなければなりません。許可される唯一の宣言は、非静的データメンバーと&lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;宣言です（C ++ 14以降）。</target>
        </trans-unit>
        <trans-unit id="79c7bbc8f686393ed4d5a563735506c51a1b8513" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;std::weak_ptr&lt;/code&gt; is to break reference cycles formed by objects managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.</source>
          <target state="translated">&lt;code&gt;std::weak_ptr&lt;/code&gt; のもう1つの用途は、 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; によって管理されるオブジェクトによって形成される参照サイクルを中断することです。そのようなサイクルが孤立している場合（つまり、サイクルへの外部共有ポインタがない場合）、shared_ptr参照カウントはゼロに到達できず、メモリがリークされます。これを防ぐには、サイクル内のポインタの1つを弱くすることができます。</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">浮動小数点値がNaNかどうかをテストする別の方法は、それをそれ自体と比較することです &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f898bf7d5a8e88530be0282c53c70a4902e14d0" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;declarations&quot;&gt;simple declarations&lt;/a&gt; are allowed, except.</source>
          <target state="translated">任意の&lt;a href=&quot;declarations&quot;&gt;シンプルな宣言は&lt;/a&gt;除き、許可されています。</target>
        </trans-unit>
        <trans-unit id="b7e1bdbe6a7f8ce733280e2254188bf3b1de8cb1" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt; are allowed, with additional syntax elements that are only available for non-static member functions: &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; and &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; specifiers, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt;, cv-qualifiers, ref-qualifiers, and &lt;a href=&quot;constructor&quot;&gt;member initialization lists&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;関数の宣言&lt;/a&gt;はすべて許可されます。追加の構文要素は、非静的メンバー関数でのみ使用できます。&lt;a href=&quot;final&quot;&gt;最終&lt;/a&gt;指定子と&lt;a href=&quot;override&quot;&gt;オーバーライド&lt;/a&gt;指定子、&lt;a href=&quot;abstract_class&quot;&gt;純粋指定子&lt;/a&gt;、cv修飾子、参照修飾子、および&lt;a href=&quot;constructor&quot;&gt;メンバー初期化リスト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b49f8c4e0a542030094cffe671da5baa163695a" translate="yes" xml:space="preserve">
          <source>Any additional integral types needed by the typedefs in the header &lt;a href=&quot;../header/cstdint&quot;&gt;&lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;../header/cstdint&quot;&gt; &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; の&lt;/a&gt; typedefが必要とする追加の整数型。</target>
        </trans-unit>
        <trans-unit id="f08aea9a890f019823885a1075301ba39bc58d28" translate="yes" xml:space="preserve">
          <source>Any capture may appear only once:</source>
          <target state="translated">どのキャプチャーも一度だけ出現する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a6942cddecd7def2bc3a413a01b71ac46c41eb7d" translate="yes" xml:space="preserve">
          <source>Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, is considered to be part of the input sequence.</source>
          <target state="translated">初期化されたバッファ内の文字は、コンストラクタで渡された文字列に由来するものか、 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; によって追加されたものかに関係なく、入力シーケンスの一部と見なされます。</target>
        </trans-unit>
        <trans-unit id="6e77be05deb9b5ecac58519844a0e640e7f8ea02" translate="yes" xml:space="preserve">
          <source>Any character sequence, except that it must not contain the closing sequence &lt;code&gt;)&lt;/code&gt;delimiter&lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">任意の文字シーケンス。ただし、終了シーケンスを含むことはできません &lt;code&gt;)&lt;/code&gt; 区切り文字 &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8037bc5cabc21aa1e4b299af2223a57b399d0e7" translate="yes" xml:space="preserve">
          <source>Any class type (whether declared with class-key&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;) may be declared as</source>
          <target state="translated">すべてのクラス型（class-key &lt;code&gt;class&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; で宣言されているかどうか）は、次のように宣言できます。</target>
        </trans-unit>
        <trans-unit id="3f8220613774bb0009e4140293deea0ebc75659a" translate="yes" xml:space="preserve">
          <source>Any declaration with an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage class specifier&lt;/a&gt; or with a &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; specifier (such as &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;) without an initializer</source>
          <target state="translated">初期化子なしの &lt;code&gt;extern&lt;/code&gt; &lt;a href=&quot;storage_duration&quot;&gt;ストレージクラス指定子&lt;/a&gt;または&lt;a href=&quot;language_linkage&quot;&gt;言語リンケージ&lt;/a&gt;指定子（ &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; など）を使用した宣言</target>
        </trans-unit>
        <trans-unit id="7246de96efdd56306a5b292694e0b51ddecb8395" translate="yes" xml:space="preserve">
          <source>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</source>
          <target state="translated">ラムダによって(暗黙的または明示的に)キャプチャされたエンティティはすべて、ラムダ式によって odr-use されます(したがって、ネストされたラムダによる暗黙的なキャプチャは、それを囲むラムダの暗黙的なキャプチャをトリガします)。</target>
        </trans-unit>
        <trans-unit id="2989809a7b8d0c13f3bc5dcda54fae5845e8e939" translate="yes" xml:space="preserve">
          <source>Any exception thrown by &lt;code&gt;Clock&lt;/code&gt; or &lt;code&gt;Duration&lt;/code&gt; (clocks and durations provided by the standard library never throw).</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; または &lt;code&gt;Duration&lt;/code&gt; によってスローされた例外（標準ライブラリによって提供されるクロックと継続時間は決してスローしません）。</target>
        </trans-unit>
        <trans-unit id="0155546b454eb352e396af9a9583e45239059529" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">実行中にクロック、タイムポイント、デュレーションによってスローされる例外(標準ライブラリで提供されているクロック、タイムポイント、デュレーションはスローされません)。</target>
        </trans-unit>
        <trans-unit id="c2829040c4ec83947a1f6cbfdec13c1bbc1b434c" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time_point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">実行中にクロック、タイムポイント、デュレーションによってスローされる例外(標準ライブラリで提供されているクロック、タイムポイント、デュレーションは決してスローされません)。</target>
        </trans-unit>
        <trans-unit id="c01d2aae1c56f6c1e27461994e6f980f695234ee" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call (the previously contained value, if any, had been destroyed).</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の選択されたコンストラクターによってスローされた例外。例外がスローされた場合、 &lt;code&gt;*this&lt;/code&gt; はこの呼び出し後の値は含まれません（以前に含まれていた値があった場合、破棄されていました）。</target>
        </trans-unit>
        <trans-unit id="9f5d991a2059cb95872e45c2fc73f5d2c5d644d5" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of the return value &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;T&lt;/code&gt; の選択されたコンストラクターによってスローされた例外。</target>
        </trans-unit>
        <trans-unit id="8272c2eb0b4b3a47c1fd6266b118d8e0b7dc16c2" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Compare&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Compare&lt;/code&gt; オブジェクトのスワップによってスローされた例外。</target>
        </trans-unit>
        <trans-unit id="067dbafb29590e30db3698223b8289c3ba3a81cd" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;KeyEqual&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; オブジェクトまたは &lt;code&gt;KeyEqual&lt;/code&gt; オブジェクトのスワップによってスローされる例外。</target>
        </trans-unit>
        <trans-unit id="3ee3642fda89a9c4f4d022a23e66f5f0e3c59796" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="b6634d37c80775a0920996e88d7df6e338b295bf" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="a87dda0d2400f372bf7fe2820ca303981427bec3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; (&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; types do not throw in &lt;code&gt;try_lock&lt;/code&gt;, but a custom &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; might)</source>
          <target state="translated">スローされるすべての例外 &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; （&lt;a href=&quot;../../named_req/mutex&quot;&gt;ミューテックスの&lt;/a&gt;種類がで投げていない &lt;code&gt;try_lock&lt;/code&gt; が、カスタム&lt;a href=&quot;../../named_req/lockable&quot;&gt;ロック可能&lt;/a&gt;かもしれません）</target>
        </trans-unit>
        <trans-unit id="655f412d1dcbf9a4b5e59996ea72d45e509cebc3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="7e00b1d47fa13181989c95392d4568f3ce99f9b2" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="fbacb0aafa934213b8105430ca644b8c44fceb18" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="29577e958473f7848749dbde1c0fe41d4d28de86" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="3c13a79f4c3e26012d9358714b624c43671f4909" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="50c476323ba0569c33a9d73cfd698b2849a0d7de" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="dde4d98fe163593f45905da9796164d4135b2aa5" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; によってスローされた例外</target>
        </trans-unit>
        <trans-unit id="46aca186f0d5118e57ea1ec2d858f1e279a474ac" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by the copy constructors of &lt;code&gt;BinaryPredicate&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryPredicate&lt;/code&gt; または &lt;code&gt;ForwardIt&lt;/code&gt; のコピーコンストラクターによってスローされる例外。</target>
        </trans-unit>
        <trans-unit id="4d35da87105417bd2f8dd9b5f22cbdf22b00eefe" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by.</source>
          <target state="translated">例外が発生した場合。</target>
        </trans-unit>
        <trans-unit id="ae8214fbedcd7b7b2c7806d56b17165dfe143da7" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown from iterator operations or the element swap.</source>
          <target state="translated">イテレータ操作や要素のスワップからスローされる例外。</target>
        </trans-unit>
        <trans-unit id="39254fcd3fdb015be0ee13d463da04333fcb57d3" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.</source>
          <target state="translated">括弧内の式はすべて一次式として分類されます。括弧は、値、型、および値のカテゴリを保持します。</target>
        </trans-unit>
        <trans-unit id="60455d87fc053fc9392b56ddecf2d39bad868244" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; at any given point in time either</source>
          <target state="translated">任意の時点での &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスのいずれか</target>
        </trans-unit>
        <trans-unit id="d6460fec33d2d5219b69f7a6eebb68fbfc2a92cb" translate="yes" xml:space="preserve">
          <source>Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; とユーザー定義の &lt;code&gt;swap()&lt;/code&gt; の両方が表示されるコンテキストで非修飾関数呼び出し &lt;code&gt;swap()&lt;/code&gt; を使用すると、このタイプの任意の左辺値または右辺値を他のタイプの任意の左辺値または右辺値と交換できます。</target>
        </trans-unit>
        <trans-unit id="6091484d7bf355dd0cb949cd776657171718f832" translate="yes" xml:space="preserve">
          <source>Any member that could not be determined is set to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</source>
          <target state="translated">判別できなかったメンバーはすべて &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; 設定されます</target>
        </trans-unit>
        <trans-unit id="74a03ddfcb26a95ca3f318466c08e7e95a815c27" translate="yes" xml:space="preserve">
          <source>Any number of access specifiers may appear within a class, in any order. Member access specifiers may affect class layout: the addresses of non-static &lt;a href=&quot;data_members#Layout&quot;&gt;data members&lt;/a&gt; are only guaranteed to increase in order of declaration for the members with the same access. For &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;, all non-static data members must have the same access.</source>
          <target state="translated">クラス内には、任意の数のアクセス指定子を任意の順序で指定できます。メンバーアクセス指定子は、クラスのレイアウトに影響を与える可能性があります。静的でない&lt;a href=&quot;data_members#Layout&quot;&gt;データメンバーの&lt;/a&gt;アドレスは、同じアクセスを持つメンバーの宣言順に増加することが保証されています。&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;、すべての非静的データメンバは、同じアクセス権を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="a64cd75ae326e1b045aa2b1398be8083184efecf" translate="yes" xml:space="preserve">
          <source>Any of the following can be fully specialized:</source>
          <target state="translated">以下のいずれかに完全に特化したもので構いません。</target>
        </trans-unit>
        <trans-unit id="437e7790370da61d174fe4d318acf7c074ede85b" translate="yes" xml:space="preserve">
          <source>Any of the following contexts requires class &lt;code&gt;T&lt;/code&gt; to be complete:</source>
          <target state="translated">次のいずれかのコンテキストでは、クラス &lt;code&gt;T&lt;/code&gt; が完成している必要があります。</target>
        </trans-unit>
        <trans-unit id="104d110bb41e8701d9fe7c539eb86ce87b612d21" translate="yes" xml:space="preserve">
          <source>Any of the following names declared at namespace scope have external linkage unless the namespace is unnamed or is contained within an unnamed namespace(since C++11):</source>
          <target state="translated">名前空間スコープで宣言された以下の名前は、名前が付けられていないか、名前が付けられていない名前空間内に含まれている場合を除き、外部リンクを持っています(C++11 以降)。</target>
        </trans-unit>
        <trans-unit id="5407990c5239cdd7bd6ef99bf9f9a20fd8e6527f" translate="yes" xml:space="preserve">
          <source>Any of the following names first declared at block scope have external linkage:</source>
          <target state="translated">ブロックスコープで最初に宣言された以下の名前のいずれかが外部連携を持っています。</target>
        </trans-unit>
        <trans-unit id="3238703010dee73fdace47f181589c27f2e4d0de" translate="yes" xml:space="preserve">
          <source>Any of the six two-way relational operators can be explicitly defaulted. A defaulted relational operator must have the return type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">6つの双方向関係演算子のいずれも、明示的にデフォルトに設定できます。デフォルトの関係演算子には戻り型が必要です &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="904ac65505544c6e1c0c9dffcf96e6454f73cb6f" translate="yes" xml:space="preserve">
          <source>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</source>
          <target state="translated">エンコーディング接頭辞の他の組み合わせは、実装によってサポートされていてもよいし、サポートされていなくてもよい。このような結合の結果は実装で定義される。</target>
        </trans-unit>
        <trans-unit id="0401aa15a157b543ba80abd41cb54281ed03d456" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#include&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) as long as they expand to a sequence of characters surrounded by &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt;&lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">任意の前処理トークン（マクロ定数または式）を引数として許可されている &lt;code&gt;#include&lt;/code&gt; と &lt;code&gt;__has_include&lt;/code&gt; あればによって囲まれた文字のシーケンスに拡張として（C ++ 17以降） &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;&quot;&lt;/code&gt; &lt;code&gt;&quot;&lt;/code&gt; で。</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">前処理トークン（マクロ定数または式）は、オプションで有効な文字列に続いて有効な10進整数に展開される限り、 &lt;code&gt;#line&lt;/code&gt; の引数として許可されます。</target>
        </trans-unit>
        <trans-unit id="8a80f56d370810d05ed5b7f500aef83276b2b56b" translate="yes" xml:space="preserve">
          <source>Any random number engine is also a &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, and therefore may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">どの乱数エンジンも&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;であるため、乱数（正式には、ランダム変量）を取得するために、任意の&lt;a href=&quot;../numeric/random&quot;&gt;乱数分布&lt;/a&gt;にプラグインできます。</target>
        </trans-unit>
        <trans-unit id="25328abef95d7bd06cd8ccb115014d680f4af1fb" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a bitset that happen via a &lt;code&gt;std::bitset::reference&lt;/code&gt; potentially read or write to the entire underlying bitset.</source>
          <target state="translated">経由で発生するビットセットへの読み取りまたは書き込み &lt;code&gt;std::bitset::reference&lt;/code&gt; 読み取りまたは書き込みは、潜在的な基礎となるビットセット全体に対して読み取りまたは書き込みを行う可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce62d6fd6228c7ed0a629a27ad487d906ba0cf6e" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a vector that happen via a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; potentially read or write to the entire underlying vector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 介して行われるベクターへの読み取りまたは書き込み &amp;lt;bool&amp;gt; :: reference読み取りまたは書き込みは、基になるベクター全体に対して読み取りまたは書き込みを行う可能性があります。</target>
        </trans-unit>
        <trans-unit id="79d69f3522c40f28b11ac3de0d09461ee1623eb9" translate="yes" xml:space="preserve">
          <source>Any return value from the function is ignored. If the function throws an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. In order to pass return values or exceptions back to the calling thread, &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">関数からの戻り値はすべて無視されます。関数が例外をスローすると、 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。戻り値または例外を呼び出しスレッドに戻すには、 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="65591f30b00907d381312a521d81c7b5924c3ee3" translate="yes" xml:space="preserve">
          <source>Any shared state is released. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; after a call to this method.</source>
          <target state="translated">すべての共有状態が解放されます。 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; このメソッドの呼び出し後、 false。</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">どのようなステートメントでも</target>
        </trans-unit>
        <trans-unit id="569389483a39353b7174754570a587d2d30d7a93" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer or by reference).</source>
          <target state="translated">すべてのスレッドがプログラム内の任意のオブジェクト（自動およびスレッドローカルなオブジェクト &lt;a href=&quot;storage_duration&quot;&gt;ストレージ期間の&lt;/a&gt;、ポインターまたは参照を介して別のスレッドからアクセスできます）。</target>
        </trans-unit>
        <trans-unit id="c56361a71bf85ab91f9c4ec67339965aa7d1d832" translate="yes" xml:space="preserve">
          <source>Any thread that intends to wait on &lt;code&gt;std::condition_variable&lt;/code&gt; has to.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; を待機するスレッドがあります。</target>
        </trans-unit>
        <trans-unit id="a27b17e4a874eb86d62efa02b876f52b84cb2492" translate="yes" xml:space="preserve">
          <source>Any two objects with overlapping &lt;a href=&quot;lifetime&quot;&gt;lifetimes&lt;/a&gt; (that are not &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</source>
          <target state="translated">&lt;a href=&quot;lifetime&quot;&gt;存続期間&lt;/a&gt;が重複する2つのオブジェクト（&lt;a href=&quot;bit_field&quot;&gt;ビットフィールド&lt;/a&gt;ではない））は、そのいずれかが別のサブオブジェクトであるか別のサブオブジェクトであるか、または同じ完全なオブジェクト内の異なるタイプのサブオブジェクトである場合を除いて、異なるアドレスを持つことが保証されます。それらのうち、サイズがゼロのサブオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="747805bfa6e2b47c753f371046684998f5739c7b" translate="yes" xml:space="preserve">
          <source>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</source>
          <target state="translated">このようにして無効になったポインタの使用は、ポインタの値を別の変数にコピーしても、未定義の動作となります。</target>
        </trans-unit>
        <trans-unit id="edb0075febb6c810a733225d843cfc260a841379" translate="yes" xml:space="preserve">
          <source>Any valid character except the double-quote &lt;code&gt;&quot;&lt;/code&gt;, backslash &lt;code&gt;\&lt;/code&gt;, or new-line character</source>
          <target state="translated">二重引用符 &lt;code&gt;&quot;&lt;/code&gt; 、バックスラッシュ以外の有効な文字 &lt;code&gt;\&lt;/code&gt; 、または改行文字文字</target>
        </trans-unit>
        <trans-unit id="1b24babb1df893acf8a8a6efb01913ddf0bd9397" translate="yes" xml:space="preserve">
          <source>Appear in any type specifier, including decl-specifier-seq of &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;, to specify constness or volatility of the object being declared or of the type being named.</source>
          <target state="translated">decl-specifier-seq ofを含むすべての型指定子に出現 &lt;a href=&quot;declarations&quot;&gt;宣言文法の&lt;/a&gt;出現して、宣言されているオブジェクトまたは名前が付けられている型の一貫性または揮発性を指定します。</target>
        </trans-unit>
        <trans-unit id="b3cea74b8699d0d5592fcdb76824dfd00b7a1900" translate="yes" xml:space="preserve">
          <source>Appears in a function declaration, enumeration declaration, or class declaration.</source>
          <target state="translated">関数宣言、列挙宣言、またはクラス宣言に出現します。</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">ファイルに追加</target>
        </trans-unit>
        <trans-unit id="185b3e5c1287dbe88e91911ebf09f0289a09ed1c" translate="yes" xml:space="preserve">
          <source>Append to file</source>
          <target state="translated">ファイルに追加</target>
        </trans-unit>
        <trans-unit id="7727ad0dfc1361a3b9a9f16594166faee13a49d3" translate="yes" xml:space="preserve">
          <source>Appends a &lt;code&gt;T&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 作成された &lt;code&gt;T&lt;/code&gt; を追加します &amp;lt;Args&amp;gt;（args）...で作成 ...</target>
        </trans-unit>
        <trans-unit id="ffa8f7a6232502ff61b9f355b8192a149bda0bdd" translate="yes" xml:space="preserve">
          <source>Appends a byte string pointed to by &lt;code&gt;src&lt;/code&gt; to a byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. At most &lt;code&gt;count&lt;/code&gt; characters are copied. The resulting byte string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すバイト文字列を &lt;code&gt;dest&lt;/code&gt; が指すバイト文字列に追加します。最大で &lt;code&gt;count&lt;/code&gt; 文字がコピーされます。結果のバイト文字列はnullで終了します。</target>
        </trans-unit>
        <trans-unit id="c89f8ba239ec205d14a709567d6066df8a0d1451" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;rv&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; のコピーを追加します。おそらく移動セマンティクスを使用し</target>
        </trans-unit>
        <trans-unit id="93a15a35c8298c01ed0b17fc08d04c4607bfeb7b" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">のコピーを追加します &lt;code&gt;t&lt;/code&gt; の</target>
        </trans-unit>
        <trans-unit id="0749406f25dc8bfe01326e6508ea40f8ccdfe8f5" translate="yes" xml:space="preserve">
          <source>Appends a copy of the character string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指す文字列のコピーを、 &lt;code&gt;dest&lt;/code&gt; が指す文字列の末尾に追加します。文字 &lt;code&gt;src[0]&lt;/code&gt; は、 &lt;code&gt;dest&lt;/code&gt; の終わりにあるnullターミネーターを置き換えます。結果のバイト文字列はnullで終了します。</target>
        </trans-unit>
        <trans-unit id="0f3b244f19389096a59b50d552c3a3947e4ec319" translate="yes" xml:space="preserve">
          <source>Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すワイド文字列のコピーを、 &lt;code&gt;dest&lt;/code&gt; が指すワイド文字列の末尾に追加します。ワイド文字 &lt;code&gt;src[0]&lt;/code&gt; は、 &lt;code&gt;dest&lt;/code&gt; の終わりにあるnullターミネーターを置き換えます。結果のワイド文字列はnullで終了します。</target>
        </trans-unit>
        <trans-unit id="ee76f2e6383e182374a1ac158b3fb988871f2017" translate="yes" xml:space="preserve">
          <source>Appends a new element to the end of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">コンテナの最後に新しい要素を追加します。要素は &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; constructを介して構築されます。これは通常、placement-newを使用して、コンテナによって提供される場所に要素をインプレースで構築します。引数 &lt;code&gt;args...&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt;（args）...としてコンストラクターに転送されます。。</target>
        </trans-unit>
        <trans-unit id="3769354c56bdf441401d30ffbfd485d11afed226" translate="yes" xml:space="preserve">
          <source>Appends additional characters to the string.</source>
          <target state="translated">文字列に追加の文字を追加します。</target>
        </trans-unit>
        <trans-unit id="9435c7778f8168db6ddee793e51647858e33337b" translate="yes" xml:space="preserve">
          <source>Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;, stopping if the null terminator is copied. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すワイド文字列から &lt;code&gt;dest&lt;/code&gt; が指す文字列の終わりまでに最大 &lt;code&gt;count&lt;/code&gt; 個のワイド文字を追加し、nullターミネーターがコピーされると停止します。ワイド文字 &lt;code&gt;src[0]&lt;/code&gt; は、 &lt;code&gt;dest&lt;/code&gt; の終わりにあるnullターミネーターを置き換えます。nullターミネータは常に最後に追加されます（そのため、関数が書き込むワイド文字の最大数は &lt;code&gt;count+1&lt;/code&gt; です）。</target>
        </trans-unit>
        <trans-unit id="616d6d1b2db8c5cbc5b78e6729f280f6ef9cde21" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the output character sequence.</source>
          <target state="translated">文字 &lt;code&gt;c&lt;/code&gt; を出力文字シーケンスに追加します。</target>
        </trans-unit>
        <trans-unit id="97e86c02631fb97ad63c305dc2c6744a765ce0c5" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the put area of the buffer, reallocating if possible.</source>
          <target state="translated">文字 &lt;code&gt;c&lt;/code&gt; をバッファの書き込み領域に追加し、可能であれば再割り当てします。</target>
        </trans-unit>
        <trans-unit id="532328072ae734b050324e7bd55974ecc3a7470f" translate="yes" xml:space="preserve">
          <source>Appends the given character &lt;code&gt;ch&lt;/code&gt; to the end of the string.</source>
          <target state="translated">文字列の最後に、指定された文字 &lt;code&gt;ch&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="cfc483d3db69eff6dcd82b004d3786722b9a1849" translate="yes" xml:space="preserve">
          <source>Appends the given element &lt;code&gt;value&lt;/code&gt; to the end of the container.</source>
          <target state="translated">コンテナの最後に指定された要素の &lt;code&gt;value&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="d2c0fb94e5cddaf445eca7c3640f9ada9fb6e2a7" translate="yes" xml:space="preserve">
          <source>Applied to</source>
          <target state="translated">に適用されます。</target>
        </trans-unit>
        <trans-unit id="cbd47fe22d148dd069a031976318ab7fb6d631c4" translate="yes" xml:space="preserve">
          <source>Applies compound assignment operators to each element in the numeric array.</source>
          <target state="translated">数値配列の各要素に複合代入演算子を適用します。</target>
        </trans-unit>
        <trans-unit id="bc6e0092dfd47ac0f36260b8d91a3704f6cc8726" translate="yes" xml:space="preserve">
          <source>Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type &lt;code&gt;T&lt;/code&gt;, removes cv-qualifiers, and defines the resulting type as the member typedef &lt;code&gt;type&lt;/code&gt;. Formally:</source>
          <target state="translated">lvalueからrvalue、配列からポインター、関数からポインターへの暗黙の変換を &lt;code&gt;T&lt;/code&gt; 型に適用し、cv-qualifiersを削除して、結果の型をメンバーtypedef &lt;code&gt;type&lt;/code&gt; として定義します。正式に：</target>
        </trans-unit>
        <trans-unit id="71f4ff319120444a2809431ede654e171b067641" translate="yes" xml:space="preserve">
          <source>Applies the corresponding operation to the referred elements and the elements of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">参照される要素と &lt;code&gt;other&lt;/code&gt; の要素に対応する操作を適用します。</target>
        </trans-unit>
        <trans-unit id="27d8e4e4d1d2e00786c12ccc2c42604642524bdd" translate="yes" xml:space="preserve">
          <source>Applies the unary operators to the year value.</source>
          <target state="translated">年値に単項演算子を適用します。</target>
        </trans-unit>
        <trans-unit id="a0cc3e98fe133b6a125be7a1095a1e4722d59951" translate="yes" xml:space="preserve">
          <source>Applies the visitor &lt;code&gt;vis&lt;/code&gt; to the variants &lt;code&gt;vars&lt;/code&gt;.</source>
          <target state="translated">ビジター &lt;code&gt;vis&lt;/code&gt; をバリアント &lt;code&gt;vars&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="767013b70c83389088a9d12acdf6717a821be569" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in a function declaration, which must be the first declaration of the function.</source>
          <target state="translated">関数宣言で宣言されている名前に適用され、関数の最初の宣言でなければなりません。</target>
        </trans-unit>
        <trans-unit id="0463466b4fbb2abaeda54896e7f772d38769d910" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in the declaration of a non-static data member that's not a bit field.</source>
          <target state="translated">ビット・フィールドではない非静的データ・メンバの宣言で宣言されている名前に適用されます。</target>
        </trans-unit>
        <trans-unit id="c80f073f7430ca362ef718e10efb9033f924c369" translate="yes" xml:space="preserve">
          <source>Applies unary operators to each element in the numeric array.</source>
          <target state="translated">数値配列の各要素に単項演算子を適用します.</target>
        </trans-unit>
        <trans-unit id="4b03880d31fcc803c8ff4f90e7d09f01a683bd9e" translate="yes" xml:space="preserve">
          <source>Apply binary operators to each element of two valarrays, or a valarray and a value.</source>
          <target state="translated">2 つの配列、または配列と値の各要素に 2 進演算子を適用します。</target>
        </trans-unit>
        <trans-unit id="68fcd04d7e11c3d0bcd63b86035531ef6f69e2ba" translate="yes" xml:space="preserve">
          <source>Applying &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</source>
          <target state="translated">適用&lt;a href=&quot;cv&quot;&gt;CV-修飾子&lt;/a&gt;（のtypedefまたはテンプレートタイプの操作によって）、アレイ型にする要素タイプに修飾子を適用するが、その要素CV修飾型である任意の配列型は、同じCV-資格を有すると考えられます。</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="09d845a999b4fbc8adffb5aaf317f7912e88b018" translate="yes" xml:space="preserve">
          <source>Approximately (last-first)log(middle-first) applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; のおよそ（最後から1番目）のログ（中央から1番目）のアプリケーション。</target>
        </trans-unit>
        <trans-unit id="784f9dcf68eaea0702498dee303485e97ffb2719" translate="yes" xml:space="preserve">
          <source>Approximately &lt;code&gt;N log N&lt;/code&gt; comparisons, where N is the number of elements in the list.</source>
          <target state="translated">約 &lt;code&gt;N log N&lt;/code&gt; 比較。Nはリスト内の要素の数です。</target>
        </trans-unit>
        <trans-unit id="263ef14d73529c347640508e4c1ee9f8d38a5463" translate="yes" xml:space="preserve">
          <source>Arbitrary variable name</source>
          <target state="translated">任意の変数名</target>
        </trans-unit>
        <trans-unit id="e35b07545cf742633f94fa34acab673ea47df2c2" translate="yes" xml:space="preserve">
          <source>Args&lt;code&gt;...&lt;/code&gt;args(optional)</source>
          <target state="translated">Args&lt;code&gt;...&lt;/code&gt;args(optional)</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">引数リストが長すぎる</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="2b55cecef5202fd86c073a0e44fac351439665bc" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Lookup</source>
          <target state="translated">引数依存ルックアップ</target>
        </trans-unit>
        <trans-unit id="81b2c9c824baa8fa05c1678ad66e87db4cff58c7" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup</source>
          <target state="translated">引数依存ルックアップ</target>
        </trans-unit>
        <trans-unit id="ae0999c00edb7da81dc23e3610fb98d912a734a5" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</source>
          <target state="translated">引数に依存したルックアップでは、異なる名前空間で定義された演算子を使用することができます。例。</target>
        </trans-unit>
        <trans-unit id="48fb1df93f3daa01db173d8e4c1d5be0610f1c51" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, including implicit function calls to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt;.</source>
          <target state="translated">引数に依存するルックアップ（ADLまたはKoenigルックアップとも呼ばれます）は、&lt;a href=&quot;operators&quot;&gt;オーバーロードされた演算子&lt;/a&gt;への暗黙的な関数呼び出しを含む、&lt;a href=&quot;operator_other&quot;&gt;関数呼び出し式&lt;/a&gt;で修飾されていない関数名をルックアップするための一連のルールです。これらの関数名は、通常の&lt;a href=&quot;lookup&quot;&gt;修飾&lt;/a&gt;されていない名前検索で考慮されるスコープと名前空間に加えて、引数の名前空間で検索されます。</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="6e926e8a15212af2e7d9e38d85b6ff5994219acc" translate="yes" xml:space="preserve">
          <source>Arithmetic comparison operators</source>
          <target state="translated">算術比較演算子</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算術演算</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">算術演算子</target>
        </trans-unit>
        <trans-unit id="ebc8c7691d9a7980369acc634bd9267bcb2e5a9e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are overloaded for many standard library types.</source>
          <target state="translated">算術演算子は、多くの標準ライブラリ型に対してオーバーロードされています。</target>
        </trans-unit>
        <trans-unit id="aa83af8c4fc56c37be9ed278bb37886d698b573b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing the process running time of implementation-defined range and precision.</source>
          <target state="translated">実装で定義された範囲と精度のプロセス実行時間を表すことができる算術型です。</target>
        </trans-unit>
        <trans-unit id="8067dbf084d6b81e05c895b3fb91dd4530c4b57b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing times.</source>
          <target state="translated">回数を表すことができる算術型。</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">算術型</target>
        </trans-unit>
        <trans-unit id="d06d9a0dfd0ee03ff5118df0f82845bdc8d2b4bc" translate="yes" xml:space="preserve">
          <source>Arithmetic types are the built-in types for which the &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; (+, -, *, /) are defined (possibly in combination with the usual arithmetic conversions).</source>
          <target state="translated">算術型は、&lt;a href=&quot;../language/operator_arithmetic&quot;&gt;算術演算子&lt;/a&gt;（+、-、*、/）が定義されている組み込み型です（通常の算術変換と組み合わせて）。</target>
        </trans-unit>
        <trans-unit id="7a080955122add0c1c12baf72d49c4257bf60020" translate="yes" xml:space="preserve">
          <source>Array &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; may be formed directly by accessing an array member of a class rvalue or by using &lt;code&gt;std::move&lt;/code&gt; or another cast or function call that returns an rvalue reference.</source>
          <target state="translated">配列の&lt;a href=&quot;value_category&quot;&gt;x&lt;/a&gt;値は、クラスの右辺値の配列メンバーにアクセスするか、 &lt;code&gt;std::move&lt;/code&gt; または右辺値参照を返す別のキャストまたは関数呼び出しを使用して直接形成できます。</target>
        </trans-unit>
        <trans-unit id="ee291b10c5dda44d0a9e99115603b2cd5af533b7" translate="yes" xml:space="preserve">
          <source>Array I/O implementations</source>
          <target state="translated">アレイI/O実装</target>
        </trans-unit>
        <trans-unit id="1fac704c74c4d1cd597a85741e932ee6a1399565" translate="yes" xml:space="preserve">
          <source>Array allocation may supply unspecified overhead, which may vary from one call to new to the next. The pointer returned by the new-expression will be offset by that value from the pointer returned by the allocation function. Many implementations use the array overhead to store the number of objects in the array which is used by the &lt;a href=&quot;delete&quot;&gt;&lt;code&gt;delete[]&lt;/code&gt;&lt;/a&gt; expression to call the correct number of destructors. In addition, if the new-expression is used to allocate an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;, it may request additional memory from the allocation function if necessary to guarantee correct alignment of objects of all types no larger than the requested array size, if one is later placed into the allocated array.</source>
          <target state="translated">配列の割り当てにより、未指定のオーバーヘッドが発生する可能性があります。これは、呼び出しごとに異なります。 new-expressionによって返されるポインターは、割り当て関数によって返されるポインターからの値によってオフセットされます。多くの実装では、配列オーバーヘッドを使用して、正しい数のデストラクタを呼び出すために&lt;a href=&quot;delete&quot;&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;/a&gt;式で使用される配列にオブジェクトの数を格納します。さらに、new式を使用して &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;unsigned char&lt;/code&gt; 、または&lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt;配列を割り当てる場合、必要に応じて、割り当て関数から追加のメモリを要求して、割り当てられた配列に後で配置される場合は、要求された配列サイズ。</target>
        </trans-unit>
        <trans-unit id="19dbfbf61f5e11cabe0b3e7c939480487b44e48e" translate="yes" xml:space="preserve">
          <source>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</source>
          <target state="translated">配列型や関数型はテンプレート宣言に書いてもよいが、適宜オブジェクトへのポインタや関数へのポインタで自動的に置換される。</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">配列宣言</target>
        </trans-unit>
        <trans-unit id="fa11a0bed9bf8be4aa754cdcc96dcd83617299af" translate="yes" xml:space="preserve">
          <source>Array rvalues</source>
          <target state="translated">配列 rvalues</target>
        </trans-unit>
        <trans-unit id="2e4177a778e8e0d4d36e9396b01d0e6f4341b30c" translate="yes" xml:space="preserve">
          <source>Array subscript operator</source>
          <target state="translated">配列の添え字演算子</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">配列からポインタへの変換</target>
        </trans-unit>
        <trans-unit id="c0025fd7b0d4a983ce2fa2e1c1b60d86f77fcd32" translate="yes" xml:space="preserve">
          <source>Array version, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">配列バージョン、 &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d338acd11db4278249951233a983d4b787dc89b" translate="yes" xml:space="preserve">
          <source>Array-oriented access</source>
          <target state="translated">配列指向のアクセス</target>
        </trans-unit>
        <trans-unit id="78c423e7d10bf3348df8d43bf148cb5827744e5a" translate="yes" xml:space="preserve">
          <source>Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a &lt;a href=&quot;cv&quot;&gt;volatile-qualified&lt;/a&gt; glvalue and has one of the following forms (built-in meaning required, possibly parenthesized).</source>
          <target state="translated">配列からポインターへの変換および関数からポインターへの変換は、廃棄された値の式によって計算された値には適用されません。左辺値から右辺値への変換は、式が&lt;a href=&quot;cv&quot;&gt;揮発性修飾された&lt;/a&gt; glvalueであり、次の形式のいずれかである場合にのみ適用されます（組み込みの意味が必要で、おそらく括弧で囲まれています）。</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">アレイからポインターへの減衰</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="1376db7bd12df19420984d74ce62a991f95e82b5" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed from any &lt;a href=&quot;types&quot;&gt;fundamental type&lt;/a&gt; (except &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;pointer&quot;&gt;pointers&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointers to members&lt;/a&gt;, &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, or from other arrays (in which case the array is said to be multi-dimensional).</source>
          <target state="translated">配列は、任意の&lt;a href=&quot;types&quot;&gt;基本型&lt;/a&gt;（ &lt;code&gt;void&lt;/code&gt; を除く）、&lt;a href=&quot;pointer&quot;&gt;ポインター&lt;/a&gt;、&lt;a href=&quot;pointer&quot;&gt;メンバーへのポインター&lt;/a&gt;、&lt;a href=&quot;classes&quot;&gt;クラス&lt;/a&gt;、&lt;a href=&quot;enum&quot;&gt;列挙型&lt;/a&gt;、または他の配列（この場合、配列は多次元と呼ばれます）から構築できます。</target>
        </trans-unit>
        <trans-unit id="fb1e79ec0101099cc8a59bf9fd30eb4aa15f99db" translate="yes" xml:space="preserve">
          <source>Arrays of character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;) can be initialized from an appropriate &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</source>
          <target state="translated">文字型の配列（ &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;signed char&lt;/code&gt; 、 &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;char8_t&lt;/code&gt; 、 &lt;code&gt;char16_t&lt;/code&gt; 、 &lt;code&gt;char32_t&lt;/code&gt; 、 &lt;code&gt;wchar_t&lt;/code&gt; ）は、適切な&lt;a href=&quot;string_literal&quot;&gt;&lt;/a&gt;、オプションで中括弧で囲まれ文字列リテラルます。文字列リテラルの連続する文字（暗黙の終了NULL文字を含む）は、配列の要素を初期化します。配列のサイズが指定されていて、それが文字列リテラルの文字数より大きい場合、残りの文字はゼロで初期化されます。</target>
        </trans-unit>
        <trans-unit id="1dad2511cb3cf432d9a23097f1bff2b6f8637192" translate="yes" xml:space="preserve">
          <source>Arrays of unknown bound</source>
          <target state="translated">未知の境界の配列</target>
        </trans-unit>
        <trans-unit id="5cf5ca03aab0034cdf7ff385d06729a538f15f36" translate="yes" xml:space="preserve">
          <source>As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;, the iterator will continue to point to the same array element, and will thus change its value.</source>
          <target state="translated">原則として、配列のイテレータは、配列の有効期間を通じて無効になることはありません。ただし、&lt;a href=&quot;array/swap&quot;&gt;スワップ&lt;/a&gt;中に、イテレータは同じ配列要素をポイントし続けるため、その値が変更さ。</target>
        </trans-unit>
        <trans-unit id="614cc5be51bd0fccb31d1106fa599930fafe0ca5" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as a uses-allocator type even though &lt;code&gt;std::uses_allocator&lt;/code&gt; is false for pairs (unlike e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;): see pair-specific overloads of &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt;(until C++20)&lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt;(since C++20)</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; あっても使用・アロケータ・タイプとして扱われる &lt;code&gt;std::uses_allocator&lt;/code&gt; （例えば異なり対について偽 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ）：ペア固有のオーバーロードを参照 &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt; （C ++ 20まで） &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; （C ++ 20以降）</target>
        </trans-unit>
        <trans-unit id="363835804f732ae2a7518afa5d70079b8f827fb9" translate="yes" xml:space="preserve">
          <source>As a special case, objects can be created in arrays of &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; (in which case it is said that the array</source>
          <target state="translated">特殊なケースとして、オブジェクトは &lt;code&gt;unsigned char&lt;/code&gt; または&lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt;配列で作成できます。（この場合、配列は</target>
        </trans-unit>
        <trans-unit id="f52724b9ca0301f1d8b93282821a00b036f2d526" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;eq=key_equal()&lt;/code&gt;</source>
          <target state="translated">上記のように、 &lt;code&gt;eq=key_equal()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8531b085109b3b3d1377cabf79180d8d388c7ee8" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;hf=hasher()&lt;/code&gt;</source>
          <target state="translated">上記のように、 &lt;code&gt;hf=hasher()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda77b28e4ca321fc30d59f16b97fba79dbe7581" translate="yes" xml:space="preserve">
          <source>As above, with an unspecified number of buckets</source>
          <target state="translated">上記のように、不特定多数のバケットを使用して</target>
        </trans-unit>
        <trans-unit id="cb4232ed7041310ecc9217dc4e9b0dad693d0afb" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">「実装によってサポートされる」要件の例として、POSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;でposix_memalignは&lt;/a&gt;任意受け入れる &lt;code&gt;alignment&lt;/code&gt; 2の累乗の倍数で &lt;code&gt;sizeof(void*)&lt;/code&gt; 、とのPOSIXベースの実装 &lt;code&gt;aligned_alloc&lt;/code&gt; この要件を継承。</target>
        </trans-unit>
        <trans-unit id="0a94bbdb2793055475b5f04a01eddcc7f88ab6b4" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">「実装によってサポートされる」要件の例として、POSIX関数&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt;は、 &lt;code&gt;sizeof(void*)&lt;/code&gt; の2の倍数である任意の &lt;code&gt;alignment&lt;/code&gt; を受け入れ、 &lt;code&gt;aligned_alloc&lt;/code&gt; のPOSIXベースの実装はこの要件を継承します。</target>
        </trans-unit>
        <trans-unit id="6dabb20bee356347a72de2e02dded113dd51368a" translate="yes" xml:space="preserve">
          <source>As any other function, a destructor may terminate by throwing an &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;(this usually requires it to be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;)(since C++11), however if this destructor happens to be called during &lt;a href=&quot;throw&quot;&gt;stack unwinding&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">他の関数と同様に、デストラクタは&lt;a href=&quot;exceptions&quot;&gt;例外を&lt;/a&gt;スローすることで終了する場合があります（通常、これは明示的に &lt;code&gt;noexcept(false)&lt;/code&gt; と宣言する必要があります）（C ++ 11以降）。ただし、このデストラクタが&lt;a href=&quot;throw&quot;&gt;スタックの巻き戻し&lt;/a&gt;中に呼び出された場合、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 代わりにterminateが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7a66bb24008dddd2f1f26becdeebf04e56826247" translate="yes" xml:space="preserve">
          <source>As defined above.</source>
          <target state="translated">上記で定義したように</target>
        </trans-unit>
        <trans-unit id="a534c811c2d3571f2ae27f157ef19b52a844ad05" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;で説明されているように、非静的メンバー関数へのポインターまたは非静的データメンバーへのポインターを呼び出す場合、最初の引数は参照またはポインター（ &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; などのスマートポインターを含む可能性があります）である必要があります。 ：unique_ptr）は、メンバーがアクセスされるオブジェクトに。</target>
        </trans-unit>
        <trans-unit id="9ee2578ea146050c5227b8b046d49c6f68518e95" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;, the C++ program may provide global and class-specific replacements for these functions. If the new-expression begins with the optional &lt;code&gt;::&lt;/code&gt; operator, as in &lt;code&gt;::new T&lt;/code&gt; or &lt;code&gt;::new T[n]&lt;/code&gt;, class-specific replacements will be ignored (the function is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in global &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;). Otherwise, if &lt;code&gt;T&lt;/code&gt; is a class type, lookup begins in the class scope of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../memory/new/operator_new&quot;&gt;割り当て関数&lt;/a&gt;で説明されているように、C ++プログラムは、これらの関数のグローバルおよびクラス固有の置換を提供する場合があります。 &lt;code&gt;::new T&lt;/code&gt; または &lt;code&gt;::new T[n]&lt;/code&gt; 、new-expressionがオプションの &lt;code&gt;::&lt;/code&gt; 演算子で始まる場合、クラス固有の置換は無視されます（関数はグローバル&lt;a href=&quot;scope&quot;&gt;スコープで&lt;/a&gt;&lt;a href=&quot;lookup&quot;&gt;検索さ&lt;/a&gt;れます）。それ以外の場合、 &lt;code&gt;T&lt;/code&gt; がクラス型の場合、検索は &lt;code&gt;T&lt;/code&gt; のクラススコープで開始されます。</target>
        </trans-unit>
        <trans-unit id="03fe97a528d16f7fe7e71f5717247af8db4822bd" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt;, the syntax &lt;code&gt;T()&lt;/code&gt;(1) is prohibited for arrays, while &lt;code&gt;T{}&lt;/code&gt;(5) is allowed.</source>
          <target state="translated">&lt;a href=&quot;explicit_cast&quot;&gt;関数キャスト&lt;/a&gt;で説明したように、配列 &lt;code&gt;T()&lt;/code&gt; （1）は配列に対して禁止されていますが、 &lt;code&gt;T{}&lt;/code&gt; （5）は許可されています。</target>
        </trans-unit>
        <trans-unit id="f2a24edd45dbf727b01f52b1b2fe43e48097af38" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;non-local initialization&lt;/a&gt;, static and thread-local variables that aren't constant-initialized(since C++14) are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.</source>
          <target state="translated">&lt;a href=&quot;initialization#Non-local_variables&quot;&gt;非ローカル初期化で&lt;/a&gt;説明されているようにで定数で初期化されていない静的変数とスレッドローカル変数（C ++ 14以降）は、他の初期化が行われる前にゼロで初期化されます。非クラス非ローカル変数の定義に初期化子がない場合、デフォルトの初期化は何もせず、以前のゼロ初期化の結果は変更されません。</target>
        </trans-unit>
        <trans-unit id="08d19aea73540a5ba0404cba80c23af9e3c2ceba" translate="yes" xml:space="preserve">
          <source>As described in &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; で説明されているように、非静的メンバー関数へのポインターまたは非静的データメンバーへのポインターを呼び出す場合、最初の引数は参照またはポインター（ &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; などのスマートポインターを含む）である必要がありますおよび &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ）は、メンバーがアクセスされるオブジェクトに。</target>
        </trans-unit>
        <trans-unit id="2b2d6cdbd1b2496e6a2f40aed0a78a511c900aab" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt;, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</source>
          <target state="translated">&lt;a href=&quot;lookup&quot;&gt;ルックアップで&lt;/a&gt;説明したようにで、テンプレートで使用される依存名のルックアップは、テンプレートの引数が判明するまで延期されます。</target>
        </trans-unit>
        <trans-unit id="58e3f3f862eff79aa619bdf804e54d8152b28137" translate="yes" xml:space="preserve">
          <source>As formulated in C++11, the behavior of &lt;code&gt;std::result_of&lt;/code&gt; is undefined when &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is ill-formed (e.g. when F is not a callable type at all). C++14 changes that to a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (when F is not callable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simply doesn't have the &lt;code&gt;type&lt;/code&gt; member).</source>
          <target state="translated">C ++ 11の動作中に処方通り &lt;code&gt;std::result_of&lt;/code&gt; 定義されていないとき &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 悪い形成される（例えばときFは呼び出し可能な型ではありません）。C ++ 14はそれを&lt;a href=&quot;../language/sfinae&quot;&gt;SFINAEに&lt;/a&gt;変更します（Fが呼び出し可能でない場合、 &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; 単に &lt;code&gt;type&lt;/code&gt; メンバーがありません）。</target>
        </trans-unit>
        <trans-unit id="937a4526e972e8900a66eaf74bf3283dd336852b" translate="yes" xml:space="preserve">
          <source>As free (namespace) function</source>
          <target state="translated">フリー(名前空間)関数として</target>
        </trans-unit>
        <trans-unit id="ebe6ab533cbf3972cb8d127e93ba520450789106" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, if statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the loop body as if it was a compound statement.</source>
          <target state="translated">の場合である&lt;a href=&quot;while&quot;&gt;一方、&lt;/a&gt;ループ文は、単一の文（しない化合物文）である場合、変数のスコープは、それが複合文であるかのように、ループ本体に制限され、それに宣言しました。</target>
        </trans-unit>
        <trans-unit id="c00d6a8291143d3954d0476db09f338bbdf6a6a6" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;typename&lt;/code&gt;, the &lt;code&gt;template&lt;/code&gt; prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template(since C++11).</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; の場合と同様に、 &lt;code&gt;template&lt;/code&gt; 、名前が依存していない場合やテンプレートのスコープに使用が表示されていない場合でもプレフィックスを使用できます（C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="f30e97ae154b85ba90b59b0fc7f3cc9421ecbfce" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid &lt;code&gt;weekday&lt;/code&gt; even if &lt;code&gt;wd.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">計算がオーバーフローしない限り、（1-3 &lt;code&gt;wd.ok()&lt;/code&gt; はwd.ok（）が &lt;code&gt;false&lt;/code&gt; であっても常に有効な &lt;code&gt;weekday&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="b2ffc3f13ddf954cdee7f939204ad75111f3eb7d" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid month even if &lt;code&gt;m.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">計算がオーバーフローしない限り、（1-3 &lt;code&gt;m.ok()&lt;/code&gt; はm.ok（）が &lt;code&gt;false&lt;/code&gt; であっても常に有効な月を返します。</target>
        </trans-unit>
        <trans-unit id="974f4de3b83d59e1f68e4272f20e899a5d37454c" translate="yes" xml:space="preserve">
          <source>As member function</source>
          <target state="translated">メンバー機能として</target>
        </trans-unit>
        <trans-unit id="713b3ed5226e8894aaa4433505d652a47c900087" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;declarations#Declarators&quot;&gt;Declarations&lt;/a&gt;, the declarator can be followed by a</source>
          <target state="translated">&lt;a href=&quot;declarations#Declarators&quot;&gt;宣言&lt;/a&gt;で述べたように、宣言子の後には</target>
        </trans-unit>
        <trans-unit id="49e91975e9ca17802a309ea7799083868c1165b1" translate="yes" xml:space="preserve">
          <source>As non-member function</source>
          <target state="translated">非会員機能として</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
