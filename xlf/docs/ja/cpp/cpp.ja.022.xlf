<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="fc058be4fe81eec42326824dea95a8995ba79311" translate="yes" xml:space="preserve">
          <source>The formal parameter of the catch clause (type-specifier-seq and declarator or type-specifier-seq and abstract-declarator) determines which types of exceptions cause this catch clause to be entered. It cannot be an &lt;a href=&quot;reference&quot;&gt;rvalue reference type&lt;/a&gt;, &lt;a href=&quot;abstract_class&quot;&gt;abstract class&lt;/a&gt;, &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, or pointer to incomplete type (except that pointers to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; are allowed). If the type of the formal parameter is array type or function type, it is treated as the corresponding pointer type (similar to a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">catch句の仮パラメーター（type-specifier-seqとdeclarator、またはtype-specifier-seqとabstract-declarator）は、このcatch句に入る例外のタイプを決定します。これは、&lt;a href=&quot;reference&quot;&gt;右辺値参照型&lt;/a&gt;、&lt;a href=&quot;abstract_class&quot;&gt;抽象クラス&lt;/a&gt;、&lt;a href=&quot;incomplete_type&quot;&gt;不完全型&lt;/a&gt;、または不完全型へのポインタ（（おそらく&lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;修飾された） &lt;code&gt;void&lt;/code&gt; へのポインタが許可されている場合を除いて）にはできません。仮パラメーターの型が配列型または関数型の場合は、対応するポインター型として扱われます（&lt;a href=&quot;function&quot;&gt;関数宣言&lt;/a&gt;と同様）。</target>
        </trans-unit>
        <trans-unit id="8c84fba53b093effe5342ab55502a277a5ffaba5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible through filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; の形式は実装定義であり、必ずしもファイルを指すとは限りません（たとえば、ファイルシステムAPIを介してアクセス可能なコンソールまたは別のデバイスである場合があります）。それらをサポートするプラットフォームでは、 &lt;code&gt;filename&lt;/code&gt; に絶対または相対ファイルシステムパスを含めることができます。</target>
        </trans-unit>
        <trans-unit id="19e13fb520e9b9f29460d58a00f41c09337dc08f" translate="yes" xml:space="preserve">
          <source>The format of floating-point values is as follows:</source>
          <target state="translated">浮動小数点値のフォーマットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a0add987dacb96215da068df8fc467e3a8d4b58c" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数値の形式は、&lt;a href=&quot;../../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; で&lt;/a&gt;想定されているものと同じです。です。</target>
        </trans-unit>
        <trans-unit id="c7a581065d0c8c103e51ec546cb2d29946e0e282" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、 &lt;code&gt;base&lt;/code&gt; 値 &lt;code&gt;10&lt;/code&gt; を指定した&lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt;で想定されているものと同じです。引数のです。</target>
        </trans-unit>
        <trans-unit id="de50d9c89fd0c551d172e90d35e19763d28aebed" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">予想されるように数値の形式は同じである&lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt;値と &lt;code&gt;​0​&lt;/code&gt; のための &lt;code&gt;base&lt;/code&gt; 引数（ベースの解析最初の文字によって決定されます）。</target>
        </trans-unit>
        <trans-unit id="f009580f6110aee4f2a9398c68d1bf94787198b5" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">予想されるように数値の形式は同じである&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;値と &lt;code&gt;10&lt;/code&gt; のための &lt;code&gt;base&lt;/code&gt; 引数のです。</target>
        </trans-unit>
        <trans-unit id="48ec45a6a03f7559d556421a2a44ac148d321b20" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、 &lt;code&gt;base&lt;/code&gt; 引数の値が &lt;code&gt;16&lt;/code&gt; の&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;で想定されているものと同じです。</target>
        </trans-unit>
        <trans-unit id="bb05ad1877111e85c5dfa1d9f5bf199cff8a0c43" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、 &lt;code&gt;base&lt;/code&gt; 引数の値が &lt;code&gt;8&lt;/code&gt; の&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;で想定されているものと同じです。</target>
        </trans-unit>
        <trans-unit id="f5976eb1d0b6e29b5c32d55d187559f6ff886126" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数値の形式は、&lt;a href=&quot;../../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; で&lt;/a&gt;期待されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="fecd04092122729704233da78da7584029c1baf0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、 &lt;code&gt;base&lt;/code&gt; 引数の値が &lt;code&gt;10&lt;/code&gt; の&lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt;で期待されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="5bb104d61d7e8e7ed04a16c3daae6cd68cca3601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">予想されるように数値の形式は同じである&lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt;値と &lt;code&gt;​0​&lt;/code&gt; のための &lt;code&gt;base&lt;/code&gt; 引数（ベースの解析最初の文字によって決定されます）。</target>
        </trans-unit>
        <trans-unit id="90f5746e8bc2a7796c8836cbdbee3ca457ca3f47" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、 &lt;code&gt;base&lt;/code&gt; 引数の値が &lt;code&gt;10&lt;/code&gt; の&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;で期待されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="c174dea8f8ac6d3123fee439903c3ea47dd4f027" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;で想定されているものと同じであり、 &lt;code&gt;base&lt;/code&gt; は値 &lt;code&gt;16&lt;/code&gt; です。引数のです。</target>
        </trans-unit>
        <trans-unit id="f5eb1aae953e6c6c5362653e5973307871541db0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数値の形式は、&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;で想定されているものと同じであり、 &lt;code&gt;base&lt;/code&gt; は値 &lt;code&gt;8&lt;/code&gt; です。引数のです。</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">書式文字列は、出力ストリームに変更されずにコピーされる通常のマルチバイト文字（ &lt;code&gt;%&lt;/code&gt; を除く）と変換仕様で構成されます。各変換仕様の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">フォーマット文字列は、出力ストリームに変更なしでコピーされる通常のワイド文字（ &lt;code&gt;%&lt;/code&gt; を除く）と変換仕様で構成されます。各変換仕様の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="translated">書式文字列は、0個以上の変換指定子と通常の文字（ &lt;code&gt;%&lt;/code&gt; を除く）で構成されます。終了ヌル文字を含むすべての通常の文字は、変更されずに出力文字列にコピーされます。各変換仕様は &lt;code&gt;%&lt;/code&gt; 文字で始まり、オプションで &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;O&lt;/code&gt; 修飾子（ロケールでサポートされていない場合は無視されます）が続き、その後に指定子の動作を決定する文字が続きます。次のフォーマット指定子を使用できます。</target>
        </trans-unit>
        <trans-unit id="f2ac326d01048c042fad765ae54487eb3b38a164" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. All ordinary characters, excluding the terminating null character, are written into the output stream without modification. Each unmodified conversion specifier begins with a &lt;code&gt;%&lt;/code&gt; character followed by a character that determines the behavior of the specifier. Some conversion specifiers have a modified form in which an &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier character is inserted after the &lt;code&gt;%&lt;/code&gt; character. Each conversion specifier is replaced by appropriate characters in the output as described below.</source>
          <target state="translated">書式文字列は、0個以上の変換指定子と通常の文字で構成されます。終了ヌル文字を除くすべての通常の文字は、変更されずに出力ストリームに書き込まれます。変更されていない各変換指定子は、 &lt;code&gt;%&lt;/code&gt; 文字で始まり、その後に指定子の動作を決定する文字が続きます。一部の変換指定子には、 &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;O&lt;/code&gt; 修飾子文字が &lt;code&gt;%&lt;/code&gt; の後に挿入された変更された形式があります文字のます。以下に説明するように、各変換指定子は出力で適切な文字に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="3945cb192e1c3a5530627de4981979e1dedb2322" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. Each ordinary character, excluding whitespace characters and the terminating null character, matches one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</source>
          <target state="translated">フォーマット文字列は,0個以上の変換指定子と通常の文字から構成されます。空白文字と終端のヌル文字を除く各通常文字は,入力ストリームから1つの同一の文字と一致するか,ストリーム上の次の文字が等しくない場合に関数を失敗させます。</target>
        </trans-unit>
        <trans-unit id="ae378d353693d1c7d74c4fd94775d83dcaefd506" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">書式文字列は、0個以上の変換指定子、空白文字、および通常の文字（ &lt;code&gt;%&lt;/code&gt; を除く）で構成されます。大文字と小文字を区別しない比較では、通常の各文字が入力ストリームの1文字と一致することが期待されます。各空白文字は、入力文字列の任意の空白と一致します。各変換仕様は &lt;code&gt;%&lt;/code&gt; 文字で始まり、オプションで &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;O&lt;/code&gt; 修飾子（ロケールでサポートされていない場合は無視されます）が続き、その後に指定子の動作を決定する文字が続きます。形式指定子は、POSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime（）と&lt;/a&gt;一致します。</target>
        </trans-unit>
        <trans-unit id="27b600c5cf47587815343dd3f9cb052e7b9ecfa5" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">フォーマット文字列は、0個以上の変換指定子、空白文字、および通常の文字（ &lt;code&gt;%&lt;/code&gt; を除く）で構成されます。大文字と小文字を区別しない比較では、通常の各文字が入力ストリームの1文字と一致することが期待されます。各空白文字は、入力文字列の任意の空白と一致します。各変換仕様は &lt;code&gt;%&lt;/code&gt; 文字で始まり、オプションで &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;O&lt;/code&gt; 修飾子（ロケールでサポートされていない場合は無視されます）が続き、その後に指定子の動作を決定する文字が続きます。フォーマット指定子はPOSIX関数&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime（）と&lt;/a&gt;一致します：</target>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="translated">フォーマット文字列は、次のように構成されています。</target>
        </trans-unit>
        <trans-unit id="f557203d9607d6c00cf9156c3eb7b68888a42acd" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; used by this function is always &lt;code&gt;mp.neg_format()&lt;/code&gt;.</source>
          <target state="translated">この関数で使用されるフォーマット &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; は常に &lt;code&gt;mp.neg_format()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="36de08c85d1411e27803f51f67e99c60bb0859a9" translate="yes" xml:space="preserve">
          <source>The friend declaration appears in a &lt;a href=&quot;class&quot;&gt;class body&lt;/a&gt; and grants a function or another class access to private and protected members of the class where the friend declaration appears.</source>
          <target state="translated">フレンド宣言は&lt;a href=&quot;class&quot;&gt;クラス本体に&lt;/a&gt;表示されます関数または別のクラスプライベートおよび保護されたメンバーへのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="translated">浮動小数点例外フラグの完全な内容は、例外が発生するかクリアされるかを示すブール値であるとは限りません。たとえば、ブールステータスと例外をトリガーしたコードのアドレスを含む構造体である場合があります。これらの関数は、このようなコンテンツをすべて取得し、実装定義の形式で &lt;code&gt;flagp&lt;/code&gt; に取得/保存します。</target>
        </trans-unit>
        <trans-unit id="3f3faeb997d1ed337e80e4abb047a6ba3e3e7ebc" translate="yes" xml:space="preserve">
          <source>The full path the directory entry refers to.</source>
          <target state="translated">ディレクトリエントリが参照するフルパス。</target>
        </trans-unit>
        <trans-unit id="3d6b6fb5d314fe36dd9f31283cfc562903b69b1f" translate="yes" xml:space="preserve">
          <source>The function (or member) name specified by &lt;code&gt;E&lt;/code&gt; can be overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules used to decide which overload is to be called.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; で指定された関数（またはメンバー）名は、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード&lt;/a&gt;可能で、オーバーロード解決どのオーバーロードを呼び出すかを決定するために使用される規則。</target>
        </trans-unit>
        <trans-unit id="e82b0b07e6f429ee9f9368f05dad9fa0ba43d37a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;TC::now()&lt;/code&gt; does not throw exceptions.</source>
          <target state="translated">関数 &lt;code&gt;TC::now()&lt;/code&gt; は例外をスローしません。</target>
        </trans-unit>
        <trans-unit id="0e4cb90e10ef6ef7003e78c1e00b67a01ecdf0f5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">関数 &lt;code&gt;canonical()&lt;/code&gt; はPOSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpathを&lt;/a&gt;モデルにしていますます。</target>
        </trans-unit>
        <trans-unit id="a8f8abebb05723f10583ccaaf0c51e54fca3aa87" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">関数 &lt;code&gt;canonical()&lt;/code&gt; は、&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;POSIXrealpathを&lt;/a&gt;モデルにしています。</target>
        </trans-unit>
        <trans-unit id="83d5158312c85ad69a25e7f6c7b3eb92ed2aac66" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">関数 &lt;code&gt;std::frexp&lt;/code&gt; とそのデュアル &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt; 、直接ビット操作することなく、浮動小数点数の表現を操作するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="7a6d7907ee719b354792f98bec95c1316c2a0690" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">関数 &lt;code&gt;std::ldexp&lt;/code&gt; （ &quot;load exponent&quot;）とそのデュアル &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 、ビットを直接操作せずに浮動小数点数の表現を操作できます。</target>
        </trans-unit>
        <trans-unit id="57c5dfaac85f79a223adb7359ed5cef42e000f8a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;weakly_canonical()&lt;/code&gt; was introduced to simplify operational semantics of &lt;a href=&quot;relative&quot;&gt;&lt;code&gt;relative()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">関数 &lt;code&gt;weakly_canonical()&lt;/code&gt; は、&lt;a href=&quot;relative&quot;&gt; &lt;code&gt;relative()&lt;/code&gt; の&lt;/a&gt;操作セマンティクスを簡素化するために導入されました。</target>
        </trans-unit>
        <trans-unit id="65499eb81228ba91e476f471dc5abca02679437e" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;std::free&lt;/code&gt;.</source>
          <target state="translated">この関数は、特殊なケースの量を減らすために、nullポインターを受け入れます（何もしません）。割り当てが成功したかどうかにかかわらず、割り当て関数から返されたポインタは &lt;code&gt;std::free&lt;/code&gt; 渡すことができます。</target>
        </trans-unit>
        <trans-unit id="2446536a1064ed7b3941beeb277b791515eaa68b" translate="yes" xml:space="preserve">
          <source>The function body is a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</source>
          <target state="translated">関数本体は、&lt;a href=&quot;statements#Compound_statements&quot;&gt;複合ステートメント&lt;/a&gt;（中括弧のペアで囲まれた0個以上のステートメントのシーケンス）であり、関数呼び出しが行われたときに実行されます。</target>
        </trans-unit>
        <trans-unit id="c3d08aba422a7497ce575560818de2b5e3664ee2" translate="yes" xml:space="preserve">
          <source>The function call expressions have the form.</source>
          <target state="translated">関数呼び出し式は、形式を持っています。</target>
        </trans-unit>
        <trans-unit id="ef5f5323e424bfd7a1f80cd467bc80719cc4bc17" translate="yes" xml:space="preserve">
          <source>The function called by a user-defined literal is known as</source>
          <target state="translated">ユーザー定義リテラルによって呼び出される関数は</target>
        </trans-unit>
        <trans-unit id="21d35ce53dec97b605e35fbf4bfeaf3e6b25267e" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; to advance the input sequence. If that function returns &lt;code&gt;Traits::eof()&lt;/code&gt; meaning that input sequence has been exhausted and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; could not retrieve more data, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned. Otherwise &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; is called in order to read the character.</source>
          <target state="translated">関数は &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; を呼び出して、入力シーケンスを進めます。その関数が &lt;code&gt;Traits::eof()&lt;/code&gt; 返し、入力シーケンスが使い果たされ、 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; がそれ以上データを取得できなかった場合、 &lt;code&gt;Traits::eof()&lt;/code&gt; が返されます。それ以外の場合は &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; 、文字を読み取るためにが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e8f1319f9d6ef5782692a77b9fd4057196ea681b" translate="yes" xml:space="preserve">
          <source>The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; とは異なる戻り値の型で実装できます。この場合、置換タイプには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="c822a40a4534bfa3e5439e5ab35928c6a3a344b3" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator&amp;lt;&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">この関数は、タイプ &lt;code&gt;T&lt;/code&gt; に &lt;code&gt;operator&amp;lt;&lt;/code&gt; が定義されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="882d329b93dcad39ff502adfce6844369dd33e8b" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator+=&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;. If the &lt;code&gt;std::valarray&lt;/code&gt; is empty, the behavior is undefined. The order in which the elements are processed by this function is unspecified.</source>
          <target state="translated">この関数は、タイプ &lt;code&gt;T&lt;/code&gt; に &lt;code&gt;operator+=&lt;/code&gt; が定義されている場合にのみ使用できます。 &lt;code&gt;std::valarray&lt;/code&gt; 場合空で、動作は未定義です。この関数が要素を処理する順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="91f7fe88eabe258e81ae01d0f690791e30dabd0d" translate="yes" xml:space="preserve">
          <source>The function does not participate in overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; インスタンスでない限り、関数はオーバーロード解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="b0d7738f85da6ab4917bf056d0bb5e776378bfa8" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; でない限り、関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="3f53989ed7fe6b85b91be67846d454e5a5091efc" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; インスタンスであり、 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; でない限り、関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="2bf9d721422f351f851c897408c2ce6f0621c92c" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; インスタンスでない限り、関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="38127f74fcf3c7345c5f5fdb8dc95f19e70fd613" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 特殊化であり、 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; でない限り、関数はオーバーロード解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="4dd86d349303d51526c774f537efd9b40b552f98" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 特殊化でない限り、関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="translated">この関数はローカライズをサポートしておらず、改行文字を削除することはできません。</target>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="translated">この機能はローカライズをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="b9ca2d431e6b4c994632d537c675b64adb91091c" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">この関数は、以前の &lt;code&gt;ungetc&lt;/code&gt; の呼び出しからの影響をすべて削除します。</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">関数には、&amp;pi;（1/2 + n）に数学的な極があります。ただし、一般的な浮動小数点表現では&amp;pi;/ 2を正確に表現できないため、極エラーが発生する引数の値はありません。</target>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="translated">関数は虚部の符号を考慮して分岐部に連続しています。</target>
        </trans-unit>
        <trans-unit id="064517df7162e7c80b05f70d0c1d72dcf596b5e9" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; と同等です。。ただし、ファイルの終わりとエラーのインジケータがクリアされる点が異なります。</target>
        </trans-unit>
        <trans-unit id="75e35cecac837fab428a324853818b53ded0ac11" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">この関数は、プログラミング言語APLの整数関数afterにちなんで名付けられています。これは、C ++ 98に含まれていない&lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STLコンポーネントの&lt;/a&gt; 1つでしたが、最終的にはC ++ 11の標準ライブラリに組み込まれました。</target>
        </trans-unit>
        <trans-unit id="fe1dff5e844a0cf75859a0d38601b66527b350d8" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;https://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">この関数は、プログラミング言語APLの整数関数⍳にちなんで名付けられています。これは、C ++ 98に含まれていなかった&lt;a href=&quot;https://www.sgi.com/tech/stl/iota.html&quot;&gt;STLコンポーネントの&lt;/a&gt;1つでしたが、最終的にはC ++ 11の標準ライブラリになりました。</target>
        </trans-unit>
        <trans-unit id="e9eb4c7699e43ce8f08f56257eff79ffdcf27b49" translate="yes" xml:space="preserve">
          <source>The function is not required to be defined for |x|&amp;gt;1</source>
          <target state="translated">| x |&amp;gt; 1に対して関数を定義する必要はありません</target>
        </trans-unit>
        <trans-unit id="b0d406efcda5923258fa6e7ba435edf7afdbb66b" translate="yes" xml:space="preserve">
          <source>The function is only required to be defined where both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are greater than zero, and is allowed to report a domain error otherwise.</source>
          <target state="translated">関数は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方がゼロより大きい場合にのみ定義する必要があり、そうでない場合はドメインエラーを報告できます。</target>
        </trans-unit>
        <trans-unit id="6034c35371ebcc562e4d00c27057a576e4fdd7db" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;gptr&lt;/code&gt;, &lt;code&gt;egptr&lt;/code&gt; and &lt;code&gt;eback&lt;/code&gt; pointers to define the location of newly loaded data (if any). On failure, the function ensures that either &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() == egptr&lt;/code&gt;.</source>
          <target state="translated">関数は &lt;code&gt;gptr&lt;/code&gt; 、 &lt;code&gt;egptr&lt;/code&gt; および &lt;code&gt;eback&lt;/code&gt; ポインターを更新して、新しくロードされたデータ（存在する場合）の場所を定義します。失敗した場合、関数は &lt;code&gt;gptr() == nullptr&lt;/code&gt; または &lt;code&gt;gptr() == egptr&lt;/code&gt; いずれかを保証します。</target>
        </trans-unit>
        <trans-unit id="e7a7a46183956d552300dee684d15128ebe48ebf" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;pptr&lt;/code&gt;, &lt;code&gt;epptr&lt;/code&gt; and &lt;code&gt;pbase&lt;/code&gt; pointers to define the location to write more data. On failure, the function ensures that either &lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() == epptr&lt;/code&gt;.</source>
          <target state="translated">更新することができる機能 &lt;code&gt;pptr&lt;/code&gt; 、 &lt;code&gt;epptr&lt;/code&gt; および &lt;code&gt;pbase&lt;/code&gt; ポインタは、より多くのデータを書き込むために位置を定義します。失敗した場合、関数は &lt;code&gt;pptr() == nullptr&lt;/code&gt; または &lt;code&gt;pptr() == epptr&lt;/code&gt; いずれかを保証します。</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="translated">この関数は静的ストレージを変更し、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="ab3db171e79e2989a832c6ee9c99d6df12884a1d" translate="yes" xml:space="preserve">
          <source>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">関数は、指定された配置によって配置された必要なバイト数をバッファーに収めることができる場合にのみ、ポインターを変更します。バッファが小さすぎる場合、関数は何もせず &lt;code&gt;nullptr&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="translated">この関数は、渡されたオブジェクトを変更してはいけません。また、同じオブジェクトに対して呼び出された場合は、配列内の位置に関係なく一貫した結果を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="6f186c1fa81fe391780ded04d401cc94118bdba5" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot;</source>
          <target state="translated">関数名は &quot;complementary span &quot;の略です。</target>
        </trans-unit>
        <trans-unit id="db20681f76479d1a2df4829db6ccf4a0a080e0ef" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;new scalb&quot;, where &lt;code&gt;scalb&lt;/code&gt; was an older non-standard function whose second argument had floating-point type.</source>
          <target state="translated">関数名は「新しいscalb」を表します。ここで、 &lt;code&gt;scalb&lt;/code&gt; は2番目の引数が浮動小数点型の古い非標準関数でした。</target>
        </trans-unit>
        <trans-unit id="c9dcfedf49fa204154f0431b2673a0daebcd06a5" translate="yes" xml:space="preserve">
          <source>The function object &lt;code&gt;pred&lt;/code&gt; shall not apply any non-constant function through the dereferenced iterator. This function object may be a pointer to function or an object of a type with an appropriate function call operator.</source>
          <target state="translated">関数オブジェクト &lt;code&gt;pred&lt;/code&gt; は、間接参照されたイテレータを通じて非定数関数を適用しません。この関数オブジェクトは、関数へのポインター、または適切な関数呼び出し演算子を持つ型のオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="fec4de0270a6f3097d68f50b43e7edfb64e10dc9" translate="yes" xml:space="preserve">
          <source>The function parameters that do not participate in template argument deduction (e.g. if the corresponding template arguments are explicitly specified) are subject to implicit conversions to the type of the corresponding function parameter (as in the usual &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;).</source>
          <target state="translated">テンプレート引数の推定に参加しない関数パラメーター（対応するテンプレート引数が明示的に指定されている場合など）は、対応する関数パラメーターの型への暗黙的な変換の対象になります（通常の&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決と&lt;/a&gt;同様）。</target>
        </trans-unit>
        <trans-unit id="7eeb93d2b7dca68685dc425373a6764fb01e3729" translate="yes" xml:space="preserve">
          <source>The function provides no means to prevent buffer overflow of the destination array, given sufficiently long input string. &lt;code&gt;std::gets&lt;/code&gt; was deprecated in C++11 and removed from C++14.</source>
          <target state="translated">この関数は、十分に長い入力文字列が与えられた場合、宛先配列のバッファオーバーフローを防止する手段を提供しません。 &lt;code&gt;std::gets&lt;/code&gt; はC ++ 11で廃止され、C ++ 14から削除されました。</target>
        </trans-unit>
        <trans-unit id="fa9dad8347dfb2e0d670a4af83e853b0527c897a" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with some of its arguments bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">関数テンプレート &lt;code&gt;bind&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の転送呼び出しラッパーを生成します。このラッパーを呼び出すことは、引数の一部を &lt;code&gt;args&lt;/code&gt; にバインドして &lt;code&gt;f&lt;/code&gt; を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="1b74686fedbb22b834206589460eadd916d0aa6c" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind_front&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with its first &lt;code&gt;sizeof...(Args)&lt;/code&gt; parameters bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">関数テンプレート &lt;code&gt;bind_front&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の転送呼び出しラッパーを生成しますます。このラッパーを呼び出すことは、最初の &lt;code&gt;sizeof...(Args)&lt;/code&gt; パラメーターを &lt;code&gt;args&lt;/code&gt; にバインドして &lt;code&gt;f&lt;/code&gt; を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="a42b57be9690e30b4d127d5c56b2e136867973a2" translate="yes" xml:space="preserve">
          <source>The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;in the Itanium C++ ABI&lt;/a&gt; (&lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt;), meaning that the linker will erroneously consider them to be the same entity.</source>
          <target state="translated">関数テンプレート＃1と＃3はシグネチャが異なり、異なるテンプレートです。それにもかかわらず、＃2と＃4は、異なる関数テンプレートのインスタンス化であるにもかかわらず&lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;、Itanium C ++ ABI&lt;/a&gt;（ &lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt; ）で同じ符号化された名前を持ちます。つまり、リンカーはそれらを誤って同じエンティティと見なします。</target>
        </trans-unit>
        <trans-unit id="1661ab084a02d0a0b4022e49867df5380e8a9ad8" translate="yes" xml:space="preserve">
          <source>The function templates are then ranked as if for &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;function template overloading&lt;/a&gt;.</source>
          <target state="translated">関数テンプレートは、&lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;関数テンプレートのオーバーロードの&lt;/a&gt;場合と同様にランク付けされます。</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="translated">その後、この関数はトークンの先頭へのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="4126da2324b4eb270d68c514e43af8301f52dd63" translate="yes" xml:space="preserve">
          <source>The function to calculate the result has not been started yet</source>
          <target state="translated">結果を計算する関数はまだ起動していません。</target>
        </trans-unit>
        <trans-unit id="eb957ebe7149eefbfbfc9fa1905a6cdb297d02f9" translate="yes" xml:space="preserve">
          <source>The function type of the function template is &lt;code&gt;P&lt;/code&gt;. The &lt;a href=&quot;overloaded_address&quot;&gt;target type&lt;/a&gt; is the type of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">関数テンプレートの関数タイプは &lt;code&gt;P&lt;/code&gt; です。の&lt;a href=&quot;overloaded_address&quot;&gt;ターゲット・タイプは&lt;/a&gt;のタイプである &lt;code&gt;A&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d62041d0f93824e7e4927764fa5aa1df2523bc0c" translate="yes" xml:space="preserve">
          <source>The function-call operator is always &lt;code&gt;constexpr&lt;/code&gt; if it satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr function&lt;/a&gt;. It is also constexpr if the keyword constexpr was used in the lambda declaration.</source>
          <target state="translated">関数呼び出し演算子は常に &lt;code&gt;constexpr&lt;/code&gt; です、&lt;a href=&quot;constexpr&quot;&gt;constexpr関数の&lt;/a&gt;要件を満たす場合、です。キーワードconstexprがラムダ宣言で使用された場合もconstexprです。</target>
        </trans-unit>
        <trans-unit id="90237372df253176f7201dadf305ca2efdb82ba0" translate="yes" xml:space="preserve">
          <source>The function-call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the keyword &lt;code&gt;consteval&lt;/code&gt; was used in the lambda expression.</source>
          <target state="translated">関数呼び出し演算子は&lt;a href=&quot;consteval&quot;&gt;即時関数です&lt;/a&gt;キーワード &lt;code&gt;consteval&lt;/code&gt; がラムダ式で使用された場合、です。</target>
        </trans-unit>
        <trans-unit id="18222cb267ac69f3312ca400b95bb5960956fbce" translate="yes" xml:space="preserve">
          <source>The function-call operators of T are obtained by ordinary &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; of the name &lt;code&gt;operator()&lt;/code&gt; in the context of the expression &lt;code&gt;(E).operator()&lt;/code&gt;, and every declaration found is added to the set of candidate functions.</source>
          <target state="translated">Tの関数呼び出し演算子は、名前 &lt;code&gt;operator()&lt;/code&gt; の通常の&lt;a href=&quot;lookup&quot;&gt;検索&lt;/a&gt;によって取得されます。、式 &lt;code&gt;(E).operator()&lt;/code&gt; のコンテキストでれ、見つかったすべての宣言が候補関数のセットに追加されます。</target>
        </trans-unit>
        <trans-unit id="5f03f8854c3dadb42ebc1a2f13e6f98271799bab" translate="yes" xml:space="preserve">
          <source>The function-like entities described on this page are</source>
          <target state="translated">このページに記載されている機能的なエンティティは</target>
        </trans-unit>
        <trans-unit id="c90c3720bc6cd842ff45d50c455cbeb05ef64826" translate="yes" xml:space="preserve">
          <source>The function-try-block is one of the alternative syntax forms for function-body, which is a part of &lt;a href=&quot;function&quot;&gt;function definition&lt;/a&gt;.</source>
          <target state="translated">function-try-blockは、function-bodyの代替構文形式の1つです。これは、 &lt;a href=&quot;function&quot;&gt;関数定義の&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d70566d5bc405ba10ba5bb68262596374bff760" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;std::log1p&lt;/code&gt; は、たとえば、毎日の小さな金利を計算するときの財務計算に役立ちます：（1 + x）n</target>
        </trans-unit>
        <trans-unit id="ce063565abd09222888790e9a9d67e9d39a935ae" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;std::expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">関数 &lt;code&gt;std::expm1&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; は、たとえば、毎日の小さな金利を計算するときの財務計算に役立ちます：（1 + x）n</target>
        </trans-unit>
        <trans-unit id="7d057934f5d91a8d0d5efe334eb2fd28c09a314a" translate="yes" xml:space="preserve">
          <source>The functions may be called concurrently with the destruction of the objects with static storage duration and with each other, maintaining the guarantee that if registration of A was sequenced-before the registration of B, then the call to B is sequenced-before the call to A, same applies to the sequencing between static object constructors and calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">関数は、静的な保存期間を持つオブジェクトの破棄と同時に、または互いに呼び出すことができ、Aの登録がBの登録の前にシーケンス化されている場合、Bへの呼び出しは、 A、同じことが静的オブジェクトコンストラクターと &lt;code&gt;atexit&lt;/code&gt; の呼び出しの間のシーケンスにも当てはまります &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">関数は、 &lt;code&gt;endptr&lt;/code&gt; が指すポインターを、解釈された最後の文字を過ぎた文字を指すように設定します。 &lt;code&gt;endptr&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; の場合、無視されます。</target>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">関数は、 &lt;code&gt;endptr&lt;/code&gt; が指すポインターを、解釈された最後の文字を超えたワイド文字を指すように設定します。 &lt;code&gt;endptr&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; の場合、無視されます。</target>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">関数は、 &lt;code&gt;str_end&lt;/code&gt; が指すポインターを、解釈された最後の文字を過ぎた文字を指すように設定します。 &lt;code&gt;str_end&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; の場合、無視されます。</target>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">関数は、 &lt;code&gt;str_end&lt;/code&gt; が指すポインターを、解釈された最後の文字を超えたワイド文字を指すように設定します。 &lt;code&gt;str_end&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; の場合、無視されます。</target>
        </trans-unit>
        <trans-unit id="f29db516e7cae858024d84b5b0bd244f31b9db50" translate="yes" xml:space="preserve">
          <source>The functions that accept rvalue reference parameters (including &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt;, and regular member functions such as &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;) are selected, by &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when called with &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; arguments (either &lt;a href=&quot;../language/value_category&quot;&gt;prvalues&lt;/a&gt; such as a temporary objects or &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; such as the one produced by &lt;code&gt;std::move&lt;/code&gt;). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to</source>
          <target state="translated">右辺値参照パラメーターを受け入れる関数（&lt;a href=&quot;../language/move_constructor&quot;&gt;移動コンストラクター&lt;/a&gt;、&lt;a href=&quot;../language/move_operator&quot;&gt;移動代入演算子&lt;/a&gt;、および通常のメンバー関数など） &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../language/value_category&quot;&gt;値&lt;/a&gt;引数（一時オブジェクトなどの&lt;a href=&quot;../language/value_category&quot;&gt; prvalues）を&lt;/a&gt;指定して呼び出されると、&lt;a href=&quot;../language/overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;によって選択されますまたは &lt;code&gt;std::move&lt;/code&gt; によって生成されるような&lt;a href=&quot;../language/value_category&quot;&gt; xvalues&lt;/a&gt;）。引数がリソース所有オブジェクトを識別する場合、これらのオーバーロードにはオプションがありますが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="e09608bd7873c020fdfa17e45a1cb9324cfb8735" translate="yes" xml:space="preserve">
          <source>The functions underflow() and overflow()/sync() perform the actual I/O between the file and the get and put areas of the buffer. When &lt;code&gt;CharT&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;, most implementations store multibyte characters in the file and a &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet is used to perform wide/multibyte character conversion.</source>
          <target state="translated">関数underflow（）およびoverflow（）/ sync（）は、ファイルとバッファのgetおよびput領域の間で実際のI / Oを実行します。 &lt;code&gt;CharT&lt;/code&gt; が &lt;code&gt;char&lt;/code&gt; でない場合、ほとんどの実装はマルチバイト文字をファイルに格納し、 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; ファセットを使用してワイド/マルチバイト文字変換を実行します。</target>
        </trans-unit>
        <trans-unit id="bffe0d58cdd89a2176e51e07265897958db537f6" translate="yes" xml:space="preserve">
          <source>The functions will be called during the destruction of the static objects, in reverse order: if A was registered before B, then the call to B is made before the call to A. Same applies to the ordering between static object constructors and the calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">関数は、静的オブジェクトの破棄中に逆の順序で呼び出されます。AがBの前に登録されている場合、Bの呼び出しはAの呼び出しの前に行われます。静的オブジェクトコンストラクターと次の呼び出しの間の順序にも同じことが当てはまります。 &lt;code&gt;atexit&lt;/code&gt; ： &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="aed96e855f7e3173d3f85e69b959cd5f429e28d2" translate="yes" xml:space="preserve">
          <source>The generated random number.</source>
          <target state="translated">生成された乱数。</target>
        </trans-unit>
        <trans-unit id="7e36dee47d5123274fbbdd384f8394bc9448d978" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy assignment operator is deprecated(since C++11) if &lt;code&gt;T&lt;/code&gt; has a user-declared destructor or user-declared copy constructor.</source>
          <target state="translated">暗黙的に定義されたコピー代入演算子の生成は（C ++ 11以降）非推奨です。 &lt;code&gt;T&lt;/code&gt; にユーザー宣言のデストラクタまたはユーザー宣言のコピーコンストラクタがある。</target>
        </trans-unit>
        <trans-unit id="9e1eed93866aa0d0e35d2a62d35e689f1a41f754" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy constructor is deprecated if &lt;code&gt;T&lt;/code&gt; has a user-defined destructor or user-defined copy assignment operator.</source>
          <target state="translated">暗黙的に定義されたコピーコンストラクタの生成は、 &lt;code&gt;T&lt;/code&gt; にユーザー定義のデストラクタまたはユーザー定義のコピー代入演算子がある。</target>
        </trans-unit>
        <trans-unit id="4f4aa88d036bf2efbab8a357c041b989e684ecb4" translate="yes" xml:space="preserve">
          <source>The generic template and two template specializations each contain a single version of &lt;code&gt;get&lt;/code&gt;. The three versions of &lt;code&gt;get&lt;/code&gt; differ only in the return type.</source>
          <target state="translated">汎用テンプレートと2つのテンプレート特殊化には、それぞれ1つのバージョンの &lt;code&gt;get&lt;/code&gt; が含まれています。 &lt;code&gt;get&lt;/code&gt; の3つのバージョンは、戻り値の型のみが異なります。</target>
        </trans-unit>
        <trans-unit id="7aac1cf4d4dcf6d2df58133c2a7081efc8452b18" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cerr&lt;/code&gt; and &lt;code&gt;std::wcerr&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt;, respectively), associated with the standard C error output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">グローバルオブジェクト &lt;code&gt;std::cerr&lt;/code&gt; および &lt;code&gt;std::wcerr&lt;/code&gt; は、実装定義型のストリームバッファーへの出力を制御します（ &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt; から派生）は、標準Cエラー出力ストリーム &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; に関連付けられている、それぞれ。</target>
        </trans-unit>
        <trans-unit id="4cdce0c44ee46c553e1a9e5502ff67dca5ca8589" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cin&lt;/code&gt; and &lt;code&gt;std::wcin&lt;/code&gt; control input from a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C input stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">グローバルオブジェクト &lt;code&gt;std::cin&lt;/code&gt; および &lt;code&gt;std::wcin&lt;/code&gt; は、実装定義型のストリームバッファーからの入力を制御します（ &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; から派生）は、標準C入力ストリーム &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; に関連付けられた、。</target>
        </trans-unit>
        <trans-unit id="461aa84897b843038a6471036df9b6bfd2e5db28" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::clog&lt;/code&gt; and &lt;code&gt;std::wclog&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;, but, unlike &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt;, these streams are not automatically flushed and not automatically tie()'d with cout.</source>
          <target state="translated">グローバルオブジェクト &lt;code&gt;std::clog&lt;/code&gt; および &lt;code&gt;std::wclog&lt;/code&gt; は、標準C出力ストリーム &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; に関連付けられている、実装定義型（ &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; から派生）のストリームバッファーへの出力を制御しますが、 &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; とは異なります:: wcerr、これらのストリームは自動的にフラッシュされず、coutで自動的にtie（）されません。</target>
        </trans-unit>
        <trans-unit id="f5f98bba6559b17ed7e6d131e3611a81638ab812" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">グローバルオブジェクト &lt;code&gt;std::cout&lt;/code&gt; および &lt;code&gt;std::wcout&lt;/code&gt; は、標準C出力ストリーム &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に関連付けられた、実装定義型（ &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; から派生）のストリームバッファーへの出力を制御します。。</target>
        </trans-unit>
        <trans-unit id="70f50373a3f6e5f0380c536e396a13926eb96f45" translate="yes" xml:space="preserve">
          <source>The goto statement transfers control to the location specified by &lt;a href=&quot;statements#Labels&quot;&gt;label&lt;/a&gt;. The goto statement must be in the same function as the label it is referring, it may appear before or after the label.</source>
          <target state="translated">gotoステートメントは、&lt;a href=&quot;statements#Labels&quot;&gt;labelで&lt;/a&gt;指定された場所に制御を移します。gotoステートメントは、参照しているラベルと同じ関数内にある必要があります。ラベルの前または後に表示できます。</target>
        </trans-unit>
        <trans-unit id="9203ba2e1b9acd8459fc296135b185d6bdec6014" translate="yes" xml:space="preserve">
          <source>The groups are stored as binary values: three-digit group is &lt;code&gt;'\3'&lt;/code&gt;, and 51-digit group is &lt;code&gt;'3'&lt;/code&gt;. The character at index zero of the returned string holds the number of digits in the rightmost group. The character at index 1 holds the number of digits in the second group from the right, etc. The grouping indicated by the last character in the returned string is reused to group all remaining digits in the (left part of) the number.</source>
          <target state="translated">グループはバイナリ値として保存されます。3桁のグループは &lt;code&gt;'\3'&lt;/code&gt; で、51桁のグループは &lt;code&gt;'3'&lt;/code&gt; です。返される文字列のインデックス0の文字は、右端のグループの桁数を保持します。インデックス1の文字は、右から2番目のグループの桁数を保持します。返された文字列の最後の文字が示すグループは、番号の（左側の）残りのすべての桁をグループ化するために再利用されます。</target>
        </trans-unit>
        <trans-unit id="377e30e67488234928e5265aef21fdf60f228f58" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;a href=&quot;to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">&lt;code&gt;std::from_chars&lt;/code&gt; が&lt;a href=&quot;to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt;によってフォーマットされたすべての浮動小数点値を回復できることの保証両方の機能は同じ実装からであれば、正確にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="6a78268c72fa332949b19e97ea94c6bd065b9550" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;code&gt;to_chars&lt;/code&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">&lt;code&gt;std::from_chars&lt;/code&gt; が &lt;code&gt;to_chars&lt;/code&gt; によってフォーマットされたすべての浮動小数点値を回復できることの保証両方の機能は同じ実装からであれば、正確にのみ設けられています。</target>
        </trans-unit>
        <trans-unit id="bb6a61b9c44ca51fc2d67b8e734fd60e0f744ad5" translate="yes" xml:space="preserve">
          <source>The hash code of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">関連する &lt;code&gt;type_info&lt;/code&gt; オブジェクトのハッシュコード。</target>
        </trans-unit>
        <trans-unit id="b862a5e504b0376ea8c84c346ba305c970071424" translate="yes" xml:space="preserve">
          <source>The hash function.</source>
          <target state="translated">ハッシュ関数です。</target>
        </trans-unit>
        <trans-unit id="3937832fedbe42cd580633aa32952bacd6b0b437" translate="yes" xml:space="preserve">
          <source>The hash value that respects collation order.</source>
          <target state="translated">照合順序を考慮したハッシュ値。</target>
        </trans-unit>
        <trans-unit id="e822b844b21e9499cc3d98cbf3f05f1abdf07e6d" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utility templates designed to ease constraining common algorithm operations.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;../header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt;は、一般的なアルゴリズム操作の制約を容易にするために設計された一連の概念と関連するユーティリティテンプレートを提供します。</target>
        </trans-unit>
        <trans-unit id="32774d695cdea646f90e7d021305a854ad71bc9b" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; must be included before using &lt;code&gt;typeid&lt;/code&gt; (if the header is not included, every use of the keyword &lt;code&gt;typeid&lt;/code&gt; makes the program ill-formed.).</source>
          <target state="translated">&lt;code&gt;typeid&lt;/code&gt; を使用する前に、ヘッダー&lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;を&lt;/a&gt;含める必要があります（ヘッダーが含まれていない場合、キーワード &lt;code&gt;typeid&lt;/code&gt; を使用するたびに、プログラムの形式が正しくありません）。</target>
        </trans-unit>
        <trans-unit id="39e45883b37cb57381dea376201d7779a8f05664" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/bit&quot;&gt;&lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt;&lt;/a&gt; provides several function templates to access, manipulate, and process individual bits and bit sequences.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/bit&quot;&gt; &lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; &lt;/a&gt;は、個々のビットおよびビットシーケンスにアクセス、操作、および処理するためのいくつかの関数テンプレートを提供します。</target>
        </trans-unit>
        <trans-unit id="c204ad70977b9fc2b727eaecd4f753ba2d1dc617" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cfenv&quot;&gt;&lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/cfenv&quot;&gt; &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; &lt;/a&gt;は、オーバーフローやゼロ除算などの&lt;a href=&quot;numeric/fenv&quot;&gt;例外的な浮動小数点状態&lt;/a&gt;に関連するフラグと関数を定義します。</target>
        </trans-unit>
        <trans-unit id="0cbc07e97f0d93b88b9c5ece9e00510e37bf2c6a" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; also provides several mathematical special functions such as &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt; などのいくつかの数学的な特殊関数も提供します。</target>
        </trans-unit>
        <trans-unit id="5f4dd67444c139abdd3f7b0de3e2b42f5e337403" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; などの&lt;a href=&quot;numeric/math&quot;&gt;標準Cライブラリ数学関数を&lt;/a&gt;提供します。</target>
        </trans-unit>
        <trans-unit id="743b06117d162324a98c31415f3c294f57b66ed9" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utilities designed to ease constraining common algorithm operations.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt;は、一般的なアルゴリズム操作の制約を容易にするために設計された一連の概念と関連ユーティリティを提供します。</target>
        </trans-unit>
        <trans-unit id="508d20b6cea54c392d295d11726346c65aa4b0b3" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/numeric&quot;&gt;&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;&lt;/a&gt; provides numeric algorithms below:</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/numeric&quot;&gt; &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; &lt;/a&gt;は、以下の数値アルゴリズムを提供します。</target>
        </trans-unit>
        <trans-unit id="ba440bf8e1f8c37da5221f67c871d6fb13769ff0" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/random&quot;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/random&quot;&gt;pseudo-random number generators and numerical distributions&lt;/a&gt;. The header &lt;a href=&quot;header/cstdlib&quot;&gt;&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;&lt;/a&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/random&quot;&gt; &lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;numeric/random&quot;&gt;疑似乱数ジェネレーターと数値分布を&lt;/a&gt;定義します。ヘッダー&lt;a href=&quot;header/cstdlib&quot;&gt; &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; &lt;/a&gt;には、 &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; によるCスタイルの乱数生成も含まれています。</target>
        </trans-unit>
        <trans-unit id="dd8e217a3115bdf6060d0de317017567a06a41d7" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/ratio&quot;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/ratio&quot;&gt;types and functions for manipulating and storing compile-time ratios&lt;/a&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/ratio&quot;&gt; &lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;numeric/ratio&quot;&gt;、コンパイル時の比率を操作および保存するためのタイプと関数を&lt;/a&gt;提供します。</target>
        </trans-unit>
        <trans-unit id="218920ec6c8d077db4c2f0630d45c58c68f68e0c" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/version&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/a&gt; supplies implementation-dependent information about the C++ standard library (such as the version number and release date. It also defines the &lt;a href=&quot;utility/feature_test&quot;&gt;library feature-test macros&lt;/a&gt;.</source>
          <target state="translated">ヘッダー&lt;a href=&quot;header/version&quot;&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/a&gt;は、C ++標準ライブラリに関する実装依存の情報（バージョン番号やリリース日など）を提供します。また、&lt;a href=&quot;utility/feature_test&quot;&gt;ライブラリの機能テストマクロ&lt;/a&gt;も定義します。</target>
        </trans-unit>
        <trans-unit id="bf5126087a87a6889e7920c9e1157d0b23d15572" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; provides several classes and functions related to exception handling in C++ programs.</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; は、C ++プログラムでの例外処理に関連するいくつかのクラスと関数を提供します。</target>
        </trans-unit>
        <trans-unit id="bc6caf28cb4847d14f957dc4f821e46a30b84457" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines (directly or indirectly) an instance of &lt;code&gt;std::ios_base::Init&lt;/code&gt; with static storage duration: this makes it safe to access the standard I/O streams in the constructors and destructors of static objects with &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; is included in the translation unit before these objects were defined).</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; は、静的ストレージ期間を持つ &lt;code&gt;std::ios_base::Init&lt;/code&gt; インスタンスを（直接的または間接的に）定義するかのように動作します。これにより、静的オブジェクトのコンストラクターおよびデストラクタ内の標準I / Oストリームに安全にアクセスできます。&lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;順序付け初期化&lt;/a&gt;（限り &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; これらのオブジェクトが定義される前に、翻訳単位に含まれます）。</target>
        </trans-unit>
        <trans-unit id="fd4ecbc573accaaae87826b6f734bf136d186983" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; defines types and functions used to report error conditions originating from the operating system, streams I/O, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, or other low-level APIs.</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; は、オペレーティングシステム、ストリームI / O、 &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 、またはその他の低レベルAPIに起因するエラー状態を報告するために使用されるタイプと関数を定義します。</target>
        </trans-unit>
        <trans-unit id="57e8428ad704374a45b4d8a73edeba81162f1a2e" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; are meaningless in C++ because the macros they provide in C are language keywords in C++.</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; は、C ++で提供されるマクロがC ++の言語キーワードであるため、C ++では無意味です。</target>
        </trans-unit>
        <trans-unit id="7e08bc9e99ec8f39019e1085b8cf1191154179ba" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. The use of all these headers is deprecated in C++.</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; には、C標準ライブラリのコンテンツは含まれず、代わりにC ++標準ライブラリの他のヘッダーが含まれています。これらすべてのヘッダーの使用は、C ++では推奨されていません。</target>
        </trans-unit>
        <trans-unit id="9d743155eef03d9de2f708dc85802d31a16ee771" translate="yes" xml:space="preserve">
          <source>The hexadecimal floating-point literals were not part of C++ until C++17, although they can be parsed and printed by the I/O functions since C++11: both C++ I/O streams when &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; is enabled and the C I/O streams: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt;, etc. See &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for the format description.</source>
          <target state="translated">16進浮動小数点リテラルは、C ++ 17まではC ++の一部ではありませんでしたが、C ++ 11以降は、I / O関数によって解析および出力できます &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; が有効で、 CI / Oストリーム： &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; などを参照の &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 形式の説明のため。</target>
        </trans-unit>
        <trans-unit id="2bcfe16e4a34071ba0fe16d4ac0cbe3af5aafda3" translate="yes" xml:space="preserve">
          <source>The hinted insert (3,4) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">ヒント付き挿入（3,4）は、 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; などの順次コンテナでの位置挿入とシグネチャ互換にするためにブール値を返しません。これにより、 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; などの汎用インサーターを作成できます。ヒントのある挿入が成功したかどうかを確認する1つの方法は、前後で&lt;a href=&quot;size&quot;&gt;size（）&lt;/a&gt;を比較することです。</target>
        </trans-unit>
        <trans-unit id="25af4f74a579fcba3c500fb626cf10f9c5227e2b" translate="yes" xml:space="preserve">
          <source>The hinted insert (4-6) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">ヒント付き挿入（4-6）は、 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; などの順次コンテナでの位置挿入と署名互換にするためにブール値を返しません。これにより、 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; などの汎用インサーターを作成できます。ヒントのある挿入が成功したかどうかを確認する1つの方法は、前後で&lt;a href=&quot;size&quot;&gt;size（）&lt;/a&gt;を比較することです。</target>
        </trans-unit>
        <trans-unit id="60466cfba360b12a497fdcbd2421cdfcee028890" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;override&lt;/code&gt;, if used, appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">識別子の &lt;code&gt;override&lt;/code&gt; が使用されている場合、メンバー関数宣言の構文またはクラス定義内のメンバー関数定義の&lt;a href=&quot;function&quot;&gt;宣言子の&lt;/a&gt;直後に表示されます。</target>
        </trans-unit>
        <trans-unit id="855cd3f29b0c4d0647de6b78163ac3dde4862c47" translate="yes" xml:space="preserve">
          <source>The identifier in any capture without an initializer (other than the &lt;code&gt;this&lt;/code&gt;-capture) is looked up using usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; in the</source>
          <target state="translated">イニシャライザなしのキャプチャの識別子（ &lt;code&gt;this&lt;/code&gt; -capture 以外）は、通常の&lt;a href=&quot;lookup&quot;&gt;非修飾名検索&lt;/a&gt;を使用して検索されます。</target>
        </trans-unit>
        <trans-unit id="e9e7a102d6df5884074f2499d6bb5f69817edee5" translate="yes" xml:space="preserve">
          <source>The identifier then becomes the name of an lvalue that refers to the object bound to said variable.</source>
          <target state="translated">識別子は、この変数にバインドされたオブジェクトを参照する lvalue の名前になります。</target>
        </trans-unit>
        <trans-unit id="822a7edda6406f5fc42188900a3b551e64031aa7" translate="yes" xml:space="preserve">
          <source>The immediate input function &lt;a href=&quot;../basic_istream/readsome&quot;&gt;&lt;code&gt;basic_istream::readsome&lt;/code&gt;&lt;/a&gt;, if &lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt;&lt;code&gt;basic_streambuf::in_avail&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">即時入力関数&lt;a href=&quot;../basic_istream/readsome&quot;&gt; &lt;code&gt;basic_istream::readsome&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt; &lt;code&gt;basic_streambuf::in_avail&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;-1&lt;/code&gt; を返す場合）</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="translated">実装は、少なくとも &lt;code&gt;32&lt;/code&gt; 個の関数の登録をサポートすることが保証されています。正確な制限は実装定義です。</target>
        </trans-unit>
        <trans-unit id="d765572265bbb1c2ba3ca90d43753fb5f543201a" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that the</source>
          <target state="translated">を確保するための実装が求められています。</target>
        </trans-unit>
        <trans-unit id="f14c981912c9ec5ad33b5a6c478bfe2e9cbdf180" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">実装では、 &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; で追加のマクロ定数を定義して、追加の浮動小数点例外を識別できます。このような定数はすべて &lt;code&gt;FE_&lt;/code&gt; で始まり、その後に少なくとも1つの大文字が続きます。</target>
        </trans-unit>
        <trans-unit id="22e5ff471a91c192911b7ddaa27337e54bd023f9" translate="yes" xml:space="preserve">
          <source>The implementation may extend the behavior of the first overload of &lt;code&gt;std::async&lt;/code&gt; by enabling additional (implementation-defined) bits in the default launch policy.</source>
          <target state="translated">実装は、デフォルトの起動ポリシーで追加の（実装定義）ビットを有効にすることにより、 &lt;code&gt;std::async&lt;/code&gt; 最初のオーバーロードの動作を拡張できます。</target>
        </trans-unit>
        <trans-unit id="66f2e43503845c9ed791a5293976886ce8971522" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;shared_ptr&lt;/code&gt; object.</source>
          <target state="translated">実装は、一時的な &lt;code&gt;shared_ptr&lt;/code&gt; オブジェクトを作成せずに要件を満たす場合があります。</target>
        </trans-unit>
        <trans-unit id="64697b003de59849a6866340318f593ae74fc065" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;weak_ptr&lt;/code&gt; object.</source>
          <target state="translated">実装は、一時的な &lt;code&gt;weak_ptr&lt;/code&gt; オブジェクトを作成せずに要件を満たす場合があります。</target>
        </trans-unit>
        <trans-unit id="7b237d3793f32597e507f67af416d68948b4ad9d" translate="yes" xml:space="preserve">
          <source>The implementation may support other date formats besides the ones required by the standard.</source>
          <target state="translated">実装は,標準で要求される日付フォーマット以外にも,他の日付フォーマットをサポートしてもよい。</target>
        </trans-unit>
        <trans-unit id="12a35a278ea92405afc482e169257edd666c8c44" translate="yes" xml:space="preserve">
          <source>The implementation shall provide sufficient additional &lt;code&gt;constexpr&lt;/code&gt; and &lt;code&gt;noexcept&lt;/code&gt; overloads of these functions so that a &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; object &lt;code&gt;sv&lt;/code&gt; may be compared to another object &lt;code&gt;t&lt;/code&gt; with an implicit conversion to &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt;, with semantics identical to comparing &lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">実装は、十分な追加提供しなければならない &lt;code&gt;constexpr&lt;/code&gt; のと &lt;code&gt;noexcept&lt;/code&gt; ように、これらの関数のオーバーロードを &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; オブジェクトの &lt;code&gt;sv&lt;/code&gt; 別のオブジェクトと比較することができる &lt;code&gt;t&lt;/code&gt; への暗黙的な変換と &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; 比較と同じセマンティクスで、 &lt;code&gt;sv&lt;/code&gt; と &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8fa4c86d6d639e7f910fb3c11363bc126fb0186" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装は場合を検出することが推奨されている &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 呼び出し前と投げる &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; のエラー状態で &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ef09408705d9954ea1018c6860f6e1b66768503" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;a href=&quot;../future_error&quot;&gt;&lt;code&gt;future_error&lt;/code&gt;&lt;/a&gt; with an error condition of &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_errc::no_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">実装では、呼び出しの前に &lt;code&gt;valid == false&lt;/code&gt; 場合を検出し、&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_errc::no_state&lt;/code&gt; &lt;/a&gt;エラー条件でfuture_errorをスローすることが&lt;a href=&quot;../future_error&quot;&gt; &lt;code&gt;future_error&lt;/code&gt; &lt;/a&gt;れています。</target>
        </trans-unit>
        <trans-unit id="46992c68e68dfb44f3f1d1f0f1a081b8b330576b" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装では、呼び出しの前に &lt;code&gt;valid == false&lt;/code&gt; あるケースを検出し、 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; のエラー条件で &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; をスローすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="30a185593e3d55839d1d436fbf8fa472dc5d96a9" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">&lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc ++&lt;/a&gt;と&lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc ++&lt;/a&gt;の実装は、 &lt;code&gt;token&lt;/code&gt; が読み取られたときに乱数を生成する文字デバイスの名前であると想定し、デフォルト値は &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; ですが、CPU命令RDRNDが利用可能な場合、libstdc ++はそれをデフォルトとして使用します。</target>
        </trans-unit>
        <trans-unit id="07ff6cacb8ff12c796c80e4fa51112a73181e2ed" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;https://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">実装&lt;a href=&quot;https://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;のlibc ++&lt;/a&gt;と&lt;a href=&quot;https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;のlibstdc ++&lt;/a&gt;期待 &lt;code&gt;token&lt;/code&gt; から読み込まれたときに、デフォルト値で、乱数を生成キャラクタデバイスの名前である &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; 、ただしCPU命令RDRNDが利用可能である、のlibstdc ++使用するデフォルトとして。</target>
        </trans-unit>
        <trans-unit id="1e1bd066a7f11748e7bb0264fc2e8c480f468bd7" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">暗黙的に宣言された（または最初の宣言でデフォルトが設定された）コピー割り当て演算子には、&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;（C ++ 17まで）&lt;a href=&quot;noexcept_spec&quot;&gt;例外仕様&lt;/a&gt;（C ++ 17以降）で説明されている例外仕様があります。</target>
        </trans-unit>
        <trans-unit id="94f03f3d0e083d8f05c0d3d27ca9e6043e7f1447" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">暗黙的に宣言された（または最初の宣言でデフォルトが設定された）コピーコンストラクターには、&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;（C ++ 17まで）&lt;a href=&quot;noexcept_spec&quot;&gt;例外仕様&lt;/a&gt;（C ++ 17以降）で説明されている例外仕様があります。</target>
        </trans-unit>
        <trans-unit id="c3a2dc4c3c835b9d7e3746bb1d579e66f0b3d256" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) default constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">暗黙的に宣言された（または最初の宣言でデフォルトが設定された）デフォルトコンストラクターには、&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;（C ++ 17まで）&lt;a href=&quot;noexcept_spec&quot;&gt;例外仕様&lt;/a&gt;（C ++ 17以降）で説明されている例外仕様があります。</target>
        </trans-unit>
        <trans-unit id="ad35568398ddbdf1c5594f6799a40acc879779b5" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">暗黙的に宣言された（または最初の宣言でデフォルトが設定された）移動割り当て演算子には、&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;（C ++ 17まで）&lt;a href=&quot;noexcept_spec&quot;&gt;例外仕様&lt;/a&gt;（C ++ 17以降）で説明されている例外仕様があります。</target>
        </trans-unit>
        <trans-unit id="3deae4df87e12fce8a01835c91a2ac9242a339b1" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">暗黙的に宣言された（または最初の宣言でデフォルトが設定された）移動コンストラクターには、&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;（C ++ 17まで）&lt;a href=&quot;noexcept_spec&quot;&gt;例外仕様&lt;/a&gt;（C ++ 17以降）で説明されている例外仕様があります。</target>
        </trans-unit>
        <trans-unit id="3213a8544ac4c22b0682928a2ce16724be0fb301" translate="yes" xml:space="preserve">
          <source>The implicitly-declared copy constructor for class &lt;code&gt;T&lt;/code&gt; is undefined if any of the following conditions are true:</source>
          <target state="translated">次の条件のいずれかに該当する場合、クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言されたコピーコンストラクターは未定義です。</target>
        </trans-unit>
        <trans-unit id="6fae264774979621faa26711431abb58dbca09db" translate="yes" xml:space="preserve">
          <source>The implicitly-declared destructor is virtual (because the base class has a virtual destructor) and the lookup for the deallocation function (&lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; results in a call to ambiguous, deleted, or inaccessible function.</source>
          <target state="translated">暗黙的に宣言されたデストラクタは仮想であり（基本クラスには仮想デストラクタがあるため）、割り当て解除関数の検索（ &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; の結果、あいまいな関数、削除された関数、またはアクセスできない関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="50ffc691488ff90f9bb81089da927863779b099a" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted copy constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言された、またはデフォルトのコピーコンストラクタは、次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="08afe67b1a14690a725702d4c692f1dc10c64e2f" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted default constructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as deleted(since C++11) if any of the following is true:</source>
          <target state="translated">次のいずれかに該当する場合、クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言またはデフォルト設定されているデフォルトコンストラクターは、（C ++ 11以降）削除済みとして定義され、未定義です。</target>
        </trans-unit>
        <trans-unit id="65cafdb084858cf182d0ce28289e802bf9e83822" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted destructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言された、またはデフォルトのデストラクタは、次のように定義されていません（C ++ 11まで）</target>
        </trans-unit>
        <trans-unit id="e8b5ed6dfa8b272f8c00f443dfeac236e2515204" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move assignment operator for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言された、またはデフォルトの移動代入演算子は、次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="4ce2934ef2171aeb2c0ad6a343b987738915dab2" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の暗黙的に宣言された、またはデフォルトの移動コンストラクタは、次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="ad92a1e56a9451101a860f2143c244760ecd26c4" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions are typically incorrect if the class is managing a resource whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a &quot;shallow copy&quot; (copy the value of the handle, without duplicating the underlying resource).</source>
          <target state="translated">暗黙的に定義された特別なメンバ関数は、クラスがリソースを管理していて、そのハンドルが非クラス型のオブジェクト (生ポインタ、POSIX ファイル記述子など)で、そのデストラクタが何もせず、コピーコンストラクタ/割り当て演算子が &quot;浅いコピー&quot; (基礎となるリソースを複製せずにハンドルの値をコピーすること)を実行する場合には、典型的には正しくありません。</target>
        </trans-unit>
        <trans-unit id="192f6f2391fc950f581ebc15e6c0166986a4e41a" translate="yes" xml:space="preserve">
          <source>The implicitly-generated member functions and any member function declared as defaulted on its first declaration are inline just like any other function defined inside a class definition.</source>
          <target state="translated">暗黙的に生成されたメンバ関数と、その最初の宣言でデフォルトとして宣言された任意のメンバ関数は、クラス定義内で定義された他の関数と同じようにインラインになります。</target>
        </trans-unit>
        <trans-unit id="d43d2eaebfe91ea20d3c9ee4934fb21de74d02b4" translate="yes" xml:space="preserve">
          <source>The implied &lt;code&gt;lk.unlock&lt;/code&gt; is</source>
          <target state="translated">暗黙の &lt;code&gt;lk.unlock&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="34929ac211f53c3511c4b293c3b116cd7ed0a254" translate="yes" xml:space="preserve">
          <source>The index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に格納されているインデックス。</target>
        </trans-unit>
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">インデックス &lt;code&gt;I&lt;/code&gt; が0でも1でもない場合、インデックスベースのオーバーロード（1〜4）はコンパイルに失敗します。</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">示された演算子はタイプ &lt;code&gt;T&lt;/code&gt; に適用できます</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">インダイレクト演算子とメンバ演算子は、多くのイテレータやスマートポインタクラスによってオーバーロードされています。</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">インダイレクト演算子の式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">この機能によって提供される情報は、通常、ディレクトリ反復の副生成物として提供され、そしてのメンバー関数によって得ることができる &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; 。ディレクトリの反復中に、 &lt;code&gt;status&lt;/code&gt; 再度呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">この関数によって提供される情報は、通常、ディレクトリ反復の副産物としても提供されます。ディレクトリの反復中に、 &lt;code&gt;exists(*iterator)&lt;/code&gt; を呼び出すことは、 &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; より効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">継承されたコンストラクターは、本文が空で、&lt;a href=&quot;constructor&quot;&gt;メンバーの初期化子リスト&lt;/a&gt;が1つの入れ子になった名前指定子で構成され、そのすべての引数を基本クラスコンストラクターに転送するユーザー定義コンストラクターと同等です。</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">初期値は、&lt;a href=&quot;declarations&quot;&gt;宣言子&lt;/a&gt;または&lt;a href=&quot;new&quot;&gt;新しい式&lt;/a&gt;の初期化セクションで指定できます。また、関数の呼び出し中にも発生します。関数のパラメーターと関数の戻り値も初期化されます。</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">クラスまたは識別子が&lt;a href=&quot;derived_class&quot;&gt;仮想基本クラスを&lt;/a&gt;指定する初期化子は、構築されるオブジェクトの最も派生したクラスではないクラスのコンストラクターの実行中は無視されます。</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">注入されたクラス名は、当該クラスの範囲内のクラス名です。</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">クラス・テンプレートまたはクラス・テンプレート専門化の注入されたクラス名は、スコープ内であればどこでもテンプレート名または型名として使用することができます。</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">インライン指定子は、ブロックスコープ(別の関数内)での関数や変数(C++17 以降)の宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">インライン指定子は、変換単位で既に定義されている関数や変数(C++17 以降)を非インラインとして再定義することはできません。</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">入力は、ステージ1で選択された変換指定子を使用して &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; ように解析されます</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">入力はによってかのように解析される &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 符号付き整数のため &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 符号なし整数のための &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 用 &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">入力はによってかのように解析され &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 符号付き整数のため &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 符号なし整数のための &lt;code&gt;v&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 浮動小数点のために &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">式への入力は、そのオペランドから構成されます。</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; の挿入操作は、&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;として動作します。</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">のインスタンス化は</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コールバックとともに格納される整数値は、通常、 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; から取得したインデックスです。</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">エンジンによって生成される積分型。これが符号なし積分型でない場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">概念の目的は、構文上の制限（HasPlus、Array）ではなく、意味論的なカテゴリ（Number、Range、RegularFunction）をモデル化することです。&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C ++コアガイドラインT.20&lt;/a&gt;によると、「意味のあるセマンティクスを指定する機能は、構文上の制約とは対照的に、真の概念の定義的な特性です。」</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">この関数の目的は&lt;a href=&quot;../../language/range-for&quot;&gt;、ループの範囲&lt;/a&gt;がvalarrayで機能できるようにすることであり、コンテナーのセマンティクスを提供することではありません。</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">この要件の目的は、C ++ライブラリの複素数型と&lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C言語の複素数型&lt;/a&gt;（およびその配列）の間のバイナリ互換性を維持することです。これらには、同じオブジェクト表現要件があります。</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">C++標準ライブラリのインタフェースは、以下のヘッダの集合で定義されています。</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">汎用パス名形式の内部パス名を指定された文字列型に変換したものです。</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">ネイティブパス名形式の内部パス名を、指定された文字列型に変換したものです。</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">参照されるビットの逆数。</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; の呼び出しは、次のいずれかのコンテキストでのみ表示される必要があります。</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">このコンテナの反復順序は、安定している必要はありません（たとえば、 &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; を使用して2つの &lt;code&gt;std::unordered_multimap&lt;/code&gt; を比較することはできません）。ただし、キーが比較する要素のすべてのグループは</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">このコンテナの反復順序は、安定している必要はありません（たとえば、 &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; を使用して2つの &lt;code&gt;std::unordered_multiset&lt;/code&gt; を比較することはできません）。ただし、キーが比較する要素のすべてのグループは</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">&lt;code&gt;first==last&lt;/code&gt; 場合、イテレータは &lt;code&gt;first&lt;/code&gt; に逆参照可能である必要はありません。空の範囲の消去は何もしません。</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">イテレータ &lt;code&gt;pos&lt;/code&gt; は有効で逆参照可能でなければなりません。したがって、 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; イテレータ（有効ですが、逆参照はできません）を &lt;code&gt;pos&lt;/code&gt; の値として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">イテレータ &lt;code&gt;pos&lt;/code&gt; は有効で逆参照可能でなければなりません。したがって、 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; イテレータ（有効ですが、逆参照不可）を &lt;code&gt;pos&lt;/code&gt; の値として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">イテレータは &lt;code&gt;first + (last - n_first)&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">イテレータ・ライブラリには、5 種類 (C++17 まで)のイテレータ、6 種類 (C++17 以降)のイテレータ、およびイテレータの特性、アダプタ、ユーティリティ関数の定義が用意されています。</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">メンバ関数の場合、この関数から得られたイテレータは無効化され &lt;code&gt;resize()&lt;/code&gt; アレイ上に呼び出され &lt;code&gt;v&lt;/code&gt; 又は場合の寿命 &lt;code&gt;v&lt;/code&gt; いずれか早い方、終了します。</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">メンバ関数の場合、この関数テンプレートから得られたイテレータは無効化され&lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt;アレイ上に呼び出され &lt;code&gt;v&lt;/code&gt; 又は場合の寿命 &lt;code&gt;v&lt;/code&gt; いずれか早い方、終了します。</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">すべての要素が &lt;code&gt;p&lt;/code&gt; を満たす場合 &lt;code&gt;[first, last)&lt;/code&gt; または &lt;code&gt;last&lt;/code&gt; 内の最初のパーティションの終わりを超える反復子。</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">キー比較関数オブジェクト。</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">キー比較機能です。</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">キーワード&lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;dependent_name&quot;&gt;従属テンプレート名&lt;/a&gt;を明確にするために、必要に応じて修飾識別子に含めることができます。</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;nullptr&lt;/code&gt; は、ポインタリテラルを示します。それはある&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;型の &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;nullptr&lt;/code&gt; から任意のポインター型のnullポインター値への&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的な変換&lt;/a&gt;、およびメンバー型への任意のポインターが存在します。同様の変換が、タイプ &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 値とマクロ &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; を含む任意のnullポインター定数に対して存在します。</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">キーワード &lt;code&gt;requires&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">キーワード &lt;code&gt;requires&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">キーワード &lt;code&gt;template&lt;/code&gt; は、演算子 &lt;code&gt;::&lt;/code&gt; (スコープ解決）、 &lt;code&gt;-&amp;gt;&lt;/code&gt; （ポインターによるメンバーアクセス）、およびの後にのみ、この方法で使用できます &lt;code&gt;.&lt;/code&gt; （メンバーアクセス）、以下はすべて有効な例です。</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">キーワード &lt;code&gt;this&lt;/code&gt; は、値がオブジェクトのアドレスであり、メンバー関数が呼び出される&lt;a href=&quot;value_category&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;式&lt;/a&gt;です。次のコンテキストで表示されます。</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、テンプレートの外でも使用できます。</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、修飾された名前（例： &lt;code&gt;T::x&lt;/code&gt; ）の前にのみこの方法で使用できますが、名前が依存している必要はありません。</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、テンプレートの宣言と定義、および従属名を使用できるコンテキストでのみ使用する必要があります。これには、明示的な特殊化宣言と明示的なインスタンス化宣言は含まれません。</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">このキーワードは未使用で予約されています。</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">キーワードのようなフォーム（ &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;not&lt;/code&gt; ）と記号のようなフォーム（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;||&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; ）互換的に使用することができます（参照&lt;a href=&quot;operator_alternative&quot;&gt;代替表現を&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">ラムダ式は、一意の無名非組合わない非集約クラス型のprvalue式であり、これは</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">プーリングメカニズムを使用して満たす必要がある最大の割り当てサイズ。このしきい値より大きい単一のブロックを &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; うとすると、上流のstd :: pmr :: memory_resourceから直接割り当てられます。場合 &lt;code&gt;largest_required_pool_block&lt;/code&gt; はゼロであるか、または限界が代わりに使用されていることを、実装定義の限界よりも大きいです。実装は、このフィールドで指定されたよりも大きいパススルーしきい値を選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">最大のブロックサイズと最大のチャンクサイズは、 &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 構造体をコンストラクタに渡すことで調整できます。</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_string_view&lt;/code&gt; で参照できるcharのようなオブジェクトの最大数。</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::nearbyint&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::rint&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::round&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準の浮動小数点形式の正確な整数であるため、この関数自体がオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">の最後の文字</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">参照先ファイルシステムオブジェクトの最終更新時刻。</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">ラテン&lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;文字「ſ」（U + 017F）&lt;/a&gt;は、「S」（U + 0053）の代替小文字形式です。</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">変換指定 &lt;code&gt;#o&lt;/code&gt; （たとえば、 &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; の組み合わせから生じる）によって生成される先行ゼロは、埋め込み文字としてカウントされません。</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が指す文字シーケンスの長さ。</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すバイト文字列の文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すワイド文字列の文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すバイト文字列にない文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指す文字列に見つからない文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">ヌル文字で終わる文字列の長さ。</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">nullで終了する文字列 &lt;code&gt;str&lt;/code&gt; の長さ。</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">nullで終了するワイド文字列 &lt;code&gt;str&lt;/code&gt; の長さ。</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">指定されたマッチまたはサブマッチの長さ。</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">変換された文字列の長さで、終端のヌル文字は含まれません。</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">変換された幅広文字列の長さで、終端のヌル文字は含まれません。</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; 以外のオープンモードのサポートレベルは、実装によって異なります。C ++ 11は、 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; のサポートを &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; およびこのコンストラクターで明示的に指定していますが、 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; 実装ごとに異なる効果があります。</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">ライブラリは、すべての符号付きおよび符号なし整数型のオーバーロードを提供し、パラメータ &lt;code&gt;value&lt;/code&gt; 参照型として &lt;code&gt;char&lt;/code&gt; を提供します。2-4）浮動小数点パーサー：デフォルト（ &quot;C&quot;）ロケールで &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; によって使用されるものと同じパターンを期待しますが、</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;のライブラリバージョン</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;のライブラリバージョン&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt;および&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;のライブラリバージョン</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;参照&lt;/a&gt;の存続期間は、その初期化が完了したときに始まり、スカラーオブジェクトのように終了します。</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">配列の要素を初期化するために使用されるデフォルトのコンストラクタのデフォルト引数を評価したときに作成される一時オブジェクトの寿命は、配列の次の要素が初期化を開始する前に終了します。</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">一時オブジェクトの存続期間は、const左辺値参照または右辺値参照にバインドすることで延長できます（C ++ 11以降）。詳細については、&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;参照の初期化&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">オブジェクトの存続期間は、オブジェクトを参照するすべての &lt;code&gt;atomic_ref&lt;/code&gt; の存続期間を超えている必要があります。任意ながら &lt;code&gt;atomic_ref&lt;/code&gt; のオブジェクトを参照するインスタンスが存在し、オブジェクトは、排他的にこれらを介してアクセスされなければならない &lt;code&gt;atomic_ref&lt;/code&gt; のインスタンス。 &lt;code&gt;atomic_ref&lt;/code&gt; オブジェクトによって参照されるオブジェクトのサブオブジェクトは、他の &lt;code&gt;atomic_ref&lt;/code&gt; オブジェクトによって同時に参照できません。</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">返されたポインタが指す配列の寿命は指定されていませんが、実際には、与えられた型のRTTIデータ構造体が存在する限り持続し、動的ライブラリ(アンロード可能)からロードされない限り、アプリケーションの寿命を持ちます。</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">コアーチン状態の寿命は、呼び出し元の寿命の中に厳密に入れ子にされており</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">基本クラスのリストは、&lt;a href=&quot;class&quot;&gt;クラス宣言構文の&lt;/a&gt; base-clauseで提供されています。base-clauseは、文字 &lt;code&gt;:&lt;/code&gt; とそれに続く1つ以上のbase-specifiersのコンマ区切りリストで構成されます。</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;内の例外のリストは、パック拡張の場合もあります。</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;名前付き関数&lt;/a&gt;と同様のパラメーターのリスト。ただし、&lt;a href=&quot;default_arguments&quot;&gt;デフォルトの引数&lt;/a&gt;は許可されていません（C ++ 14まで）。 &lt;code&gt;auto&lt;/code&gt; がパラメーターのタイプとして使用される場合、ラムダは</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">この関数を呼び出す前のロケール。式 &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; の結果を効果的に返します。</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">ロケール機能には、文字分類や文字列の照合、数値、金額、日時の書式設定や解析、メッセージの検索などの国際化のサポートが含まれています。ロケール設定は、ストリーム I/O、正規表現ライブラリ、および C++標準ライブラリのその他のコンポーネントの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">操作前のストリームに関連付けられたロケールオブジェクト。</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">正規表現でローカライズされた動作に使用されるロケール。&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructibleである&lt;/a&gt;必要があります</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">論理演算子の式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x)&lt;/code&gt; を呼び出した結果の論理的な補数。</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x, y)&lt;/code&gt; を呼び出した結果の論理的な補数。</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">lognormal_distribution乱数分布は、対数正規分布に従って乱数x&amp;gt; 0を生成し&lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;ます&lt;/a&gt;：f（x; m、s）=</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">メンバー &lt;code&gt;get&lt;/code&gt; のルックアップでは、通常どおりアクセシビリティが無視され、タイプ以外のテンプレートパラメーターの正確なタイプも無視されます。プライベート &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; メンバーの形式が正しくなくても、メンバーの解釈が使用されます。</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例外仕様での識別子 &lt;code&gt;swap&lt;/code&gt; のルックアップは、通常のルックアップルールで検出されたものに加えて、この関数テンプレートを検出し、例外仕様をC ++ 17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">マクロ &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; は、標準レイアウトクラスの先頭からの任意のメンバーのオフセットを決定するために使用できます。</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">マクロ &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; は、標準レイアウトクラスでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">マクロ &lt;code&gt;NAN&lt;/code&gt; は、静的な非数値（QNaN）値に評価される &lt;code&gt;float&lt;/code&gt; 型の定数式に展開されます。実装がQNaNをサポートしていない場合、このマクロ定数は定義されていません。</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">マクロ &lt;code&gt;NULL&lt;/code&gt; は、実装定義のnullポインター定数である可能性があります。</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">マクロ &lt;code&gt;offsetof&lt;/code&gt; は、型 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 整数定数式に展開されます。その値は、指定された型のオブジェクトの先頭から指定されたメンバーまでのオフセット（バイト単位）です。</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">マクロ定数 &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; は、他のすべての &lt;code&gt;FE_*&lt;/code&gt; のビット単位のORに展開され、常に定義されており、実装で浮動小数点例外がサポートされていない場合はゼロです。</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">マクロ定数 &lt;code&gt;FE_DFL_ENV&lt;/code&gt; は、型 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 式に展開されます。これは、デフォルトの浮動小数点環境の完全なコピー、つまりプログラムの起動時に読み込まれる環境を指します。</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">マクロ定数 &lt;code&gt;math_errhandling&lt;/code&gt; は、 &lt;code&gt;MATH_ERRNO&lt;/code&gt; と等しい &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; 、MATH_ERREXCEPTと等しいか、ビット単位のOR（ &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ）と等しい &lt;code&gt;int&lt;/code&gt; 型の式に展開されます。</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">引数で呼び出されるマニピュレーター（例： &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; ）は、指定されていない型のオブジェクトを返す関数として実装されます。これらのマニピュレータは、要求された操作を実行する独自の &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; または &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">引数なしで呼び出されるマニピュレーター（例： &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; ）は、ストリームへの参照を唯一の引数として取る関数として実装されます。&lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;の特別なオーバーロードは、これらの関数へのポインターを受け入れます。これらの関数（または関数テンプレートのインスタンス化）は、標準ライブラリで&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;アドレス可能な関数&lt;/a&gt;のみです（C ++ 20以降）。</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">その方法 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; （それが全てで最適化されているかどうかだけでなく、）スペース効率化され、実装定義です。1つの潜在的な最適化には、各要素が &lt;code&gt;sizeof(bool)&lt;/code&gt; バイトではなく1ビットを占有するようにベクトル要素を結合することが含まれます。</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">OSコマンドラインで指定された引数が &lt;code&gt;argv&lt;/code&gt; によって参照されるマルチバイト文字配列に変換される方法には、実装定義の処理が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">現在のCロケールのLC_CTYPEファセットの &lt;code&gt;desc&lt;/code&gt; によって識別されたマッピングを使用して、 &lt;code&gt;ch&lt;/code&gt; のマッピングされた値。</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">不要な一時オブジェクトの作成を回避するために、一時オブジェクトの具体化は、通常、可能な限り遅延されます。「&lt;a href=&quot;copy_elision&quot;&gt;コピーの省略&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">円弧サインの主値の数学的定義は、asin z=-です。</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">逆双曲線余弦の主値の数学的定義は、acosh z = ln（z +&amp;radic;z+1&amp;radic;z-1）です。任意のzに対して、acosh（z）=</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">逆双曲線正弦の主値の数学的定義は、asinh z = ln（z +&amp;radic;1+ z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準ライブラリコンポーネントの数学関数は、この例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されている範囲エラーを報告します）。</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントの数学関数は、この例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたオーバーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::overflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="43eb628800204d96d7e81842c715db4a7e602e27" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントの数学関数はこの例外をスローしません（数学関数は &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているようにオーバーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::overflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">OuterAllocの最大アロケーションサイズ。</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">1つの &lt;code&gt;InternT&lt;/code&gt; 文字を生成するために &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; によって変換された場合に消費される可能性がある &lt;code&gt;ExternT&lt;/code&gt; 文字の最大数。</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">プールを補充するために上流の &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; から一度に割り当てられるブロックの最大数。 &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; の値がゼロであるか、実装で定義された制限より大きい場合は、代わりにその制限が使用されます。実装は、このフィールドで指定された値よりも小さい値を使用することを選択する場合があり、プールごとに異なる値を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock_for&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock_until&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、タイプ &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; の例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; がロックされる最大回数は指定されていませんが、その数に達すると、&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;を呼び出すと &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; がスローされ、&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">要素の最大値。</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">生成される可能性のある最大値。</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">サポートされている最大の割り当てサイズ。</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">分布によって生成される可能性のある最大値。</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">この関数の結果の意味とタイプは実装定義です。POSIXシステムでは、これはタイプ &lt;code&gt;pthread_cond_t*&lt;/code&gt; 値である場合があります。Windowsシステムでは、これは &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; の場合があります。</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">フォーマット指定子の意味は</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">ビルドレベルを選択する仕組みは実装で定義されています。異なるビルドレベルで翻訳された翻訳ユニットの結合は条件付きでサポートされています。</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">メンバー &lt;code&gt;operator()&lt;/code&gt; は効果的に &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; と同じ値を返します。</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">メンバのアクセス演算子の式には、次のような形式があります。</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">メンバーへのポインタを介したメンバーアクセス演算子式は、形式を持っています。</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">メンバー &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; へのポインターを介したメンバーアクセス。この演算子をオーバーロードすることによる特定の欠点はありませんが、実際にはめったに使用されません。それは&lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;スマートポインターインターフェイスの&lt;/a&gt;一部である可能性が示唆され、実際には&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenixの&lt;/a&gt;アクターによってその能力で使用されます。これはcpp.reactなどのEDSLでより一般的&lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89feaad6ef39273143072a5bab0c6502c099dc36" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">メンバー &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; へのポインタを介したメンバーアクセス-&amp;gt; *。この演算子をオーバーロードすることによる特定の欠点はありませんが、実際にはめったに使用されません。&lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;スマートポインタインターフェイスの&lt;/a&gt;一部である可能性が示唆されており、実際には、&lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenixの&lt;/a&gt;アクターによってその機能で使用されています。これは、cpp.reactなどのEDSLでより一般的&lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">書込み用にオープンされたバッファ内のメンバ文字列は、効率化のために過剰に割り当てられることがある。その場合は、バッファ内の</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_regex&lt;/code&gt; のメンバー定数は、名前空間 &lt;code&gt;std::regex_constants&lt;/code&gt; 定義されている&lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt;定数の複製です。</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">メンバー関数 &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">このサーチャーで &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; を実行するためにstd :: searchのサーチャーオーバーロードによって呼び出されるメンバー関数。</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">このサーチャーで &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; を実行するためにstd :: searchのサーチャーオーバーロードによって呼び出されるメンバー関数。 &lt;code&gt;RandomIt2&lt;/code&gt; は&lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;の要件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">の型を定義するために、使用宣言によって派生クラスに導入されたメンバ関数は、派生クラスのメンバとみなされます。</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">メンバーの機能 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;std::initializer_list&lt;/code&gt; のオーバーロード &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">この特殊化のメンバ関数は、基礎となる型のハッシュがスローされる可能性があるため、その場合を除いてnoexexであることは保証されません。</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">この特殊化のメンバ関数は、ポインタが空想ポインタである可能性があり、そのハッシュがスローされる可能性があるため、noexceptが保証されていません。</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">この特殊化のメンバ関数は、noexceptであることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">メンバー関数は、 &lt;code&gt;matched&lt;/code&gt; メンバーが &lt;code&gt;true&lt;/code&gt; でない限り、定義されたデフォルト値を返します。</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">メンバーの解釈は、範囲タイプに &lt;code&gt;begin&lt;/code&gt; という名前のメンバーと &lt;code&gt;end&lt;/code&gt; という名前のメンバーがある場合に使用されます。これは、メンバーがタイプ、データメンバー、関数、または列挙子であるかどうか、およびそのアクセシビリティに関係なく行われます。したがって、クラス &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; ようなクラス。/ *クラスの残りの部分* /}; 名前空間スコープの開始/終了関数が存在する場合でも、範囲ベースのforループでは使用できません。</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">のメンバー名が表示されます。</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">基底クラスのメンバー名は、 &lt;code&gt;conjunction&lt;/code&gt; および &lt;code&gt;operator=&lt;/code&gt; 以外は非表示にされておらず、確実に &lt;code&gt;conjunction&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disjunction&lt;/code&gt; と &lt;code&gt;operator=&lt;/code&gt; 以外の基本クラスのメンバー名は非表示にならず、 &lt;code&gt;disjunction&lt;/code&gt; で明確に使用できます。</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">メンバーoperator（）は、それが &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 式がnoexceptである場合はnoexceptです（つまり、基になる呼び出し演算子の例外指定を保持します）。</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">メンバーの仕様、または</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">メンバーテンプレートクラスの再 &lt;code&gt;rebind&lt;/code&gt; は、異なるタイプのアロケーターを取得する方法を提供します。例えば、</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">メンバータイプ &lt;code&gt;X::pointer&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">メンバータイプ &lt;code&gt;is_transparent&lt;/code&gt; は、この関数オブジェクトが</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">メンバータイプ &lt;code&gt;X::iterator&lt;/code&gt; および &lt;code&gt;X::const_iterator&lt;/code&gt; は&lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIteratorsです&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">メンバー型 &lt;code&gt;X::pointer&lt;/code&gt; 、 &lt;code&gt;X::const_pointer&lt;/code&gt; 、 &lt;code&gt;X::void_pointer&lt;/code&gt; と &lt;code&gt;X::const_void_pointer&lt;/code&gt; 、すべての&lt;a href=&quot;allocator&quot;&gt;アロケータの&lt;/a&gt;タイプ &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">メンバー型 &lt;code&gt;iterator&lt;/code&gt; および &lt;code&gt;const_iterator&lt;/code&gt; は、同じ型のエイリアスである場合があります。以来 &lt;code&gt;iterator&lt;/code&gt; に変換され &lt;code&gt;const_iterator&lt;/code&gt; の、 &lt;code&gt;const_iterator&lt;/code&gt; のは、一つの定義ルールの違反を避けるために、関数の引数リストで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">メンバーには以下のような意味があります。</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">C++プログラムで利用可能なメモリは、1つまたは複数の連続した</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">読み取り、変更、書き込み、および読み込み操作のメモリモデルは、それぞれ &lt;code&gt;succ&lt;/code&gt; と &lt;code&gt;fail&lt;/code&gt; です。（1-2）バージョンは、デフォルトで &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">読み取り、変更、書き込み、および読み込み操作のメモリモデルは、それぞれ &lt;code&gt;success&lt;/code&gt; と &lt;code&gt;failure&lt;/code&gt; です。（2）及び（4）バージョンの &lt;code&gt;order&lt;/code&gt; 除いて、両方のリード・モディファイ・ライトと負荷操作のために使用されること &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 場合、ロード操作のために使用される &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">このポリモーフィックアロケータが使用するメモリリソースポインタ。</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">メモリ書き込み変換指定子 &lt;code&gt;%n&lt;/code&gt; は、フォーマット文字列がユーザー入力に依存するセキュリティエクスプロイトの一般的なターゲットであり、境界チェック &lt;code&gt;printf_s&lt;/code&gt; ファミリーの関数ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">カタログからのメッセージ、または何も見つからなかった場合は &lt;code&gt;dfault&lt;/code&gt; のコピー。</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">要素の最小値。</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">生成される可能性のある最小値。</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">分布によって生成される可能性のある最小値。</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EC&lt;/code&gt; は、ロケールの世紀の代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EX&lt;/code&gt; は、ロケールの代替時間表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EX&lt;/code&gt; は、ロケールの代替時間表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EY&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ec&lt;/code&gt; は、ロケールの代替の日付と時刻の表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ec&lt;/code&gt; は、ロケールの代替の日付と時刻の表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ex&lt;/code&gt; は、ロケールの代替日付表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ex&lt;/code&gt; は、ロケールの代替日付表現を生成します。</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OH&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OH&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OI&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OM&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OM&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OS&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OS&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OU&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OV&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OW&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Od&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Oe&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Om&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Om&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ou&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ou&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ow&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ow&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EC&lt;/code&gt; および &lt;code&gt;%OC&lt;/code&gt; は、ロケールの世紀の代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ed&lt;/code&gt; および &lt;code&gt;%Ee&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ey&lt;/code&gt; および &lt;code&gt;%Oy&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ez&lt;/code&gt; および &lt;code&gt;%Oz&lt;/code&gt; は、時間と分の間に &lt;code&gt;:&lt;/code&gt; を挿入します（例 &lt;code&gt;-04:30&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ez&lt;/code&gt; および &lt;code&gt;%Oz&lt;/code&gt; は、形式 &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; 解析します（つまり、時間と分の間で &lt;code&gt;:&lt;/code&gt; を必要とし、時間の先行ゼロをオプションにします）。</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">通貨形式は、 &lt;code&gt;std::money_base::part&lt;/code&gt; 変換可能な4つの &lt;code&gt;char&lt;/code&gt; の配列です。そのシーケンスでは、 &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;sign&lt;/code&gt; 、および &lt;code&gt;value&lt;/code&gt; のそれぞれが1回だけ出現し、残りの位置には &lt;code&gt;space&lt;/code&gt; または &lt;code&gt;none&lt;/code&gt; 出現しません。存在する場合、値 &lt;code&gt;none&lt;/code&gt; は最初ではありません。存在する場合、値 &lt;code&gt;space&lt;/code&gt; は最初でも最後でもありません。</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に保存される月の値。</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">ほとんどの派生型 &lt;code&gt;other&lt;/code&gt; ほとんどの派生型と一致しないことがあり &lt;code&gt;*this&lt;/code&gt; 。したがって、派生クラスの実装では、通常、 &lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; 派生型が &lt;code&gt;dynamic_cast&lt;/code&gt; を使用して一致するかどうかを確認し、キャストが失敗した場合はただちに &lt;code&gt;false&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">&lt;code&gt;std::result_of&lt;/code&gt; 背後にある動機は、特にその結果の型が引数のセットごとに異なる場合に、&lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;を呼び出した結果を判別することです。</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の移動割り当て演算子は、次のすべてが当てはまる場合は簡単です。</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">割り当ての移動演算子は、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;によって選択されるたびに呼び出されます。たとえば、オブジェクトが割り当て式の左側に表示され、右側が同じまたは暗黙的に変換可能な型の右辺値である場合などです。</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; のmoveコンストラクターは、次のすべてが当てはまる場合は簡単です。</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">オブジェクトがされたときに、典型的に呼ばれるムーブコンストラクタ&lt;a href=&quot;initialization&quot;&gt;初期化&lt;/a&gt;（によって&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;または&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期化&lt;/a&gt;から）&lt;a href=&quot;value_category#rvalue&quot;&gt;右辺値&lt;/a&gt;を含む同じタイプの（C ++ 17以降）はxValue（C ++ 17まで）（はxValue又はprvalue）。</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">この関数が使用するマルチバイトエンコーディングは、現在アクティブな C ロケールによって指定されます。</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">マルチバイトのヌル文字を変換して保存しました。</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">マルチバイトのnull文字が変換されて保存されました。 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に設定され、 &lt;code&gt;*ps&lt;/code&gt; は初期シフト状態を表します。</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">このミューテックスは、共有モードで実行中の現在のスレッドによってロックされている必要があり、そうでなければ動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">ミューテックスは、現在の実行スレッドでロックされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">nの分布パラメータです。</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">名前 &lt;code&gt;array::elems&lt;/code&gt; は説明のためだけのものであり、インターフェースの一部ではありません。</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">名前 &lt;code&gt;posix&lt;/code&gt; は、将来のトップレベルの名前空間のために予約されています。プログラムがその名前空間で何かを宣言または定義した場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">名前 &lt;code&gt;proxy&lt;/code&gt; は、説明のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">名前の &lt;code&gt;ranges::swap&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">非静的データ・メンバまたは非静的メンバ関数の名前は、以下の3つの状況でのみ出現します。</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;スコープ&lt;/a&gt;列挙で導入された列挙子の名前は、宣言の時点で始まり、列挙指定子の終わりで終わります（対照的に、スコープ指定されていない列挙子は、列挙指定子の終わりの後にスコープ内にあります）。</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">スコープされていない列挙の名前は省略することができます。</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">すべての&lt;a href=&quot;class&quot;&gt;クラス&lt;/a&gt;メンバーの名前（静的、非静的、関数、型など）には、関連付けられた「メンバーアクセス」があります。メンバーの名前がプログラムのどこかで使用されると、そのアクセスがチェックされ、アクセスルールを満たさない場合、プログラムはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">関連する &lt;code&gt;type_info&lt;/code&gt; オブジェクトの名前。</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">ロケールの名前、または名前がない場合は &quot;*&quot;。</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">ネストされたクラスの名前は、包含クラスのスコープ内に存在し、ネストされたクラスのメンバー関数からの名前ルックアップは、ネストされたクラスのスコープを調べた後、包含クラスのスコープを訪問します。入れ子のクラスのメンバーと同様に、入れ子になったクラスは、入れ子のクラスがアクセスできるすべての名前（プライベート、保護など）にアクセスできますが、それ以外の場合は独立しており、入れ子のクラスの&lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;ポインターへの特別なアクセス権はありません。</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">パラメータ名は任意です。</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">必要な言語連携の名前</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">この関数の名前は、2つの形式のうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">この関数の名前は &quot;stream:how many characters? &quot;の略なので、&quot;show many C &quot;ではなく &quot;S how many C &quot;と発音します。</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">このタイムゾーンの名前（例： &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">名前は「文字列ポインタブレーク」の略で、区切り文字(「ブレーク」)の最初の文字へのポインタを返すことから、「文字列ポインタブレーク」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">名前 &lt;code&gt;argc&lt;/code&gt; と &lt;code&gt;argv&lt;/code&gt; は任意であり、パラメーターのタイプの表現も同様です &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; も同様に有効です。</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">デフォルトの引数で使用される名前は検索され、&lt;a href=&quot;access&quot;&gt;アクセシビリティが&lt;/a&gt;チェックされ、宣言の時点でバインドされますが、関数呼び出しの時点で実行されます。</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">名前空間&lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt;は、汎用演算子 &lt;code&gt;!=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; を提供します</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">名前空間 &lt;code&gt;std&lt;/code&gt; は、標準C ++ライブラリの名前を配置するために使用されます。&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;名前空間への名前の&lt;/a&gt;追加に関する規則については、名前空間stdの拡張を参照してください。</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">名前空間エイリアス &lt;code&gt;std::view&lt;/code&gt; は、 &lt;code&gt;std::ranges::view&lt;/code&gt; 省略形として提供されています。</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">名前空間本体は&lt;a href=&quot;scope&quot;&gt;名前空間スコープを&lt;/a&gt;定義し、名前の&lt;a href=&quot;lookup&quot;&gt;検索に&lt;/a&gt;影響します。</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">この条件変数のネイティブハンドル。</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">パス名のネイティブ文字列表現で、ネイティブ構文、ネイティブ文字型、ネイティブ文字エンコーディングを使用します。この文字列は、OS API での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">極座標成分（r、&amp;theta;）を持つ複素数zの自然対数は、ln r + i（&amp;theta;+2n&amp;pi;）に等しく、主値はln r +i&amp;theta;です。</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;../fenv/fe_round&quot;&gt;現在の丸めモード&lt;/a&gt;に従って、 &lt;code&gt;arg&lt;/code&gt; に最も近い整数値が返されます。</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">新しいエイリアス alias_name は、ns_name にアクセスする代替方法を提供します。</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">新しい式は、まずクラススコープで適切な割り当て関数の名前を検索し、次にグローバルスコープで検索します。&lt;a href=&quot;../../language/lookup&quot;&gt;名前ルックアップルールに従って&lt;/a&gt;、クラススコープで宣言された割り当て関数は、このクラスのオブジェクトを割り当てようとする新しい式のすべてのグローバル割り当て関数を非表示にすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">新しい文字列は、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; の新しい値は指定されていません。</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">新しい名もなきロケ地。</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">new-expressionは、適切な&lt;a href=&quot;../memory/new/operator_new&quot;&gt;割り当て関数を&lt;/a&gt;呼び出してストレージを割り当てます。場合は &lt;code&gt;type&lt;/code&gt; 非配列型で、関数の名前は &lt;code&gt;operator new&lt;/code&gt; 。 &lt;code&gt;type&lt;/code&gt; が配列型の場合、関数の名前は &lt;code&gt;operator new[]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">改行文字 &lt;code&gt;\n&lt;/code&gt; は、&lt;a href=&quot;../io/c&quot;&gt;テキストモードI / Oで&lt;/a&gt;使用する場合に特別な意味を持ちます。OS固有の改行表現（通常はバイトまたはバイトシーケンス）に変換されます。一部のシステムは、代わりに長さフィールドで行をマークします。</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の新しく作成されたオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">get領域の次の文字。成功すると &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; 、失敗すると &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">次の文字は、 &lt;code&gt;char_type ct = *in;&lt;/code&gt; ように &lt;code&gt;in&lt;/code&gt; から抽出されます。</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">保存される次のマルチバイト文字は &lt;code&gt;len&lt;/code&gt; を超えます。</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">ストリームからの次のワイド文字、またはエラーが発生したかファイルの終わりに達した場合は &lt;code&gt;WEOF&lt;/code&gt; 。エンコードエラーが発生した場合、 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;EILSEQ&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">次に格納されるワイド文字は &lt;code&gt;len&lt;/code&gt; を超えます。</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">noexcept-specificationは関数タイプの一部であり、&lt;a href=&quot;function&quot;&gt;関数宣言子の&lt;/a&gt;一部として表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">noexcept-specificationは関数型の一部ではなく（&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様の&lt;/a&gt;ように）、型の関数、変数、非静的データメンバーを&lt;a href=&quot;function&quot;&gt;宣言する&lt;/a&gt;ときに、&lt;a href=&quot;lambda&quot;&gt;ラムダ宣言子&lt;/a&gt;または最上位関数宣言子の一部としてのみ表示できます関数、関数へのポインター、関数への参照、またはメンバー関数へのポインター。また、これらの宣言の1つでパラメーターまたは戻り値の型を宣言し、その宣言がたまたま関数へのポインターまたは参照である場合。&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;または&lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非変換の特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 常に &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; で使用できるタイプ &lt;code&gt;catalog&lt;/code&gt; 負でない値。カタログを開けなかった場合は、負の値を返します。</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">投げないオーバーロードは、エラーに対して特別なアクションを持ちません。</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードは、エラー時に &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードはエラー時に &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードは、エラー時に &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">投げないオーバーロードは、エラー時に空のパスを返します。</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">スローしないオーバーロードは、エラー時にすべてのメンバーを &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">この関数によって計算されるノルムは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;フィールドノルム&lt;/a&gt;または&lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;絶対二乗&lt;/a&gt;とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">式 &lt;code&gt;(E)&lt;/code&gt; の正規形は、 &lt;code&gt;E&lt;/code&gt; の正規形です。</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">表現の正規形 &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; の名前コンセプトの制約表現の正規形である &lt;code&gt;C&lt;/code&gt; 、A1、A2を代入した後、...、ANのための &lt;code&gt;C&lt;/code&gt; &quot; s Cの各アトミック制約のパラメーターマッピング内のそれぞれのテンプレートパラメーター。パラメーターマッピングへのそのような置換の結果、無効な型または式になる場合、プログラムの形式が正しくないため、診断は必要ありません。</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; の正規形は、 &lt;code&gt;E1&lt;/code&gt; と &lt;code&gt;E2&lt;/code&gt; の正規形の結合です。</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">式の正規形 &lt;code&gt;E1 || E2&lt;/code&gt; は、 &lt;code&gt;E1&lt;/code&gt; と &lt;code&gt;E2&lt;/code&gt; の正規形の分離です。</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">他の式 &lt;code&gt;E&lt;/code&gt; の正規形は、式が &lt;code&gt;E&lt;/code&gt; で、パラメーターマッピングがIDマッピングであるアトミック制約です。これには、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; または &lt;code&gt;||&lt;/code&gt; を折りたたむものも含め、すべての&lt;a href=&quot;fold&quot;&gt;折りたたみ式が&lt;/a&gt;含まれます。演算子。</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">通知スレッドは、待機スレッドが保持しているものと同じミューテックスにロックを保持する必要はありません。</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">実際、そうすると、通知されたスレッドは通知されたスレッドがロックを解放するのを待って、すぐにまたブロックしてしまうので、悲観的になってしまいます。しかし、いくつかの実装(特に pthreads の多くの実装)では、この状況を認識しており、待機中のスレッドを起動させずに、条件変数のキューから直接通知呼び出し内のミューテックスのキューに転送することで、この「急いで待つ」シナリオを回避しています。</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">null文字（ &lt;code&gt;'\0'&lt;/code&gt; 、 &lt;code&gt;L'\0'&lt;/code&gt; 、 &lt;code&gt;char16_t()&lt;/code&gt; など）は常に文字列リテラルに追加されます。したがって、文字列リテラル &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; は文字 &lt;code&gt;'H'&lt;/code&gt; を保持する &lt;code&gt;const char[6]&lt;/code&gt; 、 &lt;code&gt;'e'&lt;/code&gt; 、 &lt;code&gt;'l'&lt;/code&gt; 、 &lt;code&gt;'l'&lt;/code&gt; 、 &lt;code&gt;'o'&lt;/code&gt; 、および &lt;code&gt;'\0'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">ヌル文字を変換して保存しました。</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">ヌル文字が変換されて保存されました。 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に設定され、 &lt;code&gt;*ps&lt;/code&gt; は初期シフト状態を表します。</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">nullディレクティブ（ &lt;code&gt;#&lt;/code&gt; の後に改行が続く）は許可され、効果はありません。</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">文字列内の &lt;code&gt;CharT&lt;/code&gt; 要素の数。</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">ビュー内の &lt;code&gt;CharT&lt;/code&gt; 要素の数。</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">すべての &lt;code&gt;from_end-from&lt;/code&gt; 文字が消費されるか、 &lt;code&gt;max&lt;/code&gt; &lt;code&gt;internT&lt;/code&gt; 文字が生成されるか、変換エラーが発生するまで、 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; によって変換された場合に消費される &lt;code&gt;externT&lt;/code&gt; 文字の数。</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">呼び出しの瞬間に管理対象オブジェクトの所有権を共有する &lt;code&gt;shared_ptr&lt;/code&gt; インスタンスの数。</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">ビットフィールドのビット数は、それが保持できる値の範囲の制限を設定します。</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">コンテナ内のバケツの数です。</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">（間のバイト数 &lt;code&gt;1&lt;/code&gt; 及び &lt;code&gt;n&lt;/code&gt; は完全に有効なマルチバイト文字こと）。</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">配列オブジェクトに格納されているバイト数（シフトシーケンスを含む）。これは、 &lt;code&gt;c8&lt;/code&gt; がコードポイントのUTF-8表現の最後のコード単位ではない場合、ゼロになることがあります。</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">成功した場合の終了 &lt;code&gt;'\0'&lt;/code&gt; を含まない、 &lt;code&gt;str&lt;/code&gt; が指す文字配列に書き込まれたバイト数。場合は &lt;code&gt;count&lt;/code&gt; 文字列全体が格納される前に到達した、 &lt;code&gt;​0​&lt;/code&gt; 返され、その内容は不定です。</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">実際に抽出した文字数。</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">非ブロック読み取りに使用できる文字数（get領域のサイズまたは関連する文字シーケンスから読み取る準備ができている文字数）、または &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; までの関連シーケンスで使用できる文字がない場合は &lt;code&gt;-1&lt;/code&gt; ）わかる。</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">ファイルからの読み取りに使用できる文字数。ファイルの終わりに達した場合は &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">直近の変換操作で消費された文字数。</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">最後の未整形入力操作で抽出された文字数。</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">put領域の文字数、何も出力されなかった場合は0。</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">正常に読み取られた文字数。 &lt;code&gt;count&lt;/code&gt; 未満の場合、入力シーケンスは最後に達しています。</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">正常に書き込まれた文字数です。</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">関連する文字シーケンスで確実に使用可能な文字の数、または &lt;code&gt;showmanyc&lt;/code&gt; がブロックなしで使用可能な文字がないと判断できる場合は &lt;code&gt;-1&lt;/code&gt; 。もし &lt;code&gt;showmanyc&lt;/code&gt; が &lt;code&gt;-1&lt;/code&gt; を返す、 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; は必ず &lt;code&gt;Traits::eof&lt;/code&gt; またはthrowを返します。</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">putエリアに書き込まれた文字数。</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">実行される比較の数は、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; 距離の対数です（最大2 * log</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">実行される比較の数は、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; 距離の対数です（最大で対数</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">間の桁数 &lt;code&gt;thousand-sep&lt;/code&gt; S（の最大サイズ &lt;code&gt;digits&lt;/code&gt; ）の結果によって指定される &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">小数点以下に表示する桁数。一般的な米国のロケールでは、これは値 &lt;code&gt;2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ints&lt;/code&gt; の要素数。</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">バケット &lt;code&gt;n&lt;/code&gt; の要素の数。</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">コンテナ内の要素数。</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">スパン内の要素数。</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">削除された要素の数。</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; のハードリンクの数。</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">参照先ファイルシステムオブジェクトのハードリンクの数。</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; から &lt;code&gt;last&lt;/code&gt; までのインクリメントの数。ランダムアクセス反復子が使用され、 &lt;code&gt;first&lt;/code&gt; 使用される場合、値は負になる可能性がありますから &lt;code&gt;last&lt;/code&gt; 到達できる場合（C ++ 11以降）、。</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">正規表現内のマークされた副表現の数。</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">サブマッチの数。</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">この期間の目盛りの数。</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">&lt;code&gt;std::numpunct&lt;/code&gt; サポートされている数値の形式は以下のとおりです。ここで、 &lt;code&gt;digit&lt;/code&gt; は &lt;code&gt;fmtflags&lt;/code&gt; 引数値で指定された基数セットを表し、 &lt;code&gt;thousands-sep&lt;/code&gt; および &lt;code&gt;decimal-point&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; それぞれ（）関数 decimal_point（）関数の結果です。整数値の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;処理のステージ2で、次の文字の読み取り中にストリームの終わりが検出された場合、&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;の数値入力オーバーロード。解析状態に応じて、 &lt;code&gt;failbit&lt;/code&gt; は同時に設定される場合と設定されない場合があります &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; たとえば、int n; istringstream buf（ &quot;1&quot;）; buf &amp;gt;&amp;gt; n; &lt;code&gt;eofbit&lt;/code&gt; ではなく &lt;code&gt;failbit&lt;/code&gt; 設定します。整数 &lt;code&gt;1&lt;/code&gt; は正常に解析され、 &lt;code&gt;n&lt;/code&gt; に格納されました。一方、 &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; &lt;code&gt;eofbit&lt;/code&gt; と &lt;code&gt;failbit&lt;/code&gt; の両方を設定します &lt;code&gt;true&lt;/code&gt; 。ブール値trueの解析を完了するのに十分な文字がありませんでした。</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; が実際に現在組み込まれているロケールで、数値の &lt;code&gt;radix&lt;/code&gt; として有効な数字を表す場合の数値。エラーの場合は &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">数値、ポインタ、およびブールの入力過負荷&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;（技術的には、オーバーロードの&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;、彼らが呼ぶ）、入力が有効な値として、あるいは解析された値がに収まらない場合は解析できない場合宛先タイプ。</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">オブジェクトの</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">オブジェクト &lt;code&gt;u&lt;/code&gt; は&lt;a href=&quot;../language/default_initialization&quot;&gt;デフォルトで初期化されます&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">オブジェクト &lt;code&gt;u&lt;/code&gt; は&lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;または&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">新規式で作成されたオブジェクトは、以下のルールに従って初期化されます。</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">GLVALUEで表されるオブジェクトは、以下の場合にはアクセスされません。</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">オブジェクトはデフォルトで初期化されています。</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">オブジェクトは、&lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;shared_ptr&lt;/code&gt; に提供されるカスタムの削除機能を使用して破棄されます構築中にます。</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">オブジェクトは、 &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; を呼び出すことにより、ユーザーが提供する可能性のある削除機能を使用して破棄されます。デフォルトの &lt;code&gt;delete&lt;/code&gt; 機能は、オブジェクトを破棄してメモリの割り当てを解除する削除演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">オブジェクトは、以下のいずれかが発生した場合に、関連する削除器を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">オブジェクトはタイプ &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;optional&lt;/code&gt; 値で初期化/割り当てられますオブジェクトでます。</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">オブジェクトは、タイプ &lt;code&gt;T&lt;/code&gt; または別の &lt;code&gt;optional&lt;/code&gt; 値で初期化/割り当てられますその</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">タイプ&lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt;のオブジェクトこのロケールで使用されるを記述する。</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">グループを保持するタイプ &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::moneypunct&lt;/code&gt; の標準的な特殊化は、グループ化がないことを示す空の文字列を返します。典型的なグループ（例： &lt;code&gt;en_US&lt;/code&gt; ロケール）は &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">グループを保持するタイプ &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::numpunct&lt;/code&gt; の標準的な特殊化は、グループ化がないことを示す空の文字列を返します。典型的なグループ（例： &lt;code&gt;en_US&lt;/code&gt; ロケール）は &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">タイプ &lt;code&gt;CharT&lt;/code&gt; のオブジェクト小数点文字を保持する。</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">桁区切り記号として使用するタイプ &lt;code&gt;char_type&lt;/code&gt; のオブジェクト。一般的な米国のロケールでは、これは &lt;code&gt;','&lt;/code&gt; または &lt;code&gt;L','&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">桁区切り記号として使用するタイプ &lt;code&gt;char_type&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::numpunct&lt;/code&gt; の標準的な特殊化は &lt;code&gt;','&lt;/code&gt; および &lt;code&gt;L','&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">タイプ &lt;code&gt;string_type&lt;/code&gt; のオブジェクト通貨記号またはコードを保持する。</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">そのような宣言によって宣言されたオブジェクトまたは型は、すべての &lt;code&gt;alignas&lt;/code&gt; の最も厳密な（最大の）非ゼロ式と等しい&lt;a href=&quot;objects#Alignment&quot;&gt;配置要件&lt;/a&gt;を持ちますは、型の自然な整列を弱める場合を除き、宣言で使用される指定子ます。</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">オブジェクトは、 &lt;code&gt;lock&lt;/code&gt; 、 &lt;code&gt;try_lock&lt;/code&gt; 、および &lt;code&gt;unlock&lt;/code&gt; への不特定の一連の呼び出しによってロックされます。 &lt;code&gt;lock&lt;/code&gt; または &lt;code&gt;unlock&lt;/code&gt; 呼び出しで例外が発生した場合は、 &lt;code&gt;unlock&lt;/code&gt; オブジェクトに対してを呼び出してから再スローします。</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">new-expressionsによって作成されたオブジェクト（動的ストレージ期間を持つオブジェクト）は、new-expressionによって返されたポインターが一致&lt;a href=&quot;delete&quot;&gt;するdelete-expressionで&lt;/a&gt;使用されるまで存続します。ポインタの元の値が失われると、オブジェクトに到達できなくなり、割り当てを解除できなくなります。</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">オブジェクトはオーバーラップする可能性があります。コピーは、文字が一時的な文字配列にコピーされた後に、配列から &lt;code&gt;dest&lt;/code&gt; に文字がコピーされたかのように行われます。</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">成功または &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; で取得した文字失敗。</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">取得したワイド文字、またはエラーが発生したかファイルの終わりに達した場合は &lt;code&gt;WEOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">機能テストの推奨に関する公式文書</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">標準レイアウトタイプの最初のメンバーのオフセットは常にゼロです（&lt;a href=&quot;../language/ebo&quot;&gt;空ベースの最適化&lt;/a&gt;は必須です）。</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; の古い値。</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 格納される唯一のデータは、タイプ &lt;code&gt;Rep&lt;/code&gt; のティックカウントです。 &lt;code&gt;Rep&lt;/code&gt; が浮動小数点の場合、 &lt;code&gt;duration&lt;/code&gt; はティックの分数を表すことができます。 &lt;code&gt;Period&lt;/code&gt; は期間のタイプの一部として含まれており、異なる期間間で変換する場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一の違い &lt;code&gt;std::nearbyint&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; それである &lt;code&gt;std::nearbyint&lt;/code&gt; 上げることはありません &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一の違い &lt;code&gt;std::rint&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; されていること &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; 上げることはありません &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">唯一の例外は</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">decl-specifier-seqで2回出現できる唯一の指定子は &lt;code&gt;long&lt;/code&gt; （2回出現する可能性があります）です。 &lt;code&gt;const static const&lt;/code&gt; や &lt;code&gt;virtual inline virtual&lt;/code&gt; などの他のすべての繰り返しはエラーです。</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">コンストラクタ宣言のdecl-specifier-seqで許可される指定子は、&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;、&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;、 &lt;code&gt;explicit&lt;/code&gt; 、および &lt;code&gt;constexpr&lt;/code&gt; のみです（特に、戻り値の型は許可されていません）。&lt;a href=&quot;member_functions&quot;&gt;cv-およびref-qualifiers&lt;/a&gt;も使用できないことに注意してください。構築中のオブジェクトのconstおよびvolatileセマンティクスは、最も派生したコンストラクターが完了するまで開始されません。</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">この特殊化によって、唯一の標準 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; メンバー定数 &lt;code&gt;is_always_lock_free&lt;/code&gt; も提供されます。</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外をスローする唯一の標準ライブラリコンポーネントは &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外をスローする唯一の標準ライブラリコンポーネントは、 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">個人的にコピー可能な型は、スカラ型、個人的にコピー可能なクラス、およびそのような型/クラスの配列のみです(const-qualifiedの可能性もありますが、volatile-qualifiedではありません)。</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">唯一の有効な使用 &lt;code&gt;operator*&lt;/code&gt; イテレータは割り当ての左側にある出力には： &lt;code&gt;operator*&lt;/code&gt; メンバー定義プロキシオブジェクトを返すことができる &lt;code&gt;operator=&lt;/code&gt; （テンプレートであってもよいです）。</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">アロケータを置き換えるには、コピー割り当て、移動割り当て、スワップしかありません。</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">組み込みの後置インクリメントまたはデクリメント演算子のオペランドexprは、非ブール算術型の変更可能な（非const）&lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;または完全な&lt;a href=&quot;type-id&quot;&gt;オブジェクトタイプ&lt;/a&gt;へのポインターでなければなりません。結果は、オペランドの元の値の&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;コピーです。副作用として、非ブールオペランドの場合、式 &lt;code&gt;x++&lt;/code&gt; は &lt;code&gt;x += 1&lt;/code&gt; 評価することによってそのオペランドの値を変更し、式 &lt;code&gt;x--&lt;/code&gt; は &lt;code&gt;x -= 1&lt;/code&gt; 評価することによってそのオペランドの値を変更します。に対して定義されたすべての算術変換規則とポインター算術規則&lt;a href=&quot;operator_arithmetic&quot;&gt;算術演算子に&lt;/a&gt;は、式と戻り値の型だけでなく、オペランドに適用される暗黙の変換（存在する場合）を適用および決定します。</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">組み込みの前置インクリメントまたはデクリメント演算子のオペランドexprは、非ブール算術型の変更可能な（非const）&lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;または完全な&lt;a href=&quot;type-id&quot;&gt;オブジェクト型&lt;/a&gt;へのポインターでなければなりません。非ブールオペランドの場合、式 &lt;code&gt;++x&lt;/code&gt; は &lt;code&gt;x += 1&lt;/code&gt; とまったく同じであり、式 &lt;code&gt;--x&lt;/code&gt; は &lt;code&gt;x -= 1&lt;/code&gt; とまったく同じです。つまり、プレフィックスのインクリメントまたはデクリメントは、変更されたオペランド。&lt;a href=&quot;operator_arithmetic&quot;&gt;算術演算子に&lt;/a&gt;定義されているすべての算術変換規則とポインター算術規則が適用され、オペランドに適用される暗黙の変換（存在する場合）と式の戻り値の型が決定されます。</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; のオペランドをCスタイルの型キャストにすることはできません。式 &lt;code&gt;sizeof (int) * p&lt;/code&gt; は &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; として明確に解釈されますが、 &lt;code&gt;sizeof((int)*p)&lt;/code&gt; は解釈されません。</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">組み込みのindirection演算子のオペランドは、オブジェクトへのポインタまたは関数へのポインタでなければならず、結果はexprが指すポインタまたは関数を参照するlvalueとなります。</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">任意の演算子のオペランドは、他の式または1次式にすることができます（たとえば、 &lt;code&gt;1+2*3&lt;/code&gt; では、operator +のオペランドは部分式 &lt;code&gt;2*3&lt;/code&gt; および &lt;code&gt;1&lt;/code&gt; 次式1です）。</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">演算子&lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt;（C ++ 11以降）のオペランドは、評価されない式です（これらが多相性glvalueであり、 &lt;code&gt;typeid&lt;/code&gt; のオペランドでない限り）。これらの演算子はコンパイル時のプロパティのみをクエリするためですオペランドの。したがって、 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; コンソール出力を実行しません。</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">オペレーションは、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">オペレーションは、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">オペレーションは、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;set_exception&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">オペレーションは、 &lt;code&gt;set_value&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">以下のように操作を行います。</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">オペレーター &lt;code&gt;operator!&lt;/code&gt; 通常、ブールコンテキストで使用するためのユーザー定義クラスによってオーバーロードされます。このようなクラスは、ユーザー定義の変換関数の &lt;code&gt;explicit operator bool()&lt;/code&gt; （標準ライブラリの例については &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; を参照）と &lt;code&gt;operator!&lt;/code&gt; 予期される動作も提供します！ &lt;code&gt;operator bool&lt;/code&gt; 反対の値を返すことです。</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">演算子 &lt;code&gt;::&lt;/code&gt; （スコープ解決）、 &lt;code&gt;.&lt;/code&gt; （メンバーアクセス）、 &lt;code&gt;.*&lt;/code&gt; （メンバーへのポインターを介したメンバーアクセス）、および &lt;code&gt;?:&lt;/code&gt; ( 3項条件付き）はオーバーロードできません。</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非ローカル変数の破棄の順序は &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 記述されています。</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">等しい要素の順序が保持されるとは限りません。範囲 &lt;code&gt;[middle, last)&lt;/code&gt; の残りの要素の順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">リスト内のメンバーの初期化子の順番は関係ありません。</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">消去されない要素の順番は保存されます。(これにより、コンテナを反復しながら個々の要素を消去することが可能になります)。</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">等価比較する要素の順序は挿入順であり、変更はありません。(C++11 以降)。</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">キーが等価な比較をするキーと値のペアの順序は、挿入順であり、変更されません。(C++11 以降)。</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">順序付けの比較は辞書式に行われます-比較は &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; と同等の関数によって実行されます。</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">順序は厳密な弱順序関係である。</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; キーワードの本来の目的は、&lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;関数のインライン置換が&lt;/a&gt;関数呼び出しよりも優先される、つまり、関数呼び出しのCPU命令を実行する代わりに、制御を関数本体にコピーするのではなく、関数本体は、呼び出しを生成せずに実行されます。これにより、関数呼び出し（引数の受け渡しと結果の取得）によって生じるオーバーヘッドは回避されますが、関数のコードを複数回繰り返す必要があるため、実行可能ファイルが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">出力イテレーター &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; すると、標準アルゴリズムで初期化されていないメモリに結果を保存できます。アルゴリズムがタイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを逆参照イテレーターに書き込むときは常に、オブジェクトはイテレーターが指す初期化されていないストレージ内の場所にコピー構築されます。テンプレートパラメータ &lt;code&gt;OutputIt&lt;/code&gt; は、の要件を満たし、任意のタイプであり&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIteratorを&lt;/a&gt;と有する &lt;code&gt;operator*&lt;/code&gt; のオブジェクトを返すように定義され、 &lt;code&gt;operator&amp;amp;&lt;/code&gt; リターンタイプのオブジェクト &lt;code&gt;T*&lt;/code&gt; 。通常、タイプ &lt;code&gt;T*&lt;/code&gt; は &lt;code&gt;OutputIt&lt;/code&gt; として使用されます。</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">式の出力は、その結果と、式によって変更されたすべてのオペランド(もしあれば)で構成されます。</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">場合、過負荷（3）のみオーバーロード解決に関与 &lt;code&gt;Sseq&lt;/code&gt; はとしての資格&lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;。特に、 &lt;code&gt;Sseq&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; に変換可能な場合、候補関数のセットから除外されます。</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">オーバーロード（3）は、 &lt;code&gt;int&lt;/code&gt; などの非クラス型の要素をゼロに初期化します。これは、初期化されていない&lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt;動作とは異なります。 &lt;code&gt;new[]&lt;/code&gt; 動作と一致させるために、そのような要素を初期化しないままにする&lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;カスタムAllocator :: construct&lt;/a&gt;を提供できます。</target>
        </trans-unit>
        <trans-unit id="b0d7a75e51aff3dfb39b338a8d075fab0f39ca24" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">オーバーロード（3）は、 &lt;code&gt;int&lt;/code&gt; などの非クラス型の要素をゼロにします。これは&lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt;動作とは異なり、初期化されないままになります。 &lt;code&gt;new[]&lt;/code&gt; 動作に一致させるために、そのような要素を初期化しないままにする&lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;カスタムAllocator :: construct&lt;/a&gt;を提供できます。</target>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; リターンの最初の要素へのポインタ &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;valarray&lt;/code&gt; 数値配列の最初の要素を参照して指定されていないタイプのイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;initializer_list&lt;/code&gt; の最後の要素過去1に戻りポインタ &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;valarray&lt;/code&gt; 数値配列の最後の要素過去1を参照の不特定の型のイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; リターン &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; の最後の要素を指し &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; 戻り &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; の最初の要素を指し &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">operator- &lt;code&gt;-&amp;gt;&lt;/code&gt; のオーバーロードは、生のポインターを返すか、またはoperator- &lt;code&gt;-&amp;gt;&lt;/code&gt; がオーバーロードされたオブジェクトを（参照または値によって）返す必要があります。</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを取らないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; を使用し、エラーコード引数としてOSエラーコードを使用して構築された、基になるOS APIエラーに対して&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターをとらないオーバーロードは、OSエラーコードをエラーコード引数として構築された、基になるOS APIエラーに対して&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取らないオーバーロードは、最初のパス引数として &lt;code&gt;to&lt;/code&gt; を2番目のパス引数として、OSエラーコードをエラーコード引数として構築さ &lt;code&gt;from&lt;/code&gt; 、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">とらないオーバーロード &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータは、スロー&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;で構築基盤となるOSのAPIエラー、上 &lt;code&gt;old_p&lt;/code&gt; 最初のパス引数として &lt;code&gt;new_p&lt;/code&gt; 第2の経路引数として、およびエラーコードの引数としてOSのエラーコードを。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">とらないオーバーロード &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータは、スロー&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; を&lt;/a&gt;用いて構築基盤となるOSのAPIのエラー、上 &lt;code&gt;p1&lt;/code&gt; 最初のパス引数として &lt;code&gt;p2&lt;/code&gt; 第2の経路引数として、およびエラーコードの引数としてOSのエラーコード。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを取らないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; を使用し、エラーコード引数としてOSエラーコードを使用して構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターをとらないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; 、2番目のパス引数として &lt;code&gt;base&lt;/code&gt; 、エラーコード引数としてOSエラーコードで構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターをとらないオーバーロードは、最初のパス引数として &lt;code&gt;path to be returned&lt;/code&gt; れるパスとエラーコード引数としてOSエラーコードで構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターをとらないオーバーロードは、最初のパス引数として &lt;code&gt;target&lt;/code&gt; 、2番目のパス引数として &lt;code&gt;link&lt;/code&gt; 、エラーコード引数としてOSエラーコードで構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">&lt;code&gt;ExecutionPolicy&lt;/code&gt; というテンプレートパラメータを持つオーバーロードは、次のようにエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">オーバーロード（2-6）は &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; へのアロケーターの伝播を提供します。これは、リーディングアロケーターもトレーリングアロケーターの呼び出し規約もサポートしません（たとえば、リーディングアロケーター規約を使用する &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; とは異なります）。</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">オーバーロード（5、6）は、しばしば &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; をヒントとしてオーバーロード（3）を呼び出すループとして実装されます。それらは、最小の要素が &lt;code&gt;*this&lt;/code&gt; の最後の要素より大きいソートされたシーケンス（別のセットなど）を追加するために最適化されています。</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">C ++ 14以降、オーバーロードは &lt;code&gt;constexpr&lt;/code&gt; としてマークされています。</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">パラメータとして &lt;code&gt;opts&lt;/code&gt; をとらないオーバーロードは、&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; の&lt;/a&gt;デフォルトで構築されたインスタンスをオプションとして使用します。 &lt;code&gt;upstream&lt;/code&gt; をパラメーターとして使用しないオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; の戻り値をアップストリームメモリリソースとして使用します。</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">パラメータとして &lt;code&gt;opts&lt;/code&gt; をとらないオーバーロードは、&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; の&lt;/a&gt;デフォルトで構築されたインスタンスをオプションとして使用します。 &lt;code&gt;upstream&lt;/code&gt; をパラメーターとして使用しないオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; 戻り値をアップストリームメモリリソースとして使用します。</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆または &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆を左側の引数として取る &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; のオーバーロードは、挿入および抽出演算子と呼ばれます。これらはユーザー定義型を正しい引数（ &lt;code&gt;b&lt;/code&gt; @bのb）として受け取るため、非メンバーとして実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; のオーバーロード 短絡評価を失います。</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">引数が範囲外の場合、 &lt;code&gt;pos1&lt;/code&gt; または &lt;code&gt;pos2&lt;/code&gt; という名前のパラメーターを取るオーバーロードは &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; スローします。</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 使用しないオーバーロードは、各タプル引数がペアの要素になることを前提としています。 &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; を使用するオーバーロードは、各タプル引数を使用して、指定されたタイプの新しいオブジェクトを区分的に構築し、それがペアの要素になることを前提としています。</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">&lt;code&gt;ExecutionPolicy&lt;/code&gt; という名前のテンプレートパラメータを持つオーバーロードは、次のようにエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">仮想メンバー関数 &lt;code&gt;what()&lt;/code&gt; のオーバーライドは提供される場合がありますが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;仮想&lt;/a&gt;関数のオーバーライドは、基本クラス宣言からデフォルト引数を取得せず、仮想関数呼び出しが行われると、デフォルト引数はオブジェクトの静的タイプに基づいて決定されます（注：これは&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;非仮想インターフェイス&lt;/a&gt;パターン）。</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">オブジェクトの所有権は、その値を別の &lt;code&gt;shared_ptr&lt;/code&gt; にコピー構築またはコピー割り当てすることによってのみ、別の &lt;code&gt;shared_ptr&lt;/code&gt; と共有できます。別の &lt;code&gt;shared_ptr&lt;/code&gt; が所有する生の基になるポインターを使用して新しい &lt;code&gt;shared_ptr&lt;/code&gt; を構築すると、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">標準規格の厳密なエイリアシングルールを定義する段落には、Cから部分的に継承された2つの追加の箇条書きが含まれています。</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">このアルゴリズムの並列化可能なバージョンである &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; では、 &lt;code&gt;op1&lt;/code&gt; と &lt;code&gt;op2&lt;/code&gt; が可換的かつ連想的である必要がありますが、 &lt;code&gt;std::inner_product&lt;/code&gt; はそのような要件を設けておらず、常に指定された順序で操作を実行します。</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">パラメータ &lt;code&gt;P&lt;/code&gt; は、次のように得られる：で &lt;code&gt;T&lt;/code&gt; 含む変数の宣言された型 &lt;code&gt;auto&lt;/code&gt; のすべての発生 &lt;code&gt;auto&lt;/code&gt; 、パラメータ虚型テンプレートで置換されている &lt;code&gt;U&lt;/code&gt; 初期化して、コピーリストの初期化である場合、または &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; 。引数 &lt;code&gt;A&lt;/code&gt; は初期化式です。上記のルールに従って &lt;code&gt;P&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; を演繹した後、演繹された &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;P&lt;/code&gt; に代入され、実際の変数の型が取得されます。</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">パラメータ &lt;code&gt;i&lt;/code&gt; は、配列の要素数よりも少なくなければなりません。それ以外の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">パラメータ &lt;code&gt;init&lt;/code&gt; は、この関数ではオプションであるため、 &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; とは異なり、最後に表示されます。</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">パラメータは値で渡され、スライスの対象となります。</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">関数のパラメータ型と戻り値の型はターゲットと正確に一致していなければならず、暗黙の変換は考慮されません(例えば、baseへのポインタを返す関数へのポインタを初期化する際に、 derivedへのポインタを返す関数は選択されません)。</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">削除された関数（C ++ 11以降）を除いて、パラメーターの型と関数の戻り値の型を&lt;a href=&quot;incomplete_type&quot;&gt;不完全な&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;クラス型&lt;/a&gt;にすることはできません。完全性チェックは、関数のコンテキストで行われます</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">関数定義の宣言子で宣言されたパラメーターは、本体内の&lt;a href=&quot;scope&quot;&gt;スコープ&lt;/a&gt;内にあります。関数本体でパラメーターが使用されていない場合は、名前を付ける必要はありません（抽象宣言子を使用するだけで十分です）。</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">パラメータ m と s はそれぞれ x の自然対数の平均と標準偏差である。</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">配布オブジェクトのパラメーターは、 &lt;code&gt;d.param(p)&lt;/code&gt; を使用して永続的に変更することも、 &lt;code&gt;d(g,p)&lt;/code&gt; を使用して単一のoperator（）呼び出しの期間だけ変更することもできます。</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">スライスのパラメータ --開始、サイズ、ストライドをそれぞれ指定します。</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">スライスのパラメータ --それぞれ開始、サイズ、歩幅。</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">主関数の2つのパラメータ形式のパラメータは、実行環境から任意のマルチバイト文字列を渡すことを可能にします(これらは通常</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析された日付は、引数 &lt;code&gt;t&lt;/code&gt; が指す &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体の対応するフィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">解析された月は、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; フィールド &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析された時間は、引数 &lt;code&gt;t&lt;/code&gt; が指す &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体の対応するフィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">解析された曜日は &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; フィールド &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">解析された年は、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体フィールド &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">部分的な特殊化（5）は、 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; 変換できない場合にのみ存在します。</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">ペアの &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; の部分的な特殊化は、タプルのような構文を使用して、ペアの要素の数（常に2）を取得するコンパイル時の方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">ペアの &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; の部分的な特殊化は、タプルのような構文を使用して、ペアの要素のタイプへのコンパイル時アクセスを提供します。 &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; 場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">テンプレートの部分特殊化 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、ユーザーがshared_ptrのがアトミックオブジェクトを操作することができます。</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">テンプレートの部分特殊化 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、ユーザーがアトミックのweak_ptrオブジェクトを操作することができます。</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">過去の終わりのイテレータは特に言及する価値があります。一般に、このイテレータは、消去されていない要素に対する通常のイテレータであるかのように無効化されます。したがって、 &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; は決して無効化されず、 &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; はrehashでのみ無効化され、 &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; は常に無効化されます（変更された要素の後にあるため）。</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">また、消去された要素がコンテナの先頭にあり、最後の要素が消去されていない場合は、過去終了イテレータも無効になります。</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">過去の終わりのイテレータは無効になる可能性があります(実装で定義されています)。</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">過去の終わりのイテレータです。</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">パス &lt;code&gt;&quot;/&quot;&lt;/code&gt; はPOSIX OSでは絶対パスですが、Windowsでは相対パスです。</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">パスは、 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 関数によって返されたイテレータを介して要素ごとにトラバースできます。イテレータは、パスを汎用形式で表示し、ルート名、ルートディレクトリ、および後続のファイル名要素を反復します（ただし、ディレクトリセパレータはスキップされます。ルートディレクトリを識別するもの）。パスの最後の要素がディレクトリセパレータの場合、最後のイテレータは空の要素を逆参照します。</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">入力文字列を UTF-8 からファイルシステムのネイティブ文字エンコーディングに変換した後に構築されたパス。</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">パス名には次のような構文があります。</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">親ディレクトリへのパス。</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">離心率が &lt;code&gt;k&lt;/code&gt; 、半長軸がaの楕円の周長は4aE（k）に等しく、Eは &lt;code&gt;std::comp_ellint_2&lt;/code&gt; です。離心率が0の場合、楕円は縮退して半径aの円になり、周長は2&amp;pi;aになるため、E（0）=&amp;pi;/ 2になります。離心率が1に等しい場合、楕円は長さが2aの線に縮退し、その外周は4aなので、E（1）= 1になります。</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">結果の期間の期間は、 &lt;code&gt;Period1&lt;/code&gt; と &lt;code&gt;Period2&lt;/code&gt; の最大公約数です。</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">プレースホルダー&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;はconversion-type-idで使用でき、&lt;a href=&quot;function#Return_type_deduction&quot;&gt;推定される戻り型を示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">プレースホルダー &lt;code&gt;auto&lt;/code&gt; には、型の推定に参加する &lt;code&gt;const&lt;/code&gt; や &lt;code&gt;&amp;amp;&lt;/code&gt; などの修飾子が伴う場合があります。プレースホルダー &lt;code&gt;decltype(auto)&lt;/code&gt; は、宣言された型の唯一の構成要素でなければなりません（C ++ 14以降）。</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">配置形式 &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; は許可されません。これは、割り当て解除関数の一致するシグニチャー &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; が通常の（配置ではない）ためです。割り当て解除関数。</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">プラットフォーム依存のエラー値。</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">&lt;a href=&quot;injected-class-name&quot;&gt;注入されたクラス名&lt;/a&gt;の宣言のポイントは、そのクラス（またはクラステンプレート）定義の開始中括弧の直後です。</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">&lt;a href=&quot;structured_binding&quot;&gt;構造化バインディング&lt;/a&gt;の宣言のポイントは、構造化バインディング宣言の識別子リストの直後ですが、構造化バインディング初期化子は、導入されている名前を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;タイプエイリアスまたはエイリアステンプレート&lt;/a&gt;の宣言のポイントは、エイリアスが参照するtype-idの直後です。</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">クラスまたはテンプレートの宣言のポイントは、クラスに名前を付ける識別子（またはテンプレートの特殊化に名前を付けるテンプレート&lt;a href=&quot;templates#template-id&quot;&gt;ID&lt;/a&gt;）がその&lt;a href=&quot;classes&quot;&gt;class-headに&lt;/a&gt;現れた直後であり、基本クラスのリストのスコープに既にあります。</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">列挙型の宣言のポイントは、&lt;a href=&quot;enum&quot;&gt;列挙型指定子&lt;/a&gt;または不透明な列挙型宣言の中で最初に使用された方に現れる、その名前を示す識別子の直後です。</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">列挙子の宣言ポイントは、その定義の直後(変数の場合のようにイニシャライザの前ではありません)です。</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">ポインタからメンバへのポインタは,それ自体がポインタからメンバへのポインタであっても構いません:メンバへのポインタは,複数レベルであっても構いません.ポインタとポインタからメンバへのポインタの混在した複数レベルの組み合わせも許されます.</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; が保持するポインタ。</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; が直接保持するポインターは &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; によって返されるポインターですが、制御ブロックが保持するポインター/オブジェクトは、共有所有者の数がゼロに達したときに削除されるポインターです。これらのポインタは必ずしも同じではありません。</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">ポインターは範囲 &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; は有効で、その中の値は文字列に格納された値に対応し、最後の位置の後にnull文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; から取得したポインタは、次の方法で無効化できます。</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">文字列オブジェクトに他のnull文字が含まれていない場合、 &lt;code&gt;c_str()&lt;/code&gt; から取得されたポインタは、nullで終了する文字列へのポインタとしてのみ扱われます。</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;data()&lt;/code&gt; から取得したポインタは、次の方法で無効化できます。</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.allocate(n)&lt;/code&gt; の呼び出しによって返されるポインター。</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">この実装で使用されるポインタの安全性。</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">変換先のポインタ</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">割り当てられたストレージへのポインタ。</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">再利用するストレージのブロックへのポインターは、上記のプロセスで最初の引数として選択された&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;割り当て解除関数に&lt;/a&gt;渡されます。ブロックのサイズは、オプションの &lt;code&gt;std::size_t&lt;/code&gt; 引数として渡されます。アラインメント要件は、オプションの &lt;code&gt;std::align_val_t&lt;/code&gt; 引数として渡されます（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">人気の高いEdsger W. Dijkstraのエッセイ&lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;「Gotoは有害であると考えられている」は&lt;/a&gt;、このキーワードの不注意な使用がもたらす可能性のある多くの微妙な問題の調査を提示しています。</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; の前の宣言の部分は、導入された識別子ではなく、隠し変数 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; に適用されます。</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">指定されたマッチまたはサブマッチの最初の文字の位置。</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">このタイプの可能な値（ &lt;code&gt;icase&lt;/code&gt; 、 &lt;code&gt;optimize&lt;/code&gt; 、など）は&lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt;内で複製されます。</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FLT_ROUNDSの可能な値は、 &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; によって返されるstd :: &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; 可能な値と一致します。</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">後付けの条件は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">postfix の増分式と減分式は、形式を持ちます。</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">関数パラメータ(ラムダ式のパラメータを含む)または関数ローカルの定義済み変数の潜在的なスコープは、その宣言時点から始まります。</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;クラスで&lt;/a&gt;宣言された名前の潜在的なスコープは、宣言の時点から始まり、残りのクラス本体とすべての関数本体（クラス定義の外部または名前の宣言の前に定義されている場合でも）、デフォルト引数、例外仕様が含まれます、クラス内のブレースまたはイコール初期化子、&lt;a href=&quot;attributes/contract&quot;&gt;コントラクト条件&lt;/a&gt;（C ++ 20以降）、およびネストされたクラスのこれらすべてのものを再帰的に返します。</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">例外ハンドラで宣言された名前の潜在的なスコープは、宣言された時点から始まり、例外ハンドラが終了した時点で終了します。</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">で宣言された名前の潜在的なスコープは</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">テンプレート・パラメータ名の潜在的な範囲は、宣言された時点から始まり、それが導入された最小のテンプレート宣言の最後まで続きます。特に,テンプレート・パラメータは,後続のテンプレート・パラメータの宣言や基底クラスの仕様では使用できますが,先行するテンプレート・パラメータの宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">&lt;a href=&quot;statements#Compound_statements&quot;&gt;ブロック&lt;/a&gt;内の宣言によって導入された変数の潜在的なスコープ（複合ステートメント）のポイントで始まり、ブロックの終わりで終わります。同じ名前を導入する宣言を持つネストされたブロックがない限り、実際のスコープは潜在的なスコープと同じです（その場合、ネストされた宣言の潜在的なスコープ全体が外部宣言のスコープから除外されます）。</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">&lt;a href=&quot;namespace&quot;&gt;名前空間で&lt;/a&gt;宣言されたエンティティの潜在的なスコープは宣言で始まり、その後に続く同じ名前空間名のすべての名前空間定義の連結と、この名前またはその名前空間全体を別のスコープに導入した&lt;a href=&quot;namespace&quot;&gt;usingディレクティブ&lt;/a&gt;で構成されます。そのスコープの残りの部分。</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">テンプレートテンプレートパラメータのパラメータ名の潜在的なスコープは、その名前が現れる最小のテンプレートパラメータリストです。</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">結果の精度は少なくとも &lt;code&gt;std::chrono::seconds&lt;/code&gt; であり、引数の精度が高いほど、精度が高くなります。</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">契約条件の述語には、それが適用される関数の本文の最初の&lt;a href=&quot;../statements#Expression_statements&quot;&gt;式ステートメント&lt;/a&gt;として出現する場合と同じ意味上の制限があります。</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">接頭辞の増分式と減分式は、形式を持ちます。</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">前処理ディレクティブは、プリプロセッサの動作を制御します。それぞれのディレクティブは1行で構成され、以下のような形式になっています。</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">プリプロセッサは、ソースファイルの翻訳機能を持っています。</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">プリプロセッサは、コンパイル前の&lt;a href=&quot;language/translation_phases&quot;&gt;変換フェーズ4&lt;/a&gt;で実行されます。前処理の結果、単一のファイルが作成され、実際のコンパイラに渡されます。</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">プリプロセッサは、ソースファイルの一部の条件付きコンパイルをサポートしています。この動作はによって制御されている &lt;code&gt;#if&lt;/code&gt; 、 &lt;code&gt;#else&lt;/code&gt; の、 &lt;code&gt;#elif&lt;/code&gt; の、 &lt;code&gt;#ifdef&lt;/code&gt; 、 &lt;code&gt;#ifndef&lt;/code&gt; 命令と &lt;code&gt;#endif&lt;/code&gt; のディレクティブ。</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">プリプロセッサは、テキストマクロの置換をサポートしています。関数のようなテキストマクロの置換もサポートしています。</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; によって返される以前のロケール。</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">グローバル C++ロケールの前の値。</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされた新しいハンドラ、または何もインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされていた終了ハンドラ、またはインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされた予期せぬハンドラ、または何もインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">プライマリ &lt;code&gt;std::atomic&lt;/code&gt; テンプレートは、&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;と&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignableの&lt;/a&gt;両方を満たす任意の&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型 &lt;code&gt;T&lt;/code&gt; でインスタンス化できます。次のいずれかの値が &lt;code&gt;false&lt;/code&gt; の場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">主な &lt;code&gt;std::atomic_ref&lt;/code&gt; テンプレートは、任意の&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;タイプ &lt;code&gt;T&lt;/code&gt; （ &lt;code&gt;bool&lt;/code&gt; を含む）でインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">function-try-block の主な目的は、コンストラクタのメンバ初期化リストからスローされた例外に対応するために、ログを取って再スローしたり、例外オブジェクトを修正して再スローしたり、代わりに別の例外をスローしたり、プログラムを終了したりすることです。デストラクタや通常の関数ではほとんど使用されません。</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">大文字、小文字、異表記、発音区別符号などを無視して、現在埋め込まれているロケールでの文字シーケンス &lt;code&gt;[first, last)&lt;/code&gt; のプライマリソートキー。</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">プライマリテンプレート(1)は定義されておらず、4つの異なるレベルの精度を扱うために4つの特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">プライマリ・テンプレートは空の構造体です。標準では、以下のような特殊化を定義しています。</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">プライマリテンプレートが空です。デフォルトのタイムゾーンポインタータイプである &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; の特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; の主な用途は、 &lt;code&gt;operator[]&lt;/code&gt; から返されるl値を提供することです。</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bitset::reference&lt;/code&gt; の主な用途は、&lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt;から返されるl値を提供することです。</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">プライベート &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; メンバーは、この代入演算子の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">確率 &lt;code&gt;h(a)==h(b)&lt;/code&gt; ための &lt;code&gt;a!=b&lt;/code&gt; 接近しなければならない &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">プログラムは形が悪い</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">&lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; が真でない場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 特殊化でない場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; が負の場合、プログラムの形式は正しくありません。場合 &lt;code&gt;N&lt;/code&gt; がゼロである、示されたタイプである &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; が2の累乗でない場合、プログラムの形式は &lt;code&gt;ptr&lt;/code&gt; ません。ptrが &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを指さない場合（すべてのレベルでcv-qualificationを無視）、またはオブジェクトの配置が &lt;code&gt;N&lt;/code&gt; 以上でない場合、動作は未定義です。。</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が関数型または（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; の場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">&lt;code&gt;std::initializer_list&lt;/code&gt; 明示的または部分的な特殊化が宣言されている場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">次のいずれかが当てはまらない場合、プログラムの形式が &lt;code&gt;true&lt;/code&gt; ありません。</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">プログラムは,1つの明確な</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">プログラマは何のスレッドが上の待つしようとしていないことを確認する必要があります &lt;code&gt;*this&lt;/code&gt; デストラクタが開始された後、待機中のスレッドがループで待機関数を呼び出しているか、述語を取る待機関数のオーバーロードを使用している場合は特に。</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">プログラミング言語&lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt;は、最初に式の値カテゴリを導入しました。すべてのCPL式は「右側モード」で評価できますが、「左側モード」で意味があるのは特定の種類の式のみです。右側モードで評価される場合、式は値（右側の値、または</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">プロミスは、プロミス未来通信チャネルの &quot;プッシュ &quot;エンドである:共有状態に値を格納する操作</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; のパブリック関数は、 &lt;code&gt;gptr() == nullptr&lt;/code&gt; または &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; 場合にのみ、この関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">厳密なエイリアスと関連ルールの目的は、タイプに基づくエイリアス分析を有効にすることです。これは、プログラムが関連のないタイプ（たとえば、 &lt;code&gt;int*&lt;/code&gt; と &lt;code&gt;float*&lt;/code&gt; ）への2つのポインタが同時に存在し、どちらも同じメモリをロードまたは保存するために使用できます（&lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;SG12リフレクタのこの電子メールを&lt;/a&gt;参照）。したがって、そのような状況を作成できると思われる技法は、必ず未定義の動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">このアダプタの目的は、入れ子になったコンテナのすべてのレベルが同じ共有メモリセグメントに配置されなければならない場合など、入れ子になったコンテナ内のステートフルなアロケータを正しく初期化することです。アダプタのコンストラクタはリスト内のすべてのアロケータの引数を取り、 各ネストされたコンテナは必要に応じてアダプタからそのアロケータの状態を取得します。</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外タイプの目的は、エラー条件 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; メンバー関数から &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; スローされる）および関連するerrno定数 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">このルールの目的は、テンプレートのインスタンス化に関する&lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODRの&lt;/a&gt;違反を防ぐことです。</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">疑問符のエスケープシーケンス &lt;code&gt;\?&lt;/code&gt; &lt;a href=&quot;operator_alternative&quot;&gt;トリグラフ&lt;/a&gt;が文字列リテラル内で解釈されないようにするために使用されます。 &lt;code&gt;&quot;??/&quot;&lt;/code&gt; などの文字列は &lt;code&gt;&quot;\&quot;&lt;/code&gt; としてコンパイルされ &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; 、「？\？/」のように2番目の疑問符がエスケープされると、「？」になり &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">実装がクワイエットNaNをサポートしていない場合は、識別文字列 &lt;code&gt;arg&lt;/code&gt; またはゼロに対応するクワイエットNaN値。</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">商は実装で定義された方向に丸められます。</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">商は、小数部分が破棄された（ゼロに向かって切り捨てられた）代数商です。残りは &lt;code&gt;quot * y + rem == x&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">商は、式 &lt;code&gt;x/y&lt;/code&gt; の結果です。残りは、式 &lt;code&gt;x%y&lt;/code&gt; の結果です。</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">商はゼロに向かって切り捨てられます(端数部分は破棄されます)。</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">乱数ライブラリは、乱数や擬似乱数を生成するクラスを提供します。これらのクラスには以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、 &lt;code&gt;value&lt;/code&gt; に関して少なくとも部分的に順序付けられている必要があります。つまり、次の要件をすべて満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、式 &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; または &lt;code&gt;!comp(value, element)&lt;/code&gt; に関して分割する必要があります。つまり、式が &lt;code&gt;true&lt;/code&gt; であるすべての要素は、式が &lt;code&gt;false&lt;/code&gt; であるすべての要素の前になければなりません。。完全にソートされた範囲はこの基準を満たしています。</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、式の &lt;code&gt;element &amp;lt; value&lt;/code&gt; または &lt;code&gt;comp(element, value)&lt;/code&gt; に関して分割する必要があります。つまり、式が &lt;code&gt;true&lt;/code&gt; であるすべての要素は、式が &lt;code&gt;false&lt;/code&gt; であるすべての要素の前になければなりません。完全にソートされた範囲はこの基準を満たしています。</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">ranges ライブラリには、さまざまなビューアダプタを含む、要素の範囲を扱うためのコンポーネントが用意されています。</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">標準変換シーケンスのランクは、それが保持する標準変換のランクの中で最悪です（最大&lt;a href=&quot;implicit_cast&quot;&gt;3つの変換&lt;/a&gt;がある場合があります）。</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">生のポインタオーバーロードは、ポイントされたオブジェクトの所有権を想定しています。したがって、 &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; などによってすでに &lt;code&gt;shared_ptr&lt;/code&gt; によって管理されているオブジェクトの生のポインタオーバーロードを使用して &lt;code&gt;shared_ptr&lt;/code&gt; を構築すると、たとえオブジェクトが &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">再割り当てはどちらかで行います。</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">rebindメンバのテンプレートエイリアスは、Tを指すポインタのような型が与えられると、Uを指すのと同じポインタのような型を取得することを可能にします。</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">認識されるバイトオーダーマークは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">参照は、この &lt;code&gt;ios_base&lt;/code&gt; オブジェクトに対する操作 &lt;code&gt;iword()&lt;/code&gt; への別の呼び出しを含む）によって無効になる可能性がありますが、格納された値は保持されるため、後で同じインデックスを持つ &lt;code&gt;iword(index)&lt;/code&gt; から読み取ると、同じ値が生成されます（次の &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ）を呼び出します。値は任意の目的に使用できます。要素のインデックスは、 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; への以前の呼び出しで取得する必要があります。それ以外の場合の動作は未定義です。新しい要素はに初期化され &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参照は、この &lt;code&gt;ios_base&lt;/code&gt; オブジェクトに対する操作 &lt;code&gt;pword()&lt;/code&gt; への別の呼び出しを含む）によって無効になる可能性がありますが、格納された値は保持されるため、後で同じインデックスを持つ &lt;code&gt;pword(index)&lt;/code&gt; から読み取ると、同じ値が生成されます（次の &lt;code&gt;copyfmt()&lt;/code&gt; への呼び出し）。値は任意の目的に使用できます。要素のインデックスは &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; で取得する必要があります。そうでない場合、動作は未定義です。新しい要素は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に初期化されます。</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">参照されるビット。</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">正規表現イテレータは、シーケンス内で見つかった正規表現のマッチのセット全体を追跡するために使用されます。</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">正規表現ライブラリはこの特性を使用して、文字を等価クラスと照合します。例えば、正規表現 &lt;code&gt;[[=a=]]&lt;/code&gt; 文字に相当する &lt;code&gt;c1&lt;/code&gt; 場合 &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; と等価である &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; （いずれかのために真である &lt;code&gt;c1&lt;/code&gt; から &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; 米国で英語ロケール）。なお &lt;code&gt;transform_primary()&lt;/code&gt; 同値クラスは複数文字であってもよいのでなど、文字列引数を取る &lt;code&gt;[[=ch=]]&lt;/code&gt; チェコまたは &lt;code&gt;[[=dzs=]]&lt;/code&gt; ハンガリー語です。</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">regex traits クラスは、正規表現のローカライズ可能な側面をカプセル化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">登録された関数は、&lt;a href=&quot;exit&quot;&gt;プログラムの正常終了時&lt;/a&gt;に呼び出されません。その場合に関数を &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 必要がある場合は、std :: atexitを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">正規表現ライブラリは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正規表現&lt;/a&gt;を表すクラスを提供します。正規表現は、文字列内でパターンマッチングを実行するために使用される一種のミニ言語です。正規表現を使用したほとんどすべての操作は、次のオブジェクトのいくつかを操作することによって特徴付けることができます。</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">関連するPOSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt;は、 &lt;code&gt;command&lt;/code&gt; によって生成された出力を呼び出し元が利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="882b56e07684c56a82fb47ac99ca4f95e58df12c" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">関連するPOSIX関数&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt;は、 &lt;code&gt;command&lt;/code&gt; によって生成された出力を呼び出し元が利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">関連する関数 &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; は出力に改行文字を追加しますが、 &lt;code&gt;std::fputs&lt;/code&gt; は文字列を変更せずに書き込みます。</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">トップレベルの cv-qualifiers を削除しても,関数内で表示されるパラメータの型には影響しません.</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">&lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; ヘッダーが含まれていなくても、置き換え可能な割り当て解除関数（1〜10）は各変換単位で暗黙的に宣言されます。これらの機能は</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">指定された照合要素の文字列としての表現。</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C1::duration&lt;/code&gt; の表現タイプ。</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; となるような、要求されたサブスパン &lt;code&gt;r&lt;/code&gt; 。 &lt;code&gt;Count&lt;/code&gt; が &lt;code&gt;std::dynamic_extent&lt;/code&gt; 場合、 &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; それ以外の場合は &lt;code&gt;r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">要素に課される要件は、コンテナで実行される実際の操作によって異なります。一般に、要素タイプは完全なタイプであり、&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;の要件を満たす必要がありますが、多くのメンバー関数はより厳しい要件を課しています。</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">要素に課される要件は、コンテナで実行される実際の操作によって異なります。一般に、要素タイプは&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;の要件を満たす必要がありますが、多くのメンバー関数はより厳しい要件を課しています。アロケータが&lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;アロケータの完全性の要件を&lt;/a&gt;満たしている場合、このコンテナ（そのメンバーではない）は不完全な要素型でインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">結果は</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">式に次の潜在的に評価される構成の少なくとも1つが含まれている場合、結果は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">式の&lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;潜在的な例外&lt;/i&gt;&lt;/a&gt;のセットが空の場合、結果は &lt;code&gt;true&lt;/code&gt; になり、それ以外の場合は &lt;code&gt;false&lt;/code&gt; になります。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （算術オーバーフローなしで計算）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （算術オーバーフローなしで計算）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; （なしで計算算術オーバーフロー）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （計算なしで算術オーバーフロー）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">結果は &lt;code&gt;bool&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">結果は準備ができています</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">結果は、列挙型の基本型から宛先型への&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的な変換&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">結果は、元の値を最初に列挙の基になる型に&lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;変換し&lt;/a&gt;、次に列挙型に変換するのと同じです。</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; の大きさが大きい場合、結果にはほとんどまたはまったく意味がありません。</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; の結果は実装定義です。</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs != rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs % rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs * rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs + rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs - rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs / rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs ^ rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs | rhs&lt;/code&gt; の結果| rhs。</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs || rhs&lt;/code&gt; の結果|| rhs。</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">終了反復子の &lt;code&gt;operator*&lt;/code&gt; または &lt;code&gt;operator-&amp;gt;&lt;/code&gt; の結果は、未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; の結果は、空のクラス型に適用された場合でも、常にゼロ以外です。</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;~arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">ディレクトリのサイズを決定しようとした結果(通常のファイルやシンボリックリンクではない他のファイルも同様に)は、実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">ではない match_results オブジェクトのほとんどのメンバ関数を呼び出した結果。</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">2つのポインタをメンバに比較した結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">オブジェクトへの2つのポインタを比較した結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">符号なし整数に負の数の文字列を変換した結果は、いくつかの実装でのプロトコルに続いているが、++ 17 Cまでゼロを生成するために指定された &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; ターゲットタイプで否定、与え &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&quot;-1&quot;&lt;/code&gt; 、および代わりに、ターゲットタイプの最大値を生成します。C ++ 17 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; は、std :: strtoullに厳密に従うことが正しい動作です。</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">2つのポインタの均等比較の結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">operator〜の結果は、（昇格後の）引数のビット単位のNOT（1の補数）値です。 operator＆の結果は、オペランドのビットごとのAND値です（通常の算術変換後）。オペレーターの結果|オペランドのビット単位のOR値です（通常の算術変換後）。 operator ^の結果は、オペランドのビット単位のXOR値です（通常の算術変換後）。</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">パス連結の結果。</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">2つの &lt;code&gt;month&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::months&lt;/code&gt; です。その期間の単位はグレゴリオ暦の平均月の長さを表し、結果の期間は、オペランドによって表される特定の月の日数とは関係ありません。たとえば、 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; は、3月の秒数（ &lt;code&gt;2678400s&lt;/code&gt; ）ではなく、 &lt;code&gt;2629746s&lt;/code&gt; （30.436875日）です。</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">2つの &lt;code&gt;year&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::years&lt;/code&gt; 期間です。この期間単位はグレゴリオ暦の平均年の長さを表し、結果の期間は、オペランドで表される特定の年の日数とは関係ありません。たとえば、 &lt;code&gt;2018y - 2017y&lt;/code&gt; 結果は &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; であり、365日ではなく365.2425日を表します。</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">2つの &lt;code&gt;year_month&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::months&lt;/code&gt; です。この期間の単位は、平均グレゴリオ月（30.436875日）の長さを表し、結果の期間は、問題の期間の実際の日数とは関係ありません。例えば、結果 &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; 、2017年2月は28日しか含まれていても。</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">比較の結果： &lt;code&gt;*obj&lt;/code&gt; が &lt;code&gt;*expected&lt;/code&gt; と等しい場合は &lt;code&gt;true&lt;/code&gt; 、それ以外の場合は &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">上記のように変換した結果</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">以上のように決定された変換結果。</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">式の結果の型は常に &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">ジェネレーターによって生成された結果タイプ。これが &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、または &lt;code&gt;long double&lt;/code&gt; のいずれでもない場合の効果は未定義です。</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">ジェネレーターによって生成された結果タイプ。これが &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、または &lt;code&gt;unsigned long long&lt;/code&gt; のいずれでもない場合、効果は未定義です。</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">結果値は &lt;code&gt;T&lt;/code&gt; （1-3）または &lt;code&gt;bool&lt;/code&gt; （4）に明確に変換できます。</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">結果値は明確に &lt;code&gt;bool&lt;/code&gt; に変換できます。</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">結果のオフセットは、成功した場合は &lt;code&gt;pos_type&lt;/code&gt; に変換され、失敗した場合は &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">結果として得られる範囲は、どちらかの入力範囲と重なることはできません。</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">結果の範囲もソートされます。等価な要素がいくつかの要素が見つかった場合、すなわち、個別に処理される &lt;code&gt;m&lt;/code&gt; 個の時刻 &lt;code&gt;[first1, last1)&lt;/code&gt; および &lt;code&gt;n&lt;/code&gt; で時間を &lt;code&gt;[first2, last2)&lt;/code&gt; 、それにコピーされ &lt;code&gt;d_first&lt;/code&gt; 正確に &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; 回。結果の範囲は、いずれの入力範囲とも重複できません。</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">結果の文字列には &lt;code&gt;N&lt;/code&gt; 文字が含まれ、最初の文字は最後（ &lt;code&gt;N-1&lt;/code&gt; 番目）のビットに対応し、最後の文字は最初のビットに対応します。</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">円形にシフトされた要素を持つ結果の配列。</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">結果として得られる要素をシフトさせた値の配列。</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;func&lt;/code&gt; を適用して取得した値を含む結果のvalarray 。</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">結果の値（つまり、対応する2項演算子を &lt;code&gt;*this&lt;/code&gt; の&lt;a href=&quot;../memory_order#Modification_order&quot;&gt;変更順序&lt;/a&gt;で対応するメンバー関数の効果の直前の値に適用した結果）。</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">結果の値(つまり、対応するメンバ関数の効果の直前の値に対応する二進演算子を適用した結果)。</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">からの復帰は</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">捨て文のリターン文は、関数のリターン型控除には参加しません。</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">戻り値の型は、最も深く入れ子にされた引数型の上に2レベル以上のテンプレート入れ子を追加しません。</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; による任意のポインター型 &lt;code&gt;U*&lt;/code&gt; への変換をサポートするために、戻り値の型は（たとえば、 &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; *ではなく） &lt;code&gt;void*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">戻り値の型は、積分昇格後の左オペランドの型です。</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt;の戻り型</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が関数の場合、 &lt;code&gt;T&lt;/code&gt; の戻り型。それ以外の場合、定義されていません</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::begin&lt;/code&gt; の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::end&lt;/code&gt; の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iota_view::begin&lt;/code&gt; の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iota_view::end&lt;/code&gt; の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::bind&lt;/code&gt; の戻り型は、 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt;（f）から構築されたstd :: &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; メンバーオブジェクト、および &lt;code&gt;args...&lt;/code&gt; ごとに1つのオブジェクト型を保持します &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; &amp;lt;Arg_i&amp;gt; :: type、 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; &amp;lt;Arg_i&amp;gt;（arg_i）から同様に構築されます。</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">戻り型 &lt;code&gt;std::bind&lt;/code&gt; ある&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;コピーコンストラクト&lt;/a&gt;、そのメンバオブジェクトの全て（上記で特定）はコピーコンストラクトであり、ある場合&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;そうでありません。タイプは次のメンバーを定義します。</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; の戻り値の型は、コピー/移動コンストラクターがメンバーごとのコピー/移動を実行するかのように動作します。それは&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;コピーコンストラクト&lt;/a&gt;（上記で特定）は、そのメンバオブジェクトのすべてがコピーコンストラクトであり、ある場合&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;そうでありません。</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not_fn&lt;/code&gt; の戻り値の型は、型 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; メンバーオブジェクトを保持します。</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">条件演算子の戻り値の型は、バイナリ型の特性 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; としてもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">関数呼び出し式の戻り値の型は、選択された関数の戻り値の型であり、実際に呼び出されるオーバーライド関数が別の型を返す場合でも、静的バインディングを使用して決定されます（ &lt;code&gt;virtual&lt;/code&gt; キーワードは無視されます）。これにより、オーバーライド関数は、基本関数によって返される戻り値の型から派生したクラスへのポインターまたは参照を返すことができ&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;ます&lt;/a&gt;。つまり、C ++は共変戻り値型をサポートします。 &lt;code&gt;E&lt;/code&gt; がデストラクタを指定する場合、戻り値の型は &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">関数の戻り値の型は、関数型や配列型にすることはできません(ただし、それらへのポインタや参照は可能です)。</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">戻り値は、デフォルトで &lt;code&gt;std::cout&lt;/code&gt; 出力するものとは大幅に異なる場合があります。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">呼び出された関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">Compareを満たす型のオブジェクトに適用された関数呼び出し操作の戻り値は、&lt;a href=&quot;../language/implicit_cast&quot;&gt;コンテキストに応じ&lt;/a&gt;て &lt;code&gt;bool&lt;/code&gt; に変換され、呼び出しの最初の引数が2番目の引数の前にある場合に &lt;code&gt;true&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">返される配列はヌル終端である必要はありません。</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">返される配列はnullで終了します。つまり、 &lt;code&gt;data()&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; は同じ機能を実行します。</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">返されたオブジェクト(コール・ラッパー)は、以下のプロパティを持っています。</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">返されたオブジェクトは、 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt;（f）から構築されたstd :: &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; &amp;lt;F&amp;gt;タイプのメンバーオブジェクト &lt;code&gt;fd&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; （&lt;a href=&quot;../forward&quot;&gt;stdで&lt;/a&gt;構築された &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; オブジェクト &lt;code&gt;tup&lt;/code&gt; を保持するかのように動作します。:: forward &amp;lt; Args &amp;gt;（args）...）（これは &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; のラップを解除します）、ただし返されるオブジェクトの割り当て動作は指定されておらず、名前は説明のためだけです。</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">たとえば &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; が残っていて、制御ブロック全体が破棄されるまで実装が削除を破棄しない場合、返されたポインタは最後の &lt;code&gt;shared_ptr&lt;/code&gt; よりも長く存続する可能性があります。</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">返される範囲は2つのイテレータで定義され、1つは最初の要素である</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">返される文字列は、 &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; ように構築されます。これは、返される文字列のアロケータがデフォルトで構築されることを意味します&amp;mdash;新しいアロケータは</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">返された文字列はプログラムで変更してはいけませんが、その後の呼び出しで上書きされる可能性があります &lt;code&gt;strerror&lt;/code&gt; 関数。 &lt;code&gt;strerror&lt;/code&gt; はスレッドセーフである必要はありません。実装は、静的な読み取り専用文字列リテラルへの異なるポインターを返す場合と、strerrorが文字列を配置する静的バッファーを指す同じポインターを繰り返し返す場合があります。</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">戻り値は &lt;code&gt;x&lt;/code&gt; と同じ符号を持ち、大きさは &lt;code&gt;y&lt;/code&gt; 未満です。</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">戻り値は正確です（ &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; は発生しません）、現在の&lt;a href=&quot;../fenv/fe_round&quot;&gt;丸めモード&lt;/a&gt;とは無関係です。</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">戻り値は正確です。 &lt;a href=&quot;../fenv/fe_round&quot;&gt;、現在の丸めモード&lt;/a&gt;は無視されます</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">逆は必ずしも当てはまりません。異なるオブジェクト表現を持つ&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型の2つのオブジェクトが同じ値を表す場合があります。たとえば、複数の浮動小数点ビットパターンは同じ特別な値&lt;a href=&quot;../numeric/math/nan&quot;&gt;NaNを&lt;/a&gt;表します。より一般的には、オブジェクト表現の一部のビットが値の表現にまったく関与しない場合があります。そのようなビットは、&lt;a href=&quot;objects#Alignment&quot;&gt;アラインメント要件&lt;/a&gt;、&lt;a href=&quot;bit_field&quot;&gt;ビットフィールド&lt;/a&gt;サイズなどを満たすために導入されたパディングである可能性があります。</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">パスのルートディレクトリ。</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">パスのルート名。</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">パスのルートパスです。</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">丸めモードは &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 変更でき、 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; はその変更を反映します。</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">「より効率的な実装」に関するルールは、中間バッファリングなしでバルクI / Oを許可します。これにより、 &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; は、iostreamの一部の実装でポインタをPOSIX &lt;code&gt;read()&lt;/code&gt; システムコールに渡すだけです。</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">3/5/0のルール</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">安全なbool問題</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">I / O階層の次のクラス &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; のコンストラクターにも同じことが当てはまります。さらに派生したクラス（ &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; ）は常に具象streambufferオブジェクトで構築され、仮想ベースの初期化を完了するために、場合によっては複数回、&lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S(il.begin(), il.end())&lt;/code&gt; と同じ</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">同じ機能を複数回登録することができます。</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">この関数が呼ばれるたびに同じ値が返されます。</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">同じ単語がマクロとしてインクルードファイル &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; のCプログラミング言語で定義されています。C ++で、これらは言語に組み込まれているため、C ++のバージョン &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; は、何も定義されていません。</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">名前のない名前空間またはインライン名前空間で宣言されたエンティティのスコープには、囲む名前空間が含まれます。</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">条件で紹介された名前の範囲は、宣言であれば両ステートメントの本体の範囲を合わせたものになります。</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;choose&lt;/code&gt; を &lt;code&gt;std::chrono::time_zone&lt;/code&gt; および &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; 特定のメンバー関数に渡して、あいまいな、または存在しない現地時間を解決する方法を制御できます。 &lt;code&gt;choose::earliest&lt;/code&gt; を渡すと以前の時点が返され、 &lt;code&gt;choose::latest&lt;/code&gt; を渡すと遅い時点が返されます。（存在しない現地時間の場合、これらの2つの時点は同一です。）</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::cv_status&lt;/code&gt; は、タイムアウトが原因で時間待機が返されたかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::errc&lt;/code&gt; は、POSIXエラーコードに対応する移植可能なエラー条件の値を定義します。</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::future_errc&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; および関連クラスが &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 例外オブジェクトで報告するエラーコードを定義します。実装では追加のエラーコードが定義される場合がありますが、必要なエラーコードは4つだけです。 &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; の適切な特殊化が提供されているため、タイプ &lt;code&gt;std::future_errc&lt;/code&gt; 値は暗黙的に &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 変換できます。</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::io_errc&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 例外オブジェクトのI / Oストリームによって報告されるエラーコードを定義します。実装では追加のエラーコードが定義される場合がありますが、必要なエラーコードは1つ（ &lt;code&gt;std::io_errc::stream&lt;/code&gt; ）だけです。 &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; の適切な特殊化が提供されているため、タイプ &lt;code&gt;std::io_errc&lt;/code&gt; 値は暗黙的に &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 変換できます。</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">スコープ付き列挙型 &lt;code&gt;pointer_safety&lt;/code&gt; は、C ++でサポートされるポインターセーフモードをリストします。</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">両方の演算子の第2オペランドが（正式名である&lt;a href=&quot;name#In_expressions&quot;&gt;ID-発現&lt;/a&gt;名こと）のデータメンバーまたはメンバー関数 &lt;code&gt;T&lt;/code&gt; または明白とアクセス基底クラスの &lt;code&gt;B&lt;/code&gt; の &lt;code&gt;T&lt;/code&gt; （例えば &lt;code&gt;E1.E2&lt;/code&gt; または &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ） 、オプションで&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;修飾&lt;/a&gt;（例： &lt;code&gt;E1.B::E2&lt;/code&gt; または &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; ）、オプションで&lt;a href=&quot;dependent_name&quot;&gt;テンプレートの&lt;/a&gt; &lt;code&gt;E1.template E2&lt;/code&gt; さを使用（例：E1.template E2または &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">両方のオペレータの第二オペランド部材（TO型ポインタの表現である&lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;データ&lt;/a&gt;又は&lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;機能&lt;/a&gt;）の &lt;code&gt;T&lt;/code&gt; 明白とアクセス可能な基底クラスのメンバーまたはポインタ &lt;code&gt;B&lt;/code&gt; の &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">2 番目のオーバーロードには、引数の先頭のための別のテンプレートパラメータとパラメータパックが含まれています。</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コールバックの2番目のパスを使用して、 &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; 内のポインターが指すユーザー定義オブジェクトをディープコピーできます。</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">2番目のシグニチャーは、 &lt;code&gt;opts&lt;/code&gt; を &lt;code&gt;perm_options::replace&lt;/code&gt; 設定して呼び出されたかのように動作します。</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">選択された要素が存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">継承コンストラクターのセマンティクスは&lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;、C ++ 11に対する欠陥レポート&lt;/a&gt;によって遡及的に変更されました。以前は、継承コンストラクター宣言により、一連の合成コンストラクター宣言が派生クラスに挿入され、冗長な引数のコピー/移動が発生し、SFINAEの一部の形式との相互作用に問題があり、主要なABIに実装できない場合がありました。古いコンパイラは、以前のセマンティクスをまだ実装している場合があります。</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">メンバー関数のセマンティクスは以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数のセマンティクスは、C関数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt;との一貫性を保つことを目的としています。</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数のセマンティクスは、C関数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt;と一致することを目的としています。</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">この対のイテレータで示されるシーケンスは、以下のように構成されている。</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">ステージ2で蓄積された &lt;code&gt;char&lt;/code&gt; のシーケンスは数値に変換されます</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">同じ &lt;code&gt;g&lt;/code&gt; を使用したこの呼び出しの連続した呼び出しによって返される一連の番号は、 &lt;code&gt;d.param()&lt;/code&gt; によってパラメーター化された分布に従ってランダムに分布されます。</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">同じ &lt;code&gt;g&lt;/code&gt; を使用したこの呼び出しの連続した呼び出しによって返される一連の数値は、 &lt;code&gt;p&lt;/code&gt; によってパラメーター化された分布に従ってランダムに分布されます。</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">候補となる関数のセットと引数のリストは、オーバーロード解決が使用されるコンテキストごとに独自の方法で用意されています。</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">オーバーロードの解決のために送信される候補関数のセットは、上記のセットの和集合です。オーバーロードの解決を目的とした引数リストは、 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; を除く演算子のオペランドで構成されています。2番目のオペランドは関数呼び出しの引数ではありません（&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;メンバーアクセス演算子を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">通常の&lt;a href=&quot;lookup&quot;&gt;非修飾ルックアップ&lt;/a&gt;によって検出された宣言のセットと、ADLによって生成された関連セットのすべての要素で検出された宣言のセットは、次の特別なルールでマージされます。</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">区間境界の集合 b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">baseの有効な値のセットは{0,2,3、...、36}です。基数2の整数の有効な数字のセットは &lt;code&gt;{0,1&lt;/code&gt; }、基数3の整数は &lt;code&gt;{0,1,2&lt;/code&gt; }のようになります。 &lt;code&gt;10&lt;/code&gt; より大きいベースの場合、有効な数字には &lt;code&gt;Aa&lt;/code&gt; から始まるアルファベット文字が含まれます基数の 11整数の 36整数の &lt;code&gt;Zz&lt;/code&gt; 。文字の大文字と小文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共有状態には既に値または例外が格納されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; に&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共有状態は、 &lt;code&gt;get_future&lt;/code&gt; の呼び出しによってすでに取得されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; に&lt;/a&gt;設定されます。</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">共有状態は、現在のスレッドが終了して</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短絡のインスタンス化は、 &lt;code&gt;conjunction&lt;/code&gt; を折り畳み式と区別します： &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; ような折り畳み式は、 &lt;code&gt;Bs&lt;/code&gt; 内のすべての &lt;code&gt;B&lt;/code&gt; をインスタンス化しますが、 &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; は、値が決定されるとインスタンス化を停止します。これは、後者のタイプのインスタンス化にコストがかかる場合、または間違ったタイプでインスタンス化するとハードエラーが発生する可能性がある場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短絡インスタンス化は、 &lt;code&gt;disjunction&lt;/code&gt; をフォールド式と区別します： &lt;code&gt;(... || Bs::value)&lt;/code&gt; ようなフォールド式は &lt;code&gt;Bs&lt;/code&gt; 内のすべての &lt;code&gt;B&lt;/code&gt; をインスタンス化しますが、 &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; は、値が可能になるとインスタンス化を停止します決定。これは、後者のタイプのインスタンス化にコストがかかる場合、または間違ったタイプでインスタンス化するとハードエラーが発生する可能性がある場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">スカラーM(書き込み)に対する副作用Aは</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">結果の符号は、最初のバイトのペアの値の差の符号です（両方とも解釈されます） &lt;code&gt;unsigned char&lt;/code&gt; 比較されるオブジェクトが異なる unsigned char）符号です。</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">結果の符号は、最初の文字のペアの値の差の符号です（どちらも次のように解釈されます） &lt;code&gt;unsigned char&lt;/code&gt; 比較される文字列が異なる unsigned char）符号です。</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">結果の符号は、比較される配列の中で異なる幅広文字の最初のペアの値の間の差の符号である。</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">結果の符号は、比較される文字列の中で異なる最初のワイド文字のペアの値の差の符号である。</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">署名に &lt;code&gt;const &amp;amp;&lt;/code&gt; を含める必要はありません。</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">比較関数のシグネチャは、次のようなものに相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">関数のシグネチャは以下に相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">述語関数のシグネチャは、次のようなものに相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">同様の名前のコンテナーメンバー関数&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt;は、削除された要素を消去します。</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">サインは複素平面上の関数全体であり、枝切りを持たない。サインの数学的定義は、sin z =</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">との整合性が取れていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">大きさ &lt;code&gt;A&lt;/code&gt; の状態の大きさ以上である &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; のサイズ。</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">任意のサイズ&lt;a href=&quot;objects&quot;&gt;のオブジェクト&lt;/a&gt;またはメンバーのサブオブジェクト（ない限り &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -下記参照）（++ 20 C以降）は、タイプが空である場合でも、少なくとも1であることが要求される&lt;a href=&quot;class&quot;&gt;クラスタイプ&lt;/a&gt;（あるクラスまたは同じタイプの異なるオブジェクトのアドレスが常に異なることを保証できるようにするために、非静的データメンバーを持たない構造体）。</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">ファイルのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">工事時に投入された民間コンテナの大きさ。</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">プッシュバックバッファのサイズは、実際には 4k (Linux,MacOS)から 4 (Solaris)まで、あるいは保証された最低 1 (HPUX,AIX)まで様々です。</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">参照先のファイルシステムオブジェクトのサイズ。</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">シーケンスの &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; バイト単位）、つまり、size（）* sizeof（element_type）。</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">演算子のサイズは</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">最小 &lt;code&gt;q&lt;/code&gt; における &lt;code&gt;[p,p+n)&lt;/code&gt; なるように &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; 真であります</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 以上の最小の2のべき乗、または結果が &lt;code&gt;T&lt;/code&gt; で表現できない場合は未指定の値。</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">ソケットが接続されていない</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">最大マンチルールの唯一の例外は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">メッセージのソースは実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">スパンは静的な範囲（つまり &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ）でなければならず、 &lt;code&gt;I&lt;/code&gt; は &lt;code&gt;[0, N)&lt;/code&gt; 範囲の整数値でなければなりません。これは、 &lt;code&gt;operator[]&lt;/code&gt; ではなく、コンパイル時に適用されます。</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">特別なパス名のドット（ &lt;code&gt;&quot;.&quot;&lt;/code&gt; ）は、その親ディレクトリへのハードリンクです。特別なパス名のドットドット &lt;code&gt;&quot;..&quot;&lt;/code&gt; は、その親の親であるディレクトリへのハードリンクです。</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">特殊なパス名のdotとdot-dotはスキップされます。</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">サイズゼロの特別な無名ビットフィールドは、パディングを強制的に分割することができる。これは、次のビットフィールドがその割り当て単位の先頭から始まることを指定する。</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">特殊化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;に&lt;/a&gt;は、C ++ 14まで &lt;code&gt;emplace()&lt;/code&gt; メンバーがありませんでした。</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">特殊化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;に&lt;/a&gt;は、C ++ 14まで &lt;code&gt;emplace_back()&lt;/code&gt; メンバーがありませんでした。</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">特殊化 &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; は、公開された明確なベースがあります。</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">特殊化 &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; は、明確で明確な基盤があります。</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">特殊化 &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; は、 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; が有効な場合は有効になり（ &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）、それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; が有効になっている場合、特殊化 &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; が有効になります（ &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）。それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; すべての特殊化が有効な場合、特殊化 &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; が有効になります（ &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）。それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">専門は &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; 、 &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; 、および &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; です&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt;表現し、操作するための&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;複素数が&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">リリースと消費の順序の仕様は改訂中であり、 &lt;code&gt;memory_order_consume&lt;/code&gt; の使用は一時的に推奨されていません。</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">指定された非タイプ引数は、対応する非タイプテンプレートパラメータのタイプと一致するか、それらに&lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;変換可能で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">指定されたテンプレート引数は、種類的にはテンプレートパラメータと一致していなければなりません(すなわち、typeの場合はtype、nontypeの場合はnontype、templateの場合はtemplate)。パラメータの数よりも多くの引数を持つことはできません(1つのパラメータがパラメータパックでない限り、その場合はパックではないパラメータごとに引数を持たなければなりません)。</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">標準の32ビットIEEE 754浮動小数点型には24ビットの小数部（23ビットが書き込まれ、1つが暗示される）があるため、7桁の10進数を表すことができる（ &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; は7.22）、ただし、相対的な丸め誤差は不均一であり、7桁の10進数字を含む一部の浮動小数点値は32ビット浮動小数点への変換と &lt;code&gt;8.589974e9&lt;/code&gt; 以降の変換を存続させません。最小の正の例は &lt;code&gt;8.589973e9&lt;/code&gt; であり、これはラウンドトリップ後に8.589974e9になります。これらの丸め誤差は表現で1ビットを超えることはできず、 &lt;code&gt;digits10&lt;/code&gt; は &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; として計算されます。これは6.92です。切り捨てると、値は6になります。</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準のCストリームは、 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準C ++のストリームは、次のとおりです。 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。デフォルトでは、特定のスタッククラスのインスタンス化にコンテナクラスが指定されていない場合、標準のコンテナ &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">この規格は、C ++ 11以降で導入されたC ++言語およびライブラリ機能に対応する一連の&lt;a href=&quot;preprocessor/replace&quot;&gt;プリプロセッサマクロを&lt;/a&gt;定義しています。それらは、前述の機能の存在を検出するためのシンプルでポータブルな方法として意図されています。</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">標準では、I / Oが行われる前に呼び出される &lt;code&gt;setbuf(0, 0)&lt;/code&gt; バッファリングされていない出力を設定する必要があることを除いて、この関数の動作を定義していません。</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">標準では、メインスレッドと &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; によって開始されたスレッドが同時進行を保証することを推奨していますが、これは必須ではありません。</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準エラー条件 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; は、通常、入力ではなく結果が範囲外であり、 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; に密接に関連している条件を示します。</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">標準自体は優先順位のレベルを指定していません。それらは文法から派生したものです。</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリは、関数テンプレート&lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;も定義し、イテレータのペアと値を取得します。このオーバーロードは、標準&lt;a href=&quot;../../algorithm&quot;&gt;アルゴリズムの&lt;/a&gt; 1つです。</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリは、ファイルの削除に使用される &lt;code&gt;std::remove&lt;/code&gt; 取得 &lt;code&gt;const char*&lt;/code&gt; オーバーロードも定義しています：&lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準ライブラリには、事前定義された&lt;a href=&quot;../utility/functional&quot;&gt;関数オブジェクトテンプレート&lt;/a&gt;と、新しいテンプレートを作成するためのメソッド（ &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ）も用意されています。</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">標準ライブラリコンポーネント &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; 使用すると、コンパイル時に評価される条件に基づいて特定のオーバーロードを有効または無効にするために、置換の失敗を作成できます。</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">標準ライブラリコンポーネント &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; は、SFINAEアプリケーションを簡略化するもう1つのユーティリティメタ関数です。</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているドメインエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::domain_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="4dffee91fae753bda05b684cabb9727f41e1ecf3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたドメインエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::domain_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているアンダーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::underflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="5163045812559a0cfa0dfff651b770d63211f5c3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているようにアンダーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::underflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリは、2つの重要な待機可能変数 &lt;code&gt;std::suspend_always&lt;/code&gt; と &lt;code&gt;std::suspend_never&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">nothrowバージョン(5-8)の標準ライブラリ実装は、対応するthrowingバージョン(1-4)を直接呼び出します。投げ配列バージョン(2,4)の標準ライブラリ実装は、対応する単一オブジェクトバージョン(1,3)を直接呼び出す。このように、すべての割り当てを処理するためには、throwing単一オブジェクト割り当て関数を置き換えるだけで十分です。</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">nothrowバージョン(9,10)の標準ライブラリ実装は、対応するthrowingバージョン(1,2)を直接呼び出します。サイズを考慮した解放関数(5-8)の標準ライブラリ実装は,対応するサイズを考慮しない解放関数(1-4)を直接呼び出す.サイズを考慮しない配列フォーム(2,4)の標準ライブラリ実装は、対応する単一オブジェクトフォーム(1,3)を直接呼び出します。</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">演算子の削除の標準ライブラリ配置形式（13、14）は置き換えることができず、配置のnew-expressionが &lt;code&gt;::new&lt;/code&gt; 構文を使用しなかった場合にのみカスタマイズできます。一致する署名： &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; または &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;std::bit_and&lt;/code&gt; 特殊化を提供します &lt;code&gt;T&lt;/code&gt; が指定されていない場合、パラメータの型と戻り値の型は推定されたままになります。</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_not&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_or&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_xor&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::divides&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::equal_to&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::greater&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::greater_equal&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::less&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::less_equal&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;std::logical_and&lt;/code&gt; 特殊化を提供します &lt;code&gt;T&lt;/code&gt; が指定されていない場合は、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::logical_not&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::logical_or&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::minus&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::modulus&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::multiplies&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::negate&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::not_equal_to&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が指定されていない場合、標準ライブラリは &lt;code&gt;std::owner_less&lt;/code&gt; 特殊化を提供します。この場合、パラメーターの型は引数から推定されます（それぞれの引数は &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; でなければなりません）。</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::plus&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">標準ライブラリは、タイプ &lt;code&gt;bool&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; 特殊化を提供します。これは、スペース効率のために最適化される場合があります。</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">標準ライブラリは、返される値を取得したり、非同期タスク(別のスレッドで起動された関数など)によってスローされる例外をキャッチしたりする機能を提供しています。これらの値は</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">標準ライブラリは、次のタイプの &lt;code&gt;std::atomic&lt;/code&gt; テンプレートを部分的に特殊化し、プライマリテンプレートにはない追加のプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリは、すべてのポインタ型に対して &lt;code&gt;std::atomic_ref&lt;/code&gt; テンプレートの部分的な特殊化を提供します。すべてのアトミック型に提供される演算に加えて、これらの特殊化は、&lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;などのポインター型に適したアトミック算術演算をさらにサポートします。</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">標準ライブラリには、以下のようなサーチャーが用意されています。</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">算術型の別名である標準ライブラリ型（ &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; ）も、 &lt;code&gt;std::numeric_limits&lt;/code&gt; 型の特性で調べることができます。</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリの、割り当てられていない演算子new（9-10）の配置形式は置換できず、配置new-expressionが &lt;code&gt;::new&lt;/code&gt; 構文を使用していない場合にのみ、クラス固有の配置new（19、 20）署名が一致する場合： &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; または &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">標準出力オブジェクト &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; は、デフォルトで &lt;code&gt;unitbuf&lt;/code&gt; ビットが設定されています。</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">標準では、持続時間を測定するために&lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt;を使用することを推奨しています。実装が代わりに&lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; &lt;/a&gt;を使用する場合、待機時間もクロック調整の影響を受けやすい場合があります。</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">標準規格では、継続時間を測定するために定常クロックを使用することを推奨しています。実装が代わりにシステムクロックを使用する場合、待ち時間はクロックの調整に敏感になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">標準の符号付き整数型： &lt;code&gt;signed char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、および &lt;code&gt;long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; の標準的な特殊化は、パターン &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt; 返します</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">標準の符号なし整数型： &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、および &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">すべての書き込み可能なためのgetエリアの開始、 &lt;code&gt;std::strstreambuf&lt;/code&gt; が提供するインタフェースを介して構築されたオブジェクト &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 、またプット領域の開始です。</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">開始ディレクトリの深さは0、サブディレクトリの深さは1などです。</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">状態 &lt;code&gt;A&lt;/code&gt; は状態含み、 &lt;code&gt;B&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">&lt;code&gt;if constexpr&lt;/code&gt; がとして知られている場合に始まるステートメント</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">分子と分母を表す静的データメンバー &lt;code&gt;nom&lt;/code&gt; と &lt;code&gt;den&lt;/code&gt; は、 &lt;code&gt;Num&lt;/code&gt; と &lt;code&gt;Denom&lt;/code&gt; をそれらの最大公約数で割ることによって計算されます。ただし、 &lt;code&gt;Num&lt;/code&gt; または &lt;code&gt;Denom&lt;/code&gt; が異なる2つの &lt;code&gt;std::ratio&lt;/code&gt; は、同じ有理数（縮小後）を表す場合でも、異なる型です。 &lt;code&gt;ratio&lt;/code&gt; タイプは、その介し最低条件に低減することができる &lt;code&gt;type&lt;/code&gt; メンバー： &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; ある &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">エントリで参照されたファイルの状態。</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">保留中の再帰フラグのステータスは、この呼び出しの後に &lt;code&gt;false&lt;/code&gt; である&lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt;で照会できます。&lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt;後に &lt;code&gt;true&lt;/code&gt; にリセットされ、その初期値も &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">パスによって識別されるファイル名のステム (すなわち、最終的な拡張子のないファイル名)。</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">ストレージクラス指定子は、名前の&lt;a href=&quot;declarations&quot;&gt;宣言構文&lt;/a&gt;のdecl-specifier-seqの一部です。名前の&lt;a href=&quot;scope&quot;&gt;スコープ&lt;/a&gt;とともに、名前の2つの独立したプロパティを制御します。</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">デックのストレージは、必要に応じて自動的に拡張および縮小されます。両端キューの拡張は、既存の要素を新しいメモリ位置にコピーする必要がないため、 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 拡張よりも安価です。一方、dequeは通常、最小のメモリコストが大きくなります。 1つの要素のみを保持する両端キューは、その完全な内部配列を割り当てる必要があります（たとえば、64ビットlibstdc ++ではオブジェクトサイズの8倍、64ビットlibc ++ではオブジェクトサイズの16倍または4096バイトのいずれか大きい方）。</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">ベクトルの保存は自動的に処理され、必要に応じて拡大および縮小されます。将来の成長に対応するためにより多くのメモリが割り当てられるため、ベクトルは通常、静的配列よりも多くのスペースを占有します。このように、要素が挿入されるたびにベクターが再割り当てを行う必要はありませんが、追加のメモリが使い果たされた場合のみです。割り当てられたメモリの総量は、 &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 関数を使用して照会できます。追加のメモリは、 &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; への呼び出しを介してシステムに返すことができます（C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">保存された呼び出し可能なオブジェクトは</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">保存されているdeleterオブジェクト。</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">保存されている期間。</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">保存されているエラーカテゴリ。</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">保存されているエラーコード。</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">保存されているポインタ。</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">保存されている参照。</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">保存されたタスクはすでに呼び出されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; に&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">保存されたタスクはすでに呼び出されています。エラーカテゴリは &lt;code&gt;promise_already_satisfied&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">ストリームベースのI / Oライブラリは、&lt;a href=&quot;io/manip&quot;&gt;I / Oマニピュレーター&lt;/a&gt;（例： &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; など）を使用して、ストリームの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">ストリームベースの入出力ライブラリは、抽象的な入出力デバイスを中心に構成されています。これらの抽象デバイスにより、同じコードでファイル、メモリストリーム、または任意の操作 (圧縮など)をオンザフライで実行するカスタムアダプタデバイスへの入力/出力を処理することができます。</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">streambuf引数がnullポインターの場合、または文字がstreambufに挿入されなかった場合、&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;のstreambufオーバーロード。</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">関数が文字を挿入しない場合、&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;のstreambufオーバーロード。</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">指定された浮動小数点型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">指定された符号付き整数型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">指定された符号なし整数型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">文字列入力関数 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; は、指定された終了文字に到達するのではなく、ストリームの最後に到達することによって完了する場合。</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">文字列ライブラリは、 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; （C ++ 17以降）の型と関数を定義するクラステンプレート &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; も提供します。以下の特殊化が定義されています。</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">文字列リテラル。</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">正または負の符号として使用される文字を保持するタイプ &lt;code&gt;string_type&lt;/code&gt; の文字列。</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">元の文字列を照合する代わりに、変換された文字列の辞書式比較を使用できるように変換された文字列。「C」ロケールでは、返される文字列は &lt;code&gt;[low, high)&lt;/code&gt; 正確なコピーです。他のロケールでは、返される文字列の内容は実装定義であり、サイズはかなり長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">string_literal は通常、アセンブリ言語で書かれた短いプログラムで、この宣言が実行されるたびに実行されます。異なる C++コンパイラは、asm 宣言のルールを大きく変えており、周囲の C++コードとの相互作用についても異なる規約を持っています。</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">string_viewリテラル。</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">この構造体は、C スタイルの配列のパフォーマンスとアクセス性を、独自のサイズの把握、代入のサポート、ランダムアクセスイテレータなどの標準コンテナの利点と組み合わせたものです。</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">添え字演算子式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">テンプレート化された&lt;a href=&quot;templates#Templated_entity&quot;&gt;エンティティの&lt;/a&gt;宣言で使用されるrequire-expressionにテンプレート引数を代入すると、その要件に無効なタイプまたは式が形成されたり、それらの要件のセマンティック制約に違反したりする可能性があります。このような場合、requires-expressionは &lt;code&gt;false&lt;/code&gt; と評価され、プログラムが不正な形式になることはありません。置換と意味的制約のチェックは字句順に行われ、requires-expressionの結果を決定する条件が検出されると停止します。置換（存在する場合）およびセマンティック制約チェックが成功した場合、requires-expressionは &lt;code&gt;true&lt;/code&gt; と評価されます。</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">要素の合計。</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">戻り値と &lt;code&gt;*iptr&lt;/code&gt; に格納された値の合計により、 &lt;code&gt;x&lt;/code&gt; が得られます（丸めが可能）。</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">提供されたロック &lt;code&gt;lk&lt;/code&gt; は、スレッドが終了するまで保持されます。この関数が呼び出されると、 &lt;code&gt;cond&lt;/code&gt; を待機するために同じロックを取得するスレッドはなくなります。一部のスレッドがこの条件変数で待機している場合、誤って起動したときにロックを解放して再取得しようとすべきではありません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
