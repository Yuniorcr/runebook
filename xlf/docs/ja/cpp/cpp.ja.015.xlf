<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">ハードウェアは、オブジェクトによって参照されることを必要とすることが &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; HAVE厳しいアライメント以外の &lt;code&gt;T&lt;/code&gt; のオブジェクトとの操作かどうかを &lt;code&gt;atomic_ref&lt;/code&gt; がロックフリー参照オブジェクトの位置合わせに依存する可能性があります。</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">すべての非静的データメンバとビットフィールドが同じクラスで宣言されている (すべての派生クラスまたはすべてのベースクラスで宣言されている)</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">最初の非静的データメンバーと同じ型の基本クラスがない（&lt;a href=&quot;../language/ebo&quot;&gt;空の基本最適化を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">参照型の非静的データメンバを持たない</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">同じ型の基底クラスサブオブジェクトが 2 つもない (間接的な可能性がある)</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">仮想関数や仮想基底クラスを持たない</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;../language/default_constructor&quot;&gt;デフォルトコンストラクターがあり&lt;/a&gt;、それらはすべて&lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;自明&lt;/a&gt;または削除されており、少なくとも1つは削除されていません。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">ハッシュ関数は、プログラムの一回の実行内で、同じ入力に対して同じ結果を生成する必要があるだけです。これにより、衝突によるサービス拒否攻撃を防ぐ塩漬けハッシュが可能になります。</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">ハッシュ関数は例外を投げるべきではありません。</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">ハッシュポリシー</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">ハッシュサポート</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">ヘッダー名の前処理トークンは、 &lt;code&gt;#include&lt;/code&gt; ディレクティブ内でのみ形成されます。</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">に必要なヘッダ</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">ヒープの割り当て</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">ヒープ操作</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">ヘルパークラス</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">ヘルパークラス</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">ヘルパーの概念</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">ヘルパー関数 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;std::reference_wrapper&lt;/code&gt; オブジェクトの生成によく使用されます。</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">入出力のフォーマットを制御するヘルパー機能</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">ヘルパーオブジェクト</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">ヘルパーテンプレート</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">ヘルパーテンプレートのエイリアス</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">ヘルパーテンプレート</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">ヘルパーの種類</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">ヘルパー変数テンプレート</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">ヘルパー変数のテンプレート</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">ここで、&amp;mu;は&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;平均値&lt;/a&gt;、&amp;sigma;は&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;標準偏差&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">ここで、sequence &lt;code&gt;= 0&lt;/code&gt; は純粋指定子と呼ばれ、宣言子の直後またはオプションのvirt-specifier（&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt;または&lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;）の後に表示されます。</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">ここで、&lt;b&gt;挿入&lt;/b&gt;とはコンテナに1つ以上の要素を追加するメソッドを指し、&lt;b&gt;消去&lt;/b&gt;とはコンテナから1つ以上の要素を削除するメソッドを指します。</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">エルミート多項式</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">16進数のエスケープシーケンスには長さの制限がなく、有効な16進数ではない最初の文字で終了します。単一の16進エスケープシーケンスによって表される値が、この文字列リテラルで使用される文字タイプ（ &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;char16_t&lt;/code&gt; 、 &lt;code&gt;char32_t&lt;/code&gt; 、または &lt;code&gt;wchar_t&lt;/code&gt; ）によって表される値の範囲に適合しない場合、結果は不定です。</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">16進数浮動小数点リテラル</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">16進浮動小数点フォーマットでは、 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 仕様で要求されているように、ストリーム精度の指定は無視されます。</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">上位レベルのメモリ管理ユーティリティ</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">C++の歴史</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">ホストにアクセスできない</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">時、分、秒</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">ただし、 &lt;code&gt;ForwardIt1&lt;/code&gt; および &lt;code&gt;ForwardIt2&lt;/code&gt; が&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;および &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; の要件を満たしている場合、述語の適用は行われません。</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">ただし、すべてのC ++コンパイラは&lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;2の補数&lt;/a&gt;表現を使用します。C++ 20以降、これは規格で許可されている唯一の表現であり、保証範囲は-2N-1です。</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">しかし、基底クラスのサブオブジェクトはそれほど制約を受けず、オブジェクトのレイアウトから完全に最適化することができます。</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">ただし、非&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorsの&lt;/a&gt;場合、イテレーターの増分数はO（N）です。</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;BidirIt&lt;/code&gt; は別途の要件を満たし&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorを&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt1&lt;/code&gt; と &lt;code&gt;InputIt2&lt;/code&gt; が&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;および &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; の要件を満たしている場合、述語の適用は行われません（サイズの不一致は、要素を見ずに検出されます）。</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt&lt;/code&gt; は別途の要件を満たし&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorを&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt&lt;/code&gt; または &lt;code&gt;ForwardIt&lt;/code&gt; がさらにLegacyRandomAccessIteratorの要件を満たしている&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;場合&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">ただし、テンプレート引数の推定に参加するすべてのパラメーターの推定が成功し、推定されないすべてのテンプレート引数が明示的に指定またはデフォルト設定されている場合、残りの関数パラメーターが対応する関数引数と比較されます。明示的に指定されたテンプレート引数を置き換える前に非依存であったタイプの残りの各パラメーター &lt;code&gt;P&lt;/code&gt; について、対応する引数 &lt;code&gt;A&lt;/code&gt; を暗黙的に &lt;code&gt;P&lt;/code&gt; に変換できない場合、演繹は失敗します。</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">ただし、宣言で&lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt;（C ++ 17以降）指定子を使用する場合、メンバーは完全な型を持つように宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">しかし、一の実装（libcのは++）を構築することが知られて &lt;code&gt;key_type&lt;/code&gt; と &lt;code&gt;mapped_type&lt;/code&gt; 二つの別々のアロケータを介してオブジェクトを &lt;code&gt;construct()&lt;/code&gt; 公開されている間違いなくむしろ据え付けるよりも、規格によって要求されるように、コール &lt;code&gt;value_type&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">しかし、(上記の構文では)宣言子の後に現れる属性は、関数自体ではなく、関数の型に適用されます。</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲線余弦は複素平面内の関数全体であり、分岐カットはありません。虚数成分に対して周期的であり、周期は2&amp;pi;iです。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲関数</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲線正弦は複素平面内の関数全体であり、分岐カットはありません。虚数成分に対して周期的であり、周期は2&amp;pi;iです。</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">双曲線正接は、複雑な平野上の分析関数であり、分岐カットはありません。これは、虚数成分に対して周期的であり、周期は&amp;pi;iであり、座標（0、&amp;pi;（1/2 + n））に虚数線に沿って1次の極を持っています。ただし、一般的な浮動小数点表現では&amp;pi;/ 2を正確に表現できないため、極エラーが発生する引数の値はありません。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">I/O マニピュレータ</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">入出力エラー</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">I/Oフォーマットフラグは</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C/C++インラインアセンブリ</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559では、 &lt;code&gt;from==to&lt;/code&gt; は常にfromを返すこと &lt;code&gt;from&lt;/code&gt; 推奨しています。これらの関数 &lt;code&gt;to&lt;/code&gt; 代わりにに戻り、ゼロ周辺の動作を一貫させます &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; は &lt;code&gt;+0.0&lt;/code&gt; を返し、 &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; は &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">インバーテッドアンダータイ</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE &amp;lt;R&amp;gt;（f、t1、t2、...、tN）</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112 は、POSIX 制御キ ャ ラ ク タ を Unicode キ ャ ラ ク タ U+0000...U+001F、U+007F...U+009F、U+2028、U+2029 (Unicode クラス Cc、Zl、Zp)と定義しています。</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112は、POSIXスペースキ ャ ラ ク タ を Unicode キ ャ ラ ク タ U+0009...U+000D、U+0020、U+1680、U+180E、U+2000...U+2006、U+2008...U+200A、U+2028、U+2029、U+205F、および U+3000 と定義しています。</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 週ベースの年</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">ISO C 言語標準では、C コンパイラは以下の 3 つのプラグマをサポートすることが要求されており、いくつかの C++コンパイラベンダは C++フロントエンドで程度の差こそあれ、これらをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Container::emplace_back&lt;/code&gt; 複雑さと同じです。</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">識別子の削除</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">&amp;nu;&amp;gt; = 128の場合、動作は実装定義です</target>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="translated">再割り当てが行われた場合 (かつ行われた場合のみ)、すべてのポインタ、参照、およびイテレータは無効になります。</target>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt;がサポートされており、 &lt;code&gt;ON&lt;/code&gt; に設定されている場合、すべての浮動小数点算術演算子は現在の浮動小数点&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;丸め方向&lt;/a&gt;に従い、&lt;a href=&quot;initialization#Non-local_variables&quot;&gt;静的初期化子の&lt;/a&gt;一部でない限り、&lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; で&lt;/a&gt;指定された浮動小数点算術エラーを報告します（この場合、浮動小数点例外は発生せず、丸めモードは最も近いものになります）。</target>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="translated">場合&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期&lt;/a&gt;クラスタイプのオブジェクトのは、その必要と&lt;a href=&quot;cast_operator&quot;&gt;ユーザ定義の変換関数は、&lt;/a&gt;型のCVの初期化表現に変換するために呼び出される &lt;code&gt;S&lt;/code&gt; を型のCVに &lt;code&gt;T&lt;/code&gt; 初期化される対象物の、以下の機能は、候補関数です。</target>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="translated">場合は&lt;a href=&quot;goto&quot;&gt;後藤が&lt;/a&gt;トライブロックを終了するために使用されて実行されているブロックスコープの自動変数のデストラクタのいずれかの場合には &lt;code&gt;goto&lt;/code&gt; スロー例外は、これらの例外は、変数が定義されているのtryブロックでキャッチされています。</target>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="translated">場合&lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exceptionが&lt;/a&gt;真で、何もしません。それ以外の場合は、現在含まれている値を破棄します。</target>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!m.ok()&lt;/code&gt; の場合、 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt; 同等ですが、有効な月ではありません&quot;; 。そうでなければ、形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; はで表される月の月の省略名からなる &lt;code&gt;m&lt;/code&gt; 、関連付けられたロケール使用して決定し &lt;code&gt;os&lt;/code&gt; 、および挿入 &lt;code&gt;s&lt;/code&gt; に &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!uppercase&lt;/code&gt; の場合、変換指定子 &lt;code&gt;%g&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!wd.ok()&lt;/code&gt; の場合、 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt; 同じですが、有効な平日ではありません&quot;; 。そうでなければ、形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; は平日のために省略された曜日名から成るが、で表される &lt;code&gt;wd&lt;/code&gt; 、関連付けられたロケール使用して決定し &lt;code&gt;os&lt;/code&gt; 、および挿入 &lt;code&gt;s&lt;/code&gt; に &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="translated">場合 &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; のデストラクタ &lt;code&gt;tuple&lt;/code&gt; 自明です。</target>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="translated">If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; を呼び出します。その関数が返す場合 &lt;code&gt;-1&lt;/code&gt; 、セットが &lt;code&gt;badbit&lt;/code&gt; で &lt;code&gt;os.rdstate()&lt;/code&gt; 例外を伝播せず。</target>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; 、実装定義の値の代わりに置換されている &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt; の異なる値に対しておそらく異なる &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;*a&lt;/code&gt; と &lt;code&gt;*b&lt;/code&gt; 、その後、同じオブジェクトを参照してください== &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; すでにオブジェクトを所有し、それが最後である &lt;code&gt;shared_ptr&lt;/code&gt; それを所有している、そして &lt;code&gt;r&lt;/code&gt; 同じではありません &lt;code&gt;*this&lt;/code&gt; 、オブジェクトが所有する削除手段によって破壊されます。</target>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; すでにオブジェクトを所有し、それが最後である &lt;code&gt;shared_ptr&lt;/code&gt; それを所有している、オブジェクトが所有する削除手段によって破壊されます。</target>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;*this&lt;/code&gt; および &lt;code&gt;other&lt;/code&gt; 両方のダイナミック型持っている &lt;code&gt;std::exception&lt;/code&gt; その後 &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; 値が含まれていますが、 &lt;code&gt;other&lt;/code&gt; 、それから含まれている値は、そのデストラクタを呼び出すことによって破壊されていません。 &lt;code&gt;*this&lt;/code&gt; は、呼び出し後の値は含まれません。</target>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; 値が含まれ、その値を破壊したかのよう &lt;code&gt;value().T::~T()&lt;/code&gt; 。それ以外の場合、影響はありません。</target>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; 、値が含まれている含まれている値への参照を返します。</target>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; 、関連するミューテックスを持っている（（ &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; null以外のポインタを返す）と、それの所有権を取得している（ &lt;code&gt;owns()&lt;/code&gt; を返す &lt;code&gt;true&lt;/code&gt; ）、ミューテックスを呼び出すことでロックが解除される &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に関連するスレッドがある場合（ &lt;code&gt;joinable() == true&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; 接尾イテレータで、セットが &lt;code&gt;*this&lt;/code&gt; エンド・オブ・シーケンスイテレータに。</target>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; が共有状態を参照する最後のオブジェクトである場合、共有状態を破棄します。そうでなければ何もしません。</target>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">場合 &lt;code&gt;*this&lt;/code&gt; オブジェクトを所有し、それが最後である &lt;code&gt;shared_ptr&lt;/code&gt; それを所有している、オブジェクトが所有する削除手段によって破壊されます。</target>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 関連付けられた実行中のスレッドがまだある場合（つまり、 &lt;code&gt;joinable() == true&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 呼び出します。それ以外の場合は、の状態に割り当てる &lt;code&gt;other&lt;/code&gt; する &lt;code&gt;*this&lt;/code&gt; とセット &lt;code&gt;other&lt;/code&gt; デフォルトの構築状態に。</target>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;--a == --b&lt;/code&gt; その後 &lt;code&gt;a == b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; の後に文字 &lt;code&gt;~&lt;/code&gt; が続き、次に識別子が続く場合（つまり、デストラクタまたは疑似デストラクタを指定する場合）、その識別子は、の左側の名前と同じスコープで検索され &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; trueの場合、呼び出しはする &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; スキップしてもよいです。</target>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 場合、アロケータは変更されません。それ以外の場合、移動割り当ての後、 &lt;code&gt;get_allocator()&lt;/code&gt; は &lt;code&gt;other.get_allocator()&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; trueの場合、アロケータは、非会員への非修飾呼び出し使用して交換されている &lt;code&gt;swap&lt;/code&gt; 。それ以外の場合、それらはスワップされません（そして &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 場合、動作は未定義です）。</target>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; が 2（または2のパワー）で、戻り値は、正確である&lt;a href=&quot;../fenv/fe_round&quot;&gt;現在の丸めモードが&lt;/a&gt;無視されます</target>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt; 、スロー &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 、そうでなければ当量 &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; の特殊化である &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 、次いで、 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; と等価である &lt;code&gt;t1.get().*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; の特殊化である &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 、次いで、 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; と等価である &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; と等価である &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; と等価である &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; 、そしてこのデストラクタは些細なデストラクタです。</target>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; が適切なバッファーサイズでない場合は、 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; を使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 精度が低い場合、値が丸められるか切り捨てられるかは、実装によって定義されます。</target>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; に設定されて &lt;code&gt;which&lt;/code&gt; 再配置のため、試み &lt;code&gt;gptr()&lt;/code&gt; （GETエリア内の次のポインタ）。場合 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; に設定さ &lt;code&gt;which&lt;/code&gt; 、再配置のにしようと &lt;code&gt;pptr()&lt;/code&gt; （プット・エリア内の次のポインタ）。どちらのビットも &lt;code&gt;which&lt;/code&gt; に設定されていない場合、操作は失敗します。</target>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; または類似アロケータが使用され、クラスが実装する必要はありません&lt;a href=&quot;../language/move_constructor&quot;&gt;移動コンストラクタを&lt;/a&gt;、このタイプの要件を満たすために：&lt;a href=&quot;../language/copy_constructor&quot;&gt;コピーコンストラクタ&lt;/a&gt;取る &lt;code&gt;const T&amp;amp;&lt;/code&gt; 引数は右辺値式をバインドすることができます。 MoveInsertableクラスが移動コンストラクターを実装している場合は、&lt;a href=&quot;../utility/move&quot;&gt;移動セマンティクス&lt;/a&gt;も実装して、構築後の &lt;code&gt;rv&lt;/code&gt; の値が指定されていないという事実を利用できます。</target>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; もない非最終非組合クラス型である &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; も由来 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 、公に両方から派生し、不特定のタイプの例外スロー &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; およびfrom &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt; 。 &lt;code&gt;nested_exception&lt;/code&gt; 基本クラスのデフォルトのコンストラクタは &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 呼び出し、現在処理されている例外オブジェクトがあれば、それを &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; にキャプチャします。</target>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; と等価である &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; と等価である &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; のデストラクタ &lt;code&gt;pair&lt;/code&gt; 自明です。</target>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; 文字型へのポインタである（例えば場合、 &lt;code&gt;Y&lt;/code&gt; がである &lt;code&gt;char&lt;/code&gt; または &lt;code&gt;char[]&lt;/code&gt; または &lt;code&gt;CharT&lt;/code&gt; ）、これは呼び出し終わる可能性&lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;の過負荷 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; NULLで終了するため文字列&lt;/a&gt;（ポインタは、A列に実際のポイントでない場合、未定義の動作を引き起こす）はなく、&lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;ポインタの値そのものを印刷するための過負荷&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 戻り &lt;code&gt;true&lt;/code&gt; 、ポインタが間接参照されるべきではない非ヌルポインタです。</target>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="translated">もし &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; を返す &lt;code&gt;true&lt;/code&gt; 、単一のヌル文字へのポインタポイント。</target>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">このオブジェクトに対して &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; が呼び出されたことがない場合は、呼び出し時のグローバルロケールが返されます。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; の最後の呼び出しに渡されたロケールが返されます。</target>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; ヌル・ポインタ（つまり、何の関連するストリーム・バッファが存在しない）であり、 &lt;code&gt;state | badbit&lt;/code&gt; が割り当てられています。例外をスローする場合があります。</target>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">場合は &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; ダイナミックostrstreamで呼び出させた&lt;a href=&quot;freeze&quot;&gt;（false）を凍結が&lt;/a&gt;その後に呼び出されていなかった、このデストラクタでメモリリークが発生します。</target>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">場合は &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; ダイナミックstrstreamの上と呼ばれた&lt;a href=&quot;freeze&quot;&gt;（false）を凍結が&lt;/a&gt;その後に呼び出されていなかった、このデストラクタでメモリリークが発生します。</target>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">場合は &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; ダイナミックstrstreamの上と呼ばれた &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; その後に呼び出されていなかった、このデストラクタでメモリリークが発生します。</target>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; 偽であると &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; trueの場合、戻り &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="translated">場合は &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、そして &lt;code&gt;A&lt;/code&gt; は満たさなければならない&lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;とコピー操作が例外をスローしてはいけません</target>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="translated">場合は &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、そして &lt;code&gt;A&lt;/code&gt; は満たさなければならない&lt;a href=&quot;moveassignable&quot;&gt;MoveAssignableを&lt;/a&gt;し、移動操作が例外をスローしてはいけません。</target>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="translated">場合は &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; の左辺値 &lt;code&gt;A&lt;/code&gt; は、でなければなら&lt;a href=&quot;swappable&quot;&gt;スワップ&lt;/a&gt;およびスワップ操作が例外をスローしてはいけません</target>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="translated">場合は &lt;code&gt;A&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、これはによると、配置-新を呼び出します &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt; 。これは、 &lt;code&gt;T&lt;/code&gt; が構築可能に移動することを効果的に要求します。</target>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;A&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、これはによると、配置-新を呼び出します &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が参照型の場合、参照される型に置き換えられます</target>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; がcv修飾されている場合、 &lt;code&gt;A&lt;/code&gt; はそれ自体のcv修飾されていないバージョンに置き換えられます</target>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は CV-修飾され、トップレベルのCV-修飾子は無視されます。場合 &lt;code&gt;A&lt;/code&gt; が参照型であり、呼ばれるタイプは、推論によって使用されます。</target>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は左辺値参照だったと &lt;code&gt;P&lt;/code&gt; が右辺値参照し、Aは、より多くのPより専門であると考えられています</target>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; はより多くのCV-資格よりだった &lt;code&gt;P&lt;/code&gt; 、Aは、より多くのPより専門であると考えられています</target>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="translated">場合 &lt;code&gt;B&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;std::enable_if&lt;/code&gt; typedefのパブリックメンバ有する &lt;code&gt;type&lt;/code&gt; 、等しい &lt;code&gt;T&lt;/code&gt; 。それ以外の場合、メンバーtypedefはありません。</target>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; が定義されている場合、名前付きのプライマリテンプレートで宣言されているコンストラクター（またはコンストラクターテンプレート） &lt;code&gt;Ci&lt;/code&gt; ごとに（定義されている場合）、架空の関数テンプレート &lt;code&gt;Fi&lt;/code&gt; が構築されます。</target>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; が定義されていないか、コンストラクターを宣言していない場合は、架空のコンストラクター &lt;code&gt;C()&lt;/code&gt; から上記のように派生した追加の架空の関数テンプレートが追加されます。</target>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;Count&lt;/code&gt; が &lt;code&gt;std::dynamic_extent&lt;/code&gt; でない場合、 &lt;code&gt;Count&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="translated">場合 &lt;code&gt;D&lt;/code&gt; は、参照型であり、第二の過負荷が選択され、プログラムが悪い形成されています。</target>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;D&lt;/code&gt; は、参照型で削除済みとして、第二の過負荷が定義されています。これらのオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロードの解決に参加します。これらの2つのコンストラクターのいずれかが&lt;a href=&quot;../../language/deduction_guide&quot;&gt;クラステンプレート引数deduction&lt;/a&gt;によって選択されている場合、プログラムの形式は正しくありません。</target>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Deleter&lt;/code&gt; が参照型の場合、 &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt; と同等。それ以外の場合は、 &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;Deleter&lt;/code&gt; 参照型である、ことを要求 &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; nothrow-ある&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Deleter&lt;/code&gt; が参照型ではない場合、nothrow- &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;である必要があります。</target>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Derived&lt;/code&gt; が&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;ポリモーフィック&lt;/a&gt;である場合、そのようなポインターを使用して&lt;a href=&quot;virtual&quot;&gt;仮想関数を呼び出す&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;Derived&lt;/code&gt; から誘導される &lt;code&gt;Base&lt;/code&gt; またはその両方が（CV-資格を無視して、両方の場合において）同じ非組合クラスである場合、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; に等しい &lt;code&gt;true&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="translated">場合 &lt;code&gt;E2&lt;/code&gt; が可変メンバーではない、&lt;a href=&quot;cv&quot;&gt;CV-資格&lt;/a&gt;結果がのCV-資格の和集合である &lt;code&gt;E1&lt;/code&gt; および &lt;code&gt;E2&lt;/code&gt; （そうでない場合、 &lt;code&gt;E2&lt;/code&gt; が可変されるメンバーである）、それの揮発性資格の和集合である &lt;code&gt;E1&lt;/code&gt; および &lt;code&gt;E2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="translated">場合 &lt;code&gt;E&lt;/code&gt; における&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;関数呼び出し式&lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; クラス型CV有する &lt;code&gt;T&lt;/code&gt; を、その後、。</target>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="translated">場合は &lt;code&gt;E&lt;/code&gt; での&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;関数呼び出し式&lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; の名前オーバーロードされた関数および/または関数テンプレート（ただし、呼び出し可能ではないオブジェクト）のセットには、次のルールが続いています。</target>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="translated">場合 &lt;code&gt;E&lt;/code&gt; は、ポリモーフィッククラス型でない場合、または &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; のアクセスできないまたは曖昧な基底クラスである &lt;code&gt;E&lt;/code&gt; 、影響はありません。</target>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; がメンバー関数を指定する場合、それは仮想である可能性があります。その場合、実行時に動的ディスパッチを使用して、その関数の最後のオーバーライドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="translated">&lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; が存在し、型に名前を付ける場合、 &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; は有効で型に名前を付ける必要があり、 &lt;code&gt;Pred&lt;/code&gt; は &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; いずれかである必要があります（プログラムは正常ではありません-それ以外の場合）。</target>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; が整数型の場合、 &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;InputIt&lt;/code&gt; がない&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;場合、動作は未定義され &lt;code&gt;last&lt;/code&gt; から到達できない &lt;code&gt;first&lt;/code&gt; インクリメント（おそらく繰り返し）によって &lt;code&gt;first&lt;/code&gt; 。場合 &lt;code&gt;InputIt&lt;/code&gt; がある&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;場合、動作は未定義され &lt;code&gt;last&lt;/code&gt; から到達可能ではありません &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;first&lt;/code&gt; から到達できない &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; がLegacyForwardIteratorを満たす場合、この関数は重複を検出するために入力を&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;再読み取り&lt;/a&gt;します。</target>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="translated">場合 &lt;code&gt;Iter&lt;/code&gt; 持っていない &lt;code&gt;pointer&lt;/code&gt; 、他のすべての4つのメンバーのタイプがあり、次のようにメンバーの型が宣言されています。</target>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="translated">場合 &lt;code&gt;Iter&lt;/code&gt; 5つすべてのメンバータイプがない &lt;code&gt;difference_type&lt;/code&gt; 、 &lt;code&gt;value_type&lt;/code&gt; 、 &lt;code&gt;pointer&lt;/code&gt; 、 &lt;code&gt;reference&lt;/code&gt; 、そして &lt;code&gt;iterator_category&lt;/code&gt; は、その後、このテンプレートは、それらの名前のいずれかによって全くメンバーがありません（ &lt;code&gt;std::iterator_traits&lt;/code&gt; SFINAEフレンドリーれています）。</target>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; が &lt;code&gt;std::dynamic_extent&lt;/code&gt; 場合、返されるスパン &lt;code&gt;S&lt;/code&gt; の範囲も &lt;code&gt;std::dynamic_extent&lt;/code&gt; です。それ以外の場合は、 &lt;code&gt;sizeof(T) * N&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">ソースコードで &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; が含まれている場所で &lt;code&gt;NDEBUG&lt;/code&gt; がマクロ名として定義されている場合、 &lt;code&gt;assert&lt;/code&gt; は何もしません。</target>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;NDEBUG&lt;/code&gt; が定義されていない場合、 &lt;code&gt;assert&lt;/code&gt; はその引数（スカラー型でなければならない）がゼロと等しいかどうかをチェックします。存在する場合、 &lt;code&gt;assert&lt;/code&gt; は実装固有の診断情報を標準エラー出力に出力し、 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; を呼び出します。診断情報には、 &lt;code&gt;expression&lt;/code&gt; のテキスト、標準マクロ &lt;code&gt;__func__&lt;/code&gt; &lt;code&gt;__FILE__&lt;/code&gt; 、 &lt;code&gt;__LINE__&lt;/code&gt; LINE__、および標準変数__func__（C ++ 11以降）の値を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; が関数パラメーターリスト &lt;code&gt;(T)&lt;/code&gt; を含む形式の1つである場合、そのリストの各パラメーター &lt;code&gt;P&lt;/code&gt; iは、 &lt;code&gt;A&lt;/code&gt; の関数パラメーターリストの対応する引数 &lt;code&gt;A&lt;/code&gt; i と比較されます。最後の場合は &lt;code&gt;P&lt;/code&gt; iがパックの拡張であり、その宣言は各残りと比較される &lt;code&gt;A&lt;/code&gt; のパラメータ型リストでI &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; がテンプレートパラメータリスト &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt; を含む形式のいずれかである場合、そのテンプレート引数リストの各要素 &lt;code&gt;P&lt;/code&gt; iは、その &lt;code&gt;A&lt;/code&gt; の対応するテンプレート引数 &lt;code&gt;A&lt;/code&gt; i と照合されます。最後の &lt;code&gt;P&lt;/code&gt; iがパック展開である場合、そのパターンは &lt;code&gt;A&lt;/code&gt; のテンプレート引数リスト内の残りの各引数と比較されます。他の方法では推定されない末尾のパラメーターパックは、空のパラメーターパックに推定されます。</target>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="translated">場合 &lt;code&gt;P&lt;/code&gt; は、メンバ関数型への関数型、関数型へのポインタ、またはポインタであり、場合 &lt;code&gt;A&lt;/code&gt; はで&lt;a href=&quot;overloaded_address&quot;&gt;オーバーロードされた関数の集合&lt;/a&gt;関数テンプレートを含有しない、テンプレート引数控除は、それぞれ過負荷と試みています。1つだけが成功した場合、その成功した控除が使用されます。成功しなかった場合、または1つ以上成功した場合、テンプレートパラメータは推定されていないコンテキストです（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; が参照型の場合、参照される型に置き換えられます</target>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; がcv修飾されている場合、 &lt;code&gt;P&lt;/code&gt; はそれ自体のcv修飾されていないバージョンに置き換えられます</target>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; が自明なコピー構築が可能な場合、 &lt;code&gt;fpos&lt;/code&gt; には自明なコピーコンストラクターがあります。 &lt;code&gt;State&lt;/code&gt; が自明なコピー代入可能な場合、 &lt;code&gt;fpos&lt;/code&gt; には自明なコピー代入演算子があります。 &lt;code&gt;State&lt;/code&gt; が自明に破壊可能である場合、 &lt;code&gt;fpos&lt;/code&gt; は自明なデストラクタを持っています。</target>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="translated">場合 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; は、両方の参照型であり、そして</target>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T1&lt;/code&gt; 及び &lt;code&gt;T2&lt;/code&gt; が、両方の右辺値参照型である：の単純な共通の参照タイプ場合 &lt;code&gt;T1 &amp;amp;&lt;/code&gt; と &lt;code&gt;T2 &amp;amp;&lt;/code&gt; （前の箇条書きに従って決定）が存在し、聞かせて &lt;code&gt;C&lt;/code&gt; が示すタイプの対応する右辺値参照タイプこと。もし &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; ともに &lt;code&gt;true&lt;/code&gt; 、その後の単純な共通基準タイプ &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; がある &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="translated">場合 &lt;code&gt;T1&lt;/code&gt; はある &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; がある &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; すなわち、両方が左辺値参照型です）：そのシンプルな共通の参照タイプがある &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt; 、ここで</target>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; （のテンプレートパラメータ &lt;code&gt;shared_ptr&lt;/code&gt; ）配列型である &lt;code&gt;U[N]&lt;/code&gt; 、 &lt;code&gt;idx&lt;/code&gt; 以下でなければならない &lt;code&gt;N&lt;/code&gt; そうでなければ動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; および &lt;code&gt;U&lt;/code&gt; は、（CONST /揮発性の資格を含む）同じタイプの名前、会員定数を提供する &lt;code&gt;value&lt;/code&gt; に等しい &lt;code&gt;true&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は typedefの部材有する &lt;code&gt;allocator_type&lt;/code&gt; から変換可能である &lt;code&gt;Alloc&lt;/code&gt; または別名で &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt; （ライブラリ基礎TS）を、部材の定数の &lt;code&gt;value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は（おそらくCV-資格）で &lt;code&gt;void&lt;/code&gt; 、関数型、またはバインドされ、未知の配列は、 &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;及びタイプのいずれか2つのオブジェクト場合 &lt;code&gt;T&lt;/code&gt; 同じ値を持つが同じ有する&lt;a href=&quot;../language/objects&quot;&gt;オブジェクト表現を&lt;/a&gt;提供するメンバ定数の &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;（スカラー型、自明にコピー可能とクラスである&lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;些細なデフォルトコンストラクタ&lt;/a&gt;、またはこのようなタイプ/クラスのアレイ、おそらくはCV修飾）は、メンバ定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../language/derived_class&quot;&gt;派生クラス&lt;/a&gt;一部ベースの &lt;code&gt;B&lt;/code&gt; 、次いで &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; で&lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;暗黙的に変換&lt;/a&gt;する &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; 。結果のデフォルトの削除手段 &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; 使用する&lt;a href=&quot;new/operator_delete&quot;&gt;オペレータは、削除&lt;/a&gt;のために &lt;code&gt;B&lt;/code&gt; につながる、&lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;未定義の動作&lt;/a&gt;のデストラクタない限り、 &lt;code&gt;B&lt;/code&gt; がある&lt;a href=&quot;../language/virtual&quot;&gt;仮想&lt;/a&gt;。 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 動作は異なることに注意してください &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; に&lt;a href=&quot;new/operator_delete&quot;&gt;演算子delete&lt;/a&gt;を使用します &lt;code&gt;B&lt;/code&gt; のデストラクタが&lt;a href=&quot;../language/virtual&quot;&gt;仮想&lt;/a&gt;でない場合でも、所有されているオブジェクトは正しく削除されます。</target>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;多型クラス&lt;/a&gt;（、少なくとも一つの仮想関数を宣言または継承非組合クラスである）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../language/type-id&quot;&gt;スカラー型&lt;/a&gt;（おそらくCV-修飾されている&lt;a href=&quot;is_arithmetic&quot;&gt;演算&lt;/a&gt;、ポインタ、&lt;a href=&quot;is_member_pointer&quot;&gt;メンバへのポインタ&lt;/a&gt;、&lt;a href=&quot;../language/enum&quot;&gt;列挙&lt;/a&gt;、または &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 型）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt;ある（「昔ながらのデータ・タイプ」）は、両方の些細な標準レイアウトは、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がクラス型及び他のタイプのCV-修飾されていないバージョンである &lt;code&gt;T&lt;/code&gt; またはから派生したクラス &lt;code&gt;T&lt;/code&gt; 、&lt;a href=&quot;converting_constructor&quot;&gt;非明示的なコンストラクタ&lt;/a&gt;の &lt;code&gt;T&lt;/code&gt; が検査され、最良一致がオーバーロード解決によって選択されます。次に、コンストラクターが呼び出され、オブジェクトが初期化されます。</target>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が、デフォルトのコンストラクターを持たないが &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; を取るコンストラクターを持つクラス型である場合、&lt;a href=&quot;list_initialization&quot;&gt;リストの初期化&lt;/a&gt;が実行されます。</target>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="translated">もし &lt;code&gt;T&lt;/code&gt; がクラス型で、</target>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がクラス型の場合、 &lt;code&gt;T&lt;/code&gt; は完全な型になります。それ以外の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、クラス型、および他のタイプのCV-修飾されていないバージョンではありませんである &lt;code&gt;T&lt;/code&gt; または由来する &lt;code&gt;T&lt;/code&gt; 場合、または &lt;code&gt;T&lt;/code&gt; が非クラス型であるが、他のタイプは、クラスタイプ、ある&lt;a href=&quot;implicit_cast&quot;&gt;ユーザ定義の変換シーケンス&lt;/a&gt; otherの型から &lt;code&gt;T&lt;/code&gt; （またはTがクラス型で変換関数が利用可能な場合はTから派生した型）に変換できるものが調べられ、オーバーロードの解決を通じて最適なものが選択されます。変換の結果は、変換&lt;a href=&quot;converting_constructor&quot;&gt;コンストラクター&lt;/a&gt;が使用された場合の一時的なprvalue（C ++ 17まで）prvalue式（C ++ 17以降）であり、オブジェクトを&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;するために使用されます。最後のステップは通常&lt;a href=&quot;copy_elision&quot;&gt;最適化され&lt;/a&gt;、変換の結果はターゲットオブジェクトに割り当てられたメモリに直接作成されますが、使用されていない場合でも適切なコンストラクター（移動またはコピー）にアクセスできる必要があります。（C ++ 17まで）</target>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がクラスの場合、それは</target>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は完全な列挙型である、のtypedefメンバーを提供 &lt;code&gt;type&lt;/code&gt; その名の基になる型 &lt;code&gt;T&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、（任意のCV修飾変異体を含む配列、関数、オブジェクト・ポインタ、関数ポインタ、メンバオブジェクトポインタ、メンバ関数ポインタ、参照、クラス、共用体、または列挙である）の化合物の種類は、あるメンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は（あるconst修飾型で &lt;code&gt;const&lt;/code&gt; 、または &lt;code&gt;const volatile&lt;/code&gt; ）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は const修飾型であり、それはユーザ提供のデフォルトコンストラクタを持つクラス型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、 CV-修飾型であり、そのCV-修飾されていないバージョンでは、デフォルトの初期化の目的のために使用されています。</target>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、最終的なクラスである（すなわち、と宣言されたクラス&lt;a href=&quot;../language/final&quot;&gt;最終指定子&lt;/a&gt;）を提供メンバー定数の &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は基本的なタイプである（ある、算術型、 &lt;code&gt;void&lt;/code&gt; 、または &lt;code&gt;nullptr_t&lt;/code&gt; ）提供会員定数の &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; はリテラルの型で、このデストラクタは些細なデストラクタです。</target>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が何らかのタイプ &lt;code&gt;X&lt;/code&gt; の多次元配列である場合、メンバーtypedef &lt;code&gt;type&lt;/code&gt; を &lt;code&gt;X&lt;/code&gt; に等しくします。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は非クラス型であり、オブジェクトに含まれる値をprvalue結果として生成されます。クラス型の場合、この変換。</target>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は非組合のクラス型で、 &lt;code&gt;T&lt;/code&gt; は完全な型でなければなりません。それ以外の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は参照型（左辺値参照または右辺値参照）であり、部材の一定の提供 &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;T&lt;/code&gt; が参照型である、その後 &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; 常に &lt;code&gt;false&lt;/code&gt; 。参照の可能性がある型のconst-nessをチェックする適切な方法は、参照を削除することです： &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が参照型である場合、参照される型へのポインターであるメンバーtypedef &lt;code&gt;type&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; はスカラー型である、オブジェクトの初期値は積分定数ゼロで&lt;a href=&quot;explicit_cast&quot;&gt;明示的に変換&lt;/a&gt;する &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、標準のレイアウトタイプである（すなわち、スカラー型、標準レイアウトクラス、またはそのようなタイプ/クラス、おそらくはCV修飾の配列）を提供メンバー定数の &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が仮想デストラクタを持つ型の場合、 &lt;code&gt;true&lt;/code&gt; に等しいメンバー定数 &lt;code&gt;value&lt;/code&gt; 提供します。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は組合型であり、第一の非静的名前付きデータ・メンバーは、ゼロ初期化され、すべてのパディングがゼロのビットに初期化されます。</target>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、揮発性の修飾型（である &lt;code&gt;volatile&lt;/code&gt; 、又は &lt;code&gt;const volatile&lt;/code&gt; ）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../language/abstract_class&quot;&gt;抽象クラス&lt;/a&gt;（少なくとも一つの純粋仮想関数を宣言または継承非組合クラスである）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../language/type-id&quot;&gt;オブジェクトのタイプ&lt;/a&gt;（すなわち、任意の可能性のCV修飾機能以外のタイプ、参照、またはある &lt;code&gt;void&lt;/code&gt; タイプ）、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;aggregate_initialization&quot;&gt;集合型&lt;/a&gt;、&lt;a href=&quot;aggregate_initialization&quot;&gt;凝集初期化が&lt;/a&gt;行われます。</target>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、集約型であり、初期化リストは、同一または派生型（おそらくCV修飾）の単一の要素を有し、オブジェクトは（によってその要素から初期化された&lt;a href=&quot;copy_initialization&quot;&gt;コピーの初期&lt;/a&gt;コピーリストの初期化のために、またはによって&lt;a href=&quot;direct_initialization&quot;&gt;ダイレクト&lt;/a&gt;直接リスト初期化のための初期化）。</target>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は算術型である（すなわち、一体型または浮動小数点型）または &lt;code&gt;cv-qualified&lt;/code&gt; そのバージョン、提供会員定数の &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は算術型で、メンバ定数を提供する &lt;code&gt;value&lt;/code&gt; 等しく &lt;code&gt;true&lt;/code&gt; であれば &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt; ：でこの結果 &lt;code&gt;true&lt;/code&gt; 浮動小数点型と符号付き整数型のため、及びに &lt;code&gt;false&lt;/code&gt; の符号なし整数型のためのおよび &lt;code&gt;bool&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は算術型で、メンバ定数を提供する &lt;code&gt;value&lt;/code&gt; 等しく &lt;code&gt;true&lt;/code&gt; 場合に &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt; ：このもたらす &lt;code&gt;true&lt;/code&gt; の符号なし整数型およびタイプ &lt;code&gt;bool&lt;/code&gt; とに &lt;code&gt;false&lt;/code&gt; の符号付き整数型および浮動ポイントタイプ。</target>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、いくつかのタイプの配列である &lt;code&gt;X&lt;/code&gt; 、のtypedef部材を提供する &lt;code&gt;type&lt;/code&gt; に等しい &lt;code&gt;X&lt;/code&gt; そうでなければ、 &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;T&lt;/code&gt; 。 Tが多次元配列の場合、最初の次元のみが削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; が配列型である &lt;code&gt;U[N]&lt;/code&gt; の場合、これらのコンストラクタは、オーバーロード解決に関与しない &lt;code&gt;Y(*)[N]&lt;/code&gt; はに変換ない &lt;code&gt;T*&lt;/code&gt; 。場合 &lt;code&gt;T&lt;/code&gt; が配列型である &lt;code&gt;U[]&lt;/code&gt; あれば、これらのコンストラクタは、オーバーロード解決に関与しない &lt;code&gt;Y(*)[]&lt;/code&gt; に変換可能ではない &lt;code&gt;T*&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;Y*&lt;/code&gt; が &lt;code&gt;T*&lt;/code&gt; 変換できない場合、これらのコンストラクターはオーバーロード解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="translated">もし &lt;code&gt;T&lt;/code&gt; が配列型であり、</target>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が配列型の場合、配列の次元数に等しいメンバー定数 &lt;code&gt;value&lt;/code&gt; 提供します。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は0です。</target>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は配列型であり、部材の一定の提供 &lt;code&gt;value&lt;/code&gt; 沿って要素の数に等しい &lt;code&gt;N&lt;/code&gt; 場合、アレイの第次元 &lt;code&gt;N&lt;/code&gt; がである &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt; 。その他のタイプの場合、または &lt;code&gt;T&lt;/code&gt; が最初の次元に沿った未知の境界の配列で、 &lt;code&gt;N&lt;/code&gt; が0の場合、 &lt;code&gt;value&lt;/code&gt; は0です。</target>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; が空の型である（すなわち、サイズ0のビットフィールド、ない仮想関数、無仮想基本クラス以外の非静的データメンバ、及び無空でない基底クラスと非組合クラス型） &lt;code&gt;true&lt;/code&gt; に等しいメンバー定数 &lt;code&gt;value&lt;/code&gt; 提供します。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、エラーコード列挙され、このテンプレートはメンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、エラー状態の列挙型であり、このテンプレートはメンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、（BOOLを除く）積分または列挙型であり、typedefのメンバー提供 &lt;code&gt;type&lt;/code&gt; に対応する符号付き整数型である &lt;code&gt;T&lt;/code&gt; を同じCV-修飾子と、。</target>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、（BOOLを除く）積分または列挙型であり、部材のtypedef提供 &lt;code&gt;type&lt;/code&gt; に対応する符号なし整数型である &lt;code&gt;T&lt;/code&gt; を同じCV-修飾子と、。列挙型に対応する符号なし整数型は、列挙型と同じ &lt;code&gt;sizeof&lt;/code&gt; を持つ最小&lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;ランクの&lt;/a&gt;符号なし整数型です。</target>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は非組合クラスタイプである、すべての基底クラスと非静的データ・メンバーは、ゼロ初期化され、すべてのパディングがゼロのビットに初期化されます。コンストラクターがあっても無視されます。</target>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がオブジェクトタイプの場合、タイプ &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; に等しい場合、式 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; が未評価のコンテキストで整形式であれば、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が配列型の場合、各要素はゼロで初期化されます</target>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;でない場合、 &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; を専門とするプログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が標準のプレースホルダータイプではない場合、このテンプレートは &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt; &amp;lt;int、0&amp;gt;から派生します</target>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がconst修飾されていない場合、（上記の箇条書きで定義/式が評価された後の） &lt;code&gt;rv&lt;/code&gt; の結果の状態は有効ですが、指定されていません。それ以外の場合は変更されません。</target>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、非静的メンバオブジェクトまたは非静的メンバ関数へのポインタへのポインタであるメンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しく &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が参照型の場合、何も行われません。</target>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、標準のプレースホルダ（_1、_2、_3、...）のタイプであり、このテンプレートが由来する &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 呼び出しによって生成されるタイプである場合、このテンプレートは &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; から派生します。その他のタイプの場合、このテンプレートは &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; から派生します。</target>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は自明、破壊され、このデストラクタはそうも自明である &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; も自明-破壊です。</target>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../concepts/defaultconstructible&quot;&gt; &lt;code&gt;DefaultConstructible&lt;/code&gt; を&lt;/a&gt;モデル化している場合、 &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; のデフォルトコンストラクターは、値で初期化された &lt;code&gt;T&lt;/code&gt; を含むセミレギュラーラッパーを構築します。</target>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がタイプ「 &lt;code&gt;U&lt;/code&gt; の配列」または「 &lt;code&gt;U&lt;/code&gt; の配列への参照」に名前を付ける場合、メンバーtypedef &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;U*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; が満足のすべての要件&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypeを&lt;/a&gt;、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しい &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; を満たす&lt;a href=&quot;../named_req/clock&quot;&gt;クロック&lt;/a&gt;要件は、メンバー定数を提供する &lt;code&gt;value&lt;/code&gt; 等しく &lt;code&gt;true&lt;/code&gt; 。その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; の移動のコンストラクタではありません &lt;code&gt;noexcept&lt;/code&gt; とTではない&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;に &lt;code&gt;*this&lt;/code&gt; は、ベクターは投げムーブコンストラクタを使用します。スローした場合、保証は放棄され、効果は不定です。</target>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T_i&lt;/code&gt; ある（おそらくCV-資格） &lt;code&gt;bool&lt;/code&gt; 、 &lt;code&gt;F(T_i)&lt;/code&gt; 場合にのみ考慮され &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; またれる &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; または &lt;code&gt;V&lt;/code&gt; が &lt;code&gt;std::intmax_t&lt;/code&gt; で表現できない場合、プログラムの形式が正しくありません。場合 &lt;code&gt;Num&lt;/code&gt; または &lt;code&gt;Denom&lt;/code&gt; がで表現できない &lt;code&gt;std::intmax_t&lt;/code&gt; 実装が正しい値得ていない限り、プログラムが病気に形成され、 &lt;code&gt;U&lt;/code&gt; と &lt;code&gt;V&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; がアロケータを認識しない場合、用語は &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; であるかのように定義されます。ただし、アロケータオブジェクトを作成する必要はなく、ユーザー定義の &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 特殊化はインスタンス化されません。</target>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; がアロケータに対応していない場合、用語は &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt; であるかのように定義されます。ただし、アロケータオブジェクトを作成する必要はなく、ユーザー定義の &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 特殊化はインスタンス化されません。</target>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">場合は &lt;code&gt;[s_first, s_last)&lt;/code&gt; 空であるか、そのようなシーケンスが見つからない場合は、 &lt;code&gt;last&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="translated">場合は &lt;code&gt;[s_first, s_last)&lt;/code&gt; 空で、 &lt;code&gt;first&lt;/code&gt; 返されます。（C ++ 11以降）</target>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;a &amp;lt; b&lt;/code&gt; と &lt;code&gt;b &amp;lt; c&lt;/code&gt; その後、 &lt;code&gt;a &amp;lt; c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;a &amp;lt; b&lt;/code&gt; そして &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;a == b&lt;/code&gt; と &lt;code&gt;b == c&lt;/code&gt; 、そして &lt;code&gt;a == c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">&lt;code&gt;a == b&lt;/code&gt; 場合、 &lt;code&gt;param_type&lt;/code&gt; オブジェクトを受け入れない&lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt;オーバーロードへの後続の呼び出しは、未定義の動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;a == b&lt;/code&gt; 場合、 &lt;code&gt;b == a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="translated">場合と &lt;code&gt;b&lt;/code&gt; が等しい比較（ &lt;code&gt;a == b&lt;/code&gt; の文脈変換可能な &lt;code&gt;true&lt;/code&gt; ）それらは非dereferenceableまたは両方されているか &lt;code&gt;*a&lt;/code&gt; と &lt;code&gt;*b&lt;/code&gt; 同一のオブジェクトにバインドされている参考文献 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="translated">もし &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; およびステージ1つの表現は、xまたはXの後の0xまたは0X、意志パッドを開始しました</target>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="translated">もし &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; 記号の後や記号文字が表現で発生し、意志パッド</target>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="translated">もし &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; 、意志パッド後</target>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="translated">もし &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt; 、意志パッドの前に</target>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="translated">場合 &lt;code&gt;alignof(T)&lt;/code&gt; は有効な式ではありません、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、+&amp;infin;が返されます</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; が発生し、実装定義の値が返されます</target>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、変更されずに返されます</target>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、それが返され、未指定の値が &lt;code&gt;*exp&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、変更されずに返されます</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; が &amp;plusmn;0で、&amp;plusmn;&amp;infin;、またはNaN、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;0の場合、-&amp;infin;が返され、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;0の場合、変更されずに返されます</target>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が&amp;plusmn;0の場合、変更されずに返され、 &lt;code&gt;*exp&lt;/code&gt; に &lt;code&gt;0&lt;/code&gt; が格納されます。</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; がNaNの場合、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; が発生し、実装定義の値が返されます</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; がNaNの場合、NaNが返されます</target>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; がNaNの場合、NaNが返され、未指定の値が &lt;code&gt;*exp&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; がNaNの場合、NaNが返されます。</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; がNaNの場合、 &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が自然数の場合、 &lt;code&gt;std::lgamma(arg)&lt;/code&gt; は &lt;code&gt;arg-1&lt;/code&gt; の階乗の対数です。</target>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が自然数の場合、 &lt;code&gt;std::tgamma(arg)&lt;/code&gt; は &lt;code&gt;arg-1&lt;/code&gt; の階乗です。多くの実装は、引数が十分に小さい整数である場合、正確な整数領域階乗を計算します。</target>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が無限の場合、 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; が浮動小数点数でない場合、動作は不定です。</target>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; がないゼロは、無限、またはNaN、返される値は全く同じであると &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; がゼロまたはゼロ以上の整数であり、極エラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; がゼロまたはゼロ以上の整数であり、磁極誤差またはドメインエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; がゼロである、 &lt;code&gt;FP_ILOGB0&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;arg&lt;/code&gt; がゼロである、リターンはゼロと店舗がゼロ &lt;code&gt;*exp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="translated">場合 &lt;code&gt;b&lt;/code&gt; が trueの場合、返されるビットマスクは、彼らの大文字小文字を区別せずに文字のマッチングに適しています。</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; が &lt;code&gt;TIME_UTC&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">場合 &lt;code&gt;base&lt;/code&gt; 有限で負であり、 &lt;code&gt;exp&lt;/code&gt; は有限と非整数であり、ドメインエラーが発生し、範囲エラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">場合 &lt;code&gt;base&lt;/code&gt; ゼロであり、 &lt;code&gt;exp&lt;/code&gt; は負であり、ドメインエラーまたは極エラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">場合は &lt;code&gt;base&lt;/code&gt; ゼロで、 &lt;code&gt;exp&lt;/code&gt; がゼロである、ドメイン・エラーが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;basefield == 0&lt;/code&gt; 場合、変換指定子 &lt;code&gt;%i&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt; 、変換指定子を使用します &lt;code&gt;%x&lt;/code&gt; と</target>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;basefield == hex&lt;/code&gt; 場合、変換指定子 &lt;code&gt;%X&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;basefield == oct&lt;/code&gt; 場合、変換指定子 &lt;code&gt;%o&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="translated">&lt;code&gt;begin == end&lt;/code&gt; 場合、何もしません。さもないと、</target>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">場合 &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; と &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; 共に &lt;code&gt;true&lt;/code&gt; 、次に &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; で &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;boolalpha != 0&lt;/code&gt; 取得 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; であれば &lt;code&gt;v == true&lt;/code&gt; か &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; であれば &lt;code&gt;v == false&lt;/code&gt; 、それぞれ連続した文字の出力 &lt;code&gt;c&lt;/code&gt; にその文字列の &lt;code&gt;out&lt;/code&gt; して &lt;code&gt;*out++ = c&lt;/code&gt; 。この場合、それ以上の処理は行われず、関数は &lt;code&gt;out&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="translated">&lt;code&gt;boolalpha == 0&lt;/code&gt; 場合、 &lt;code&gt;v&lt;/code&gt; を &lt;code&gt;int&lt;/code&gt; 型に変換し、整数出力を実行します。</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がnullポインターの場合、内部バッファーの &lt;code&gt;size&lt;/code&gt; をsizeに変更します。</target>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">場合は &lt;code&gt;buffer&lt;/code&gt; NULLポインタでない、サイズのユーザーが用意したバッファを使用してストリームを指示 &lt;code&gt;size&lt;/code&gt; から始まる &lt;code&gt;buffer&lt;/code&gt; 。ストリームは、 &lt;code&gt;buffer&lt;/code&gt; が指す配列の&lt;a href=&quot;../../language/lifetime&quot;&gt;存続期間&lt;/a&gt;が終了する前に（ &lt;code&gt;fclose&lt;/code&gt; を使用して）クローズする必要があります。 &lt;code&gt;setvbuf&lt;/code&gt; の呼び出しが成功した後の配列の内容は不確定であり、それを使用しようとする試みは未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がnullでない場合、 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がnullの場合、 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; と同等で、バッファリングがオフになります。</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;code&gt;c16&lt;/code&gt; がワイド文字の16ビット表現の最後のコード単位ではない場合、c16は &lt;code&gt;s&lt;/code&gt; が指す配列に書き込みません。更新されるのは &lt;code&gt;*ps&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="translated">&lt;code&gt;c8&lt;/code&gt; が無効な場合（有効なマルチバイト文字に対応する &lt;code&gt;char8_t&lt;/code&gt; のシーケンスに寄与しない場合）、マクロ &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; の値が &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; に格納され、 &lt;code&gt;(size_t)(-1)&lt;/code&gt; が返され、変換状態は指定されません。</target>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">場合 &lt;code&gt;c8&lt;/code&gt; コードポイントの表現の最終UTF-8コード単位ではなく、機能はアレイによって指さに書き込まない &lt;code&gt;s&lt;/code&gt; 、唯一 &lt;code&gt;*ps&lt;/code&gt; 更新されます。</target>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">場合 &lt;code&gt;c8&lt;/code&gt; ヌル文字である &lt;code&gt;u8'\0'&lt;/code&gt; は、nullバイトは、保存された初期シフト状態と変換状態パラメータを復元するために必要なシフトシーケンスが先行する &lt;code&gt;*ps&lt;/code&gt; 初期シフト状態を表すように更新されます。</target>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は（ファイルの終わり指標である &lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt; ）、その後、追記する文字はありません。関数は何もせず、 &lt;code&gt;traits::eof()&lt;/code&gt; 以外の未指定の値を返します。</target>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 場合、 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 以外の値を返します。それ以外の場合は、成功すると &lt;code&gt;(unsigned char)(c)&lt;/code&gt; を返し、失敗すると &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">場合 &lt;code&gt;ch&lt;/code&gt; が等しくない &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; は、文字プッシュ &lt;code&gt;ch&lt;/code&gt; （として再解釈 &lt;code&gt;unsigned char&lt;/code&gt; ストリームに関連付けられた入力バッファに） &lt;code&gt;stream&lt;/code&gt; からの後続の読み出し動作よりように &lt;code&gt;stream&lt;/code&gt; ている文字を取得しますが。ストリームに関連付けられた外部デバイスは変更されません。</target>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">場合 &lt;code&gt;ch&lt;/code&gt; が等しくない &lt;code&gt;WEOF&lt;/code&gt; は、ワイド文字プッシュ &lt;code&gt;ch&lt;/code&gt; 入力には、ストリームに関連するバッファ &lt;code&gt;stream&lt;/code&gt; からの後続の読み出し動作よりように &lt;code&gt;stream&lt;/code&gt; ているワイド文字を取得します。ストリームに関連付けられた外部デバイスは変更されません。</target>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; と等しい場合、操作は失敗し、ストリームは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; が &lt;code&gt;WEOF&lt;/code&gt; と等しい場合、操作は失敗し、ストリームは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">場合 &lt;code&gt;command&lt;/code&gt; ヌル・ポインタであり、コマンドプロセッサが存在する場合にのみ場合、ホスト環境は、コマンドプロセッサを有し、か否かをチェックゼロ以外の値を返します。</target>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;comp(a,b)==true&lt;/code&gt; その後、 &lt;code&gt;comp(b,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; が2つの要素を同等として示している場合、それらの順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="translated">場合 &lt;code&gt;copy_options::directories_only&lt;/code&gt; に存在する &lt;code&gt;options&lt;/code&gt; は何もしません、</target>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="translated">場合 &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; 中に存在している &lt;code&gt;options&lt;/code&gt; 、何もしません。</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ある &lt;code&gt;​0​&lt;/code&gt; 、その後、 &lt;code&gt;dest&lt;/code&gt; が NULLポインタであることを許可されています。</target>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">文字列 &lt;code&gt;src&lt;/code&gt; 全体がコピーされる前に &lt;code&gt;count&lt;/code&gt; に達した場合、結果の文字配列はnullで終了しません。</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">文字列 &lt;code&gt;src&lt;/code&gt; 全体がコピーされる前に &lt;code&gt;count&lt;/code&gt; に達した場合、結果のワイド文字配列はnullで終了しません。</target>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ゼロまたは負で、 &lt;code&gt;first&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ゼロである、文字列が等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ゼロで、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ゼロで、関数はnullポインタを返します。</target>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="translated">場合 &lt;code&gt;d_&lt;/code&gt; この時間を保持部材変数（すなわち、時間エポック）である &lt;code&gt;time_point&lt;/code&gt; のオブジェクト、</target>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;del&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、配列は &lt;code&gt;new[]&lt;/code&gt; で割り当てられたと見 &lt;code&gt;delete[] tbl&lt;/code&gt; 、このファセットのデストラクタがdelete [] tblを呼び出します。</target>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;dir&lt;/code&gt; がされていない &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; またはオフセット &lt;code&gt;off&lt;/code&gt; ないが &lt;code&gt;​0​&lt;/code&gt; 、そしてこのたfilebufオブジェクト上で行わ最も再送操作があること、のいずれかプット・バッファが空、または最後に呼び出されません（出力しましたfunctionは &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; でした）、次に &lt;code&gt;std::codecvt::unshift&lt;/code&gt; を呼び出して必要なシフト解除シーケンスを決定し、 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; を呼び出してそのシーケンスをファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="translated">場合 &lt;code&gt;e&lt;/code&gt; 、クラスメンバアクセス式である（ &lt;code&gt;e1.e2&lt;/code&gt; または &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt; ）、オブジェクト式E1の電位の結果はセットに含まれています。</target>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="translated">場合 &lt;code&gt;e&lt;/code&gt; カンマ式である（ &lt;code&gt;e1,e2&lt;/code&gt; ）の電位結果 &lt;code&gt;e2&lt;/code&gt; 潜在的な結果の集合であります</target>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; がglvalue条件式である場合（ &lt;code&gt;e1?e2:e3&lt;/code&gt; 、ここでe2とe3はglvalueです）、 &lt;code&gt;e2&lt;/code&gt; と &lt;code&gt;e3&lt;/code&gt; の潜在的な結果の和集合が両方ともセットに含まれます。</target>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="translated">場合 &lt;code&gt;e&lt;/code&gt; ポインタ・ツー・メンバアクセス式である（ &lt;code&gt;e1.*e2&lt;/code&gt; または &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt; ）は、その第二オペランド定数式オブジェクト式E1の電位の結果であり、セットに含まれています</target>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="translated">場合は &lt;code&gt;e&lt;/code&gt; がある&lt;a href=&quot;expressions&quot;&gt;ID-式は&lt;/a&gt;、式 &lt;code&gt;e&lt;/code&gt; がその唯一の潜在的な結果であり、</target>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="translated">場合 &lt;code&gt;e&lt;/code&gt; 配列の添字式である（ &lt;code&gt;e1[e2]&lt;/code&gt; オペランドの一方が配列され、そのオペランドの潜在的な結果をセットに含まれています）</target>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="translated">場合 &lt;code&gt;e&lt;/code&gt; 、括弧内の式である（ &lt;code&gt;(e1)&lt;/code&gt; ）の電位結果 &lt;code&gt;e1&lt;/code&gt; セットに含まれています</target>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="translated">呼び出しの前に &lt;code&gt;eofbit&lt;/code&gt; がストリームに設定されている場合、監視オブジェクトの構築により &lt;code&gt;failbit&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;equiv(a,b)==true&lt;/code&gt; と &lt;code&gt;equiv(b,c)==true&lt;/code&gt; 場合、 &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;equiv(a,b)==true&lt;/code&gt; 場合、 &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">場合 &lt;code&gt;exit_code&lt;/code&gt; がある &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; 、正常終了を示す実装定義のステータスは、ホスト環境に戻されます。場合 &lt;code&gt;exit_code&lt;/code&gt; である &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; 示す、実装定義のステータス、</target>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">場合は &lt;code&gt;exp&lt;/code&gt; が 0である場合、 &lt;code&gt;x&lt;/code&gt; は、そのまま返されます</target>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; がクラス &lt;code&gt;T&lt;/code&gt; の&lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;メンバー関数へ&lt;/a&gt;のポインターである場合：</target>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;fail()==true&lt;/code&gt; 、返し &lt;code&gt;pos_type(-1)&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="translated">&lt;code&gt;failed()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返す場合、 &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; を呼び出して、文字 &lt;code&gt;c&lt;/code&gt; を関連するストリームバッファーに挿入します。ここで、 &lt;code&gt;pbuf&lt;/code&gt; は &lt;code&gt;streambuf_type*&lt;/code&gt; タイプのプライベートメンバーです。そうでなければ、何もしません。</target>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">場合は &lt;code&gt;first == last&lt;/code&gt; または &lt;code&gt;first1 == last1&lt;/code&gt; 、 &lt;code&gt;init&lt;/code&gt; は、そのまま返されます。</target>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first == last&lt;/code&gt; 場合、この関数は効果がなく、単に &lt;code&gt;d_first&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt; が含まれている場合、最初に一致したものだけが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt; が含まれている場合、一致しないサブシーケンスは &lt;code&gt;out&lt;/code&gt; にコピーされません。</target>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt; 、変換指定子を使用します &lt;code&gt;%a&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; 、変換指定子を使用します &lt;code&gt;%A&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt; 、変換を使用します指定子 &lt;code&gt;%f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt; 、使用する変換指定子 &lt;code&gt;%e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt; 、使用する変換指定 &lt;code&gt;%E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">もし &lt;code&gt;from&lt;/code&gt; と &lt;code&gt;to&lt;/code&gt; で決定されたのと同じファイルです &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt; 、エラーを報告</target>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">場合 &lt;code&gt;from&lt;/code&gt; 存在しない、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="translated">場合 &lt;code&gt;from&lt;/code&gt; ディレクトリですが、 &lt;code&gt;to&lt;/code&gt; 通常のファイルで、エラーを報告</target>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="translated">場合 &lt;code&gt;from&lt;/code&gt; シンボリックリンクになって、その後、</target>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;from_stream&lt;/code&gt; がフォーマット文字列で指定されたすべての解析に失敗した場合、または完全な結果を指定するのに不十分な情報が解析された場合、または解析が矛盾する情報を開示した場合、 &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;from_stream&lt;/code&gt; がフォーマット文字列で指定されたすべての解析に失敗した場合、または完全な結果を指定するのに不十分な情報が解析された場合、または解析が矛盾する情報を開示した場合、 &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; がvolatile修飾されている場合（つまり、cv修飾子が &lt;code&gt;volatile&lt;/code&gt; または &lt;code&gt;const volatile&lt;/code&gt; のいずれかである場合）、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">もし &lt;code&gt;get() == nullptr&lt;/code&gt; 影響はありません。それ以外の場合、所有されたオブジェクトは&lt;a href=&quot;get_deleter&quot;&gt; &lt;code&gt;get_deleter()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;get&quot;&gt; &lt;code&gt;(get())&lt;/code&gt; &lt;/a&gt;によって破棄されます。</target>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;good() == true&lt;/code&gt; 、リターンによって得られたとして、次の文字 &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="translated">&lt;code&gt;has_relative_path()&lt;/code&gt; がfalseを返す場合、結果は &lt;code&gt;*this&lt;/code&gt; のコピーになります。それ以外の場合、結果は、ジェネリックフォーマットパス名が &lt;code&gt;*this&lt;/code&gt; のジェネリックフォーマットパス名の最長の接頭辞であり、反復で生成される要素が1つ少ないパスです。</target>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;i == j&lt;/code&gt; とは、 &lt;code&gt;(i, j)&lt;/code&gt; のドメイン内にある &lt;code&gt;==&lt;/code&gt; これは同等です &lt;code&gt;*j&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="translated">このオブジェクトに対して &lt;code&gt;imbue()&lt;/code&gt; が呼び出されたことがない場合は、呼び出し時のグローバルロケールが返されます。それ以外の場合は、 &lt;code&gt;imbue()&lt;/code&gt; の最後の呼び出しに渡されたロケールが返されます。</target>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="translated">&lt;code&gt;in==end&lt;/code&gt; 場合、ステージ2は直ちに終了し、それ以上の文字は抽出されません</target>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="translated">&lt;code&gt;index() == 0&lt;/code&gt; 場合、年と月の最初の &lt;code&gt;weekday()&lt;/code&gt; の7日前の日付を表す &lt;code&gt;sys_days&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="translated">&lt;code&gt;is.good()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;is.setstate(failbit)&lt;/code&gt; を呼び出し（c ++ 11以降）、戻ります。それ以外の場合で、 &lt;code&gt;is.tie()&lt;/code&gt; がnullポインターでない場合は、 &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; を呼び出して、出力シーケンスを外部ストリームと同期させます。 &lt;code&gt;is.tie()&lt;/code&gt; の put領域が空の場合、この呼び出しを抑制できます。実装は、 &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; の呼び出しが発生するまで &lt;code&gt;flush&lt;/code&gt; の呼び出しを延期する場合があります。歩哨オブジェクトが破壊される前にそのような呼び出しが発生しない場合、それは完全に除去される可能性があります。</target>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt; 、結果はに等しいです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt; 場合|| （！isnan（t）&amp;amp;&amp;amp; ba！= 0）、結果は &lt;code&gt;NaN&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">&lt;code&gt;islower&lt;/code&gt; がゼロ以外の値を返す場合、 &lt;code&gt;iscntrl&lt;/code&gt; 、 &lt;code&gt;isdigit&lt;/code&gt; 、 &lt;code&gt;isspace&lt;/code&gt; 、および &lt;code&gt;ispunct&lt;/code&gt; が同じCロケールの同じ文字に対してゼロを返すことが保証されます。</target>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">&lt;code&gt;isupper&lt;/code&gt; がゼロ以外の値を返す場合、 &lt;code&gt;iscntrl&lt;/code&gt; 、 &lt;code&gt;isdigit&lt;/code&gt; 、 &lt;code&gt;isspace&lt;/code&gt; 、および &lt;code&gt;ispunct&lt;/code&gt; が同じCロケールの同じ文字に対してゼロを返すことが保証されます。</target>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;lock&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; をすでに所有しているスレッドによって &lt;code&gt;lock&lt;/code&gt; が呼び出された場合、動作は定義されていません。たとえば、プログラム</target>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（排他モードまたは共有モード）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;lock_shared&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">場合は &lt;code&gt;member&lt;/code&gt; ある&lt;a href=&quot;../language/static&quot;&gt;静的メンバ&lt;/a&gt;や&lt;a href=&quot;../language/member_functions&quot;&gt;メンバ関数&lt;/a&gt;、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">&lt;code&gt;mode &amp;gt; 0&lt;/code&gt; 場合、 &lt;code&gt;stream&lt;/code&gt; ワイド指向にしようとします。 &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; 場合、 &lt;code&gt;stream&lt;/code&gt; バイト指向にしようとします。 &lt;code&gt;mode==0&lt;/code&gt; 場合、ストリームの現在の方向のみを照会します。</target>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="translated">場合 &lt;code&gt;money_base::space&lt;/code&gt; または &lt;code&gt;money_base::none&lt;/code&gt; の最後の要素である &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 、パーサは、金銭的価値の他のコンポーネントが解析された後に空白を消費しようとしません。それ以外の場合、 &lt;code&gt;money_base::space&lt;/code&gt; が表示される場所で1つ以上の空白文字が消費されます。</target>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="translated">&lt;code&gt;mp.grouping()&lt;/code&gt; が1000単位の区切り文字を許可しない場合、最初に遭遇した区切り文字は解析エラーとして扱われ、それ以外の場合はオプションとして扱われます。</target>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;mp.positive_sign()&lt;/code&gt; （正のフォーマットパターンが使用される場合）又は &lt;code&gt;mp.negative_sign()&lt;/code&gt; （負のフォーマットパターンを使用する場合には）複数の文字の文字列を返し、最初の文字が返さは、ここで出力シーケンス内に配置されます &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; はフォーマットパターンに表示され、残りの文字は他のすべての文字の後に配置されます。たとえば、フォーマットパターン &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; 単位が &lt;code&gt;123&lt;/code&gt; で、negative_signが &lt;code&gt;&quot;-&quot;&lt;/code&gt; 場合、結果は &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;()&quot;&lt;/code&gt; の negative_signは &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="translated">もし &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; 、文字列が表します</target>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="translated">もし &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; の長さ</target>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="translated">もし &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; の最初の文字の位置</target>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="translated">場合 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; と &lt;code&gt;n &amp;lt; size()&lt;/code&gt; 、参照返し &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; にマッチした標的配列の一部を表すと</target>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="translated">&lt;code&gt;n == 0&lt;/code&gt; 場合、一致した式全体を表す文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="translated">&lt;code&gt;n == 0&lt;/code&gt; 場合、一致した正規表現全体と一致したターゲットシーケンスの部分を表す &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; への参照を返します。</target>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="translated">場合 &lt;code&gt;n == 0&lt;/code&gt; 、カウント範囲が有効であり、空です。それ以外の場合、カウント範囲は、nが正であり、iが逆参照可能で、 &lt;code&gt;[++i, --n)&lt;/code&gt; が有効なカウント範囲である場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="translated">&lt;code&gt;n == 0&lt;/code&gt; 場合、一致した式全体の長さが返されます。</target>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="translated">&lt;code&gt;n == 0&lt;/code&gt; 場合、一致した式全体の最初の文字の位置が返されます。</target>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が128以上の場合、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が128以上の場合、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="translated">場合 &lt;code&gt;n&lt;/code&gt; は配列内の要素の数よりも大きい場合、選択 &lt;code&gt;last-first&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">場合は &lt;code&gt;n&lt;/code&gt; 負の場合、イテレータが減少します。この場合、 &lt;code&gt;InputIt&lt;/code&gt; は&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;の要件を満たす必要があります。そうでない場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">場合 &lt;code&gt;n&lt;/code&gt; または &lt;code&gt;m&lt;/code&gt; 大きいまたは128に等しい、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; より大きい場合、過去の終わりのイテレータを含むすべてのイテレータ、および要素へのすべての参照が無効になります。それ以外の場合、イテレータまたは参照は無効化されません。</target>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; が現在の &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; より大きい場合、新しいストレージが割り当てられ、 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;new_cap&lt;/code&gt; 以上になります。</target>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; が現在の &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 以下の場合、効果はありません。</target>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; が現在の &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; より小さい場合、これは非バインディングの縮小要求です。</target>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; が現在の &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; よりも小さい場合、これは非拘束の縮小に合わせる要求で、 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; と同等です（ C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">場合は &lt;code&gt;new_filename&lt;/code&gt; 存在し、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="translated">場合 &lt;code&gt;new_size&lt;/code&gt; がゼロであり、動作は実装が定義されている：NULLポインタが返されてもよい（この場合、古いメモリブロックがよいか、解放されなくてもよい）、またはいくつかの非ヌルポインタがアクセス記憶するために使用されないことが返されてもよいです。</target>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">場合 &lt;code&gt;noskipws&lt;/code&gt; がゼロとされ &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; ISゼロ以外、機能を抽出し、破棄（現在吹き込まれたロケールによって決定された次に使用可能な文字は、空白文字でなくなるまで、すべての空白文字 &lt;code&gt;is&lt;/code&gt; ）。場合 &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; または &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; を返すの &lt;code&gt;traits::eof()&lt;/code&gt; 、関数が呼び出されます &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; （投げること &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="translated">場合 &lt;code&gt;obj&lt;/code&gt; がデフォルトで構築できなかった、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">&lt;code&gt;old_p&lt;/code&gt; がディレクトリの場合、new_pは次の &lt;code&gt;new_p&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">場合 &lt;code&gt;old_p&lt;/code&gt; は、非ディレクトリファイルをある、そして &lt;code&gt;new_p&lt;/code&gt; のいずれかである必要があります</target>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;openmode&lt;/code&gt; がリストされているモードのいずれでもない場合、 &lt;code&gt;open()&lt;/code&gt; は失敗します。</target>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="translated">場合 &lt;code&gt;opts&lt;/code&gt; ある &lt;code&gt;perm_options::add&lt;/code&gt; 、ファイルの権限は正確に設定されている &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; （つまり、 &lt;code&gt;prms&lt;/code&gt; に設定されているが、ファイルの現在のアクセス許可には設定されていない有効なビットは、ファイルのアクセス許可に追加されます）</target>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="translated">場合 &lt;code&gt;opts&lt;/code&gt; ある &lt;code&gt;perm_options::remove&lt;/code&gt; 、ファイルのパーミッションが正確に設定されている &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; （意味、で明らかである任意の有効ビット &lt;code&gt;prms&lt;/code&gt; が、ファイルの中にセット現在の権限はファイルの権限でクリアされます）</target>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; が &lt;code&gt;perm_options::replace&lt;/code&gt; 場合、ファイル権限は正確に &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; 設定されます（つまり、 &lt;code&gt;prms&lt;/code&gt; のすべての有効なビットが適用されます）</target>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">もし &lt;code&gt;os.good()&lt;/code&gt; で &lt;code&gt;false&lt;/code&gt; を返します。それ以外の場合で、 &lt;code&gt;os.tie()&lt;/code&gt; がnullポインターでない場合は、 &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; を呼び出して、出力シーケンスを外部ストリームと同期させます。準備中、コンストラクターは &lt;code&gt;setstate(failbit)&lt;/code&gt; を呼び出すことがあります（これ &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; がスローされる場合があります）。</target>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="translated">&lt;code&gt;os.rdbuf()&lt;/code&gt; が実際に &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; をポイントしている場合、フラッシュ時にエミットする（つまり、基になるストリームバッファーにデータを送信する）かどうかを切り替えます。</target>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="translated">場合 &lt;code&gt;other&lt;/code&gt; 値が含まれ、次にかどうかに応じて &lt;code&gt;*this&lt;/code&gt; 値が含まれ、含まれる値のいずれかで&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初期化&lt;/a&gt;又はから割り当て &lt;code&gt;*other&lt;/code&gt; （2）または &lt;code&gt;std::move(*other)&lt;/code&gt; （3）。移動したオプションの静止画</target>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="translated">場合 &lt;code&gt;other&lt;/code&gt; 値が含まれ、次にかどうかに応じて &lt;code&gt;*this&lt;/code&gt; 値が含まれ、含まれる値のいずれかで&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初期化&lt;/a&gt;又はから割り当て &lt;code&gt;*other&lt;/code&gt; （5）または &lt;code&gt;std::move(*other)&lt;/code&gt; （6）。移動したオプションの静止画</target>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; が &lt;code&gt;*this&lt;/code&gt; と同じオブジェクトを参照している場合、効果はありません。それ以外の場合は、ストリーム &lt;code&gt;other&lt;/code&gt; の状態を &lt;code&gt;*this&lt;/code&gt; にコピーします。これは次の順序で行われます。</target>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="translated">場合 &lt;code&gt;out_stream&lt;/code&gt; に関連へのポインタである &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;delim&lt;/code&gt; このオブジェクトの構築時に指定された区切り文字であり、次に、効果は同等です。</target>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">&lt;code&gt;p == 1&lt;/code&gt; 場合、 &lt;code&gt;param_type&lt;/code&gt; オブジェクトを受け入れない&lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt;オーバーロードへの後続の呼び出しは、未定義の動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; が存在しない場合、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;p&lt;/code&gt; が存在しない場合、戻り &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;p&lt;/code&gt; が存在するが、ファイルの属性が権限の欠如、リターンのために例えば、決定することはできません &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="translated">もし &lt;code&gt;p&lt;/code&gt; が実装定義ファイルタイプを有し、戻り &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; は、実装定義であります&lt;a href=&quot;file_type&quot;&gt; &lt;code&gt;file_type&lt;/code&gt; &lt;/a&gt;その型の定数。</target>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; ブロック特殊ファイルである（POSIXたかのよう &lt;code&gt;S_ISBLK&lt;/code&gt; ）、リターン &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;p&lt;/code&gt; 文字型特殊ファイルである（POSIXたかのよう &lt;code&gt;S_ISCHR&lt;/code&gt; ）、リターン &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; ディレクトリです（POSIXたかのよう &lt;code&gt;S_ISDIR&lt;/code&gt; 、）戻っ &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;p&lt;/code&gt; は FIFOまたはパイプファイルである（POSIXたかのよう &lt;code&gt;S_ISFIFO&lt;/code&gt; ）、戻り &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;p&lt;/code&gt; は（POSIXたかのよう通常のファイルである &lt;code&gt;S_ISREG&lt;/code&gt; 戻り、） &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;p&lt;/code&gt; はソケットである（POSIXたかのよう &lt;code&gt;S_ISSOCK&lt;/code&gt; ）戻り &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; がシンボリックリンクの場合、 &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt; 返します</target>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;parm_n&lt;/code&gt; が参照型または&lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;デフォルトの引数のプロモーションの&lt;/a&gt;結果として生じる型と互換性のない型で宣言されている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="translated">場合 &lt;code&gt;path::value_type&lt;/code&gt; ある &lt;code&gt;char&lt;/code&gt; がネイティブエンコーディングがUTF-8である、によって直接的にかのようにパスを構築 &lt;code&gt;path(source)&lt;/code&gt; 又は &lt;code&gt;path(first, last)&lt;/code&gt; 。注：これは、Linuxなど、Unicodeを使用するPOSIXシステムの一般的な状況です。</target>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="translated">場合 &lt;code&gt;path::value_type&lt;/code&gt; ある &lt;code&gt;char&lt;/code&gt; 、変換があれば、システムに依存します。これは、ネイティブエンコーディングがUTF-8であり、 &lt;code&gt;string()&lt;/code&gt; が変換を行わない典型的なPOSIXシステム（Linuxなど）の場合です。</target>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="translated">場合 &lt;code&gt;placement_params&lt;/code&gt; が提供され、彼らは追加の引数として割り当て関数に渡されます。このような割り当て関数は、標準の割り当て関数 &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt; 後に「配置new」と呼ばれ、2番目の引数を変更せずに返すだけです。これは、割り当てられたストレージにオブジェクトを構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;pos &amp;gt; size()&lt;/code&gt; 場合、 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; 場合、このコンストラクタは &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; スローします。 &lt;code&gt;str&lt;/code&gt; で調べた文字が &lt;code&gt;zero&lt;/code&gt; でも &lt;code&gt;one&lt;/code&gt; ない場合は、 &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">もし &lt;code&gt;pos == size()&lt;/code&gt; は、値を持つ文字への参照 &lt;code&gt;CharT()&lt;/code&gt; （ヌル文字）が返されます。</target>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; がnullポインターでない場合、ポインター &lt;code&gt;ptr&lt;/code&gt; (変換関数の内部 &lt;code&gt;str.c_str()&lt;/code&gt; はstr.c_str（）の最初の未変換文字のアドレスを受け取り、その文字のインデックスが計算されて &lt;code&gt;*pos&lt;/code&gt; に保存されます。変換によって処理された文字数を示します。</target>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; がnullポインターでない場合、変換関数の内部にあるポインター &lt;code&gt;ptr&lt;/code&gt; は、 &lt;code&gt;str.c_str()&lt;/code&gt; で最初の未変換文字のアドレスを受け取り、その文字のインデックスが計算されて次の場所に格納されます。 &lt;code&gt;*pos&lt;/code&gt; にます。変換によって処理された文字数を示します。</target>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; がコンテナーの範囲内にない場合、タイプ &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">&lt;code&gt;ps&lt;/code&gt; がNULLポインターでない場合、 &lt;code&gt;mbsinit&lt;/code&gt; 関数は、ポイントされた &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; オブジェクトが初期変換状態を記述しているかどうかを判別します。</target>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">場合 &lt;code&gt;ptr&lt;/code&gt; が NULLポインタである、動作が呼び出した場合と同じである &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;new_size&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">場合 &lt;code&gt;ptr&lt;/code&gt; が NULLポインタで、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; が空の場合、新しい &lt;code&gt;shared_ptr&lt;/code&gt; も空になります（ただし、その格納されたポインターは必ずしもnullであるとは限りません）。それ以外の場合、新しい &lt;code&gt;shared_ptr&lt;/code&gt; は、 &lt;code&gt;r&lt;/code&gt; の初期値と所有権を共有します。ただし、 &lt;code&gt;dynamic_cast&lt;/code&gt; によって &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; 実行された場合は空になります。がnullポインターを返したます。</target>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; がnullでない場合、デフォルトのメモリリソースポインタを &lt;code&gt;r&lt;/code&gt; に設定します。それ以外の場合は、デフォルトのメモリリソースポインタを &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;rand()&lt;/code&gt; への呼び出しの前に使用されている &lt;code&gt;srand()&lt;/code&gt; 、 &lt;code&gt;rand()&lt;/code&gt; それはを播種したかのように振る舞う &lt;code&gt;srand(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt; 、抽出物 &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; 文字格納し、第1の要素が指すcharacaterアレイの連続した位置に &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="translated">場合 &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt; 、呼び出し、 &lt;code&gt;setstate(eofbit)&lt;/code&gt; し、何の文字を抽出していません。</target>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="translated">もし &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt; 、何の文字を抽出していません。</target>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; が &lt;code&gt;Traits::eof()&lt;/code&gt; 返す場合、 &lt;code&gt;setstate(badbit)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;rdbuf()&lt;/code&gt; nullの場合、または &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; 返し &lt;code&gt;Traits::eof()&lt;/code&gt; を呼び出します &lt;code&gt;setstate(badbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="translated">もし &lt;code&gt;rep_&lt;/code&gt; メンバ変数である持続オブジェクトにダニの数を保持し、</target>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="translated">場合 &lt;code&gt;rep_&lt;/code&gt; メンバ変数である持続オブジェクトにダニの数を保持し、そして &lt;code&gt;D&lt;/code&gt; 戻り型であり、</target>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="translated">もし &lt;code&gt;rep_&lt;/code&gt; メンバ変数であるこの期間オブジェクトにダニの数を保持し、</target>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタであり &lt;code&gt;n&lt;/code&gt; ゼロであり、たfilebufとなります</target>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタであり &lt;code&gt;n&lt;/code&gt; ゼロであり、この関数は効果がありません。</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタであり、初期シフト状態戻る表すために、内部変換状態をリセット &lt;code&gt;​0​&lt;/code&gt; 現在のマルチバイト符号化は、現在のマルチバイトなら状態依存（シフトシーケンスを使用しない）または非ゼロの値でない場合エンコードは状態に依存します（シフトシーケンスを使用します）。</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; がnullポインターの場合、グローバル変換状態をリセットし、シフトシーケンスを使用するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタで、呼び出しは同等です &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; いくつかの内部バッファ用 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタで、呼び出しは同等です &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; いくつかの内部バッファ用 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタで、呼び出しは同等です &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; いくつかの内部バッファ用 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタである、呼び出しは同等です &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; いくつかの内部バッファ用 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタの値が &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;pc16&lt;/code&gt; 無視され、呼び出しと等価であるれる &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタの値が &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;pc32&lt;/code&gt; 無視され、呼び出しと等価であるれる &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタであり、値 &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;pc8&lt;/code&gt; 無視され、呼び出しは以下と等価であるれる &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタであり、値 &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;pwc&lt;/code&gt; 無視され、呼び出しは以下と等価であるれる &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタではなく、 &lt;code&gt;c16&lt;/code&gt; コードポイントの有効な可変長符号化の最後の16ビット・コード部であり、この関数はいずれかを含む、そのコードポイントのマルチバイト文字表現を格納するのに必要なバイト数を（決定しますシーケンスをシフトし、現在のマルチバイト変換状態（ &lt;code&gt;*ps&lt;/code&gt; ）を考慮に入れて、マルチバイト文字表現を、最初の要素が &lt;code&gt;s&lt;/code&gt; によってポイントされる文字配列に格納し、必要に応じて &lt;code&gt;*ps&lt;/code&gt; を更新します。この関数では、最大で &lt;code&gt;MB_CUR_MAX&lt;/code&gt; バイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタではなく、 &lt;code&gt;c8&lt;/code&gt; コードポイントの有効なUTF-8エンコーディングの最後のコード部であり、この関数は、任意のシフト配列を含むそのコードポイントのマルチバイト文字表現を格納するのに必要なバイト数を（決定します現在のマルチバイト変換状態（ &lt;code&gt;*ps&lt;/code&gt; ）を考慮して、マルチバイト文字表現を、最初の要素が &lt;code&gt;s&lt;/code&gt; で指されている文字配列に格納し、必要に応じて &lt;code&gt;*ps&lt;/code&gt; を更新します。この関数では、最大で &lt;code&gt;MB_CUR_MAX&lt;/code&gt; バイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタではありません、最大で検査する &lt;code&gt;n&lt;/code&gt; がバイトがで指さで始まる、マルチバイト文字列のバイト &lt;code&gt;s&lt;/code&gt; （任意のシフトシーケンスを含む）、次のマルチバイト文字を完了するために必要なバイト数を決定します。関数が &lt;code&gt;s&lt;/code&gt; の次のマルチバイト文字が完全で有効であると判断した場合、それをUTF-8に変換し、最初のUTf-8コード単位を &lt;code&gt;*pc8&lt;/code&gt; に格納します（ &lt;code&gt;pc8&lt;/code&gt; がnullでない場合）。</target>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタではありません、最大で検査する &lt;code&gt;n&lt;/code&gt; がバイトがで指さで始まる、マルチバイト文字列のバイト &lt;code&gt;s&lt;/code&gt; （任意のシフトシーケンスを含む）、次のマルチバイト文字を完了するために必要なバイト数を決定します。関数が &lt;code&gt;s&lt;/code&gt; の次のマルチバイト文字が完全で有効であると判断した場合、それを対応する16ビット文字に変換し、 &lt;code&gt;*pc16&lt;/code&gt; に格納します（ &lt;code&gt;pc16&lt;/code&gt; の場合がnullでない）。</target>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタではありません、最大で検査する &lt;code&gt;n&lt;/code&gt; がバイトがで指さで始まる、マルチバイト文字列のバイト &lt;code&gt;s&lt;/code&gt; （任意のシフトシーケンスを含む）、次のマルチバイト文字を完了するために必要なバイト数を決定します。関数が &lt;code&gt;s&lt;/code&gt; の次のマルチバイト文字が完全で有効であると判断した場合、それを対応する32ビット文字に変換し、 &lt;code&gt;*pc32&lt;/code&gt; に格納します（ &lt;code&gt;pc32&lt;/code&gt; の場合がnullでない）。</target>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">場合は &lt;code&gt;s&lt;/code&gt; が NULLポインタではありません、最大で検査する &lt;code&gt;n&lt;/code&gt; がバイトがで指さで始まる、マルチバイト文字列のバイト &lt;code&gt;s&lt;/code&gt; （任意のシフトシーケンスを含む）、次のマルチバイト文字を完了するために必要なバイト数を決定します。関数が &lt;code&gt;s&lt;/code&gt; の次のマルチバイト文字が完全で有効であると判断した場合、対応するワイド文字に変換して &lt;code&gt;*pwc&lt;/code&gt; に格納します（ &lt;code&gt;pwc&lt;/code&gt; の場合）ますがnullでない）。</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタではなく、マルチバイト文字またはに含まれるバイト数を返す &lt;code&gt;-1&lt;/code&gt; 最初のバイトにより指さ場合 &lt;code&gt;s&lt;/code&gt; は有効なマルチバイト文字または形成しない &lt;code&gt;​0​&lt;/code&gt; 場合 &lt;code&gt;s&lt;/code&gt; はヌルcharcterで指しています &lt;code&gt;'\0'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">場合 &lt;code&gt;s&lt;/code&gt; がヌルポインタでない、のマルチバイト表現に含まれるバイト数を返し &lt;code&gt;wc&lt;/code&gt; または &lt;code&gt;-1&lt;/code&gt; 場合 &lt;code&gt;wc&lt;/code&gt; 有効な文字ではありませんが。</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; がnullポインターでない場合、関数は &lt;code&gt;c32&lt;/code&gt; のマルチバイト文字表現（シフトシーケンスを含み、現在のマルチバイト変換状態 &lt;code&gt;*ps&lt;/code&gt; を考慮に入れる）を格納するために必要なバイト数を決定し、マルチバイト文字表現を最初の要素が &lt;code&gt;s&lt;/code&gt; によってポイントされている文字配列。必要に応じて &lt;code&gt;*ps&lt;/code&gt; を更新します。この関数では、最大で &lt;code&gt;MB_CUR_MAX&lt;/code&gt; バイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; がnullポインターでない場合、関数は &lt;code&gt;wc&lt;/code&gt; のマルチバイト文字表現（シフトシーケンスを含み、現在のマルチバイト変換状態 &lt;code&gt;*ps&lt;/code&gt; を考慮に入れる）を格納するために必要なバイト数を決定し、マルチバイト文字表現を最初の要素が &lt;code&gt;s&lt;/code&gt; によってポイントされている文字配列。必要に応じて &lt;code&gt;*ps&lt;/code&gt; を更新します。この関数では、最大で &lt;code&gt;MB_CUR_MAX&lt;/code&gt; バイトを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; が他のコンテキストで表示される場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="translated">&lt;code&gt;showbase&lt;/code&gt; フラグが &lt;code&gt;str.flags()&lt;/code&gt; で設定されている場合、通貨記号または通貨文字列は必須です。設定されていない場合、通貨記号はオプションです。</target>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="translated">場合 &lt;code&gt;size()&lt;/code&gt; 0である &lt;code&gt;data()&lt;/code&gt; はnullポインタを返す場合と返さない場合があります。</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">場合 &lt;code&gt;size&lt;/code&gt; ゼロであり、動作は実装定義である（ヌルポインタが返されることがあり、またはいくつかの非ヌルポインタがアクセス記憶するために使用されないことが返されてもよいです）。</target>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">場合は &lt;code&gt;size&lt;/code&gt; ゼロであり、動作は定義された実装である（NULLポインタが返されることがあり、またはいくつかの非ヌル・ポインタがアクセス記憶装置に使用することはできませんが、それに合格しなければならないこと返却することができる &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">場合は &lt;code&gt;size&lt;/code&gt; や &lt;code&gt;count&lt;/code&gt; ゼロで、 &lt;code&gt;fread&lt;/code&gt; リターンはゼロと他のアクションを実行しません。</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">場合は &lt;code&gt;size&lt;/code&gt; や &lt;code&gt;count&lt;/code&gt; ゼロである、 &lt;code&gt;fwrite&lt;/code&gt; のリターンはゼロと他のアクションを実行しません。</target>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; 、何のインナーアロケータが宣言されなかったされ、リターンは &lt;code&gt;*this&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; への参照を返します。つまり、 &lt;code&gt;*this&lt;/code&gt; のすべての内部アロケーターで構成されるスコープ付きアロケーターで、最初の内部アロケーターが外部アロケーターになります。</target>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; 2よりも大きい（すなわち、 &lt;code&gt;T...&lt;/code&gt; タイプから成る &lt;code&gt;T1, T2, R...&lt;/code&gt; ）、次いで場合 &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; 、メンバーの存在 &lt;code&gt;type&lt;/code&gt; 意味を &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; そのようなタイプが存在する場合。それ以外の場合は、メンバー &lt;code&gt;type&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; （すなわち、2よりも大きい &lt;code&gt;T...&lt;/code&gt; タイプから成る &lt;code&gt;T1, T2, R...&lt;/code&gt; ）、次いで場合 &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; 、存在しますメンバー &lt;code&gt;type&lt;/code&gt; は、 &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; ます（そのようなタイプが存在する場合）。他のすべてのケースでは、メンバー &lt;code&gt;type&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; 1である（すなわち、 &lt;code&gt;T...&lt;/code&gt; 一種類のみ含まれてい &lt;code&gt;T0&lt;/code&gt; 、メンバーの） &lt;code&gt;type&lt;/code&gt; 名と同じタイプ &lt;code&gt;T0&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; 1である（すなわち、 &lt;code&gt;T...&lt;/code&gt; 一種類のみ含まれてい &lt;code&gt;T0&lt;/code&gt; 、メンバーの） &lt;code&gt;type&lt;/code&gt; 名と同じタイプ &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; 、それが存在する場合は、それ以外の場合、メンバー &lt;code&gt;type&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; 2である（すなわち、 &lt;code&gt;T...&lt;/code&gt; 丁度2種類含まれてい &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; を）、</target>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; 2である（すなわち、 &lt;code&gt;T...&lt;/code&gt; 2種類含まれてい &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; を）：</target>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sizeof...(T)&lt;/code&gt; ゼロである、何のメンバーが存在しない &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="translated">もし &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; またはタイプのいずれかであれば &lt;code&gt;Types&lt;/code&gt; 、完全なオブジェクト・タイプではありません、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="translated">同じファイルで &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;seekpos()&lt;/code&gt; を呼び出して &lt;code&gt;sp&lt;/code&gt; が取得されなかった場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">場合 &lt;code&gt;std::abs&lt;/code&gt; 型の引数で呼び出された &lt;code&gt;X&lt;/code&gt; よう &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; および &lt;code&gt;X&lt;/code&gt; は、に変換することはできません &lt;code&gt;int&lt;/code&gt; 型で&lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;不可欠なプロモーション&lt;/a&gt;、プログラムは悪いが形成されています。</target>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">場合 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 何もしてい &lt;code&gt;fetch_and&lt;/code&gt; メンバー（このメンバーだけのために提供されていない&lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;整数型&lt;/a&gt;）、プログラムが悪い形成されています。</target>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">場合 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 全く持っていない &lt;code&gt;fetch_xor&lt;/code&gt; 部材（このメンバーのみのために提供される&lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;整数型&lt;/a&gt;）、プログラムが悪い形成されています。</target>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="translated">&lt;code&gt;std::consume_header&lt;/code&gt; 場合バイト順マークで始まるファイルを読み込むときに選択されていない場合、Unicode文字U + FEFF（改行なしスペース幅ゼロ）は、文字列の内容の最初の文字として読み込まれます。</target>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="translated">場合 &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 参照され、これは、同じタイプの右辺値参照バージョンです。それ以外の場合（ラップされたイテレーターが値で戻る場合など）、これは &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 変更なし</target>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">場合は &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 、コールはへの最初の呼び出しとして扱われる &lt;code&gt;std::wcstok&lt;/code&gt; この特定のワイド文字列のため。この関数は、最初のワイド文字である</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">場合は &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 、コールはへの最初の呼び出しとして扱われ &lt;code&gt;strtok&lt;/code&gt; は、この特定の文字列のため。この関数は、最初の文字である</target>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 、呼び出しは後続の呼び出しとして扱われる &lt;code&gt;std::wcstok&lt;/code&gt; ：関数は、それは同じで、前の呼び出しでた場所から再開 &lt;code&gt;*ptr&lt;/code&gt; が。この動作は、最後に検出されたトークンに続くワイド文字へのポインターが &lt;code&gt;str&lt;/code&gt; として渡される場合と同じです。</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 、呼び出しが以降の呼び出しとして扱われる &lt;code&gt;strtok&lt;/code&gt; は：関数は、前の呼び出しにしたところから継続します。動作は、以前に格納されたポインタが &lt;code&gt;str&lt;/code&gt; として渡される場合と同じです。</target>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">場合 &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; 等しい &lt;code&gt;str.internal&lt;/code&gt; 、フィル文字が挿入される場所 &lt;code&gt;none&lt;/code&gt; または &lt;code&gt;space&lt;/code&gt; のフォーマットパターンに表示されます。</target>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">もし &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; 非ゼロである（ &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; マニピュレータを使用した）、次いで、通貨記号または文字列を呼び出すことによって生成される &lt;code&gt;mp.curr_symbol()&lt;/code&gt; 、出力シーケンスに配置された &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; に表示されフォーマットパターン。</target>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;str.width()&lt;/code&gt; （例えば、非ゼロである &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; ステージ2未満である後にだけ使用された）と、チャートの数 &lt;code&gt;str.width()&lt;/code&gt; 、その後のコピー &lt;code&gt;fill&lt;/code&gt; 文字は、位置に挿入されていることで示されていますシーケンスの長さを &lt;code&gt;str.width()&lt;/code&gt; にするパディング。</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; がnullポインターの場合、ライブラリパッケージ内で操作されたものやプログラムに直接アクセスできないものを含め、開いているすべての出力ストリームがフラッシュされます。</target>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="translated">もし &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt; 、結果は有限です。</target>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;t == 0&lt;/code&gt; 、結果はに等しいです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;t == 1&lt;/code&gt; 、結果はに等しい &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; が前の項目を満たさない場合、 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; は &lt;code&gt;(*t1).*f&lt;/code&gt; と同等です。* f</target>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; が前の項目を満たさない場合、 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; は &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="translated">場合 &lt;code&gt;t&lt;/code&gt; と &lt;code&gt;rv&lt;/code&gt; 同じオブジェクトを参照していない、の値 &lt;code&gt;t&lt;/code&gt; はの値に相当し &lt;code&gt;rv&lt;/code&gt; の割り当ての前に。</target>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; がうるう秒の挿入中の時点を表す場合、うるう秒の挿入前の &lt;code&gt;sys_time&lt;/code&gt; の最後の表現可能な値が返されます。他のすべての場合では、 &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="translated">&lt;code&gt;tbl&lt;/code&gt; がnullの場合、 &lt;code&gt;classic_table()&lt;/code&gt; はすべての分類メンバー関数によって使用されます。それ以外の場合、 &lt;code&gt;tbl&lt;/code&gt; は、少なくとも &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; サイズのマスクの配列の最初の要素へのポインターである必要があり、その配列は、このファセットのすべての分類メンバー関数で使用されます。</target>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="translated">場合 &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt; 、によってスローされた例外をスローする &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; 私は、インデックスされて（）。</target>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="translated">&lt;code&gt;time_point&lt;/code&gt; の精度が低い場合、値が丸められるか切り捨てられるかは、実装で定義されます。</target>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout_duration&lt;/code&gt; が &lt;code&gt;timeout_duration.zero()&lt;/code&gt; 以下の場合、関数は &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout_duration&lt;/code&gt; が &lt;code&gt;timeout_duration.zero()&lt;/code&gt; 以下の場合、関数は &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout_time&lt;/code&gt; がすでに経過している場合、この関数は &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout_time&lt;/code&gt; がすでに経過している場合、この関数は &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="translated">場合 &lt;code&gt;to&lt;/code&gt; は存在しません、最初の実行は &lt;code&gt;create_directory(to, from)&lt;/code&gt; （旧ディレクトリの属性のコピーを新しいディレクトリが作成されます）</target>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;tp&lt;/code&gt; が2つのUTC &lt;code&gt;time_point&lt;/code&gt; の間に存在しない時間を表す場合、それらの2つの &lt;code&gt;time_point&lt;/code&gt; は同じであり、その &lt;code&gt;time_point&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock()&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">すでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock_for(duration)&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_for&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">すでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_for&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock_shared()&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_shared_for&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_shared_until&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">&lt;code&gt;try_lock_until(time_point)&lt;/code&gt; が成功した場合、同じオブジェクトに対する以前の &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">いずれかのモード（共有または排他）ですでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_until&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">すでに &lt;code&gt;mutex&lt;/code&gt; を所有しているスレッドによって &lt;code&gt;try_lock_until&lt;/code&gt; が呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="translated">あれば &lt;code&gt;type&lt;/code&gt; 配列型である第一の正として指定されなければならないよりも、全ての寸法は、他の&lt;a href=&quot;constant_expression&quot;&gt;整数定数式&lt;/a&gt;（C ++ 14まで）&lt;a href=&quot;constant_expression&quot;&gt;定数式変換&lt;/a&gt;型の &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; よい（C ++ 14以降）が、第一次元 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 変換可能な任意の式であること。これは、実行時にサイズが定義された配列を直接作成する唯一の方法です。このような配列は、</target>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; が&lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;標準のレイアウトタイプ&lt;/a&gt;でない場合、動作は未定義です（C ++ 17まで） &lt;code&gt;offsetof&lt;/code&gt; マクロの使用は条件付きでサポートされています（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="translated">あれば &lt;code&gt;typeid&lt;/code&gt; （コンストラクターを含む、デストラクタまたはコンストラクタで建設中のオブジェクトまたは破壊に使用される&lt;a href=&quot;constructor&quot;&gt;初期化リスト&lt;/a&gt;または&lt;a href=&quot;data_members#Member_initialization&quot;&gt;デフォルトメンバ初期化子&lt;/a&gt;）、次いで &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; オブジェクトはこのによって参照 &lt;code&gt;typeid&lt;/code&gt; に構成されているクラスを表すか、または最も派生したクラスでなくても破棄されます。</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;ungetc&lt;/code&gt; 複数の介在読取り、または再配置することなく何度も呼ばれ、それは失敗することがあり（すなわち、サイズ1のプッシュバックバッファが保証されているが、任意の大きなバッファは、実装定義です）。複数の &lt;code&gt;ungetc&lt;/code&gt; が正常に実行された場合、読み取り操作は、 &lt;code&gt;ungetc&lt;/code&gt; の逆の順序でプッシュバックされた文字を取得します。</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;ungetwc&lt;/code&gt; は複数の介在読取り、または再配置することなく何度も呼ばれ、それは失敗することがあり（すなわち、サイズ1のプッシュバックバッファが保証されているが、任意の大きなバッファは、実装定義です）。複数の正常な &lt;code&gt;ungetwc&lt;/code&gt; が実行された場合、読み取り操作はプッシュバックされたワイド文字を &lt;code&gt;ungetwc&lt;/code&gt; の逆の順序で取得します。</target>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="translated">場合は &lt;code&gt;using: namespace&lt;/code&gt; 属性リストの先頭に表示されますが、属性リストには他の属性は、名前空間を指定することはできません：名前空間を使用して指定されたそれらすべてに適用されます。</target>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">もし &lt;code&gt;v.index() != w.index()&lt;/code&gt; 、返品 &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">もし &lt;code&gt;v.index() != w.index()&lt;/code&gt; 、返品 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;v.valueless_by_exception()&lt;/code&gt; の場合、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">もし &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; 、返品 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; がどちらかの境界と等しい場合、境界ではなく &lt;code&gt;v&lt;/code&gt; への参照を返します。</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">場合 &lt;code&gt;va_arg&lt;/code&gt; には複数の引数がないときに呼び出され &lt;code&gt;ap&lt;/code&gt; 、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;w.valueless_by_exception()&lt;/code&gt; の場合、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;w.valueless_by_exception()&lt;/code&gt; の場合、 &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">&lt;code&gt;wc&lt;/code&gt; がヌル文字の場合、ヌルバイトは &lt;code&gt;s&lt;/code&gt; に書き込まれ、その前に初期シフト状態を復元するために必要なシフトシーケンスが続きます。</target>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">場合 &lt;code&gt;which&lt;/code&gt; を含む &lt;code&gt;ios_base::in&lt;/code&gt; 場合、である（この緩衝液は、読み取りのために開いている &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt; ）、次にポインタリードを再配置 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 内部下記のようにエリアを取得</target>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">場合 &lt;code&gt;which&lt;/code&gt; 含む &lt;code&gt;ios_base::in&lt;/code&gt; このバッファが読み出し用にオープンされ、その後、リードポインタ再配置 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 以下に説明するように、GET領域内</target>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">場合 &lt;code&gt;which&lt;/code&gt; 含まれ &lt;code&gt;ios_base::out&lt;/code&gt; し、このバッファは（、である書き込み用に開かれて &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt; 、その後、再配置書き込みポインタ） &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; 内部プットエリア下記の通り</target>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">もし &lt;code&gt;which&lt;/code&gt; が含ま &lt;code&gt;ios_base::out&lt;/code&gt; し、このバッファは、書き込み用に開かれている場合、書き込みポインタ再配置 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; プット・エリア内の下記のように</target>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">場合は &lt;code&gt;which&lt;/code&gt; 両方を含む &lt;code&gt;ios_base::in&lt;/code&gt; や &lt;code&gt;ios_base::out&lt;/code&gt; 、バッファが読み取りと書き込み（両方のために開かれている &lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt; ）、および &lt;code&gt;dir&lt;/code&gt; は &lt;code&gt;ios_base::beg&lt;/code&gt; または &lt;code&gt;ios_base::end&lt;/code&gt; いずれかであり、次に説明するように、読み取りポインターと書き込みポインターの両方を再配置します。</target>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">場合 &lt;code&gt;which&lt;/code&gt; 両方を含む &lt;code&gt;ios_base::in&lt;/code&gt; し、 &lt;code&gt;ios_base::out&lt;/code&gt; 、バッファが読み出しと書き込みの両方のために開放され、そして &lt;code&gt;when&lt;/code&gt; のいずれかである &lt;code&gt;ios_base::beg&lt;/code&gt; または &lt;code&gt;ios_base::end&lt;/code&gt; 後述のように、次に読み出し及び書き込みポインタの両方を再配置します。</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 両方ともゼロであり、ドメイン・エラー</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 両方ともゼロであり、範囲エラーのいずれかが発生しません</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&amp;plusmn;&amp;infin;で &lt;code&gt;y&lt;/code&gt; がNaNでない場合、NaNが返され、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、&amp;plusmn;0が返され、&amp;plusmn;&amp;infin;が &lt;code&gt;*iptr&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&amp;plusmn;&amp;infin;の場合、変更されずに返されます</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; が &amp;plusmn;0であり、 &lt;code&gt;y&lt;/code&gt; が &amp;plusmn;0が返され、ゼロではありません</target>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&amp;plusmn;0の場合、&amp;plusmn;0が返され、&amp;plusmn;0が &lt;code&gt;*iptr&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&amp;plusmn;0の場合、変更されずに返されます</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;&amp;plusmn;0&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が負であり、 &lt;code&gt;-&amp;pi;/2&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 及び &lt;code&gt;y&lt;/code&gt; は正で、 &lt;code&gt;+&amp;pi;/2&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;+&amp;infin;&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が有限で負である、 &lt;code&gt;-0&lt;/code&gt; 返されます</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;+&amp;infin;&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は有限で正、 &lt;code&gt;+0&lt;/code&gt; 返されます</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;-&amp;infin;&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が有限で負である、 &lt;code&gt;-&amp;pi;&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;-&amp;infin;&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が有限で正である、 &lt;code&gt;+&amp;pi;&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNaNの場合、NaNが返されます</target>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNaNの場合、NaNが返され、NaNは &lt;code&gt;*iptr&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNaNの場合、 &lt;code&gt;y&lt;/code&gt; の符号付きのNaN が返されます。</target>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; 負の場合、ドメインエラーが発生することがあります</target>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; ゼロではない、以下2つの最大積算電力を算出する &lt;code&gt;x&lt;/code&gt; 。場合は &lt;code&gt;x&lt;/code&gt; ゼロで、リターンはゼロ。</target>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; ゼロでない場合、値の格納に必要なビット数を算出する &lt;code&gt;x&lt;/code&gt; \、（1 + \ lfloor log_2（X）\ rfloor \）1 +床である、（ログ</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">場合は &lt;code&gt;y&lt;/code&gt; が &amp;plusmn;&amp;infin;とある &lt;code&gt;x&lt;/code&gt; が有限で、 &lt;code&gt;x&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; が&amp;plusmn;0で &lt;code&gt;x&lt;/code&gt; がNaNでない場合、NaNが返され、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; が -0実装は算術演算で一貫して署名されたゼロをサポートしている場合、結果は、陰性です。</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; があり &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; ある &lt;code&gt;+&amp;infin;&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; があり &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; IS &lt;code&gt;-&amp;infin;&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; が返され</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; があり &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; かつ &lt;code&gt;x&lt;/code&gt; が有限であり、 &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; に戻されます</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; があり &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 及び &lt;code&gt;x&lt;/code&gt; 負であるか、または &lt;code&gt;-0&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; 返されます</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; があり &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 及び &lt;code&gt;x&lt;/code&gt; は正または &lt;code&gt;+0&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">場合は &lt;code&gt;y&lt;/code&gt; がゼロであるが、ドメインエラーが発生していない、ゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; がゼロである、極エラーが発生していません</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; がゼロの場合、 &lt;code&gt;*quo&lt;/code&gt; に格納される値は指定されていません。</target>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt; 早く返し、 &lt;code&gt;sys_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt; 、後で返す &lt;code&gt;sys_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; （虚数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （実数部の符号は不定である）と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させる（実数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; （虚数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （実数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; （虚数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の有限非ゼロYの場合）、結果は &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の有限非ゼロYの場合）、結果は &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の有限の正のyの場合）、結果は &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の有限の正のyの場合）、結果は &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の有限の正のyの場合）、結果は &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の正の有限Yの場合）、結果は &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の正の有限のYの場合）、結果は &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （任意の正の有限Yの場合）、結果は &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; のための有限の正のyは</target>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; （実数部の符号は不定である）と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚数部の符号は不定である）と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させます</target>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; を上昇させます</target>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+0,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(+1,+0)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; を上昇させます</target>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; （符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; （符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; （不特定の虚数部の符号）</target>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （任意の有限の正のyの場合）、結果は &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （任意の有限Yの場合）、結果は &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （任意の正の有限Yの場合）、結果は &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （任意の正の有限Yの場合）、結果は &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; 、結果は &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 有限の正のyについて</target>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(-0,+0)&lt;/code&gt; 、結果は &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （実数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; （実数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+0)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚数部の符号が指定されていません）</target>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+0)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,+y)&lt;/code&gt; （任意の有限非ゼロyについて）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; （任意の有限非ゼロYの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; （任意の有限Yの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; （任意の有限Yの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させることができます。</target>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; （ゼロ以外のYの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; （任意のゼロでないYの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(NaN,y)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の有限非ゼロXの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の有限の正のxの場合）、結果は &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の有限Xの場合）、結果は &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の有限Xの場合）、結果は &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の有限Xの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させます。</target>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の正の有限のxの場合）、結果は &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （任意の正の有限のxの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （いずれかのための&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;の有限X）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させ</target>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; がある &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; 、結果は &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; xがNaNである場合であっても</target>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意の有限非ゼロXの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意の有限非ゼロXの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意の有限Xの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意の有限Xの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させることができます。</target>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意のゼロでない有限のxについて）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させることができます。</target>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （任意の正の有限のxの場合）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （いずれかのために&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;の有限x）は、結果がされている &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです。</target>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; （いずれかのために&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;有限X）、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">場合 &lt;code&gt;z&lt;/code&gt; である &lt;code&gt;(x,NaN)&lt;/code&gt; 、結果は &lt;code&gt;(NaN,NaN)&lt;/code&gt; （xは&amp;plusmn;&amp;infin;ない限り）および &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; を上昇させてもよいです</target>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="translated">A が関数のパラメータ パックから変換された場合、推論に失敗します(C++14 まで)。</target>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="translated">Cが初期化子リストコンストラクターではなく、初期化子リストにcv修飾されたXの要素が1つある場合、暗黙の変換シーケンスは完全一致ランクになります。初期化リストに、Xから派生したcv修飾型の可能性がある単一の要素がある場合、暗黙の変換シーケンスには変換ランクがあります。（集約との違いに注意してください：集約は、集約の初期化を検討する前に単一要素の初期リストから直接&lt;a href=&quot;aggregate_initialization&quot;&gt;初期化し&lt;/a&gt;、非集約は、他のコンストラクターの前にinitializer_listコンストラクターを検討します）</target>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="translated">Pが関数パラメータパックの場合、引数テンプレートの残りの各パラメータ型の型Aが、関数パラメータパックの宣言子IDの型Pと比較されます。各比較は、関数パラメータ・パックによって展開されたテンプレート・パラメータ・パック内の後続の位置のテンプレート引数を推論します。</target>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="translated">ステージ2が &lt;code&gt;in==end&lt;/code&gt; のテストで終了した場合、 &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; が実行されてeofビットが設定されます。</target>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="translated">イニシャライザを持つIf文</target>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">生成されるUTF-8コード単位が &lt;code&gt;u8'\0'&lt;/code&gt; 場合、変換状態 &lt;code&gt;*ps&lt;/code&gt; は初期シフト状態を表します。</target>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; のマルチバイト文字のUTF-8エンコードが複数のUTF-8コード単位で構成されている場合、この関数の最初の呼び出しの後に、 &lt;code&gt;*ps&lt;/code&gt; が更新されて、 &lt;code&gt;mbrtoc8&lt;/code&gt; への次の呼び出しが &lt;code&gt;*s&lt;/code&gt; を考慮しない、追加のUTF-8コード単位。</target>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="translated">場合は&lt;a href=&quot;friend&quot;&gt;、フレンド&lt;/a&gt;宣言がデフォルトを指定し、それがフレンド関数の定義である必要があり、この機能の他の宣言は翻訳単位で許可されていません。</target>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">場合は&lt;a href=&quot;lambda&quot;&gt;ラムダ式は、&lt;/a&gt;デフォルトの引数で表示され、それが明示的または暗黙的に何かをキャプチャすることはできません。</target>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="translated">&lt;a href=&quot;parameter_pack&quot;&gt;パラメータパック&lt;/a&gt;が最後の &lt;code&gt;P&lt;/code&gt; として表示される場合、タイプ &lt;code&gt;P&lt;/code&gt; は、呼び出しの残りの各引数のタイプ &lt;code&gt;A&lt;/code&gt; と照合されます。一致ごとに、パック展開の次の位置のテンプレート引数が推定されます。</target>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="translated">場合は &lt;code&gt;choose&lt;/code&gt; 渡されず、あいまいなまたは存在しないローカルタイムが検出され、A &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; か &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; （該当する場合）例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;va_list&lt;/code&gt; のインスタンスは、作成した別の関数に渡され、経由で使用されている &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; その関数には、関数呼び出しのいずれかのその後の使用はへの呼び出しによって先行されなければならない &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="translated">MoveAssignableクラスが移動割り当て演算子を実装している場合、割り当て後の &lt;code&gt;rv&lt;/code&gt; の値が指定されていないという事実を利用するために、&lt;a href=&quot;../utility/move&quot;&gt;移動セマンティクス&lt;/a&gt;も実装できます。</target>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">MoveConstructibleクラスが移動コンストラクターを実装している場合、構築後の &lt;code&gt;rv&lt;/code&gt; の値が指定されていないという事実を利用するために、&lt;a href=&quot;../utility/move&quot;&gt;移動セマンティクス&lt;/a&gt;も実装できます。</target>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="translated">UTF-8文字列リテラルと幅の広い文字列リテラルが並んでいる場合、プログラムは不定形になります。</target>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="translated">最後に &lt;code&gt;emit()&lt;/code&gt; を呼び出してから&lt;a href=&quot;sync&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt;呼び出しが行われた場合は、ラップされたストリームに対して&lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt; &lt;code&gt;pubsync()&lt;/code&gt; &lt;/a&gt;を呼び出して、それをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sprintf&lt;/code&gt; または &lt;code&gt;snprintf&lt;/code&gt; の呼び出しにより、重複するオブジェクト間でコピーが行われる場合、動作は未定義です（例： &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="translated">呼び出し場合 &lt;code&gt;try_lock&lt;/code&gt; が失敗し、へのさらなる呼び出し &lt;code&gt;try_lock&lt;/code&gt; が行われ、される &lt;code&gt;unlock&lt;/code&gt; すべてのロックされたオブジェクトのために呼ばれず、 &lt;code&gt;0&lt;/code&gt; のロックに失敗したオブジェクトのベースのインデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">&lt;code&gt;try_lock&lt;/code&gt; の呼び出しで例外が発生した場合、 &lt;code&gt;unlock&lt;/code&gt; が解除されたオブジェクトに対して、再スローする前にロック解除が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">呼び出した場合 &lt;code&gt;wrapper()&lt;/code&gt; 渡しのconst左辺値 &lt;code&gt;std::string&lt;/code&gt; 、その後、 &lt;code&gt;T&lt;/code&gt; IS推定されるまで &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; 、と &lt;code&gt;std::forward&lt;/code&gt; のconst左辺値参照が渡されることを保証 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">呼び出した場合 &lt;code&gt;wrapper()&lt;/code&gt; 渡し非const左辺値 &lt;code&gt;std::string&lt;/code&gt; 、そして &lt;code&gt;T&lt;/code&gt; がに導き出される &lt;code&gt;std::string&amp;amp;&lt;/code&gt; 、と &lt;code&gt;std::forward&lt;/code&gt; 非const左辺値参照が渡されることを保証 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">呼び出した場合 &lt;code&gt;wrapper()&lt;/code&gt; 右辺値渡し &lt;code&gt;std::string&lt;/code&gt; 、そして &lt;code&gt;T&lt;/code&gt; がに導き出される &lt;code&gt;std::string&lt;/code&gt; （いない &lt;code&gt;std::string&amp;amp;&lt;/code&gt; 、 &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; 、または &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; ）、および &lt;code&gt;std::forward&lt;/code&gt; 性を保証右辺値参照が &lt;code&gt;foo&lt;/code&gt; に渡されること。</target>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="translated">容量の変更が行われた場合、過去の終わりのイテレータを含むすべてのイテレータと参照は無効になります。</target>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="translated">キャプチャリストにcapture-defaultがあり、それを囲むオブジェクト（ &lt;code&gt;this&lt;/code&gt; または &lt;code&gt;*this&lt;/code&gt; ）または自動変数を明示的にキャプチャしない場合、それをキャプチャします。</target>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="translated">派生クラスのキャッチフレーズが基底クラスのキャッチフレーズの後に置かれた場合、派生クラスのキャッチフレーズは決して実行されません。</target>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="translated">クラスにパブリック仮想デストラクタがある場合、そのクラスから派生させることができ、派生オブジェクトは、ベースオブジェクトへのポインタを介して安全に削除できます（&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW＃18&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="translated">クラスでユーザー定義の&lt;a href=&quot;destructor&quot;&gt;デストラクタ&lt;/a&gt;、ユーザー定義の&lt;a href=&quot;copy_constructor&quot;&gt;コピーコンストラクタ&lt;/a&gt;、またはユーザー定義の&lt;a href=&quot;as_operator&quot;&gt;コピー代入演算子&lt;/a&gt;が必要な場合、ほぼ確実に3つすべてが必要です。</target>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="translated">インスタンス化の時点でクラス・テンプレートが宣言されていても定義されていない場合、そのインスタンス化は不完全なクラス・タイプを生成します。</target>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="translated">const non-inline（C ++ 17以降）静的データメンバーまたはconstexpr静的データメンバー（C ++ 11以降）が&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;である場合でも、ネームスペーススコープでの定義は必要ですが、初期化子を持つことはできません。この定義は、 &lt;code&gt;constexpr&lt;/code&gt; データメンバーでは非推奨です（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="translated">constexpr ifステートメントが&lt;a href=&quot;templates#Templated_entity&quot;&gt;テンプレート化されたエンティティ&lt;/a&gt;内に出現し、インスタンス化の後に条件が&lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;値に依存&lt;/a&gt;しない場合、囲んでいるテンプレートがインスタンス化されても、破棄されたステートメントはインスタンス化されません。</target>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="translated">コンストラクタテンプレートまたは変換関数テンプレートに&lt;a href=&quot;explicit&quot;&gt;条件&lt;/a&gt;&lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;依存の&lt;/a&gt;明示的な指定子があり、偶然に値に依存する場合、演繹の後に、コンテキストが明示的でない候補を必要とし、生成された特殊化が明示的である場合、候補セットから削除されます。</target>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="translated">仮想関数の契約条件ならば &lt;code&gt;f&lt;/code&gt; ODR-用途は &lt;code&gt;*this&lt;/code&gt; 、クラス &lt;code&gt;f&lt;/code&gt; 直接のメンバーがいる任意のクラスの明確なとアクセス可能基底クラスでなければなりません &lt;code&gt;f&lt;/code&gt; が上書きされます。</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">変換指定が無効な場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="translated">データ競合が発生した場合、プログラムの動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="translated">宣言で自動ストレージ期間を持つ変数が導入された場合、その宣言ステートメントが実行されるときに初期化されます。ブロックで宣言されたすべての自動変数は、ブロックの終了時に（ブロックの終了方法に関係なく、&lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;、&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;、またはその最後に到達することにより）、初期化の順序とは逆の順序で破棄されます。</target>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="translated">非委任型のコンストラクタが正常に完了した後、委任型のコンストラクタが例外で終了した場合、このオブジェクトのデストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">スタックの巻き戻し中にデストラクタが終了ハンドラをリセットし、その後巻き戻しが &lt;code&gt;terminate&lt;/code&gt; 呼び出しを引き起こした場合、throw式の最後にインストールされたハンドラが呼び出されます。（注：再スローが新しいハンドラーを適用したかどうかはあいまいでした）。</target>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="translated">スタックの巻き戻し中にデストラクタが終了ハンドラをリセットした場合、巻き戻しによって後で &lt;code&gt;terminate&lt;/code&gt; が呼び出された場合に呼び出されるハンドラは不定です。</target>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">スタックの巻き戻し中にデストラクタが予期しないハンドラをリセットし、後で巻き戻しが &lt;code&gt;unexpected&lt;/code&gt; ない呼び出しを引き起こした場合、throw式の最後にインストールされたハンドラが呼び出されます。（注：再スローが新しいハンドラーを適用したかどうかはあいまいでした）。</target>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="translated">スタックの巻き戻し中にデストラクタが予期しないハンドラをリセットした場合、巻き戻しによって後で &lt;code&gt;unexpected&lt;/code&gt; しない呼び出しが発生した場合に呼び出されるハンドラは不定です。</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">ドメインエラーが発生した場合は、実装定義値(サポートされている場合は NaN)を返す。</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">ドメインエラーが発生した場合は、実装定義値を返す(サポートされている場合は NaN)。</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">ドメインエラーが発生した場合、実装定義の値が返されます。</target>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">ディレクトリイテレータが作成された後にファイルやディレクトリが削除されたり、ディレクトリツリーに追加されたりした場合、その変更がイテレータを通して観測されるかどうかは不定です。</target>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">再帰的ディレクトリイテレータが作成された後に、ファイルやディレクトリが削除されたり、ディレクトリツリーに追加されたりした場合、その変更がイテレータを通して観測されるかどうかは不定です。</target>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="translated">友人宣言が翻訳単位内の関数の最初の宣言であり、契約条件を持つ場合、その宣言は定義でなければならず、翻訳単位内の関数の唯一の宣言でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="translated">nodiscardとして宣言された関数、またはnodiscardによって値として宣言された列挙またはクラスを返す関数が、voidへのキャスト以外の&lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;破棄さ&lt;/a&gt;れた値の式から呼び出された場合、コンパイラーは警告を発行することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">関数が例外を介して &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; と、std :: terminateが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="translated">関数に複数の最終オーバーライダーがある場合、プログラムは不完全な形をしています。</target>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">関数が宣言されている場合は &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 1つの変換ユニットと同じ機能にすることなく、宣言されている &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 別の翻訳単位で、プログラムが悪い形成されています。診断は必要ありません。</target>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="translated">関数が指定子 &lt;code&gt;final&lt;/code&gt; で宣言されていて、別の関数がそれをオーバーライドしようとした場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="translated">指定子 &lt;code&gt;override&lt;/code&gt; を使用して関数が宣言されているが、仮想関数をオーバーライドしていない場合、プログラムの形式は正しくありません。</target>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="translated">例外仕様にリストされているタイプ &lt;code&gt;T&lt;/code&gt; で関数が宣言されている場合、関数はそのタイプまたはその派生タイプの例外をスローする場合があります。</target>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">関数または変数がクラス型の名前と同じ名前でスコープ内に存在する場合、明確化のために名前の前に &lt;code&gt;class&lt;/code&gt; を付加することができ、その結果、&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;複雑な型指定子が&lt;/a&gt;生成されます。</target>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">関数または変数が、共用 &lt;code&gt;struct&lt;/code&gt; はないクラス型の名前と同じ名前でスコープ内に存在する場合、あいまいさをなくすために名前の前にstructを付加でき、その結果、&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;複雑な型指定子が&lt;/a&gt;生成されます。</target>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">関数または変数がunion型の名前と同じ名前のスコープ内に存在する場合、曖昧さをなくすために &lt;code&gt;union&lt;/code&gt; を名前の前に付加して、&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;詳細な型指定子を作成できます。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="translated">関数が複数の関数をオーバーライドする場合、オーバーライドされる関数はすべて同じ契約条件のリストを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="translated">クラス・テンプレートの関数テンプレート、変数テンプレート、メンバ関数テンプレート、メンバ関数または静的データ・メンバが明示的なインスタンス化定義で明示的にインスタンス化されている場合、テンプレート定義は同じ変換単位に存在しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="translated">トランザクションセーフではない関数が、トランザクションセーフ関数への参照またはポインタを介して呼び出された場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="translated">関数がリターン型控除を使用している場合、控除先の型を使って再申告したり、同じ型に控除しても別の種類のリターン型控除を使用して再申告することはできません。</target>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="translated">使用宣言で関数を導入した場合、同名・同パラメータリストの関数宣言は、(同一関数の宣言でない限り)不整形となります。使用宣言で関数テンプレートを導入した場合、同名、パラメータ型リスト、戻り値型、テンプレートパラメータリストの関数テンプレートを宣言すると、形が崩れます。2つの使用宣言で同じ名前とパラメータリストを持つ関数を導入することができますが、その関数への呼び出しが試みられた場合、プログラムは不完全な形になります。</target>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="translated">関数ローカル(ブロックスコープ)のスタティックオブジェクトが破壊された後、別のスタティックオブジェクトのデストラクタからその関数が呼び出され、制御フローがそのオブジェクトの定義を通過した場合(またはポインタや参照を介して間接的に使用された場合)、その動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="translated">取得領域が存在する場合(例えば、ファイルを読み込むためにオープンされた場合)、その効果は実装で定義されます。典型的な実装では、取得領域を空にして、現在のファイルの位置を対応するバイト数だけ戻すことができます。</target>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="translated">ラムダが（ &lt;code&gt;this&lt;/code&gt; または &lt;code&gt;*this&lt;/code&gt; として）囲んでいるオブジェクトをキャプチャする場合、最も近い囲み関数は非静的メンバー関数であるか、ラムダが&lt;a href=&quot;data_members#Member_initialization&quot;&gt;デフォルトのメンバー初期化子&lt;/a&gt;内にある必要があります。</target>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="translated">ラムダ式（または汎用ラムダの関数呼び出し演算子のインスタンス化）が &lt;code&gt;this&lt;/code&gt; または自動ストレージ期間を持つ任意の変数を使用する場合、ラムダ式でキャプチャする必要があります。</target>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="translated">ラムダ odr-が参照によってキャプチャされた参照を使用する場合、キャプチャされた参照自体ではなく、元の参照によって参照されたオブジェクトを使用しています。</target>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">ラムダ式が&lt;a href=&quot;default_arguments&quot;&gt;デフォルトの引数&lt;/a&gt;に含まれている場合、明示的または暗黙的に何かをキャプチャすることはできません。</target>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="translated">メンバに既定のメンバ初期化子があり、コンストラクタのメンバ初期化リストにも表示されている場合、既定のメンバ初期化子は無視されます。</target>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="translated">名前が宣言される前にクラス本体で使用され、その名前の別の宣言がスコープ内にある場合、プログラムは&lt;a href=&quot;ub&quot;&gt;不正な形式であり、診断は必要ありません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="translated">積分型から浮動小数点型への変換以外に絞り込み変換が必要な場合は、プログラムの形が崩れます。</target>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="translated">ネストされたラムダ場合 &lt;code&gt;m2&lt;/code&gt; もすぐに囲むラムダによって捕獲されたキャプチャ何か &lt;code&gt;m1&lt;/code&gt; が、その後 &lt;code&gt;m2&lt;/code&gt; 以下のようにのキャプチャが変換されます。</target>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="translated">他のオブジェクトが占有していたアドレスに新しいオブジェクトが作成された場合、元のオブジェクトのすべてのポインタ、参照、名前は自動的に新しいオブジェクトを参照し、新しいオブジェクトの寿命が始まると、新しいオブジェクトを操作するために使用することができますが、以下の条件が満たされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="translated">非参照エンティティが参照によって暗黙的または明示的に捕捉され、エンティティの寿命が終了した後にクロージャ・オブジェクトの関数呼び出し演算子が呼び出された場合、未定義の動作が発生します。C++クロージャは、捕捉された参照の寿命を延長しません。</target>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="translated">非静的データメンバーに&lt;a href=&quot;data_members#Member_initialization&quot;&gt;デフォルトのメンバー初期化子が&lt;/a&gt;あり、メンバー初期化子リストにもある場合、メンバー初期化子リストが実行され、デフォルトのメンバー初期化子は無視されます。</target>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="translated">非タイプテンプレートパラメータがパラメータリストで使用され、対応するテンプレート引数が推定される場合、推定テンプレート引数のタイプ（そのテンプレートテンプレートリストで指定されているとおり、参照が保持されることを意味します）は、 cv-qualifiersが削除されていること、およびテンプレート引数が配列の境界から推定される場合を除いて、正確に非型テンプレートパラメーター。この場合、整数型は許可されますが、ブール値は常にtrueになります。</target>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="translated">あるパック展開が他のパック展開の中に入れ子になっている場合、一番内側のパック展開の中に現れるパラメータパックはそのパック展開によって展開されます。</target>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="translated">解析エラーが発生した場合、この関数の多くの実装では &lt;code&gt;*t&lt;/code&gt; はまったく変更されません。</target>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="translated">解析エラーが発生した場合、この関数のほとんどの実装は &lt;code&gt;*t&lt;/code&gt; を変更せずに残します。</target>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="translated">このような場合、「Element Import Import」(インスタンス化)は、「Element Import」(インスタンス化)と呼ばれ、「Element Import」(インスタンス化)は、「Element Import」(インスタンス化)と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">ポインター &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">極エラーが発生すると、 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; が返されます（正しい符号が付いています）。</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">極エラーが発生すると、 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">極エラーが発生すると、 &lt;code&gt;+HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;+HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;+HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">極エラーが発生すると、 &lt;code&gt;-HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;-HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;-HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">オーバーフローによる極エラーまたは範囲エラーが発生した場合、 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="translated">事後条件が述語でパラメーターを&lt;a href=&quot;../definition#ODR-use&quot;&gt;odr使用&lt;/a&gt;し、関数本体がそのパラメーターの値を直接または間接的に変更する場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="translated">事後条件に違反している場合、 &lt;code&gt;std::contract_violation&lt;/code&gt; 引数に反映されるソースの場所は、関数定義のソースの場所です。</target>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="translated">前提条件に違反した場合、 &lt;code&gt;std::contract_violation&lt;/code&gt; 引数に反映されるソースの場所は実装定義です。</target>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="translated">このモデルでは、「モデル・ナビゲーター」と「モデル・ナビゲーター」の間で、「モデル・ナビゲーター」という名前を使用して、「モデル・ナビゲーター」という名前を付けます。このクラス・テンプレートは、「クラス・テンプレート」と呼ばれ、「クラス・テンプレート」と「クラス・テンプレート」の間には、「クラス・テンプレート」と「クラス・テンプレート」の間には、「クラス・テンプレート」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="translated">プログラムに関数テンプレートの宣言が含まれていて、それが</target>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="translated">put領域が存在する場合（たとえば、ファイルが書き込み用に開かれた場合）、まず、 &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; を呼び出して、すべての保留中の出力を、シフト解除シーケンスを含めてファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">put領域が存在する場合（ファイルが書き込み用に開かれた場合など）は、 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; を呼び出して保留中のすべての出力をファイルに書き込み、次に &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt; 呼び出してファイルをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">プットバックの位置がget領域で利用可能（ &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ）であり、文字 &lt;code&gt;c&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; の左側の1文字に等しい場合（ &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt; によって決定される）（）[-1]）、次に単純に次のポインタをデクリメントします（ &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="translated">取得領域でプットバック位置が使用可能な場合（ &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ）、次のポインターをデクリメントし（ &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ）、現在指している文字を返します。</target>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="translated">プットバック位置が利用できない場合、可能であれば、 &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; を呼び出して入力シーケンスをバックアップします。</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">オーバーフローによる範囲エラーが発生した場合、 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; が返されます（ &lt;code&gt;from&lt;/code&gt; と同じ符号）。</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">オーバーフローによる範囲エラーが発生した場合、 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">オーバーフローによる範囲エラーが発生した場合、 &lt;code&gt;+HUGE_VAL&lt;/code&gt; 、 &lt;code&gt;+HUGE_VALF&lt;/code&gt; 、または &lt;code&gt;+HUGE_VALL&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">アンダーフローによる範囲エラーが発生した場合は、正しい結果(丸め後)を返します。</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">アンダーフローによる範囲エラーが発生した場合は、正しい値(丸め後)を返します。</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">アンダーフローにより範囲エラーが発生した場合は、正しい結果(丸め後)が返されます。</target>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="translated">アンダーフローで範囲エラーが発生した場合は、正しい結果(丸めた後)でござる。</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">アンダーフローにより範囲エラーが発生した場合、サブノルマルがサポートされていれば正しい結果が返されます。</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">アンダーフローにより範囲エラーが発生した場合は、正しい結果を返します。</target>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="translated">読み取りまたは書き込みエラーが発生すると、ストリームのエラーインジケーター（ &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ）が設定されます。</target>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">読み取りまたは書き込みエラーが発生した場合、ストリームのエラーインジケーター（ &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ）が設定され、ファイル位置は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="translated">require-expressionの要件に無効なタイプまたは式が含まれていて、それが&lt;a href=&quot;templates#Templated_entity&quot;&gt;テンプレート化されたエンティティの&lt;/a&gt;宣言内に現れない場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="translated">演算子 &lt;code&gt;@&lt;/code&gt; のオーバーロード解決によって書き換えられた候補が選択された場合、 &lt;code&gt;x @ y&lt;/code&gt; は書き換えられた式として解釈されます： &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; 選択された候補がパラメーターの順序が逆の合成候補の場合、または &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; それ以外の場合は、選択した書き換え済み &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 候補を使用。</target>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; への呼び出しの結果として（同期的に）シグナルハンドラーが実行される場合、ハンドラーの実行は</target>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="translated">標準レイアウト&lt;a href=&quot;union&quot;&gt;共用体&lt;/a&gt;がメンバーとして2つ（またはそれ以上）の標準レイアウトクラスを保持し、これらのクラスにデータメンバーの共通の初期シーケンスがある場合、そのメンバーに関係なく、その共通の初期シーケンスのメンバーを調べることは明確に定義されています組合はアクティブです。</target>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="translated">標準レイアウト組合が2つ以上の標準レイアウト構造体を保有している場合は、それらの共通の初期部分を検査することが認められています。</target>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="translated">静的データメンバーが &lt;code&gt;constexpr&lt;/code&gt; として宣言されている場合、それは暗黙的に &lt;code&gt;inline&lt;/code&gt; あり、名前空間スコープで再宣言する必要はありません。イニシャライザ（以前は上記のように必須でした）なしのこの再宣言は引き続き許可されますが、非推奨です。</target>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="translated">静的データメンバ場合&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypeが&lt;/a&gt;宣言されている &lt;code&gt;constexpr&lt;/code&gt; の、それが正しいクラス定義内で、すべての式が定数式である初期化子で初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="translated">整数型または列挙型の静的データメンバーが &lt;code&gt;const&lt;/code&gt; として宣言されている場合（ &lt;code&gt;volatile&lt;/code&gt; ではありません）、すべての式が&lt;a href=&quot;constexpr&quot;&gt;定数式&lt;/a&gt;である&lt;a href=&quot;initialization&quot;&gt;イニシャライザ&lt;/a&gt;でクラス定義内で初期化できます。</target>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="translated">テンプレート引数の可能性があるすべてのrequire-expressionで置換の失敗が発生した場合、プログラムは不正な形式をしており、診断は必要ありません。</target>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="translated">テキスト表現が &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; を使用して記述され、その表現が同じタイプの同じまたは異なるオブジェクト &lt;code&gt;y&lt;/code&gt; に復元される場合、y &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt; であり、 &lt;code&gt;x==y&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="translated">スレッドが提供する場合</target>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="translated">トークンがユーザー定義のリテラル構文および通常のリテラル構文と一致する場合、トークンは通常のリテラルと見なされます（つまり、 &lt;code&gt;LL&lt;/code&gt; を &lt;code&gt;123LL&lt;/code&gt; でオーバーロードすることは不可能です）。</target>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="translated">型に &lt;code&gt;value_type&lt;/code&gt; メンバーと &lt;code&gt;element_type&lt;/code&gt; メンバーの両方が含まれている場合、特殊化（5）と（6）はあいまいです。</target>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="translated">ユニオンに非自明な&lt;a href=&quot;default_constructor&quot;&gt;デフォルトコンストラクター&lt;/a&gt;を持つ非静的データメンバーが含まれている場合、ユニオンの&lt;a href=&quot;union#Union-like_classes&quot;&gt;バリアントメンバー&lt;/a&gt;にデフォルトメンバー初期化子がない限り、ユニオンのデフォルトコンストラクターはデフォルトで削除されます。</target>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="translated">共用体に非自明な特殊メンバー関数（&lt;a href=&quot;copy_constructor&quot;&gt;コピー&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;移動&lt;/a&gt;コンストラクター、&lt;a href=&quot;as_operator&quot;&gt;コピー&lt;/a&gt; / &lt;a href=&quot;move_operator&quot;&gt;移動&lt;/a&gt;割り当て、または&lt;a href=&quot;destructor&quot;&gt;デストラクター&lt;/a&gt;）を持つ非静的データメンバーが含まれている場合、その関数はデフォルトで共用体から削除され、プログラマー。</target>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="translated">普遍文字名がISO/IEC 10646のコードポイント(0x0-0x10FFFFの範囲)に対応していない場合や、普遍文字名がサロゲートコードポイント(0xD800-0xDFFFの範囲)に対応している場合は、プログラムの形が崩れています。</target>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="translated">ユーザー定義の &lt;code&gt;operator-&amp;gt;&lt;/code&gt; が指定されている場合、 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; が返された値に対して、 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; がプレーンポインターを返すまで再帰的に呼び出されます。その後、組み込みのセマンティクスがそのポインターに適用されます。</target>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="translated">使用宣言が基底クラス代入演算子を派生クラスに持ち込んだ場合、そのシグネチャがたまたま派生クラスのコピー代入演算子や移動代入演算子と一致した場合、その演算子は派生クラスの暗黙に宣言されたコピー/移動代入演算子によって隠されます。派生クラスのコピー/移動コンストラクタとたまたま一致する基底クラスのコンストラクタを継承する使用宣言も同様です(C++11以降)。</target>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="translated">文字列リテラル内の16進数エスケープの後に有効な16進数が続くと、無効なエスケープシーケンスとしてコンパイルに失敗します。文字列の連結は回避策として使用することができます。</target>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="translated">例外をスローすることにより違反ハンドラーが終了し、スローされない例外指定がある関数の呼び出しでコントラクトに違反すると、 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="translated">仮想関数が非スローである場合、オーバーライダーが削除されたと定義されていない限り、すべてのオーバーライダーの定義を含むすべての宣言は、同様に非スローでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">幅指定子が使用されている場合、正確には</target>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">アクセス指定子が省略された場合、それをデフォルト &lt;code&gt;public&lt;/code&gt; クラスについては、クラスキーで宣言した &lt;code&gt;struct&lt;/code&gt; との &lt;code&gt;private&lt;/code&gt; クラスのクラスキーを使用して宣言 &lt;code&gt;class&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">準備が完了した後、 &lt;code&gt;is.good() == true&lt;/code&gt; 、後続の &lt;code&gt;operator bool&lt;/code&gt; 呼び出しは &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="translated">すべてのスカラー型がビッグエンディアンの場合、 &lt;code&gt;std::endian::native&lt;/code&gt; は &lt;code&gt;std::endian::big&lt;/code&gt; と等しい</target>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">すべてのスカラー型がリトルエンディアンの場合、 &lt;code&gt;std::endian::native&lt;/code&gt; は &lt;code&gt;std::endian::little&lt;/code&gt; と等しい</target>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="translated">すべてのスカラー型のsizeofが1に等しい場合、エンディアンは重要ではなく、3つの値、 &lt;code&gt;std::endian::little&lt;/code&gt; 、 &lt;code&gt;std::endian::big&lt;/code&gt; 、および &lt;code&gt;std::endian::native&lt;/code&gt; はすべて同じです</target>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="translated">これらの要件がすべて満たされていれば、プログラム全体で1つの定義しかないかのように動作します。そうでなければ、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="translated">すべての可変引数が共通のタイプを共有する場合、 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; は、可変引数にアクセスするための（構文は異なりますが）便利なメカニズムを提供します。ただしこの場合、 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; はその要素へのconstポインターしか提供できないため、引数を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">割り当てが失敗した場合、 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; を呼び出します。これにより、 &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; がスローされる場合があります。</target>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="translated">割り当てが失敗した場合、Promise型がメンバー関数 &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; 定義していない限り、コルーチンは &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローします。そのメンバー関数が定義されている場合、割り当ては &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; &lt;code&gt;nothrow&lt;/code&gt; 形式を使用し、割り当てが失敗すると、コルーチンはすぐに &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; から取得したオブジェクトを呼び出し元に返します。</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">割り当てに成功した場合、任意のオブジェクトタイプに対して適切にアラインメントされた、割り当てられたメモリブロック内の最下位(最初の)バイトへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="translated">割り当てに成功した場合は、任意のスカラ型に対して適切にアラインメントされた、割り当てられたメモリブロック内の最下位(最初の)バイトへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="translated">&lt;a href=&quot;inline&quot;&gt;インライン&lt;/a&gt;関数が異なる変換単位で宣言されている場合、デフォルトの引数の累積セットは、各変換単位の最後で同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="translated">アダプタが複数の引数を取る場合、これらの形式は同等です。</target>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="translated">引数が&lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt;と式の両方として解釈できる場合、対応するテンプレートパラメーターが非型であっても、常にtype-idとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">アレイは、非常に大きい（より大きい場合 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; の要素、未満 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; は二つのポインタの間の差は、として表現ではないかもしれないことは、バイト） &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 、二つのそのようなポインタを減算した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="translated">アサーションに違反している場合、 &lt;code&gt;std::contract_violation&lt;/code&gt; 引数に反映されるソースの場所は、アサーションが適用されるステートメントのソースの場所です。</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">スレッドAのアトミックストアが &lt;code&gt;memory_order_release&lt;/code&gt; とタグ付けされ、同じ変数からのスレッドBのアトミックロードがmemory_order_acquireとタグ付けされている &lt;code&gt;memory_order_acquire&lt;/code&gt; 、すべてのメモリ書き込み（非アトミックでリラックスしたアトミック）</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">スレッドAのアトミックストアに &lt;code&gt;memory_order_release&lt;/code&gt; のタグが付けられ、同じ変数からのスレッドBのアトミックロードに &lt;code&gt;memory_order_consume&lt;/code&gt; のタグが付けられている場合、すべてのメモリ書き込み（非アトミックでリラックスしたアトミック）</target>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="translated">ある内部名前空間で宣言されているが定義されていない実体が、外部名前空間で使用宣言によって宣言された後、外部名前空間に同じ非修飾名を持つ定義が現れた場合、その定義は外部名前空間のメンバであり、使用宣言と競合します。</target>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="translated">エラーが発生した場合、ストリームのファイル位置インジケータの結果の値は不確定です。</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">エラーが発生した場合、ストリームのファイル位置インジケータの結果の値は不確定です。部分要素が読み込まれた場合、その値は不確定です。</target>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="translated">エラーが発生した場合、キャッシュされた属性の値は不定です。</target>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="translated">(コンストラクタなどで)例外が発生した場合、この関数が呼び出されなかったかのようにコンテナは変更されません (強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="translated">例外がスローされた場合（ &lt;code&gt;Allocator::allocate()&lt;/code&gt; または要素のコピー/移動コンストラクター/割り当てが原因である可能性があります）、この関数は効果がありません（強力な例外保証）。</target>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 初期関数、メイン関数、および静的またはスレッドローカルオブジェクトのコンストラクターまたはデストラクターをエスケープする例外を含め、例外がスローされてキャッチされない場合、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。キャッチされていない例外に対してスタックの巻き戻しが行われるかどうかは、実装によって定義されます。</target>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">何らかの操作によって例外がスローされた場合、挿入は何の影響も受けません。</target>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="translated">何らかの操作で例外が発生した場合、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="translated">何らかの操作で例外が発生した場合、この関数は何の影響も受けません。</target>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="translated">&lt;code&gt;insert_after&lt;/code&gt; 中に例外がスローされた場合、効果はありません（強力な例外保証）。</target>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">初期化中に例外がスローされた場合、 &lt;code&gt;[first, last)&lt;/code&gt; 一部のオブジェクトは有効ですが指定されていない状態のままになり、すでに構築されているオブジェクトは指定されていない順序で破棄されます。</target>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">初期化中に例外がスローされた場合、ソース範囲内の一部のオブジェクトは有効だが不特定多数の状態で放置され、既に構築されたオブジェクトは不特定多数の順番で破棄されます。</target>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">初期化中に例外が発生した場合、既に構築されているオブジェクトは不特定多数の順番で破棄されます。</target>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">何らかの理由で例外がスローされた場合、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">何らかの理由で例外がスローされた場合、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="translated">オブジェクトのコンストラクタから、または(まれに)オブジェクトのデストラクタから例外がスローされた場合(オブジェクトの保存期間に関係なく)、完全に構築された非静的非可変(C++14 まで)メンバと基底クラスのすべてのメンバに対して、そのコンストラクタの完了順を逆にしてデストラクタが呼び出されます。ユニオン的なクラスのバリアント メンバは、コンストラクタからの巻き戻しの場合にのみ破棄され、初期化と破棄の間にアクティブ メンバが変更された場合は動作が未定義になります(C++14 以降)。</target>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="translated">T の移動コンストラクタ以外で例外が発生した場合は、何の影響もありません。</target>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="translated">値型のコピーコンストラクター、移動コンストラクター、割り当て演算子、または移動割り当て演算子以外で例外がスローされた場合、または &lt;code&gt;emplace&lt;/code&gt; を使用して両端に単一の要素が挿入されているときに例外がスローされた場合、効果（強力な例外保証）。</target>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="translated">値の型のコピーコンストラクター、移動コンストラクター、割り当て演算子、または移動割り当て演算子以外で例外がスローされた場合、または &lt;code&gt;emplace&lt;/code&gt; を使用して最後に単一の要素を挿入しているときに例外がスローされ、値の型が&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;またはnothrow moveのいずれかが構築可能である場合、影響はありません（強力な例外保証）。</target>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="translated">どちらかの端に1つの要素を挿入する際に例外が発生した場合、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="translated">末尾に単一の要素を挿入するときに例外がスローされ、Tが&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;または &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、影響はありません（強力な例外保証）。</target>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="translated">例外がスローされる場合、 &lt;code&gt;*this&lt;/code&gt; 内の要素の順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="translated">例外がスローされた場合、共有ロックは取得されません。</target>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">例外が投げられた場合は効果がありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="translated">例外がスローされた場合、この関数は効果がありません（&lt;a href=&quot;../../language/exceptions&quot;&gt;強力な例外保証&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="translated">例外がスローされた場合、比較関数からの例外を除いて、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="translated">例外がスローされた場合、この関数は何の効果もありません(強力な例外保証)。</target>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">例外がスローされた場合、この関数は効果がありません（強力な例外保証）。場合 &lt;code&gt;T&lt;/code&gt; の動きのコンストラクタではありません &lt;code&gt;noexcept&lt;/code&gt; とではありません&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;に &lt;code&gt;*this&lt;/code&gt; は、ベクターは投げる動きコンストラクタを使用します。スローした場合、保証は放棄され、効果は不定です。</target>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="translated">例外がフューチャーによって参照される共有状態で保存された場合（例：&lt;a href=&quot;../promise/set_exception&quot;&gt; &lt;code&gt;std::promise::set_exception()&lt;/code&gt; &lt;/a&gt;呼び出しを介して）、その例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="translated">暗黙的に宣言されたデストラクタが削除されない場合、それは&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-usedの&lt;/a&gt;ときにコンパイラによって暗黙的に定義されます（つまり、関数本体が生成およびコンパイルされます）。この暗黙的に定義されたデストラクタのボディは空です。</target>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="translated">インライン関数が異なる変換単位で宣言されている場合、&lt;a href=&quot;default_arguments&quot;&gt;デフォルト引数の&lt;/a&gt;累積セットは、各変換単位の最後で同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="translated">外部リンクを持つインライン関数または変数(C++17 以降)が異なる変換単位で定義されている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="translated">挿入が実行されると、マップされた値は&lt;a href=&quot;../../language/value_initialization&quot;&gt;値で初期化され&lt;/a&gt;（クラス型ではデフォルトで作成され、それ以外の場合はゼロで初期化されます）、その参照が返されます。</target>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">挿入が発生してコンテナーの再ハッシュが発生した場合、すべての反復子が無効になります。それ以外の場合、イテレータは影響を受けません。参照は無効になりません。要素の新しい数が &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; より大きい場合にのみ、再ハッシュが発生します。</target>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="translated">上記のテンプレートのインスタンス化が、直接または間接的に、不完全な型に依存しており、その型が仮想的に完成した場合に、そのインスタンス化が異なる結果をもたらす可能性がある場合、その動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="translated">内部操作が例外をスローすると、それがキャッチされ、 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; が設定されます。場合 &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; 設定されている &lt;code&gt;badbit&lt;/code&gt; 、例外が再スローされます。</target>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="translated">形質に対する操作で例外が発生した場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="translated">オーバーライド関数が&lt;a href=&quot;attributes/contract&quot;&gt;契約条件を&lt;/a&gt;指定している場合、オーバーライドする関数と同じリスト契約条件を指定する必要があります。対応する条件が常に同じ値に評価される場合、診断は不要です。それ以外の場合は、オーバーライドされた関数の1つからの契約条件のリストを持っていると見なされます。契約条件の名前はバインドされており、契約条件が出現した時点で意味的制約がチェックされます。</target>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 、すべての共有所有者の存続期間が終了した後に &lt;code&gt;std::make_shared&lt;/code&gt; によって作成された制御ブロックを参照する場合、 &lt;code&gt;T&lt;/code&gt; が占有するメモリは、すべての弱い所有者も破壊されるまで存続します。これは、 &lt;code&gt;sizeof(T)&lt;/code&gt; が大。</target>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Tiが比較カテゴリタイプではない場合（&lt;a href=&quot;weak_equality&quot;&gt; &lt;code&gt;std::weak_equality&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;partial_ordering&quot;&gt; &lt;code&gt;std::partial_ordering&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt;）、Uは &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">引数が NaN の場合は NaN が返され、ドメインエラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="translated">候補関数が&lt;a href=&quot;member_functions&quot;&gt;メンバー関数&lt;/a&gt;（静的または非静的）であるがコンストラクターではない場合、追加のパラメーターがあるかのように扱われます（</target>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="translated">候補が関数テンプレートである場合、その特殊化は&lt;a href=&quot;template_argument_deduction&quot;&gt;テンプレート引数の控除&lt;/a&gt;を使用して生成され、そのような特殊化はタイブレーカールールで特に指定されていない限り、非テンプレート関数と同様に扱われます。名前が1つ以上の関数テンプレートを参照し、オーバーロードされた非テンプレート関数のセットも参照する場合、それらの関数とテンプレートから生成された特殊化はすべて候補になります。</target>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="translated">スタック巻き戻しメカニズムによって直接呼び出される関数が、例外オブジェクトの初期化後、例外ハンドラーの開始前に、例外を出て終了すると、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。このような関数には、スコープが終了する自動保存期間を持つオブジェクトの&lt;a href=&quot;destructor&quot;&gt;デストラクタ&lt;/a&gt;、および値&lt;a href=&quot;copy_elision&quot;&gt;渡しの&lt;/a&gt;引数を初期化するために呼び出される（省略されていない場合）例外オブジェクトのコピーコンストラクタが含まれます。</target>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="translated">関連付けられたクラスとネームスペースのセットにインライン・ネームスペースが直接含まれている場合、そのインライン・ネームスペースがセットに追加されます。</target>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="translated">関連するクラスと名前空間のセット内の名前空間が&lt;a href=&quot;namespace&quot;&gt;インライン名前空間である&lt;/a&gt;場合、それを囲む名前空間もセットに追加されます。</target>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 呼び出しを含め、行われた関数呼び出しのいずれかが失敗すると、nullポインターが返されます。行われた関数呼び出しのいずれかが例外をスローした場合、 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 呼び出し後に例外がキャッチされ、再スローされます。ファイルがすでに閉じている場合は、すぐにnullポインターを返します。</target>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="translated">関数パラメータのいずれかが</target>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="translated">オペランドのいずれかがポインタである場合、以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="translated">プライベートメンバのいずれかがパブリックまたはプロテクトされたメンバにアクセスする必要がある場合、インタフェースへの参照またはポインタをパラメータとしてプライベート関数に渡してもよい。あるいは、実装クラスの一部として後方参照を保持することもできます。</target>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="translated">これらの状況のいずれかが翻訳単位内で発生した場合、型の定義は同じ翻訳単位内に出現しなければならない。それ以外の場合は必要ありません。</target>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="translated">任意のテンプレート定義を持っている場合&lt;a href=&quot;qualified_lookup&quot;&gt;、修飾名&lt;/a&gt;の修飾子が参照するに</target>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="translated">テンプレート定義が、オブジェクト式が</target>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; で待機しているスレッドがある場合、 &lt;code&gt;notify_one&lt;/code&gt; を呼び出すと、待機しているスレッドの1つがブロック解除されます。</target>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">適用する場合 &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; の少なくとも一方に &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; は、異なる種類の生成、メンバー &lt;code&gt;type&lt;/code&gt; 名と同じタイプ &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt; （存在する場合）。そうでない場合、メンバー &lt;code&gt;type&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">argがNaNの場合はNaNを返します。</target>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="translated">式の演算子の引数の少なくとも1つがクラス型または列挙型の場合、&lt;a href=&quot;expressions#Operators&quot;&gt;組み込み演算子&lt;/a&gt;と&lt;a href=&quot;operators&quot;&gt;ユーザー定義演算子のオーバーロードの&lt;/a&gt;両方がオーバーロードの解決に参加し、候補関数のセットが次のように選択されます。</target>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="translated">解放関数のうち少なくとも1つが破壊的な削除である場合、破壊的でない削除はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="translated">オペランドの少なくとも一方がポインタまたはポインタ-メンバである場合、両方のオペランドを同じポインタ型に変換するために、必要に応じて配列-ポインタ変換、派生-ベースポインタ変換、関数ポインタ変換、および資格変換が適用されます。</target>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="translated">bool_constexprが &lt;code&gt;true&lt;/code&gt; を返す場合、この宣言は無効です。そうでない場合、コンパイル時エラーが発行され、メッセージのテキスト（存在する場合）が診断メッセージに含まれます。</target>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の両方に値が含まれている場合、含まれている値は &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt; を使用して呼び出すことで交換されます。swap（** this、* other）。 &lt;code&gt;T&lt;/code&gt; の左辺値が満たさなければならない&lt;a href=&quot;../../named_req/swappable&quot;&gt;スワップを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の両方に値が含まれていない場合、関数は効果がありません。</target>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;Base&lt;/code&gt; と &lt;code&gt;Derived&lt;/code&gt; の両方がユニオンクラスタイプではなく、それらが同じタイプでない場合（cv-qualificationを無視）、 &lt;code&gt;Derived&lt;/code&gt; は&lt;a href=&quot;../language/incomplete_type&quot;&gt;完全なタイプになり&lt;/a&gt;ます。それ以外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="translated">以前に &lt;code&gt;P&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; の両方が参照型である場合は、どちらがよりcv修飾されているかを判別します（他のすべての場合、cv修飾は部分的な順序付けの目的で無視されます）</target>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の両方がゼロの場合、ゼロを返します。それ以外の場合は、 &lt;code&gt;|m|&lt;/code&gt; 最大公約数を返します と &lt;code&gt;|n|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が有効な日付を表す場合（ &lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt; ）、辞書式比較の結果はカレンダーの順序と一致します。</target>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="translated">変換関数と変換コンストラクターの両方を使用して一部のユーザー定義変換を実行できる場合、変換関数とコンストラクターは両方とも、&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期化&lt;/a&gt;および&lt;a href=&quot;reference_initialization&quot;&gt;参照初期化&lt;/a&gt;コンテキストの&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;によって考慮されますが、&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;コンテキストではコンストラクターのみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="translated">両方のコピーと移動代入演算子が設けられている場合は、引数がある場合に、オーバーロード解決は、移動割り当てを選択&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;右辺値&lt;/i&gt;&lt;/a&gt;（いずれか&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt;一時的な名前のない又は&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;はxValue&lt;/i&gt;&lt;/a&gt;そのような結果として &lt;code&gt;std::move&lt;/code&gt; ）、及びコピーの割り当てを選択します引数が&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;左辺値&lt;/i&gt;&lt;/a&gt;（名前付きオブジェクト、または左辺値参照を返す関数/演算子）の場合コピー割り当てのみが指定されている場合は、すべての引数カテゴリーがそれを選択します（値によって引数を取る場合、またはconstへの参照として、rvalueはconst参照にバインドできるため）。これにより、コピー割り当ては移動時に移動割り当てのフォールバックになります利用できません。</target>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="translated">両方のコピーと移動コンストラクタが提供され、引数がある場合、他のコンストラクタは、移動コンストラクタ生存、オーバーロード解決が選択されていない場合&lt;a href=&quot;value_category&quot;&gt;右辺&lt;/a&gt;同じタイプ（の&lt;a href=&quot;value_category&quot;&gt;はxValue&lt;/a&gt;そのような結果として &lt;code&gt;std::move&lt;/code&gt; 又は&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;無名等temporary（until C ++ 17））、引数が&lt;a href=&quot;value_category&quot;&gt;左辺値&lt;/a&gt;（名前付きオブジェクトまたは左辺値参照を返す関数/演算子）の場合は、コピーコンストラクターを選択します。コピーコンストラクターのみが提供されている場合、すべての引数カテゴリーがそれを選択します（constへの参照が必要である限り、右辺値はconst参照にバインドできるため）。これにより、移動が利用できない場合に、移動のフォールバックがコピーされます。</target>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="translated">両方の式が整形されている場合、変換は曖昧であり、プログラムは整形されていません。</target>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="translated">オペランドの両方が配列である場合,配列型のクラスのメンバを比較する場合を除いて,三元比較は不正な形式です.</target>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="translated">両方のオペランドが符号付きの場合、または両方とも符号なしの場合は、オペランドの値が小さい方が</target>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="translated">両方のオペランドが算術型を持っている場合や、一方のオペランドがアンスコープな列挙型で他方のオペランドが積分型の場合は、通常の算術変換をオペランドに適用してから</target>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="translated">両方のオペランドの列挙型が同じEである場合、演算子は、オペランドを基本となるEの型に変換し、変換されたオペランドに &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を適用した結果を生成します。</target>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 両方のフラグが &lt;code&gt;policy&lt;/code&gt; で設定されている場合、非同期実行と遅延評価のどちらを実行するかは実装次第です。</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">変換された値と精度の両方がある場合は &lt;code&gt;​0​&lt;/code&gt; ない文字に変換結果。</target>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">剰余と商の両方が対応するタイプのオブジェクト（それぞれ、int、long、long long、std :: imaxdiv_t）として表現できる場合、両方を &lt;code&gt;std::div_t&lt;/code&gt; 、 &lt;code&gt;std::ldiv_t&lt;/code&gt; 、 &lt;code&gt;std::lldiv_t&lt;/code&gt; のタイプのオブジェクトとして返します:: lldiv_t、 &lt;code&gt;std::imaxdiv_t&lt;/code&gt; は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">c16がヌルワイド文字 &lt;code&gt;u'\0'&lt;/code&gt; 場合、ヌルバイトが格納され、最初のシフト状態を復元するために必要なシフトシーケンスが先行し、変換状態パラメーター &lt;code&gt;*ps&lt;/code&gt; が初期シフト状態を表すように更新されます。</target>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">c32がヌルワイド文字 &lt;code&gt;U'\0'&lt;/code&gt; 場合、初期シフト状態を復元するために必要なシフトシーケンスが先行するヌルバイトが格納され、変換状態パラメーター &lt;code&gt;*ps&lt;/code&gt; が初期シフト状態を表すように更新されます。</target>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="translated">例外処理中に呼び出された場合（通常、 &lt;code&gt;catch&lt;/code&gt; 句で）、現在の例外オブジェクトをキャプチャし、その例外オブジェクトへのコピーまたは参照（実装に応じて）を保持する &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; を作成します。参照されるオブジェクトは、それを参照する &lt;code&gt;exception_ptr&lt;/code&gt; オブジェクトがある限り、少なくとも有効です。</target>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">クラスレベルの &lt;code&gt;operator delete&lt;/code&gt; がテンプレート関数の場合、戻り値の型は &lt;code&gt;void&lt;/code&gt; 、最初の引数は &lt;code&gt;void*&lt;/code&gt; である必要があり、2つ以上のパラメーターが必要です。つまり、配置フォームのみがテンプレートになることができます。テンプレート演算子deleteの特殊化は、&lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;テンプレート引数の控除で&lt;/a&gt;選択されます。</target>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="translated">クラスレベルの &lt;code&gt;operator new&lt;/code&gt; がテンプレート関数の場合、戻り値の型は &lt;code&gt;void*&lt;/code&gt; で、最初の引数は &lt;code&gt;std::size_t&lt;/code&gt; である必要があり、2つ以上のパラメーターが必要です。つまり、配置フォームのみがテンプレートになることができます。</target>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="translated">call_onceへの同時呼び出しが異なる関数 &lt;code&gt;f&lt;/code&gt; を渡す場合、どの &lt;code&gt;f&lt;/code&gt; が呼び出されるかは不定です。選択された関数は、渡された &lt;code&gt;call_once&lt;/code&gt; 呼び出しと同じスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">条件が &lt;code&gt;case:&lt;/code&gt; ラベルのいずれとも一致しない値に評価され、 &lt;code&gt;default:&lt;/code&gt; ラベルが存在する場合、制御はdefault：ラベルが付いたステートメントに移され &lt;code&gt;default:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">条件が constant_expressionの1つの値と等しい値で評価された場合、制御はその constant_expressionでラベル付けされた文に転送されます。</target>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="translated">conditionが &lt;code&gt;T t = x&lt;/code&gt; などの宣言である場合、宣言された変数はループの本体のスコープ内にのみ存在し、繰り返しごとに破棄および再作成されます。つまり、whileループはこれと同等です。</target>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="translated">制御が戻り型 &lt;code&gt;void&lt;/code&gt; （おそらくcv修飾）を持つ&lt;a href=&quot;function-try-block&quot;&gt;関数&lt;/a&gt;の終わり、コンストラクターの終わり、デストラクターの終わり、または戻り型（おそらくcv）の関数のfunction-try-blockの終わりに到達した場合-qualified）returnステートメントに遭遇せずに &lt;code&gt;void&lt;/code&gt; 、 &lt;code&gt;return;&lt;/code&gt; 実行されます。</target>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="translated">制御が&lt;a href=&quot;main_function&quot;&gt;メイン関数の&lt;/a&gt;終わりに達した場合、 &lt;code&gt;return 0;&lt;/code&gt; 実行されます。</target>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="translated">ポインター宣言で &lt;code&gt;*&lt;/code&gt; の後にcvが現れる場合、それは宣言子の一部であり、宣言されているポインターに適用されます。</target>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="translated">ポインター宣言でcvが &lt;code&gt;*&lt;/code&gt; の前にある場合、それはdecl-specifier-seqの一部であり、指し示されたオブジェクトに適用されます。</target>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="translated">宣言 &lt;code&gt;D1&lt;/code&gt; と &lt;code&gt;D2&lt;/code&gt; が制約され、D1の関連制約がD2の関連制約を包含する場合（またはD2が制約されていない場合）、D1は</target>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">演繹が失敗するか、演繹は成功するが、それが生成する特殊化が無効になる場合（たとえば、パラメーターがクラスでも列挙型でもないオーバーロードされた演算子）（C ++ 14以降）特殊化はオーバーロードセットに含まれません&lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;に似ています。</target>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="translated">演繹が両方向で成功し、元の &lt;code&gt;P&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; が参照型であった場合、追加のテストが行​​われます。</target>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="translated">いずれかの場合には &lt;code&gt;M&lt;/code&gt; または &lt;code&gt;N&lt;/code&gt; は整数型ではない、またはいずれか（おそらくCV修飾）である場合 &lt;code&gt;bool&lt;/code&gt; 、プログラムが悪い形成されています。</target>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; または &lt;code&gt;src&lt;/code&gt; のいずれかがnullポインターの場合、 &lt;code&gt;count&lt;/code&gt; がゼロであっても、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; または &lt;code&gt;to&lt;/code&gt; のいずれかに実装定義の&lt;a href=&quot;file_type&quot;&gt;ファイルタイプがある&lt;/a&gt;場合、この関数の効果は実装定義です。</target>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; または &lt;code&gt;to&lt;/code&gt; のいずれかが &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt; によって決定される通常のファイル、ディレクトリ、またはシンボリックリンクでない場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; または &lt;code&gt;n&lt;/code&gt; のいずれかがゼロの場合、ゼロを返します。それ以外の場合、 &lt;code&gt;|m|&lt;/code&gt; 最小公倍数を返します と &lt;code&gt;|n|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="translated">いずれかの場合は &lt;code&gt;p1&lt;/code&gt; または &lt;code&gt;p2&lt;/code&gt; 存在しない場合、エラーが報告されています。</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">どちらかの場合 &lt;code&gt;x&lt;/code&gt; NaNであるか、 &lt;code&gt;y&lt;/code&gt; が NaNで、NaNが返されます</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; のいずれかがNaNの場合、NaNが返されます</target>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;|m|&lt;/code&gt; 場合 または &lt;code&gt;|n|&lt;/code&gt; 型 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; 値として表現できない場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">どちらかの引数がNaNの場合はNaNを返す</target>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">指定されていないにもかかわらずいずれかの関数が宣言されている場合、その関数の宣言（必ずしも定義ではない）が正当であることが保証されている場合を除いて、戻り値の型は指定されていません。これにより、 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt; をインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="translated">どちらかのオペランドがスコープされた列挙型を持っている場合、変換は行われません。</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">余りか商のどちらかを表現できない場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="translated">開始時に消去する場合-消去された要素のみ</target>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="translated">終了時に消去する場合-消去された要素と過去の終了時のイテレータのみ</target>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="translated">エラーが発生して &lt;code&gt;p&lt;/code&gt; が存在するかどうかさえわからない場合、非スローオーバーロードは &lt;code&gt;ec&lt;/code&gt; を設定して &lt;code&gt;file_status(file_type::none)&lt;/code&gt; を返し、スローオーバーロードは &lt;code&gt;filesystem_error&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">アルゴリズムの一部として呼び出された関数の &lt;code&gt;ExecutionPolicy&lt;/code&gt; が例外をスローし、ExecutionPolicyが&lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;標準ポリシーの&lt;/a&gt; 1つである場合、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。その他の &lt;code&gt;ExecutionPolicy&lt;/code&gt; の場合、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">アルゴリズムの一部として呼び出された関数の &lt;code&gt;ExecutionPolicy&lt;/code&gt; が例外をスローし、ExecutionPolicyが&lt;a href=&quot;execution_policy_tag_t&quot;&gt;標準ポリシーの&lt;/a&gt; 1つである場合、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。その他の &lt;code&gt;ExecutionPolicy&lt;/code&gt; の場合、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="translated">配列の宣言でexprを省略すると、宣言された型は「Tの不明な境界の配列」になります。これは、&lt;a href=&quot;aggregate_initialization&quot;&gt;集計初期化子&lt;/a&gt;を使用した宣言で使用される場合を除き、一種の&lt;a href=&quot;incomplete_type&quot;&gt;不完全な型&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="translated">式が NULL ポインタの値として評価された場合、デストラクタは呼び出されず、deallocation 関数は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="translated">式がヌルポインタの値に評価された場合、デストラクタは呼び出されず、deallocation関数が呼び出されたり、呼び出されなかったりしますが(これは実装で定義されています)、デフォルトのdeallocation関数はヌルポインタが渡された場合には何もしないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="translated">式が&lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;で割り当てられたオブジェクトの基本クラスサブオブジェクトへのポインターに評価される場合、基本クラスのデストラクターは仮想でなければなりません。それ以外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="translated">式の配列型が &lt;code&gt;A&lt;/code&gt; で、参照演算子が存在しない場合、 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; の型は</target>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="translated">expressionがクラスタイプのprvalueを返す関数呼び出しであるか、または右オペランドがそのような関数呼び出しである&lt;a href=&quot;operator_other&quot;&gt;コンマ式&lt;/a&gt;である場合、そのprvalueに一時オブジェクトは導入されません。</target>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="translated">式が（括弧で囲まれた）&lt;a href=&quot;consteval&quot;&gt;即時呼び出し&lt;/a&gt;（C ++ 20以降）以外のprvalueである場合、一時オブジェクトはそのprvalueから&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;具体化さ&lt;/a&gt;れません。</target>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">expressionがprvalueの場合、結果オブジェクトはその式によって直接初期化されます。タイプが一致する場合、これにはコピーまたは移動コンストラクターは含まれません（&lt;a href=&quot;copy_elision&quot;&gt;コピー省略を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="translated">式が本文で、または最も内側の囲み関数またはラムダ式のパラメーターとして宣言された自動ストレージ期間オブジェクトの（場合によっては括弧で囲まれた）名前である左辺値式である場合、&lt;a href=&quot;overload_resolution&quot;&gt;解決&lt;/a&gt;をオーバーロードして、コンストラクターの初期化に使用するコンストラクターを選択します戻り値、または &lt;code&gt;co_return&lt;/code&gt; の場合、 &lt;code&gt;promise.return_value()&lt;/code&gt; のオーバーロードを選択します（C ++ 20以降）</target>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="translated">expressionがnullポインターではなく、&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;割り当て解除関数&lt;/a&gt;が破壊的な削除ではない場合（C ++ 20以降）、 &lt;code&gt;delete&lt;/code&gt; 式は、&lt;a href=&quot;destructor&quot;&gt;破壊さ&lt;/a&gt;れているオブジェクトまたは破壊されている配列のすべての要素に対してデストラクター（存在する場合）を呼び出します（配列の最後の要素から最初の要素に進む）。</target>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="translated">抽出が失敗した場合（たとえば、数字が予想される場所に文字が入力された場合）、 &lt;code&gt;value&lt;/code&gt; は変更されずにそのままになり、 &lt;code&gt;failbit&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="translated">抽出に失敗すると、 &lt;code&gt;value&lt;/code&gt; ゼロが書き込まれ、 &lt;code&gt;failbit&lt;/code&gt; が設定されます。抽出の結果、値が大きすぎたり小さすぎて &lt;code&gt;value&lt;/code&gt; に収まらない場合、 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; が書き込まれ、 &lt;code&gt;failbit&lt;/code&gt; フラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="translated">機能テストがサポートされる場合、機能は、ここで説明したマクロ定数ので示されている &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; 同等以上の値を持つ &lt;code&gt;201505&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">一部の &lt;code&gt;c&lt;/code&gt; について、 &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; がtrueの場合、 &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="translated">ローカルスコープにフォワード宣言が現れた場合</target>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="translated">実装されている場合、ファイルから読み込める残りの文字数を返します。</target>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="translated">init-statementを使用する場合は、if文と同等です。</target>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="translated">init-statementを使用した場合は、switch文と同等です。</target>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="translated">新しい表現は、任意のストレージを割り当てられている場合（例えば、コンストラクタから）例外をスローすることにより、もし初期化が終了するが、それは適切な呼び出し&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;解放機能&lt;/a&gt;： &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; 非配列のための &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; 配列のための &lt;code&gt;type&lt;/code&gt; 。割り当て解除関数は、new-expressionが &lt;code&gt;::new&lt;/code&gt; 構文を使用している場合はグローバルスコープで検索され、それ以外の場合は、 &lt;code&gt;T&lt;/code&gt; がクラス型の場合は &lt;code&gt;T&lt;/code&gt; のスコープで検索されます。失敗した割り当て関数が通常（配置以外）の場合、割り当て解除関数の検索は、&lt;a href=&quot;delete&quot;&gt;delete-expressionで&lt;/a&gt;説明されている規則に従います。失敗した配置newの場合、一致する割り当て解除関数のすべてのパラメータータイプ（最初のものを除く）は、配置newのパラメーターと同じでなければなりません。割り当て解除関数の呼び出しは、最初の引数として渡された割り当て関数、オプションの配置引数（C ++ 17以降）として &lt;code&gt;placement_params&lt;/code&gt; 、および追加の配置引数として配置された場合はPlacement_paramsから以前に取得された値になります。割り当て解除関数が見つからない場合、メモリは割り当て解除されません。</target>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子が中括弧で囲まれた引数のリストである場合、配列は&lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子が中括弧で囲まれた引数のリストである場合、オブジェクトは&lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子が括弧で囲まれた引数のリストである場合、配列は&lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子が括弧で囲まれた引数のリストである場合、オブジェクトは&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化されます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">初期化子がない場合、各要素は&lt;a href=&quot;default_initialization&quot;&gt;デフォルトで初期化されます&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子がない場合、オブジェクトは&lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">初期化子が括弧の空のペアである場合、各要素は&lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="translated">省略された名前の後にフルネームに有効な文字が続く場合、フルネームのすべての文字を消費するか、期待されない文字が見つかるまで読み込みを続け、その場合、最初の数文字が有効な省略形であっても解析に失敗します。</target>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="translated">それがconstではないxvalueである場合、それが参照するオブジェクトは有効ではあるが指定されていない状態にあります。</target>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="translated">l&amp;ge;128の場合、動作は実装定義です</target>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="translated">lineno が 0 または 32767(C++11 まで)2147483647(C++11 以降)より大きい場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="translated">lookupで複数の割り当て解除関数が見つかった場合、呼び出される関数は次のように選択されます（これらの関数とその効果の詳細については、&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;割り当て解除関数&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="translated">ユニオンのメンバがユーザ定義のコンストラクタとデストラクタを持つクラスである場合、アクティブなメンバを切り替えるには、一般的に明示的なデストラクタとプレースメントnewが必要になります。</target>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="translated">複数のマッチが可能な場合は、どのマッチも許容される結果となります。</target>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="translated">つ以上の好ましい関数が見つかった場合、次のステップでは好ましい関数のみが考慮される。</target>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="translated">実装で定義されている共有所有者の最大数を超えてすでに共有モードでミューテックスをロックしている場合、 &lt;code&gt;lock_shared&lt;/code&gt; は共有所有者の数が減るまで実行をブロックします。所有者の最大数は、少なくとも10000であることが保証されています。</target>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="translated">複数のコンストラクタが実行可能であるが、どれも他のコンストラクタより優れていない場合、暗黙の変換シーケンスは曖昧な変換シーケンスである。</target>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">複数のスレッドが同じ静的ローカル変数を同時に初期化しようとした場合、初期化は1回だけ行われます（ &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; して任意の関数で同様の動作を取得できます）。</target>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="translated">複数の実行アクセスのスレッド同じ場合 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 同期なしオブジェクトとそれらのアクセスのいずれかの非constメンバ関数使用 &lt;code&gt;shared_ptr&lt;/code&gt; すべてのそのようなアクセスはのインスタンスを介して行われない限り、データ競合が発生する &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; （または、std :: shared_ptrへのアトミックアクセスのための&lt;a href=&quot;atomic&quot;&gt;スタンドアロン関数&lt;/a&gt;を介して、C ++ 20で非推奨）。</target>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="translated">実行アクセスの場合は、複数のスレッドが同一 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 同期なしオブジェクトとそれらのアクセスのいずれかの非constメンバ関数使用 &lt;code&gt;shared_ptr&lt;/code&gt; すべてのそのようなアクセスはのオーバーロードされているこれらの機能を介して行われない限り、データ競合が発生します対応するアトミックアクセス関数（ &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">実行アクセスの場合は、複数のスレッドが同一 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 同期せずにオブジェクトとそれらのアクセスのいずれかの非constメンバ関数使用 &lt;code&gt;weak_ptr&lt;/code&gt; 全てのこのようなアクセスはのインスタンスを介して行われない限り、データ競合が発生する &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">n&amp;gt; = 128の場合、動作は実装定義です。</target>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="translated">必要な場合は、ステータス取得 &lt;code&gt;to&lt;/code&gt; 単一の呼び出しを超えないことで、</target>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="translated">どちらの場合 &lt;code&gt;*this&lt;/code&gt; や &lt;code&gt;other&lt;/code&gt; 値が含まれ、この関数は効果がありません。</target>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">どちらの場合 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; も &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 、また任意の実装定義のポリシーフラグが設定され &lt;code&gt;policy&lt;/code&gt; 、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">キャプチャが指定されていない場合、クロージャ型はデフォルトのコピー割り当て演算子とデフォルトの移動割り当て演算子を持っています。それ以外の場合は、削除されたコピー代入演算子を持ちます(これには、実際には何もキャプチャーしていなくても、キャプチャーデフォルトがある場合も含まれます)。</target>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">キャプチャが指定されていない場合、クロージャ型はデフォルトのデフォルトコンストラクタを持ちます。それ以外の場合は、デフォルトのコンストラクタを持ちません(これには、実際には何もキャプチャーしていなくても、キャプチャーデフォルトがある場合も含まれます)。</target>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字が抽出されない場合、 &lt;code&gt;std::ios::failbit&lt;/code&gt; がonに設定されている &lt;code&gt;is&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; がスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="translated">文字が抽出されない場合、 &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">文字が抽出されなかった場合は、 &lt;code&gt;setstate(failbit)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="translated">文字が抽出されなかった場合は、 &lt;code&gt;setstate(failbit)&lt;/code&gt; を呼び出します。いずれの場合でも、 &lt;code&gt;count&amp;gt;0&lt;/code&gt; の場合、ヌル文字（ &lt;code&gt;CharT()&lt;/code&gt; が配列の次の連続する場所に格納されます。</target>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="translated">文字が挿入されていない場合は、 &lt;code&gt;setstate(failbit)&lt;/code&gt; を実行します。抽出中に例外がスローされた場合は、セットが &lt;code&gt;failbit&lt;/code&gt; 場合、および &lt;code&gt;failbit&lt;/code&gt; がに設定されている &lt;code&gt;exceptions()&lt;/code&gt; 、例外を再スロー。</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">変換が行われなかっできる場合は、 &lt;code&gt;​0​&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">エラーが発生しない場合</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">エラーが発生しない場合は ln(1+arg)が返されます。</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">エラーが発生しない場合</target>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="translated">エラーが発生しない場合は、 &lt;code&gt;base&lt;/code&gt; 乗 &lt;code&gt;exp&lt;/code&gt; （又は &lt;code&gt;iexp&lt;/code&gt; ）（baseexp</target>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="translated">エラーが発生しない場合は、 &lt;code&gt;x&lt;/code&gt; に2を掛けて &lt;code&gt;exp&lt;/code&gt; （x&amp;times;2exp</target>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="translated">エラーが発生しない場合は、 &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;arg&lt;/code&gt; の累乗で乗算します（x&amp;times;FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">エラーが発生しない場合、範囲[0; の &lt;code&gt;z&lt;/code&gt; の複素逆余弦が返されます。&amp;infin;）実軸に沿って[-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">エラーが発生しない場合は、虚数軸に沿って境界のないストリップの範囲で、区間[&amp;minus;&amp;pi; / 2;内にある &lt;code&gt;z&lt;/code&gt; の複素逆正弦が返されます。実軸に沿って+&amp;pi;/ 2]。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
