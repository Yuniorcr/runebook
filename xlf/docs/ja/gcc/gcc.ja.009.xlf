<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">外部、弱い、または初期化されていない共通シンボルではない小さなデータオブジェクトのGP相対アクセスを生成します。また、 &lt;code&gt;section&lt;/code&gt; 属性を介して小さなデータセクションに明示的に配置されたオブジェクトには、GP相対アドレッシングを使用します。</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">関数ポ イ ン タ ー と デー タ ポ イ ン タ ーのための GP 相対アドレスを生成します。このオプションを使用する場合、プログラムのテキスト、データ、および BSS セグメント全体が 64K のメモリに収まる必要があり、適切なリンカースクリプトを使用してグローバル ポインタのアドレス可能範囲内に割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">交互関数でMIPS16コードを生成します。このオプションは、MIPS16/非MIPS16の混在コード生成のリグレッションテストのために提供されるものであり、ユーザーコードをコンパイルする際の通常の使用を意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">大型モデル用のPowerPC64コードを生成します。TOCは4Gまでのサイズになる可能性があります。その他のデータやコードは64ビットのアドレス空間でのみ制限されます。</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">中型モデル用のPowerPC64コードを生成します。TOCやその他の静的データは合計4Gまでのサイズになる可能性があります。これは64ビットLinuxのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">小型モデル用のPowerPC64コードを生成します。TOCは64kに制限されています。</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">AltiVec コードを生成する際に VRSAVE 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">すべてのリターン・インスツルメンテーション・コードを指す __return_loc セクションを生成します。</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 関数の最後で関数 &lt;code&gt;abort&lt;/code&gt; の呼び出しを生成します。関数が復帰しようとした場合に実行されます。</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">コードを正しく実行するために厳密に必要でない場合でも、すべての関数に対してARMプロシージャコール規格に準拠したスタックフレームを生成します。指定する</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">すべてのリーフ関数について、Thumb Procedure Call Standard に準拠したスタック・フレームを生成します。(リーフ関数とは、他の関数を呼び出さない関数のことです。)既定値は</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">リーフ関数以外のすべての関数について、Thumb Procedure Call Standard に準拠したスタック・フレームを生成します。(リーフ関数とは、他の関数を呼び出さない関数のことです。)既定値は</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">デフォルトではなくELF形式で実行可能ファイルを生成する '</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; バイト以下であるが、非ループのインラインブロック比較拡張の制限を超えるすべてのブロック比較のループコードを使用して、インライン拡張を生成します。ブロック長が一定でない場合、ブロックの残りを比較するために &lt;code&gt;memcmp&lt;/code&gt; が呼び出される前に、最大で &lt;var&gt;num&lt;/var&gt; バイトが比較されます。デフォルト値はターゲット固有です。</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">ビッグエンディアンコードを生成します。</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">ビッグエンディアンコードを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">ビッグエンディアンコードを生成します。これは、GCCが「</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">レジスタ間接呼び出しとして呼び出しを生成し、32ビットのアドレス範囲全体へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">選択的スケジューリングにおける制御投機のチェックを生成します。このフラグはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">浮動小数点命令を含むコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含むコードを生成します。</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">32ビットまたは64ビットのABI用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">DarwinとSVR4ターゲット(GNU/Linuxを含む)の32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、int、long、ポインタを32ビットに設定し、任意のPowerPCバリアント上で動作するコードを生成します。64ビット環境では、intを32ビットに、longとポインタを64ビットに設定し、PowerPC64用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">CR16CまたはCR16C+アーキテクチャ用のコードを生成します。CR16C+アーキテクチャがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4-100用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-100のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように SH4-100 のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">SH4-100 のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4-200用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-200のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように、SH4-200用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">SH4-200のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-300のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように、SH4-300用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">SH4-300のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">SH4-340用のコードを生成します(MMU、FPU内)。</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">SH4-500(FPUなし)のコードを生成します。合格</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">スマートモードのコードを生成し、0~7番のレジスタのみを使用して16ビット命令を使用できるようにします。このオプションはCK801では無視され、CK802ではデフォルトでオンになります。他のターゲットでは、デフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">16ビット、32ビット、64ビット環境用のコードを生成します。このような環境では</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">int、long、ポインタを32ビットに設定する32ビット環境用のコードを生成します。これは唯一サポートされている動作なので、このフラグは基本的に無視されます。</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64ビット環境では、32ビットにint、64ビットにlongとポインタが設定されます。</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64 ビット環境では、int を 32 ビットに、long を 64 ビットに、ポインタを 64 ビットに設定します。これらはHP-UX固有のフラグです。</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64ビット環境では、intを32ビットに、longとポインタを64ビットに設定します。</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11/10用のコードを生成します。msoft-float -mno-splitを意味します。</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11/40用のコードを生成します。msoft-float -mno-splitを意味します。</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">PDP-11/45 のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">ビッグエンディアンターゲットのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">ビッグエンディアンターゲットのコードを生成します。これはHP-UXのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。これはAIX5とGNU/Linuxのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">ビッグエンディアンモードで動作するプロセッサ用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">リトルエンディアンモードで動作するプロセッサ用のコードを生成します。これはすべての標準構成のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">特定のM680x0またはColdFire命令セットアーキテクチャのコードを生成します。M680x0アーキテクチャの &lt;var&gt;arch&lt;/var&gt; の許容値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">特定のM680x0またはColdFireプロセッサのコードを生成します。M680x0 &lt;var&gt;cpu&lt;/var&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">特定のRISC-V ISAのコードを生成します（例： '</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">指定されたPTX ISAを指定してコードを生成します（例： '</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">分割命令エミュレーションを必要とするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">乗算命令エミュレーションを必要とするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">除算命令をサポートするハードウェア用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">乗算命令をサポートするハードウェア用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">右回転命令をサポートするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">フラグの即時設定（ &lt;code&gt;l.sf*i&lt;/code&gt; ）命令をサポートするハードウェアのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">シフト関連の命令（ &lt;code&gt;l.srai&lt;/code&gt; 、 &lt;code&gt;l.srli&lt;/code&gt; 、 &lt;code&gt;l.slli&lt;/code&gt; 、 &lt;code&gt;1.rori&lt;/code&gt; ）をサポートするハードウェアのコードを生成します。 &lt;code&gt;l.rori&lt;/code&gt; 命令の生成を有効にするには、</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">符号拡張命令をサポートするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">条件付き移動（ &lt;code&gt;l.cmov&lt;/code&gt; ）命令をサポートするハードウェアのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">最大スループット・アルゴリズムを使用して浮動小数点値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用して浮動小数点値をインラインで分割するコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">最大スループットアルゴリズムを使用して整数値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用して整数値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">最大スループットアルゴリズムを使用してインライン平方根のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用してインライン平方根のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">ロングアドレスモード用のコードを生成します。これは64ビットおよびx32環境でのみサポートされています。64 ビット環境ではデフォルトのアドレスモードです。</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">ショートアドレスモード用のコードを生成します。これは32ビットおよびx32環境でのみサポートされています。32ビットおよびx32環境ではデフォルトのアドレスモードです。</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">210プロセッサ用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">libgcc の代わりに C-SKY コンパイラのランタイム用のコードを生成します。このオプションのデフォルトはoffです。</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">H8/300Hのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">ノーマルモードでH8SとH8/300Hのコードを生成します。このスイッチは</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">H8S用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">H8S/2600用のコードを生成します。このスイッチは</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">M32R のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">M32R/2のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">M32R/X用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">SH1のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">SH2のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">FPUを使用しないSH2a用、または浮動小数点単位を使用しないSH2a-FPU用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットが倍精度モードになっていると仮定して、SH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">SH2eのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">SH3のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">SH3eのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">単精度演算のみをサポートする浮動小数点ユニットを持つSH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">浮動小数点ユニットを使用しないSH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">SH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">SH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">SH4al-dsp用のコード、または浮動小数点単位を使用しないようにSH4a用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">与えられたABIのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">カーネルコードモデルのコードを生成します。カーネルはアドレス空間の負の2GBで動作します。このモデルはLinuxカーネルコードに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">ラージ・コード・モデルのコードを生成します。これは、アドレスやセクションのサイズについての仮定をしません。プログラムは静的にのみリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="1e1198ebae196f98c194fd331b5a616e80bed1c4" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only. The</source>
          <target state="translated">ラージ・コード・モデルのコードを生成します。これは、アドレスやセクションのサイズについての仮定をしません。プログラムは静的にのみリンクすることができます。このような場合には</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">大規模モデル用のコードを生成します。呼出距離、PC 相対アドレス、絶対アドレスに制限はありません。</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">ラージ・モデルのコードを生成します。このモデルでは、アドレスやセクションのサイズについては何も仮定していません。</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">中型モデルのコードを生成:プログラムはアドレス空間の下位2GBにリンクされています。小さなシンボルもそこに配置されます。よりも大きなサイズのシンボルは</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">中・任意コードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、任意の2GiBアドレス範囲内になければなりません。プログラムは静的にも動的にもリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">ミディアムローコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、2GiBのアドレス範囲内に存在し、絶対アドレス-2GiBと+2GiBの間に存在しなければなりません。プログラムは、静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">スモールコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、互いに4GB以内でなければなりません。プログラムは静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">スモールコードモデルのコードを生成します:プログラムとそのシンボルは、アドレス空間の下位2GBにリンクされている必要があります。ポインタは64ビットです。プログラムは静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">小型モデルのコードを生成します。直接通話の距離はどちらか一方の方向に500Mまでとします。PC関連のアドレスは32ビットです。絶対アドレスは全アドレス範囲をサポートしています。</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">指定されたABIのコードを生成します。許容値は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">指定されたアーキテクチャのコードを生成します。 &lt;var&gt;architecture-type&lt;/var&gt; の選択肢は '</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">指定された呼び出し規約のコードを生成します。許容値は '</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">指定されたデータモデルのコードを生成します。許容値は '</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">一般レジスタへのアクセスに制限がないスーパバイザモード用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">小さなコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは,互いに1MB以内でなければならない.プログラムは静的にも動的にもリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">いくつかの一般的なレジスタへのアクセスが禁止されているユーザモード用のコードを生成します:GR5では、このモードではレジスタr24からr31にアクセスできません;GR6ではレジスタr29からr31のみが影響を受けます。</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">OpenMP のオフロードで使用するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">ビッグエンディアンモードでコードを生成します。</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">ビッグエンディアン、リトルエンディアンモードでそれぞれコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">リトルエンディアンモードでコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">大きなスイッチテーブルに適したコードを生成します。このオプションは、アセンブラ/リンカがスイッチテーブル内の範囲外の分岐について文句を言う場合にのみ使用します。</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">GDBが動的にロードできるようにするなど、迅速なターンアラウンド開発に適したコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">オペレーティングシステム内のトレースルーチンにTPF OS固有のブランチを追加する(追加しない)コードを生成します。このオプションは、TPF OS 用にコンパイルする場合でも、デフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">静的実行可能ファイルを実行時に別のアドレスに再配置できるようにする（許可しない）コードを生成します。単純な組み込みPowerPCシステムローダーは、 &lt;code&gt;.got2&lt;/code&gt; のコンテンツ全体と、このオプションによって生成される32ビットアドレスのテーブルである &lt;code&gt;.fixup&lt;/code&gt; セクションにリストされている4バイトの場所を再配置する必要があります。これが機能するためには、リンクされているすべてのオブジェクトが</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld&lt;/code&gt; および &lt;code&gt;ld.so&lt;/code&gt; が実行可能でない &lt;code&gt;.plt&lt;/code&gt; および &lt;code&gt;.got&lt;/code&gt; セクションを含む実行可能ファイルと共有ライブラリを構築できるようにするコードを生成します。これは、PowerPC 32ビットSYSV ABIオプションです。</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">データセグメントがテキストセグメントとは異なるメモリ領域に位置するようにするコードを生成します。これにより、テキスト部分に対する再配置を排除することで、仮想メモリ管理のない環境でもその場での実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">データセグメントがテキストセグメントとは異なるメモリ領域に配置されるようにするコードを生成します。これにより、仮想メモリ管理のない環境でも、その場で実行できるようになります。このオプションは</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">トラップ命令が例外をスローできるようにするコードを生成します。これには、どこにも存在しないプラットフォーム固有のランタイムサポートが必要であることに注意してください。さらに、&lt;em&gt;トラッピング&lt;/em&gt;命令が例外をスローすることのみを許可します（メモリ参照または浮動小数点命令など）。 &lt;code&gt;SIGALRM&lt;/code&gt; などの任意のシグナルハンドラから例外をスローすることはできません。</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">すべての呼び出しが遠くにあると仮定して(仮定しない)、より長い高価な呼び出しシーケンスが必要となるようなコードを生成します。</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">呼び出しが空間の境界を越えないことを前提としたコードを生成します。これにより、GCCは間接的な呼び出しを高速に実行するコードを生成することができます。</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">データセグメントがテキストセグメントに続くことを前提としたコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">ターゲットがスペースレジスタを持たないことを前提としたコードを生成します。これにより、GCC はより高速な間接呼び出しを生成し、スケールされていないインデックスアドレスモードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="355b3cfdddf15ceae95ec40c1959bb7baa77194d" translate="yes" xml:space="preserve">
          <source>Generate code that changes (does not change) the default branch targets enabled by</source>
          <target state="translated">で有効になっているデフォルトのブランチターゲットを変更する(変更しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">浮動小数点レジスタセットを使用しない(使用しない)コードを生成します。ソフトウェア浮動小数点エミュレーションは</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">スタックストレージに直接 &lt;code&gt;.local&lt;/code&gt; メモリを使用しないコードを生成します。代わりに、ワープごとのスタックポインターが明示的に維持されます。これにより、可変長のスタック割り当てが可能になり（可変長配列または &lt;code&gt;alloca&lt;/code&gt; を使用）、基になるストレージにグローバルメモリが使用されている場合、他のスレッドから、またはアトミック命令を使用して自動変数にアクセスできます。このコード生成バリアントはOpenMPオフロードに使用されますが、オプションはコンパイラーをテストする目的で単独で公開されます。OpenMPオフロードを使用してプログラムにリンクするのに適したコードを生成するには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">グローバルポインタレジスタを使用しないコードを生成します。その結果は位置に依存しないコードではなく、IA-64 ABIに違反します。</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">IDベースの共有ライブラリが使用されていることを前提としないコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">自己再配置可能なコードを生成します。これは</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">Power8 以降のプロセッサで命令を融合できるように、いくつかの整数演算を隣接して保持する (保持しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">グローバルレジスタ &lt;code&gt;$231&lt;/code&gt; を使用するGNU ABIとは対照的に、関数のパラメーターと戻り値（呼び出された関数内）がレジスタ &lt;code&gt;$0&lt;/code&gt; と見なされるコードを生成します。</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; で実行されるコードを生成します。これは、汎用MIPS ISAの名前、または特定のプロセッサーの名前にすることができます。ISA名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">特定のプロセッサタイプを表すシステムの名前である &lt;var&gt;cpu-type&lt;/var&gt; で実行されるコードを生成します。 &lt;var&gt;cpu-type&lt;/var&gt; の可能な値は '</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">ARM 命令セットと Thumb 命令セット間の呼び出しをサポートするコードを生成します。このオプションがないと、v5 以前のアーキテクチャでは、2 つの命令セットを 1 つのプログラム内で確実に使用できません。デフォルトは</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成しますが、このライブラリまたは実行可能ファイルは他のID共有ライブラリとリンクしないと想定しています。これにより、コンパイラはジャンプと呼び出しにより高速なコードを使用できます。</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">ライブラリIDメソッドで共有ライブラリをサポートするコードを生成します。これにより、仮想メモリ管理のない環境でも、その場で実行したり、共有ライブラリを利用したりすることが可能になります。このオプションは</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">ライブラリIDメソッドで共有ライブラリをサポートするコードを生成します。これにより、仮想メモリ管理のない環境での実行インプレースや共有ライブラリの利用が可能になります。このオプションは</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">インデックス付きロード命令やストア命令の使用を回避しようとする(回避しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">インデックス付きロード命令やストア命令の使用を避けようとする(避けない)コードを生成します。これらの命令は、16M の境界を越える大規模な配列をステップスルーする場合など、特定の状況では Power6 プロセッサでパフォーマンスのペナルティを受ける可能性があります。このオプションは、Power6 をターゲットにしている場合はデフォルトで有効になっており、そうでない場合は無効になっています。</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">AltiVec 命令を使用する(使用しない)コードを生成し、AltiVec 命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にします。を設定する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">AltiVec 命令を使用する(使用しない)コードを生成します。32 ビットコードでは、以下の場合を除き、AltiVec 命令を有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">ISEL命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">IEEEの単精度と倍精度の代わりにVAX FとGの浮動小数点演算を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">POWER6Xプロセッサや拡張PowerPC V2.05アーキテクチャをサポートする他のプロセッサで実装されているFPの汎用レジスタへの移動命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">POWER5+プロセッサやPowerPC V2.03アーキテクチャをサポートする他のプロセッサに実装されたFPラウンドから整数命令までを使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">アトミック・クワッドワードメモリ命令を使用する(使用しない)コードを生成します。のように、そのようなコードを生成するためには</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">POWER6 プロセッサおよび PowerPC V2.05 アーキテクチャをサポートする他のプロセッサで実装されている compare bytes 命令を使用する (使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">いくつかのPOWERプロセッサで実装されている10進浮動小数点命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">浮動小数点乗算および累積命令を使用する(使用しない)コードを生成します。ハードウェア浮動小数点を使用する場合、これらの命令はデフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">浮動小数点乗算および累積命令を使用する(使用しない)コードを生成します。ハードウェア浮動小数点を使用する場合、これらの命令はデフォルトで生成されます。マシンに依存する</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">浮動小数点レジスタセットを使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">ペアリングされた simd 命令の生成を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">IBM 405、440、464、および 476 プロセッサ上のハーフワード乗算および乗算累積命令を使用する (使用しない)コードを生成します。これらの命令は、これらのプロセッサをターゲットにしている場合、デフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">複数ワードのロード命令と複数ワードのストア命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">複数ワードのロード命令と複数ワードのストア命令を使用する(使用しない)コードを生成します。これらの命令は、POWER システムではデフォルトで生成され、PowerPC システムでは生成されません。使用しないでください。</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">ベースレジスタを計算されたメモリ位置のアドレスに更新するロード命令またはストア命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">ベースレジスタを計算されたメモリ位置のアドレスに更新するロード命令またはストア命令を使用する(使用しない)コードを生成します。これらの命令はデフォルトで生成されます。を使用する場合は</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">ロード文字列命令とストア文字列ワード命令を使用する(使用しない)コードを生成して、複数のレジスタを保存し、小さなブロック移動を行います。</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">POWER4プロセッサやPowerPC V2.01アーキテクチャをサポートする他のプロセッサで実装されている条件レジスタフィールド命令からの移動を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">非原子型クワッドワードメモリ命令を使用する(使用しない)コードを生成します。このようなコードを生成するためには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">浮動小数点平方根を含む汎用グループのオプションのPowerPCアーキテクチャ命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">グラフィックスグループのオプションのPowerPCアーキテクチャ命令(浮動小数点選択を含む)を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">POWER5プロセッサやPowerPC V2.02アーキテクチャをサポートする他のプロセッサで実装されているpopcountおよび倍精度FP逆見積命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">POWER7 プロセッサおよび PowerPC V2.06 アーキテクチャをサポートする他のプロセッサで実装された popcount 命令を使用する (使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">string-searchを使用する（使用しない）コードを生成する</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">PowerPC ISA のバージョン 2.07 で追加されたベクトル命令とスカラ命令を使用する(使用しない)コードを生成します。また、ベクター命令へのより直接的なアクセスを可能にする組み込み関数の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">ベクトル/スカラ(VSX)命令を使用する(使用しない)コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">ベクトル/スカラ(VSX)命令を使用する(使用しない)コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用を有効にします。32 ビットコードでは、以下の場合を除き、VSX 命令や AltiVec 命令を有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld.so&lt;/code&gt; が埋めるBSS &lt;code&gt;.plt&lt;/code&gt; セクションを使用するコードを生成し、書き込み可能で実行可能である &lt;code&gt;.plt&lt;/code&gt; および &lt;code&gt;.got&lt;/code&gt; セクションを必要とします。これは、PowerPC 32ビットSYSV ABIオプションです。</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">単一の定数グローバルポインタの値を使用するコードを生成します。これはカーネルコードをコンパイルするときに便利です。</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">長い呼び出しシーケンスを使用するコードを生成します。これにより、呼び出しがリンカで生成されたスタブに常に到達できるようになります。デフォルトでは、コール・サイトから関数または変換ユニットの先頭までの距離が、使用するブランチ・タイプによって設定された事前の制限を超えた場合にのみ、長いコールを生成するようになっています。通常の通話の制限は、PA 2.0 および PA 1.X アーキテクチャの場合、それぞれ 7,600,000 バイトおよび 240,000 バイトです。シブコールは常に 240,000 バイトに制限されています。</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">汎用レジスタのみを使用するコードを生成します。これにより、コンパイラが浮動小数点レジスタ、ベクターレジスタ、マスクレジスタ、バインドレジスタを使用することを防ぎます。</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">'を使用してスレッドローカルストレージにアクセスするコードを生成します</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">オーバーフローする前にスタックを自動的に分割するコードを生成します。結果として得られるプログラムは不連続なスタックを持ち、 プログラムがこれ以上メモリを確保できなくなった場合にのみオーバーフローすることができます。これはスレッド化されたプログラムを実行しているときに最も便利です。これは現在のところ、GNU/Linux を実行している x86 ターゲットにのみ実装されています。</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">MN10300プロセッサ用の乗算命令のバグを回避するためのコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">スタックが特定の値(レジスタの値またはシンボルのアドレス)を超えて大きくならないようにするコードを生成します。より大きなスタックが必要な場合、実行時にシグナルが発生します。ほとんどのターゲットでは、スタックが境界を超える前にシグナルが発生するので、特別な注意を払わなくてもシグナルをキャッチすることができます。</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">スタック衝突スタイルの攻撃を防ぐコードを生成します。このオプションを有効にすると、コンパイラは一度にスタック領域の1ページのみを割り当て、各ページは割り当て後すぐにアクセスされます。したがって、アロケーションがオペレーティングシステムによって提供されるスタックガードページを飛び越えてしまうことを防ぎます。</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">スタックの境界を超えていないことを検証するコードを生成します。複数のスレッドが存在する環境で実行している場合はこのフラグを指定する必要がありますが、シングルスレッド環境で指定する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">与えられたレジスタ範囲を固定レジスタとして扱うコードを生成します。固定レジスタとは、レジスタアロケータが使用できないレジスタのことです。これはカーネルコードをコンパイルするときに便利です。レジスタ範囲はダッシュで区切られた2つのレジスタとして指定されます。複数のレジスタ範囲をカンマで区切って指定することができます。</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; および &lt;code&gt;pop&lt;/code&gt; 命令を使用してコードを生成します。このオプションのデフォルトはオンです。</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">&lt;code&gt;stm&lt;/code&gt; および &lt;code&gt;ldm&lt;/code&gt; 命令を使用してコードを生成します。このオプションはCK801ではサポートされていませんが、他のプロセッサではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">AM33プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">AM33/2.0プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">AM34プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">グローバルアンカーシンボルアドレスを使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">FDPIC ABIを使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">16-31番の上位レジスタを使用してコードを生成します。このオプションはCK801、CK802、CK803ではサポートされておらず、他のプロセッサではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">汎用レジスタのみを使用するコードを生成します。これにより、コンパイラが浮動小数点レジスタやAdvanced SIMDレジスタを使用しないようになりますが、アセンブラには何の制限もかかりません。</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">コンパイラを生成して、指定されたUNIX標準の開始ファイルを事前定義および選択します。 &lt;var&gt;unix-std&lt;/var&gt; の選択肢は '</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">条件付きの動作命令を生成します。</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">分割命令を生成します。デフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">コンパクトな実装のためにチューニングされた倍精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">高速な実装のためにチューニングされた倍精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="6b4a611d12d60ad206db3327cb2ea87939e3d6cb" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. Only valid for</source>
          <target state="translated">拡張算術命令を生成します。現在、 &lt;code&gt;divaw&lt;/code&gt; 、 &lt;code&gt;adds&lt;/code&gt; 、 &lt;code&gt;subs&lt;/code&gt; 、および &lt;code&gt;sat16&lt;/code&gt; のみがサポートされています。のみ有効</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">拡張算術命令を生成します。現在、 &lt;code&gt;divaw&lt;/code&gt; 、 &lt;code&gt;adds&lt;/code&gt; 、 &lt;code&gt;subs&lt;/code&gt; 、 &lt;code&gt;sat16&lt;/code&gt; のみがサポートされています。これは常に有効です</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">インライン関数の拡張デバッグ情報を生成します。インラインのエントリポイントに位置ビュー追跡マーカーが挿入されるため、住所とビュー番号を計算してデバッグ情報に出力できます。これは、位置ビューとは無関係に有効にできます。その場合、ビュー番号は出力されませんが、ステートメントフロンティアと一緒にのみ有効にできます。デフォルトで有効になるのは、位置ビューが有効になっている場合のみです。</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">分析プログラム &lt;code&gt;prof&lt;/code&gt; に適したプロファイル情報を書き込むための追加コードを生成します（</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">選択した単位 &lt;var&gt;unit&lt;/var&gt; の浮動小数点演算を生成します。 &lt;var&gt;unit&lt;/var&gt; の選択肢は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">&lt;code&gt;rE&lt;/code&gt; イプシロンレジスタと比較する浮動小数点比較命令を生成します。</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">浮動小数点命令を生成します。これは68020以降、およびFPUを備えたColdFireデバイスのデフォルトです。これは、マクロ定義 &lt;code&gt;__HAVE_68881__&lt;/code&gt; M680x0ターゲットとの &lt;code&gt;__mcffpu__&lt;/code&gt; のColdFireターゲット上を。</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">&lt;code&gt;movli.l&lt;/code&gt; および &lt;code&gt;movco.l&lt;/code&gt; 命令のみを使用してハードウェアアトミックシーケンスを生成します。これはSH4Aでのみ利用可能で、マルチコアシステムに適しています。ハードウェア命令は32ビットのアトミック変数のみをサポートするため、8または16ビット変数へのアクセスは、32ビットアクセスでエミュレートされます。このオプションでコンパイルされたコードは、SH4Aシステムで実行された場合、他のソフトウェアアトミックモデル割り込み/例外処理システムとも互換性があります。このモデルでは、システムの割り込み/例外処理コードによる追加のサポートは必要ありません。</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">マシンタイプ &lt;var&gt;cpu-type&lt;/var&gt; の命令を生成します。とは対照的に</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">バレルシフターがサポートする命令を生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">関数の入り口と出口の計測呼び出しを生成します。関数の開始直後と関数の終了直前に、次のプロファイリング関数が、現在の関数のアドレスとその呼び出しサイトで呼び出されます。（一部のプラットフォームでは、 &lt;code&gt;__builtin_return_address&lt;/code&gt; は現在の関数を超えて機能しないため、それ以外の場合、プロファイリング関数で呼び出しサイト情報を利用できない場合があります。）</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">リトルエンディアン(デフォルト)とビッグエンディアン(実験的)のコードをそれぞれ生成します。</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">リトルエンディアンコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">リトルエンディアンコードを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">リトルエンディアンコードを生成します。これは、GCCが「</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">mul.xおよびumul.x命令を生成します。これは「</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; バイト以下のすべてのブロック比較（ &lt;code&gt;memcmp&lt;/code&gt; への呼び出しや構造体比較など）の非ループインラインコードを生成します。 &lt;var&gt;num&lt;/var&gt; が0の場合、ブロック比較のすべてのインライン展開（非ループおよびループ）は無効になります。デフォルト値はターゲット固有です。</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">標準のGNU Objective-Cランタイムと互換性のあるオブジェクトコードを生成します。これは、ほとんどのタイプのシステムではデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">NeXTランタイムと互換性のある出力を生成します。これは、DarwinやMac OS Xを含むNeXTベースのシステムのデフォルトです。このオプションを使用する場合（およびその場合のみ）、マクロ &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; が事前定義されています。</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">浮動小数点用の80387命令を含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">浮動小数点命令を含む出力を生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。&lt;strong&gt;警告：&lt;/strong&gt;必要なライブラリは、すべてのHPPAターゲットで使用できるわけではありません。通常、マシンの通常のCコンパイラの機能が使用されますが、これはクロスコンパイルで直接行うことはできません。クロスコンパイルに適したライブラリ関数を提供するには、独自の配置を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。&lt;strong&gt;警告：&lt;/strong&gt;必要なライブラリは、すべてのSPARCターゲットで使用できるわけではありません。通常、マシンの通常のCコンパイラの機能が使用されますが、これはクロスコンパイルで直接行うことはできません。クロスコンパイルに適したライブラリ関数を提供するには、独自の配置を行う必要があります。埋め込まれたターゲット '</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">クワッドワード(long double)浮動小数点命令のライブラリ呼び出しを含む出力を生成します。呼び出される関数は SPARC ABI で指定されたものです。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">クワッドワード(long double)浮動小数点命令を含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">5206e ColdFire CPU の出力を生成します。このオプションは現在では廃止され、同等の</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">520X ColdFire CPU用の出力を生成します。これは、コンパイラが520Xベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">68000 用の出力を生成します。これは、68000ベースのシステム用にコンパイラが構成されている場合のデフォルトです。と同等です。</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">68010 用の出力を生成します。コンパイラが68010ベースのシステム用に構成されている場合のデフォルトです。と同等です。</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">68020 用の出力を生成します。コンパイラが68020ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">68030 用の出力を生成します。コンパイラが68030ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">新しい命令を使用せずに、68040用の出力を生成します。これにより、68020/68881、68030、68040のいずれかで比較的効率的に実行できるコードが生成されます。生成されたコードは、68040でエミュレートされた688881命令を使用します。</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">68040 用の出力を生成します。コンパイラが68040ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">新しい命令を使用せずに、68060の出力を生成します。これにより、68020/68881、68030、68040のいずれかで比較的効率的に実行できるコードが生成されます。生成されたコードは、68060でエミュレートされた688881命令を使用します。</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">68060 用の出力を生成します。コンパイラが68060ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">CPU32用の出力を生成します。これは、コンパイラがCPU32ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5307 CPU の出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5407 CPU の出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">ColdFire V4e ファミリー CPU (例:547x/548x)の出力を生成します。これには、ハードウェア浮動小数点命令の使用が含まれます。このオプションは次のものと同等です。</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 528X ファミリのメンバーの出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">パフォーマンス拡張2の命令を生成する。</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">パフォーマンス拡張命令を生成します。</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">位置に依存しないEABIコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">ターゲットマシンでサポートされている場合、共有ライブラリでの使用に適した位置非依存コード(PIC)を生成します。このようなコードは、グローバルオフセットテーブル(GOT)を介してすべての定数アドレスにアクセスします。ダイナミック・ローダーはプログラムの起動時に GOT エントリを解決します(ダイナミック・ローダーは GCC の一部ではなく、オペレーティング・システムの一部です)。リンクされた実行ファイルの GOT サイズがマシン固有の最大サイズを超えると、リンカから以下のようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0に&lt;/a&gt;ある「ARMv8-M Security Extensions：Development Tools Engineering Specificationの要件」に従って安全なコードを生成します。 PDF。</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">コンパクトな実装のためにチューニングされた単精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">高速な実装のためにチューニングされた単精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">&lt;code&gt;SR.IMASK = 1111&lt;/code&gt; 設定して、割り込みを一時的に無効にするソフトウェアアトミックシーケンスを生成します。このモデルは、プログラムが特権モードで実行されている場合にのみ機能し、シングルコアシステムにのみ適しています。システムの割り込み/例外処理コードからの追加サポートは必要ありません。ターゲットが &lt;code&gt;sh*-*-linux*&lt;/code&gt; およびSH1 *またはSH2 *の場合、このモデルはデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">スレッド制御ブロックで変数を使用するソフトウェアアトミックシーケンスを生成します。これは、gUSAシーケンスのバリエーションであり、SH1 *およびSH2 *ターゲットでも使用できます。生成されたアトミックシーケンスは、システムの割り込み/例外処理コードによる追加のサポートを必要とし、シングルコアシステムにのみ適しています。このモデルを使用する場合、「</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;guard&lt;/var&gt; カナリアを使用してスタック保護コードを生成します。サポートされている場所は '</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">文字列拡張命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">生成 &lt;code&gt;tas.b&lt;/code&gt; のオペコード &lt;code&gt;__atomic_test_and_set&lt;/code&gt; を。特定のハードウェアおよびソフトウェアの構成によっては、 &lt;code&gt;tas.b&lt;/code&gt; 命令によって暗黙的に指定されるオペランドキャッシュラインのフラッシュが原因で、全体的なパフォーマンスが低下する可能性があることに注意してください。マルチコアSH4Aプロセッサでは、特定のキャッシュ構成でデータが破損する可能性があるため、 &lt;code&gt;tas.b&lt;/code&gt; 命令は注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">サーバーIO の事前定義 &lt;code&gt;_SIO&lt;/code&gt; を生成します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">ターゲットマシンがサポートしている場合は、DWARF形式のアンワインドテーブルを生成します。テーブルは各命令境界で正確なので、非同期イベント(デバッガやガベージコレクタなど)からのスタックアンワインドに使用できます。</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">v3 push25/pop25命令を生成します。</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">生成されたコードはハードウェア割り込みに対応していません。コードサイズが小さくなります。</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">ビット操作用の &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">エラーメッセージを生成します。このプラグマ&lt;em&gt;は&lt;/em&gt;コンパイルのエラーを示す&lt;em&gt;と&lt;/em&gt;見なされ、そのように扱われます。</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;brk&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">&lt;code&gt;clrpsw&lt;/code&gt; マシン命令を生成して、プロセッサステータスワードの指定されたビットをクリアします。</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32b&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32l&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32q&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32w&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">&lt;code&gt;etnd&lt;/code&gt; 機械命令を生成します。現在の入れ子の深さは整数値として返されます。ネストの深さが0の場合、コードはトランザクションの一部として実行されません。</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;extractps&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;insertps&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">指定された値で割り込みを生成する &lt;code&gt;int&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">2つの引数の上位16ビットを乗算した結果をアキュムレータに追加するための &lt;code&gt;machi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">&lt;code&gt;maclo&lt;/code&gt; マシン命令を生成して、2つの引数の下位16ビットを乗算した結果をアキュムレータに追加します。</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; マシン命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; マシン命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">&lt;code&gt;movlps&lt;/code&gt; マシン命令をメモリからのロードとして生成します</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movlps&lt;/code&gt; マシン命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movss&lt;/code&gt; 機械命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; マシン命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; 機械命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">&lt;code&gt;mulhi&lt;/code&gt; 機械命令を生成して、2つの引数の上位16ビットを乗算した結果をアキュムレータに配置します。</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">2つの引数の下位16ビットを乗算した結果を &lt;code&gt;mullo&lt;/code&gt; に配置するためのmulloマシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの上位32ビットを読み取るための &lt;code&gt;mvfachi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの中央の32ビットを読み取るための &lt;code&gt;mvfacmi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">引数で指定された制御レジスタを読み取り、その値を返す &lt;code&gt;mvfc&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの上位32ビットを設定するための &lt;code&gt;mvtachi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">&lt;code&gt;mvtaclo&lt;/code&gt; マシン命令を生成して、アキュムレータの下位32ビットを設定します。</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">制御レジスタ番号 &lt;code&gt;reg&lt;/code&gt; を &lt;code&gt;val&lt;/code&gt; に設定する &lt;code&gt;mvtc&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">割り込み優先レベルを設定する &lt;code&gt;mvtipl&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">&lt;code&gt;ntstg&lt;/code&gt; 機械命令を生成します。2番目の引数は、最初の引数の場所に書き込まれます。トランザクションが中止された場合、ストア操作はロールバックされません。</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">コンパイラのメモリバリアを使用して &lt;code&gt;pause&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pclmulqdq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrb&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrd&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">64ビットモードで &lt;code&gt;pextrq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrb&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrd&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">&lt;code&gt;pinsrq&lt;/code&gt; マシン命令を64ビットモードで生成します。</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntl&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsigned long&lt;/code&gt; のサイズに応じて、 &lt;code&gt;popcntl&lt;/code&gt; または &lt;code&gt;popcntq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntq&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">&lt;code&gt;ppa rX,rY,1&lt;/code&gt; 機械語命令を生成します。整数パラメータがrXに読み込まれ、値0がrYに読み込まれます。integerパラメータは、トランザクションが繰り返し中止された回数を指定します。</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">指定されたモードに従ってアキュムレータを &lt;code&gt;racw&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">引数のバイトを交換する &lt;code&gt;revw&lt;/code&gt; マシン命令を生成します。これにより、ビット0〜7がビット8〜15を占有し、ビット16〜23がビット24〜31を占有します。</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">繰り返し乗算および累算シーケンスを開始する &lt;code&gt;rmpa&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">浮動小数点ステータスワードレジスタに設定されている現在の丸めモードに従って丸められた浮動小数点引数を返す &lt;code&gt;round&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">引数の飽和値を返す &lt;code&gt;sat&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">&lt;code&gt;setpsw&lt;/code&gt; マシン命令を生成して、指定されたビットをプロセッサステータスワードに設定します。</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">指定された中止コードを使用して、 &lt;code&gt;tabort&lt;/code&gt; 機械命令を生成します。0〜255の中止コードは予約されており、エラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">制約のないハードウェアトランザクションを開始する &lt;code&gt;tbegin&lt;/code&gt; 機械命令を生成します。パラメータがNULL以外の場合、メモリ領域はトランザクション診断バッファを格納するために使用され、最初のオペランドとして &lt;code&gt;tbegin&lt;/code&gt; に渡されます。このバッファは使用して定義することができる &lt;code&gt;struct __htm_tdb&lt;/code&gt; に定義されたC構造体 &lt;code&gt;htmintrin.h&lt;/code&gt; をダブルワード境界上に存在しなければなりません。 2番目のtbeginオペランドは &lt;code&gt;0xff0c&lt;/code&gt; に設定されます。これにより、すべてのGPRの保存/復元が有効になり、トランザクション本文内のFPRおよびAR操作の中止が無効になります。 tbegin命令によって設定された条件コードは整数値として返されます。定義により、tbegin命令はすべてのFPRの内容を上書きします。コンパイラーは、FPRを保存および復元するコードを生成します。ソフト浮動小数点コードの場合、 &lt;code&gt;*_nofloat&lt;/code&gt; を使用することをお勧めしますバリアント。TDBが書き込まれないようにするには、定数のゼロ値をパラメーターとして渡す必要があります。変数にゼロ値を渡すだけでは不十分です。トランザクション内のアクセスレジスタを変更してもトランザクションのアボートはトリガーされませんが、実際にそれらを変更することはサポートされていません。トランザクションの入力時にアクセスレジスタは保存されません。中止コードに到達すると、未定義の状態になります。</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">制約のあるハードウェアトランザクションを開始する &lt;code&gt;tbeginc&lt;/code&gt; 機械命令を生成します。2番目のオペランドは &lt;code&gt;0xff08&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">トランザクションを終了し、変更を他のスレッドから見えるようにする &lt;code&gt;tend&lt;/code&gt; 機械語命令を生成します。tendによって生成された条件コードは整数値として返されます。</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64、MMX、SSE、SSE2、SSE3およびSSSE3命令セットをサポートするジェネリックVIA Nano CPU。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">浮動小数点制御レジスタおよびステータスレジスタ(FPU制御レジスタ31)の内容を取得および設定します。これらの関数はハードフロートコードでのみ利用可能ですが、MIPS16と非MIPS16の両方のコンテキストで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">ハードウェアでIntel CETからのシャドウスタックサポートが有効になっている場合は、シャドウスタックポインターの現在の値を取得します。それ以外の場合は &lt;code&gt;0&lt;/code&gt; を取得します。 &lt;code&gt;ret_type&lt;/code&gt; は、64ビットターゲットの場合は &lt;code&gt;unsigned long long&lt;/code&gt; 、32ビットターゲットの場合は &lt;code&gt;unsigned int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">ラベルへのポインタの取得、および計算されたゲトを取得します。</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">関数のリターンアドレスまたはフレームアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 型の値が暗黙的に &lt;code&gt;double&lt;/code&gt; に昇格されたときに警告を出します。32ビットの「単精度」浮動小数点ユニットを備えたCPUは、ハードウェアでは &lt;code&gt;float&lt;/code&gt; を実装しますが、ソフトウェアでは &lt;code&gt;double&lt;/code&gt; をエミュレートします。このようなマシンでは、ソフトウェアエミュレーションに必要なオーバーヘッドのため、 &lt;code&gt;double&lt;/code&gt; 値を使用して計算を行うと、はるかにコストがかかります。</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">宣言される前に関数が使用された場合に警告を与える。C99 モード (</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">&lt;em&gt;基本標準&lt;/em&gt;（エラーを参照）</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; で終了する一連の入力レジスターが与えられた場合、どれが &lt;code&gt;asm&lt;/code&gt; によって暗黙的にポップされ、どれがGCCによって明示的にポップされなければならないかを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">コンパイルされたファイル内のすべての外部から見える関数に、残りの関数を実行する前にサム・モードに切り替えるARM命令セット・ヘッダを与えます。これにより、これらの関数をインターワーキング以外のコードから呼び出すことができます。既定ではインターワーキングが有効になっているため、このオプションは AAPCS 構成では有効ではありません。</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">グローバルレジスタ変数は初期値を持つことができません。</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">ソースコードを</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">指示を緩和するためのガイドリンカー。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HIおよびLOレジスタ。</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HIレジスター。</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">HIGH登録クラス $r12~$r14、$r20~$r31。</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">半精度浮動小数点。</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">Halt(停止)。プロセッサは実行を停止します。この組み込みはアサーションの実装に便利です。</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">ハードウェア自動プリフェッチャースケジューラモデル制御フラグ。モデルが調査する先読みサイクルの数。''では、命令ソートヒューリスティックのみを有効にします。</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">ハードウェア乗算は通常、ライブラリルーチンを呼び出すことで実行されます。これにより、生成されるコードのスペースを節約することができます。でコンパイルする場合</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">持っている &lt;code&gt;operator=&lt;/code&gt; への参照を返す &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">したがって、慣習として、 &lt;code&gt;r*&lt;/code&gt; は &lt;code&gt;const char *&lt;/code&gt; *を意味するものと見なされ（ほとんどの場合それが意味されるため）、 &lt;code&gt;char *const&lt;/code&gt; をエンコードする方法はありません。 &lt;code&gt;char *const&lt;/code&gt; は単に &lt;code&gt;*&lt;/code&gt; としてエンコードされ、 &lt;code&gt;const&lt;/code&gt; は失われます。</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">ここに '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">ここで、 &lt;code&gt;longjmp&lt;/code&gt; が発生したときに、 &lt;code&gt;a&lt;/code&gt; が最初の値に復元される場合と復元されない場合があります。 &lt;code&gt;a&lt;/code&gt; がレジスタに割り当てられている場合、最初の値が復元されます。それ以外の場合は、最後に格納された値を保持します。</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">ここで、 &lt;code&gt;r12&lt;/code&gt; は使用するレジスタの名前です。これは、グローバルレジスタ変数の定義に使用される構文と同じですが、ローカル変数の場合、宣言は関数内に表示されます。 &lt;code&gt;register&lt;/code&gt; キーワードが必要とされ、かつと組み合わせることはできません &lt;code&gt;static&lt;/code&gt; 。レジスター名は、ターゲット・プラットフォームに有効なレジスター名でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">ここで、 &lt;code&gt;r12&lt;/code&gt; は使用するレジスタの名前です。これは、ローカルレジスタ変数の定義に使用される構文と同じですが、グローバル変数の場合、宣言は関数の外部に表示されます。 &lt;code&gt;register&lt;/code&gt; キーワードが必要とされ、かつと組み合わせることはできません &lt;code&gt;static&lt;/code&gt; 。レジスター名は、ターゲット・プラットフォームに有効なレジスター名でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">制約修飾文字は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">ここでは、これらのオプションの使用例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">出力オペランドの例をいくつか挙げてみます。</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">ここでは、i386 マシン上でコンパイラが生成した型とそのエンコーディングを紹介します。</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">以下は、 &lt;code&gt;asm&lt;/code&gt; オペランドで使用できる制約文字の詳細です。制約は、オペランドがレジスターにあるかどうか、およびどの種類のレジスターかを示すことができます。オペランドがメモリ参照になるかどうか、およびどの種類のアドレスか。オペランドがイミディエート定数であるかどうか、およびオペランドが取り得る値。制約では、2つのオペランドを一致させる必要がある場合もあります。インライン &lt;code&gt;asm&lt;/code&gt; のオペランドでは、 'でない限り、副作用は許可されません。</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">以下は、架空の &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; 命令です。 &lt;code&gt;asm&lt;/code&gt; がそれらを変更するため、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; ポインターレジスタを入力/出力として指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">これは、メモリ内の浮動小数点値への2つのポインタを取り、浮動小数点レジスタ出力を生成する架空の二乗和命令です。通知 &lt;code&gt;x&lt;/code&gt; 、及び &lt;code&gt;y&lt;/code&gt; は二度現れる両方 &lt;code&gt;asm&lt;/code&gt; アクセスメモリを指定すると、パラメータとによって使用されるレジスタベースを指定するために、一度、 &lt;code&gt;asm&lt;/code&gt; 。GCCは両方の目的で同じレジスターを使用できるため、これを行うことでレジスターを無駄にすることは通常ありません。ただし、この &lt;code&gt;asm&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;%1&lt;/code&gt; と &lt;code&gt;%3&lt;/code&gt; の両方を使用し、それらが同じであることを期待するのは愚かです。実際、 &lt;code&gt;%3&lt;/code&gt; レジスタではないかもしれません。これは、 &lt;code&gt;x&lt;/code&gt; が指すオブジェクトへのシンボリックメモリ参照である可能性があります。</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">以下は、Foundationライブラリ（ &lt;code&gt;NSArray&lt;/code&gt; 、 &lt;code&gt;NSString&lt;/code&gt; 、および &lt;code&gt;NSLog&lt;/code&gt; の実装を提供する）を使用した完全に機能する例です。</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">ここでは、サポートされている各アーキテクチャと、サポートされている実装のリストを示します。</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">以下は、C ++プログラムのコンパイル&lt;em&gt;専用&lt;/em&gt;のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">以下は、Objective-CおよびObjective-C ++プログラムのコンパイル&lt;em&gt;専用&lt;/em&gt;のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">ここでは、ゴリ押しでより専門的な説明をします。コードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">ここでは、クローバーされたレジスタの使用を示すVAXのための現実的な例を示しています。</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">ここでは、スペックファイルの小さな例を紹介します。</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">ここでは、タイプ別にグループ化されたすべてのオプションの概要を示します。説明は以下のセクションにあります。</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">ここに定義されたすべての表があります</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;gcc&lt;/code&gt; の ARMポートからの切り捨てられた例です。</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">以下は、i386 の &lt;code&gt;asm goto&lt;/code&gt; の例です。</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">これは、アセンブリーに実装されたPowerPCベクトルスケールの例で、ベクトルと条件コードクロバー、および &lt;code&gt;asm&lt;/code&gt; によって変更されない初期化されたオフセットレジスターを完備しています。</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">以下は、i386 の基本的な &lt;code&gt;asm&lt;/code&gt; の例です。</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">次に、複合リテラルを使用して &lt;code&gt;struct foo&lt;/code&gt; を作成する例を示します。</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">ここでは、この機能を使用する方法の例を示します。インスタンスが弱いポインタ参照を保持するクラスを実装したいとします。</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">以下は、 &lt;code&gt;_XABORT_RETRY&lt;/code&gt; の処理と他の失敗のフォールバックパスを示す例です。</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">シンボリックネームを使用した例を示します。</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">ここでは、型名を引数にした例を示します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">ここでは、2つの出力ファイル名</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">ここで説明する型は、 &lt;code&gt;int&lt;/code&gt; へのポインタの型です。</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">ここで、 &lt;code&gt;d&lt;/code&gt; はレジスタまたはメモリのいずれかにあります。コンパイラーはすでに &lt;code&gt;e&lt;/code&gt; が指す &lt;code&gt;uint32_t&lt;/code&gt; ロケーションの現在の値をレジスターに持っている可能性があるため、両方の制約を指定して、 &lt;code&gt;d&lt;/code&gt; に最適なロケーションを選択できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">ここで、 &lt;code&gt;t4&lt;/code&gt; は4バイトを占めます。</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">ここで、 &lt;code&gt;t5&lt;/code&gt; は2バイトを占めます。</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">ここでは、 &lt;code&gt;std::move&lt;/code&gt; 呼び出しは冗長です。G ++はCore Issue 1579を実装しているため、別の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">ここで、関数 &lt;code&gt;intermediate&lt;/code&gt; は、引数として &lt;code&gt;store&lt;/code&gt; のアドレスを受け取ります。場合 &lt;code&gt;intermediate&lt;/code&gt; コールが &lt;code&gt;store&lt;/code&gt; に与えられた引数 &lt;code&gt;store&lt;/code&gt; に格納するために使用されている &lt;code&gt;array&lt;/code&gt; 。しかし、この手法は、含まれている関数（この例では &lt;code&gt;hack&lt;/code&gt; ）が終了しない限り機能します。</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">ここで、名前 &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;N&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; のタイプに依存しないコンテキストに表示されます。したがって、コンパイラーは、インスタンス化の時点の前だけでなく、テンプレートでの使用のコンテキストでそれらを定義する必要があり、ここではそれぞれ &lt;code&gt;::foo(double)&lt;/code&gt; および &lt;code&gt;A::N&lt;/code&gt; を使用します。特に、 &lt;code&gt;::foo(double)&lt;/code&gt; に渡すときに整数値を &lt;code&gt;double&lt;/code&gt; に変換します。</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">Hewlett-Packard PA-RISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">16進数の浮動小数点定数。</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">非表示の可視性は、宣言されたエンティティに新しい形式のリンケージがあることを示します。これを「非表示のリンケージ」と呼びます。非表示のリンケージを持つオブジェクトの2つの宣言は、同じ共有オブジェクト内にある場合、同じオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">歴史的に、GCCは「空の」ループを削除していません。プログラムにループを入れる最も可能性の高い理由は遅延があるため、それらを削除しても実際のプログラムの実行が速くなることはないからです。</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">歴史的に、C ++やFortranを含む多くの言語のコンパイラは、「プリプロセッサ」として実装されており、Cなどの別の高水準言語を出力します。GCCに含まれるコンパイラは、この方法で実装されていません。それらはすべて直接マシンコードを生成します。この種のプリプロセッサーは、C、C ++、Objective-C、およびObjective-C ++言語の統合機能である&lt;em&gt;Cプリプロセッサー&lt;/em&gt;と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">GCCが &lt;code&gt;asm&lt;/code&gt; ブロックのサイズを計算する方法。</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">GCCがISO C仕様をどのように実装しているか。</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">GCCがISO C++仕様をどのように実装しているか。</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">GCCのヘルプを得るには</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">診断の識別方法(C90 3.7、C99、C11 3.10、C90、C99、C11 5.1.1.3)。</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">どの程度の最適化か?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">コンパイラはどれだけうるさいのか?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">ヘッダー名の両方の形式の配列がどのようにヘッダーまたは外部ソースファイル名にマッピングされるか(C90 6.1.7、C99、C11 6.4.7)。</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">インクルードで名前付きソースファイルを検索する方法 '</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">特定の浮動定数について、最も近い表現可能な値または最も近い表現可能な値にすぐ隣接するより大きい表現可能な値またはより小さい表現可能な値がどのように選択されるか(C90 6.1.3.1、C99およびC11 6.4.4.2)。</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">GCCのテスト開発にどう貢献するか。</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">自由ソフトウェアのための資金調達を保証するためにはどうすればよいか。</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">スイッチをサブプロセスに渡す方法。</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">gcov-dumpの使い方。</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">gcov-toolの使い方。</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">gcovの使い方。</target>
        </trans-unit>
        <trans-unit id="235eb3fbbc41bc188e100c67a4cfb3682e2f4f2a" translate="yes" xml:space="preserve">
          <source>How to use lto-dump.</source>
          <target state="translated">lto-dumpの使い方。</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">このマニュアルをコピーして共有する方法</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">どのように、なぜ、どこにバグを報告するのか。</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; ユニオンには &lt;code&gt;float&lt;/code&gt; 型のメンバーがないため、は有効なキャストではありません。</target>
        </trans-unit>
        <trans-unit id="485c9587b5b19b4655aac341ac1212bc65c7e3c5" translate="yes" xml:space="preserve">
          <source>However, even with</source>
          <target state="translated">しかし、そのような場合でも</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">しかし、ライブラリやメインの実行ファイルが例外を投げたりキャッチしたりするようになっている場合は、G++ドライバを使ってリンクするか、オプションの</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">しかし、揮発性記憶装置の値が変更されておらず、揮発性記憶装置の値が使用されていない場合には、その状況はあまり顕著ではない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">しかし、ここでの理論的根拠は、空でないループを最適化しても空のループを生成することはできないということです。これは、慎重に書かれたC言語をそれほど強力でないオプティマイザを使ってコンパイルした場合にも当てはまりますが、慎重に書かれたC++やより強力なオプティマイザを使ってコンパイルした場合には、必ずしも当てはまるとは限りません。このように、GCC はループから操作を削除します。ループが有限であることが証明できる場合、GCC はループ自体も削除します。</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">ただし、 &lt;code&gt;gcc&lt;/code&gt; を使用してもC ++ライブラリは追加されません。 &lt;code&gt;g++&lt;/code&gt; は、GCCを呼び出し、C ++ライブラリに対するリンクを自動的に指定するプログラムです。それは扱います</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">しかし、これらの組み込み関数は、いくつかの洗練された機能や言語の他の拡張機能とうまく相互作用しない可能性があります。したがって、引数の単なるフォワーダとして機能する非常に単純な関数以外では使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">登録する</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">IBM 970サーバーCPU(すなわち、Apple G5)。</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">IBM A2 64ビット組み込みCPU</target>
        </trans-unit>
        <trans-unit id="3bd4304c8c79a3c3382925e10c0656323fb15790" translate="yes" xml:space="preserve">
          <source>IBM POWER10 Server CPU.</source>
          <target state="translated">IBM POWER10サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">IBM POWER4サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">IBM POWER5サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">IBM POWER5+サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">IBM POWER6 Server CPU(アーキテクトモード)。</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">IBM POWER6 Server CPU(RAWモード)。</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">IBM POWER7サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">IBM POWER8サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">IBM POWER9サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32ビット組込みCPU。</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32ビット組み込みCPU。</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">IBM PowerPCセルブロードバンドエンジンアーキテクチャCPU。</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPUは、i486と同じようにMMXと3DNow! 命令セットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 CPUは、MMX命令セットのサポートを追加したi486と同じように扱われました。</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CPは、関数のパラメーターに渡されるすべての可能な値と型を追跡して、それらを伝播し、仮想化を解除しようとします。</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CPは、独自のクローニング収益性ヒューリスティックのスコアを計算し、それを超えるスコアを持つクローニング機会を実行します。</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CPは、アグリゲートで渡されたスカラ値の数を伝搬することも可能です。</target>
        </trans-unit>
        <trans-unit id="8556958b5ec1035f0a6b05619f3cd2d467506614" translate="yes" xml:space="preserve">
          <source>IPA-CP will analyze conditional statement that references some function parameter to estimate benefit for cloning upon certain constant value. But if number of operations in a parameter expression exceeds</source>
          <target state="translated">IPA-CPは、関数パラメータを参照している条件文を解析して、ある一定の値に基づいてクローニングの効果を推定します。しかし、パラメータ式に含まれる操作の数が</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRAは、その累積サイズが</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">IRAは、ループ不変量を移動させる決定を行う際に、ループ内のレジスタ圧をより正確に評価するために使用することができます(以下を参照してください)。</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">IRAでは、デフォルトで地域レジスタの割り当てが使用されます。関数にこのパラメータで指定された数よりも多くのループが含まれている場合、最も頻繁に実行されるループのうち、最大でも指定された数だけが地域レジスタ割り当てのための領域を形成します。</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">PowerPCのISA 3.0は、新しいアトミックメモリ操作（amo）命令を追加しました。GCCは、64ビット環境でこれらの命令をサポートします。すべての関数は、インクルードファイル &lt;code&gt;amo.h&lt;/code&gt; で宣言されています。</target>
        </trans-unit>
        <trans-unit id="5e4fcacd5131358ff23946df8c2180ba0733f8f2" translate="yes" xml:space="preserve">
          <source>ISA 3.1 of the PowerPC added new Matrix-Multiply Assist (MMA) instructions. GCC provides support for these instructions through the following built-in functions which are enabled with the &lt;code&gt;-mmma&lt;/code&gt; option. The vec_t type below is defined to be a normal vector unsigned char type.&amp;Acirc; The uint2, uint4 and uint8 parameters are 2-bit, 4-bit and 8-bit unsigned integer constants respectively.&amp;Acirc; The compiler will verify that they are constants and that their values are within range.&amp;Acirc;</source>
          <target state="translated">PowerPCのISA3.1は、新しいMatrix-Multiply Assist（MMA）命令を追加しました。GCCは、 &lt;code&gt;-mmma&lt;/code&gt; オプションで有効にされる次の組み込み関数を通じて、これらの命令のサポートを提供します。以下のvec_tタイプは、通常のベクトルunsigned charタイプとして定義されています。uint2、uint4、およびuint8パラメーターは、それぞれ2ビット、4ビット、および8ビットの符号なし整数定数です。コンパイラーは、それらが定数であることを確認し、それらの値が範囲内にあること。</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ISO Cはそのような構成を許可していません。</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO Cは、特定の種類の無効なプログラムに対して「診断」メッセージを要求しますが、診断としてカウントされる警告がGCCによって定義されています。GCCが警告を生成するがエラーは生成しない場合、それは正しいISO Cサポートです。テストスイートがこれを「失敗」と呼ぶ場合、GCCオプションで実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11、ISO C規格の2011年改訂。この標準は、実質的に完全にサポートされ、モジュロバグ、浮動小数点の問題（主に、ただし完全ではないが、附属書FおよびGのオプションのC11機能に関連しています）およびオプションの附属書K（境界チェックインターフェイス）およびL（分析可能性）です。名前 '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ISO C17、ISO C規格の2017年改訂版(2018年発行)。この規格は、欠陥の修正以外はC11と同じです(いずれも</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">ISO C90を修正1で修正しました。</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99とISO C++では、宣言とコードを複合文の中で自由に混在させることができます。拡張として、GNU Cでは、C90モードでもこれを許可しています。例えば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99およびISO C ++ 11は、少なくとも64ビット幅の整数のデータ型をサポートし、GCCは拡張としてC90およびC ++ 98モードでそれらをサポートします。単に書く &lt;code&gt;long long int&lt;/code&gt; 符号付き整数のため、または &lt;code&gt;unsigned long long int&lt;/code&gt; 符号なし整数のために。 &lt;code&gt;long long int&lt;/code&gt; 型の整数定数を作成するには、接尾辞 'を追加します</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99およびISO C ++ 17は、 &lt;code&gt;1.55e1&lt;/code&gt; などの通常の10進表記で記述された浮動小数点数だけでなく、16進形式で記述された &lt;code&gt;0x1.fp3&lt;/code&gt; などの数値もサポートします。GNU拡張機能として、GCCはこれをC90モード（厳密に準拠している場合を除く）およびC ++ 98、C ++ 11、C ++ 14モードでサポートします。そのフォーマットでは</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99は複雑な浮動データ型をサポートし、拡張としてGCCはC90モードおよびC ++でそれらをサポートします。GCCは、ISO C99の一部ではない複雑な整数データ型もサポートしています。キーワード &lt;code&gt;_Complex&lt;/code&gt; を使用して複合型を宣言できます。拡張機能として、古いGNUキーワード &lt;code&gt;__complex__&lt;/code&gt; もサポートされています。</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99。この標準は実質的に完全にサポートされており、モジュロバグと浮動小数点の問題（主に、完全ではないが、附属書FとGのオプションのC99機能に関連している）。詳細については、&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http：//gcc.gnu.org/c99status.html&lt;/a&gt;を参照してください。名 '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">ISO / IEC TS 18661-3は、 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; の新しい許容値を定義しています。これは、交換形式または拡張形式であるセマンティック型の操作と定数を、その型の精度と範囲で評価する必要があることを示します。これらの新しい値は、C99 / C11で許可されている値のスーパーセットであり、 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; の他の正の値の意味を指定していません。そのため、C11に準拠するコードは、新しい値の可能性を想定して書かれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3：2015は、追加の浮動小数点型 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; Cサポートを定義し、GCCはこれらの型名をサポートします。サポートされるタイプのセットは、ターゲットアーキテクチャによって異なります。これらの型は、C ++のコンパイル時にはサポートされません。これらのタイプの定数は、サフィックス &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; または &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; または &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ます。これらの型名を &lt;code&gt;_Complex&lt;/code&gt; と一緒に使用して、複合型を宣言できます。</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">理想的には、移植可能なプログラムは、オブジェクトの &lt;code&gt;unsigned char&lt;/code&gt; に依存する場合、常に &lt;code&gt;signed char&lt;/code&gt; またはunsigned charを使用する必要があります。しかし、多くのプログラムは、プレーンな &lt;code&gt;char&lt;/code&gt; を使用するように作成されており、署名対象のマシンに応じて、署名されること、または署名されないことを期待しています。このオプションとその逆により、そのようなプログラムを反対のデフォルトで動作させることができます。</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">上記と同じですが、 &lt;code&gt;jli&lt;/code&gt; テーブル内の関数の場所がわかっており、属性パラメーターとして指定されます。</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">識別子とラベルが競合します。従来のC言語では、ラベルのための独立した名前空間がありません。</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">コンパイラが使用する各ツールのバージョンを、出力の &lt;code&gt;.ident&lt;/code&gt; アセンブラディレクティブで識別します。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="translated">もし '</target>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">3DNowなら！拡張が有効になっている場合、 &lt;code&gt;V2SF&lt;/code&gt; は2つの32ビット浮動小数点値のベクトルのモードとして使用されます。</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">&lt;code&gt;%*&lt;/code&gt; が仕様シーケンスの最後の部分として表示される場合、最後の置換の終了後にスペースが追加されます。ただし、シーケンス内にさらにテキストがある場合、スペースは生成されません。これにより、 &lt;code&gt;%*&lt;/code&gt; 置換をより大きな文字列の一部として使用できます。たとえば、次のようなspec文字列：</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">場合 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; （又は &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ）が実装しないか、または戻り &lt;code&gt;NO&lt;/code&gt; 、ランタイムは次に転送フックを試みます。</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">場合 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; 渡された、上記の理由境界チェックの不足の警告が、この時間をトリガーします。</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;code&gt;D1&lt;/code&gt; は、フォーム有する &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; 、そして宣言 &lt;code&gt;T D&lt;/code&gt; タイプ「指定 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; は、」 &lt;var&gt;ident&lt;/var&gt; 、次いで、 &lt;code&gt;T D1&lt;/code&gt; は、「タイプを指定し &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; の指定子リスト &lt;var&gt;Type&lt;/var&gt; 」。</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;code&gt;D1&lt;/code&gt; は、形式は &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; 、と宣言 &lt;code&gt;T D&lt;/code&gt; 指定タイプを「 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; のために」 &lt;var&gt;ident&lt;/var&gt; 、その後、 &lt;code&gt;T D1&lt;/code&gt; は「タイプを指定する &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; の &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;へのtype-list &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; ポインター。</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">&lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; が特定のdeclに設定されている場合は、 &lt;code&gt;DECL_NAME&lt;/code&gt; の代わりにそれをダンプで使用します。その主な用途は、アセンブリファイル内のマングルされた名前から逆方向に作業する使いやすさです。</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">&lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; が設定されていない場合、GCCは、呼び出されるパス名に基づいて、使用する適切なプレフィックスを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">場合 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; が設定されている、それはコンパイラによって実行されるサブプログラムの名前に使用する接頭辞を指定します。この接頭辞がサブプログラムの名前と組み合わされている場合、スラッシュは追加されませんが、必要に応じてスラッシュで終わる接頭辞を指定できます。</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">&lt;code&gt;LANG&lt;/code&gt; が定義されていない場合、または他の値がある場合、コンパイラーはデフォルトのロケールで定義されている &lt;code&gt;mblen&lt;/code&gt; および &lt;code&gt;mbtowc&lt;/code&gt; を使用して、マルチバイト文字を認識および変換します。</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; がGCCに与えられた場合、 &lt;code&gt;X&lt;/code&gt; を置き換えます。それ以外の場合、 &lt;code&gt;T&lt;/code&gt; がGCCに与えられると、 &lt;code&gt;Y&lt;/code&gt; に置き換えられます。それ以外の場合は &lt;code&gt;D&lt;/code&gt; に置き換えます。必要な数の句を含めることができます。これはと組み合わせることができます &lt;code&gt;.&lt;/code&gt; 、 &lt;code&gt;,&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、および必要に応じて &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; が設定されている場合は、一時ファイルに使用するディレクトリを指定します。GCCは、一時ファイルを使用して、次のステージへの入力として使用されるコンパイルの1つのステージの出力を保持します。たとえば、適切なコンパイラへの入力であるプリプロセッサの出力。</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、特色があり &lt;code&gt;true&lt;/code&gt; 場合は、他の &lt;code&gt;type&lt;/code&gt; 例外をスローしないことが知られているデフォルトのコンストラクタを持つCVクラスまたは共用タイプ（またはその配列）は、その後形質があるある &lt;code&gt;true&lt;/code&gt; 他にそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、形質がある &lt;code&gt;true&lt;/code&gt; 場合、他の &lt;code&gt;type&lt;/code&gt; 例外をスローしないことが知られているコピーコンストラクタとCV-修飾クラスまたは共用タイプで、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_class (type)&lt;/code&gt; あり &lt;code&gt;false&lt;/code&gt; その後、形質はある &lt;code&gt;false&lt;/code&gt; 。さもなければ &lt;code&gt;type&lt;/code&gt; 場合にのみ空と考えられる： &lt;code&gt;type&lt;/code&gt; 全く非静的データメンバー、またはすべての非静的データメンバ、もしあれば、ある長さ0のビットフィールドを有していない、及び &lt;code&gt;type&lt;/code&gt; 何の仮想メンバーを持っていない、及び &lt;code&gt;type&lt;/code&gt; 何仮想がありません基本クラス、および &lt;code&gt;type&lt;/code&gt; には、 &lt;code&gt;__is_empty (base_type)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; である基本クラス &lt;code&gt;base_type&lt;/code&gt; がありません。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;type&lt;/code&gt; 参照型であり、次いで形質が &lt;code&gt;true&lt;/code&gt; ならば、他の &lt;code&gt;type&lt;/code&gt; 些細なデストラクタ（[class.dtor]）とCVクラスまたは共用タイプ（またはその配列）であり、次いで形質である &lt;code&gt;true&lt;/code&gt; それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;type&lt;/code&gt; 参照型であるその後、形質がある &lt;code&gt;true&lt;/code&gt; 場合、他の &lt;code&gt;type&lt;/code&gt; 些細なコピーコンストラクタ（[class.copy]）とCVクラスまたは共用タイプで、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければです &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、特色があり &lt;code&gt;true&lt;/code&gt; 場合は、他の &lt;code&gt;type&lt;/code&gt; CV-資格の些細なデフォルトコンストラクタを持つクラスまたは共用タイプ（またはその配列）（[class.ctor]）を形質があるある &lt;code&gt;true&lt;/code&gt; 、それは他の、は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">&lt;code&gt;base_type&lt;/code&gt; が &lt;code&gt;derived_type&lt;/code&gt; （[class.derived]）の基本クラスである場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。 &lt;code&gt;base_type&lt;/code&gt; および &lt;code&gt;derived_type&lt;/code&gt; の最上位のcv修飾は無視されます。この特性の目的のために、クラス型は独自のベースと見なされます。 &lt;code&gt;__is_class (base_type)&lt;/code&gt; ：__is_class（base_type）および &lt;code&gt;__is_class (derived_type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;base_type&lt;/code&gt; と &lt;code&gt;derived_type&lt;/code&gt; が同じタイプでない場合（cv-qualifiersを無視して）、 &lt;code&gt;derived_type&lt;/code&gt; は完全なタイプになります。この要件が満たされない場合、診断が生成されます。</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">&lt;code&gt;objc_msg_lookup()&lt;/code&gt; が適切なメソッド実装を見つけられない場合、レシーバは必要なメソッドを実装していないため、クラスがメソッドを動的に登録できるかどうかを確認しようとします。</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">場合は &lt;code&gt;packed&lt;/code&gt; 構造で使用されているビットフィールドが使用されている場合、あるいは、それはマイクロソフトABIは、GCCが通常行う方法とは異なる構造をレイアウトすることかもしれません。特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラー間で（関数呼び出しを介して、またはファイル内のデータとして）パックされたデータを移動する場合、いずれかの形式にアクセスする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; &lt;code&gt;signed&lt;/code&gt; または符号なしが省略された場合、ベクトル型の符号付きは、基本型のデフォルトの符号付きです。デフォルトはオペレーティングシステムによって異なるため、移植性のあるプログラムは常に署名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;const&lt;/code&gt; -修飾または参照型で、その後特性がある &lt;code&gt;false&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;__is_pod (type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、特性は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; がcv修飾クラスまたは共用コピー割り当て（[class.copy]）の共用体タイプの場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;const&lt;/code&gt; -qualifiedまたは参照型で、その後特性がある &lt;code&gt;false&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、特性は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; が例外をスローしないことがわかっているコピー代入演算子を持つcv修飾クラスまたは共用体タイプの場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 仮想デストラクタ（[class.dtor]）を持つクラス型で、その後特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV PODタイプ（[basic.types]）で、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CVの列挙型（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV組合のタイプ（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV修飾クラスタイプではなく、労働組合のタイプ（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; リテラルのタイプ（[basic.types]）形質があるある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 多型クラスである（[class.virtual]）、その後特色があり &lt;code&gt;true&lt;/code&gt; 他のそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 標準レイアウトタイプ（[basic.types]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 些細なタイプ（[basic.types]）形質があるある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 抽象クラスである（[class.abstract]）、その後特色があり &lt;code&gt;true&lt;/code&gt; 他のそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">場合 &lt;var&gt;X&lt;/var&gt; がある &lt;code&gt;0xf&lt;/code&gt; 場合、 &lt;var&gt;n&lt;/var&gt; 番目のビット &lt;var&gt;val&lt;/var&gt; が不変戻されます。</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">場合 &lt;var&gt;desired&lt;/var&gt; に書き込まれる &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 次に &lt;code&gt;true&lt;/code&gt; 返され、メモリは、で指定されたメモリ順序に従って影響さ &lt;var&gt;success_memorder&lt;/var&gt; 。ここで使用できるメモリ順序に制限はありません。</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">場合は &lt;var&gt;device&lt;/var&gt; 、デバイスが、 'のような唯一のコアアーキテクチャではありません</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;var&gt;exp1&lt;/var&gt; 返され、戻り値の型は同じである &lt;var&gt;exp1&lt;/var&gt; のタイプ。同様に、 &lt;var&gt;exp2&lt;/var&gt; が返される場合、その戻り型は &lt;var&gt;exp2&lt;/var&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">場合 &lt;var&gt;file&lt;/var&gt; あります</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;m&lt;/var&gt; を指定しない場合、デフォルトで &lt;var&gt;n&lt;/var&gt; になります。</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">場合 &lt;var&gt;n&lt;/var&gt; は指定された、またはゼロではないが、「非常にそうするマシン依存のデフォルトを使用</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">場合は &lt;var&gt;n&lt;/var&gt; を指定するか、またはゼロではないが、マシン依存のデフォルトを使用します。</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">場合は &lt;var&gt;n&lt;/var&gt; を指定するか、またはゼロではないが、マシン依存のデフォルトを使用します。許可される &lt;var&gt;n&lt;/var&gt; オプションの最大値は65536です。</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">場合は &lt;var&gt;options&lt;/var&gt; 省略され、デフォルトでは'と</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; が指定されている場合、GCCは &lt;var&gt;path&lt;/var&gt; を調べて、プロファイルフィードバックデータファイルを見つけます。見る</target>
        </trans-unit>
        <trans-unit id="9d543a6e5b2a62c41981e6b57e0c00240c859530" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC saves</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; が指定されている場合、GCCは保存します</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; が 'の場合</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">指定された接頭辞を使ってサブプログラムが見つからない場合、GCCはサブプログラムの通常の場所を探してみます。</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCCが2.23より前のGLIBCを使用するように構成されている場合、組み込み関数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; は常に0を返し、コンパイラーは警告を発行します。</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCCが2.23より前のGLIBCを使用するように構成されている場合、組み込み関数 &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; は常に0を返し、コンパイラーは警告を発行します。</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">LTOが、互換性のない型で宣言されたCリンクを持つオブジェクトを、別々の翻訳単位でリンクさせるために遭遇した場合(ISO C99 6.2.7に従った未定義の動作)、非致命的な診断が発行される可能性があります。実行時の動作は未定義のままです。他の言語でも同様の診断が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">SSE拡張が有効な場合、 &lt;code&gt;V4SF&lt;/code&gt; は4つの32ビット浮動小数点値のベクトルに使用されます。一部の命令は4つの32ビット整数のベクトルを使用し、これらは &lt;code&gt;V4SI&lt;/code&gt; を使用します。最後に、一部の命令はベクトルレジスタ全体を操作し、それを128ビット整数として解釈します。これらはモード &lt;code&gt;TI&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">Xが0〜7の範囲にある場合、 &lt;var&gt;n&lt;/var&gt; 番目の結果ビットはビットの &lt;var&gt;X&lt;/var&gt; 番目のビットに設定され &lt;var&gt;bits&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">Xが8&amp;hellip; &lt;code&gt;0xe&lt;/code&gt; の範囲にある場合、 &lt;var&gt;n&lt;/var&gt; 番目の結果ビットは未定義です。</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">場合&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;という名前のアドレス空間&lt;/a&gt;ジェネリックまたは以外の &lt;code&gt;__flash&lt;/code&gt; が使用され、その後、 &lt;code&gt;RAMPZ&lt;/code&gt; を操作する前に、必要に応じて設定されています。</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">クラスがプロトコルを実装すると宣言されている場合、そのクラスで実装されていないプロトコルの各メソッドに対して警告が発行されます。デフォルトの動作は、メソッドの実装がスーパークラスから継承されている場合でも、クラスで明示的に実装されていないすべてのメソッドに対して警告を発行することです。もし</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">診断に修正のヒントが含まれている場合、診断の出力と同様に、ハーフオープン間隔で構成される &lt;code&gt;fixits&lt;/code&gt; 配列があります。</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">関数が一時的な &lt;code&gt;initializer_list&lt;/code&gt; またはローカルの &lt;code&gt;initializer_list&lt;/code&gt; 変数を返す場合、配列の有効期間はreturnステートメントの終わりで終了するため、返される値にはぶら下がりポインタが含まれます。</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">ループが変数ストライドを持つ配列を反復処理する場合,ストライドが常に1であると仮定した別のバージョンのループを作成します.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">new-expressionが &lt;code&gt;initializer_list&lt;/code&gt; を作成する場合、配列はそれを囲む完全式の最後までしか存在しないため、ヒープ内の &lt;code&gt;initializer_list&lt;/code&gt; にはぶら下がりポインタがあります。</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">プログラムが別のC ++ライブラリを使用する必要があり、デフォルトでそのライブラリを使用するC ++ドライバーを使用して最終的なリンクを実行できない場合は、 &lt;code&gt;g++&lt;/code&gt; にそのライブラリの場所と名前を通知する必要があります。また、異なるスタートアップファイルやその他のランタイムサポートライブラリを指定し、1つ以上のオプションでGCCのサポートライブラリの使用を抑制する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">標準システムのインクルードディレクトリ、または</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">変数が &lt;code&gt;below100&lt;/code&gt; 属性を持つ場合（ &lt;code&gt;BELOW100&lt;/code&gt; も許可されます）、GCCは変数をメモリの最初の0x100バイトに配置し、特別なオペコードを使用してアクセスします。そのような変数は、いずれかに配置され &lt;code&gt;.bss_below100&lt;/code&gt; 部又は &lt;code&gt;.data_below100&lt;/code&gt; セクション。</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">長さ0のビットフィールドが通常のビットフィールドの後に続く場合、長さ0のビットフィールドのタイプが構造全体の配置に影響を与える可能性があります。たとえば、 &lt;code&gt;t2&lt;/code&gt; のサイズは4バイトです。これは、長さがゼロのビットフィールドが通常のビットフィールドの後にあり、shortタイプであるためです。</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">長さ0のビットフィールドがビットフィールド &lt;code&gt;foo&lt;/code&gt; の後に挿入され、長さ0のビットフィールドのアラインメントがそれに続くメンバー &lt;code&gt;bar&lt;/code&gt; より大きい場合、 &lt;code&gt;bar&lt;/code&gt; は、ゼロのタイプとしてアラインされます。長さビットフィールド。</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">通常は合体している2つのビットフィールドの間に長さ0のビットフィールドが挿入された場合、そのビットフィールドは合体しません。</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">投機的な実行が正しくない場合に、任意のメモリ位置へのアクセスが安全でない可能性がある場合は、コードを次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">特定の関数へのすべての呼び出しが統合されており、その関数が &lt;code&gt;static&lt;/code&gt; と宣言されている場合、通常、関数自体はアセンブラーコードとして出力されません。</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">明示的なバージョン番号が提供され</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">命令がAltivecレジスタのみを取得する場合、 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">のいずれかであれば</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">有効なテスト条件のいずれかが真であれば、結果ベクトルの対応するエントリは-1です。それ以外の場合(有効なテスト条件がすべて偽)、結果ベクトルの対応するエントリは 0 です。</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">これらのオプションのいずれかが使用されている場合、リンカーは実行されず、オブジェクトファイル名を引数として使用しないでください。&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;全体的なオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">アプリケーションコードがコピー割り当てに依存している場合、ユーザー定義のコピー割り当て演算子は不確実性を取り除きます。このような演算子を使用すると、アプリケーションは仮想ベースサブオブジェクトがどのように割り当てられるかを定義することができます。</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">同じ関数に &lt;code&gt;signal&lt;/code&gt; と &lt;code&gt;interrupt&lt;/code&gt; 両方が指定されている場合、 &lt;code&gt;signal&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">両方の引数がゼロの場合、ホットパッチは無効になります。</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">テンプレートと囲い込みクラスの両方が明示的に可視化されている場合は、テンプレートからの可視化が使用されます。</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">と組み合わせた場合</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">制御フローが &lt;code&gt;__builtin_unreachable&lt;/code&gt; のポイントに達すると、プログラムは未定義になります。これは、コンパイラーがコードの到達不能性を推定できない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">プリコンパイルされたヘッダを使用しているときにデバッグ情報が出力される場合は</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">宣言のアセンブリ名を変更する方法のいずれかが、アセンブリ名がすでに決定されている宣言に適用された場合(これらの機能のいずれかを以前に使用していたか、またはコードを生成するためにコンパイラがアセンブリ名を必要としていたため)、新しい名前が異なる場合、警告が表示され、名前は変更されません。</target>
        </trans-unit>
        <trans-unit id="880d85143795b8a0d51003e3aa0f6bbac2bee006" translate="yes" xml:space="preserve">
          <source>If enabled, call summaries are only used for functions with more than one call site, and that are sufficiently complicated (as per</source>
          <target state="translated">この機能を有効にすると、コールサマリーは複数のコールサイトを持ち、十分に複雑な関数にのみ使用されます (</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、現時点で他に選択肢がない場合にのみ、制御投機的な指示がスケジュールに選択されます。これにより、制御仕様の使用がより保守的になります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、現時点で他に選択肢がない場合にのみ、スケジュールのためにデータ投機的な命令が選択されます。これにより、データスペキュレーションの使用がより保守的になります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、命令の優先度の計算中に投機的な依存関係が考慮されます。これにより、投機の使用が少し保守的になります。デフォルトの設定は無効です。</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">この機能を有効にした場合、送信引数に必要なスペースの最大量が関数プロローグで計算されます。これは、依存性の低減、スケジューリングの改善、優先スタック境界が2と等しくない場合のスタック使用量の削減のため、ほとんどの最新のCPUで高速化されます。 欠点は、コードサイズの顕著な増加です。このスイッチは</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">関数があるファイルで定義されていて、別のファイルで呼び出される場合は、この宣言を両方のファイルに書くようにしてください。</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">それがスカラ型である場合、あるいはほとんどのターゲットにおいて、唯一のメンバオブジェクトがスカラ型である集約型、あるいはメンバオブジェクトがスカラ型である組合わせ型である場合、式はGCCによって揮発性オブジェクトの読み取りとして解釈され、それ以外の場合、式はその副作用についてのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">複数の場合</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">どちらも</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">新しいシステムヘッダーファイルがインストールされている場合、修正されたヘッダーファイルを更新するための自動調整は行われません。にインストールされている &lt;code&gt;mkheaders&lt;/code&gt; スクリプトを使用して更新できます。</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">コードで &lt;code&gt;NSFastEnumerationState&lt;/code&gt; が定義されていない場合、コンパイラーは &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; を &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; に自動的に置き換えます。この場合、その型はコンパイラーによって同じ方法で暗黙的に定義されます。これは混乱を招く可能性があるため、 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; （上記を参照）を定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">何場合は &lt;var&gt;arg-index&lt;/var&gt; に与えられていない &lt;code&gt;nonnull&lt;/code&gt; 属性、すべてのポインタ引数が非nullとしてマークされています。説明のために、次の宣言は前の例と同等です。</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">コンパイル中にエラーが発生しない場合は、コンパイラを &lt;var&gt;opts&lt;/var&gt; 実行して、optsと</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">修正が必要ない場合、この関数は単に &lt;var&gt;addr&lt;/var&gt; を通過します。</target>
        </trans-unit>
        <trans-unit id="23e134435009fd7bc4ece425ce52605621edbf3d" translate="yes" xml:space="preserve">
          <source>If none of the above search methods find &amp;lsquo;</source>
          <target state="translated">上記の検索方法のいずれも見つからない場合 '</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">属性で特に指定されていない場合は、すべての呼び出しが &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 命令のオフセット範囲を超えている可能性があるため、（そうでなければ直接）呼び出しを実行する前に関数アドレスをレジスターにロードします。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">属性で特に指定されていない場合は、すべての直接呼び出しが &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 命令の範囲内にあると想定するため、これらの命令を直接呼び出しに使用してください。デフォルトは</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">計測している関数のメモリアクセス数がこの数以上の場合は、インラインチェックの代わりにコールバックを使用してください。例えば、インラインコードを無効にするには</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">GIMPLE バイトコードを含むオブジェクトファイルがライブラリアーカイブに保存されている場合、 例えば</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">パッチ適用可能な関数エントリがコマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">プロファイリングがアクティブな場合 (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">ターゲットマシンがサポートしている場合、大規模な配列にアクセスするループのパフォーマンスを向上させるために、メモリをプリフェッチする命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">ターゲットマシンでサポートされている場合は、必要なデータが利用できないことによる実行のストールをなくすために命令を並べ替えようとします。これは、ロード命令や浮動小数点命令の結果が要求されるまで他の命令を発行できるようにすることで、浮動小数点命令やメモリロード命令が遅いマシンを支援します。</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">ターゲットマシンでサポートされている場合、遅延分岐命令の後に利用可能な命令スロットを利用して命令を並べ替えようとします。</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">タ ーゲ ッ ト マシ ンでサポー ト さ れてい る 場合は、 位置に依存 し ない コ ー ド を出力 し ます。 こ れはダ イ ナ ミ ッ ク リ ン ク に適してお り 、 グ ロ ーバルオ フ セ ッ ト テーブルのサ イ ズの制限を回避で き ます。このオプションは、AArch64,m68k,PowerPC,SPARC では違いがあります。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">場合は &lt;code&gt;LC_ALL&lt;/code&gt; の環境変数が設定されている、それはの値より優先されます &lt;code&gt;LC_CTYPE&lt;/code&gt; と &lt;code&gt;LC_MESSAGES&lt;/code&gt; を。それ以外の場合、 &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_MESSAGES&lt;/code&gt; はデフォルトで &lt;code&gt;LANG&lt;/code&gt; 環境変数の値になります。これらの変数がいずれも設定されていない場合、GCCはデフォルトで従来のC英語の動作に設定されます。</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">場合 &lt;code&gt;error&lt;/code&gt; または &lt;code&gt;warning&lt;/code&gt; 属性は、関数宣言と、そのような関数の呼び出しに使用される含むデッドコード削除または他の最適化、エラーまたは（それぞれ）警告を介して除去されていない &lt;var&gt;message&lt;/var&gt; 診断されます。これは、特に &lt;code&gt;__builtin_constant_p&lt;/code&gt; およびインライン関数とともに、 &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; トリック。</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">場合は &lt;var&gt;filename&lt;/var&gt; 提供され、その後、適用可能なすべての最適化からのダンプはに連結されている &lt;var&gt;filename&lt;/var&gt; 。それ以外の場合、ダンプは出力されます</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; に続くCコードが出力オペランドをまったく使用しない場合は、 &lt;code&gt;asm&lt;/code&gt; ステートメントに &lt;code&gt;volatile&lt;/code&gt; を使用して、オプティマイザが &lt;code&gt;asm&lt;/code&gt; ステートメントを不要として破棄しないようにします（&lt;a href=&quot;#Volatile&quot;&gt;Volatileを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">CPUが投機的に実行している場合は、どちらかになります。</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">CPUがコードを投機的に実行していない場合は、 &lt;var&gt;val&lt;/var&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">ベクトル/スカラー（power8-vector）命令セットへのISA 2.07の追加が利用可能な場合、64ビットターゲットに対して以下の追加関数を利用できます。これらの &lt;var&gt;__uint128&lt;/var&gt; を使用するための &lt;var&gt;__int128&lt;/var&gt; および__uint128タイプを保持するために、新しいベクトルタイプ（ &lt;var&gt;vector __int128&lt;/var&gt; および &lt;var&gt;vector __uint128&lt;/var&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">ベクトル/スカラー（power8-vector）命令セットへのISA 2.07の追加が利用可能な場合、32ビットと64ビットの両方のターゲットで次の追加関数を使用できます。64ビットターゲットの場合、 &lt;var&gt;vector long&lt;/var&gt; longの代わりに &lt;var&gt;vector long long&lt;/var&gt; 、 &lt;var&gt;vector bool long&lt;/var&gt; longの代わりに &lt;var&gt;vector bool long long&lt;/var&gt; を、 &lt;var&gt;vector unsigned long&lt;/var&gt; longの代わりに &lt;var&gt;vector unsigned long long&lt;/var&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">ISA 3.0命令セットの追加(</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">ISA 3.0 命令セットの追加が有効な場合 (</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">マクロの引数の型が可変的に変更されている場合、 &lt;code&gt;__auto_type&lt;/code&gt; を使用すると1回だけ評価されますが、 &lt;code&gt;typeof&lt;/code&gt; を使用すると2回評価されます。</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">属性が指定され、 &lt;code&gt;#pragma omp declare simd&lt;/code&gt; が宣言と</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">コンパイラがデフォルトでシステムのヘッダーを使用するように構築されている場合、このオプションのデフォルトは、コンパイラが実行されているシステムのバージョンです。それ以外の場合、デフォルトでは、できるだけ多くのシステムおよびコードベースと互換性のある選択が行われます。</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">コンパイラーの最適化で関数の本体または本体から抽出された情報を使用して別の関数を最適化/変更する場合、後者は前者の影響を受ける関数と呼ばれます。関数にパッチを適用する場合、影響を受ける関数にもパッチを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">暗号化命令が有効な場合 (</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">デバイスに特定の &lt;code&gt;RAMP&lt;/code&gt; レジスタが付属している場合、ISRプロローグ/エピローグはそのSFRを保存/復元し、ISRコードが（暗黙的に）使用する可能性がある場合にゼロに初期化します。</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">デバイスがサポートして変更することが64 KiBのと、コンパイラのニーズよりも大きなRAM場合 &lt;code&gt;RAMPZ&lt;/code&gt; を操作を達成するために、 &lt;code&gt;RAMPZ&lt;/code&gt; は、操作の後にゼロにリセットされます。</target>
        </trans-unit>
        <trans-unit id="f00789f645166f6c5f009a2c80467dcc5f52da72" translate="yes" xml:space="preserve">
          <source>If the diagnostic has a path of control-flow events associated with it, it has a &lt;code&gt;path&lt;/code&gt; array of objects representing the events. Each event object has a &lt;code&gt;description&lt;/code&gt; string, a &lt;code&gt;location&lt;/code&gt; object, along with a &lt;code&gt;function&lt;/code&gt; string and a &lt;code&gt;depth&lt;/code&gt; number for representing interprocedural paths. The &lt;code&gt;function&lt;/code&gt; represents the current function at that event, and the &lt;code&gt;depth&lt;/code&gt; represents the stack depth relative to some baseline: the higher, the more frames are within the stack.</source>
          <target state="translated">診断に制御フローイベントのパスが関連付けられている場合、診断にはイベントを表すオブジェクトの &lt;code&gt;path&lt;/code&gt; 配列があります。各イベントオブジェクトには、 &lt;code&gt;description&lt;/code&gt; 文字列、 &lt;code&gt;location&lt;/code&gt; オブジェクト、 &lt;code&gt;function&lt;/code&gt; 文字列、およびプロシージャ間のパスを表すための &lt;code&gt;depth&lt;/code&gt; 番号があります。 &lt;code&gt;function&lt;/code&gt; そのイベントで現在の関数を表し、及び &lt;code&gt;depth&lt;/code&gt; 、いくつかのベースラインに対してスタックの深さを表す：高く、より多くのフレームがスタック内にあります。</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">等号を省略した場合は、デフォルトの</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">転送フックが存在しないか &lt;code&gt;NULL&lt;/code&gt; を返す場合、ランタイムは現在、非推奨の古いAPIを使用して転送を試み、それが失敗した場合、プログラムを中止します。GNU Objective-Cランタイムの将来のバージョンでは、ランタイムはすぐに中止されます。</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">&lt;code&gt;untrusted_index&lt;/code&gt; が500の制限未満で関数が繰り返し呼び出される場合、分岐予測子は、 &lt;code&gt;array&lt;/code&gt; 格納された値を返すコードのブロックが実行されることを学習します。その後、範囲外の値で関数が呼び出された場合でも、予測が正しくないとCPUが判断するまで、そのコードブロックを最初に実行しようとします（CPUは、その時点で不正な操作を巻き戻します）。ただし、関数の結果がどのように使用されるかに応じて、範囲外の場所に格納されたものを明らかにできるトレースをキャッシュに残すことができる場合があります。組み込み関数を使用して、コードを次のように変更することにより、この方法でデータの漏洩を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">関数が &lt;code&gt;extern&lt;/code&gt; と宣言されている場合、関数のこの定義はインライン化にのみ使用されます。関数をスタンドアロン関数としてコンパイルすることは決してありません。明示的にアドレスを取得する場合でも同様です。このようなアドレスは、関数を宣言しただけで関数を定義していないかのように、外部参照になります。これはほとんどマクロの効果があります。これを使用する方法は、関数定義をこの属性を持つヘッダーファイルに入れ、 &lt;code&gt;extern&lt;/code&gt; なしで関数の別のコピーを置くことです、ライブラリファイル内。ヘッダーファイル内の定義により、関数のほとんどの呼び出しがインライン化されます。関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照します。関数の2つの定義は厳密に同じである必要はありませんが、同じ効果がない場合はプログラムが奇妙に動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">関数が複数の場所でインライン化されている場合、各場所のブロック構造は同じではないかもしれません。例えば、ある条件がコンパイル時に計算できるようになった場合などです。インライン関数のすべての使用法が同じソース行に対して表示されるため、行数自体が矛盾しているように見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">関数がインライン化されていない場合、コンパイラは必要なオブジェクト・ファイルに関数の行外コピーを出力する必要があります。もし</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">ホットパッチオプションが有効な場合、コンパイルユニット内のすべての関数に対して「ホットパッチ」関数プロローグが生成されます。関数ラベルの前には、指定された数の2バイトのNOP命令が追加されます（ &lt;var&gt;pre-halfwords&lt;/var&gt; 、最大1000000）。ラベルの後に、アーキテクチャで許可されている最大のNOPのような命令を使用して、2 * &lt;var&gt;post-halfwords&lt;/var&gt; バイトが追加されます（最大1000000）。</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">のような関数宣言が入力プログラムに含まれている場合。</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">リンカがアプリケーションが小さすぎるデータを使用していると文句を言う場合は、パフォーマンスクリティカルではない部分を</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">セット内の候補の数がこの値よりも少ない場合は、新規追加の際には必ず不要なIVをセットから削除するようにしてください。</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">オペランド場合 &lt;code&gt;__alignof__&lt;/code&gt; は左辺値ではなく、型で、その値は、その型のために必要なアライメントで、アカウントに任意の最小アラインメントを取ることは、属性で指定された &lt;code&gt;aligned&lt;/code&gt; （参照&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数の属性&lt;/a&gt;）。たとえば、この宣言の後：</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__alignof__&lt;/code&gt; 式のオペランドが関数の場合、式は、属性の &lt;code&gt;aligned&lt;/code&gt; によって指定できる関数の整列に評価されます（「&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通の関数属性&lt;/a&gt;」を参照）。</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">式の挿入と削除の比率がこの値よりも大きい場合、RTL PREは式を挿入または削除し、その結果、命令ストリームに部分的に冗長な計算を残します。</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">レジスタがコールセーブされたレジスタである場合、コールABIが影響を受けます:変数が代入された後の関数エピローグシーケンスではレジスタは復元されません。したがって、関数は標準ABIを想定した呼び出し元に安全に戻ることができません。</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">同じフィールドが複数回初期化されている場合や、ユニオンのフィールドが重複して初期化されている場合は、最後に初期化されたフィールドの値が使用されます。ユニオンのフィールド自体が構造体の場合は、最後に初期化されたフィールドからの構造体全体が使用されます。前の初期化子に副作用があった場合、副作用が発生するかどうかは不特定です。現在、GCCは副作用のある初期化子式を破棄して警告を出しています。</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">シフト演算の第2引数が範囲内であれば、シフト演算の結果が未定義でないことを確認します。未定義とみなされるものは、CとC++、ISO C90とC99などの間で若干異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">選択された浮動小数点ハードウェアにNEON拡張機能が含まれている場合(例えば</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">ローカル変数のサイズがバイト数以下の場合は、ランタイムコールバックを使用せずに、直接シャドウメモリをポイズン(またはアンポイズン)します。</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用が（部分的に）動的であり、制限がない場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用量が（部分的に）動的であるが制限されている場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用量が完全に静的であるが、指定された量を超える場合、それは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">ターゲットが命令キャッシュのフラッシュを必要としない場合、 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; は効果がありません。それ以外の場合、命令キャッシュをクリアするために命令が &lt;code&gt;__clear_cache&lt;/code&gt; で発行されるか、libgccの__clear_cache関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">ターゲットがデータプリフェッチをサポートしていない場合、アドレス式は副作用を含む場合に評価されますが、他のコードが生成されず、GCCが警告を発行しない場合に評価されます。</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">ターゲットが BSS セクションをサポートしている場合、GCC はデフォルトでゼロに初期化された変数を BSS に入れます。これにより、結果として得られるコードのスペースを節約することができます。</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">トランザクションがアボートする場合、すべての副作用は取り消され、ビットマスクとしてエンコードされたアボートコードが返される。以下のマクロが定義されています。</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">その中の値に副作用がある場合、副作用は一度だけ発生し、範囲のイニシャライザで初期化されたフィールドごとに発生するのではありません。</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; の値が常に1、2、または3の場合、 &lt;code&gt;x&lt;/code&gt; は常に初期化されますが、GCCはこれを認識しません。警告を抑制するには、assert（0）または同様のコードでデフォルトのケースを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">変数がインラインアセンブリで参照される場合、アクセスのタイプは制約を介してコンパイラーに提供する必要があります（&lt;a href=&quot;constraints#Constraints&quot;&gt;制約を&lt;/a&gt;参照）。基本的なasmからのアクセスはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">出力オペランドがなく、入力オペランドがある場合は、出力オペランドがあるところに2つの連続したコロンを配置してください。</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">ロックフリーの命令シーケンスを提供するパターンやメカニズムがない場合は、実行時に解決されるべき同じパラメータを持つ外部ルーチンへの呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">これらのオプションが提供されている場合、S / 390バックエンドは、スタックサイズが &lt;var&gt;stack-guard&lt;/var&gt; サイズを超える &lt;var&gt;stack-size&lt;/var&gt; ガードバイトである場合にトラップをトリガーする追加の命令を関数プロローグで発行します（S / 390上のスタックは下向きに成長することに注意してください）。場合 &lt;var&gt;stack-guard&lt;/var&gt; オプションが省略されたコンパイルされた関数のフレームサイズよりも大きい2の最小電力が選択されます。これらのオプションは、スタックオーバーフローの問題のデバッグに使用することを目的としています。追加で発行されたコードはオーバーヘッドをほとんど引き起こさないため、パフォーマンスを大幅に低下させることなく、本番のようなシステムでも使用できます。与えられた値は2の正確な累乗でなければならず、 &lt;var&gt;stack-size&lt;/var&gt; は &lt;var&gt;stack-guard&lt;/var&gt; より大きい必要があります64kを超えることなく。効率を上げるために、追加のコードは、スタックが &lt;var&gt;stack-size&lt;/var&gt; で指定された値に揃えられたアドレスから始まると仮定しています。 &lt;var&gt;stack-guard&lt;/var&gt; オプションはのみと組み合わせて使用することができます &lt;var&gt;stack-size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">このような場合は、コードを</target>
        </trans-unit>
        <trans-unit id="53d537c555f3b94f5d31bf2fb2f1a8bc63f88e46" translate="yes" xml:space="preserve">
          <source>If this is option is provided then the stack depth will be printed for each run of events within</source>
          <target state="translated">このオプションが指定された場合、スタックの深さは</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">このオプションがコマンドラインに複数回表示され、異なる値が指定されている場合、 '</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">このオプションを無効にすると、コンパイラは最も効率的な命令を使用します。前の例では、ビットフィールドの一部を含まないバイトや、更新されるビットフィールドとは関係のないメモリマップされたレジスタにアクセスしますが、これは32ビットのロード命令かもしれません。</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">このオプションを有効にすると、コンパイラは関数の不必要なオーバーアラインメントを避けようとします。コンパイラはアセンブラに</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">このオプションが提供されていないが</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">このオプションを使用しない場合は、シングルコア・アプリケーション・プログラミング・モデルが使用されます。</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">このオプションが設定されている場合、明示的な</target>
        </trans-unit>
        <trans-unit id="8f5657470cc0e8b94374de4f09052f6ad27d3937" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler warns for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">このオプションを使用すると、コンパイラーは、サイズが無制限であるか、配列サイズが &lt;var&gt;byte-size&lt;/var&gt; バイトを超えることを許可する引数によって制限されている可変長配列の宣言について警告します。これはどのように似ています</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">このオプションを使用すると、コンパイラーは、サイズが無制限であるか、配列サイズが &lt;var&gt;byte-size&lt;/var&gt; バイトを超えることができる引数で制限されている可変長配列の宣言について警告します。これは、</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">この変数が設定されている場合、その値は、 &lt;code&gt;__DATE__&lt;/code&gt; および &lt;code&gt;__TIME__&lt;/code&gt; マクロの現在の日付と時刻の代わりに使用されるUNIXタイムスタンプを指定し、埋め込まれたタイムスタンプを再現できるようにします。</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">この変数が設定されている場合、その値はコンパイラが処理する非システムヘッダファイルに基づいて Make の依存関係を出力する方法を指定します。システムヘッダファイルは依存関係の出力では無視されます。</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">関数に使用する場合は、PLTサフィックスを印刷し、PICコードを生成します。たとえば、関数foo（）の「foo」の代わりに &lt;code&gt;foo@PLT&lt;/code&gt; ます。定数に使用する場合は、構文固有の接頭辞をすべて削除し、必要な定数を発行します。上記の &lt;code&gt;p&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">シェルまたはシェルのようなプログラムからプリプロセッサを呼び出す場合は、シェルの引用構文を使用して、シェル構文で意味を持つスペースなどの文字を保護する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">プラグインがサポートされているリンカを使用していない場合やリンカプラグインを有効にしていない場合は</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">他の最適化オプションを使用していない場合は</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">Cfront-model のコードを使用している場合は、おそらく</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">GNUstep-Baseなどの「Foundation」ライブラリを使用している場合、このライブラリは、ほとんどの検査タスクを実行するための豊富な機能セットを提供し、おそらくGNU Objective-CランタイムAPIへの直接アクセスのみが必要になります新しいクラスまたはメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO Cプログラムに含まれたときに必須の作業というヘッダファイルを作成している場合、書き込みが &lt;code&gt;__typeof__&lt;/code&gt; の代わりに &lt;code&gt;typeof&lt;/code&gt; 演算。&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;代替キーワードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO C90プログラムに含めるヘッダーファイルを記述する &lt;code&gt;__inline__&lt;/code&gt; は、 &lt;code&gt;inline&lt;/code&gt; ではなく__inline__を記述します。&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;代替キーワードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">アクセスされるメモリの量を制御することにこだわるのであれば、揮発性のものを使用しますが、ビットフィールドは使用しません。</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">モジュール &lt;var&gt;Mod&lt;/var&gt; をコンパイルすると</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">'でマークされたヘッダーファイルでクラスを定義する場合</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">最適化レベル・オプションを指定しない場合</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">プリコンパイルされたヘッダを生成して使用する際に異なるオプションを使用した場合、実際の動作はオプションの動作が混在しています。例えば</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">オペランドのタイプがわからない場合でも、これを行うことができますが、 &lt;code&gt;typeof&lt;/code&gt; または &lt;code&gt;__auto_type&lt;/code&gt; を使用する必要があります（&lt;a href=&quot;typeof#Typeof&quot;&gt;Typeofを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">GCCを使っていて困ったことがあれば</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">複数の入力ファイルを使用して &lt;code&gt;gcov&lt;/code&gt; を呼び出す場合、各入力ファイルからの寄与が合計されます。通常は、実行可能ファイルの最終リンクと同じファイルリストを使用して呼び出します。</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">GCC を並列に起動して、異なるサブディレクトリに共通のベース名を持つ複数の異なるソースファイルをコンパイルしたり、複数の出力先に向けてコンパイルされた同じソースファイルをコンパイルしたりすると、異なる並列コンパイラが互いに干渉して一時ファイルを上書きしてしまう可能性があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">上記が10バイトの配列しか読み取らないことがわかっている場合は、代わりに次のようなメモリ入力を使用できます。 &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">標準準拠のライブラリが必要な場合は、GCCがライブラリを提供していないため、ライブラリを見つける必要があります。GNU Cライブラリ（ &lt;code&gt;glibc&lt;/code&gt; と呼ばれる）は、ISO C、POSIX、BSD、SystemV、およびX / Openとの互換性をGNU / LinuxおよびHURDベースのGNUシステムに提供します。他のシステムをサポートする最近のバージョンはありませんが、非常に古いバージョンはサポートしていました。GNU Cライブラリのバージョン2.2には、ほぼ完全なC99サポートが含まれています。新しいライブラリが利用可能かどうかをオペレーティングシステムのベンダーに問い合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">異なる言語、ターゲット、またはコンパイラオプションに対して同じヘッダーファイルをプリコンパイルする必要がある場合は、代わりに次のような名前の&lt;em&gt;ディレクトリ&lt;/em&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">代入が発生した後に揮発性オブジェクトを読み込む必要がある場合は、シーケンスポイントを介在させた別の式を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">コンパイルのいくつかの段階だけが必要な場合は</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">コードの最適化に &lt;code&gt;gcov&lt;/code&gt; を使用する場合は、まず特別なGCCオプションを使用してプログラムをコンパイルする必要があります '</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">使用可能なTOCスペースがオーバーフローしたというリンカのエラーメッセージが表示された場合、使用するTOCスペースの量を減らすには</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">変数宣言で &lt;code&gt;short_a&lt;/code&gt; を &lt;code&gt;short&lt;/code&gt; に置き換えた場合、上記のプログラムは、</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">「を指定した場合</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">関数定義で &lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; の両方を指定した場合、その定義はインライン化のみに使用されます。アドレスを明示的に参照したとしても、関数が単独でコンパイルされることはありません。そのようなアドレスは、関数を宣言しただけで関数を定義していないかのように、外部参照になります。</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">のようなコマンドラインスイッチを指定した場合</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">どちらも指定しない場合</target>
        </trans-unit>
        <trans-unit id="6cae6e383580c515521bd2b40fbda23cacc80529" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used.</source>
          <target state="translated">オプションの &lt;var&gt;n&lt;/var&gt; を指定すると、リンク時に行われる最適化とコード生成は、インストールされている &lt;code&gt;make&lt;/code&gt; プログラムを利用して、 &lt;var&gt;n&lt;/var&gt; 個の並列ジョブを使用して並列に実行されます。環境変数 &lt;code&gt;MAKE&lt;/code&gt; を使用して、使用するプログラムをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">オプションの &lt;var&gt;n&lt;/var&gt; を指定すると、リンク時に行われる最適化とコード生成は、インストールされている &lt;code&gt;make&lt;/code&gt; プログラムを使用して、 &lt;var&gt;n&lt;/var&gt; 個の並列ジョブを使用して並列に実行されます。環境変数 &lt;code&gt;MAKE&lt;/code&gt; を使用して、使用するプログラムをオーバーライドできます。 &lt;var&gt;n&lt;/var&gt; のデフォルト値は1です。</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">これらのオプションの両方を指定しても、TOC内のスペースが足りない場合は</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">含まれている関数が終了した後で、ネストされた関数をそのアドレスで呼び出そうとすると、すべての地獄が壊れます。含まれているスコープレベルが終了した後にそれを呼び出そうとした場合、スコープから外れた変数の一部を参照している場合は幸運かもしれませんが、リスクを取るのは賢明ではありません。ただし、ネストされた関数がスコープから外れたものを参照しない場合は、安全である必要があります。</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">新しいシステムバージョンをインストールするなどしてシステムのヘッダーファイルを更新しても、GCCの固定ヘッダーファイルは自動的には更新されません。にインストールされている &lt;code&gt;mkheaders&lt;/code&gt; スクリプトを使用して更新できます。</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">を使用する場合は</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">あなたが使用する場合</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">このオプションと</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">複数の</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">1つの大きなファイルを使ってインスタンションを行う場合は</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">&lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; アドレススペースの1つを使用する場合、リンカスクリプトを &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; して、必要に応じて.progmem &lt;var&gt;N&lt;/var&gt; .dataセクションを見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">を使用している場合は</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 修飾子を使用する場合、インライン化の目的で、 &lt;code&gt;asm&lt;/code&gt; ステートメントのサイズは可能な限り最小のサイズと見なされます（&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asmのサイズを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">ISA 3.0 命令セット (</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">別の引数を取るオプションを渡したい場合は</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">引数を取るオプションを渡したい場合は</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">最初に配列を渡し、その後に長さを渡したい場合は、パラメータリストで前方宣言を使用できます&amp;mdash;別のGNU拡張機能です。</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">グローバルレジスタ変数を実際に使用しないソースファイルを再コンパイルして、指定されたレジスタを他の目的で使用しないようにしたい場合は、実際にグローバルレジスタ宣言をソースコードに追加する必要はありません。コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">変数の初期化されていない値を自身のイニシャライザで使用しているコードについて警告したい場合は</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">自分のコレクションオブジェクトを高速な列挙で使えるようにしたい場合は、そのオブジェクトに</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">コマンドラインで関数のようなマクロを定義したい場合は、引数リストを等号（ある場合）の前に括弧で囲みます。括弧はほとんどのシェルにとって意味があるため、オプションを引用する必要があります。 &lt;code&gt;sh&lt;/code&gt; と &lt;code&gt;csh&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">コードが複数のアセンブラの方言をサポートする必要がある場合 (例えば、様々なコンパイルオプションをサポートする必要があるパブリックヘッダを書く場合など)、この形式のコンストラクトを使用します。</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">何らかの理由で文字 'を含めたい場合</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">代わりにGCCドライバを使用して共有ライブラリを作成した場合、共有ライブラリが必ずしも共有されている</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;#ident&lt;/code&gt; ディレクティブは無視してください。</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">即時15ビット符号なし整数</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">即時16ビット符号付き整数</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">-16..4294967295の範囲の即時32ビット整数（つまり、32ビット符号なし整数または '</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">命令のエンコーディングに付けられる32ビット符号付き整数。</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">2つに分割できる即時64ビット定数 '</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">即定数 -1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">命令エンコーディングでインライン化できる即定数:整数 -16~64、または float 0.0,+/0.5,+/1.0,+/2.0,+/4.0,1.0/(2.0*PI)</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">16~64の範囲の即時整数</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">遅延リンクとdlopenされた共有ライブラリ内の関数への長い呼び出しをサポートするインラインPLT呼び出しシーケンスを使用して、-fno-pltと長い呼び出しを実装します（実装しません）。インラインPLT呼び出しは、新しいGNUリンカーを備えたPowerPC64 ELFv2および32ビットPowerPCシステムでのみサポートされ、GCCの構成時にサポートが検出された場合はデフォルトで有効になり、32ビットPowerPCの場合はGCCが</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">スレッド間の順序付け制約がないことを暗示します。</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">AMD Athlon CPUをMMX、3DNow!、強化された3DNow!、SSE命令セットのフルサポートで改善。</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">ジェネリックプログラミングのサポートを強化しました。</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPUの改良版で、64ビット拡張、MMX、SSE、SSE2、SSE3の命令セットをサポート。</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">MMX、SSE、SSE2、SSE3命令セットをサポートしたIntel Pentium 4 CPUの改良版。</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">AMD K6 CPUのMMXと3DNow!命令セットをサポートした改良版。</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">AMD K8コアのSSE3命令セットをサポートした改良版。</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">では &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; はに展開 &lt;code&gt;((void *)0)&lt;/code&gt; 。GCCは、 &lt;code&gt;NULL&lt;/code&gt; を定義する他のヘッダーを提供していません。一部のライブラリ実装では、それらのヘッダーで他の定義を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">で &lt;code&gt;get_i()&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; コンパイラは（ここではグローバルスコープである）を囲む名前空間スコープで宣言された名前を探しますので、依存コンテキストで使用されていません。これは依存しており、 &lt;code&gt;Derived&lt;/code&gt; を宣言した後でも &lt;code&gt;Base&lt;/code&gt; の特殊化を宣言する可能性があるため、基本クラスを調べないため、コンパイラーは &lt;code&gt;i&lt;/code&gt; が何を参照するのかを実際に知ることができません。グローバル変数 &lt;code&gt;i&lt;/code&gt; がない場合は、エラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">Cコードでは、このオプションは、C標準では&lt;em&gt;暫定的な定義&lt;/em&gt;と呼ばれる、初期化子なしで定義されたグローバル変数の配置を制御します。暫定的な定義は、ストレージを割り当てない &lt;code&gt;extern&lt;/code&gt; キーワードを使用した変数の宣言とは異なります。</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">Cモードでは、これは</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">Cでは、このオプションはユニバーサルゼロ初期化子について警告しません '</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">C++コードでは、これにより、構造体のメンバ名を以前の型宣言と同様のものにすることができます。</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">C++では、オブジェクトの値はその有効期間内の変更によってのみ影響を受けます。コンストラクタが開始されると、オブジェクトは不確定な値を持ち、オブジェクトの有効期間内の変更は、オブジェクトが破棄されるとデッドストアとなります。通常、デッドストアの除去はこれを利用します。コードがオブジェクトの寿命を超えてもオブジェクトのストレージの値が維持されることに依存している場合は、このフラグを使用してこの最適化を無効にすることができます。コンストラクタが開始される前にストアを保存しておき(たとえば演算子 new がオブジェクトストレージをクリアするなど)、 デストラクタの後にオブジェクトをデッドストアとして扱うには</target>
        </trans-unit>
        <trans-unit id="56ef40910d39bd9b38715d5759edee181d6be40d" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor, you can use</source>
          <target state="translated">C++では、オブジェクトの値はその有効期間内の変更によってのみ影響を受けます。コンストラクタが開始されると、オブジェクトは不確定な値を持ち、オブジェクトの有効期間内の変更は、オブジェクトが破棄されるとデッドストアとなります。通常、デッドストアの除去はこれを利用します。コードがオブジェクトの寿命を超えてもオブジェクトのストレージの値が維持されることに依存している場合は、このフラグを使用してこの最適化を無効にすることができます。コンストラクタが開始される前にストアを保存しておき(たとえば演算子 new がオブジェクトストレージをクリアするなど)、 デストラクタの後にオブジェクトをデッドストアとして扱うには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">C ++では、 '</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">C ++では、属性の可視性（「&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性&lt;/a&gt;」を参照）は、クラス、構造体、共用体、列挙型にも適用できます。他のタイプ属性とは異なり、属性は最初のキーワードとタイプの名前の間に出現する必要があります。タイプの本体の後に表示することはできません。</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">C++では、テンプレート引数の可視性が制限されている場合、この制限は暗黙的にテンプレート・インスタンスに伝搬されます。それ以外の場合は、テンプレートのインスタンス化と特殊化は、そのテンプレートの可視性をデフォルトとします。</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">C ++では、スレッドローカル変数の初期化子が存在する場合、ANSI / ISO C ++標準の5.19.2で定義されているように、それは &lt;var&gt;constant-expression&lt;/var&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">C ++では、メンバー関数（PMF）へのポインターは、考えられるすべての呼び出しメカニズムを処理するために、ソートのワイドポインターを使用して実装されます。PMFは、調整方法に関する情報を保存する必要があります '</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">C ++では、 &lt;code&gt;ifunc&lt;/code&gt; 属性はリゾルバー関数のマングル名である文字列を取ります。A C ++クラスの非静的メンバ関数のためのリゾルバ &lt;code&gt;C&lt;/code&gt; は、ポインタを取る非メンバ関数へのポインタを返すように宣言されるべきである &lt;code&gt;C&lt;/code&gt; インプリメンテーション機能のと同じ引数が続く最初の引数として、。G ++は2つの関数の署名をチェックし、</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">C ++では、論理演算子 &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; ベクトルに使用できます。 &lt;code&gt;!v&lt;/code&gt; は &lt;code&gt;v == 0&lt;/code&gt; と同等であり、 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; は &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; および &lt;code&gt;a || b&lt;/code&gt; と同等です。bはaと同等 &lt;code&gt;a!=0 | b!=0&lt;/code&gt; 。スカラー &lt;code&gt;s&lt;/code&gt; とベクトル &lt;code&gt;v&lt;/code&gt; の間の混合演算の場合、 &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; は &lt;code&gt;s?v!=0:0&lt;/code&gt; （評価は短絡）と同等であり、 &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; は &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">C ++では、三項演算子 &lt;code&gt;?:&lt;/code&gt; を使用できます。 &lt;code&gt;a?b:c&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; 同じタイプのベクトルであり、同じサイズの同じ要素数を有する整数のベクトルであり &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; 、すべての3つの引数を計算し、ベクトル作成 &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; 。 OpenCLとは異なり、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;a != 0&lt;/code&gt; として解釈され、 &lt;code&gt;a &amp;lt; 0&lt;/code&gt; はないことに注意してください。バイナリ演算の場合と同様に、この構文は、 &lt;code&gt;b&lt;/code&gt; または &lt;code&gt;c&lt;/code&gt; のいずれかがスカラーで、その後ベクトルに変換される場合にも受け入れられます。もし両方 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; そして &lt;code&gt;c&lt;/code&gt; スカラーとの一種である &lt;code&gt;true?b:c&lt;/code&gt; の要素型と同じサイズを有し、次いで、 &lt;code&gt;b&lt;/code&gt; のおよび &lt;code&gt;c&lt;/code&gt; が要素がこのタイプを持っておりと同数の要素を有するベクトル型に変換されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">C++では、型にはリンケージがあるため、可視性属性は関数やオブジェクトだけでなく、型にも適用されます。クラスは、その非静的データ・メンバの型やベースよりも大きな可視性を持っていてはならず、クラス・メンバはそのクラスの可視性をデフォルトとしています。また、明示的な可視性を持たない宣言は、その型の可視性に制限されます。</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C ++では、属性 &lt;code&gt;alloc_align&lt;/code&gt; 、 &lt;code&gt;alloc_size&lt;/code&gt; 、 &lt;code&gt;assume_aligned&lt;/code&gt; 、 &lt;code&gt;format&lt;/code&gt; 、 &lt;code&gt;format_arg&lt;/code&gt; 、 &lt;code&gt;malloc&lt;/code&gt; 、または &lt;code&gt;nonnull&lt;/code&gt; で宣言されたプライマリテンプレートの明示的な特殊化がそれなしで宣言されると、警告が発行されます。 &lt;code&gt;deprecated&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、および &lt;code&gt;warning&lt;/code&gt; 属性は警告を抑制します。（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">C ++では、この属性は &lt;code&gt;extern&lt;/code&gt; にまったく依存していませんが、特別な動作を有効にするには &lt;code&gt;inline&lt;/code&gt; キーワードが必要です。</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">C ++では、このプラグマは「C」リンケージの宣言にのみ暗黙的に適用されます。繰り返しますが、 &lt;code&gt;asm&lt;/code&gt; ラベルにはこの制限はありません。</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">C ++では、 &lt;code&gt;asm&lt;/code&gt; と &lt;code&gt;inline&lt;/code&gt; が標準キーワードであるため、このスイッチは &lt;code&gt;typeof&lt;/code&gt; キーワードにのみ影響します。あなたは使用したいかもしれません</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">C++では、クラスのメンバ関数や静的メンバ変数を visibility 属性でマークすることができます。これは、特定のメソッドや静的メンバ変数が 1 つの共有オブジェクトからのみ使用されるべきであることがわかっている場合に便利です。例えば、クラス全体を非表示にすることなくインライン・メソッドを非表示にすることは通常は有用ではありません。</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">C ++ 14では &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; 呼び出しますが、C ++ 17では &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">C++17 では、コンパイラはこれらのテンポラリを省略する必要がありますが、このオプションはまだ些細なメンバ関数に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">Cでは、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; はのためのさらに別の名前である &lt;code&gt;__func__&lt;/code&gt; 、それは文字列に評価（C ++、名前空間スコープでは、）のファイルでことを除いて、 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。さらに、C ++では、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; には関数のシグネチャとその基本名が含まれています。たとえば、このプログラム：</target>
        </trans-unit>
        <trans-unit id="fdc98ae804a4e7fb53930f663d8637b51c1dfdb4" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file scope (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">Cでは、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; はのためのさらに別の名前である &lt;code&gt;__func__&lt;/code&gt; ファイルスコープ（または、C ++、名前空間スコープ内）で、それは文字列に評価することを除いて、 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。さらに、C ++では、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; には、関数のシグネチャとそのベアネームが含まれています。たとえば、次のプログラムは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Cでは、複合リテラルは、静的または自動の保存期間を持つ名前のないオブジェクトを指定します。 C ++では、複合リテラルは、その完全式の終わりまでのみ存続する一時オブジェクトを指定します。その結果、複合リテラルのサブオブジェクトのアドレスを取得する明確に定義されたCコードは、C ++では未定義になる可能性があるため、G ++は一時配列のポインターへの変換を拒否します。たとえば、上記の配列複合リテラルの例が関数内にある場合、C ++でのその後の &lt;code&gt;foo&lt;/code&gt; の使用は、配列の有効期間が &lt;code&gt;foo&lt;/code&gt; の宣言の後に終了するため、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">Cでは、関数がすべての呼び出し元にインライン化されている場合でも、オブジェクトファイルに &lt;code&gt;inline&lt;/code&gt; 宣言されている &lt;code&gt;static&lt;/code&gt; 関数を発行します。このスイッチは、GNU C90の &lt;code&gt;extern inline&lt;/code&gt; 拡張を使用する機能には影響しません。C ++では、すべてのインライン関数をオブジェクトファイルに出力します。</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">Cでは、関数が &lt;code&gt;extern&lt;/code&gt; でも &lt;code&gt;static&lt;/code&gt; でもない場合、関数はスタンドアロン関数としてコンパイルされ、可能な場合はインライン化されます。</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">C / C ++では、 &lt;code&gt;else&lt;/code&gt; ブランチはすべて可能な限り最も内側の &lt;code&gt;if&lt;/code&gt; ステートメントに属し、この例では &lt;code&gt;if (b)&lt;/code&gt; です。上記の例で示したように、これはプログラマーが選択したインデントによってプログラマーが期待したものとは異なります。この混乱の可能性がある場合、このフラグを指定すると、GCCは警告を発行します。警告を排除するには、最も内側の &lt;code&gt;if&lt;/code&gt; ステートメントを明示的に中括弧で囲み、 &lt;code&gt;else&lt;/code&gt; が外側の &lt;code&gt;if&lt;/code&gt; に属することができないようにします。結果のコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">G ++では、ステートメント式の結果値は配列と関数ポインターの減衰を受け、値によって囲んでいる式に返されます。たとえば、 &lt;code&gt;A&lt;/code&gt; がクラスの場合、</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">GNU CおよびC ++では、関数属性を使用して、コンパイラーが呼び出しを最適化したり、コードの正確性をより注意深くチェックしたりするのに役立つ特定の関数プロパティを指定できます。たとえば、属性を使用して、関数が決して戻らない（ &lt;code&gt;noreturn&lt;/code&gt; ）、その引数の値にのみ依存して値を返す（ &lt;code&gt;const&lt;/code&gt; ）、または &lt;code&gt;printf&lt;/code&gt; スタイルの引数（ &lt;code&gt;format&lt;/code&gt; ）を指定することができます。</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">GNU Cでは、加算と減算の演算は、 &lt;code&gt;void&lt;/code&gt; へのポインターと関数へのポインターでサポートされています。これは、 &lt;code&gt;void&lt;/code&gt; または関数のサイズを1として扱うことによって行われます。</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">GNU Cでは、属性指定子リストは、 &lt;code&gt;case&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ラベル以外のラベルに続くコロンの後に表示される場合があります。GNU C ++は、属性指定子の直後にセミコロンが続く場合（つまり、ラベルが空のステートメントに適用される場合）にのみラベルの属性を許可します。セミコロンがないと、C ++ラベル属性はあいまいになります。これは、属性リストで始まる宣言をC ++でラベル付けすることが許可されているためです。C90またはC99では宣言にラベルを付けることができないため、あいまいさが発生することはありません。</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">GNU Cでは、属性指定子リストがnull文の一部として現れることがあります。属性はセミコロンの前に現れます。</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">GNU Cでは、属性指定子リストが列挙子の一部として表示される場合があります。属性は、列挙定数の後、 &lt;code&gt;=&lt;/code&gt; の前に存在します。列挙子のオプションの属性は、列挙定数に適合します。存在する場合、定数式の後に属性を配置することはできません。</target>
        </trans-unit>
        <trans-unit id="50d3726425717c2c21e872422eba9b6e01ec20e3" translate="yes" xml:space="preserve">
          <source>In GNU C, but not GNU C++, you may also declare the type of a variable as &lt;code&gt;__auto_type&lt;/code&gt;. In that case, the declaration must declare only one variable, whose declarator must just be an identifier, the declaration must be initialized, and the type of the variable is determined by the initializer; the name of the variable is not in scope until after the initializer. (In C++, you should use C++11 &lt;code&gt;auto&lt;/code&gt; for this purpose.) Using &lt;code&gt;__auto_type&lt;/code&gt;, the &amp;ldquo;maximum&amp;rdquo; macro above could be written as:</source>
          <target state="translated">GNU C ++ではなくGNU Cでは、変数の型を &lt;code&gt;__auto_type&lt;/code&gt; として宣言することもできます。その場合、宣言は1つの変数のみを宣言する必要があり、その宣言子は単なる識別子でなければならず、宣言は初期化する必要があり、変数の型は初期化子によって決定されます。変数の名前は、初期化子の後までスコープ内にありません。 （C ++では、この目的でC ++ 11 &lt;code&gt;auto&lt;/code&gt; を使用する必要があります。） &lt;code&gt;__auto_type&lt;/code&gt; を使用すると、上記の「最大」マクロは次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="161e108f588ab6d10ef611d46f160cd49c4d5897" translate="yes" xml:space="preserve">
          <source>In GNU C, pointers to arrays with qualifiers work similar to pointers to other qualified types. For example, a value of type &lt;code&gt;int (*)[5]&lt;/code&gt; can be used to initialize a variable of type &lt;code&gt;const int (*)[5]&lt;/code&gt;. These types are incompatible in ISO C because the &lt;code&gt;const&lt;/code&gt; qualifier is formally attached to the element type of the array and not the array itself.</source>
          <target state="translated">GNU Cでは、修飾子を持つ配列へのポインターは、他の修飾型へのポインターと同様に機能します。たとえば、 &lt;code&gt;int (*)[5]&lt;/code&gt; 型の値を使用して、 &lt;code&gt;const int (*)[5]&lt;/code&gt; 型の変数を初期化できます。これらの型はISO Cでは互換性がありません &lt;code&gt;const&lt;/code&gt; 修飾子は、配列自体ではなく配列の要素型に正式に付加されるためです。</target>
        </trans-unit>
        <trans-unit id="30928a7827c13008efbc31a4cd47ef8c080ec55d" translate="yes" xml:space="preserve">
          <source>In GNU C, you may normally use dollar signs in identifier names. This is because many traditional C implementations allow such identifiers. However, dollar signs in identifiers are not supported on a few target machines, typically because the target assembler does not allow them.</source>
          <target state="translated">GNU Cでは、通常、識別子名にドル記号を使うことができます。これは伝統的な C の実装の多くがそのような識別子を許可しているからです。しかし、いくつかのターゲットマシンでは、 識別子名にドル記号を使用することができません。</target>
        </trans-unit>
        <trans-unit id="42c17a04ef25e4ac6774717de0dc2e63f588b7db" translate="yes" xml:space="preserve">
          <source>In GNU C, you may use C++ style comments, which start with &amp;lsquo;</source>
          <target state="translated">GNU Cでは、 'で始まるC ++スタイルのコメントを使用できます。</target>
        </trans-unit>
        <trans-unit id="2f24585b9162dc03bf874f7e503f710293aefabe" translate="yes" xml:space="preserve">
          <source>In ISO C and ISO C++, two identifiers are different if they are different sequences of characters. However, sometimes when characters outside the basic ASCII character set are used, you can have two different character sequences that look the same. To avoid confusion, the ISO 10646 standard sets out some &lt;em&gt;normalization rules&lt;/em&gt; which when applied ensure that two sequences that look the same are turned into the same sequence. GCC can warn you if you are using identifiers that have not been normalized; this option controls that warning.</source>
          <target state="translated">ISO CとISO C ++では、2つの識別子は、文字のシーケンスが異なる場合は異なります。ただし、基本的なASCII文字セット以外の文字が使用されている場合、同じように見える2つの異なる文字シーケンスが存在することがあります。混乱を避けるために、ISO 10646標準はいくつかの&lt;em&gt;正規化規則&lt;/em&gt;を&lt;em&gt;定めて&lt;/em&gt;おり、これを適用すると、同じように見える2つのシーケンスが確実に同じシーケンスに変換されます。正規化されていない識別子を使用している場合、GCCが警告を表示します。このオプションはその警告を制御します。</target>
        </trans-unit>
        <trans-unit id="ae9542423c752a021f2d6e4fc0443b96ae1d5030" translate="yes" xml:space="preserve">
          <source>In ISO C, this is not allowed: &lt;code&gt;long&lt;/code&gt; and other type modifiers require an explicit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">ISO Cでは、これは許可されていません： &lt;code&gt;long&lt;/code&gt; と他のタイプの修飾子が明示的に必要と &lt;code&gt;int&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="a83c2089c56e85f19efece977b66d33d39dca615" translate="yes" xml:space="preserve">
          <source>In ISO C99 you can give the elements in any order, specifying the array indices or structure field names they apply to, and GNU C allows this as an extension in C90 mode as well. This extension is not implemented in GNU C++.</source>
          <target state="translated">ISO C99では、配列のインデックスや構造体のフィールド名を指定して、任意の順序で要素を与えることができますが、GNU CではこれをC90モードでも拡張として許可しています。この拡張はGNU C++では実装されていません。</target>
        </trans-unit>
        <trans-unit id="ee146e8637f31533cbc25f2e770067e2245618cc" translate="yes" xml:space="preserve">
          <source>In ISO C99, arrays that are not lvalues still decay to pointers, and may be subscripted, although they may not be modified or used after the next sequence point and the unary &amp;lsquo;</source>
          <target state="translated">ISO C99では、左辺値ではない配列は引き続きポインタに減衰し、添字が付けられる場合がありますが、次のシーケンスポイントと単項 'の後に変更または使用することはできません</target>
        </trans-unit>
        <trans-unit id="8675eb52335a427e8b8fe6e8d5660e8a4778f71b" translate="yes" xml:space="preserve">
          <source>In Standard C++, objects defined at namespace scope are guaranteed to be initialized in an order in strict accordance with that of their definitions &lt;em&gt;in a given translation unit&lt;/em&gt;. No guarantee is made for initializations across translation units. However, GNU C++ allows users to control the order of initialization of objects defined at namespace scope with the &lt;code&gt;init_priority&lt;/code&gt; attribute by specifying a relative &lt;var&gt;priority&lt;/var&gt;, a constant integral expression currently bounded between 101 and 65535 inclusive. Lower numbers indicate a higher priority.</source>
          <target state="translated">標準C ++では、名前空間スコープで定義されたオブジェクト&lt;em&gt;は、指定された変換単位での&lt;/em&gt;定義の順序に厳密に従って、初期化されることが保証されています。翻訳単位全体の初期化は保証されません。ただし、GNU C ++では、現在101から65535までの範囲の定数積分式である相対 &lt;var&gt;priority&lt;/var&gt; 指定することで、 &lt;code&gt;init_priority&lt;/code&gt; 属性で名前空間スコープで定義されたオブジェクトの初期化の順序を制御できます。数値が小さいほど優先順位が高くなります。</target>
        </trans-unit>
        <trans-unit id="7083740b732c482c66c0773b79daf9926d12ffe7" translate="yes" xml:space="preserve">
          <source>In Thumb State the core registers &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r7&lt;/code&gt;. In ARM state this is an alias for the &lt;code&gt;r&lt;/code&gt; constraint.</source>
          <target state="translated">親指の状態でコアレジスタ &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r7&lt;/code&gt; 。ARM状態では、これは &lt;code&gt;r&lt;/code&gt; 制約のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="d1d4e1edbad74d306db2f222651915a6d0f5858a" translate="yes" xml:space="preserve">
          <source>In Thumb state, the core registers &lt;code&gt;r8&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;.</source>
          <target state="translated">Thumb状態では、コアは、レジスタ &lt;code&gt;r8&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6352795921f416092911448041e5d77f4ed5cab2" translate="yes" xml:space="preserve">
          <source>In a statement expression, any temporaries created within a statement are destroyed at that statement&amp;rsquo;s end. This makes statement expressions inside macros slightly different from function calls. In the latter case temporaries introduced during argument evaluation are destroyed at the end of the statement that includes the function call. In the statement expression case they are destroyed during the statement expression. For instance,</source>
          <target state="translated">ステートメント式では、ステートメント内で作成された一時変数はそのステートメントの終わりで破棄されます。これにより、マクロ内のステートメント式が関数呼び出しと少し異なります。後者の場合、引数の評価中に導入された一時変数は、関数呼び出しを含むステートメントの最後で破棄されます。ステートメント式の場合、それらはステートメント式の実行中に破棄されます。例えば、</target>
        </trans-unit>
        <trans-unit id="5ba9aa0570b135c995bc38a76f20798c8cb8905c" translate="yes" xml:space="preserve">
          <source>In a structure initializer, specify the name of a field to initialize with &amp;lsquo;</source>
          <target state="translated">構造体初期化子で、初期化するフィールドの名前を 'で指定します</target>
        </trans-unit>
        <trans-unit id="b60fb2c19e13e2004512b51ba3ef992aebaa1e2a" translate="yes" xml:space="preserve">
          <source>In a typical forwarding implementation, the &lt;code&gt;__objc_msg_forward2&lt;/code&gt; hook function determines the argument and return type of the method that is being looked up, and then creates a function that takes these arguments and has that return type, and returns it to the caller. Creating this function is non-trivial and is typically performed using a dedicated library such as &lt;code&gt;libffi&lt;/code&gt;.</source>
          <target state="translated">典型的な転送の実装では、 &lt;code&gt;__objc_msg_forward2&lt;/code&gt; フック関数は、検索されるメソッドの引数と戻り値の型を決定し、これらの引数を取り、その戻り値の型を持つ関数を作成して、呼び出し元に返します。この関数の作成は簡単ではなく、通常は &lt;code&gt;libffi&lt;/code&gt; などの専用ライブラリを使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="54dd00baa71ef2667fe6e28112deacb360520410" translate="yes" xml:space="preserve">
          <source>In addition a C preprocessor macro is defined, based upon the setting of this option. Possible values are: &lt;code&gt;__RL78_G10__&lt;/code&gt;, &lt;code&gt;__RL78_G13__&lt;/code&gt; or &lt;code&gt;__RL78_G14__&lt;/code&gt;.</source>
          <target state="translated">さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されます。可能な値は &lt;code&gt;__RL78_G10__&lt;/code&gt; 、 &lt;code&gt;__RL78_G13__&lt;/code&gt; または &lt;code&gt;__RL78_G14__&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ea9e02775fab3d62ec695ffb7a117d5587d95e84" translate="yes" xml:space="preserve">
          <source>In addition a C preprocessor macro is defined, based upon the setting of this option. Possible values are: &lt;code&gt;__RL78_MUL_NONE__&lt;/code&gt;, &lt;code&gt;__RL78_MUL_G13__&lt;/code&gt; or &lt;code&gt;__RL78_MUL_G14__&lt;/code&gt;.</source>
          <target state="translated">さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されます。可能な値は、 &lt;code&gt;__RL78_MUL_G13__&lt;/code&gt; &lt;code&gt;__RL78_MUL_NONE__&lt;/code&gt; 、__ RL78_MUL_G13__、または &lt;code&gt;__RL78_MUL_G14__&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8837c405f2a2c41529e9b5f823973ab02322956f" translate="yes" xml:space="preserve">
          <source>In addition an MCU-specific linker script is added to the linker command line. The script&amp;rsquo;s name is the name of the MCU with</source>
          <target state="translated">さらに、MCU固有のリンカースクリプトがリンカーコマンドラインに追加されます。スクリプトの名前は、MCUの名前です。</target>
        </trans-unit>
        <trans-unit id="62b95995af660527c1e8f21b9d4ad0c066623058" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__builtin_tbegin&lt;/code&gt; a loop for transient failures is generated. If tbegin returns a condition code of 2 the transaction will be retried as often as specified in the second argument. The perform processor assist instruction is used to tell the CPU about the number of fails so far.</source>
          <target state="translated">&lt;code&gt;__builtin_tbegin&lt;/code&gt; に加えて、一時的な障害のループが生成されます。tbeginが2の条件コードを返す場合、トランザクションは2番目の引数で指定された頻度で再試行されます。プロセッサアシスト実行命令は、これまでに失敗した回数をCPUに通知するために使用されます。</target>
        </trans-unit>
        <trans-unit id="eced644e577e40c96cd49fe30f0f7fd6120dd908" translate="yes" xml:space="preserve">
          <source>In addition to all the flags that</source>
          <target state="translated">すべてのフラグに加えて</target>
        </trans-unit>
        <trans-unit id="565a2d203f5b02e7460006ace0af95f26a347995" translate="yes" xml:space="preserve">
          <source>In addition to allowing restricted pointers, you can specify restricted references, which indicate that the reference is not aliased in the local context.</source>
          <target state="translated">制限付きポインタを許可するだけでなく、制限付き参照を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="b4b514e38fd4621ee545768450d76575b94e288e" translate="yes" xml:space="preserve">
          <source>In addition to forward declaration of explicit instantiations (with &lt;code&gt;extern&lt;/code&gt;), G++ has extended the template instantiation syntax to support instantiation of the compiler support data for a template class (i.e. the vtable) without instantiating any of its members (with &lt;code&gt;inline&lt;/code&gt;), and instantiation of only the static data members of a template class, without the support data or member functions (with &lt;code&gt;static&lt;/code&gt;):</source>
          <target state="translated">（ &lt;code&gt;extern&lt;/code&gt; を使用した）明示的なインスタンス化の前方宣言に加えて、G ++はテンプレートのインスタンス化構文を拡張し、テンプレートクラス（つまり、vtable）のコンパイラーサポートデータのインスタンス化をサポートします（そのメンバーを（ &lt;code&gt;inline&lt;/code&gt; ）インスタンス化せずに）。テンプレートクラスの静的データメンバーのみのサポートデータまたはメンバー関数（ &lt;code&gt;static&lt;/code&gt; ）なし：</target>
        </trans-unit>
        <trans-unit id="6439cc01a9774bbc0ce4a99e0995283f7780b83f" translate="yes" xml:space="preserve">
          <source>In addition to reordering basic blocks in the compiled function, in order to reduce number of taken branches, partitions hot and cold basic blocks into separate sections of the assembly and</source>
          <target state="translated">コンパイルされた関数内の基本ブロックの並び替えに加えて、取り込まれる分岐の数を減らすために、ホットとコールドの基本ブロックをアセンブリの別のセクションに分割して</target>
        </trans-unit>
        <trans-unit id="b8e7d51ee0ff5509475a8b0b3cef903395f3e89e" translate="yes" xml:space="preserve">
          <source>In addition to that, the NeXT runtime uses a different encoding for bitfields. It encodes them as &lt;code&gt;b&lt;/code&gt; followed by the size, without a bit offset or the underlying field type.</source>
          <target state="translated">それに加えて、NeXTランタイムはビットフィールドに異なるエンコーディングを使用します。ビットオフセットまたは基になるフィールドタイプなしで、サイズの後に &lt;code&gt;b&lt;/code&gt; としてエンコードします。</target>
        </trans-unit>
        <trans-unit id="f8c503d521df2902eea004c571a88a7aaf261eea" translate="yes" xml:space="preserve">
          <source>In addition to the above HTM built-ins, we have added built-ins for some common extended mnemonics of the HTM instructions:</source>
          <target state="translated">上記の HTM ビルトインに加えて、HTM 命令の一般的な拡張ニーモニックのためのビルトインを追加しました。</target>
        </trans-unit>
        <trans-unit id="084c327f43e99f5eed11f3cfccf089fdeb010185" translate="yes" xml:space="preserve">
          <source>In addition to the attributes documented here, GCC plugins may provide their own attributes.</source>
          <target state="translated">ここで説明した属性に加えて、GCC プラグインは独自の属性を提供することができます。</target>
        </trans-unit>
        <trans-unit id="59aaa6ec676f5bdbed99a7053eff5202675d0852" translate="yes" xml:space="preserve">
          <source>In addition to the full set of format archetypes (attribute format style arguments such as &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, and &lt;code&gt;strfmon&lt;/code&gt;), Darwin targets also support the &lt;code&gt;CFString&lt;/code&gt; (or &lt;code&gt;__CFString__&lt;/code&gt;) archetype in the &lt;code&gt;format&lt;/code&gt; attribute. Declarations with this archetype are parsed for correct syntax and argument types. However, parsing of the format string itself and validating arguments against it in calls to such functions is currently not performed.</source>
          <target state="translated">フォーマットアーキタイプの完全なセット（ &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 、 &lt;code&gt;strftime&lt;/code&gt; 、 &lt;code&gt;strfmon&lt;/code&gt; などの属性フォーマットスタイルの引数）に加えて、Darwinターゲットは、 &lt;code&gt;format&lt;/code&gt; 属性で &lt;code&gt;CFString&lt;/code&gt; （または &lt;code&gt;__CFString__&lt;/code&gt; ）アーキタイプもサポートしています。このアーキタイプの宣言は、構文と引数のタイプが正しいかどうか解析されます。ただし、フォーマット文字列自体の解析と、そのような関数の呼び出しでの引数に対する検証は現在行われていません。</target>
        </trans-unit>
        <trans-unit id="5bd7b4c6a1206aaa445d7deaac33eb27ef613d77" translate="yes" xml:space="preserve">
          <source>In addition to the options listed here, there are a number of options to control search paths for include files documented in &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;Directory Options&lt;/a&gt;. Options to control preprocessor diagnostics are listed in &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Warning Options&lt;/a&gt;.</source>
          <target state="translated">ここにリストされているオプションに加えて、&lt;a href=&quot;directory-options#Directory-Options&quot;&gt;ディレクトリオプションに&lt;/a&gt;記載されているインクルードファイルの検索パスを制御するためのオプションがいくつかあります。プリプロセッサー診断を制御するオプションは、&lt;a href=&quot;warning-options#Warning-Options&quot;&gt;警告オプションに&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="71f7076b5c36e97c5be103bbb5410f7a8e3b889f" translate="yes" xml:space="preserve">
          <source>In addition to the side effects of the</source>
          <target state="translated">の副作用に加えて</target>
        </trans-unit>
        <trans-unit id="3678577a99df8db4bb55d5c4af98383773644309" translate="yes" xml:space="preserve">
          <source>In addition to the tokens described by the input, output, and goto operands, these tokens have special meanings in the assembler template:</source>
          <target state="translated">input,output,および goto オペランドで記述されるトークンに加えて、これらのトークンはアセンブラテンプレートでは特別な意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="4906f7c8d95701a33b767af39ebc70e032dc64d0" translate="yes" xml:space="preserve">
          <source>In addition to the traps enabled by &amp;lsquo;</source>
          <target state="translated">によって有効化されるトラップに加えて、</target>
        </trans-unit>
        <trans-unit id="8e62f62dfa434b0bbfd42f77c43f2e3f4b28a77e" translate="yes" xml:space="preserve">
          <source>In addition to the types the compiler also encodes the type specifiers. The table below describes the encoding of the current Objective-C type specifiers:</source>
          <target state="translated">型に加えて、コンパイラは型指定子もエンコードします。以下の表は、現在の Objective-C の型指定子のエンコーディングについて説明しています。</target>
        </trans-unit>
        <trans-unit id="07e2b4620d71805ca7178b4ed737fff6b9e3c7bc" translate="yes" xml:space="preserve">
          <source>In addition to this, there are checking built-in functions &lt;code&gt;__builtin___printf_chk&lt;/code&gt;, &lt;code&gt;__builtin___vprintf_chk&lt;/code&gt;, &lt;code&gt;__builtin___fprintf_chk&lt;/code&gt; and &lt;code&gt;__builtin___vfprintf_chk&lt;/code&gt;. These have just one additional argument, &lt;var&gt;flag&lt;/var&gt;, right before format string &lt;var&gt;fmt&lt;/var&gt;. If the compiler is able to optimize them to &lt;code&gt;fputc&lt;/code&gt; etc. functions, it does, otherwise the checking function is called and the &lt;var&gt;flag&lt;/var&gt; argument passed to it.</source>
          <target state="translated">これに加えて、 &lt;code&gt;__builtin___vprintf_chk&lt;/code&gt; 関数 &lt;code&gt;__builtin___printf_chk&lt;/code&gt; 、__builtin___vprintf_chk、 &lt;code&gt;__builtin___fprintf_chk&lt;/code&gt; および &lt;code&gt;__builtin___vfprintf_chk&lt;/code&gt; のチェックがあります。これらは、ただ一つの追加の引数を、持っている &lt;var&gt;flag&lt;/var&gt; 適切なフォーマット文字列の前に、 &lt;var&gt;fmt&lt;/var&gt; 。コンパイラーがそれらを &lt;code&gt;fputc&lt;/code&gt; などの関数に最適化できる場合、そうします。そうでない場合、チェック関数が呼び出され、 &lt;var&gt;flag&lt;/var&gt; 引数がそれに渡されます。</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="translated">おまけに</target>
        </trans-unit>
        <trans-unit id="ac54bbc55b4419b170b9ec36b5935081a1cdb3e2" translate="yes" xml:space="preserve">
          <source>In addition, alignment of loops and of code after barriers are dropped.</source>
          <target state="translated">また、バリアを落とした後のループの整列やコードの整列も行っています。</target>
        </trans-unit>
        <trans-unit id="3781d09a3dc831734b5b02916076ee6266e64979" translate="yes" xml:space="preserve">
          <source>In addition, all of the following transfer instructions for internal registers X and Y must be provided to use any of the double-precision floating-point instructions. Custom instructions taking two double-precision source operands expect the first operand in the 64-bit register X. The other operand (or only operand of a unary operation) is given to the custom arithmetic instruction with the least significant half in source register &lt;var&gt;src1&lt;/var&gt; and the most significant half in &lt;var&gt;src2&lt;/var&gt;. A custom instruction that returns a double-precision result returns the most significant 32 bits in the destination register and the other half in 32-bit register Y. GCC automatically generates the necessary code sequences to write register X and/or read register Y when double-precision floating-point instructions are used.</source>
          <target state="translated">さらに、倍精度浮動小数点命令を使用するには、内部レジスタXおよびYに対する次の転送命令をすべて提供する必要があります。2倍精度ソースオペランドを取るカスタム命令は、ソースレジスタの最下位半分とカスタム演算命令に与えられる（または唯一のオペランド単項演算の）64ビットレジスタXの最初のオペランド他方のオペランドを期待 &lt;var&gt;src1&lt;/var&gt; と &lt;var&gt;src2&lt;/var&gt; の最上位半分。倍精度の結果を返すカスタム命令は、最上位32ビットを宛先レジスタに、残りの半分を32ビットレジスタYに返します。GCCは、レジスタXの書き込みやレジスタYの読み取りに必要なコードシーケンスを自動的に生成します。 -precision浮動小数点命令が使用されます。</target>
        </trans-unit>
        <trans-unit id="fef0ea4de76cead18315e4916cf4d5b385d79842" translate="yes" xml:space="preserve">
          <source>In addition, many header files are written to provide prototypes in ISO C but not in traditional C. Many of these header files can work without change in C++ provided &lt;code&gt;__STDC__&lt;/code&gt; is defined. If &lt;code&gt;__STDC__&lt;/code&gt; is not defined, they will all fail, and will all need to be changed to test explicitly for C++ as well.</source>
          <target state="translated">さらに、多くのヘッダーファイルは、ISO Cではプロトタイプを提供するために作成されますが、従来のCでは作成されません。これらのヘッダーファイルの多くは、 &lt;code&gt;__STDC__&lt;/code&gt; が定義されていれば、C ++で変更を加えなくても機能します。 &lt;code&gt;__STDC__&lt;/code&gt; が定義されていない場合、それらはすべて失敗し、C ++も明示的にテストするためにすべて変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="69f2b7c74d79a65e34a188c54ca6206079621349" translate="yes" xml:space="preserve">
          <source>In addition, optional data alignment is dropped, and the option</source>
          <target state="translated">さらに、オプションのデータアライメントは削除され、オプションの</target>
        </trans-unit>
        <trans-unit id="f5228c4c2186ef6ab55d19754c2564a752819979" translate="yes" xml:space="preserve">
          <source>In addition, seriously incorrect code results if you call a function with too many arguments. (Normally, extra arguments are harmlessly ignored.)</source>
          <target state="translated">さらに、引数が多すぎる関数を呼び出すと、深刻な不正確なコードになってしまいます。(通常、余分な引数は無害に無視されます)。</target>
        </trans-unit>
        <trans-unit id="e473178ce28eda4321e03738b81ae5d066682365" translate="yes" xml:space="preserve">
          <source>In addition, the application binary interface implemented by a C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">さらに、C++コンパイラによって実装されたアプリケーション・バイナリ・インターフェースは、コードの生成と実行時のサポートに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="f27cb290fe4b9fbefe17d7b31e3d8d9c930761f0" translate="yes" xml:space="preserve">
          <source>In addition, the prefix is used in an unusual way in finding the directories to search for header files. For each of the standard directories whose name normally begins with &amp;lsquo;</source>
          <target state="translated">さらに、ヘッダーファイルを検索するディレクトリを見つける際に、プレフィックスが通常とは異なる方法で使用されます。名前が通常 'で始まる標準ディレクトリのそれぞれについて</target>
        </trans-unit>
        <trans-unit id="5527ccace27f3e086df478c816bee689b9fc66e3" translate="yes" xml:space="preserve">
          <source>In addition, these optimization, warning, and code generation options have meanings only for C++ programs:</source>
          <target state="translated">また、これらの最適化オプション、警告オプション、コード生成オプションは、C++プログラムに対してのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="44ad112ffeb1cd8d7fe00b8c03ab2d8724483140" translate="yes" xml:space="preserve">
          <source>In addition, these warning options have meanings only for C++ programs:</source>
          <target state="translated">さらに、これらの警告オプションは、C++プログラムに対してのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="9ebc6f9e6bacdd5dfc6bdf2f0b70b8aa1ddf9898" translate="yes" xml:space="preserve">
          <source>In all these variables, an empty element instructs the compiler to search its current working directory. Empty elements can appear at the beginning or end of a path. For instance, if the value of &lt;code&gt;CPATH&lt;/code&gt; is &lt;code&gt;:/special/include&lt;/code&gt;, that has the same effect as &amp;lsquo;</source>
          <target state="translated">これらすべての変数で、空の要素はコンパイラに現在の作業ディレクトリを検索するように指示します。空の要素は、パスの最初または最後に表示できます。たとえば、 &lt;code&gt;CPATH&lt;/code&gt; の値が &lt;code&gt;:/special/include&lt;/code&gt; の場合、 'と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="c45a725203acab43d85b1db22ebc2d67b4410490" translate="yes" xml:space="preserve">
          <source>In an application, for a function being called once, this attribute saves at least 8 bytes of code; and if other successive calls are being made to the same function, it saves 2 bytes of code per each of these calls.</source>
          <target state="translated">アプリケーションでは、一度だけ呼び出された関数に対して、この属性は少なくとも8バイトのコードを節約します。</target>
        </trans-unit>
        <trans-unit id="112621cd575ed0f9bd039d93d7933cb0a5997ed6" translate="yes" xml:space="preserve">
          <source>In both of these common cases, the program behaves the same as if you had not used the &lt;code&gt;inline&lt;/code&gt; keyword, except for its speed.</source>
          <target state="translated">これらの一般的なケースの両方で、プログラムは速度を除いて、 &lt;code&gt;inline&lt;/code&gt; キーワードを使用しなかった場合と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="45ec19e142c4b27b0fe325e46bb4808fe673f706" translate="yes" xml:space="preserve">
          <source>In calls to a function declared with more than one &lt;code&gt;format_arg&lt;/code&gt; attribute, each with a distinct argument value, the corresponding actual function arguments are checked against all format strings designated by the attributes. This capability is designed to support the GNU &lt;code&gt;ngettext&lt;/code&gt; family of functions.</source>
          <target state="translated">それぞれ異なる引数値を持つ複数の &lt;code&gt;format_arg&lt;/code&gt; 属性で宣言された関数の呼び出しでは、対応する実際の関数引数が、属性で指定されたすべてのフォーマット文字列に対してチェックされます。この機能は、GNU &lt;code&gt;ngettext&lt;/code&gt; ファミリーの関数をサポートするように設計されています。</target>
        </trans-unit>
        <trans-unit id="02aea3bf160a5791ea88be98400d993055dab8e4" translate="yes" xml:space="preserve">
          <source>In case the target&amp;rsquo;s text segment can be made writable at run time by any means, padding the function entry with a number of NOPs can be used to provide a universal tool for instrumentation.</source>
          <target state="translated">ターゲットのテキストセグメントを実行時に何らかの方法で書き込み可能にすることができる場合は、関数エントリにいくつかのNOPを埋め込むことで、汎用のツールを提供できます。</target>
        </trans-unit>
        <trans-unit id="9874bbe3a17ce137014e4f267a820e02a459cd83" translate="yes" xml:space="preserve">
          <source>In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an &lt;code&gt;if&lt;/code&gt; statement with an &lt;code&gt;else&lt;/code&gt; clause, CSE follows the jump when the condition tested is false.</source>
          <target state="translated">共通部分式除去（CSE）では、ジャンプのターゲットが他のパスによって到達されない場合、ジャンプ命令をスキャンします。たとえば、CSEが &lt;code&gt;else&lt;/code&gt; 句のある &lt;code&gt;if&lt;/code&gt; ステートメントを検出すると、テストされた条件がfalseの場合、CSEはジャンプに従います。</target>
        </trans-unit>
        <trans-unit id="0d002f9e5ac95dd6140d2236721894e943a8d321" translate="yes" xml:space="preserve">
          <source>In common with many processors, the R10K tries to predict the outcome of a conditional branch and speculatively executes instructions from the &amp;ldquo;taken&amp;rdquo; branch. It later aborts these instructions if the predicted outcome is wrong. However, on the R10K, even aborted instructions can have side effects.</source>
          <target state="translated">多くのプロセッサと同様に、R10Kは条件付き分岐の結果を予測し、「実行された」分岐からの命令を投機的に実行します。予測された結果が間違っている場合は、後でこれらの指示を中止します。ただし、R10Kでは、中断された命令でも副作用が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="efdf71d142bfbc79dd5b3bcc72b386e56b413dad" translate="yes" xml:space="preserve">
          <source>In conjunction with</source>
          <target state="translated">連携して</target>
        </trans-unit>
        <trans-unit id="55aaa1ae89f88214a90bc2fc53bf852861a0ee3c" translate="yes" xml:space="preserve">
          <source>In conjunction with an option such as</source>
          <target state="translated">のようなオプションと組み合わせて</target>
        </trans-unit>
        <trans-unit id="133d5d5b4d70459f3ec35b8411d0a144d606b9d7" translate="yes" xml:space="preserve">
          <source>In contrast to the use of GP-relative addressing for small data, zero-based addressing is never generated by default and there are no conventional section names used in standard linker scripts for sections in the low or high areas of memory.</source>
          <target state="translated">小規模データにGP相対アドレッシングを使用するのとは対照的に、ゼロベースのアドレッシングはデフォルトでは生成されず、標準リンカースクリプトでは、メモリのローエリアまたはハイエリアのセクションに使用される従来のセクション名はありません。</target>
        </trans-unit>
        <trans-unit id="6c721c449943a687c21935f7f759a9b08f371a66" translate="yes" xml:space="preserve">
          <source>In each case, the &lt;var&gt;value&lt;/var&gt; is an integer. The allowable choices for &lt;var&gt;name&lt;/var&gt; are:</source>
          <target state="translated">いずれの場合も、 &lt;var&gt;value&lt;/var&gt; は整数です。名前に使用できる選択肢は次の &lt;var&gt;name&lt;/var&gt; です。</target>
        </trans-unit>
        <trans-unit id="114b94c6fa09db558271708b17c4b748f9cd7a69" translate="yes" xml:space="preserve">
          <source>In each case, the &lt;var&gt;value&lt;/var&gt; is an integer. The following choices of &lt;var&gt;name&lt;/var&gt; are recognized for all targets:</source>
          <target state="translated">いずれの場合も、 &lt;var&gt;value&lt;/var&gt; は整数です。次の &lt;var&gt;name&lt;/var&gt; 選択肢は、すべてのターゲットで認識されます。</target>
        </trans-unit>
        <trans-unit id="b8fca13e59c9eabf00cc2843d8091a8272a3dfca" translate="yes" xml:space="preserve">
          <source>In extremely rare cases involving some very large functions you may receive errors from the AIX Assembler complaining about a displacement that is too large. If you should run into it, you can work around by making your function smaller.</source>
          <target state="translated">非常に大きな関数を含む非常に稀なケースでは、AIX アセンブラから大きすぎる変位についてのエラーが表示されることがあります。このような場合は、関数を小さくすることで回避することができます。</target>
        </trans-unit>
        <trans-unit id="2aed0db0e41463dc20e3d5ead025ac9ef7859b51" translate="yes" xml:space="preserve">
          <source>In extremely rare cases involving some very large functions you may receive errors from the HP linker complaining about an out of bounds unconditional branch offset. This used to occur more often in previous versions of GCC, but is now exceptionally rare. If you should run into it, you can work around by making your function smaller.</source>
          <target state="translated">いくつかの非常に大きな関数を含む非常に稀なケースでは、HP リンカから境界外の無条件分岐オフセットについてのエラーを受け取ることがあります。これは以前のバージョンのGCCでは頻繁に発生していましたが、現在では例外的に発生しています。このような場合は、関数を小さくすることで回避することができます。</target>
        </trans-unit>
        <trans-unit id="00a48cd8543b2af5e751023419b48f45c985af5f" translate="yes" xml:space="preserve">
          <source>In general, code compiled with</source>
          <target state="translated">一般的に</target>
        </trans-unit>
        <trans-unit id="8355c0879f482055d04fc677fc9eeb1be4e895fa" translate="yes" xml:space="preserve">
          <source>In most cases, these built-in functions are considered a &lt;em&gt;full barrier&lt;/em&gt;. That is, no memory operand is moved across the operation, either forward or backward. Further, instructions are issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.</source>
          <target state="translated">ほとんどの場合、これらの組み込み関数は&lt;em&gt;完全なバリア&lt;/em&gt;と見なされます。つまり、メモリオペランドは、操作の前後に移動されません。さらに、必要に応じて命令が発行され、プロセッサが操作全体の負荷を推測したり、操作後にストアがキューに入れられたりしないようにします。</target>
        </trans-unit>
        <trans-unit id="8dfbf43c73d9e540dd9c54a0b6d437a60ee32ec6" translate="yes" xml:space="preserve">
          <source>In new code it is better to use</source>
          <target state="translated">新しいコードでは</target>
        </trans-unit>
        <trans-unit id="62929241db8cf48751f4d6a5beb9e5db94e0fcf8" translate="yes" xml:space="preserve">
          <source>In order to facilitate indirect jump on devices with more than 128 Ki bytes of program memory space, there is a special function register called &lt;code&gt;EIND&lt;/code&gt; that serves as most significant part of the target address when &lt;code&gt;EICALL&lt;/code&gt; or &lt;code&gt;EIJMP&lt;/code&gt; instructions are used.</source>
          <target state="translated">プログラムメモリ空間が128 Kiバイトを超えるデバイスでの間接ジャンプを容易にするために、 &lt;code&gt;EICALL&lt;/code&gt; または &lt;code&gt;EIJMP&lt;/code&gt; 命令が使用されるときにターゲットアドレスの最も重要な部分として機能する &lt;code&gt;EIND&lt;/code&gt; と呼ばれる特別な関数レジスタがあります。</target>
        </trans-unit>
        <trans-unit id="142019152633ff8b7d8e1d63884c100e78b27ae7" translate="yes" xml:space="preserve">
          <source>In order to get a warning about an unused function parameter, you must either specify</source>
          <target state="translated">未使用の関数パラメータに関する警告を取得するには、以下のいずれかの方法で</target>
        </trans-unit>
        <trans-unit id="c494a40c1966ba85c60ab283de3d77a3dbd352eb" translate="yes" xml:space="preserve">
          <source>In order to get minimal, maximal and default value of a parameter, one can use</source>
          <target state="translated">パラメータの最小値、最大値、デフォルト値を取得するには</target>
        </trans-unit>
        <trans-unit id="aac1d3e632375c3d26f5a99a3c3744709b4cc7cf" translate="yes" xml:space="preserve">
          <source>In order to make it clear that you want the member of the base class, you need to defer lookup until instantiation time, at which the base class is known. For this, you need to access &lt;code&gt;i&lt;/code&gt; in a dependent context, by either using &lt;code&gt;this-&amp;gt;i&lt;/code&gt; (remember that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Derived&amp;lt;T&amp;gt;*&lt;/code&gt;, so is obviously dependent), or using &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt;. Alternatively, &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; might be brought into scope by a &lt;code&gt;using&lt;/code&gt;-declaration.</source>
          <target state="translated">基本クラスのメンバーが必要であることを明確にするために、基本クラスが既知であるインスタンス化時までルックアップを延期する必要があります。このためには、 &lt;code&gt;this-&amp;gt;i&lt;/code&gt; （ &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;Derived&amp;lt;T&amp;gt;*&lt;/code&gt; 型であるため、明らかに依存していることに注意してください）または &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; を使用して、依存コンテキストで &lt;code&gt;i&lt;/code&gt; にアクセスする必要があります。または、 &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; &lt;code&gt;using&lt;/code&gt; -declaration を使用してスコープに含めることもできます。</target>
        </trans-unit>
        <trans-unit id="8d32cad4da98f43c6d843c991432c09408caaf0e" translate="yes" xml:space="preserve">
          <source>In order to preserve backtraces, GCC will never turn calls to &lt;code&gt;noreturn&lt;/code&gt; functions into tail calls.</source>
          <target state="translated">バックトレースを保持するために、GCCは &lt;code&gt;noreturn&lt;/code&gt; 関数の呼び出しをテール呼び出しに変換しません。</target>
        </trans-unit>
        <trans-unit id="8051ea04a019f5cadfa6ef75e3e8fdfb4199ab11" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;_Float128&lt;/code&gt;, &lt;code&gt;__float128&lt;/code&gt;, and &lt;code&gt;__ibm128&lt;/code&gt; on PowerPC Linux systems, you must use the</source>
          <target state="translated">使用するためには &lt;code&gt;_Float128&lt;/code&gt; 、 &lt;code&gt;__float128&lt;/code&gt; 、および &lt;code&gt;__ibm128&lt;/code&gt; を PowerPCのLinuxシステムでは、あなたが使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b53b26d6553c2df239324a926065719ab4a8ddb" translate="yes" xml:space="preserve">
          <source>In other words, this environment variable is equivalent to combining the options</source>
          <target state="translated">言い換えれば、この環境変数は、オプションの</target>
        </trans-unit>
        <trans-unit id="60319e85faea62862eceee65393b98d81d541246" translate="yes" xml:space="preserve">
          <source>In particular, a caller function can inline a callee function only if the architectural features available to the callee are a subset of the features available to the caller. For example: A function &lt;code&gt;foo&lt;/code&gt; compiled with</source>
          <target state="translated">特に、呼び出し元関数は、呼び出し先が利用できるアーキテクチャ機能が呼び出し元が利用できる機能のサブセットである場合にのみ、呼び出し先関数をインライン化できます。例：関数 &lt;code&gt;foo&lt;/code&gt; がしてコンパイル</target>
        </trans-unit>
        <trans-unit id="dfcf3dce47ea75abfa11b8f210c50bb328c92b22" translate="yes" xml:space="preserve">
          <source>In particular, in GNU C &amp;lsquo;</source>
          <target state="translated">特に、GNU Cでは</target>
        </trans-unit>
        <trans-unit id="752fbae7c4ca268deafc3b5be65444a5caccc6bb" translate="yes" xml:space="preserve">
          <source>In particular, the following things, even if they can work in a particular case, are not guaranteed:</source>
          <target state="translated">特に、以下のようなことは、特定のケースでは効果があっても、保証されるものではありません。</target>
        </trans-unit>
        <trans-unit id="fc7e4e23d46d87fd7427f9d533a75885300d9f17" translate="yes" xml:space="preserve">
          <source>In position-dependent code, a few targets also convert calls to functions that are marked to not use the PLT to use the GOT instead.</source>
          <target state="translated">位置依存のコードでは、いくつかのターゲットは、PLT を使用しないようにマークされた関数の呼び出しを、代わりに GOT を使用するように変換します。</target>
        </trans-unit>
        <trans-unit id="689474804d315625babc4fa837c13bb94860852e" translate="yes" xml:space="preserve">
          <source>In processor names, a final &amp;lsquo;</source>
          <target state="translated">プロセッサ名では、最後の '</target>
        </trans-unit>
        <trans-unit id="a2387332e373acd28cba30f5a2036e7dd3dc49b3" translate="yes" xml:space="preserve">
          <source>In situations where a character array is intended to store a sequence of bytes with no terminating &lt;code&gt;NUL&lt;/code&gt; such an array may be annotated with attribute &lt;code&gt;nonstring&lt;/code&gt; to avoid this warning. Such arrays, however, are not suitable arguments to functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings. To help detect accidental misuses of such arrays GCC issues warnings unless it can prove that the use is safe. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">文字配列が &lt;code&gt;NUL&lt;/code&gt; を終了せずにバイトのシーケンスを格納することを目的としている状況では、このような配列は、この警告を回避するために属性 &lt;code&gt;nonstring&lt;/code&gt; で注釈を付けることができます。ただし、そのような配列は、 &lt;code&gt;NUL&lt;/code&gt; で終了する文字列を期待する関数への適切な引数ではありません。そのようなアレイの偶発的な誤用を検出するのを助けるために、GCCは使用が安全であると証明できない限り警告を出します。&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ecfec26cb0ac5a0a1c1e85b523feb3ed95ffb03b" translate="yes" xml:space="preserve">
          <source>In some cases, such as when the &lt;code&gt;packed&lt;/code&gt; attribute is applied to a structure field, it may not be possible to access the field with a single read or write that is correctly aligned for the target machine. In this case GCC falls back to generating multiple accesses rather than code that will fault or truncate the result at run time.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 属性が構造体フィールドに適用される場合など、場合によっては、ターゲットマシンに対して正しく配置された単一の読み取りまたは書き込みでフィールドにアクセスできないことがあります。この場合、GCCはフォールトしたり、実行時に結果を切り捨てたりするコードではなく、複数のアクセスの生成にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="6658650e6720d9733c30a8ad0be8becc792aaec5" translate="yes" xml:space="preserve">
          <source>In some other C compilers, an &lt;code&gt;extern&lt;/code&gt; declaration affects all the rest of the file even if it happens within a block.</source>
          <target state="translated">他の一部のCコンパイラでは、 &lt;code&gt;extern&lt;/code&gt; 宣言は、ブロック内で発生した場合でも、ファイルの残りすべてに影響します。</target>
        </trans-unit>
        <trans-unit id="c8c50a3ca24a6c45c0c4b47ae136e3f0a0a01c74" translate="yes" xml:space="preserve">
          <source>In some places, GCC uses various constants to control the amount of optimization that is done. For example, GCC does not inline functions that contain more than a certain number of instructions. You can control some of these constants on the command line using the</source>
          <target state="translated">いくつかの場所では、GCCは様々な定数を使用して最適化の量を制御しています。例えば、GCC は一定数以上の命令を含む関数をインライン化しません。これらの定数のいくつかは、コマンドラインで</target>
        </trans-unit>
        <trans-unit id="f69acb29f3e047877fe023942587da5b98d97826" translate="yes" xml:space="preserve">
          <source>In standard C, you are not allowed to leave the variable argument out entirely; but you are allowed to pass an empty argument. For example, this invocation is invalid in ISO C, because there is no comma after the string:</source>
          <target state="translated">標準C言語では、変数の引数を完全に省略することはできませんが、空の引数を渡すことはできます。例えば、この呼び出しはISO Cでは文字列の後にカンマがないので無効です。</target>
        </trans-unit>
        <trans-unit id="58989f3f4b9eea02c0ec4c1059a86cfbe8cdb94e" translate="yes" xml:space="preserve">
          <source>In the Alpha architecture, floating-point traps are imprecise. This means without software assistance it is impossible to recover from a floating trap and program execution normally needs to be terminated. GCC can generate code that can assist operating system trap handlers in determining the exact location that caused a floating-point trap. Depending on the requirements of an application, different levels of precisions can be selected:</source>
          <target state="translated">Alphaアーキテクチャでは、浮動小数点トラップは不正確です。これは、ソフトウェアの支援なしでは浮動小数点トラップから回復することが不可能であり、プログラムの実行は通常終了する必要があることを意味します。GCC は、浮動小数点トラップの原因となった正確な場所を特定するために、オペレーティング・システムのトラップ・ハンドラを支援するコードを生成することができます。アプリケーションの要件に応じて、異なるレベルの精度を選択することができます。</target>
        </trans-unit>
        <trans-unit id="6bf5f3b4f4b7b32e9468d2fe59cdb7f94586ed94" translate="yes" xml:space="preserve">
          <source>In the C++ frontend, when printing diagnostics showing mismatching template types, such as:</source>
          <target state="translated">C++フロントエンドでは、テンプレートのタイプが不一致であることを示す診断結果を印刷する際に、以下のような問題がありました。</target>
        </trans-unit>
        <trans-unit id="30e98524998c5d7c58be11e9d977beb07b3f8a4e" translate="yes" xml:space="preserve">
          <source>In the ISO C standard of 1999, a macro can be declared to accept a variable number of arguments much as a function can. The syntax for defining the macro is similar to that of a function. Here is an example:</source>
          <target state="translated">1999 年の ISO C 規格では、関数と同様に、可変数の引数を受け入れるようにマクロを宣言することができます。マクロを定義するための構文は、関数のそれに似ています。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="d2c1baab4661a523e3364f174cd970aa12806955" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;var&gt;n&lt;/var&gt; could be negative, causing a larger than expected argument to be implicitly cast into the &lt;code&gt;alloca&lt;/code&gt; call.</source>
          <target state="translated">上記の例では、 &lt;var&gt;n&lt;/var&gt; が負になる可能性があり、予想よりも大きい引数が &lt;code&gt;alloca&lt;/code&gt; 呼び出しに暗黙的にキャストされます。</target>
        </trans-unit>
        <trans-unit id="23d4340feaa11dd8e5b284a54d802e8107a80100" translate="yes" xml:space="preserve">
          <source>In the above example, four versions of function foo are created. The first version of foo with the target attribute &quot;default&quot; is the default version. This version gets executed when no other target specific version qualifies for execution on a particular platform. A new version of foo is created by using the same function signature but with a different target string. Function foo is called or a pointer to it is taken just like a regular function. GCC takes care of doing the dispatching to call the right version at runtime. Refer to the &lt;a href=&quot;http://gcc.gnu.org/wiki/FunctionMultiVersioning&quot;&gt;GCC wiki on Function Multiversioning&lt;/a&gt; for more details.</source>
          <target state="translated">上記の例では、関数fooの4つのバージョンが作成されます。ターゲット属性が「デフォルト」のfooの最初のバージョンがデフォルトバージョンです。このバージョンは、他のターゲット固有のバージョンが特定のプラットフォームでの実行に適格でない場合に実行されます。fooの新しいバージョンは、同じ関数シグネチャを使用して作成されますが、ターゲット文字列は異なります。関数fooが呼び出されるか、それへのポインタが通常の関数と同じように取得されます。GCCは、実行時に適切なバージョンを呼び出すためのディスパッチを行います。詳細については、&lt;a href=&quot;http://gcc.gnu.org/wiki/FunctionMultiVersioning&quot;&gt;Function MultiversioningのGCC wikiを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a1bff041cccec6e7eb7b11056100ded2af52d7c9" translate="yes" xml:space="preserve">
          <source>In the above example, passing &lt;code&gt;-Walloca-larger-than=1000&lt;/code&gt; would not issue a warning because the call to &lt;code&gt;alloca&lt;/code&gt; is known to be at most 1000 bytes. However, if &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the compiler would emit a warning.</source>
          <target state="translated">上記の例では、 &lt;code&gt;-Walloca-larger-than=1000&lt;/code&gt; を渡しても警告は発行されません。これは、 &lt;code&gt;alloca&lt;/code&gt; の呼び出しが最大で1000バイトであることがわかっているためです。ただし、 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; が渡された場合、コンパイラは警告を発します。</target>
        </trans-unit>
        <trans-unit id="332968dc71142314e45ea6ca9e33a5109f2af711" translate="yes" xml:space="preserve">
          <source>In the absence of the zero-length array extension, in ISO C90 the &lt;code&gt;contents&lt;/code&gt; array in the example above would typically be declared to have a single element. Unlike a zero-length array which only contributes to the size of the enclosing structure for the purposes of alignment, a one-element array always occupies at least as much space as a single object of the type. Although using one-element arrays this way is discouraged, GCC handles accesses to trailing one-element array members analogously to zero-length arrays.</source>
          <target state="translated">長さゼロの配列拡張がない場合、ISO C90 では、上記の例の &lt;code&gt;contents&lt;/code&gt; 配列は通常、単一の要素を持つように宣言されます。配置の目的で囲んでいる構造体のサイズにのみ寄与する長さ0の配列とは異なり、1要素の配列は常に、少なくとも1つの型の単一オブジェクトと同じ大きさのスペースを占有します。この方法で1要素の配列を使用することはお勧めできませんが、GCCは長さ0の配列と同様に、末尾の1要素の配列メンバーへのアクセスを処理します。</target>
        </trans-unit>
        <trans-unit id="c5606a80dd3681d695be85b469a76a47b51736f5" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;fn&lt;/code&gt;, &lt;var&gt;rptr&lt;/var&gt; points to an unaliased integer and &lt;var&gt;rref&lt;/var&gt; refers to a (different) unaliased integer.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; の本体では、 &lt;var&gt;rptr&lt;/var&gt; はエイリアス化されていない整数を指し、 &lt;var&gt;rref&lt;/var&gt; はエイリアス化されていない（異なる）整数を参照します。</target>
        </trans-unit>
        <trans-unit id="72adaffc52e227090554b141dc851c2ba2acd228" translate="yes" xml:space="preserve">
          <source>In the call to &lt;code&gt;f1&lt;/code&gt; inside &lt;code&gt;f2&lt;/code&gt;, the pointer &lt;code&gt;p&lt;/code&gt; is converted into a pointer to the anonymous field.</source>
          <target state="translated">&lt;code&gt;f2&lt;/code&gt; 内の &lt;code&gt;f1&lt;/code&gt; の呼び出しでは、ポインター &lt;code&gt;p&lt;/code&gt; が匿名フィールドへのポインターに変換されます。</target>
        </trans-unit>
        <trans-unit id="0a8054866654e30e64690afd790ea604bf91b2c2" translate="yes" xml:space="preserve">
          <source>In the case of mixed tabs and spaces, the warning uses the</source>
          <target state="translated">タブとスペースが混在している場合、警告は</target>
        </trans-unit>
        <trans-unit id="ad595b872596498a83b3124d23704c11425d8f05" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;section&lt;/code&gt; attribute, the section name given will be used, and the &lt;code&gt;.lower&lt;/code&gt; prefix will not be added.</source>
          <target state="translated">&lt;code&gt;section&lt;/code&gt; 属性の場合、指定されたセクション名が使用され、 &lt;code&gt;.lower&lt;/code&gt; プレフィックスは追加されません。</target>
        </trans-unit>
        <trans-unit id="668ede8f3b6b3725bfdad3d893282dd8102b4a7b" translate="yes" xml:space="preserve">
          <source>In the example above, if the size of each &lt;code&gt;short&lt;/code&gt; is 2 bytes, then the size of the entire &lt;code&gt;struct S&lt;/code&gt; type is 6 bytes. The smallest power of two that is greater than or equal to that is 8, so the compiler sets the alignment for the entire &lt;code&gt;struct S&lt;/code&gt; type to 8 bytes.</source>
          <target state="translated">上記の例では、各 &lt;code&gt;short&lt;/code&gt; のサイズが2バイトの場合、 &lt;code&gt;struct S&lt;/code&gt; タイプ全体のサイズは6バイトです。それ以上の最小の2のべき乗は8なので、コンパイラーは &lt;code&gt;struct S&lt;/code&gt; タイプ全体のアライメントを8バイトに設定します。</target>
        </trans-unit>
        <trans-unit id="d611872451077c2adcf065d60aa97d23e192a616" translate="yes" xml:space="preserve">
          <source>In the example above, the format string (&lt;code&gt;my_format&lt;/code&gt;) is the second argument of the function &lt;code&gt;my_print&lt;/code&gt;, and the arguments to check start with the third argument, so the correct parameters for the format attribute are 2 and 3.</source>
          <target state="translated">上記の例では、フォーマット文字列（ &lt;code&gt;my_format&lt;/code&gt; ）は関数 &lt;code&gt;my_print&lt;/code&gt; の 2番目の引数であり、チェックする引数は3番目の引数から始まるため、format属性の正しいパラメーターは2および3です。</target>
        </trans-unit>
        <trans-unit id="c81e2f387793e8f74907d44b15263e2ac578ba9c" translate="yes" xml:space="preserve">
          <source>In the following example 2 bytes are saved for each call to function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">次の例では、関数 &lt;code&gt;foo&lt;/code&gt; の呼び出しごとに2バイトが保存されます。</target>
        </trans-unit>
        <trans-unit id="f2582be090e1c1dbe5968b20143ec726da1f7d9e" translate="yes" xml:space="preserve">
          <source>In the following example &lt;code&gt;struct my_packed_struct&lt;/code&gt;&amp;rsquo;s members are packed closely together, but the internal layout of its &lt;code&gt;s&lt;/code&gt; member is not packed&amp;mdash;to do that, &lt;code&gt;struct my_unpacked_struct&lt;/code&gt; needs to be packed too.</source>
          <target state="translated">次の例では、 &lt;code&gt;struct my_packed_struct&lt;/code&gt; のメンバーは密にパックされていますが、その &lt;code&gt;s&lt;/code&gt; メンバーの内部レイアウトはパックされていません。これを行うには、 &lt;code&gt;struct my_unpacked_struct&lt;/code&gt; もパックする必要があります。</target>
        </trans-unit>
        <trans-unit id="2ad9bba785d38d1a703efec0ed08be1c07a3d9c1" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;A&lt;/code&gt; would normally be created before &lt;code&gt;B&lt;/code&gt;, but the &lt;code&gt;init_priority&lt;/code&gt; attribute reverses that order:</source>
          <target state="translated">次の例では、 &lt;code&gt;A&lt;/code&gt; は通常 &lt;code&gt;B&lt;/code&gt; の前に作成されますが、 &lt;code&gt;init_priority&lt;/code&gt; 属性はその順序を逆にします。</target>
        </trans-unit>
        <trans-unit id="eab6b57c27507ae55bdb9c6e5a0691baa5974d49" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &amp;ldquo;bar&amp;rdquo; is misleadingly indented as if it were guarded by the &amp;ldquo;if&amp;rdquo; conditional.</source>
          <target state="translated">次の例では、「bar」の呼び出しは、「if」条件によって保護されているかのように誤解を招くようにインデントされています。</target>
        </trans-unit>
        <trans-unit id="5d55b7c384eed91ea4e21f8b8e99933dea2beab9" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &lt;code&gt;strncat&lt;/code&gt; specifies a bound that is less than the length of the source string. As a result, the copy of the source will be truncated and so the call is diagnosed. To avoid the warning use &lt;code&gt;bufsize - strlen (buf) - 1)&lt;/code&gt; as the bound.</source>
          <target state="translated">次の例では、 &lt;code&gt;strncat&lt;/code&gt; の呼び出しで、ソース文字列の長さより短い境界を指定しています。その結果、ソースのコピーが切り捨てられるため、呼び出しが診断されます。警告を回避するには、境界として &lt;code&gt;bufsize - strlen (buf) - 1)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="99023364872044963c7ac2454f86695e7bf39529" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &lt;code&gt;strncpy&lt;/code&gt; specifies the size of the destination buffer as the bound. If the length of the source string is equal to or greater than this size the result of the copy will not be NUL-terminated. Therefore, the call is also diagnosed. To avoid the warning, specify &lt;code&gt;sizeof buf - 1&lt;/code&gt; as the bound and set the last element of the buffer to &lt;code&gt;NUL&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;strncpy&lt;/code&gt; の呼び出しで、宛先バッファーのサイズを境界として指定しています。ソース文字列の長さがこのサイズ以上の場合、コピーの結果はNULで終了しません。したがって、コールも診断されます。警告を回避するには、バウンドとして &lt;code&gt;sizeof buf - 1&lt;/code&gt; を指定し、バッファの最後の要素を &lt;code&gt;NUL&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="b2205cf9915c94cb78e3ab81cd7cb0eabf600a0e" translate="yes" xml:space="preserve">
          <source>In the following example, the optimization info is output to</source>
          <target state="translated">次の例では、最適化情報が</target>
        </trans-unit>
        <trans-unit id="090624bc5f542a6200f2b5db31c7a96042440439" translate="yes" xml:space="preserve">
          <source>In the future, GCC may ignore all longcall specifications when the linker is known to generate glue.</source>
          <target state="translated">将来的には、リンカがグルーを生成することがわかっている場合、GCCはすべてのロングコール仕様を無視する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b65ba979b01328e9229388df23c21da9df9f6b9" translate="yes" xml:space="preserve">
          <source>In the past, the GNU C++ compiler was extended to experiment with new features, at a time when the C++ language was still evolving. Now that the C++ standard is complete, some of those features are superseded by superior alternatives. Using the old features might cause a warning in some cases that the feature will be dropped in the future. In other cases, the feature might be gone already.</source>
          <target state="translated">過去には、C++言語がまだ進化していた時期に、GNU C++コンパイラは新しい機能を試すために拡張されました。C++標準が完成した今、それらの機能のいくつかは優れた代替機能に取って代わられています。古い機能を使用すると、場合によっては、その機能が将来的に削除されるという警告が表示されることがあります。他のケースでは、その機能はすでになくなっているかもしれません。</target>
        </trans-unit>
        <trans-unit id="2ec007d1b8fb8c7647c245995b76441efba1c6d6" translate="yes" xml:space="preserve">
          <source>In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before std::terminate() is called (C++98 15.5.1).</source>
          <target state="translated">一致するハンドラが見つからない場合、std::terminate()が呼び出される前にスタックを巻き戻すかどうかは実装で定義されています(C++98 15.5.1)。</target>
        </trans-unit>
        <trans-unit id="2b3b9b011b7a600b4b0a236d7a6052525d44af3c" translate="yes" xml:space="preserve">
          <source>In the x86-64 compiler,</source>
          <target state="translated">x86-64 コンパイラでは。</target>
        </trans-unit>
        <trans-unit id="69fa1e0803241118d47ffd49449baa41bc17a296" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;PRId64&lt;/code&gt; is treated as a separate preprocessing token.</source>
          <target state="translated">この場合、 &lt;code&gt;PRId64&lt;/code&gt; は別個の前処理トークンとして扱われます。</target>
        </trans-unit>
        <trans-unit id="5e608c39601145b6331e6e0d1f6c70cd4fe12595" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;C::C&lt;/code&gt; is exported from the current DLL, but the virtual table for &lt;code&gt;C&lt;/code&gt; is not exported. (You can use &lt;code&gt;__attribute__&lt;/code&gt; instead of &lt;code&gt;__declspec&lt;/code&gt; if you prefer, but most Symbian OS code uses &lt;code&gt;__declspec&lt;/code&gt;.)</source>
          <target state="translated">このコードでは、 &lt;code&gt;C::C&lt;/code&gt; は現在のDLLからエクスポートされますが、 &lt;code&gt;C&lt;/code&gt; の仮想テーブルはエクスポートされません。（必要に応じて、 &lt;code&gt;__declspec&lt;/code&gt; の代わりに &lt;code&gt;__attribute__&lt;/code&gt; を使用できますが、ほとんどのSymbian OSコードは &lt;code&gt;__declspec&lt;/code&gt; を使用します。）</target>
        </trans-unit>
        <trans-unit id="cf74d98117e616fffd8931f1489225a69f862b46" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;target(&quot;+crc+nocrypto&quot;)&lt;/code&gt; enables the &lt;code&gt;crc&lt;/code&gt; extension and disables the &lt;code&gt;crypto&lt;/code&gt; extension for the function &lt;code&gt;foo&lt;/code&gt; without modifying an existing</source>
          <target state="translated">この例では、 &lt;code&gt;target(&quot;+crc+nocrypto&quot;)&lt;/code&gt; は、既存のファイルを変更せずに、関数 &lt;code&gt;foo&lt;/code&gt; の &lt;code&gt;crc&lt;/code&gt; 拡張を有効にし、 &lt;code&gt;crypto&lt;/code&gt; 拡張を無効にします。</target>
        </trans-unit>
        <trans-unit id="58a4adc7d0429a642a388d8bfe0b7fe702edd6d4" translate="yes" xml:space="preserve">
          <source>In this example using the fictitious &lt;code&gt;combine&lt;/code&gt; instruction, the constraint &lt;code&gt;&quot;0&quot;&lt;/code&gt; for input operand 1 says that it must occupy the same location as output operand 0. Only input operands may use numbers in constraints, and they must each refer to an output operand. Only a number (or the symbolic assembler name) in the constraint can guarantee that one operand is in the same place as another. The mere fact that &lt;code&gt;foo&lt;/code&gt; is the value of both operands is not enough to guarantee that they are in the same place in the generated assembler code.</source>
          <target state="translated">架空の &lt;code&gt;combine&lt;/code&gt; 命令を使用するこの例では、入力オペランド1 の制約 &lt;code&gt;&quot;0&quot;&lt;/code&gt; は、出力オペランド0と同じ場所を占める必要があることを示しています。制約で数値を使用できるのは入力オペランドのみであり、それぞれが出力オペランドを参照する必要があります。制約内の数値（またはシンボリックアセンブラ名）のみが、あるオペランドが別のオペランドと同じ場所にあることを保証できます。 &lt;code&gt;foo&lt;/code&gt; が両方のオペランドの値であるという単なる事実だけでは、生成されたアセンブラコード内で同じ場所にあることを保証するには不十分です。</target>
        </trans-unit>
        <trans-unit id="520980bd6ea541d3639c3a33ef889a8d9a6daa19" translate="yes" xml:space="preserve">
          <source>In this example,</source>
          <target state="translated">この例では</target>
        </trans-unit>
        <trans-unit id="319dc8c090a6daef3a9c5df24c2d9cdc65374743" translate="yes" xml:space="preserve">
          <source>In this example, copy elision isn&amp;rsquo;t applicable because the type of the expression being returned and the function return type differ, yet G++ treats the return value as if it were designated by an rvalue.</source>
          <target state="translated">この例では、返される式のタイプと関数の戻り値のタイプが異なるため、コピー省略は適用できませんが、G ++は戻り値を右辺値で指定されているものとして扱います。</target>
        </trans-unit>
        <trans-unit id="4e8bd971ddd095859a278a42bd750e7f78bf378c" translate="yes" xml:space="preserve">
          <source>In this example, only</source>
          <target state="translated">この例では</target>
        </trans-unit>
        <trans-unit id="9d08184dfe71cd797666be2ee4c2240b6d577d4d" translate="yes" xml:space="preserve">
          <source>In this example, the definition of X as 1 is saved by &lt;code&gt;#pragma
push_macro&lt;/code&gt; and restored by &lt;code&gt;#pragma pop_macro&lt;/code&gt;.</source>
          <target state="translated">この例では、Xの1としての定義は &lt;code&gt;#pragma push_macro&lt;/code&gt; によって保存され、 &lt;code&gt;#pragma pop_macro&lt;/code&gt; によって復元されます。</target>
        </trans-unit>
        <trans-unit id="21ecdc81f33fba4861729ef952b0d8145291cd18" translate="yes" xml:space="preserve">
          <source>In this example, the initialization of &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; in &lt;code&gt;+initialize&lt;/code&gt; occurs too late. The programmer can send a message to one of these objects before the variables are actually initialized, thus sending messages to the &lt;code&gt;nil&lt;/code&gt; object. The &lt;code&gt;+initialize&lt;/code&gt; method which actually initializes the global variables is not invoked until the first message is sent to the class object. The solution would require these variables to be initialized just before entering &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;+initialize&lt;/code&gt; での &lt;code&gt;Stdin&lt;/code&gt; 、 &lt;code&gt;Stdout&lt;/code&gt; 、および &lt;code&gt;Stderr&lt;/code&gt; の初期化が遅すぎます。プログラマは、変数が実際に初期化される前に、これらのオブジェクトの1つにメッセージを送信して、 &lt;code&gt;nil&lt;/code&gt; オブジェクトにメッセージを送信できます。 &lt;code&gt;+initialize&lt;/code&gt; 最初のメッセージをクラスオブジェクトに送信されるまで、実際のグローバル変数を初期化するメソッドが呼び出されていません。このソリューションでは、これらの変数を &lt;code&gt;main&lt;/code&gt; に入る直前に初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="9aaba03579077debce898734e55c1aab4715c942" translate="yes" xml:space="preserve">
          <source>In this example, using the &lt;code&gt;restrict&lt;/code&gt; qualifier had the same effect. In the following example, that would not be possible. Assume &lt;em&gt;k &amp;lt; -m&lt;/em&gt; or &lt;em&gt;k &amp;gt;= m&lt;/em&gt;. Only with the pragma, the compiler knows that it can unconditionally vectorize the following loop:</source>
          <target state="translated">この例では、 &lt;code&gt;restrict&lt;/code&gt; 修飾子を使用しても同じ効果がありました。次の例では、それは不可能です。&lt;em&gt;k &amp;lt;-m&lt;/em&gt;または&lt;em&gt;k&amp;gt; = m&lt;/em&gt;と仮定します。プラグマを使用する場合のみ、コンパイラーは次のループを無条件にベクトル化できることを認識します。</target>
        </trans-unit>
        <trans-unit id="faacd98f76b275362fdf70ef063e37d5684ab5f2" translate="yes" xml:space="preserve">
          <source>In this example, you are able to access members of the unnamed union with code like &amp;lsquo;</source>
          <target state="translated">この例では、名前のない共用体のメンバーに 'のようなコードでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="11ec4b5f708bff6df3841d797062db8a50e96ffa" translate="yes" xml:space="preserve">
          <source>In this i386 example, &lt;code&gt;old&lt;/code&gt; (referred to in the template string as &lt;code&gt;%0&lt;/code&gt;) and &lt;code&gt;*Base&lt;/code&gt; (as &lt;code&gt;%1&lt;/code&gt;) are outputs and &lt;code&gt;Offset&lt;/code&gt; (&lt;code&gt;%2&lt;/code&gt;) is an input:</source>
          <target state="translated">このi386の例では、 &lt;code&gt;old&lt;/code&gt; （テンプレート文字列では &lt;code&gt;%0&lt;/code&gt; と呼ばれます）および &lt;code&gt;*Base&lt;/code&gt; （ &lt;code&gt;%1&lt;/code&gt; として）が出力で、 &lt;code&gt;Offset&lt;/code&gt; （ &lt;code&gt;%2&lt;/code&gt; ）が入力です。</target>
        </trans-unit>
        <trans-unit id="baf1ef107e11e79f68ce627953735497e89d197f" translate="yes" xml:space="preserve">
          <source>In this mode, each basic block is only shown on one line &amp;ndash; the last line of the block. A multi-line block will only contribute to the execution count of that last line, and other lines will not be shown to contain code, unless previous blocks end on those lines. The total execution count of a line is shown and subsequent lines show the execution counts for individual blocks that end on that line. After each block, the branch and call counts of the block will be shown, if the</source>
          <target state="translated">このモードでは、各基本ブロックは1行（ブロックの最終行）にのみ表示されます。複数行のブロックはその最後の行の実行カウントにのみ寄与し、他の行は、前のブロックがそれらの行で終了しない限り、コードを含むことが示されません。行の合計実行数が表示され、後続の行はその行で終了する個々のブロックの実行数を示します。各ブロックの後に、ブロックの分岐数と呼び出し数が表示されます。</target>
        </trans-unit>
        <trans-unit id="f98f506a6c9d396979e78ddb03cc339a44caf644" translate="yes" xml:space="preserve">
          <source>In this simple case, the ability to omit the middle operand is not especially useful. When it becomes useful is when the first operand does, or may (if it is a macro argument), contain a side effect. Then repeating the operand in the middle would perform the side effect twice. Omitting the middle operand uses the value already computed without the undesirable effects of recomputing it.</source>
          <target state="translated">この単純なケースでは、中間のオペランドを省略する機能は特に有用ではありません。これが有用になるのは、最初のオペランドに副作用が含まれている場合、または(マクロ引数の場合)副作用が含まれている可能性がある場合です。その場合、中間のオペランドを繰り返すことで、副作用を2回実行することになります。中間のオペランドを省略することで、すでに計算された値を再計算することなく使用することができます。</target>
        </trans-unit>
        <trans-unit id="30850ac01d9d951fde54525545edac5180129639" translate="yes" xml:space="preserve">
          <source>In this situation, it may seem reasonable to save a pointer to the C string returned by the &lt;code&gt;c_str&lt;/code&gt; member function and use that rather than call &lt;code&gt;c_str&lt;/code&gt; repeatedly. However, the temporary string created by the call to &lt;code&gt;strfunc&lt;/code&gt; is destroyed after &lt;code&gt;p&lt;/code&gt; is initialized, at which point &lt;code&gt;p&lt;/code&gt; is left pointing to freed memory.</source>
          <target state="translated">この状況では、 &lt;code&gt;c_str&lt;/code&gt; メンバー関数によって返されたC文字列へのポインターを保存し、 &lt;code&gt;c_str&lt;/code&gt; を繰り返し呼び出すのではなく、それを使用するのが理にかなっているように見えるかもしれません。ただし、 &lt;code&gt;strfunc&lt;/code&gt; の呼び出しによって作成された一時的な文字列は、 &lt;code&gt;p&lt;/code&gt; が初期化された後に破棄されます。この時点で、 &lt;code&gt;p&lt;/code&gt; は解放されたメモリを指したままになります。</target>
        </trans-unit>
        <trans-unit id="9c79c74c33310ccb6338d0595028b7084d9d04e6" translate="yes" xml:space="preserve">
          <source>In traditional C, some preprocessor directives did not exist. Traditional preprocessors only considered a line to be a directive if the &amp;lsquo;</source>
          <target state="translated">従来のCでは、一部のプリプロセッサディレクティブは存在しませんでした。従来のプリプロセッサは、 '</target>
        </trans-unit>
        <trans-unit id="af6d48f148638b92ad84fcdf9e5cab97ac9e3711" translate="yes" xml:space="preserve">
          <source>In traditional C, you can combine &lt;code&gt;long&lt;/code&gt;, etc., with a typedef name, as shown here:</source>
          <target state="translated">従来のCでは、次に示すように、 &lt;code&gt;long&lt;/code&gt; などをtypedef名と組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="337c46940ff663b0e38af630f4ae21daa389738f" translate="yes" xml:space="preserve">
          <source>Include path specified with &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-I&lt;/code&gt; および &lt;code&gt;-L&lt;/code&gt; で指定されたパスを含める</target>
        </trans-unit>
        <trans-unit id="a6cc27c788d1407147380009a18cb3a8d2d00752" translate="yes" xml:space="preserve">
          <source>Includes by default</source>
          <target state="translated">デフォルトでインクルード</target>
        </trans-unit>
        <trans-unit id="ba953d2d262b9f5a9a993ae297fa4814ea4c549d" translate="yes" xml:space="preserve">
          <source>Increase the minimum alignment of each &lt;var&gt;variable&lt;/var&gt; to &lt;var&gt;alignment&lt;/var&gt;. This is the same as GCC&amp;rsquo;s &lt;code&gt;aligned&lt;/code&gt; attribute see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;). Macro expansion occurs on the arguments to this pragma when compiling C and Objective-C. It does not currently occur when compiling C++, but this is a bug which may be fixed in a future release.</source>
          <target state="translated">それぞれの最小整列増加 &lt;var&gt;variable&lt;/var&gt; に &lt;var&gt;alignment&lt;/var&gt; 。これは、GCCの &lt;code&gt;aligned&lt;/code&gt; 属性と同じです。&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数の属性を&lt;/a&gt;参照してください）。CおよびObjective-Cのコンパイル時に、このプラグマの引数でマクロ展開が発生します。現在、C ++のコンパイル時には発生しませんが、これは将来のリリースで修正される可能性があるバグです。</target>
        </trans-unit>
        <trans-unit id="3a36ae001267163487813c67072e72529ac1fc44" translate="yes" xml:space="preserve">
          <source>Increment the current shadow stack pointer by the size specified by the function argument. The argument is masked to a byte value for security reasons, so to increment by more than 255 bytes you must call the function multiple times.</source>
          <target state="translated">現在のシャドウスタックポインタを関数の引数で指定されたサイズだけインクリメントします。セキュリティ上の理由から、引数はバイト値にマスクされているため、255バイト以上インクリメントするには、この関数を複数回呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a77ff871b762622ee18fb03c8d6e4821448c4ba7" translate="yes" xml:space="preserve">
          <source>Index of concepts and symbol names.</source>
          <target state="translated">概念と記号名の索引。</target>
        </trans-unit>
        <trans-unit id="fc043d0a8b4563d771d031e44dbc955b74387769" translate="yes" xml:space="preserve">
          <source>Index to command line options.</source>
          <target state="translated">コマンドラインオプションのインデックス。</target>
        </trans-unit>
        <trans-unit id="420ef9e906b8f54c4b93394265974a605cf160bb" translate="yes" xml:space="preserve">
          <source>Indicate target register priority for r0..r3 / r12..r15.</source>
          <target state="translated">r0...r3/r12...r15 のターゲット・レジスタの優先度を表示します。</target>
        </trans-unit>
        <trans-unit id="d7462beabb9f4e989c2289174fc3246820893fad" translate="yes" xml:space="preserve">
          <source>Indicate to the linker that it should perform a relaxation optimization pass to shorten branches, calls and absolute memory addresses. This option only has an effect when used on the command line for the final link step.</source>
          <target state="translated">リンカに、分岐、呼び出し、およびアブソリュート・メモリ・アドレスを短縮するための緩和最適化パスを実行することを指示します。このオプションは、最終リンクステップのコマンドラインで使用された場合にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="6fbdf91a468c725e57cb1a980eb023240915fbde" translate="yes" xml:space="preserve">
          <source>Indicate to the preprocessor that the input file has already been preprocessed. This suppresses things like macro expansion, trigraph conversion, escaped newline splicing, and processing of most directives. The preprocessor still recognizes and removes comments, so that you can pass a file preprocessed with</source>
          <target state="translated">入力ファイルが既に前処理されていることをプリプロセッサに示します。これは、マクロの展開、トリグラフの変換、エスケープされた改行のスプライシング、 ほとんどのディレクティブの処理などを抑制します。プリプロセッサはコメントを認識して削除します。</target>
        </trans-unit>
        <trans-unit id="68073a6ddfa5de56b268fec01a6e6dd0d5ff13eb" translate="yes" xml:space="preserve">
          <source>Indicate whether GCC should generate code to use the optional BWX, CIX, FIX and MAX instruction sets. The default is to use the instruction sets supported by the CPU type specified via</source>
          <target state="translated">オプションのBWX、CIX、FIX、およびMAX命令セットを使用するコードをGCCが生成するかどうかを指定します。デフォルトでは</target>
        </trans-unit>
        <trans-unit id="be40fe5ecac7625ba1093b2709ac8dc3be8fddd9" translate="yes" xml:space="preserve">
          <source>Indicates that code should be generated for a particular code model for this function. The behavior and permissible arguments are the same as for the command line option</source>
          <target state="translated">この関数の特定のコードモデルに対してコードを生成することを示します。挙動と許容される引数は、コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="b7d51ac61701200efc681b006d913292e4425e50" translate="yes" xml:space="preserve">
          <source>Indicates that no floating-point or Advanced SIMD registers should be used when generating code for this function. If the function explicitly uses floating-point code, then the compiler gives an error. This is the same behavior as that of the command-line option</source>
          <target state="translated">この関数のコードを生成する際に浮動小数点レジスタまたは高度な SIMD レジスタを使用しないことを示します。関数が明示的に浮動小数点コードを使用している場合、コンパイラはエラーを返します。これは、コマンドライン・オプション</target>
        </trans-unit>
        <trans-unit id="96da1f4a760883d4e09985b3e134953d179eb7dd" translate="yes" xml:space="preserve">
          <source>Indicates that the frame pointer should be omitted for a leaf function call. To keep the frame pointer, the inverse attribute &lt;code&gt;no-omit-leaf-frame-pointer&lt;/code&gt; can be specified. These attributes have the same behavior as the command-line options</source>
          <target state="translated">リーフ関数呼び出しでフレームポインターを省略すべきことを示します。フレームポインターを保持するには、逆属性 &lt;code&gt;no-omit-leaf-frame-pointer&lt;/code&gt; を指定できます。これらの属性は、コマンドラインオプションと同じ動作をします</target>
        </trans-unit>
        <trans-unit id="fee4cd3e78cab50081b4e8f5d0006d9ed8234377" translate="yes" xml:space="preserve">
          <source>Indicates that the workaround for the Cortex-A53 erratum 835769 should be applied to this function. To explicitly disable the workaround for this function specify the negated form: &lt;code&gt;no-fix-cortex-a53-835769&lt;/code&gt;. This corresponds to the behavior of the command line options</source>
          <target state="translated">Cortex-A53 erratum 835769の回避策をこの関数に適用する必要があることを示します。この関数の回避策を明示的に無効にするには、否定形式 &lt;code&gt;no-fix-cortex-a53-835769&lt;/code&gt; を指定します。これはコマンドラインオプションの動作に対応します</target>
        </trans-unit>
        <trans-unit id="aeccc2135e57d183072ddb1eb0451783b85ba84e" translate="yes" xml:space="preserve">
          <source>Indicates that there is no OS function for flushing the cache.</source>
          <target state="translated">キャッシュをフラッシュするための OS 機能がないことを示します。</target>
        </trans-unit>
        <trans-unit id="3b9239fee5592f778e9dc693d4e38e7027710f85" translate="yes" xml:space="preserve">
          <source>Indirect functions cannot be weak. Binutils version 2.20.1 or higher and GNU C Library version 2.11.1 are required to use this feature.</source>
          <target state="translated">間接関数を弱くすることはできません。この機能を利用するには、Binutils のバージョン 2.20.1 以降と GNU C ライブラリのバージョン 2.11.1 が必要です。</target>
        </trans-unit>
        <trans-unit id="0a81ae1d4de3c814c6c4d2e18a5c858ca409fcdb" translate="yes" xml:space="preserve">
          <source>Indirect jumps and calls on these devices are handled as follows by the compiler and are subject to some limitations:</source>
          <target state="translated">これらのデバイスへの間接的なジャンプや呼び出しは、コンパイラによって以下のように処理され、いくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="9f398b6aa8bfe6a67d6b37c29d0d17a413b5679b" translate="yes" xml:space="preserve">
          <source>Inefficiency: because of both the modified allocation strategy and the generic implementation, code performance is hampered.</source>
          <target state="translated">非効率:修正された割り当て戦略と一般的な実装の両方のため、コードのパフォーマンスが妨げられます。</target>
        </trans-unit>
        <trans-unit id="102a9633450074424f655c619be378c7b15f449d" translate="yes" xml:space="preserve">
          <source>Inform the compiler that the assembler supports &lt;code&gt;.loc&lt;/code&gt; directives. It may then use them for the assembler to generate DWARF2+ line number tables.</source>
          <target state="translated">アセンブラが &lt;code&gt;.loc&lt;/code&gt; ディレクティブをサポートすることをコンパイラに通知します。次に、それらをアセンブラーに使用して、DWARF2 +行番号テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="25aeb41e0e10d4686e4fd03645c7ee0ccf628c50" translate="yes" xml:space="preserve">
          <source>Inform the compiler that the assembler supports &lt;code&gt;view&lt;/code&gt; assignment and reset assertion checking in &lt;code&gt;.loc&lt;/code&gt; directives.</source>
          <target state="translated">アセンブラが &lt;code&gt;.loc&lt;/code&gt; ディレクティブの &lt;code&gt;view&lt;/code&gt; 割り当てとリセットアサーションチェックをサポートすることをコンパイラに通知します。</target>
        </trans-unit>
        <trans-unit id="b50c3134100dc83deb9c57710a2383b61f03ab15" translate="yes" xml:space="preserve">
          <source>Inhibit all warning messages.</source>
          <target state="translated">すべての警告メッセージを禁止します。</target>
        </trans-unit>
        <trans-unit id="080f1e9a6e2cab41869cd5a7281f008e51e71667" translate="yes" xml:space="preserve">
          <source>Inhibit generation of linemarkers in the output from the preprocessor. This might be useful when running the preprocessor on something that is not C code, and will be sent to a program which might be confused by the linemarkers.</source>
          <target state="translated">プリプロセッサからの出力におけるラインマーカーの生成を禁止します。これは、Cコードではないものでプリプロセッサを実行している場合に便利で、ラインマーカーによって混乱する可能性のあるプログラムに送信されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="fa7703731fa04f07d423f5b7d1cd54384f1143c1" translate="yes" xml:space="preserve">
          <source>Initialization of automatic aggregates.</source>
          <target state="translated">自動集計の初期化。</target>
        </trans-unit>
        <trans-unit id="11b16505aae7a8cef6f4bca8519967cba1c19746" translate="yes" xml:space="preserve">
          <source>Initialization of unions. If the initializer is zero, the warning is omitted. This is done under the assumption that the zero initializer in user code appears conditioned on e.g. &lt;code&gt;__STDC__&lt;/code&gt; to avoid missing initializer warnings and relies on default initialization to zero in the traditional C case.</source>
          <target state="translated">労働組合の初期化。初期化子がゼロの場合、警告は省略されます。これは、ユーザーコードのゼロ初期化子が &lt;code&gt;__STDC__&lt;/code&gt; などの条件付きで表示され、初期化子の警告の欠落を回避し、従来のCの場合のゼロへのデフォルト初期化に依存しているという仮定の下で行われます。</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="20eedc8fe9e9a35e534ae1ecdbec914e536d314f" translate="yes" xml:space="preserve">
          <source>Inline all block moves (such as calls to &lt;code&gt;memcpy&lt;/code&gt; or structure copies) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. The minimum value for &lt;var&gt;num&lt;/var&gt; is 32 bytes on 32-bit targets and 64 bytes on 64-bit targets. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; バイト以下のすべてのブロック移動（ &lt;code&gt;memcpy&lt;/code&gt; や構造体コピーの呼び出しなど）をインライン化します。 &lt;var&gt;num&lt;/var&gt; の最小値は、32ビットターゲットでは32バイト、64ビットターゲットでは64バイトです。デフォルト値はターゲット固有です。</target>
        </trans-unit>
        <trans-unit id="19b0a018d37cfb0b1d0545d49bb366c506acf3ce" translate="yes" xml:space="preserve">
          <source>Inline also indirect calls that are discovered to be known at compile time thanks to previous inlining. This option has any effect only when inlining itself is turned on by the</source>
          <target state="translated">以前のインライン化のおかげでコンパイル時に判明した間接的な呼び出しもインライン化します。このオプションは、インライン化自体が</target>
        </trans-unit>
        <trans-unit id="fafe5cb70796ac6434a1aca1419cbd95d727be6c" translate="yes" xml:space="preserve">
          <source>Inline assembler with operands.</source>
          <target state="translated">オペランドを持つインラインアセンブラです。</target>
        </trans-unit>
        <trans-unit id="14e6ac3d090072cf48a1a85932e7b4359138b15c" translate="yes" xml:space="preserve">
          <source>Inline assembler without operands.</source>
          <target state="translated">オペランドのないインラインアセンブラです。</target>
        </trans-unit>
        <trans-unit id="894882df2e980808e76bd468c0679a5b444a90d9" translate="yes" xml:space="preserve">
          <source>Inline code to invalidate instruction cache entries after setting up nested function trampolines. This option has no effect if</source>
          <target state="translated">入れ子になった関数トランポリンを設定した後に命令キャッシュエントリを無効にするインラインコード。このオプションは</target>
        </trans-unit>
        <trans-unit id="f4aac95ae4ed684541a98bc144426b8b8c5823e2" translate="yes" xml:space="preserve">
          <source>Inline constants into the code stream if it can be done in two instructions or less.</source>
          <target state="translated">2命令以下でできる場合は、コードストリームにインライン定数を入れます。</target>
        </trans-unit>
        <trans-unit id="116dec339b590ba4e7b045ac4254203eac5168bf" translate="yes" xml:space="preserve">
          <source>Inline functions are typically defined in a header file which can be included in many different compilations. Hopefully they can usually be inlined, but sometimes an out-of-line copy is necessary, if the address of the function is taken or if inlining fails. In general, we emit an out-of-line copy in all translation units where one is needed. As an exception, we only emit inline virtual functions with the vtable, since it always requires a copy.</source>
          <target state="translated">インライン関数は一般的にヘッダファイルで定義されており、多くの異なるコンパイルに含めることができます。うまくいけば、通常はインライン化できますが、関数のアドレスが取られていたり、インライン化に失敗した場合には、行外コピーが必要になることもあります。一般的に、行外コピーが必要な場合は、すべての翻訳ユニットで行外コピーを出力します。例外として、インラインの仮想関数は常にコピーが必要なので、vtableでのみエミットします。</target>
        </trans-unit>
        <trans-unit id="91795d77f30dd9a95fe0227642128a77b706a436" translate="yes" xml:space="preserve">
          <source>Inline functions marked by &lt;code&gt;always_inline&lt;/code&gt; and functions whose body seems smaller than the function call overhead early before doing</source>
          <target state="translated">&lt;code&gt;always_inline&lt;/code&gt; でマークされたインライン関数と、実行前の早い段階で関数呼び出しオーバーヘッドよりも本体が小さいように見える関数</target>
        </trans-unit>
        <trans-unit id="873b9f05fa871d467703c76988bb2508081a72a8" translate="yes" xml:space="preserve">
          <source>Inline parts of functions. This option has any effect only when inlining itself is turned on by the</source>
          <target state="translated">関数の部分をインライン化します。このオプションは、インライン化自体が</target>
        </trans-unit>
        <trans-unit id="6695d9e4d931f3bbf61149758e9dd6a876eef21a" translate="yes" xml:space="preserve">
          <source>Inlineable functions can create unexpected line counts. Line counts are shown for the source code of the inlineable function, but what is shown depends on where the function is inlined, or if it is not inlined at all.</source>
          <target state="translated">インライン化可能な関数は、予期しない行数を作成することがあります。行数はインライン化可能な関数のソースコードに対して表示されますが、表示される内容は関数がインライン化されている場所や、インライン化されていない場合によって異なります。</target>
        </trans-unit>
        <trans-unit id="d9ba93d99f300a33841b732c50e4886ea39ea97f" translate="yes" xml:space="preserve">
          <source>Inlining is actually controlled by a number of parameters, which may be specified individually by using</source>
          <target state="translated">インライン化は実際にはいくつかのパラメータによって制御されます。</target>
        </trans-unit>
        <trans-unit id="5482ac6acd5628aa80debf07d0b113dce510f9a8" translate="yes" xml:space="preserve">
          <source>Input constraint strings may not begin with either &amp;lsquo;</source>
          <target state="translated">入力制約文字列は 'で始めることはできません</target>
        </trans-unit>
        <trans-unit id="b80748d19a1a87bf6f0f8e345598d0900573298f" translate="yes" xml:space="preserve">
          <source>Input constraints can also be digits (for example, &lt;code&gt;&quot;0&quot;&lt;/code&gt;). This indicates that the specified input must be in the same place as the output constraint at the (zero-based) index in the output constraint list. When using &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax for the output operands, you may use these names (enclosed in brackets &amp;lsquo;</source>
          <target state="translated">入力制約は数字にすることもできます（たとえば、 &lt;code&gt;&quot;0&quot;&lt;/code&gt; ）。これは、指定された入力が、出力制約リストの（ゼロから始まる）インデックスの出力制約と同じ場所にある必要があることを示しています。使用している場合 &lt;var&gt;asmSymbolicName&lt;/var&gt; の出力オペランドの構文を、あなたは「括弧で囲まれた（これらの名前を使用することができます</target>
        </trans-unit>
        <trans-unit id="dab23b44a9c445e4c1ef121f24288981557e7ceb" translate="yes" xml:space="preserve">
          <source>Input files that don&amp;rsquo;t require compilation are ignored.</source>
          <target state="translated">コンパイルを必要としない入力ファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="9cfdbdf047fb129da10e8b15031d32fae6737df1" translate="yes" xml:space="preserve">
          <source>Input files that don&amp;rsquo;t require preprocessing are ignored.</source>
          <target state="translated">前処理を必要としない入力ファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="0a9931474c689da17fc13937907d59216f561db0" translate="yes" xml:space="preserve">
          <source>Input operands make values from C variables and expressions available to the assembly code.</source>
          <target state="translated">入力オペランドは、C言語の変数や式の値をアセンブリコードで利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="1e2fe59177e98538b3f70c61c4f5e289c840eb88" translate="yes" xml:space="preserve">
          <source>Insert &lt;var&gt;count&lt;/var&gt;&lt;code&gt;NOP&lt;/code&gt; instructions. The number of instructions must be a compile-time integer constant.</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; &lt;code&gt;NOP&lt;/code&gt; 命令を挿入します。命令の数は、コンパイル時の整数定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="80ef9bd4f5c2793b85eb597a6f564354bfd5ad04" translate="yes" xml:space="preserve">
          <source>Insert ENDBR instruction at function entry only via the &lt;code&gt;cf_check&lt;/code&gt; function attribute. This is useful when used with the option</source>
          <target state="translated">ENDBR命令は、 &lt;code&gt;cf_check&lt;/code&gt; 関数属性を介してのみ関数エントリに挿入します。これはオプションとともに使用すると便利です</target>
        </trans-unit>
        <trans-unit id="7e304b0a6f8c78bdb7728a0243dd358487c2e9b4" translate="yes" xml:space="preserve">
          <source>Insert NOPs to force costly dependent insns into separate groups. Insert &lt;var&gt;number&lt;/var&gt; NOPs to force an insn to a new group.</source>
          <target state="translated">NOPを挿入して、コストのかかる依存型インストゥルメントを個別のグループに強制します。 &lt;var&gt;number&lt;/var&gt; NOPを挿入して、insnを新しいグループに強制します。</target>
        </trans-unit>
        <trans-unit id="5093204ba172ea889ff043021567428c590f67d7" translate="yes" xml:space="preserve">
          <source>Insert NOPs to force costly dependent insns into separate groups. Insert exactly as many NOPs as needed to force an insn to a new group, according to the estimated processor grouping.</source>
          <target state="translated">NOP を挿入して、コストのかかる依存する insn を別のグループに強制的に配置します。必要な数だけNOPを挿入して、推定されるプロセッサのグループ化に応じてinsnを新しいグループに強制的に入れます。</target>
        </trans-unit>
        <trans-unit id="da911af1e2c13a9407a1ba5438f240e7adaf4534" translate="yes" xml:space="preserve">
          <source>Insert a &amp;lsquo;</source>
          <target state="translated">「を挿入</target>
        </trans-unit>
        <trans-unit id="f7312b3d8cfcdef6b49830b93ffae1a5aa1b9a7e" translate="yes" xml:space="preserve">
          <source>Insert a cache barrier before a load or store that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">投機的に実行される可能性があり、中止しても副作用が出る可能性があるロードやストアの前にキャッシュバリアを挿入します。</target>
        </trans-unit>
        <trans-unit id="0d1ec5c206dd0a56248bac70a97eb7b49297f48d" translate="yes" xml:space="preserve">
          <source>Insert a cache barrier before a store that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">投機的に実行される可能性があり、中止しても副作用が出る可能性があるストアの前にキャッシュバリアを挿入します。</target>
        </trans-unit>
        <trans-unit id="613b69ab72c3cdbf33646040c8aaf33daa5e69f7" translate="yes" xml:space="preserve">
          <source>Insert an ISB instruction into the instruction stream.</source>
          <target state="translated">命令ストリームに ISB 命令を挿入します。</target>
        </trans-unit>
        <trans-unit id="698e6e70baffc9a9c2b3857106b77a97d6d36fc3" translate="yes" xml:space="preserve">
          <source>Insert an ISYNC instruction into the instruction stream where &lt;var&gt;addr&lt;/var&gt; is an instruction address for serialization.</source>
          <target state="translated">命令ストリームにISYNC命令を挿入 &lt;var&gt;addr&lt;/var&gt; はシリアル化命令アドレスです。</target>
        </trans-unit>
        <trans-unit id="ae82250f19f4a7ef9b7f40de2bc48433366c0b9a" translate="yes" xml:space="preserve">
          <source>Insert bits from &lt;var&gt;bits&lt;/var&gt; into &lt;var&gt;val&lt;/var&gt; and return the resulting value. The nibbles of &lt;var&gt;map&lt;/var&gt; determine how the insertion is performed: Let &lt;var&gt;X&lt;/var&gt; be the &lt;var&gt;n&lt;/var&gt;-th nibble of &lt;var&gt;map&lt;/var&gt;</source>
          <target state="translated">ビットから &lt;var&gt;bits&lt;/var&gt; を &lt;var&gt;val&lt;/var&gt; に挿入し、結果の値を返します。ニブル &lt;var&gt;map&lt;/var&gt; レット：挿入が行われる方法を決定する &lt;var&gt;X&lt;/var&gt; は、であり &lt;var&gt;n&lt;/var&gt; 番目のニブル &lt;var&gt;map&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1b3701c0f8e0fee3d402f64923ea901bb1d7943e" translate="yes" xml:space="preserve">
          <source>Installing GCC automatically creates and installs the fixed header files, by running a program called &lt;code&gt;fixincludes&lt;/code&gt;. Normally, you don&amp;rsquo;t need to pay attention to this. But there are cases where it doesn&amp;rsquo;t do the right thing automatically.</source>
          <target state="translated">GCCをインストールすると、 &lt;code&gt;fixincludes&lt;/code&gt; と呼ばれるプログラムを実行することにより、固定ヘッダーファイルが自動的に作成およびインストールされます。通常、これに注意を払う必要はありません。しかし、自動的に正しく動作しない場合があります。</target>
        </trans-unit>
        <trans-unit id="e4d7156bb86c9e4e2a11b97b329fef2be7147327" translate="yes" xml:space="preserve">
          <source>Instead of emitting debugging information for a C++ class in only one object file, emit it in all object files using the class. This option should be used only with debuggers that are unable to handle the way GCC normally emits debugging information for classes because using this option increases the size of debugging information by as much as a factor of two.</source>
          <target state="translated">C++クラスのデバッグ情報を 1 つのオブジェクト・ファイルだけに出力するのではなく、そのクラスを使用するすべてのオブジェクト・ファイルに出力します。このオプションを使用すると、デバッグ情報のサイズが 2 倍にもなるため、GCC がクラスのデバッグ情報を通常出力する方法を扱えないデバッガでのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="be3fc5710abd7790f590b73876140d19f165f83e" translate="yes" xml:space="preserve">
          <source>Instead of outputting the result of preprocessing, output a rule suitable for &lt;code&gt;make&lt;/code&gt; describing the dependencies of the main source file. The preprocessor outputs one &lt;code&gt;make&lt;/code&gt; rule containing the object file name for that source file, a colon, and the names of all the included files, including those coming from</source>
          <target state="translated">前処理の結果を出力する代わりに、メインソースファイルの依存関係を説明する &lt;code&gt;make&lt;/code&gt; に適したルールを出力します。プリプロセッサは、そのソースファイルのオブジェクトファイル名、コロン、および含まれるすべてのファイルの名前を含む1つの &lt;code&gt;make&lt;/code&gt; ルールを出力します。</target>
        </trans-unit>
        <trans-unit id="77341899c1b278a6893d86a8271c991e7d1d0365" translate="yes" xml:space="preserve">
          <source>Instead of the normal output, generate a list of &amp;lsquo;</source>
          <target state="translated">通常の出力の代わりに、 'のリストを生成します</target>
        </trans-unit>
        <trans-unit id="a34650e9f39910beff75fbecd84557b57d4a5454" translate="yes" xml:space="preserve">
          <source>Instead, a stub has to be set up, i.e. the function has to be called through a symbol (&lt;code&gt;func_4&lt;/code&gt; in the example):</source>
          <target state="translated">代わりに、スタブを設定する必要があります。つまり、関数はシンボル（例では &lt;code&gt;func_4&lt;/code&gt; ）を介して呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="c7ff7b3be05374bf926227d5a6cce16675add1a0" translate="yes" xml:space="preserve">
          <source>Instruction precision. The trap handler can determine the exact instruction that caused a floating-point exception.</source>
          <target state="translated">命令の精度。トラップハンドラは、浮動小数点例外の原因となった正確な命令を決定することができます。</target>
        </trans-unit>
        <trans-unit id="6b7ec2b988946f38d8fde29ac1dc412bf003f9ab" translate="yes" xml:space="preserve">
          <source>Instructions and corresponding built-ins may have additional restrictions and/or input/output values manipulated:</source>
          <target state="translated">命令およびそれに対応するビルトインは、追加の制限および/または入出力値が操作されている場合があります。</target>
        </trans-unit>
        <trans-unit id="60de57ec73ea7d3697a15749f6ec729f6774747c" translate="yes" xml:space="preserve">
          <source>Instructions and extensions for interfacing C with assembler.</source>
          <target state="translated">Cをアセンブラと連動させるための命令と拡張機能。</target>
        </trans-unit>
        <trans-unit id="00371913daeb498043597ab2a3f06503732e4834" translate="yes" xml:space="preserve">
          <source>Instructions may freely access executable sections. This is the default setting.</source>
          <target state="translated">命令は、実行可能なセクションに自由にアクセスすることができます。これはデフォルトの設定です。</target>
        </trans-unit>
        <trans-unit id="728907072b85d2aba92847d49d68ef5c24bb45d9" translate="yes" xml:space="preserve">
          <source>Instructions must not access executable sections. This option can be useful on targets that are configured to have a dual instruction/data SRAM interface but that (unlike the M4K) do not automatically redirect PC-relative loads to the instruction RAM.</source>
          <target state="translated">命令は実行可能セクションにアクセスしてはいけません。このオプションは、命令/データSRAMインターフェイスがデュアル命令/データSRAMインターフェイスに設定されていても、(M4Kとは異なり)PC関連のロードを命令RAMに自動的にリダイレクトしないように構成されているターゲットの場合に有効です。</target>
        </trans-unit>
        <trans-unit id="77c99e564d8632f1532735d88bcf4dbafa41656e" translate="yes" xml:space="preserve">
          <source>Instructions that can address I/O special function registers directly like &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;SBI&lt;/code&gt;, etc. may use a different address as if addressed by an instruction to access RAM like &lt;code&gt;LD&lt;/code&gt; or &lt;code&gt;STS&lt;/code&gt;. This offset depends on the device architecture and has to be subtracted from the RAM address in order to get the respective I/O address.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;SBI&lt;/code&gt; などのI / O特殊機能レジスタを直接アドレス指定できる命令は、 &lt;code&gt;LD&lt;/code&gt; または &lt;code&gt;STS&lt;/code&gt; のようなRAMにアクセスする命令でアドレス指定されているかのように、別のアドレスを使用できます。このオフセットはデバイスアーキテクチャに依存し、それぞれのI / Oアドレスを取得するためにRAMアドレスから減算する必要があります。</target>
        </trans-unit>
        <trans-unit id="cfee5983fd7c9714339e56871463e3d57aa0eec5" translate="yes" xml:space="preserve">
          <source>Instructions that initiate or test completion of DMA must not be reordered with respect to loads and stores of the memory that is being accessed. With</source>
          <target state="translated">DMAを開始またはテスト完了する命令は、アクセスされているメモリのロードおよびストアに関して順序を変えてはいけません。順番を変更してはいけません。</target>
        </trans-unit>
        <trans-unit id="1ce9914ad99ce6285279f0d2872eb791125e8521" translate="yes" xml:space="preserve">
          <source>Instrument comparison operation (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=) with pointer operands. The option must be combined with either</source>
          <target state="translated">ポインターオペランドを使用した機器比較演算（&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt; =）。オプションはいずれかと組み合わせる必要があります</target>
        </trans-unit>
        <trans-unit id="f9387cf45ec340cf769d2b6bfd22820dfe0ee0f4" translate="yes" xml:space="preserve">
          <source>Instrument function exit in -pg -mfentry instrumented functions with call to specified function. This only instruments true returns ending with ret, but not sibling calls ending with jump. Valid types are &lt;var&gt;none&lt;/var&gt; to not instrument, &lt;var&gt;call&lt;/var&gt; to generate a call to __return__, or &lt;var&gt;nop5&lt;/var&gt; to generate a 5 byte nop.</source>
          <target state="translated">指定された関数の呼び出しを伴う-pg -mfentryインストルメント済み関数のインストルメント関数出口。これは、retで終わるtrueの戻り値のみを計測しますが、jumpで終わる兄弟呼び出しは計測しません。有効なタイプはない &lt;var&gt;none&lt;/var&gt; ない機器への &lt;var&gt;call&lt;/var&gt; __return__への呼び出し、または生成する &lt;var&gt;nop5&lt;/var&gt; 5バイトのnopを生成するために。</target>
        </trans-unit>
        <trans-unit id="c422d699b98760b3dc7f3d9f1edcf402a69024bc" translate="yes" xml:space="preserve">
          <source>Instrument only functions from files where names do not match all the regular expressions (separated by a semi-colon).</source>
          <target state="translated">インストゥルメントは、名前がすべての正規表現と一致しないファイルからのみ機能します(セミコロンで区切られています)。</target>
        </trans-unit>
        <trans-unit id="65fc966a722098cb273080c59ea2c31dc9cc3d92" translate="yes" xml:space="preserve">
          <source>Instrument only functions from files where names match any regular expression (separated by a semi-colon).</source>
          <target state="translated">インストゥルメントは、名前が正規表現と一致するファイルからのみ機能します(セミコロンで区切られています)。</target>
        </trans-unit>
        <trans-unit id="55915d652d64c067aae4ac13787cd5f4e2697a1d" translate="yes" xml:space="preserve">
          <source>Instrument subtraction with pointer operands. The option must be combined with either</source>
          <target state="translated">ポインタオペランドを用いたインストゥルメント減算。このオプションは</target>
        </trans-unit>
        <trans-unit id="f97527e405387e5a9385fec8790b4168dd1d8deb" translate="yes" xml:space="preserve">
          <source>Int constant that is the element number of the 64-bit scalar in a vector.</source>
          <target state="translated">ベクトル内の64ビットスカラの要素番号であるInt定数。</target>
        </trans-unit>
        <trans-unit id="2c6ce795cf7dec61b5fb3d9cd78c430001b2fa7a" translate="yes" xml:space="preserve">
          <source>Int constant that is the element number that the MFVSRLD instruction. targets.</source>
          <target state="translated">MFVSRLD 命令が対象とする要素番号を表す Int 定数です。</target>
        </trans-unit>
        <trans-unit id="da3ed23012cb8789d59d48ce6671ae83734c67c3" translate="yes" xml:space="preserve">
          <source>Integer constant -1</source>
          <target state="translated">整数定数 -1</target>
        </trans-unit>
        <trans-unit id="4c803cf324e7329fee610f61a0c7d3b490694d57" translate="yes" xml:space="preserve">
          <source>Integer constant -1^20..1^19.</source>
          <target state="translated">整数定数 -1^20...1^19.</target>
        </trans-unit>
        <trans-unit id="2d5c0333af76728cebb79e955757484473872b82" translate="yes" xml:space="preserve">
          <source>Integer constant 0</source>
          <target state="translated">整数定数0</target>
        </trans-unit>
        <trans-unit id="ec0deff2b158ad4cb0e8bfb80bf58b629d319506" translate="yes" xml:space="preserve">
          <source>Integer constant 1-4.</source>
          <target state="translated">整数定数1~4。</target>
        </trans-unit>
        <trans-unit id="f8ce91b7924266e877123b863072a4c805b14605" translate="yes" xml:space="preserve">
          <source>Integer constant 1.</source>
          <target state="translated">整数定数 1.</target>
        </trans-unit>
        <trans-unit id="1c45cb8e2489b4f0de7b30a15f87854cc65bcd1c" translate="yes" xml:space="preserve">
          <source>Integer constant 31</source>
          <target state="translated">整数定数 31</target>
        </trans-unit>
        <trans-unit id="8a25d342105560c6220c4d21018dbd66f4909ac2" translate="yes" xml:space="preserve">
          <source>Integer constant 32</source>
          <target state="translated">整数定数 32</target>
        </trans-unit>
        <trans-unit id="0886d513058a9038f440a00ef02c6efc4d8b2b92" translate="yes" xml:space="preserve">
          <source>Integer constant 63</source>
          <target state="translated">整数定数 63</target>
        </trans-unit>
        <trans-unit id="e5d7234c4cec0b69e9a17de13e13f7813e3fe736" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -16 &amp;hellip; 15.</source>
          <target state="translated">-16〜15の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="1565cd95bbecf4f27341ea540e96d5e245a3ed87" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -31 &amp;hellip; 0.</source>
          <target state="translated">-31〜0の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="61fb232c331445cfab1e14db8fe240ad44ae23ee" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -32768 &amp;hellip; 32767.</source>
          <target state="translated">-32768〜32767の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="41e8e6f2af1c63e52d1b0b7e46462d22a537cb51" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -65535 .. -1 (16-bit negative immediate)</source>
          <target state="translated">範囲内の整数定数 -65535 ...-1 (16ビット負の即時)</target>
        </trans-unit>
        <trans-unit id="61d203086fb27478ca235c1af13878c2c9eb4b69" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 15.</source>
          <target state="translated">0〜15の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="23ba3688657355d36ab63c4cf135962636a98aed" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 31, for 32-bit shifts.</source>
          <target state="translated">32ビットシフトの場合、0〜31の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="8a5ce6a50ce7c04ba5c11f9521a26c518ec2f5a9" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 31.</source>
          <target state="translated">0〜31の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="139ee936a79aaecfdde7d9044eb41363a8396bbf" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 63, for 64-bit shifts.</source>
          <target state="translated">64ビットのシフトの場合、0〜63の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="dbc4a22dc2be34fbbf4cb0f86cc5f6d5bed6c2db" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 65535.</source>
          <target state="translated">0から65535の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="c3baf5f98ff3b5c0b48fedbf2ab36c7ce3d9b574" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 .. 65535 (16-bit immediate)</source>
          <target state="translated">0 ~ 65535(16ビット即時)の範囲の整数定数</target>
        </trans-unit>
        <trans-unit id="2eb542fcd23b06c609f45ce695bf858099197e4a" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 1 .. 31 (5-bit immediate)</source>
          <target state="translated">1 ~ 31 の範囲の整数定数(5 ビット即時)。</target>
        </trans-unit>
        <trans-unit id="3a4a963907c182d517ccab65869d0178be683b92" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 1 to 4 for &lt;code&gt;shladd&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;shladd&lt;/code&gt; 命令の場合、1から4の範囲の整数定数</target>
        </trans-unit>
        <trans-unit id="ed5ad237aa0c579aead190a4dde0d33acad46194" translate="yes" xml:space="preserve">
          <source>Integer constant in the range &lt;em&gt;-2^{20}&lt;/em&gt; &amp;hellip; &lt;em&gt;2^{20} - 1&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;-2 ^ {20}&lt;/em&gt; &amp;hellip; &lt;em&gt;2 ^ {20}-1&lt;/em&gt;の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="39cf676267018369b0349969938433de83ddfa88" translate="yes" xml:space="preserve">
          <source>Integer constant that can be deposited with a &lt;code&gt;zdepi&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;zdepi&lt;/code&gt; 命令でデポジットできる整数定数</target>
        </trans-unit>
        <trans-unit id="583d118a63d65e988fe09c84c0b83aa8b38f16dd" translate="yes" xml:space="preserve">
          <source>Integer constant that can be loaded with a &lt;code&gt;ldil&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;ldil&lt;/code&gt; 命令でロードできる整数定数</target>
        </trans-unit>
        <trans-unit id="d48f93a4a200fa761b79e46b5d40a57efc3b0da5" translate="yes" xml:space="preserve">
          <source>Integer constant that can be the operand of an ADDA or a SUBA insn.</source>
          <target state="translated">ADDAまたはSUBA insnのオペランドになり得る整数定数。</target>
        </trans-unit>
        <trans-unit id="4a8ae929e4e263dbb7f6fd66766fe30d1987a3a1" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used for &lt;code&gt;and&lt;/code&gt; operations in &lt;code&gt;depi&lt;/code&gt; and &lt;code&gt;extru&lt;/code&gt; instructions</source>
          <target state="translated">&lt;code&gt;depi&lt;/code&gt; および &lt;code&gt;extru&lt;/code&gt; 命令で使用できる整数定数 &lt;code&gt;and&lt;/code&gt; 演算</target>
        </trans-unit>
        <trans-unit id="2dba2c70cd49d15853d2fcbcd40ffda61228a146" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used with a 32-bit logical instruction</source>
          <target state="translated">32ビット論理命令で使用できる整数定数</target>
        </trans-unit>
        <trans-unit id="8b060ea2730a272f1b73ae50c5eba4cb144cbe70" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used with a 64-bit logical instruction</source>
          <target state="translated">64ビット論理命令で使用できる整数定数</target>
        </trans-unit>
        <trans-unit id="b5725eeea2176684ac75dce07a938b4978d11776" translate="yes" xml:space="preserve">
          <source>Integer constant that fits in one signed byte when incremented (-129 &amp;hellip; 126), but excluding -1.</source>
          <target state="translated">インクリメント（-129&amp;hellip;126）したときに1つの符号付きバイトに収まるが、-1を除く整数定数。</target>
        </trans-unit>
        <trans-unit id="3b5d9aff7d40b143bd6daff2c6a766259ab8b1fb" translate="yes" xml:space="preserve">
          <source>Integer constant that fits in one signed byte when incremented by one (-129 &amp;hellip; 126).</source>
          <target state="translated">1増加したときに1つの符号付きバイトに収まる整数定数（-129&amp;hellip;126）。</target>
        </trans-unit>
        <trans-unit id="51f11e6766d50aacca9af72d19a2ad4ee44d8420" translate="yes" xml:space="preserve">
          <source>Integer constant that has all 1 bits consecutive and starting at bit 0.</source>
          <target state="translated">すべての1ビットが連続しており、ビット0から始まる整数定数です。</target>
        </trans-unit>
        <trans-unit id="5b3c28e6f072c668f6a58d9fd92384f1db7f2163" translate="yes" xml:space="preserve">
          <source>Integer constant that is a byte tiled out eight times.</source>
          <target state="translated">バイトを8回タイルアウトした整数定数です。</target>
        </trans-unit>
        <trans-unit id="b7536bc6ddcc73d7874ea428acf5799f76f79b75" translate="yes" xml:space="preserve">
          <source>Integer constant that is a byte tiled out four times.</source>
          <target state="translated">バイトを4回タイルアウトした整数定数。</target>
        </trans-unit>
        <trans-unit id="9097601fede0f9d62a8556f7fb948f72c7e42669" translate="yes" xml:space="preserve">
          <source>Integer constant that is a sign-extended byte tiled out as four shorts.</source>
          <target state="translated">符号拡張バイトを4つのショートとして並べた整数定数です。</target>
        </trans-unit>
        <trans-unit id="a1aafaaeb369802b9c5b5f7500539f8ecf40fe8f" translate="yes" xml:space="preserve">
          <source>Integer constant that is a sign-extended byte tiled out as two shorts.</source>
          <target state="translated">符号拡張バイトを2つのショートとしてタイルアウトした整数定数です。</target>
        </trans-unit>
        <trans-unit id="f7398c389ada177deaf12a34ecfa3423b7af8637" translate="yes" xml:space="preserve">
          <source>Integer constant that is a valid mask for the clr instruction.</source>
          <target state="translated">clr命令の有効なマスクとなる整数定数です。</target>
        </trans-unit>
        <trans-unit id="b75d0ad68a107d1647765566cd4e4331ec877550" translate="yes" xml:space="preserve">
          <source>Integer constant that is a valid mask for the set instruction.</source>
          <target state="translated">セット命令の有効なマスクとなる整数定数です。</target>
        </trans-unit>
        <trans-unit id="6deb8c44627243fffa30bdcea50916656d673936" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a 32-bit &lt;code&gt;MOV&lt;/code&gt; pseudo instruction. The &lt;code&gt;MOV&lt;/code&gt; may be assembled to one of several different machine instructions depending on the value</source>
          <target state="translated">32ビット &lt;code&gt;MOV&lt;/code&gt; 疑似命令の即値オペランドとして有効な整数定数。 &lt;code&gt;MOV&lt;/code&gt; は、値に応じて、いくつかの異なるマシン命令の1つに組み立てることができます</target>
        </trans-unit>
        <trans-unit id="4a87d8c398f8df47aa819b51612d3b210718b178" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a 64-bit &lt;code&gt;MOV&lt;/code&gt; pseudo instruction</source>
          <target state="translated">64ビット &lt;code&gt;MOV&lt;/code&gt; 疑似命令の即値オペランドとして有効な整数定数</target>
        </trans-unit>
        <trans-unit id="835371f7edd442337ddaf558ccf33428685fd64a" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a &lt;code&gt;SUB&lt;/code&gt; instruction (once negated)</source>
          <target state="translated">&lt;code&gt;SUB&lt;/code&gt; 命令の即値オペランドとして有効な整数定数（一度否定されると）</target>
        </trans-unit>
        <trans-unit id="b60b6a4c6d01417f64595177f963b401572f1d12" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in an &lt;code&gt;ADD&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 命令の即値オペランドとして有効な整数定数</target>
        </trans-unit>
        <trans-unit id="87c79859b391fe886f4983ce7831a89b4adb68fe" translate="yes" xml:space="preserve">
          <source>Integer constant valid for BccI instructions</source>
          <target state="translated">BccI 命令で有効な整数定数</target>
        </trans-unit>
        <trans-unit id="85ce5abeb1e3fd38a5870ac5e6ed6f9d365a68ef" translate="yes" xml:space="preserve">
          <source>Integer constant whose value plus one is a power of 2</source>
          <target state="translated">値に1を加えたものが2のべき乗である整数定数</target>
        </trans-unit>
        <trans-unit id="a5c600b3e3e20d77f480eccf6ab83a9d32d44088" translate="yes" xml:space="preserve">
          <source>Integer constant zero</source>
          <target state="translated">完全性定数ゼロ</target>
        </trans-unit>
        <trans-unit id="c3722e4be24bd097c1e77d6a4d941d39b4c012e9" translate="yes" xml:space="preserve">
          <source>Integer constant zero.</source>
          <target state="translated">整数定数ゼロ。</target>
        </trans-unit>
        <trans-unit id="dbf06f652fea58e9dd29649e240ec804969a5dd2" translate="yes" xml:space="preserve">
          <source>Integer constants 0 through 3; shifts by these amounts are handled as multiple single-bit shifts rather than a single variable-length shift.</source>
          <target state="translated">これらの量によるシフトは、単一の可変長シフトではなく、複数のシングルビットシフトとして処理されます。</target>
        </trans-unit>
        <trans-unit id="8ac2f4ad59dbab77a56696249eb809853e9615f0" translate="yes" xml:space="preserve">
          <source>Integer constants can be written as binary constants, consisting of a sequence of &amp;lsquo;</source>
          <target state="translated">整数定数は、 'のシーケンスで構成されるバイナリ定数として記述できます。</target>
        </trans-unit>
        <trans-unit id="f41a13c6db375bed842d479bfe5b3e0010d33bf8" translate="yes" xml:space="preserve">
          <source>Integer in the range -4095 to 4095</source>
          <target state="translated">4095~4095の範囲の整数</target>
        </trans-unit>
        <trans-unit id="c3fa9d65e6a7c1536f875f2bf419adf966cd23e9" translate="yes" xml:space="preserve">
          <source>Integer in the range -8 to -1</source>
          <target state="translated">8~-1の範囲の整数</target>
        </trans-unit>
        <trans-unit id="3328ae7578dc6597eb774fb278c9e73ac29b9573" translate="yes" xml:space="preserve">
          <source>Integer in the range 0 to 32</source>
          <target state="translated">0~32の範囲の整数</target>
        </trans-unit>
        <trans-unit id="e2a38f8fa6e98406bcdf4c312d8238e5cfaf61be" translate="yes" xml:space="preserve">
          <source>Integer in the range 1 to 8</source>
          <target state="translated">1~8の範囲の整数</target>
        </trans-unit>
        <trans-unit id="a9929ab1a333ba5cc9ace240e37dbafefb59c7f4" translate="yes" xml:space="preserve">
          <source>Integer sized structures and unions are returned in register &lt;code&gt;r10&lt;/code&gt;.</source>
          <target state="translated">整数サイズの構造体と共用体は、レジスタ &lt;code&gt;r10&lt;/code&gt; に返されます。</target>
        </trans-unit>
        <trans-unit id="aeae103003a2aa38881e355310bf8ec9d365ac20" translate="yes" xml:space="preserve">
          <source>Integer sized structures and unions are returned via a memory pointer rather than a register.</source>
          <target state="translated">整数サイズの構造体やユニオンは、レジスタではなくメモリポインタを介して返されます。</target>
        </trans-unit>
        <trans-unit id="ec38048bade6f626a61ac1474e93bfb38c7df1c6" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for a custom instruction opcode. Range 0 to 255.</source>
          <target state="translated">カスタム命令オペコードの即時オペランドとして有効な整数です。範囲は0~255です。</target>
        </trans-unit>
        <trans-unit id="fe9f5b3e08a16acbb4c74692fda365cc43d2472f" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for a shift instruction. Range 0 to 31.</source>
          <target state="translated">シフト命令の即時オペランドとして有効な整数です。範囲は0~31です。</target>
        </trans-unit>
        <trans-unit id="890df9207d827aca96b399580bd0f8412e42f7e4" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for only the value 0. Can be used in conjunction with the format modifier &lt;code&gt;z&lt;/code&gt; to use &lt;code&gt;r0&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt; in the assembly output.</source>
          <target state="translated">値0のみの即値オペランドとして有効な整数。アセンブリー出力で &lt;code&gt;0&lt;/code&gt; の代わりに &lt;code&gt;r0&lt;/code&gt; を使用するために、フォーマット修飾子 &lt;code&gt;z&lt;/code&gt; と組み合わせて使用​​できます。</target>
        </trans-unit>
        <trans-unit id="96f19b7b3636f22386cbe0a9f69dade2dd82e04c" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in a data processing instruction. That is, an integer in the range 0 to 255 rotated by a multiple of 2</source>
          <target state="translated">データ処理命令の即時オペランドとして有効な整数。つまり、0から255までの範囲の整数を2の倍数で回転させたもの。</target>
        </trans-unit>
        <trans-unit id="ac46ec6d366341fdb4af14310403ae3145f3b15e" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking a signed 16-bit number. Range -32768 to 32767.</source>
          <target state="translated">符号付き16ビットの数値を取る命令の即時オペランドとして有効な整数です。範囲は-32768~32767です。</target>
        </trans-unit>
        <trans-unit id="498c2e8d0733c4db6411b6bc3ce46dadd5e77698" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking an unsigned 16-bit number. Range 0 to 65535.</source>
          <target state="translated">符号なし16ビットの数値を取る命令の即時オペランドとして有効な整数です。範囲は0~65535です。</target>
        </trans-unit>
        <trans-unit id="e29f49d17b7fc198ce0fa7cb4201b18268e8d536" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking only the upper 16-bits of a 32-bit number. Range 32-bit numbers with the lower 16-bits being 0.</source>
          <target state="translated">32ビットの数値の上位16ビットのみを取る命令の即時オペランドとして有効な整数。下位16ビットを0とした32ビットの範囲の数値。</target>
        </trans-unit>
        <trans-unit id="ef774527e73685dd482562595abea32f82ae8d26" translate="yes" xml:space="preserve">
          <source>Integer that satisfies constraint &amp;lsquo;</source>
          <target state="translated">制約を満たす整数 '</target>
        </trans-unit>
        <trans-unit id="cd276dc30e78674723811469b75093e4347a5ec8" translate="yes" xml:space="preserve">
          <source>Integer zero.</source>
          <target state="translated">整数ゼロ。</target>
        </trans-unit>
        <trans-unit id="02a8d3d0cb0f8a8a1f06403c05ed166f02853b82" translate="yes" xml:space="preserve">
          <source>Integer/Floating point constant that can be loaded into a register using three instructions</source>
          <target state="translated">3つの命令でレジスタにロードできる整数/浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="96638e8b977a410fa8a46154d5e4a6ec900c666f" translate="yes" xml:space="preserve">
          <source>Integers valid for a moveq followed by a swap</source>
          <target state="translated">moveq の後にスワップを行う場合に有効な整数</target>
        </trans-unit>
        <trans-unit id="d5c9a136f34c3dd6a7b63f408e1d675a9e1d38b5" translate="yes" xml:space="preserve">
          <source>Integers valid for mvq</source>
          <target state="translated">mvqで有効な整数</target>
        </trans-unit>
        <trans-unit id="62e557d83b66a9b174581d03e3369a916272f333" translate="yes" xml:space="preserve">
          <source>Integers valid for mvs</source>
          <target state="translated">mvsで有効な整数</target>
        </trans-unit>
        <trans-unit id="f4c85b8fad56b772bc4edffa020d9ee37f46fcc9" translate="yes" xml:space="preserve">
          <source>Integers valid for mvz</source>
          <target state="translated">mvz で有効な整数</target>
        </trans-unit>
        <trans-unit id="813e6a224069c7c2d70896d18ba42a603d4d9749" translate="yes" xml:space="preserve">
          <source>Integrate functions into their callers when their body is smaller than expected function call code (so overall size of program gets smaller). The compiler heuristically decides which functions are simple enough to be worth integrating in this way. This inlining applies to all functions, even those not declared inline.</source>
          <target state="translated">関数の本体が期待される関数呼び出しコードよりも小さい場合に、関数を呼び出し元に統合します(そのため、プログラム全体のサイズが小さくなります)。コンパイラは、この方法で統合する価値があるほど単純な関数をヒューリスティックに判断します。このインライン化は、インラインで宣言されていない関数であっても、すべての関数に適用されます。</target>
        </trans-unit>
        <trans-unit id="e91f1a6f03354a5b4184e1f82704c900a6e46315" translate="yes" xml:space="preserve">
          <source>Intel Atom Bonnell CPU.</source>
          <target state="translated">Intel Atom BonnellのCPU。</target>
        </trans-unit>
        <trans-unit id="e74ed473994f92acf9d6f6cf74055640eea6c5fe" translate="yes" xml:space="preserve">
          <source>Intel Atom CPU.</source>
          <target state="translated">インテルAtomのCPU。</target>
        </trans-unit>
        <trans-unit id="98be980f2e14c7ddb3a22e21977f5c70a3b827ac" translate="yes" xml:space="preserve">
          <source>Intel Atom Goldmont CPU.</source>
          <target state="translated">Intel Atom Goldmont CPU。</target>
        </trans-unit>
        <trans-unit id="8826cac9bbaea239ec6b025d2e96062e97854111" translate="yes" xml:space="preserve">
          <source>Intel Atom Goldmont Plus CPU.</source>
          <target state="translated">Intel Atom Goldmont Plus CPU。</target>
        </trans-unit>
        <trans-unit id="a870596d824025354ebffc8dc4c34386d2eeee36" translate="yes" xml:space="preserve">
          <source>Intel Atom Silvermont CPU.</source>
          <target state="translated">Intel Atom SilvermontのCPU。</target>
        </trans-unit>
        <trans-unit id="19971c3133f23a6216254229cc2f489858e4b628" translate="yes" xml:space="preserve">
          <source>Intel Atom Tremont CPU.</source>
          <target state="translated">Intel Atom Tremont CPU。</target>
        </trans-unit>
        <trans-unit id="753d5fc029292ebb3d94e473e03912bd930c9f2d" translate="yes" xml:space="preserve">
          <source>Intel Bonnell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.</source>
          <target state="translated">Intel Bonnell CPUは、64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3命令セットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="7edbccc518975fa2abcfd847cddd45d3bdf2e5eb" translate="yes" xml:space="preserve">
          <source>Intel Broadwell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX and PREFETCHW instruction set support.</source>
          <target state="translated">64ビット拡張機能付きIntel Broadwell CPU、MOVBE、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW命令セットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="2c6d2ee594a13260b5d6fa3f46182be446bfcf73" translate="yes" xml:space="preserve">
          <source>Intel CPU.</source>
          <target state="translated">インテルのCPU。</target>
        </trans-unit>
        <trans-unit id="b3c18e4c2ec250a1137d5aca17aa4c1bc104e36c" translate="yes" xml:space="preserve">
          <source>Intel Cannonlake Server CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC, XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI, AVX512IFMA, SHA and UMIP instruction set support.</source>
          <target state="translated">Intel Cannonlake Server CPU 64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC。XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VBMI、AVX512IFMA、SHA、UMIP命令セットをサポート。</target>
        </trans-unit>
        <trans-unit id="d0663fbf8e5631514b2db57500466ab8f139387f" translate="yes" xml:space="preserve">
          <source>Intel Cascadelake CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC, XSAVES, AVX512F, CLWB, AVX512VL, AVX512BW, AVX512DQ, AVX512CD and AVX512VNNI instruction set support.</source>
          <target state="translated">Intel Cascadelake CPU(64ビット拡張機能付き)、MOVBE、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED AD。 2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VNNI命令セットをサポート。</target>
        </trans-unit>
        <trans-unit id="9e3cc9cc4cb7f234d7785740a07261c4e8d9725a" translate="yes" xml:space="preserve">
          <source>Intel Core 2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.</source>
          <target state="translated">Intel Core 2 CPUで64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3命令セットをサポート。</target>
        </trans-unit>
        <trans-unit id="b2638689948cd6d31eb928296bcce10234faa67e" translate="yes" xml:space="preserve">
          <source>Intel Core 2 CPU.</source>
          <target state="translated">Intel Core 2のCPU。</target>
        </trans-unit>
        <trans-unit id="38efa0dcd9f562f810c407371ffbbef6853b6616" translate="yes" xml:space="preserve">
          <source>Intel Core i7 Broadwell CPU.</source>
          <target state="translated">インテル Core i7 Broadwell CPU。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
