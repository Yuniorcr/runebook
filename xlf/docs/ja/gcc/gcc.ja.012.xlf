<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="e9932d75815f4a1da8b9c3167803247d114d4d3e" translate="yes" xml:space="preserve">
          <source>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are &lt;code&gt;SBRS&lt;/code&gt;, &lt;code&gt;SBRC&lt;/code&gt;, &lt;code&gt;SBIS&lt;/code&gt;, &lt;code&gt;SBIC&lt;/code&gt; and &lt;code&gt;CPSE&lt;/code&gt;. The second macro is only defined if &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; is also set.</source>
          <target state="translated">一部のAVRデバイス（AT90S8515、ATmega103）は、ハードウェアエラッタのため、32ビット命令をスキップしてはなりません。スキップ命令は、 &lt;code&gt;SBRS&lt;/code&gt; 、 &lt;code&gt;SBRC&lt;/code&gt; 、 &lt;code&gt;SBIS&lt;/code&gt; 、 &lt;code&gt;SBIC&lt;/code&gt; 、 &lt;code&gt;CPSE&lt;/code&gt; です。 2番目のマクロは、 &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; も設定されている場合にのみ定義されます。</target>
        </trans-unit>
        <trans-unit id="b8587f1a252be44a26b4bf83b41b8cacfabe3c53" translate="yes" xml:space="preserve">
          <source>Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a &lt;code&gt;RAMP&lt;/code&gt; register is used as high part of the address: The &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; address register is concatenated with the &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively, to get a wide address. Similarly, &lt;code&gt;RAMPD&lt;/code&gt; is used together with direct addressing.</source>
          <target state="translated">一部のAVRデバイスは、16ビットポインターでアクセスできる64 KiB範囲より大きいメモリをサポートします。この64 KiB範囲外のメモリロケーションにアクセスするには、 &lt;code&gt;RAMP&lt;/code&gt; レジスタの内容をアドレスの上位部分として使用します &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;Y&lt;/code&gt; 、 &lt;code&gt;Z&lt;/code&gt; アドレスレジスタは、それぞれ &lt;code&gt;RAMPX&lt;/code&gt; 、 &lt;code&gt;RAMPY&lt;/code&gt; 、 &lt;code&gt;RAMPZ&lt;/code&gt; 特殊機能レジスタと連結されて、広いアドレス。同様に、 &lt;code&gt;RAMPD&lt;/code&gt; は直接アドレッシングと一緒に使用されます。</target>
        </trans-unit>
        <trans-unit id="b652248718bfad5072f0c61fa63785c614519d9b" translate="yes" xml:space="preserve">
          <source>Some Cortex-M3 cores can cause data corruption when &lt;code&gt;ldrd&lt;/code&gt; instructions with overlapping destination and base registers are used. This option avoids generating these instructions. This option is enabled by default when</source>
          <target state="translated">一部のCortex-M3コアは、オーバーラップするデスティネーションレジスタとベースレジスタを持つ &lt;code&gt;ldrd&lt;/code&gt; 命令を使用すると、データ破損を引き起こす可能性があります。このオプションは、これらの命令の生成を回避します。このオプションは、次の場合にデフォルトで有効になります</target>
        </trans-unit>
        <trans-unit id="de0fd695fef81a6e3c397b49019c4e2e00e1f0cc" translate="yes" xml:space="preserve">
          <source>Some GCC compilation options cause the compiler to generate code that does not conform to the platform&amp;rsquo;s default ABI. Other options cause different program behavior for implementation-defined features that are not covered by an ABI. These options are provided for consistency with other compilers that do not follow the platform&amp;rsquo;s default ABI or the usual behavior of implementation-defined features for the platform. Be very careful about using such options.</source>
          <target state="translated">一部のGCCコンパイルオプションにより、コンパイラはプラットフォームのデフォルトのABIに準拠しないコードを生成します。他のオプションは、ABIでカバーされない実装定義の機能に対して異なるプログラム動作を引き起こします。これらのオプションは、プラットフォームのデフォルトのABIまたはプラットフォームの実装定義機能の通常の動作に従わない他のコンパイラとの一貫性を保つために提供されています。このようなオプションの使用には十分注意してください。</target>
        </trans-unit>
        <trans-unit id="0325ca2d082f6bb9f5d1e5e855cb8121b2560adb" translate="yes" xml:space="preserve">
          <source>Some ISO C testsuites report failure when the compiler does not produce an error message for a certain program.</source>
          <target state="translated">いくつかのISO C testsuitesは、コンパイラが特定のプログラムのエラーメッセージを生成しない場合に失敗を報告します。</target>
        </trans-unit>
        <trans-unit id="84f1bb1b30ec55b3fd5d6eb1c7f6faa03400485d" translate="yes" xml:space="preserve">
          <source>Some additional environment variables affect the behavior of the preprocessor.</source>
          <target state="translated">いくつかの追加の環境変数はプリプロセッサの動作に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="5045e735a2d8c7129e122a97ea30410aa9319aed" translate="yes" xml:space="preserve">
          <source>Some assemblers only support this flag when &lt;var&gt;n&lt;/var&gt; is a power of two; in that case, it is rounded up.</source>
          <target state="translated">一部のアセンブラは、 &lt;var&gt;n&lt;/var&gt; が2の累乗の場合にのみこのフラグをサポートします。その場合は切り上げます。</target>
        </trans-unit>
        <trans-unit id="2ceba313d16765bb5b6ec17c1ebb8d3d9c14df42" translate="yes" xml:space="preserve">
          <source>Some attributes only make sense for C++ programs.</source>
          <target state="translated">属性によっては、C++プログラムでしか意味をなさないものもあります。</target>
        </trans-unit>
        <trans-unit id="81c2a3663ddcd2a93314c07f339088b18a9513ff" translate="yes" xml:space="preserve">
          <source>Some cases of unnamed fields in structures and unions are only accepted with this option. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details.</source>
          <target state="translated">構造体と共用体の名前のないフィールドの一部のケースは、このオプションでのみ受け入れられます。詳細については、&lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;structs / unions内の無名のstruct / unionフィールド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="15750fff39388c96e233f1fff7614239f8996f69" translate="yes" xml:space="preserve">
          <source>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance &lt;code&gt;\u207F&lt;/code&gt;, &amp;ldquo;SUPERSCRIPT LATIN SMALL LETTER N&amp;rdquo;, displays just like a regular &lt;code&gt;n&lt;/code&gt; that has been placed in a superscript. ISO 10646 defines the &lt;em&gt;NFKC&lt;/em&gt; normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use</source>
          <target state="translated">ISO 10646の一部の文字は異なる意味を持っていますが、特にフォーマットが適用された後は、一部のフォントまたは表示方法で同一に見えます。たとえば、 &lt;code&gt;\u207F&lt;/code&gt; 、「SUPERSCRIPT LATIN SMALL LETTER N」は、上付き文字に配置された通常の &lt;code&gt;n&lt;/code&gt; と同じように表示されます。ISO 10646は、これらすべてを標準形式にも変換する&lt;em&gt;NFKC&lt;/em&gt;正規化スキームを定義し、使用する場合、コードがNFKCにない場合、GCCが警告します</target>
        </trans-unit>
        <trans-unit id="5d2e5736cfa0533f11cc548a18ee8de7127f23cf" translate="yes" xml:space="preserve">
          <source>Some checkers are disabled by default (even with</source>
          <target state="translated">いくつかのチェッカーはデフォルトで無効になっています(</target>
        </trans-unit>
        <trans-unit id="06da659fa22deee4cc3d56729c6b4abce7edba00" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">いくつかの選択は、GCCが従うプラットフォーム（標準の文字エンコーディングを含む）に対して外部で決定されたABIに依存します。これらは、以下の「ABIが決定」としてリストされています。参照&lt;a href=&quot;compatibility#Compatibility&quot;&gt;バイナリ互換性&lt;/a&gt;、および&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;。一部の選択肢は、プリプロセッサのマニュアルに記載されています。Cプリプロセッサの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;実装定義の動作を&lt;/a&gt;参照してください。一部の選択肢は、C言語の対応するドキュメントに記載されています。&lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;Cの実装を&lt;/a&gt;参照してください。一部の選択は、ライブラリとオペレーティングシステム（または、独立した環境用にコンパイルする場合は他の環境）によって行われます。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="258878cc764e88fa980c6c9ddf4a6f80e9d5cd8f" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">いくつかの選択は、GCCが従うプラットフォーム（標準の文字エンコーディングを含む）に対して外部で決定されたABIに依存します。これらは、以下の「ABIが決定」としてリストされています。参照&lt;a href=&quot;compatibility#Compatibility&quot;&gt;バイナリ互換性&lt;/a&gt;、および&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;。一部の選択肢は、プリプロセッサのマニュアルに記載されています。Cプリプロセッサの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;実装定義の動作を&lt;/a&gt;参照してください。一部の選択は、ライブラリとオペレーティングシステム（または、独立した環境用にコンパイルする場合は他の環境）によって行われます。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="15506c8b8d5d6b275040aeee640a2a5a3f7d4d37" translate="yes" xml:space="preserve">
          <source>Some common examples of pure functions are &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;memcmp&lt;/code&gt;. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between consecutive calls (such as the standard C &lt;code&gt;feof&lt;/code&gt; function in a multithreading environment).</source>
          <target state="translated">純粋な関数のいくつかの一般的な例は、 &lt;code&gt;strlen&lt;/code&gt; または &lt;code&gt;memcmp&lt;/code&gt; です。興味深い非純粋関数とは、無限ループを持つ関数、または揮発性メモリやその他のシステムリソースに依存する関数であり、連続する呼び出し間で変化する可能性があります（マルチスレッド環境の標準C &lt;code&gt;feof&lt;/code&gt; 関数など）。</target>
        </trans-unit>
        <trans-unit id="12ce1dfd34507685834493a64bea0bb0f207ab99" translate="yes" xml:space="preserve">
          <source>Some computer manufacturers have published Application Binary Interface standards which specify that plain bit-fields should be unsigned. It is a mistake, however, to say anything about this issue in an ABI. This is because the handling of plain bit-fields distinguishes two dialects of C. Both dialects are meaningful on every type of machine. Whether a particular object file was compiled using signed bit-fields or unsigned is of no concern to other object files, even if they access the same bit-fields in the same data structures.</source>
          <target state="translated">コンピュータメーカーの中には、プレーンなビットフィールドは符号なしであるべきだと規定しているアプリケーション・バイナリ・インタフェース規格を公開しているところもあります。しかし、ABIでこの問題について何かを言うのは間違いです。これは、プレーン・ビット・フィールドの取り扱いがC言語の2つの方言を区別しているからです。特定のオブジェクトファイルが符号付きビットフィールドを使ってコンパイルされたか、符号なしビットフィールドを使ってコンパイルされたかは、他のオブジェクトファイルが同じデータ構造で同じビットフィールドにアクセスしたとしても、何の関心もありません。</target>
        </trans-unit>
        <trans-unit id="71e1ac9ab0109c68aee90fe9c98e8024ac2ba20a" translate="yes" xml:space="preserve">
          <source>Some configurations of the compiler also support additional target-specific options, usually for compatibility with other compilers on the same platform.</source>
          <target state="translated">コンパイラのいくつかの設定では、同じプラットフォーム上の他のコンパイラとの互換性のために、ターゲット固有のオプションを追加でサポートしています。</target>
        </trans-unit>
        <trans-unit id="efc299e6d6d519531f7a42935a2ff0371856c97e" translate="yes" xml:space="preserve">
          <source>Some developers use Local Register Variables in an attempt to improve gcc&amp;rsquo;s allocation of registers, especially in large functions. In this case the register name is essentially a hint to the register allocator. While in some instances this can generate better code, improvements are subject to the whims of the allocator/optimizers. Since there are no guarantees that your improvements won&amp;rsquo;t be lost, this usage of Local Register Variables is discouraged.</source>
          <target state="translated">一部の開発者は、特に大規模な関数において、gccのレジスター割り当てを改善するためにローカルレジスター変数を使用します。この場合、レジスタ名は本質的にレジスタアロケータへのヒントです。これにより、より良いコードが生成される場合がありますが、改善はアロケータ/オプティマイザの気まぐれに左右されます。改善が失われないという保証はないため、このローカルレジスタ変数の使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="cd13c19c4da21f1c5afd2756424c80ed7c852869" translate="yes" xml:space="preserve">
          <source>Some devices support reading from flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions. The flash memory is seen in the data address space at an offset of &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt;. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put &lt;code&gt;.rodata&lt;/code&gt; into RAM. This is handled by the default linker description file, and is currently available for &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt;. Even more convenient, there is no need to use address spaces like &lt;code&gt;__flash&lt;/code&gt; or features like attribute &lt;code&gt;progmem&lt;/code&gt; and &lt;code&gt;pgm_read_*&lt;/code&gt;.</source>
          <target state="translated">一部のデバイスは、 &lt;code&gt;LD*&lt;/code&gt; 命令によるフラッシュメモリからの読み取りをサポートしています。フラッシュメモリは、 &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt; のオフセットでデータアドレス空間に表示されます。このマクロが定義されていない場合、この機能は使用できません。定義されている場合、アドレス空間は線形であり、 &lt;code&gt;.rodata&lt;/code&gt; をRAM に配置する必要はありません。これはデフォルトのリンカ記述ファイルによって処理され、現在 &lt;code&gt;avrtiny&lt;/code&gt; および &lt;code&gt;avrxmega3&lt;/code&gt; で使用できます。さらに便利なのは、 &lt;code&gt;__flash&lt;/code&gt; などのアドレススペースや、属性 &lt;code&gt;progmem&lt;/code&gt; や &lt;code&gt;pgm_read_*&lt;/code&gt; などの機能を使用する必要がないことです。</target>
        </trans-unit>
        <trans-unit id="12cca45385c65440f1fac5331dbdc800f8010a0a" translate="yes" xml:space="preserve">
          <source>Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.</source>
          <target state="translated">ISO C99 にはあるが C90 や C++にはないいくつかの機能も、拡張機能として C90 モードと C++で GCC に受け入れられています。</target>
        </trans-unit>
        <trans-unit id="768fab3712868916420b11c9d81a46a5d1e9bab0" translate="yes" xml:space="preserve">
          <source>Some file formats do not support arbitrary sections so the &lt;code&gt;section&lt;/code&gt; attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</source>
          <target state="translated">一部のファイル形式は任意のセクションをサポートしていないため、 &lt;code&gt;section&lt;/code&gt; 属性はすべてのプラットフォームで使用できるわけではありません。モジュールのコンテンツ全体を特定のセクションにマップする必要がある場合は、代わりにリンカーの機能を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="63737560dbee375bb4595f35dcce3b604d447957" translate="yes" xml:space="preserve">
          <source>Some function attributes take one or more arguments that refer to the function&amp;rsquo;s parameters by their positions within the function parameter list. Such attribute arguments are referred to as &lt;em&gt;positional arguments&lt;/em&gt;. Unless specified otherwise, positional arguments that specify properties of parameters with pointer types can also specify the same properties of the implicit C++ &lt;code&gt;this&lt;/code&gt; argument in non-static member functions, and of parameters of reference to a pointer type. For ordinary functions, position one refers to the first parameter on the list. In C++ non-static member functions, position one refers to the implicit &lt;code&gt;this&lt;/code&gt; pointer. The same restrictions and effects apply to function attributes used with ordinary functions or C++ member functions.</source>
          <target state="translated">一部の関数属性は、関数パラメーターリスト内の位置によって関数のパラメーターを参照する1つ以上の引数を取ります。このような属性引数は、&lt;em&gt;位置引数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。特に明記されていない限り、ポインター型のパラメーターのプロパティを指定する位置引数は、非静的メンバー関数の暗黙のC ++ &lt;code&gt;this&lt;/code&gt; 引数と、ポインター型への参照のパラメーターの同じプロパティを指定することもできます。通常の関数の場合、位置1はリストの最初のパラメーターを指します。 C ++非静的メンバー関数では、位置1は暗黙の &lt;code&gt;this&lt;/code&gt; ポインターを参照します。同じ制限と効果が、通常の関数またはC ++メンバー関数で使用される関数属性に適用されます。</target>
        </trans-unit>
        <trans-unit id="fb33f99a987006c02f399310559443d2a427b3a7" translate="yes" xml:space="preserve">
          <source>Some lines of information at the start have &lt;var&gt;line_number&lt;/var&gt; of zero. These preamble lines are of the form</source>
          <target state="translated">先頭の一部の情報行には、 &lt;var&gt;line_number&lt;/var&gt; がゼロになっています。これらのプリアンブル行は次の形式です</target>
        </trans-unit>
        <trans-unit id="9e5021e481328ac057640ef2a536800d9166dbbe" translate="yes" xml:space="preserve">
          <source>Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.</source>
          <target state="translated">リンカの中には、範囲外の呼び出しを検出して、その場でグルー・コードを生成できるものがあります。これらのシステムでは、長い呼び出しは不要で、より遅いコードを生成します。この記事を書いている時点で、AIXリンカはPowerPC/64用のGNUリンカと同様にこれを行うことができます。32ビットPowerPCシステム用のGNUリンカにも、この機能が追加される予定です。</target>
        </trans-unit>
        <trans-unit id="e7ded2d98e8ad6e738cfb416e0e144f7c6488a8f" translate="yes" xml:space="preserve">
          <source>Some machines never actually require alignment; they allow references to any data type even at an odd address. For these machines, &lt;code&gt;__alignof__&lt;/code&gt; reports the smallest alignment that GCC gives the data type, usually as mandated by the target ABI.</source>
          <target state="translated">一部のマシンでは、実際に位置合わせが必要になることはありません。奇数アドレスでも任意のデータ型を参照できます。これらのマシンの場合、 &lt;code&gt;__alignof__&lt;/code&gt; は、GCCがデータ型を提供する最小の境界整列を報告します。これは通常、ターゲットABIによって要求されます。</target>
        </trans-unit>
        <trans-unit id="e609cdc1429a6fcb8d2a4566b95c795a179f9f38" translate="yes" xml:space="preserve">
          <source>Some more examples of the use of &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; の使用例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="97a9b6bbb4ff568061400bba291a0fa95f27baca" translate="yes" xml:space="preserve">
          <source>Some object formats, like ELF, allow interposing of symbols by the dynamic linker. This means that for symbols exported from the DSO, the compiler cannot perform interprocedural propagation, inlining and other optimizations in anticipation that the function or variable in question may change. While this feature is useful, for example, to rewrite memory allocation functions by a debugging implementation, it is expensive in the terms of code quality. With</source>
          <target state="translated">ELF のようなオブジェクト・フォーマットの中には、ダイナミック・リンカによるシンボルの挿入を許可しているものがあります。これは、DSOからエクスポートされたシンボルに対して、コンパイラは、問題の関数や変数が変更される可能性があることを見越して、手順間伝播やインライン化などの最適化を行うことができないことを意味しています。この機能は、例えばデバッグ実装でメモリ割り当て関数を書き換える場合などに便利ですが、コード品質の面ではコストがかかります。この機能を利用して</target>
        </trans-unit>
        <trans-unit id="53b2cdebe3092f05376eba4dc6edb1163b208474" translate="yes" xml:space="preserve">
          <source>Some of these problems are due to bugs in other software, some are missing features that are too much work to add, and some are places where people&amp;rsquo;s opinions differ as to what is best.</source>
          <target state="translated">これらの問題のいくつかは他のソフトウェアのバグが原因であり、いくつかは追加するのにあまりにも多くの作業が不足している機能があり、いくつかは人々の意見が最良のものに関して異なる場所です。</target>
        </trans-unit>
        <trans-unit id="e5a8bcdbd9732dbb47db6e251241faa598f69eaa" translate="yes" xml:space="preserve">
          <source>Some operands need to be in particular places on the stack. All output operands fall in this category&amp;mdash;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.</source>
          <target state="translated">一部のオペランドは、スタックの特定の場所に配置する必要があります。すべての出力オペランドはこのカテゴリに分類されます。制約でこれを指定しない限り、GCCは出力がどのレジスタに現れるかを知る方法が他にありません。</target>
        </trans-unit>
        <trans-unit id="7bc3611475871be65cea3ae1eb8a4118c1e3da02" translate="yes" xml:space="preserve">
          <source>Some options for compiling C programs, such as</source>
          <target state="translated">などのCプログラムをコンパイルするためのいくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="9aab2dd921eb504a0a6bf04d60fa17f07ef07e59" translate="yes" xml:space="preserve">
          <source>Some options take one or more arguments typically separated either by a space or by the equals sign (&amp;lsquo;</source>
          <target state="translated">一部のオプションは、通常、スペースまたは等号（ '</target>
        </trans-unit>
        <trans-unit id="b09c01fb6d97b0be636c36b27746781fe632f575" translate="yes" xml:space="preserve">
          <source>Some options, such as</source>
          <target state="translated">のようないくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="8b764d6df82f9df721fda3ecd882ae472b0abef6" translate="yes" xml:space="preserve">
          <source>Some other command-line options starting with</source>
          <target state="translated">で始まる他のいくつかのコマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="2b1de7c862240cc77fd4597210b6bd463edb0754" translate="yes" xml:space="preserve">
          <source>Some spurious warnings can be avoided if you declare all the functions you use that never return as &lt;code&gt;noreturn&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; として戻らない、使用するすべての関数を宣言すると、いくつかの誤った警告を回避できます。&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b7a7ebb3620b1d731c5783bb7dadf2877e0be61" translate="yes" xml:space="preserve">
          <source>Some targets have a special register that holds the &amp;ldquo;flags&amp;rdquo; for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the &lt;code&gt;asm&lt;/code&gt; statement is considered to clobber the contents.</source>
          <target state="translated">一部のターゲットには、演算または比較の結果の「フラグ」を保持する特別なレジスターがあります。通常、そのレジスターの内容は、asmによって変更されないか、または &lt;code&gt;asm&lt;/code&gt; ステートメントが内容を上書きすると見なされます。</target>
        </trans-unit>
        <trans-unit id="ece7407fc707518ca6db13a249080d20314edfb1" translate="yes" xml:space="preserve">
          <source>Some targets require that GCC track the size of each instruction used in order to generate correct code. Because the final length of the code produced by an &lt;code&gt;asm&lt;/code&gt; statement is only known by the assembler, GCC must make an estimate as to how big it will be. It does this by counting the number of instructions in the pattern of the &lt;code&gt;asm&lt;/code&gt; and multiplying that by the length of the longest instruction supported by that processor. (When working out the number of instructions, it assumes that any occurrence of a newline or of whatever statement separator character is supported by the assembler &amp;mdash; typically &amp;lsquo;</source>
          <target state="translated">一部のターゲットでは、正しいコードを生成するために、GCCが使用される各命令のサイズを追跡する必要があります。 &lt;code&gt;asm&lt;/code&gt; ステートメントによって生成されるコードの最終的な長さはアセンブラーだけが知っているので、GCCはそれがどのくらいの大きさになるかを見積もる必要があります。これは、 &lt;code&gt;asm&lt;/code&gt; のパターン内の命令の数をカウントし、その数をそのプロセッサでサポートされている最長の命令の長さで乗算することによって行われます。 （命令の数を計算するとき、改行またはステートメント区切り文字の出現がアセンブラーによってサポートされていることを想定しています。通常、 '</target>
        </trans-unit>
        <trans-unit id="d9a576a0cb85284fa181b1af5cb015b4bd820399" translate="yes" xml:space="preserve">
          <source>Some targets, e.g. x86 and PowerPC, support the &lt;code&gt;#pragma ms_struct&lt;/code&gt; directive which lays out structures and unions subsequently defined as the documented &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt;.</source>
          <target state="translated">一部のターゲット（x86やPowerPCなど）は &lt;code&gt;#pragma ms_struct&lt;/code&gt; ディレクティブをサポートしています。これは、ドキュメント化された &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt; として後で定義される構造体と共用体をレイアウトします。</target>
        </trans-unit>
        <trans-unit id="32c528c0b130160ed58ee14f8bbba2d7a132054b" translate="yes" xml:space="preserve">
          <source>Some users try to use</source>
          <target state="translated">を使おうとするユーザーもいます。</target>
        </trans-unit>
        <trans-unit id="c714f3fa36461f2e5681ce26cd399297f4a56453" translate="yes" xml:space="preserve">
          <source>Some users try to use &lt;code&gt;__STDC__&lt;/code&gt; to check for the availability of certain library facilities. This is actually incorrect usage in an ISO C program, because the ISO C standard says that a conforming freestanding implementation should define &lt;code&gt;__STDC__&lt;/code&gt; even though it does not have the library facilities. &amp;lsquo;</source>
          <target state="translated">一部のユーザーは、 &lt;code&gt;__STDC__&lt;/code&gt; を使用して、特定のライブラリ機能の可用性を確認しようとします。これは、実際にはISO Cプログラムでの誤った使用法です。これは、ISO C標準では、ライブラリ機能がない場合でも、準拠する独立型実装では &lt;code&gt;__STDC__&lt;/code&gt; を定義する必要があるためです。」</target>
        </trans-unit>
        <trans-unit id="6c0811681aff3d220c177a6ae42df51a4668d70d" translate="yes" xml:space="preserve">
          <source>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another.</source>
          <target state="translated">1 つの命令で複数のオペランドを組み合わせることができる場合があります。例えば、68000では、論理和命令はレジスタや即時値をメモリに結合したり、任意のオペランドをレジスタに結合したりすることができますが、あるメモリの位置を別の位置に結合することはできません。</target>
        </trans-unit>
        <trans-unit id="bcdf40850f5e7d0e40bbaa8bc961e1b76a034440" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to write code using a mix of generic vector operations (for clarity) and machine-specific vector intrinsics (to access vector instructions that are not exposed via generic built-ins). On x86, intrinsic functions for integer vectors typically use the same vector type &lt;code&gt;__m128i&lt;/code&gt; irrespective of how they interpret the vector, making it necessary to cast their arguments and return values from/to other vector types. In C, you can make use of a &lt;code&gt;union&lt;/code&gt; type:</source>
          <target state="translated">ジェネリックベクトル演算（わかりやすくするため）とマシン固有のベクトル組み込み関数（ジェネリックビルトインを介して公開されていないベクトル命令にアクセスするため）を組み合わせてコードを記述することが望ましい場合があります。x86では、整数ベクトルの組み込み関数は、通常、ベクトルの解釈方法に関係なく、同じベクトルタイプ &lt;code&gt;__m128i&lt;/code&gt; を使用するため、引数をキャストし、他のベクトルタイプとの間で値を返す必要があります。Cでは、 &lt;code&gt;union&lt;/code&gt; 体型を使用できます。</target>
        </trans-unit>
        <trans-unit id="e7b9f7e78924f4429d79b3875d59ae1541b656fb" translate="yes" xml:space="preserve">
          <source>Sometimes people say that defining &lt;code&gt;__STDC__&lt;/code&gt; in a compiler that does not completely conform to the ISO C standard somehow violates the standard. This is illogical. The standard is a standard for compilers that claim to support ISO C, such as &amp;lsquo;</source>
          <target state="translated">ISO C標準に完全に準拠していないコンパイラで &lt;code&gt;__STDC__&lt;/code&gt; を定義すると、何らかの形で標準に違反すると言われることがあります。これは非論理的です。標準は、ISO Cをサポートすると主張するコンパイラの標準です。</target>
        </trans-unit>
        <trans-unit id="c41073d5b9e69b8696bff1b0838e6f995522031e" translate="yes" xml:space="preserve">
          <source>Sort the symbols according to size.</source>
          <target state="translated">大きさに応じてシンボルを並べ替えます。</target>
        </trans-unit>
        <trans-unit id="f71bf34c2cf4ef01fa642de620de6d3ffbf6ba33" translate="yes" xml:space="preserve">
          <source>Sort the symbols alphabetically.</source>
          <target state="translated">記号をアルファベット順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="8110c50df0a3ae32bff485105c38a69468d7fdd2" translate="yes" xml:space="preserve">
          <source>Special constraints for some particular machines.</source>
          <target state="translated">いくつかの特定のマシンのための特別な制約。</target>
        </trans-unit>
        <trans-unit id="2ba4930cab85f2e9501af3573b08b92708f7a0ae" translate="yes" xml:space="preserve">
          <source>Special format strings</source>
          <target state="translated">特殊な形式の文字列</target>
        </trans-unit>
        <trans-unit id="2a9d5504a562859df5546c189640d36f2ebdc1bd" translate="yes" xml:space="preserve">
          <source>Special syntax for implementing &lt;code&gt;offsetof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; を実装するための特別な構文。</target>
        </trans-unit>
        <trans-unit id="253477bfce70caeee68c5d46f4cbdd5958d04b09" translate="yes" xml:space="preserve">
          <source>Specifier</source>
          <target state="translated">Specifier</target>
        </trans-unit>
        <trans-unit id="fae65de83d82c109b91ff281d719a67482b13328" translate="yes" xml:space="preserve">
          <source>Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">出力を保持するための C lvalue 式を指定します。括弧で囲んだ部分は、構文の必須部分です。</target>
        </trans-unit>
        <trans-unit id="05513a361baed0fc6bc2b4e7e1181bfda41a5c6c" translate="yes" xml:space="preserve">
          <source>Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. &amp;lsquo;</source>
          <target state="translated">オペランドの記号名を指定します。角かっこで囲んでアセンブラテンプレート内の名前を参照します（つまり、 '</target>
        </trans-unit>
        <trans-unit id="c765ec9a6362d918fb2bf1565e87927ec8cd6358" translate="yes" xml:space="preserve">
          <source>Specifies general-purposes registers that the processor automatically saves/restores on interrupt entry and exit. &lt;var&gt;register-range&lt;/var&gt; is specified as two registers separated by a dash. The register range always starts with &lt;code&gt;r0&lt;/code&gt;, the upper limit is &lt;code&gt;fp&lt;/code&gt; register. &lt;var&gt;blink&lt;/var&gt; and &lt;var&gt;lp_count&lt;/var&gt; are optional. This option is only valid for ARC EM and ARC HS cores.</source>
          <target state="translated">割り込みの開始および終了時にプロセッサが自動的に保存/復元する汎用レジスタを指定します。 &lt;var&gt;register-range&lt;/var&gt; は、ダッシュで区切られた2つのレジスタとして指定されます。レジスタ範囲は常に &lt;code&gt;r0&lt;/code&gt; で始まり、上限は &lt;code&gt;fp&lt;/code&gt; レジスタです。 &lt;var&gt;blink&lt;/var&gt; および &lt;var&gt;lp_count&lt;/var&gt; はオプションです。このオプションは、ARC EMおよびARC HSコアでのみ有効です。</target>
        </trans-unit>
        <trans-unit id="f3854791e88bad573a0be4f46ed869cefa1b475c" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large function caused by inlining in percents. For example, parameter value 100 limits large function growth to 2.0 times the original size.</source>
          <target state="translated">パーセンテージでのインライン化によるラージ関数の最大成長量を指定します。例えば、パラメータ値100では、ラージ関数の成長は元のサイズの2.0倍に制限されます。</target>
        </trans-unit>
        <trans-unit id="dfe06371f415167055f13157f6cd31af5c5dbd88" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large stack frames caused by inlining in percents. For example, parameter value 1000 limits large stack frame growth to 11 times the original size.</source>
          <target state="translated">パーセンテージでのインライン化による大きなスタックフレームの最大成長量を指定します。例えば、パラメータ値 1000 は、ラージスタックフレームの成長を元のサイズの 11 倍に制限します。</target>
        </trans-unit>
        <trans-unit id="94731e3c8ea6ab127a428ca6dbbe480337db1263" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by inlining. For example, parameter value 20 limits unit growth to 1.2 times the original size. Cold functions (either marked cold via an attribute or by profile feedback) are not accounted into the unit size.</source>
          <target state="translated">インライン化によるコンパイル単位の全体的な成長の最大値を指定します。例えば、パラメータ値 20 は、ユニットの成長を元のサイズの 1.2 倍に制限します。コールド関数(属性によってコールドとマークされているか、プロファイル・フィードバックによってコールドとマークされているかのいずれか)は、ユニット・サイズには考慮されません。</target>
        </trans-unit>
        <trans-unit id="f6a6169df4d1b9f4ae3a854ae149c4bc3eb831c7" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. For example, parameter value 10 limits unit growth to 1.1 times the original size.</source>
          <target state="translated">手順間の定数伝播によるコンパイルユニットの全体的な成長の最大値を指定します。例えば、パラメータ値10では、ユニットの成長を元のサイズの1.1倍に制限します。</target>
        </trans-unit>
        <trans-unit id="c09858fd018d531b5e4ff4ecd665a6f14de1bdc3" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the MDUC registers. This is only necessary if normal code might use the MDUC registers, for example because it performs multiplication and division operations. The default is to ignore the MDUC registers as this makes the interrupt handlers faster. The target option -mg13 needs to be passed for this to work as this feature is only available on the G13 target (S2 core). The MDUC registers will only be saved if the interrupt handler performs a multiplication or division operation or it calls another function.</source>
          <target state="translated">割り込みハンドラ関数がMDUCレジスタを保存することを指定します。これは通常のコードで乗算や除算を行う場合など、MDUCレジスタを使用する可能性がある場合にのみ必要です。デフォルトでは MDUC レジスタを無視します。この機能はG13ターゲット(S2コア)でのみ利用可能なので、この機能を動作させるにはターゲットオプション -mg13を渡す必要があります。MDUCレジスタが保存されるのは、割込みハンドラが乗算や除算を行った場合や他の関数を呼び出した場合のみです。</target>
        </trans-unit>
        <trans-unit id="e16a3667d78dbf88b960c5650973c17d00b701b4" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the accumulator register. This is only necessary if normal code might use the accumulator register, for example because it performs 64-bit multiplications. The default is to ignore the accumulator as this makes the interrupt handlers faster.</source>
          <target state="translated">割り込みハンドラ関数がアキュムレータ・レジスタを保存することを指定します。これは、通常のコードが64ビットの乗算を行うなど、アキュムレータ・レジスタを使用する可能性がある場合にのみ必要です。デフォルトではアキュムレータを無視するように設定されています。</target>
        </trans-unit>
        <trans-unit id="b7effad23ab12e24339284e6f0eafe7d16434faa" translate="yes" xml:space="preserve">
          <source>Specifies that the PRU CTABLE entry given by &lt;var&gt;index&lt;/var&gt; has the value &lt;var&gt;constant_address&lt;/var&gt;. This enables GCC to emit LBCO/SBCO instructions when the load/store address is known and can be addressed with some CTABLE entry. For example:</source>
          <target state="translated">&lt;var&gt;index&lt;/var&gt; で指定されたPRUCTABLEエントリの値が &lt;var&gt;constant_address&lt;/var&gt; であることを指定します。これにより、ロード/ストアアドレスがわかっていて、CTABLEエントリでアドレス指定できる場合に、GCCがLBCO / SBCO命令を発行できるようになります。例えば：</target>
        </trans-unit>
        <trans-unit id="dd671f6f6086870972e15aa7905ec8f7db267ac7" translate="yes" xml:space="preserve">
          <source>Specifies that the cache cannot be flushed by using a trap.</source>
          <target state="translated">トラップを使用してキャッシュをフラッシュできないことを指定します。</target>
        </trans-unit>
        <trans-unit id="47947b45b4744585e55d8f763014a0ae39516e00" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime library to be linked in which supports, for example, file I/O. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">プログラムをシミュレータ上で実行することを指定します。これにより、ファイル I/O などをサポートする代替ランタイム・ライブラリがリンクされます。実際のハードウェア上で実行されるプログラムを生成する場合は、このオプションを使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="92a7b7c9a6c346e8818d5fec33b1b2c04de8591c" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime startup and library to be linked. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">プログラムをシミュレータ上で実行することを指定します。これにより、代替ランタイム起動とライブラリがリンクされます。実際のハードウェア上で実行されるプログラムを生成する場合は、このオプションを使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="cc31c50b75b75e6cf86f872d21ade4b77825de9f" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes the simulator BSP provided by libgloss to be linked in. This option has effect only for &amp;lsquo;</source>
          <target state="translated">プログラムがシミュレーターで実行されることを指定します。これにより、libglossによって提供されるシミュレーターBSPがリンクされます。このオプションは、 '</target>
        </trans-unit>
        <trans-unit id="4b908ebdba88cf2c2a293fda93618017153fd58b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">外部ライブラリを使用して組み込みをベクトル化するために使用するABIタイプを指定します。 &lt;var&gt;type&lt;/var&gt; サポートされている値は '</target>
        </trans-unit>
        <trans-unit id="df8e8fddb7d07761c1b84aad23b4814d921c564b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. The only type supported at present is &amp;lsquo;</source>
          <target state="translated">外部ライブラリを使用して組み込みをベクトル化するために使用するABIタイプを指定します。現在サポートされている唯一のタイプは '</target>
        </trans-unit>
        <trans-unit id="3e1277fdc0689b726ff15cccd084ddbac36979fe" translate="yes" xml:space="preserve">
          <source>Specifies the ISA to use. Accepted values are &amp;lsquo;</source>
          <target state="translated">使用するISAを指定します。受け入れられる値は '</target>
        </trans-unit>
        <trans-unit id="5ca955df8b960b04d79d7dd74115e500bda85663" translate="yes" xml:space="preserve">
          <source>Specifies the RL78 core to target. The default is the G14 core, also known as an S3 core or just RL78. The G13 or S2 core does not have multiply or divide instructions, instead it uses a hardware peripheral for these operations. The G10 or S1 core does not have register banks, so it uses a different calling convention.</source>
          <target state="translated">ターゲットとするRL78コアを指定します。既定値は G14 コアで、S3 コアまたは RL78 コアとしても知られています。G13 または S2 コアには乗算または除算命令がなく、その代わりにこれらの演算にハードウェア・ペリフェラルを使用します。G10 または S1 コアにはレジスタバンクがないため、異なる呼び出し規則を使用します。</target>
        </trans-unit>
        <trans-unit id="f635669de18bf56a687958d1a8c71186afb495b2" translate="yes" xml:space="preserve">
          <source>Specifies the TLS dialect to use for this function. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">この関数で使用する TLS 方言を指定します。動作および許容される引数は、コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="c52b2c30fecaf2eb67f980f2baf7835c6acbf2e9" translate="yes" xml:space="preserve">
          <source>Specifies the architecture version and architectural extensions to use for this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">この関数で使用するアーキテクチャのバージョンとアーキテクチャ拡張を指定します。挙動と許容される引数は</target>
        </trans-unit>
        <trans-unit id="dbbb7ebc147f28ae0dcd4250f31f3d8fd9cac55e" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function and also whose architectural features to use. The behavior and valid arguments are the same as for the</source>
          <target state="translated">この関数のパフォーマンスを調整するコアと、使用するアーキテクチャ機能を指定します。動作と有効な引数は</target>
        </trans-unit>
        <trans-unit id="fe58a5c95595be8f2a1ff92d9451c73415b5a99d" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">この関数のパフォーマンスを調整するコアを指定します。振る舞いと許容される引数は</target>
        </trans-unit>
        <trans-unit id="28873c2fbf7d823a74544bebc8a6344119496c82" translate="yes" xml:space="preserve">
          <source>Specifies the fpu for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">この関数のパフォーマンスを調整するための fpu を指定します。挙動と許容される引数は</target>
        </trans-unit>
        <trans-unit id="cce88289fcb8b24761c893dbf247fdd528b95133" translate="yes" xml:space="preserve">
          <source>Specifies the function to call to flush the I and D caches, or to not call any such function. If called, the function must take the same arguments as the common &lt;code&gt;_flush_func&lt;/code&gt;, that is, the address of the memory range for which the cache is being flushed, the size of the memory range, and the number 3 (to flush both caches). The default depends on the target GCC was configured for, but commonly is either &lt;code&gt;_flush_func&lt;/code&gt; or &lt;code&gt;__cpu_flush&lt;/code&gt;.</source>
          <target state="translated">IおよびDキャッシュをフラッシュするために呼び出す関数、またはそのような関数を呼び出さないように指定します。呼び出された場合、関数は共通の &lt;code&gt;_flush_func&lt;/code&gt; と同じ引数、つまり、キャッシュがフラッシュされるメモリ範囲のアドレス、メモリ範囲のサイズ、および数値3（両方のキャッシュをフラッシュする）を取る必要があります。デフォルトは、GCCが構成されたターゲットによって異なりますが、通常は &lt;code&gt;_flush_func&lt;/code&gt; または &lt;code&gt;__cpu_flush&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7671feaad590d7ec398f51bb4af652d4dc88ce38" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">コンパイルする ID ベースの共有ライブラリの識別番号を指定します。0を指定するとよりコンパクトなコードが生成されます。それ以外の値を指定すると、その番号が現在のライブラリに強制的に割り当てられますが、このオプションを省略するよりもスペース的にも時間的にも効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="99738458ed498047e95197f3c00800b279d2d584" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library, but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">コンパイルする ID ベースの共有ライブラリの識別番号を指定します。0を指定するとよりコンパクトなコードが生成されます。それ以外の値を指定すると、その番号が現在のライブラリに強制的に割り当てられますが、このオプションを省略するよりもスペース的にも時間的にも効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="c1e382c74800682d2e9f3b74a1844826dd2ecb62" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.</source>
          <target state="translated">自己再帰的インライン関数のアウトオブラインコピーが、再帰的インライン化を実行して成長できる命令の最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="a5e540e476e706af7ae2a630f97b45afd6de5bb3" translate="yes" xml:space="preserve">
          <source>Specifies the maximum recursion depth used for recursive inlining.</source>
          <target state="translated">再帰的なインライン化に使用する最大再帰深度を指定します。</target>
        </trans-unit>
        <trans-unit id="842831f7e4e5d29f3e7d0beec2854a0216bc6e42" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size in bytes of global and static variables which can be placed into the small data area. Using the small data area can lead to smaller and faster code, but the size of area is limited and it is up to the programmer to ensure that the area does not overflow. Also when the small data area is used one of the RX&amp;rsquo;s registers (usually &lt;code&gt;r13&lt;/code&gt;) is reserved for use pointing to this area, so it is no longer available for use by the compiler. This could result in slower and/or larger code if variables are pushed onto the stack instead of being held in this register.</source>
          <target state="translated">小さなデータ領域に配置できるグローバル変数と静的変数の最大サイズをバイト単位で指定します。小さいデータ領域を使用すると、コードが小さくて高速になりますが、領域のサイズには制限があり、領域がオーバーフローしないようにするのはプログラマの責任です。また、小さいデータ領域が使用される場合、RXのレジスターの1つ（通常は &lt;code&gt;r13&lt;/code&gt; ）がこの領域を指すために予約されているため、コンパイラーは使用できなくなります。これにより、変数がこのレジスターに保持されずにスタックにプッシュされると、コードが遅くなったり、コードが大きくなったりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="7412a6cb9b0e0f8b6e7f0d0e77fd2140ccfb86a1" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size, in bytes, of a constant that can be used as an operand in a RX instruction. Although the RX instruction set does allow constants of up to 4 bytes in length to be used in instructions, a longer value equates to a longer instruction. Thus in some circumstances it can be beneficial to restrict the size of constants that are used in instructions. Constants that are too big are instead placed into a constant pool and referenced via register indirection.</source>
          <target state="translated">RX 命令でオペランドとして使用できる定数の最大サイズをバイト単位で指定します。RX命令セットでは、命令で使用できる定数の長さは4バイトまでですが、値が長くなると命令が長くなります。そのため、状況によっては命令で使用する定数のサイズを制限することが有益な場合があります。大きすぎる定数は定数プールに入れられ、レジスタ間接参照で参照されます。</target>
        </trans-unit>
        <trans-unit id="f498cab10962b0798c0931ba2f63475387ade694" translate="yes" xml:space="preserve">
          <source>Specifies the name of the operating system function to call to flush the cache. The default is &amp;lsquo;</source>
          <target state="translated">キャッシュをフラッシュするために呼び出すオペレーティングシステム関数の名前を指定します。デフォルトは '</target>
        </trans-unit>
        <trans-unit id="4cb9f9dd93932f78051a635c26202d7d8e5535cd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the target Blackfin processor. Currently, &lt;var&gt;cpu&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">ターゲットBlackfinプロセッサの名前を指定します。現在、 &lt;var&gt;cpu&lt;/var&gt; は '</target>
        </trans-unit>
        <trans-unit id="c0803aab785a2e20aedd243e17212d6d9ce8548e" translate="yes" xml:space="preserve">
          <source>Specifies the number of memory-based pseudo-registers GCC uses during code generation. These pseudo-registers are used like real registers, so there is a tradeoff between GCC&amp;rsquo;s ability to fit the code into available registers, and the performance penalty of using memory instead of registers. Note that all modules in a program must be compiled with the same value for this option. Because of that, you must not use this option with GCC&amp;rsquo;s default runtime libraries.</source>
          <target state="translated">コード生成中にGCCが使用するメモリベースの疑似レジスタの数を指定します。これらの疑似レジスターは実際のレジスターのように使用されるため、使用可能なレジスターにコードを適合させるGCCの機能と、レジスターの代わりにメモリーを使用することによるパフォーマンス上のペナルティの間にはトレードオフがあります。プログラム内のすべてのモジュールは、このオプションの同じ値でコンパイルする必要があることに注意してください。そのため、GCCのデフォルトのランタイムライブラリではこのオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="22f3ed905850cb42bd6d50bb52af7907bc7a581e" translate="yes" xml:space="preserve">
          <source>Specifies the number of registers replicated in second register bank on entry to fast interrupt. Fast interrupts are interrupts with the highest priority level P0. These interrupts save only PC and STATUS32 registers to avoid memory transactions during interrupt entry and exit sequences. Use this option when you are using fast interrupts in an ARC V2 family processor. Permitted values are 4, 8, 16, and 32.</source>
          <target state="translated">高速割込み入力時に第2レジスタバンクに複製するレジスタ数を指定します。高速割込みは最優先レベルP0の割込みです。これらの割込みは、割込みのエントリシーケンスとエグジットシーケンスの間のメモリトランザクションを回避するために、PCとSTATUS32レジスタのみを保存します。ARC V2 ファミリ・プロセッサで高速割込みを使用する場合は、このオプションを使用してください。許容値は4、8、16、32です。</target>
        </trans-unit>
        <trans-unit id="affdb413ade6c559688aa8325514465c16425b76" translate="yes" xml:space="preserve">
          <source>Specifies the trap number to use to flush the cache. The default is 12. Valid numbers are between 0 and 15 inclusive.</source>
          <target state="translated">キャッシュのフラッシュに使用するトラップ番号を指定します。デフォルトは 12 です。有効な番号は 0 から 15 までの間です。</target>
        </trans-unit>
        <trans-unit id="c90e51847549c6d7bfb26f9d83f651beb9507ea1" translate="yes" xml:space="preserve">
          <source>Specifies the type of hardware multiplication and division support to be used. The simplest is &lt;code&gt;none&lt;/code&gt;, which uses software for both multiplication and division. This is the default. The &lt;code&gt;g13&lt;/code&gt; value is for the hardware multiply/divide peripheral found on the RL78/G13 (S2 core) targets. The &lt;code&gt;g14&lt;/code&gt; value selects the use of the multiplication and division instructions supported by the RL78/G14 (S3 core) parts. The value &lt;code&gt;rl78&lt;/code&gt; is an alias for &lt;code&gt;g14&lt;/code&gt; and the value &lt;code&gt;mg10&lt;/code&gt; is an alias for &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">使用するハードウェア乗算および除算サポートのタイプを指定します。最も単純なのは &lt;code&gt;none&lt;/code&gt; で、乗算と除算の両方にソフトウェアを使用します。これがデフォルトです。 &lt;code&gt;g13&lt;/code&gt; 値は、RL78 / G13（S2コア）ターゲット上のハードウェア乗算/除算周辺FOUNDするためのものです。 &lt;code&gt;g14&lt;/code&gt; 値は、RL78 / G14（S3コア）部分によって支持され、乗算及び除算命令を使用することを選択します。値 &lt;code&gt;rl78&lt;/code&gt; の別名である &lt;code&gt;g14&lt;/code&gt; 及び値 &lt;code&gt;mg10&lt;/code&gt; の別名である &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f81d16d95cc0305e73b474da06956f8e11e96d3" translate="yes" xml:space="preserve">
          <source>Specifies whether FP exceptions are enabled. This affects how FP instructions are scheduled for some processors. The default is that FP exceptions are enabled.</source>
          <target state="translated">FP 例外を有効にするかどうかを指定します。これは、一部のプロセッサで FP 命令がどのようにスケジュールされるかに影響します。既定では、FP 例外が有効になっています。</target>
        </trans-unit>
        <trans-unit id="72b43446cb2dd4e94fe26ad69b18b9bf05535ef3" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are available to the register allocator. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">レジスタアロケータで使用できるコプロセッサレジスタを指定します。 &lt;var&gt;registers&lt;/var&gt; は、単一のレジスター、省略記号で区切られたレジスター範囲、またはそれらのコンマ区切りのリストです。例：</target>
        </trans-unit>
        <trans-unit id="0598db288f6f533223b56d068b56fd87125317c1" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are to be saved and restored by any function using them. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">どのコプロセッサー・レジスターを使用する関数によって保存および復元されるかを指定します。 &lt;var&gt;registers&lt;/var&gt; は、単一のレジスター、省略記号で区切られたレジスター範囲、またはそれらのコンマ区切りのリストです。例：</target>
        </trans-unit>
        <trans-unit id="c1b3620228a9a55d3a61b6172646e0fda8c7d9e2" translate="yes" xml:space="preserve">
          <source>Specifies which floating-point ABI to use. Permissible values are: &amp;lsquo;</source>
          <target state="translated">使用する浮動小数点ABIを指定します。許容値は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="b7d7c4da380841e46021fb0ca037b1a5efba92c6" translate="yes" xml:space="preserve">
          <source>Specify &lt;var&gt;prefix&lt;/var&gt; as the prefix for subsequent</source>
          <target state="translated">後続の &lt;var&gt;prefix&lt;/var&gt; としてプレフィックスを指定します</target>
        </trans-unit>
        <trans-unit id="a1b75d36373bf0a158266aad4b0685acf54bdd9f" translate="yes" xml:space="preserve">
          <source>Specify Atmel AVR instruction set architectures (ISA) or MCU type.</source>
          <target state="translated">Atmel AVR命令セットアーキテクチャ(ISA)またはMCUタイプを指定します。</target>
        </trans-unit>
        <trans-unit id="d5ced711925ce2b86f2945855d11a9f765bdf3b8" translate="yes" xml:space="preserve">
          <source>Specify a register to hold the constant -1, which makes loading small negative constants and certain bitmasks faster. Allowable values for &lt;var&gt;reg&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">定数-1を保持するレジスタを指定すると、小さな負の定数と特定のビットマスクの読み込みが速くなります。 &lt;var&gt;reg&lt;/var&gt; の許容値は '</target>
        </trans-unit>
        <trans-unit id="ee4e72d685bf13ccdca2b955146686e94f4dd820" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 12, 24, 32, 48. This option requires binutils 2.26 or newer.</source>
          <target state="translated">即時TLSオフセットのビットサイズを指定します。有効な値は 12,24,32,48 です。このオプションを使用するには、binutils 2.26 以降が必要です。</target>
        </trans-unit>
        <trans-unit id="0ee5fd4c06f208dc72a94346beb5b066cc520b6c" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 14, 22, and 64.</source>
          <target state="translated">即時TLSオフセットのビットサイズを指定します。有効な値は14、22、64です。</target>
        </trans-unit>
        <trans-unit id="e3d343f19f5a896581a51d8a250efd477d791df5" translate="yes" xml:space="preserve">
          <source>Specify both</source>
          <target state="translated">両方を指定する</target>
        </trans-unit>
        <trans-unit id="790583d2504db1e70b776b6337942849b2d5671c" translate="yes" xml:space="preserve">
          <source>Specify default compute dimensions for parallel offload regions that do not explicitly specify. The &lt;var&gt;geom&lt;/var&gt; value is a triple of &amp;rsquo;:&amp;rsquo;-separated sizes, in order &amp;rsquo;gang&amp;rsquo;, &amp;rsquo;worker&amp;rsquo; and, &amp;rsquo;vector&amp;rsquo;. A size can be omitted, to use a target-specific default value.</source>
          <target state="translated">明示的に指定しない並列オフロード領域のデフォルトの計算次元を指定します。 &lt;var&gt;geom&lt;/var&gt; 分離されたサイズ、順番に「ギャング」、「従業員」と、「ベクトル」 - 「」値は三重であります。ターゲット固有のデフォルト値を使用するには、サイズを省略できます。</target>
        </trans-unit>
        <trans-unit id="d0c09fd54e93619fc886af47d25ab910da3f1f1d" translate="yes" xml:space="preserve">
          <source>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation.</source>
          <target state="translated">WHOPRのコンパイル中に生成されるパーティションの数を指定する。パーティションの数は、コンパイルに使用するCPUの数を超えている必要があります。</target>
        </trans-unit>
        <trans-unit id="ddd74922c1fffe0660ee607e7c8c05e6b9c36231" translate="yes" xml:space="preserve">
          <source>Specify either the directory containing the gcov data files, or the object path name. The</source>
          <target state="translated">gcovデータファイルが格納されているディレクトリ、またはオブジェクトのパス名を指定します。このディレクトリには</target>
        </trans-unit>
        <trans-unit id="a8bb63ac54bf2ea3fd989f2a3dede75fee9c409d" translate="yes" xml:space="preserve">
          <source>Specify explicitly the &lt;var&gt;language&lt;/var&gt; for the following input files (rather than letting the compiler choose a default based on the file name suffix). This option applies to all following input files until the next</source>
          <target state="translated">次の入力ファイルの &lt;var&gt;language&lt;/var&gt; を明示的に指定します（コンパイラーにファイル名のサフィックスに基づいてデフォルトを選択させるのではなく）。このオプションは、次のすべての入力ファイルに適用されます。</target>
        </trans-unit>
        <trans-unit id="1dece3d1baf820f578333563e62b95b8ee062ffd" translate="yes" xml:space="preserve">
          <source>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty.</source>
          <target state="translated">初期インライナーができる成長を指定します。実際には、抽象化のペナルティが大きいコードのインライン化の量を増やします。</target>
        </trans-unit>
        <trans-unit id="8b0123ff59c8271225f538f6c8fc4517d3e5946e" translate="yes" xml:space="preserve">
          <source>Specify how many &lt;var&gt;bytes&lt;/var&gt; of stack space will be requested for each GPU thread (wave-front). Beware that there may be many threads and limited memory available. The size of the stack allocation may also have an impact on run-time performance. The default is 32KB when using OpenACC or OpenMP, and 1MB otherwise.</source>
          <target state="translated">各GPUスレッド（ウェーブフロント）に要求されるスタックスペースの &lt;var&gt;bytes&lt;/var&gt; を指定します。多くのスレッドがあり、使用可能なメモリが限られている場合があることに注意してください。スタック割り当てのサイズも、実行時のパフォーマンスに影響を与える可能性があります。OpenACCまたはOpenMPを使用する場合のデフォルトは32KB、それ以外の場合は1MBです。</target>
        </trans-unit>
        <trans-unit id="6b4cd64add8e5ab4a64ac446bfe3679786b4245a" translate="yes" xml:space="preserve">
          <source>Specify how to print paths of control-flow events for diagnostics that have such a path associated with them.</source>
          <target state="translated">このようなパスが関連付けられている診断用のコントロールフローイベントのパスを印刷する方法を指定します。</target>
        </trans-unit>
        <trans-unit id="de9c99e300af9c8b6bed1288c468edd9f4ff0049" translate="yes" xml:space="preserve">
          <source>Specify integer and floating-point calling convention. &lt;var&gt;ABI-string&lt;/var&gt; contains two parts: the size of integer types and the registers used for floating-point types. For example &amp;lsquo;</source>
          <target state="translated">整数と浮動小数点の呼び出し規約を指定します。 &lt;var&gt;ABI-string&lt;/var&gt; は、整数型のサイズと浮動小数点型に使用されるレジスターの2つの部分が含まれます。例えば ​​'</target>
        </trans-unit>
        <trans-unit id="d83c8944a923ba0afcb420deeb5f2d35c92d90c2" translate="yes" xml:space="preserve">
          <source>Specify that intrinsic library functions are being compiled, passing all values in registers, no matter the size.</source>
          <target state="translated">サイズに関係なく、すべての値をレジスタに渡してコンパイルすることを指定します。</target>
        </trans-unit>
        <trans-unit id="ece1c6c2bc5985e3475fb38d94d339c81045f6ff" translate="yes" xml:space="preserve">
          <source>Specify that the assembler should encode SSE instructions with VEX prefix. The option</source>
          <target state="translated">アセンブラがSSE命令をVEX接頭辞でエンコードすることを指定します。オプション</target>
        </trans-unit>
        <trans-unit id="b6e1f7a9d2a1718382e7b4d035866fa5b223eb27" translate="yes" xml:space="preserve">
          <source>Specify that the program entry point is &lt;var&gt;entry&lt;/var&gt;. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</source>
          <target state="translated">プログラムのエントリポイントが &lt;var&gt;entry&lt;/var&gt; であることを指定します。引数はリンカによって解釈されます。GNUリンカーは、シンボル名またはアドレスのいずれかを受け入れます。</target>
        </trans-unit>
        <trans-unit id="109f76cb76b9bdcac0640d708d9f5aa531701516" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850.</source>
          <target state="translated">ターゲット・プロセッサは V850 を指定してください。</target>
        </trans-unit>
        <trans-unit id="e795d47484c6aa284871594487a90d959a680146" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E. The preprocessor constant &lt;code&gt;__v850e__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">ターゲットプロセッサがV850Eであることを指定します。このオプションを使用すると、プリプロセッサ定数 &lt;code&gt;__v850e__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="8b95c4ac2d723888f85d1eb5d22f7c525dcae0da" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E1. The preprocessor constants &lt;code&gt;__v850e1__&lt;/code&gt; and &lt;code&gt;__v850e__&lt;/code&gt; are defined if this option is used.</source>
          <target state="translated">ターゲットプロセッサがV850E1であることを指定します。このオプションを使用すると、プリプロセッサ定数 &lt;code&gt;__v850e1__&lt;/code&gt; および &lt;code&gt;__v850e__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="978d09824c615036a75f151e3f181a0c030be29d" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2. The preprocessor constant &lt;code&gt;__v850e2__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">ターゲットプロセッサがV850E2であることを指定します。このオプションを使用すると、プリプロセッサ定数 &lt;code&gt;__v850e2__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="ed32c1d3fe9b0d91dac78559f89b829020d693b3" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2V3. The preprocessor constant &lt;code&gt;__v850e2v3__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">ターゲットプロセッサがV850E2V3であることを指定します。このオプションを使用すると、プリプロセッサ定数 &lt;code&gt;__v850e2v3__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="45dfef0c4ebf051e18bbb6d800fab624cbb970fb" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. The preprocessor constant &lt;code&gt;__v850e3v5__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">ターゲットプロセッサがV850E3V5であることを指定します。このオプションを使用すると、プリプロセッサ定数 &lt;code&gt;__v850e3v5__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="c53303aa9a3d3e7e971e5fac1f2e4c19510c6915" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. This is an alias for the</source>
          <target state="translated">ターゲット・プロセッサが V850E3V5 であることを指定します。のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="f54503d1104c416ab9f70cb3eb9892d2467505fc" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850ES. This is an alias for the</source>
          <target state="translated">ターゲット・プロセッサが V850ES であることを指定します。のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="ffbfc8af222c9971b65ff46dc8c44a1dab74c77d" translate="yes" xml:space="preserve">
          <source>Specify the ABI variant to output code for.</source>
          <target state="translated">コードを出力する ABI バリアントを指定します。</target>
        </trans-unit>
        <trans-unit id="20a7ba111bd81efdcb44d105c109fea8a9201317" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target architecture. Valid values for &lt;var&gt;arch&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">C-SKYターゲットアーキテクチャを指定します。 &lt;var&gt;arch&lt;/var&gt; の有効な値は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="11e0bbd00da02b87a4bf01c5c95da5cd4e1c7d2f" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target processor. Valid values for &lt;var&gt;cpu&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">C-SKYターゲットプロセッサを指定します。 &lt;var&gt;cpu&lt;/var&gt; の有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fbd43e450dfe7c7020abde276dbd9a11edafebb9" translate="yes" xml:space="preserve">
          <source>Specify the PRU MCU variant to use. Check Newlib for the exact list of supported MCUs.</source>
          <target state="translated">使用する PRU MCU バリアントを指定します。サポートされているMCUの正確なリストはNewlibをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="bc89fadc7861eb9269a2f0ab8fd00ec9f83fdfcb" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5 as the target architecture.</source>
          <target state="translated">ターゲットアーキテクチャとして SCORE5 を指定します。</target>
        </trans-unit>
        <trans-unit id="80ac17f93e6b558b7b64a2653f4a0db05f2f20e9" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5U of the target architecture.</source>
          <target state="translated">対象アーキテクチャのSCORE5Uを指定します。</target>
        </trans-unit>
        <trans-unit id="e2e0fec7f878028d3e3295fde4a330a4137fef1a" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7 as the target architecture. This is the default.</source>
          <target state="translated">ターゲットアーキテクチャとして SCORE7 を指定します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="3faa14b10ee7726e8a0c19877d4b1bbbf4106dd0" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7D as the target architecture.</source>
          <target state="translated">ターゲットアーキテクチャとして SCORE7D を指定します。</target>
        </trans-unit>
        <trans-unit id="7c8f7f5802b742a1c6e69d2f1fd902f62c599e4f" translate="yes" xml:space="preserve">
          <source>Specify the access model for the thread local storage pointer. The valid models are &amp;lsquo;</source>
          <target state="translated">スレッドローカルストレージポインタのアクセスモデルを指定します。有効なモデルは '</target>
        </trans-unit>
        <trans-unit id="4fe4d9d926d51c315bc40fdf7c449529e2dcee8d" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for in compiling the function.</source>
          <target state="translated">関数をコンパイルする際にコードを生成するアーキテクチャを指定します。</target>
        </trans-unit>
        <trans-unit id="13ac0518f9e486f66b03f2a62260517f22563228" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for when compiling the function. If you select the &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; attribute when generating 32-bit code, VSX and AltiVec instructions are not generated unless you use the</source>
          <target state="translated">関数のコンパイル時にコードを生成するアーキテクチャを指定します。32ビットコードの生成時に &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; 属性を選択した場合、VSXおよびAltiVec命令は、</target>
        </trans-unit>
        <trans-unit id="815118b1ba2fa776327569310aabc51b60f85457" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for in compiling the function.</source>
          <target state="translated">関数をコンパイルする際にチューニングするアーキテクチャを指定します。</target>
        </trans-unit>
        <trans-unit id="c736ab6b1828855a9d2fe005636f63dbc18a00fc" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for when compiling the function. If you do not specify the &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; attribute and you do specify the &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; attribute, compilation tunes for the &lt;var&gt;CPU&lt;/var&gt; architecture, and not the default tuning specified on the command line.</source>
          <target state="translated">関数のコンパイル時に調整するアーキテクチャを指定します。 &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; 属性を指定せず、 &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; 属性を指定した場合、コンパイルは、コマンドラインで指定されたデフォルトのチューニングではなく、 &lt;var&gt;CPU&lt;/var&gt; アーキテクチャーをチューニングします。</target>
        </trans-unit>
        <trans-unit id="cb717a175d86a7113193ef8b41cb494223988553" translate="yes" xml:space="preserve">
          <source>Specify the dialect to use for accessing thread local storage. Two &lt;var&gt;dialect&lt;/var&gt;s are supported&amp;mdash;&amp;lsquo;</source>
          <target state="translated">スレッドローカルストレージへのアクセスに使用する方言を指定します。2つの &lt;var&gt;dialect&lt;/var&gt; がサポートされています。</target>
        </trans-unit>
        <trans-unit id="b0bb1382b2b688a4ca78557929489507a5c35134" translate="yes" xml:space="preserve">
          <source>Specify the format of the &lt;code&gt;__fp16&lt;/code&gt; half-precision floating-point type. Permissible names are &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;__fp16&lt;/code&gt; 半精度浮動小数点型の形式を指定します。使用できる名前は '</target>
        </trans-unit>
        <trans-unit id="54ccdaa4f82b5c59817de75dfddfa096068b5632" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form</source>
          <target state="translated">ターゲットアーキテクチャの名前と、オプションで1つ以上の機能修飾子を指定します。このオプションの形式は</target>
        </trans-unit>
        <trans-unit id="db2ae06942e745baa6c648898511743a3997f671" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture.</source>
          <target state="translated">対象となるアーキテクチャの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="5bd735b6bf455d85d0ce6fea68c71abb062c337b" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">GCCがコードのパフォーマンスを調整する対象のプロセッサの名前を指定します。このオプションの許容値は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="4403ce6e54a70cfa6d14c2a2335877fa18af0100" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form</source>
          <target state="translated">ターゲットプロセッサの名前を指定します。オプションで、1 つ以上の機能修飾子を接尾辞として付けます。このオプションの形式は</target>
        </trans-unit>
        <trans-unit id="4092610bf9412a688b5dccb4c11f819e1c6c07fc" translate="yes" xml:space="preserve">
          <source>Specify the number of bits in an SVE vector register. This option only has an effect when SVE is enabled.</source>
          <target state="translated">SVE ベクトルレジスタのビット数を指定します。このオプションは SVE が有効な場合のみ有効です。</target>
        </trans-unit>
        <trans-unit id="e688b24a3a041ea4cb98f3c1a8d73b1e4471b5fc" translate="yes" xml:space="preserve">
          <source>Specify the number of registers to reserve for fast interrupt handler functions. The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 1 means that register &lt;code&gt;r13&lt;/code&gt; is reserved for the exclusive use of fast interrupt handlers. A value of 2 reserves &lt;code&gt;r13&lt;/code&gt; and &lt;code&gt;r12&lt;/code&gt;. A value of 3 reserves &lt;code&gt;r13&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt; and &lt;code&gt;r11&lt;/code&gt;, and a value of 4 reserves &lt;code&gt;r13&lt;/code&gt; through &lt;code&gt;r10&lt;/code&gt;. A value of 0, the default, does not reserve any registers.</source>
          <target state="translated">高速割り込みハンドラー関数用に予約するレジスターの数を指定します。値 &lt;var&gt;N&lt;/var&gt; の範囲は0〜4です。値1は、レジスタ &lt;code&gt;r13&lt;/code&gt; が高速割り込みハンドラ専用に予約されていることを意味します。値2は、 &lt;code&gt;r13&lt;/code&gt; および &lt;code&gt;r12&lt;/code&gt; を予約します。値3は、 &lt;code&gt;r13&lt;/code&gt; 、 &lt;code&gt;r12&lt;/code&gt; 、および &lt;code&gt;r11&lt;/code&gt; を予約し、値4は、 &lt;code&gt;r13&lt;/code&gt; から &lt;code&gt;r10&lt;/code&gt; を予約します。デフォルトの値0は、レジスタを予約しません。</target>
        </trans-unit>
        <trans-unit id="96cf955f0da2fdbcd4bc1c6671a0522d71316b38" translate="yes" xml:space="preserve">
          <source>Specify the partitioning algorithm used by the link-time optimizer. The value is either &amp;lsquo;</source>
          <target state="translated">リンク時オプティマイザが使用する分割アルゴリズムを指定します。値は '</target>
        </trans-unit>
        <trans-unit id="5f46dcee93a04ae249c6b3def708b00260f2a519" translate="yes" xml:space="preserve">
          <source>Specify the register to be used for PIC addressing. For standard PIC base case, the default is any suitable register determined by compiler. For single PIC base case, the default is &amp;lsquo;</source>
          <target state="translated">PICアドレス指定に使用するレジスタを指定します。標準のPICベースケースの場合、デフォルトはコンパイラーによって決定される適切なレジスターです。単一のPICベースケースの場合、デフォルトは '</target>
        </trans-unit>
        <trans-unit id="9157006b777e209a57da158df2f68846623d8678" translate="yes" xml:space="preserve">
          <source>Specify the size of each cache block, which must be a power of 2 between 4 and 512.</source>
          <target state="translated">各キャッシュブロックのサイズを指定します。</target>
        </trans-unit>
        <trans-unit id="edab8f619041277bee138aa740d3f8bdb844feca" translate="yes" xml:space="preserve">
          <source>Specify the size of each interrupt vector, which must be 4 or 16.</source>
          <target state="translated">各割り込みベクタのサイズを指定します。</target>
        </trans-unit>
        <trans-unit id="dde0e6e48055b68c9dfa72618fe117ee2653e7c8" translate="yes" xml:space="preserve">
          <source>Specify the size of the operating system provided stack guard as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">オペレーティングシステムが提供するスタックガードのサイズを2から &lt;var&gt;num&lt;/var&gt; バイトに引き上げて指定します。値を大きくすると、明示的なプローブの数が減る可能性がありますが、オペレーティングシステムが提供するガードよりも大きい値では、コードがスタッククラッシュスタイルの攻撃に対して脆弱になります。</target>
        </trans-unit>
        <trans-unit id="4bee625f3585900ec98450bcf9d2c818f2c00803" translate="yes" xml:space="preserve">
          <source>Specify the struct-like types for which the compiler generates debug information. The intent is to reduce duplicate struct debug information between different object files within the same program.</source>
          <target state="translated">コンパイラがデバッグ情報を生成する struct ライクなタイプを指定します。これは、同じプログラム内の異なるオブジェクト・ファイル間で重複する struct デバッグ情報を減らすことを目的としています。</target>
        </trans-unit>
        <trans-unit id="4e0fd0bd7b4133166f8983f5ca490beae5286735" translate="yes" xml:space="preserve">
          <source>Specify the width of the &lt;code&gt;lp_count&lt;/code&gt; register. Valid values for &lt;var&gt;width&lt;/var&gt; are 8, 16, 20, 24, 28 and 32 bits. The default width is fixed to 32 bits. If the width is less than 32, the compiler does not attempt to transform loops in your program to use the zero-delay loop mechanism unless it is known that the &lt;code&gt;lp_count&lt;/code&gt; register can hold the required loop-counter value. Depending on the width specified, the compiler and run-time library might continue to use the loop mechanism for various needs. This option defines macro &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; with the value of &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;lp_count&lt;/code&gt; レジスタの幅を指定します。 &lt;var&gt;width&lt;/var&gt; 有効な値は、8、16、20、24、28、32ビットです。デフォルトの幅は32ビットに固定されています。幅が32未満の場合、 &lt;code&gt;lp_count&lt;/code&gt; レジスターが必要なループカウンター値を保持できることがわかっていない限り、コンパイラーはプログラム内のループを変換してゼロ遅延ループメカニズムを使用しようとしません。指定された幅に応じて、コンパイラとランタイムライブラリは、さまざまなニーズに対してループメカニズムを引き続き使用する場合があります。このオプションは、 &lt;var&gt;width&lt;/var&gt; の値を使用してマクロ &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="ef84b64c518f868fe3c1456dcd8b940ed2f5f518" translate="yes" xml:space="preserve">
          <source>Specify thread pointer register number.</source>
          <target state="translated">スレッドポインタのレジスタ番号を指定します。</target>
        </trans-unit>
        <trans-unit id="0795a2fa90067cc8a239666f6041471cc59a29ac" translate="yes" xml:space="preserve">
          <source>Specify whether GCC may generate code that reads from executable sections. There are three possible settings:</source>
          <target state="translated">GCCが実行可能なセクションから読み取るコードを生成するかどうかを指定します。3つの設定が考えられます。</target>
        </trans-unit>
        <trans-unit id="d19282618f9569137fcb9b5340c3ea42b2a33ba2" translate="yes" xml:space="preserve">
          <source>Specify whether GCC should insert cache barriers to avoid the side effects of speculation on R10K processors.</source>
          <target state="translated">R10Kプロセッサにおける投機の副作用を避けるために、GCCがキャッシュバリアを挿入すべきかどうかを指定する。</target>
        </trans-unit>
        <trans-unit id="1440f232d0fc9c6f8894e1bd99ffd6ec679cd656" translate="yes" xml:space="preserve">
          <source>Specify which floating-point unit to use. You must specify the &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; option as &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; because the comma would separate different options.</source>
          <target state="translated">使用する浮動小数点ユニットを指定します。 &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; オプションを &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; として指定する必要があります。これは、コンマが異なるオプションを区切るためです。</target>
        </trans-unit>
        <trans-unit id="f360040b863c4a298bd666b8b6b30d2471ac8011" translate="yes" xml:space="preserve">
          <source>Specifying</source>
          <target state="translated">Specifying</target>
        </trans-unit>
        <trans-unit id="99167fd0d0a95abb4e35db3c3f342b56f873f72a" translate="yes" xml:space="preserve">
          <source>Specifying &amp;lsquo;</source>
          <target state="translated">'の指定</target>
        </trans-unit>
        <trans-unit id="d1885b005623a5f02d47b85a83ced0900c30f8b7" translate="yes" xml:space="preserve">
          <source>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type &lt;code&gt;V4SI&lt;/code&gt; and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 &lt;code&gt;SIs&lt;/code&gt;.</source>
          <target state="translated">現在のアーキテクチャでは無効な組み合わせを指定すると、GCCはナローモードを使用して命令を合成します。たとえば、タイプ &lt;code&gt;V4SI&lt;/code&gt; の変数を指定し、アーキテクチャがこの特定のSIMDタイプを許可しない場合、GCCは4つの &lt;code&gt;SIs&lt;/code&gt; を使用するコードを生成します。</target>
        </trans-unit>
        <trans-unit id="2e7e05645dcca05e87ea389d828aa6bfe5f9fa1f" translate="yes" xml:space="preserve">
          <source>Specifying a larger number can produce faster, more efficient code, but can also increase the size of the program. Different values are potentially incompatible. Code compiled with one value cannot necessarily expect to work with code or libraries compiled with another value, if they exchange information using structures or unions.</source>
          <target state="translated">より大きな数値を指定すると、より高速で効率的なコードを生成できますが、プログラムのサイズを大きくすることもできます。異なる値は互換性がない可能性があります。ある値でコンパイルされたコードは、構造体やユニオンを使用して情報を交換している場合、別の値でコンパイルされたコードやライブラリでは必ずしも動作しません。</target>
        </trans-unit>
        <trans-unit id="03c6ae3356882b0eeb6636e77ccaa0aba81823b0" translate="yes" xml:space="preserve">
          <source>Specifying attributes of types.</source>
          <target state="translated">型の属性を指定します。</target>
        </trans-unit>
        <trans-unit id="9e1c53b45f7e03f5a8d931294deb320e271bf08b" translate="yes" xml:space="preserve">
          <source>Specifying attributes of variables.</source>
          <target state="translated">変数の属性を指定します。</target>
        </trans-unit>
        <trans-unit id="5db2ee21c24dcdf45bcae194cf2ecad708afe6a7" translate="yes" xml:space="preserve">
          <source>Specifying attributes on enumerators.</source>
          <target state="translated">列挙子に属性を指定します。</target>
        </trans-unit>
        <trans-unit id="ae68580bc0d24f5d44a4b1108b3374a4cbf533b1" translate="yes" xml:space="preserve">
          <source>Specifying attributes on labels.</source>
          <target state="translated">ラベルの属性を指定します。</target>
        </trans-unit>
        <trans-unit id="6f4d8f85b31cb45df6efc5370ca55a06e5b2185a" translate="yes" xml:space="preserve">
          <source>Specifying attributes on statements.</source>
          <target state="translated">ステートメントに属性を指定します。</target>
        </trans-unit>
        <trans-unit id="c4fb77efc8cd285dcec19a190e5fd370517a59b0" translate="yes" xml:space="preserve">
          <source>Specifying conventions for function calls, data layout and register usage.</source>
          <target state="translated">関数の呼び出し、データレイアウト、レジスタの使用方法などの規約を指定します。</target>
        </trans-unit>
        <trans-unit id="8a322c1f2da20dac777d0e24ef37843a3925d344" translate="yes" xml:space="preserve">
          <source>Specifying libraries and so on.</source>
          <target state="translated">ライブラリの指定など</target>
        </trans-unit>
        <trans-unit id="35c808a95c8bd97d1d48f311fe3d1ff9cbb26d16" translate="yes" xml:space="preserve">
          <source>Specifying target attributes on individual functions or performing link-time optimization across translation units compiled with different target options can affect function inlining rules:</source>
          <target state="translated">個々の関数にターゲット属性を指定したり、異なるターゲットオプションでコンパイルされた翻訳ユニット間でリンク時間の最適化を実行したりすると、関数のインラインルールに影響を与えることがあります。</target>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="translated">を指定します。</target>
        </trans-unit>
        <trans-unit id="be769970f9d0ab94f326ad5f60920cc958cef495" translate="yes" xml:space="preserve">
          <source>Specifying the assembler name to use for a C symbol.</source>
          <target state="translated">C シンボルに使用するアセンブラ名を指定します。</target>
        </trans-unit>
        <trans-unit id="b768e2f08c0d665e3b9b9a2f57c49ac37e0b4986" translate="yes" xml:space="preserve">
          <source>Speculation Barrier Instruction.</source>
          <target state="translated">投機障壁の指示。</target>
        </trans-unit>
        <trans-unit id="e39eb4a0ece25ea3aad502401ffe4e7271da49e1" translate="yes" xml:space="preserve">
          <source>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at</source>
          <target state="translated">負荷が同じ構造内の隣接する位置からのもので、ターゲット・アーキテクチャが条件付き移動命令を持っている場合、if-then-else の両方のブランチからの負荷を特定的に巻き上げます。このフラグは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="e6c7808e8703d45ea319f5ac9cfea72c1d3b2c26" translate="yes" xml:space="preserve">
          <source>Split 32-byte AVX unaligned load and store.</source>
          <target state="translated">32バイトのAVX未整列ロードとストアを分割。</target>
        </trans-unit>
        <trans-unit id="a66f8bdb0cdd7c740f8bab1b871317c083f59cec" translate="yes" xml:space="preserve">
          <source>Split a loop into two if it contains a condition that&amp;rsquo;s always true for one side of the iteration space and false for the other.</source>
          <target state="translated">ループが反復空間の一方の側では常に真であり、もう一方の側では偽である条件が含まれている場合、ループを2つに分割します。</target>
        </trans-unit>
        <trans-unit id="7e793f0b9e2c47f7ff51cea5a83ac494564f9b01" translate="yes" xml:space="preserve">
          <source>Split paths leading to loop backedges. This can improve dead code elimination and common subexpression elimination. This is enabled by default at</source>
          <target state="translated">ループのバックエッジにつながるパスを分割します。これにより、デッドコードの排除と共通のサブエクスプレッションの排除を改善することができます。これはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="c19cf5ca00368b6bf60823f07c7f7db52961a1db" translate="yes" xml:space="preserve">
          <source>Split the include path. This option has been deprecated. Please use</source>
          <target state="translated">インクルードパスを分割します。このオプションは非推奨となりました。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="03d6628c91b12235f628c3f0849b814233af5af3" translate="yes" xml:space="preserve">
          <source>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.</source>
          <target state="translated">ベクトルの動きをリロード前にシングルワードの動きに分割します。理論的には、これはより良いレジスタ割り当てを与えることができますが、今のところは逆が一般的のようです。</target>
        </trans-unit>
        <trans-unit id="9b6e2276ec4ca5446d91dd4b3bca6fc9336a2104" translate="yes" xml:space="preserve">
          <source>Stack clash protection involves probing stack space as it is allocated. This param controls the maximum distance between probes into the stack as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">スタッククラッシュ保護には、割り当てられたスタックスペースのプローブが含まれます。このパラメーターは、スタックへのプローブ間の最大距離を2から &lt;var&gt;num&lt;/var&gt; バイトに引き上げたものとして制御します。値を大きくすると、明示的なプローブの数が減る可能性がありますが、オペレーティングシステムが提供するガードよりも大きい値では、コードがスタッククラッシュスタイルの攻撃に対して脆弱になります。</target>
        </trans-unit>
        <trans-unit id="42423254dd8ef2b598b3ee0e697e74e7db04abbc" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SP).</source>
          <target state="translated">スタックポインタレジスタ(SP)。</target>
        </trans-unit>
        <trans-unit id="1d47e20f0d3ac51ec48cf366af32c77c2669b54f" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SPH:SPL)</source>
          <target state="translated">スタックポインタレジスタ (SPH:SPL)</target>
        </trans-unit>
        <trans-unit id="d8ceeae642420027f1322393a2a3a2e2bcca2060" translate="yes" xml:space="preserve">
          <source>Stack register $sp.</source>
          <target state="translated">スタックレジ $sp.</target>
        </trans-unit>
        <trans-unit id="19b7dc1683e0d583c27f00412d344ea74bdf5a0a" translate="yes" xml:space="preserve">
          <source>Stack variables are not affected by linker restrictions; GCC can properly align them on any target.</source>
          <target state="translated">スタック変数はリンカの制限の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="ac5a8f549a994c1b8e4dd80d24db9f3996eea422" translate="yes" xml:space="preserve">
          <source>Standard 80387 floating point constant.</source>
          <target state="translated">標準 80387 浮動小数点定数。</target>
        </trans-unit>
        <trans-unit id="257c765fd4761dbfb8a7c22158ae9ccc2a9c0d89" translate="yes" xml:space="preserve">
          <source>Standard C requires that pointer types used with &lt;code&gt;va_arg&lt;/code&gt; in functions with variable argument lists either must be compatible with that of the actual argument, or that one type must be a pointer to &lt;code&gt;void&lt;/code&gt; and the other a pointer to a character type. GNU C implements the POSIX XSI extension that additionally permits the use of &lt;code&gt;va_arg&lt;/code&gt; with a pointer type to receive arguments of any other pointer type.</source>
          <target state="translated">標準Cでは、可変引数リストを持つ &lt;code&gt;va_arg&lt;/code&gt; でva_argと共に使用されるポインター型は、実際の引数のそれと互換性があるか、一方の型が &lt;code&gt;void&lt;/code&gt; へのポインターであり、もう一方が文字型へのポインターである必要があります。GNU CはPOSIX XSI拡張機能を実装しています。これにより、他のポインター型の引数を受け取るために、ポインター型で &lt;code&gt;va_arg&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="6f7654adc68a64f36e03bf390845ec45238411d8" translate="yes" xml:space="preserve">
          <source>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</source>
          <target state="translated">標準C90では、初期化子の要素は、初期化される配列や構造体の要素の順序と同じ、固定された順序で現れることが要求されています。</target>
        </trans-unit>
        <trans-unit id="b23b0b38a39d349a3165d9fefce6588293b09611" translate="yes" xml:space="preserve">
          <source>Standard system directories are scanned.</source>
          <target state="translated">標準システムのディレクトリがスキャンされます。</target>
        </trans-unit>
        <trans-unit id="7f3657857ae8fa83a5a6acb61ee0490999a1f0da" translate="yes" xml:space="preserve">
          <source>Start a RTM (Restricted Transactional Memory) transaction. Returns &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; when the transaction started successfully (note this is not 0, so the constant has to be explicitly tested).</source>
          <target state="translated">RTM（Restricted Transactional Memory）トランザクションを開始します。トランザクションが正常に開始すると &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; を返します（これは0ではないため、定数を明示的にテストする必要があります）。</target>
        </trans-unit>
        <trans-unit id="d321cb5e91b977aa5f4a76bb28fcd908795d2d2b" translate="yes" xml:space="preserve">
          <source>Start lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; or stronger.</source>
          <target state="translated">ロック変数のロック省略を開始します。メモリの順序は &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="d710b21a9b9bf4c6c45243e4c0bf0c7460f48764" translate="yes" xml:space="preserve">
          <source>Starting with GCC 3.2, GCC binary conventions for C++ are based on a written, vendor-neutral C++ ABI that was designed to be specific to 64-bit Itanium but also includes generic specifications that apply to any platform. This C++ ABI is also implemented by other compiler vendors on some platforms, notably GNU/Linux and BSD systems. We have tried hard to provide a stable ABI that will be compatible with future GCC releases, but it is possible that we will encounter problems that make this difficult. Such problems could include different interpretations of the C++ ABI by different vendors, bugs in the ABI, or bugs in the implementation of the ABI in different compilers. GCC&amp;rsquo;s</source>
          <target state="translated">GCC 3.2以降、C ++のGCCバイナリ規約は、64ビットItaniumに固有になるように設計された、ベンダーに依存しないC ++ ABIに基づいていますが、すべてのプラットフォームに適用される一般的な仕様も含まれています。このC ++ ABIは、一部のプラットフォーム、特にGNU / LinuxおよびBSDシステム上の他のコンパイラベンダーによっても実装されています。将来のGCCリリースと互換性のある安定したABIを提供するために懸命に努力しましたが、これを困難にする問題が発生する可能性があります。このような問題には、異なるベンダーによるC ++ ABIの異なる解釈、ABIのバグ、または異なるコンパイラーでのABIの実装のバグが含まれる可能性があります。GCC</target>
        </trans-unit>
        <trans-unit id="e0603cbbfdea44aa94fc492612a783b691bd4ebd" translate="yes" xml:space="preserve">
          <source>Starting with GCC 4.7.0, the traditional GNU runtime API is no longer available.</source>
          <target state="translated">GCC 4.7.0から、従来のGNUランタイムAPIは利用できなくなりました。</target>
        </trans-unit>
        <trans-unit id="0d99177a777348b93d27364c0bfe456087ad31a7" translate="yes" xml:space="preserve">
          <source>Statement Attributes</source>
          <target state="translated">ステートメント属性</target>
        </trans-unit>
        <trans-unit id="9a5ff5b401235fc57fb6c95d79c8c8b7116e1c37" translate="yes" xml:space="preserve">
          <source>States an expression as an assumption, and if possible, verifies that the assumption is valid. For example, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt;.</source>
          <target state="translated">式を仮定として示し、可能であれば、仮定が有効であることを確認します。たとえば、 &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c22f2edc68615de37762f51b4fa28235f463b8f3" translate="yes" xml:space="preserve">
          <source>Static Analyzer Options</source>
          <target state="translated">静的アナライザのオプション</target>
        </trans-unit>
        <trans-unit id="0f44280770a4ee1097a4edddc52f0cd05d85a900" translate="yes" xml:space="preserve">
          <source>Static libraries are archives of object files, and have file names like</source>
          <target state="translated">スタティックライブラリはオブジェクトファイルのアーカイブであり、以下のようなファイル名を持ちます。</target>
        </trans-unit>
        <trans-unit id="c46e734f5fd8510b9e062efd2082eeb14db6af81" translate="yes" xml:space="preserve">
          <source>Static member declarations are not definitions</source>
          <target state="translated">静的なメンバ宣言は定義ではありません。</target>
        </trans-unit>
        <trans-unit id="d94ff9dc4d646834a0535298621e393784d6f1d3" translate="yes" xml:space="preserve">
          <source>Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.</source>
          <target state="translated">前処理の段階の後に停止してください;適切なコンパイラを実行しないでください。出力は前処理されたソースコードの形で、標準出力に送られます。</target>
        </trans-unit>
        <trans-unit id="2daee47861dfd3c59bf8ff060a32e292f65fec05" translate="yes" xml:space="preserve">
          <source>Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.</source>
          <target state="translated">適切なコンパイルの段階で停止してください。出力は、指定された非アセンブラ入力ファイルごとにアセンブラコードファイルの形で出力されます。</target>
        </trans-unit>
        <trans-unit id="8347e9bfc02ac3a60787813c10d80e9ff680d75e" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the best edge has probability lower than this threshold.</source>
          <target state="translated">ベストエッジの確率がこのしきい値よりも低い場合は、前進成長を停止します。</target>
        </trans-unit>
        <trans-unit id="93e3b1851a75fdb25f8f9ca9807e49174553cf12" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available.</source>
          <target state="translated">ベストエッジの確率がこのしきい値(パーセント)よりも低い場合、前方成長を停止します。プロファイルフィードバックがある場合に使用します。</target>
        </trans-unit>
        <trans-unit id="5b2c101566fb4988550c86b87f1d88d336f66263" translate="yes" xml:space="preserve">
          <source>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).</source>
          <target state="translated">ベストエッジの逆確率がこのしきい値(パーセント)以下になったときに逆成長を停止します。</target>
        </trans-unit>
        <trans-unit id="5b4aff278c0fdce3e7f55f32e7c895daaa47f804" translate="yes" xml:space="preserve">
          <source>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.</source>
          <target state="translated">コードの成長が所定のパーセンテージに達した時点でテールの重複を停止します。これはかなり人為的な制限で、クロスジャンプではほとんどの重複が後から排除されるので、望ましいコード成長よりもはるかに高い値に設定されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="e5524f873f830633dc8a23de8cf2d30b3d74c34d" translate="yes" xml:space="preserve">
          <source>Store (do not store) the address of the caller&amp;rsquo;s frame as backchain pointer into the callee&amp;rsquo;s stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF call frame information. When</source>
          <target state="translated">呼び出し元のフレームのアドレスをバックチェーンポインターとして呼び出し先のスタックフレームに格納します（格納しません）。DWARF呼び出しフレーム情報を理解しないツールを使用してデバッグできるようにするために、バックチェーンが必要になる場合があります。いつ</target>
        </trans-unit>
        <trans-unit id="b16037d0dfeba50e99ce7619111826617ed26b77" translate="yes" xml:space="preserve">
          <source>Store data (but not code) in the big-endian format. The default is</source>
          <target state="translated">データを(コードではなく)ビッグエンディアン形式で保存します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="d1b3895de4641414ac79dc4d41b3d54519e0dbbf" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently. If the</source>
          <target state="translated">通常の「一時的な」中間ファイルを永続的に保存します。もし</target>
        </trans-unit>
        <trans-unit id="825a3542481737ba30d5e3c1a289571cd11217e5" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently; place them in the current directory and name them based on the source file. Thus, compiling</source>
          <target state="translated">通常の「一時的な」中間ファイルを永続的に保存します。それらを現在のディレクトリに配置し、ソースファイルに基づいて名前を付けます。したがって、コンパイル</target>
        </trans-unit>
        <trans-unit id="6a52a11a90147dcb5f7e83906aec646860b00234" translate="yes" xml:space="preserve">
          <source>Storing into the pointer can be done likewise with the same union.</source>
          <target state="translated">ポインタへの格納も同様に、同じ組合わせで行うことができます。</target>
        </trans-unit>
        <trans-unit id="7e43c92861ad3e02cc7239ce0887aa080085a685" translate="yes" xml:space="preserve">
          <source>Storing the new address in &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt;, if &lt;var&gt;ra-address&lt;/var&gt; is nonnull.</source>
          <target state="translated">&lt;var&gt;ra-address&lt;/var&gt; がnull でない場合、 &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt; に新しいアドレスを格納します。</target>
        </trans-unit>
        <trans-unit id="d51f83d4384be85e0661264f111bae505e048852" translate="yes" xml:space="preserve">
          <source>Stream extra information needed for aggressive devirtualization when running the link-time optimizer in local transformation mode. This option enables more devirtualization but significantly increases the size of streamed data. For this reason it is disabled by default.</source>
          <target state="translated">ローカル変換モードでリンクタイム・オプティマイザーを実行する際に、積極的な仮想化に必要な追加情報をストリームします。このオプションを使用すると、より多くの仮想化が可能になりますが、ストリームされるデータのサイズが大幅に増加します。このため、既定では無効になっています。</target>
        </trans-unit>
        <trans-unit id="474bfcc8400d6e8dacea61eec4b30865208de5b9" translate="yes" xml:space="preserve">
          <source>Structure members are stored sequentially in the order in which they are declared: the first member has the lowest memory address and the last member the highest.</source>
          <target state="translated">構造体のメンバは、宣言された順に順次格納されます。</target>
        </trans-unit>
        <trans-unit id="c3de1ed2a463e2a1c2ff86baf892b9da62d4e4d8" translate="yes" xml:space="preserve">
          <source>Structure of the JSON is following:</source>
          <target state="translated">JSONの構造は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4a4ea855e21caf3a76611861328cfb1249cb6b2a" translate="yes" xml:space="preserve">
          <source>Structures with no members.</source>
          <target state="translated">メンバーのいない構造物。</target>
        </trans-unit>
        <trans-unit id="9075bc2ab7ab689b643437d474f305a0857530db" translate="yes" xml:space="preserve">
          <source>Stubs are generated automatically by the linker if the following two conditions are met:</source>
          <target state="translated">スタブは、以下の2つの条件を満たす場合、リンカによって自動的に生成されます。</target>
        </trans-unit>
        <trans-unit id="9013b380508240de43628bfd190a9b994da8e678" translate="yes" xml:space="preserve">
          <source>Substitute a file name that has suffix &lt;var&gt;suffix&lt;/var&gt; and is chosen once per compilation, and mark the argument in the same way as &amp;lsquo;</source>
          <target state="translated">接尾辞 &lt;var&gt;suffix&lt;/var&gt; があり、コンパイルごとに1回選択されるファイル名を置き換え、引数を 'と同じ方法でマークします</target>
        </trans-unit>
        <trans-unit id="5a84f064e80a6c0f3317c7855f9c6ac2c41131d2" translate="yes" xml:space="preserve">
          <source>Substitute any of</source>
          <target state="translated">のいずれかを代用します。</target>
        </trans-unit>
        <trans-unit id="998b2b0ec7c7cc0618199202723cd62e2208d036" translate="yes" xml:space="preserve">
          <source>Substitute one &amp;lsquo;</source>
          <target state="translated">1つを置き換える</target>
        </trans-unit>
        <trans-unit id="2d0f6708feea91da92348701c1acca054bd497b6" translate="yes" xml:space="preserve">
          <source>Substitute the basename of the input file being processed. This is the substring up to (and not including) the last period and not including the directory.</source>
          <target state="translated">処理される入力ファイルのベースネームを代入する。これは最後のピリオドまでの部分文字列で、ディレクトリは含まない。</target>
        </trans-unit>
        <trans-unit id="1de1b430997906cd235f8cdbc3a04979f0ce1846" translate="yes" xml:space="preserve">
          <source>Substitute the contents of spec string &lt;var&gt;name&lt;/var&gt; at this point.</source>
          <target state="translated">この時点で、仕様文字列 &lt;var&gt;name&lt;/var&gt; 内容を置き換えます。</target>
        </trans-unit>
        <trans-unit id="fd2fde2ae73c8516cb1a3cac098e2359e8a7c33a" translate="yes" xml:space="preserve">
          <source>Substitute the name of the input file being processed.</source>
          <target state="translated">処理中の入力ファイル名を代入します。</target>
        </trans-unit>
        <trans-unit id="ae8eaa414e533e6922c45c08150cca1cb19b9be1" translate="yes" xml:space="preserve">
          <source>Substitute the variable part of a matched option. See below. Note that each comma in the substituted string is replaced by a single space.</source>
          <target state="translated">マッチしたオプションの変数部分を代入します。以下を参照してください。置換された文字列の各カンマは、単一のスペースに置き換えられることに注意してください。</target>
        </trans-unit>
        <trans-unit id="43dec03cdd027bda7c71fa5dcb7ea1dab00d8963" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if either &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; is given to GCC. This may be combined with &amp;lsquo;</source>
          <target state="translated">代替 &lt;code&gt;X&lt;/code&gt; のいずれかの場合は &lt;code&gt;-S&lt;/code&gt; または &lt;code&gt;-P&lt;/code&gt; は GCCに与えられています。これは「</target>
        </trans-unit>
        <trans-unit id="e6be527872250ba01c3017e89b857046ca96045c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if one or more switches whose names start with &lt;code&gt;-S&lt;/code&gt; are specified to GCC. Normally &lt;code&gt;X&lt;/code&gt; is substituted only once, no matter how many such switches appeared. However, if &lt;code&gt;%*&lt;/code&gt; appears somewhere in &lt;code&gt;X&lt;/code&gt;, then &lt;code&gt;X&lt;/code&gt; is substituted once for each matching switch, with the &lt;code&gt;%*&lt;/code&gt; replaced by the part of that switch matching the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">代替 &lt;code&gt;X&lt;/code&gt; 名前で始まる1つの以上のスイッチであれば &lt;code&gt;-S&lt;/code&gt; GCCに指定されています。通常、そのようなスイッチがいくつ現れても、 &lt;code&gt;X&lt;/code&gt; は一度だけ置換されます。ただし、 &lt;code&gt;%*&lt;/code&gt; が &lt;code&gt;X&lt;/code&gt; のどこかにある場合、 &lt;code&gt;X&lt;/code&gt; は一致するスイッチごとに1回置換され、 &lt;code&gt;%*&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; に一致するスイッチの部分に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="786d7f6a8f7f27970f79f53feb14051559d33597" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if &lt;em&gt;not&lt;/em&gt; processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">接尾辞 &lt;code&gt;S&lt;/code&gt; のファイルを処理し&lt;em&gt;ない&lt;/em&gt;場合&lt;em&gt;は&lt;/em&gt;、 &lt;code&gt;X&lt;/code&gt; に置き換えます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="864ccc2fa9d07c116ad04b8eeaefd7787e81b65c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if not processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">言語 &lt;code&gt;S&lt;/code&gt; のファイルを処理しない場合は、 &lt;code&gt;X&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="64dfa62f2736f224c236543aa31324e1526b2435" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">言語 &lt;code&gt;S&lt;/code&gt; のファイルを処理する場合は &lt;code&gt;X&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a6dded313927000e1a3934ea810bce16c0a202a3" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">接尾辞が &lt;code&gt;S&lt;/code&gt; のファイルを処理する場合は、 &lt;code&gt;X&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="d0531e0f44345fcee0b59ff85181d8e187cb0d34" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if the</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; を代入します。</target>
        </trans-unit>
        <trans-unit id="381da79492b4d41df2595656917a76e838b4035d" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;var&gt;.SUFFIX&lt;/var&gt; for the suffixes of a matched switch&amp;rsquo;s args when it is subsequently output with &amp;lsquo;</source>
          <target state="translated">代替 &lt;var&gt;.SUFFIX&lt;/var&gt; マッチしたスイッチの引数の接尾辞のため、それがその後&quot;で出力されます</target>
        </trans-unit>
        <trans-unit id="330d507dbe426595b8910e78b9c215b447059d1c" translate="yes" xml:space="preserve">
          <source>Substitutes all the switches specified to GCC whose names start with &lt;code&gt;-S&lt;/code&gt;, but which also take an argument. This is used for switches like</source>
          <target state="translated">名前が &lt;code&gt;-S&lt;/code&gt; で始まるGCCに指定されたすべてのスイッチを置き換えますが、引数も受け取ります。これは次のようなスイッチに使用されます</target>
        </trans-unit>
        <trans-unit id="83c0a4e01bdd2a1adfb064f09d23d09f40d1cc63" translate="yes" xml:space="preserve">
          <source>Substitutes the &lt;code&gt;-S&lt;/code&gt; switch, if that switch is given to GCC. If that switch is not specified, this substitutes nothing. Note that the leading dash is omitted when specifying this option, and it is automatically inserted if the substitution is performed. Thus the spec string &amp;lsquo;</source>
          <target state="translated">代替 &lt;code&gt;-S&lt;/code&gt; スイッチは、そのスイッチはGCCに指定された場合。そのスイッチが指定されていない場合、これは何も置き換えません。このオプションを指定すると、先頭のダッシュは省略され、置換が実行されると自動的に挿入されることに注意してください。したがって、仕様文字列 '</target>
        </trans-unit>
        <trans-unit id="3c13db3d4f7d55a97362e7f68ba24cf3424c2837" translate="yes" xml:space="preserve">
          <source>Substitutes the last file name generated with &amp;lsquo;</source>
          <target state="translated">で生成された最後のファイル名を「</target>
        </trans-unit>
        <trans-unit id="4b4f52841be7dd8b1c205fb48bea71f8dc73cc8b" translate="yes" xml:space="preserve">
          <source>Substitutes the name of the &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt;, if any, and if it is writable, and if</source>
          <target state="translated">&lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt; がある場合、その名前と、書き込み可能かどうか、および</target>
        </trans-unit>
        <trans-unit id="510d92a70f7a6df088d50db8add12d77997610de" translate="yes" xml:space="preserve">
          <source>Substitutes the names of all the output files, with spaces automatically placed around them. You should write spaces around the &amp;lsquo;</source>
          <target state="translated">すべての出力ファイルの名前を、それらの周りに自動的に配置されるスペースで置き換えます。の周りにスペースを書く必要があります</target>
        </trans-unit>
        <trans-unit id="37e406a2f9f9f2524ce85dd8f1df47e0fcb53fb6" translate="yes" xml:space="preserve">
          <source>Substitutes the standard macro predefinitions for the current target machine. Use this when running &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="translated">現在のターゲットマシンの標準マクロ事前定義を置き換えます。 &lt;code&gt;cpp&lt;/code&gt; を実行するときにこれを使用します。</target>
        </trans-unit>
        <trans-unit id="601b96766181d9e1c5aa982978f52e20aab04d35" translate="yes" xml:space="preserve">
          <source>Substitutes the suffix for object files. Note that this is handled specially when it immediately follows &amp;lsquo;</source>
          <target state="translated">オブジェクトファイルのサフィックスに置き換えます。これは直後に続くときに特別に処理されることに注意してください '</target>
        </trans-unit>
        <trans-unit id="ebb148237b08e3751f6fc1e4dce1cbcd763ff06d" translate="yes" xml:space="preserve">
          <source>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</source>
          <target state="translated">減算、乗算、除算、論理演算も同様に動作します。同様に、ベクトル型で単項マイナス演算子または補数演算子を使用した結果は、オペランド内の対応する要素のマイナス値または補数値を要素とするベクトルとなります。</target>
        </trans-unit>
        <trans-unit id="9ed92f9622e5eda43509c60bb3049fa12fe5ec7f" translate="yes" xml:space="preserve">
          <source>Such a feature would work only occasionally&amp;mdash;only for calls that appear in the same file as the called function, following the definition. The only way to check all calls reliably is to add a prototype for the function. But adding a prototype eliminates the motivation for this feature. So the feature is not worthwhile.</source>
          <target state="translated">このような機能はたまにしか機能しません。定義に従って、呼び出された関数と同じファイルにある呼び出しに対してのみ機能します。すべての呼び出しを確実にチェックする唯一の方法は、関数のプロトタイプを追加することです。しかし、プロトタイプを追加すると、この機能の動機がなくなります。したがって、この機能は価値がありません。</target>
        </trans-unit>
        <trans-unit id="5af0feab651599b508e437900c6cfc81abd2fe41" translate="yes" xml:space="preserve">
          <source>Such accesses are supported, subject to the same requirements for synchronization for concurrent accesses as for concurrent accesses to any object.</source>
          <target state="translated">このようなアクセスがサポートされていますが、任意のオブジェクトへの同時アクセスと同様に、同時アクセスのための同期化の要件が適用されます。</target>
        </trans-unit>
        <trans-unit id="4cfbaa1bf62e72b4bca886bc067e3bd96ad98df4" translate="yes" xml:space="preserve">
          <source>Such an array of label values serves a purpose much like that of the &lt;code&gt;switch&lt;/code&gt; statement. The &lt;code&gt;switch&lt;/code&gt; statement is cleaner, so use that rather than an array unless the problem does not fit a &lt;code&gt;switch&lt;/code&gt; statement very well.</source>
          <target state="translated">このようなラベル値の配列は、 &lt;code&gt;switch&lt;/code&gt; ステートメントと同じような目的で使用されます。 &lt;code&gt;switch&lt;/code&gt; 文は問題が収まらないない限り、配列ではなく、それを使用し、クリーンである &lt;code&gt;switch&lt;/code&gt; 非常によく声明を。</target>
        </trans-unit>
        <trans-unit id="4348530a5b230f9786021cf2cdbed2168537bbe7" translate="yes" xml:space="preserve">
          <source>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</source>
          <target state="translated">このようなオブジェクトは通常、ポインタによってアクセスされ、ハードウェアにアクセスするために使用されます。ほとんどの式では、何が読み取りで何が書き込みかは直感的に明らかです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7e9903330f56016812404c897216c2074bedf62f" translate="yes" xml:space="preserve">
          <source>Such argument passing is supported, using the same pass-by-invisible-reference approach used for normal function arguments of such types.</source>
          <target state="translated">このような型の通常の関数の引数に使用されるのと同じpass-by-invisible-referenceアプローチを使用して、このような引数渡しがサポートされています。</target>
        </trans-unit>
        <trans-unit id="fdaf5b5f6a3d1715a900b4b2779de302364392a5" translate="yes" xml:space="preserve">
          <source>Such assignments must be very common; warning about them would cause more annoyance than good.</source>
          <target state="translated">このような課題は非常に一般的なものでなければならず、それについての警告は、良いよりも多くの迷惑を引き起こすことになります。</target>
        </trans-unit>
        <trans-unit id="fc536d9f079301ea3cff9bd45f17bf843dbe50ad" translate="yes" xml:space="preserve">
          <source>Such built-in functions are provided for &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;strncat&lt;/code&gt;.</source>
          <target state="translated">このような組み込み関数は、 &lt;code&gt;memcpy&lt;/code&gt; 、 &lt;code&gt;mempcpy&lt;/code&gt; 、 &lt;code&gt;memmove&lt;/code&gt; 、 &lt;code&gt;memset&lt;/code&gt; 、 &lt;code&gt;strcpy&lt;/code&gt; 、 &lt;code&gt;stpcpy&lt;/code&gt; 、 &lt;code&gt;strncpy&lt;/code&gt; 、 &lt;code&gt;strcat&lt;/code&gt; および &lt;code&gt;strncat&lt;/code&gt; に提供されています。</target>
        </trans-unit>
        <trans-unit id="7a73b44a4d02b7ee2f589148448bb9f1b269841d" translate="yes" xml:space="preserve">
          <source>Such code is suitable for level 0 PA systems and kernels.</source>
          <target state="translated">このようなコードは、レベル0のPAシステムやカーネルに適しています。</target>
        </trans-unit>
        <trans-unit id="221482fe63639c70a1d813f43faebcec11cd2c30" translate="yes" xml:space="preserve">
          <source>Such expressions are rvalues, and GCC implements this as a read of the volatile object being pointed to.</source>
          <target state="translated">このような式はr値であり、GCCはこれを指す揮発性のオブジェクトの読み込みとして実装しています。</target>
        </trans-unit>
        <trans-unit id="44cf0f4f846947a1f248438be1e959f7db481213" translate="yes" xml:space="preserve">
          <source>Such tokens may not be concatenated.</source>
          <target state="translated">このようなトークンは連結してはならない。</target>
        </trans-unit>
        <trans-unit id="2bba52ae9199f8bd23584e0938f470a93242074f" translate="yes" xml:space="preserve">
          <source>Support &lt;em&gt;IBM RS/6000 SP&lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt; (PE). Link an application written to use message passing with special startup code to enable the application to run. The system must have PE installed in the standard location (</source>
          <target state="translated">&lt;em&gt;IBM RS / 6000 SP &lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt;（PE）をサポートします。メッセージパッシングを使用するように作成されたアプリケーションを特別な起動コードとリンクして、アプリケーションを実行できるようにします。システムには、標準の場所にPEがインストールされている必要があります（</target>
        </trans-unit>
        <trans-unit id="075bd5530c2b703c7849a9e331065651957bda71" translate="yes" xml:space="preserve">
          <source>Support ISO C trigraphs. These are three-character sequences, all starting with &amp;lsquo;</source>
          <target state="translated">ISO Cトライグラフをサポートします。これらは3文字のシーケンスで、すべて 'で始まります</target>
        </trans-unit>
        <trans-unit id="8219e8938cf7630391bdb51b3542081a049cff2c" translate="yes" xml:space="preserve">
          <source>Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as</source>
          <target state="translated">すべてのISO C90プログラムをサポートします(ISO C90と競合する特定のGNU拡張は無効になります)。と同じです。</target>
        </trans-unit>
        <trans-unit id="54fea23628caa918a67b27ac084d811f983c065d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;resolveClassMethod:&lt;/code&gt; was added to the GNU Objective-C runtime in GCC version 4.6.</source>
          <target state="translated">&lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; および &lt;code&gt;resolveClassMethod:&lt;/code&gt; のサポートは、GCCバージョン4.6のGNU Objective-Cランタイムに追加されました。</target>
        </trans-unit>
        <trans-unit id="dd68cf9e9a0ec7bc0fc781d9f962022790ff0418" translate="yes" xml:space="preserve">
          <source>Support for decimal floating types includes the arithmetic operators add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">10進浮動小数点型のサポートには、算術演算子の加算、減算、乗算、除算が含まれます。単項算術演算子; 関係演算子; 等値演算子; 整数およびその他の浮動小数点型との間の変換。接尾辞を使用してください '</target>
        </trans-unit>
        <trans-unit id="81ca39c921120d2adfd04ac948aaa079d0c3ae01" translate="yes" xml:space="preserve">
          <source>Support for fixed-point types includes:</source>
          <target state="translated">定点型のサポートには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5e968c4a4e334d0a74a0d1d72a11bad05634a930" translate="yes" xml:space="preserve">
          <source>Support for garbage collection with the GNU runtime has been added by using a powerful conservative garbage collector, known as the Boehm-Demers-Weiser conservative garbage collector.</source>
          <target state="translated">GNUランタイムでのガベージコレクションのサポートは、Boehm-Demers-Weiser保守的ガベージコレクタとして知られる強力な保守的ガベージコレクタを使うことで追加されました。</target>
        </trans-unit>
        <trans-unit id="03b50bd9ac9ebf90f9a5662b1d0f6ab814a76b5a" translate="yes" xml:space="preserve">
          <source>Support for streams has been removed and the string to be printed will always be sent to stdout via the &lt;code&gt;write&lt;/code&gt; syscall. The string is not buffered before it is sent to write.</source>
          <target state="translated">ストリームのサポートは削除され、印刷される文字列は常に &lt;code&gt;write&lt;/code&gt; システムコールを介してstdoutに送信されます。文字列は、書き込みに送信される前にバッファリングされません。</target>
        </trans-unit>
        <trans-unit id="0504a68e0c39cc0a79b57df0e39cf16b54d9e942" translate="yes" xml:space="preserve">
          <source>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">これらの追加タイプのサポートには、算術演算子が含まれます。加算、減算、乗算、除算。単項算術演算子; 関係演算子; 等値演算子; 整数およびその他の浮動小数点型との間の変換。接尾辞を使用してください '</target>
        </trans-unit>
        <trans-unit id="43f86c51be480704f6fd0e7ee0fe1bad4e5dee50" translate="yes" xml:space="preserve">
          <source>Support thread-safe exception handling on MinGW. Programs that rely on thread-safe exception handling must compile and link all code with the</source>
          <target state="translated">MinGWでスレッドセーフ例外処理をサポートします。スレッドセーフ例外処理に依存するプログラムは、コンパイルしてすべてのコードを</target>
        </trans-unit>
        <trans-unit id="b789d7421ca6bd2ef122f7c0fe30f55f0075ed29" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;cpu&lt;/var&gt; でサポートされている値は</target>
        </trans-unit>
        <trans-unit id="4bb84e33320d5d24d55a608a57ed95d8069c1f60" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;cpu_type&lt;/var&gt; でサポートされている値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e586e3e5b6ddb947a96ee95bbf9931e047b7a75c" translate="yes" xml:space="preserve">
          <source>Suppose for example you have a &lt;code&gt;FileStream&lt;/code&gt; class that declares &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; as global variables, like below:</source>
          <target state="translated">たとえば、次のように、 &lt;code&gt;Stdin&lt;/code&gt; 、 &lt;code&gt;Stdout&lt;/code&gt; 、および &lt;code&gt;Stderr&lt;/code&gt; をグローバル変数として宣言する &lt;code&gt;FileStream&lt;/code&gt; クラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="e59b9335cfc4b19ac5e0c2f6fad649ab56af701c" translate="yes" xml:space="preserve">
          <source>Suppose the type &lt;code&gt;uid_t&lt;/code&gt; happens to be &lt;code&gt;short&lt;/code&gt;. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definition&amp;rsquo;s argument is really an &lt;code&gt;int&lt;/code&gt;, which does not match the prototype argument type of &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uid_t&lt;/code&gt; 型がたまたま &lt;code&gt;short&lt;/code&gt; と仮定します。古いスタイルの非プロトタイプ定義のサブワード引数が昇格されるため、ISO Cではこの例を使用できません。したがって、この例では、関数定義の引数は実際には &lt;code&gt;int&lt;/code&gt; であり、プロトタイプの引数の型である &lt;code&gt;short&lt;/code&gt; と一致しません。</target>
        </trans-unit>
        <trans-unit id="48ba8dd72d18863780aea11859486731c35e5eea" translate="yes" xml:space="preserve">
          <source>Suppress the generation of link options to search libdld.sl when the</source>
          <target state="translated">の場合、libdld.sl を検索するためのリンクオプションの生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="d35c9ca6cfae417ba88541dbae7bd0b48fb96152" translate="yes" xml:space="preserve">
          <source>Suppress warning messages emitted by &lt;code&gt;#warning&lt;/code&gt; directives.</source>
          <target state="translated">&lt;code&gt;#warning&lt;/code&gt; ディレクティブによって発行される警告メッセージを抑制します。</target>
        </trans-unit>
        <trans-unit id="7f779f6a3dd8fc46f68f940fe5b38cc8f0332cb0" translate="yes" xml:space="preserve">
          <source>Suppress warnings about inheriting from a virtual base with a non-trivial C++11 move assignment operator. This is dangerous because if the virtual base is reachable along more than one path, it is moved multiple times, which can mean both objects end up in the moved-from state. If the move assignment operator is written to avoid moving from a moved-from object, this warning can be disabled.</source>
          <target state="translated">C++11 の非自明な移動代入演算子を使用した仮想ベースからの継承に関する警告を抑制します。これは危険です。仮想ベースが複数のパスに沿って到達可能な場合、仮想ベースは複数回移動されるため、両方のオブジェクトが move-from 状態になってしまう可能性があります。move-from オブジェクトからの移動を避けるために move assignment 演算子を記述した場合、この警告を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="48a42269132ea484d01ac088e414c9e42de642c6" translate="yes" xml:space="preserve">
          <source>Suppress warnings about use of C++11 inheriting constructors when the base class inherited from has a C variadic constructor; the warning is on by default because the ellipsis is not inherited.</source>
          <target state="translated">省略記号が継承されていないため、デフォルトでは警告がオンになっています。</target>
        </trans-unit>
        <trans-unit id="cb3aae6f5324c78295db9baccb5bafa853510ca1" translate="yes" xml:space="preserve">
          <source>Suppress warnings from applying the &lt;code&gt;offsetof&lt;/code&gt; macro to a non-POD type. According to the 2014 ISO C++ standard, applying &lt;code&gt;offsetof&lt;/code&gt; to a non-standard-layout type is undefined. In existing C++ implementations, however, &lt;code&gt;offsetof&lt;/code&gt; typically gives meaningful results. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.</source>
          <target state="translated">警告を非表示にして、 &lt;code&gt;offsetof&lt;/code&gt; マクロを非PODタイプに適用します。2014 ISO C ++標準によれば、 &lt;code&gt;offsetof&lt;/code&gt; を非標準レイアウトタイプに適用することは定義されていません。ただし、既存のC ++実装では、 &lt;code&gt;offsetof&lt;/code&gt; は通常、意味のある結果をもたらします。このフラグは、移植性のないコードを記述していることを認識しており、意図的にそれに関する警告を無視することを選択したユーザーを対象としています。</target>
        </trans-unit>
        <trans-unit id="ba83304e4c99868bbbe79f9fdcf9011c9415eab0" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts from a pointer to an integer type of a different size.</source>
          <target state="translated">異なるサイズの整数型へのポインタからのキャストによる警告を抑制します。</target>
        </trans-unit>
        <trans-unit id="ef9b18daa97b7e3ff555e42290cbf027c56dba77" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error.</source>
          <target state="translated">サイズの異なる整数のポインタ型へのキャストによる警告を抑制します。C++では、より小さなサイズのポインタ型へのキャストはエラーとなります。</target>
        </trans-unit>
        <trans-unit id="d5c7bd9509193e71d10cdb667e9063dd06de3280" translate="yes" xml:space="preserve">
          <source>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the &lt;code&gt;designated_init&lt;/code&gt; attribute.</source>
          <target state="translated">位置指定イニシャライザを使用して、 &lt;code&gt;designated_init&lt;/code&gt; 属性でマークされた構造を初期化するときの警告を抑制します。</target>
        </trans-unit>
        <trans-unit id="b5db30b4023b1a002e3bf61c91080c305981c620" translate="yes" xml:space="preserve">
          <source>Switch ARM/Thumb modes on alternating functions. This option is provided for regression testing of mixed Thumb/ARM code generation, and is not intended for ordinary use in compiling code.</source>
          <target state="translated">ARM/Thumb モードを交互に切り替えます。このオプションは、Thumb/ARM の混在したコード生成のリグレッションテスト用に提供され、コードをコンパイルする際の通常の使用を意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="d7301da94a751f6929a8a4eed4be94e8d5777d3a" translate="yes" xml:space="preserve">
          <source>Switch initialization conversion refuses to create arrays that are bigger than</source>
          <target state="translated">スイッチの初期化変換では</target>
        </trans-unit>
        <trans-unit id="aaf2d10ad0dec99d41b3214114d91b1b2422b89f" translate="yes" xml:space="preserve">
          <source>Switch to code generation variant that allows to execute all threads in each warp, while maintaining memory state and side effects as if only one thread in each warp was active outside of OpenMP SIMD regions. All atomic operations and calls to runtime (malloc, free, vprintf) are conditionally executed (iff current lane index equals the master lane index), and the register being assigned is copied via a shuffle instruction from the master lane. Outside of SIMD regions lane 0 is the master; inside, each thread sees itself as the master. Shared memory array &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; stores all-zeros or all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD regions). Each thread can bitwise-and the bitmask at position &lt;code&gt;tid.y&lt;/code&gt; with current lane index to compute the master lane index.</source>
          <target state="translated">各ワープ内の1つのスレッドのみがOpenMP SIMD領域外でアクティブであるかのようにメモリ状態と副作用を維持しながら、各ワープ内のすべてのスレッドを実行できるコード生成バリアントに切り替えます。すべてのアトミック操作とランタイムへの呼び出し（malloc、free、vprintf）は条件付きで実行され（現在のレーンインデックスがマスターレーンインデックスと等しい場合）、割り当てられているレジスタはマスターレーンからのシャッフル命令を介してコピーされます。SIMD領域外では、レーン0がマスターです。内部では、各スレッドは自分自身をマスターと見なします。共有メモリ配列 &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; は、各ワープのすべて0または1のビットマスクを格納し、現在のモード（SIMD領域外では0）を示します。各スレッドはビット単位であり、ビットマスクは &lt;code&gt;tid.y&lt;/code&gt; の位置にあります。 現在のレーンインデックスを使用して、マスターレーンインデックスを計算します。</target>
        </trans-unit>
        <trans-unit id="df31493a786b81749ab4d7d1c6bbb6b81f2ef537" translate="yes" xml:space="preserve">
          <source>Symbolic constant for call/jump instruction.</source>
          <target state="translated">呼び出し/ジャンプ命令のための記号定数です。</target>
        </trans-unit>
        <trans-unit id="d02b75640f5617b344a6fd481b4fcf74a33c7dab" translate="yes" xml:space="preserve">
          <source>Synonyms for</source>
          <target state="translated">の同義語</target>
        </trans-unit>
        <trans-unit id="a7f02fe7170bb60802488281e7b6535e4525bc7a" translate="yes" xml:space="preserve">
          <source>Syntax without an explicit &lt;var&gt;opts&lt;/var&gt; parameter is deprecated. It is equivalent to specifying an &lt;var&gt;opts&lt;/var&gt; list of:</source>
          <target state="translated">明示的な &lt;var&gt;opts&lt;/var&gt; パラメータのない構文は非推奨です。これは、以下の &lt;var&gt;opts&lt;/var&gt; リストを指定することと同じです。</target>
        </trans-unit>
        <trans-unit id="fb5461d0f57b9c531d984331d59cfb9c2b43a2f9" translate="yes" xml:space="preserve">
          <source>System V Release 4 small data area reference</source>
          <target state="translated">システムVリリース4小データ領域リファレンス</target>
        </trans-unit>
        <trans-unit id="e4a39789bd7be8b8dfec91a966c5aa35d6a313b6" translate="yes" xml:space="preserve">
          <source>TI ABI specifies that function (code) pointers are 16-bit, whereas GNU supports only 32-bit data and code pointers.</source>
          <target state="translated">TI ABIは、関数(コード)のポインタが16ビットであることを指定していますが、GNUは32ビットのデータとコードのポインタのみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="2218a74f01f0ccb4e48f5247664f57112a4f0aaf" translate="yes" xml:space="preserve">
          <source>TI C6X family&amp;mdash;</source>
          <target state="translated">TI C6Xファミリー&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="c941de06f499163c146e2988a363757665dd2da4" translate="yes" xml:space="preserve">
          <source>TILE-Gx&amp;mdash;</source>
          <target state="translated">TILE-Gx&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="94413aebaec1d35ed29622efe6a91644c6c91dd4" translate="yes" xml:space="preserve">
          <source>TILEPro&amp;mdash;</source>
          <target state="translated">TILEPro&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="ecd7eecc4f728ae74383a27923d7203db8bfeb4c" translate="yes" xml:space="preserve">
          <source>Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses. The default is to take advantage of linker relaxations.</source>
          <target state="translated">シンボルアドレスの実体化に必要な命令数を減らすために、リンカーの緩和を利用します。デフォルトでは、リンカー緩和を利用するようになっています。</target>
        </trans-unit>
        <trans-unit id="01d35405dd4f6f085c687c5306bb4a6e617f2e88" translate="yes" xml:space="preserve">
          <source>Taking the address of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted.</source>
          <target state="translated">逆スカラー格納順序で &lt;code&gt;union&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; のアドレスを取得することが許可されています。</target>
        </trans-unit>
        <trans-unit id="9ff36b684e3489808b01be7efb64c6849f9ba0f5" translate="yes" xml:space="preserve">
          <source>Taking the address of a label may generate errors from the HP-UX PA assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">ラベルのアドレスを取得すると、HP-UX PAアセンブラでエラーが発生することがあります。PA用のGASにはこの問題はありません。</target>
        </trans-unit>
        <trans-unit id="8c7129ffec0f9a33a9ffe8b44de153b8593725b3" translate="yes" xml:space="preserve">
          <source>Taking the address of a scalar field of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is not permitted and yields an error.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; スカラーフィールドまたは逆のスカラーストレージ順序を持つ &lt;code&gt;struct&lt;/code&gt; のアドレスを取得することは許可されておらず、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9f5bfaf20daa2c55100557696546e467c263a569" translate="yes" xml:space="preserve">
          <source>Taking the address of an array field, whose component is scalar, of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted but yields a warning, unless</source>
          <target state="translated">成分がスカラーである &lt;code&gt;union&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; または逆スカラー格納順の構造体の配列フィールドのアドレスを取得することは許可されていますが、警告が表示されない限り、</target>
        </trans-unit>
        <trans-unit id="eb41297adae8dd10c30aff884697e8695add6957" translate="yes" xml:space="preserve">
          <source>Taking this into account, it is important to note the following:</source>
          <target state="translated">このことを考慮して、以下のことに注意しましょう。</target>
        </trans-unit>
        <trans-unit id="c69e706d0180e6de86eaea828036822f65c39e90" translate="yes" xml:space="preserve">
          <source>Target architectures are encouraged to provide their own patterns for each of the atomic built-in functions. If no target is provided, the original non-memory model set of &amp;lsquo;</source>
          <target state="translated">ターゲットアーキテクチャでは、アトミックな組み込み関数ごとに独自のパターンを提供することをお勧めします。ターゲットが指定されていない場合、元の非メモリモデルセット '</target>
        </trans-unit>
        <trans-unit id="f7c745960637a96625efff80e3b7b6cb80a28125" translate="yes" xml:space="preserve">
          <source>Target has split instruction and data space. Implies -m45.</source>
          <target state="translated">ターゲットは命令とデータ領域を分割しています。m45を暗示しています。</target>
        </trans-unit>
        <trans-unit id="70857ff656af8497b29b5cea7cede66fd2b8d04e" translate="yes" xml:space="preserve">
          <source>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments.</source>
          <target state="translated">関数型(stdcall、regparmなど)のia32の呼び出し規約など、型の同一性に影響を与えるターゲット固有の属性は、関数ポインタがテンプレート引数として使用されている場合に名前の衝突を引き起こすようなマングルされた名前には影響しませんでした。</target>
        </trans-unit>
        <trans-unit id="55ac9adb172fe07da9b52a8103d4a87829fbaae5" translate="yes" xml:space="preserve">
          <source>Target-specific options, such as compiling for a specific processor variant.</source>
          <target state="translated">特定のプロセッサバリアント用にコンパイルするなど、ターゲット固有のオプション。</target>
        </trans-unit>
        <trans-unit id="82a660e45a245ce196b4fdfa2d1b2b50ce849614" translate="yes" xml:space="preserve">
          <source>Tell the MIPS assembler to not run its preprocessor over user assembler files (with a &amp;lsquo;</source>
          <target state="translated">MIPSアセンブラに、ユーザーアセンブラファイル（ '</target>
        </trans-unit>
        <trans-unit id="68c3b5335b5c0cc22332ebfdb31ac1bb53445273" translate="yes" xml:space="preserve">
          <source>Tells the compiler that any variable marked with the &lt;code&gt;io&lt;/code&gt; attribute is to be considered volatile.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 属性でマークされた変数は揮発性と見なされることをコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="6c80eca69977e6b469c44eecba1a817d3b44f7d0" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 24-bit addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">コンパイラに、関数のアドレスを最初にレジスタにロードしてから、このレジスタ上でサブルーチン呼び出しを実行するように指示します。このスイッチは、ターゲット関数がオフセット・ベース・バージョンのサブルーチン呼び出し命令の24ビット・アドレス範囲外にある場合に必要です。</target>
        </trans-unit>
        <trans-unit id="f7974b9f9368d29b382ac1425edcaf88973b1540" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 64-megabyte addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">コンパイラに、関数のアドレスを最初にレジスタにロードしてから、このレジスタでサブルーチン呼び出しを実行するように指示します。このスイッチは、ターゲット関数がオフセットベースのサブルーチン呼び出し命令の64メガバイトのアドレス範囲外にある場合に必要です。</target>
        </trans-unit>
        <trans-unit id="4035c3eab8e73aa47237d7e7a48fe4ab59208c8f" translate="yes" xml:space="preserve">
          <source>Template Instantiations</source>
          <target state="translated">テンプレートのインスタンス化</target>
        </trans-unit>
        <trans-unit id="eb2cd45b5c86db640ab845c9538624992d63586f" translate="yes" xml:space="preserve">
          <source>Temporaries may vanish before you expect</source>
          <target state="translated">一時的なものは、あなたが思っている前に消えてしまうかもしれません</target>
        </trans-unit>
        <trans-unit id="9f5670dc2252e3e0202f196c05a183f0e891e7ce" translate="yes" xml:space="preserve">
          <source>Temporary assist register $ta (i.e. $r15).</source>
          <target state="translated">一時的なアシストレジスター$ta(すなわち$r15)。</target>
        </trans-unit>
        <trans-unit id="f01689c0a988a52e1980b89817f9a193bf32f058" translate="yes" xml:space="preserve">
          <source>Temporary register r0</source>
          <target state="translated">テンポラリレジスタ r0</target>
        </trans-unit>
        <trans-unit id="eb69100c455a5efc5c637f0862041f54fcc63021" translate="yes" xml:space="preserve">
          <source>That code overwrites the variable &lt;code&gt;Index&lt;/code&gt; (&amp;lsquo;</source>
          <target state="translated">このコードは変数 &lt;code&gt;Index&lt;/code&gt; （ '</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="3d372c7173ccc49ed5f8266482156df6e30a1a0e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bool&amp;rdquo; version returns &lt;code&gt;true&lt;/code&gt; if the comparison is successful and &lt;var&gt;newval&lt;/var&gt; is written. The &amp;ldquo;val&amp;rdquo; version returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; before the operation.</source>
          <target state="translated">比較が成功し、 &lt;var&gt;newval&lt;/var&gt; が書き込まれた場合、「bool」バージョンは &lt;code&gt;true&lt;/code&gt; を返します。「val」バージョンは、操作の前に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; &lt;var&gt;ptr&lt;/var&gt; の内容を返します。</target>
        </trans-unit>
        <trans-unit id="09bc8f2a14ab55c654c682384317bfec0642af39" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;signature&amp;rdquo; is a null-terminated string, composed of the following:</source>
          <target state="translated">「シグネチャ」は、次の要素で構成されるnullで終了する文字列です。</target>
        </trans-unit>
        <trans-unit id="4c06e97499a27f0f80d31e89637ece588d8ec278" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;user time&amp;rdquo; and the &amp;ldquo;system time&amp;rdquo; are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.</source>
          <target state="translated">「ユーザー時間」と「システム時間」はプログラム名の前に移動され、プログラムに渡されたオプションが表示されるので、後でどのファイルがどのオプションでコンパイルされたかがわかります。</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">「</target>
        </trans-unit>
        <trans-unit id="9820649111d032078a2e341b12a064c77a65bbc2" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R10&lt;/code&gt; register.</source>
          <target state="translated">16ビット &lt;code&gt;R10&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="8cd88b0aaf75b51696b24c3768a2b1a20915edac" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R8&lt;/code&gt; register.</source>
          <target state="translated">16ビット &lt;code&gt;R8&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="b1272239002f51f4809e26667c1b13c1b964633d" translate="yes" xml:space="preserve">
          <source>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as</source>
          <target state="translated">1998年のISO C++規格に2003年の技術解説書といくつかの追加の欠陥報告書を加えたもの。同じです。</target>
        </trans-unit>
        <trans-unit id="cfd06b261fe64d273c59c563a73adcb4a19fda6b" translate="yes" xml:space="preserve">
          <source>The 2011 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2011 ISO C ++標準と修正。名前 '</target>
        </trans-unit>
        <trans-unit id="e0824fd4223b0cb3aeed48d8b77f3a1b17acde06" translate="yes" xml:space="preserve">
          <source>The 2014 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2014 ISO C ++標準と修正。名前 '</target>
        </trans-unit>
        <trans-unit id="d75bfd00cf21586d8e597fcc9ed0b86883eb1dfa" translate="yes" xml:space="preserve">
          <source>The 2017 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2017 ISO C ++標準と修正。名前 '</target>
        </trans-unit>
        <trans-unit id="9e4484fd6590cd7f36b6fdf94168a5387d0e46c3" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">GCCの4.1、4.2、および4.3シリーズは、 &lt;code&gt;char&lt;/code&gt; 型のビットフィールドの &lt;code&gt;packed&lt;/code&gt; 属性を無視します。これはGCC 4.4で修正されましたが、変更により構造レイアウトに違いが生じる可能性があります。GCCは、そのようなフィールドのオフセットがGCC 4.4で変更されたときに通知します。たとえば、この構造ではフィールド &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の間に4ビットのパディングはありません。</target>
        </trans-unit>
        <trans-unit id="8937102670278bcd3018a5a5c9e549b76146be93" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This was fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">GCCの4.1、4.2、および4.3シリーズは、 &lt;code&gt;char&lt;/code&gt; 型のビットフィールドの &lt;code&gt;packed&lt;/code&gt; 属性を無視します。これはGCC4.4で修正されましたが、この変更により構造レイアウトに違いが生じる可能性があります。 GCCは、そのようなフィールドのオフセットがGCC4.4で変更されたときに通知します。たとえば、この構造で &lt;code&gt;a&lt;/code&gt; 、フィールドaと &lt;code&gt;b&lt;/code&gt; の間に4ビットのパディングはありません。</target>
        </trans-unit>
        <trans-unit id="909967fe10a21a246a86aeb337d0842e478f43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;cc&quot;&lt;/code&gt; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; serves to name this register. On other machines, condition code handling is different, and specifying &lt;code&gt;&quot;cc&quot;&lt;/code&gt; has no effect. But it is valid no matter what the target.</source>
          <target state="translated">&lt;code&gt;&quot;cc&quot;&lt;/code&gt; クロバーは、アセンブラコードがフラグレジスタ変更することを示しています。一部のマシンでは、GCCは条件コードを特定のハードウェアレジスタとして表します。 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; はこのレジスタに名前を付けるのに役立ちます。他のマシンでは、条件コードの処理が異なり、 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; を指定しても効果はありません。ただし、対象が何であっても有効です。</target>
        </trans-unit>
        <trans-unit id="f2534a799a74c45e086749f66cd7d314d0f206ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the &lt;code&gt;asm&lt;/code&gt;. Further, the compiler does not assume that any values read from memory before an &lt;code&gt;asm&lt;/code&gt; remain unchanged after that &lt;code&gt;asm&lt;/code&gt;; it reloads them as needed. Using the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber effectively forms a read/write memory barrier for the compiler.</source>
          <target state="translated">&lt;code&gt;&quot;memory&quot;&lt;/code&gt; クロバーは、アセンブリコードを行うメモリ（例えば、メモリにアクセスする入力パラメータの一つによって指される）を読み出し、または入力と出力オペランドに記載されたもの以外の項目に書き込むことをコンパイラに指示します。メモリに正しい値が含まれていることを確認するために、GCCは &lt;code&gt;asm&lt;/code&gt; を実行する前に特定のレジスタ値をメモリにフラッシュする必要がある場合があります。さらに、コンパイラーは、 &lt;code&gt;asm&lt;/code&gt; の前にメモリーから読み取られた値が、その &lt;code&gt;asm&lt;/code&gt; の後も変更されないままであることを想定していません。必要に応じて再ロードします。 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; クロバーを使用すると、コンパイラーの読み取り/書き込みメモリーの障壁が効果的に形成されます。</target>
        </trans-unit>
        <trans-unit id="287b2b66c9a7de19b9dd84de221d8d45c3b97aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#pragma GCC target&lt;/code&gt; pragma is presently implemented for x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.</source>
          <target state="translated">&lt;code&gt;#pragma GCC target&lt;/code&gt; プラグマは、現在のx86、ARM、AArch64、PowerPCの、S / 390のために実装、およびNios IIプロセッサのみを対象としています。</target>
        </trans-unit>
        <trans-unit id="3ccfce523413ade3933dc06559f7495350ab0dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; expressions for the same label might have different values if the containing function is inlined or cloned. If a program relies on them being always the same, &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; should be used to prevent inlining and cloning. If &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; is used in a static variable initializer, inlining and cloning is forbidden.</source>
          <target state="translated">含まれている関数がインライン化または複製されている場合、同じラベルの &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; 式の値が異なる可能性があります。プログラムがそれらが常に同じであることに依存している場合は、 &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; を使用して、インライン化と複製を防止する必要があります。場合 &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; インライン化、静的変数の初期化に使用され、クローニングが禁止されています。</target>
        </trans-unit>
        <trans-unit id="33e1502637058c6ab49c207cf28a3e3142aca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; implementation in the GNU runtime guarantees you the following things:</source>
          <target state="translated">GNUランタイムの &lt;code&gt;+load&lt;/code&gt; 実装は、次のことを保証します。</target>
        </trans-unit>
        <trans-unit id="91dd9757303b9f56bf3b6cb9119e24fe8a8727f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; is a method that is not overridden by categories. If a class and a category of it both implement &lt;code&gt;+load&lt;/code&gt;, both methods are invoked. This allows some additional initializations to be performed in a category.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; カテゴリによって上書きされていない方法です。クラスとそのカテゴリの両方が &lt;code&gt;+load&lt;/code&gt; を実装している場合、両方のメソッドが呼び出されます。これにより、いくつかの追加の初期化をカテゴリで実行できます。</target>
        </trans-unit>
        <trans-unit id="772d2fc6151afb4fb1792207ec49f4a45839a16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; method is also invoked when a bundle is dynamically loaded into your running program. This happens automatically without any intervening operation from you. When you write bundles and you need to write &lt;code&gt;+load&lt;/code&gt; you can safely create and send messages to objects whose classes already exist in the running program. The same restrictions as above apply to classes defined in bundle.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; バンドルが動的に実行されているプログラムにロードされたときに方法も呼び出されます。これは、ユーザーの介入操作なしで自動的に行われます。バンドルを作成して &lt;code&gt;+load&lt;/code&gt; を作成する必要がある場合は、実行中のプログラムにすでにクラスが存在するオブジェクトにメッセージを安全に作成して送信できます。上記と同じ制限がバンドルで定義されたクラスに適用されます。</target>
        </trans-unit>
        <trans-unit id="dc6d2c3cb15d85f1417842f0fbdf998d14486ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods thusly generated only operate on instance variables declared in the current Objective-C class, and not those inherited from superclasses. It is the responsibility of the Objective-C runtime to invoke all such methods in an object&amp;rsquo;s inheritance hierarchy. The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; methods are invoked by the runtime immediately after a new object instance is allocated; the &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods are invoked immediately before the runtime deallocates an object instance.</source>
          <target state="translated">このように生成された &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; と &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; メソッドは、現在のObjective-Cクラスで宣言されたインスタンス変数のみを操作し、スーパークラスから継承されたものは操作しません。オブジェクトの継承階層でそのようなメソッドをすべて呼び出すのは、Objective-Cランタイムの責任です。 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 方法は、新しいオブジェクト・インスタンスが割り当てられた直後に実行することによって呼び出されます。 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; ランタイムはオブジェクトインスタンスの割り当てを解除する前に、法がすぐに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e7108ce8eed259a604477fdf012b421d600214df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@finally&lt;/code&gt; clause, if present, will be executed upon exit from the immediately preceding &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section. This will happen regardless of whether any exceptions are thrown, caught or rethrown inside the &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section, analogously to the behavior of the &lt;code&gt;finally&lt;/code&gt; clause in Java.</source>
          <target state="translated">&lt;code&gt;@finally&lt;/code&gt; の句は、存在する場合、直前の終了時に実行される &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; セクション。これは、Javaの &lt;code&gt;finally&lt;/code&gt; 句の動作と同様に、 &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; セクション内で例外がスロー、キャッチ、または再スローされたかどうかに関係なく発生します。</target>
        </trans-unit>
        <trans-unit id="478f5300c419fd9f1ddbebddc4f1aa8b783e2f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@throw&lt;/code&gt; statement may appear anywhere in an Objective-C or Objective-C++ program; when used inside of a &lt;code&gt;@catch&lt;/code&gt; block, the &lt;code&gt;@throw&lt;/code&gt; may appear without an argument (as shown above), in which case the object caught by the &lt;code&gt;@catch&lt;/code&gt; will be rethrown.</source>
          <target state="translated">&lt;code&gt;@throw&lt;/code&gt; の文は、Objective-CまたはObjective-C ++プログラムのどこに表示されることがあります。使用内側場合 &lt;code&gt;@catch&lt;/code&gt; のブロックは、 &lt;code&gt;@throw&lt;/code&gt; は、（上記のように）引数なしで表示されることがあり、その場合に引っ掛かるオブジェクト &lt;code&gt;@catch&lt;/code&gt; は、再スローであろう。</target>
        </trans-unit>
        <trans-unit id="e66bfb70bc3d8564c8867b596c9daf7ef51239bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="7abbdb5d09af41601d4b6214589f91ad242a72c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AX&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;AX&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="e8869263f41399bf1548d77cd0b06fdeab5b6090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="00b8662f23339aa40fc33f83b8bce9ef615fd089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BC&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;BC&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="fafb503a49e3e2b7cffac8865ce407955e8ba5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="c945285a14de09364b5e9d34fc7e6e4e9171bb55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="f334445b19ebbcdfd81f6a6a62d0c7c6a38f5f11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DE&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;DE&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="84d9046824f2223a9b4a7038c1fdd6a7981413ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;E&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="5f8a2094444afcd8a79b22ed65059e8f2a29f862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;H&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="2d1c2a880567113429c4b1cc1d7e5ee3f5c01334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HL&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="eb2a84b1e54ac92e546337e928dcc83ba5c11f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;L&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="d88299e2896aeb367bb70fd25b9a5db675642c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that are otherwise interpreted as a string end or escape.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; の環境変数で指定文字の分類。GCCはこれを使用して、ストリング内の文字境界を判別します。これは、文字列の末尾またはエスケープとして解釈される引用符とエスケープ文字を含む一部のマルチバイトエンコーディングに必要です。</target>
        </trans-unit>
        <trans-unit id="fd95cbfac63c17d00419fc1cfbc5f410bf724a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_MESSAGES&lt;/code&gt; environment variable specifies the language to use in diagnostic messages.</source>
          <target state="translated">&lt;code&gt;LC_MESSAGES&lt;/code&gt; の環境変数は診断メッセージで使用する言語を指定します。</target>
        </trans-unit>
        <trans-unit id="59d7ad50b2abf1611438129375bb15e01da761cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_main&lt;/code&gt; attribute can be used when there &lt;em&gt;is guarantee&lt;/em&gt; that interrupts are disabled at the time when the function is entered. This saves resources when the stack pointer has to be changed to set up a frame for local variables.</source>
          <target state="translated">&lt;code&gt;OS_main&lt;/code&gt; のがあったときに属性を使用することができます&lt;em&gt;保証するものでは&lt;/em&gt;割り込みは関数が入力された時点で無効になっていることは。これにより、ローカル変数のフレームを設定するためにスタックポインターを変更する必要がある場合に、リソースを節約できます。</target>
        </trans-unit>
        <trans-unit id="20f1e35a5360b1f14267221fb24f61e47178d10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_task&lt;/code&gt; attribute can be used when there is &lt;em&gt;no guarantee&lt;/em&gt; that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register is guarded by save/clear/restore of the global interrupt enable flag.</source>
          <target state="translated">&lt;code&gt;OS_task&lt;/code&gt; のがないときに属性を使用することができます&lt;em&gt;保証&lt;/em&gt;割り込みは関数がマルチスレッドのオペレーティングシステムでは、例えばタスク機能のためのように入力され、その時点で無効になっていることは。その場合、スタックポインタレジスタの変更は、グローバル割り込みイネーブルフラグの保存/クリア/復元によって保護されます。</target>
        </trans-unit>
        <trans-unit id="973b834abbbf1594a420dbfab9c679298adbbcc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PSW&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;PSW&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="03b6c46fda7548d67fe293013e4597e13b6cc3ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SP&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="77c3ff8f2bcfaf9382aab427535123ecf6e87b0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; のレジスタ。</target>
        </trans-unit>
        <trans-unit id="f7925d7fc0ef32aa9ba1ce9e18d90f31a2b1041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Float128&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported or where &lt;code&gt;long double&lt;/code&gt; has the IEEE binary128 format. The &lt;code&gt;_Float64x&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported. The &lt;code&gt;_Float32&lt;/code&gt; type is supported on all systems supporting IEEE binary32; the &lt;code&gt;_Float64&lt;/code&gt; and &lt;code&gt;_Float32x&lt;/code&gt; types are supported on all systems supporting IEEE binary64. The &lt;code&gt;_Float16&lt;/code&gt; type is supported on AArch64 systems by default, and on ARM systems when the IEEE format for 16-bit floating-point types is selected with</source>
          <target state="translated">&lt;code&gt;_Float128&lt;/code&gt; のタイプは、すべてのシステムでサポートされてい &lt;code&gt;__float128&lt;/code&gt; がサポートされている場合や、 &lt;code&gt;long double&lt;/code&gt; IEEE binary128形式を持っています。 &lt;code&gt;_Float64x&lt;/code&gt; のタイプは、すべてのシステムでサポートされてい &lt;code&gt;__float128&lt;/code&gt; がサポートされています。 &lt;code&gt;_Float32&lt;/code&gt; のタイプは、IEEEのbinary32をサポートするすべてのシステムでサポートされています。 &lt;code&gt;_Float64&lt;/code&gt; と &lt;code&gt;_Float32x&lt;/code&gt; タイプは、IEEE binary64をサポートするすべてのシステムでサポートされています。 &lt;code&gt;_Float16&lt;/code&gt; のタイプは、デフォルトでAArch64システムでサポートされており、ARMシステム上で16ビット浮動小数点タイプのIEEE形式は、で選択された場合</target>
        </trans-unit>
        <trans-unit id="85103cf2482f16ae09dc93810b2ec0258970e808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; specifies the first abort code which can be used for &lt;code&gt;__builtin_tabort&lt;/code&gt;. Values below this threshold are reserved for machine use.</source>
          <target state="translated">&lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; は、で定義された &lt;code&gt;htmintrin.h&lt;/code&gt; 指定するために使用することができる第一アボートコード &lt;code&gt;__builtin_tabort&lt;/code&gt; を。このしきい値を下回る値は、マシンでの使用のために予約されています。</target>
        </trans-unit>
        <trans-unit id="392542e4dc2c75d48ed6b1e9e4e666156b2ab35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses.</source>
          <target state="translated">&lt;code&gt;__attribute__&lt;/code&gt; のキーワードは、二重括弧で囲まれた属性指定が続いています。</target>
        </trans-unit>
        <trans-unit id="0f8acb405a5cf121cc5773d2c4339fe65a77bcf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; macro. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when &lt;code&gt;__builtin_alloca&lt;/code&gt; is called within a nested block.</source>
          <target state="translated">&lt;code&gt;__builtin_alloca&lt;/code&gt; の機能は、ブロックスコープで呼び出さなければなりません。この関数は、呼び出し元の関数のスタックに大きいオブジェクト &lt;var&gt;size&lt;/var&gt; バイトを割り当てます。オブジェクトは、 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; マクロによって決定されたターゲットのデフォルトのスタックアライメント境界に揃えられます。 &lt;code&gt;__builtin_alloca&lt;/code&gt; の機能が割り当てられたオブジェクトの最初のバイトへのポインタを返します。割り当てられたオブジェクトの有効期間は、呼び出し元の関数が呼び出し元に戻る直前に終了します。これは、ネストされたブロック内で &lt;code&gt;__builtin_alloca&lt;/code&gt; が呼び出された場合でも同じです。</target>
        </trans-unit>
        <trans-unit id="699047c637b673c64e86fa3b74734bf759b728ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument &lt;var&gt;alignment&lt;/var&gt; whose unit is given in bits (not bytes). The &lt;var&gt;size&lt;/var&gt; argument must be positive and not exceed the stack size limit. The &lt;var&gt;alignment&lt;/var&gt; argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to &lt;code&gt;CHAR_BIT&lt;/code&gt; and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called.</source>
          <target state="translated">&lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 機能はブロックスコープで呼び出さなければなりません。この関数は、呼び出し元の関数のスタックに大きいオブジェクト &lt;var&gt;size&lt;/var&gt; バイトを割り当てます。割り当てられたオブジェクトは、引数の &lt;var&gt;alignment&lt;/var&gt; で指定された境界に配置されます。その単位は、バイトではなくビットで指定されます。 &lt;var&gt;size&lt;/var&gt; 引数が正で、スタックのサイズ制限を超えてはなりません。 &lt;var&gt;alignment&lt;/var&gt; 引数は、2以上のパワーに評価よりまたは等しいことを表現整数定数でなければならない &lt;code&gt;CHAR_BIT&lt;/code&gt; 不特定の最大値よりも少ない。他の値を使用した呼び出しは、有効な範囲を示すエラーで拒否されます。関数は、割り当てられたオブジェクトの最初のバイトへのポインタを返します。割り当てられたオブジェクトの有効期間は、関数が呼び出されたブロックの最後で終了します。割り当てられたストレージは、呼び出し元の関数が呼び出し元に戻る直前までに解放されますが、関数が呼び出されたブロックの終わりに解放される場合があります。</target>
        </trans-unit>
        <trans-unit id="d14b3efa7fa2847225bae57a72e4dc716953742d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; and &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; require an environment supporting ISA 3.0 or later. For these two functions, the &lt;code&gt;range&lt;/code&gt; argument is encoded as 4 bytes, organized as &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt;. The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument is within the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive. The &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; function returns non-zero if and only if its &lt;code&gt;u&lt;/code&gt; argument is within either the range bounded between &lt;code&gt;lo_1&lt;/code&gt; and &lt;code&gt;hi_1&lt;/code&gt; inclusive or the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive.</source>
          <target state="translated">&lt;code&gt;__builtin_byte_in_range&lt;/code&gt; と &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; ISA 3.0以降をサポートする環境が必要です。これら2つの関数の場合、引数 &lt;code&gt;range&lt;/code&gt; は4バイトとしてエンコードされ、 &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt; として編成されます。 &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; の関数は、非ゼロ値を返した場合にのみ、その場合 &lt;code&gt;u&lt;/code&gt; 引数の間境界範囲内である &lt;code&gt;lo_2&lt;/code&gt; と &lt;code&gt;hi_2&lt;/code&gt; 包括。 &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; の関数は、非ゼロを返す場合、その場合にのみ、 &lt;code&gt;u&lt;/code&gt; 引数は、間に制限の範囲のいずれか内にある &lt;code&gt;lo_1&lt;/code&gt; と &lt;code&gt;hi_1&lt;/code&gt; 包括的、または &lt;code&gt;lo_2&lt;/code&gt; と &lt;code&gt;hi_2&lt;/code&gt; の間に含まれる範囲。</target>
        </trans-unit>
        <trans-unit id="e9c90a92a294d6da36a67b6812f4d7f784a68c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; function requires a 64-bit environment supporting ISA 3.0 or later. This function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument exactly equals one of the eight bytes contained within its 64-bit &lt;code&gt;set&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;__builtin_byte_in_set&lt;/code&gt; の機能は、ISA 3.0以降をサポートする64ビット環境が必要です。この関数は、その &lt;code&gt;u&lt;/code&gt; 引数が64ビットの &lt;code&gt;set&lt;/code&gt; 引数に含まれる8バイトの1つと正確に等しい場合にのみ、ゼロ以外の値を返します。</target>
        </trans-unit>
        <trans-unit id="fb729367b3d36e784ee118ae00a98821f8cbe5c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cmpb&lt;/code&gt; function performs a byte-wise compare on the contents of its two arguments, returning the result of the byte-wise comparison as the returned value. For each byte comparison, the corresponding byte of the return value holds 0xff if the input bytes are equal and 0 if the input bytes are not equal. If either of the arguments to this built-in function is wider than 32 bits, the function call expands into the form that expects &lt;code&gt;unsigned long long int&lt;/code&gt; arguments which is only available on 64-bit targets.</source>
          <target state="translated">&lt;code&gt;__builtin_cmpb&lt;/code&gt; 関数を実行するには、バイト単位の戻り値として、バイト単位の比較の結果を返す、その2つの引数の内容を比較します。各バイト比較では、入力バイトが等しい場合、戻り値の対応するバイトは0xffを保持し、入力バイトが等しくない場合は0を保持します。この組み込み関数への引数のいずれかが32ビットより広い場合、関数呼び出しは、64ビットターゲットでのみ使用可能な &lt;code&gt;unsigned long long int&lt;/code&gt; 引数を予期する形式に拡張されます。</target>
        </trans-unit>
        <trans-unit id="26cf6e5166e71a9dc3d72ae3910f453428861ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_is&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">&lt;code&gt;__builtin_cpu_is&lt;/code&gt; の機能は、ハードウェアの能力ビットをエクスポートGLIBC 2.23以降を必要とします。 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 組み込み関数が完全にサポートされている場合、GCCはマクロ &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="225ecb4eafc9e778fee170a226e93b379e52b096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">&lt;code&gt;__builtin_cpu_supports&lt;/code&gt; の機能は、ハードウェアの能力ビットをエクスポートGLIBC 2.23以降を必要とします。 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 組み込み関数が完全にサポートされている場合、GCCはマクロ &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="9d549e750824586a0354c272406d5e4e5816a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_darn&lt;/code&gt; and &lt;code&gt;__builtin_darn_raw&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;__builtin_darn&lt;/code&gt; function provides a 64-bit conditioned random number. The &lt;code&gt;__builtin_darn_raw&lt;/code&gt; function provides a 64-bit raw random number. The &lt;code&gt;__builtin_darn_32&lt;/code&gt; function provides a 32-bit conditioned random number.</source>
          <target state="translated">&lt;code&gt;__builtin_darn&lt;/code&gt; と &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 機能は、ISA 3.0以降をサポートする64ビットの環境を必要とします。 &lt;code&gt;__builtin_darn&lt;/code&gt; の関数は、64ビットの馴化乱数を提供します。 &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 関数は、64ビットの生の乱数を提供します。 &lt;code&gt;__builtin_darn_32&lt;/code&gt; の関数は、32ビットの馴化乱数を提供します。</target>
        </trans-unit>
        <trans-unit id="fc4f02a6f5765f9e617ea8ee9a4170e4b962d403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument equals its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; のとのsignficant桁数だけあれば場合、関数はゼロ以外の値を返す &lt;code&gt;value&lt;/code&gt; 引数が等しい &lt;code&gt;comparison&lt;/code&gt; 引数。 &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; と &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; 機能は同様に振る舞うが、タイプことを必要とする &lt;code&gt;value&lt;/code&gt; 引数があること &lt;code&gt;__Decimal64&lt;/code&gt; と &lt;code&gt;__Decimal128&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="57591fb5134dd8d315ee0a2d1522ee30d9827c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is greater than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; の関数は、非ゼロ値を返す場合、そののsignficant桁数だけあれば &lt;code&gt;value&lt;/code&gt; 引数がより大きい &lt;code&gt;comparison&lt;/code&gt; 引数。 &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; と &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; 機能は同様に振る舞うが、タイプことを必要とする &lt;code&gt;value&lt;/code&gt; 引数があること &lt;code&gt;__Decimal64&lt;/code&gt; と &lt;code&gt;__Decimal128&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="b01dbf5e64c194eb164595e23ee9b740573ded8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is less than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; の関数は、非ゼロ値を返す場合、そののsignficant桁数だけあれば &lt;code&gt;value&lt;/code&gt; 引数は以下のより &lt;code&gt;comparison&lt;/code&gt; 引数。 &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; と &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; 機能は同様に振る舞うが、タイプことを必要とする &lt;code&gt;value&lt;/code&gt; 引数があること &lt;code&gt;__Decimal64&lt;/code&gt; と &lt;code&gt;__Decimal128&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="b4420e5d860b7c4bb7ba6d7a8d1a6213bfe7043a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;value&lt;/code&gt; argument has an undefined number of significant digits, such as when &lt;code&gt;value&lt;/code&gt; is an encoding of &lt;code&gt;NaN&lt;/code&gt;. The &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; の関数は、非ゼロ値を返した場合にのみ、その場合に &lt;code&gt;value&lt;/code&gt; 引数は、そのような場合など、有効数字の不定数持つ &lt;code&gt;value&lt;/code&gt; の符号化で &lt;code&gt;NaN&lt;/code&gt; 。 &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; と &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; 機能は同様に振る舞うが、タイプことを必要とする &lt;code&gt;value&lt;/code&gt; 引数があること &lt;code&gt;__Decimal64&lt;/code&gt; と &lt;code&gt;__Decimal128&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="a0bfeb225a5faf6d6577d095e4bb9f94249f0a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function evaluates to an integer constant expression equal to &lt;code&gt;true&lt;/code&gt; if the symbol or type referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument has been declared with the &lt;var&gt;attribute&lt;/var&gt; referenced by the second argument. For an &lt;var&gt;type-or-expression&lt;/var&gt; argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The &lt;var&gt;type-or-expression&lt;/var&gt; argument is subject to the same restrictions as the argument to &lt;code&gt;typeof&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;). The &lt;var&gt;attribute&lt;/var&gt; argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names&amp;mdash;with and without double leading and trailing underscores&amp;mdash;are recognized. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;type-or-expression&lt;/var&gt; has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns &lt;code&gt;true&lt;/code&gt; if all provided arguments match. For example, the first call to the function below evaluates to &lt;code&gt;true&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared with the &lt;code&gt;aligned&lt;/code&gt; attribute but the second call evaluates to &lt;code&gt;false&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared &lt;code&gt;aligned (8)&lt;/code&gt; and not &lt;code&gt;aligned (4)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__builtin_has_attribute&lt;/code&gt; 整数定数式に機能評価さに等しい &lt;code&gt;true&lt;/code&gt; で参照記号または入力する場合 &lt;var&gt;type-or-expression&lt;/var&gt; 引数はで宣言された &lt;var&gt;attribute&lt;/var&gt; 二番目の引数によって参照されます。以下のための &lt;var&gt;type-or-expression&lt;/var&gt; 属性は、組み込みの引数の型を考慮して、式には適用されないので、シンボルを参照しない引数。どちらの引数も評価されません。 &lt;var&gt;type-or-expression&lt;/var&gt; 引数は、引数と同じ制限を受ける &lt;code&gt;typeof&lt;/code&gt; 演算（参照&lt;a href=&quot;typeof#Typeof&quot;&gt;typeof演算します&lt;/a&gt;）。 &lt;var&gt;attribute&lt;/var&gt; argumentは属性名で、オプションで、括弧で囲まれた引数のコンマ区切りのリストが後に続きます。属性名の両方の形式（先頭と末尾に二重のアンダースコアがある場合とない場合）が認識されます。詳細については、「&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性の構文&lt;/a&gt;」を参照してください。 1つ以上の引数が必要な属性に属性引数が指定されていない場合、属性引数の値に関係なく、 &lt;var&gt;type-or-expression&lt;/var&gt; が属性で宣言されている場合、関数は &lt;code&gt;true&lt;/code&gt; を返します。いくつかを期待する属性に提供された引数は、検証され、提供された数値と一致します。指定されたすべての引数が一致する場合、関数は &lt;code&gt;true&lt;/code&gt; を返します。たとえば、以下の関数の最初の呼び出しは &lt;code&gt;true&lt;/code&gt; と評価されますので、 &lt;code&gt;x&lt;/code&gt; がで宣言されて &lt;code&gt;aligned&lt;/code&gt; する属性が、2番目のコール評価する &lt;code&gt;false&lt;/code&gt; ので、 &lt;code&gt;x&lt;/code&gt; が宣言されている &lt;code&gt;aligned (8)&lt;/code&gt; していない &lt;code&gt;aligned (4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cbfc7ec73fa262c76440a5134fc2d0584d6a4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; function is available only in C++. The built-in is intended to be used by implementations of the &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C++ function. Programs should make use of the latter function rather than invoking the built-in directly.</source>
          <target state="translated">&lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; 機能はC ++で提供されています。組み込み関数は、 &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C ++関数の実装で使用することを目的としています。プログラムは、組み込み関数を直接呼び出すのではなく、後者の関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c4494406f2455746a4c649b18a2c01e01f2fd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_mffsl&lt;/code&gt; uses the ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; instruction to read the FPSCR. The instruction is a lower latency version of the &lt;code&gt;mffs&lt;/code&gt; instruction. If the &lt;code&gt;mffsl&lt;/code&gt; instruction is not available, then the builtin uses the older &lt;code&gt;mffs&lt;/code&gt; instruction to read the FPSCR.</source>
          <target state="translated">&lt;code&gt;__builtin_mffsl&lt;/code&gt; は ISA 3.0使用 &lt;code&gt;mffsl&lt;/code&gt; の FPSCRを読むための指示を。この命令は、 &lt;code&gt;mffs&lt;/code&gt; 命令の低レイテンシバージョンです。場合 &lt;code&gt;mffsl&lt;/code&gt; の命令が利用できない場合、組み込みは、古い使用 &lt;code&gt;mffs&lt;/code&gt; の FPSCRを読むための指示を。</target>
        </trans-unit>
        <trans-unit id="1c6f10224f071b484a2f23cb973dde539bd04b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;__ibm128&lt;/code&gt; value that combines the two arguments.</source>
          <target state="translated">&lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; の関数は二つのかかる &lt;code&gt;double&lt;/code&gt; 引数を返すと &lt;code&gt;__ibm128&lt;/code&gt; の二つの引数を組み合わせた値を。</target>
        </trans-unit>
        <trans-unit id="ce45c9f46fdb649818045c7651274a51c7c9b814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;long double&lt;/code&gt; value that combines the two arguments. The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">&lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 関数は二つのかかる &lt;code&gt;double&lt;/code&gt; 引数を返すと &lt;code&gt;long double&lt;/code&gt; つの引数を組み合わせた値を。 &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 機能がある場合にのみ使用可能です &lt;code&gt;long double&lt;/code&gt; IBMは、二重の表現を拡張用途。</target>
        </trans-unit>
        <trans-unit id="8465d06a8e70b59990aa3c2108eef59db7b2906e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">&lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; と &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 機能は、タイムベースレジスタを読み込むための命令を生成します。 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; の機能は、複数の命令を生成し、常にタイムベースレジスタの64ビットを返すことができます。 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 機能は、常に1つの命令を生成して、32ビット環境に離れて最も重要な言葉を投げ、unsigned long型としてタイムベースレジスタの値を返します。 &lt;code&gt;__builtin_mffs&lt;/code&gt; は、 FPSCRレジスタの値を返します。 ISA 3.0は &lt;code&gt;__builtin_mffsl()&lt;/code&gt; をサポートしていることに注意してください。これにより、ソフトウェアは、スティッキーステータスビットへのアクセスに関連するレイテンシを長くすることなく、FSPCRの制御および非スティッキーステータスビットを読み取ることができます。 &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; と &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; は、引数として変更にビットを取ります。有効なビット範囲は &lt;code&gt;mtfsb1&lt;/code&gt; は、引数を取り、32を追加する &lt;code&gt;mtfsb0&lt;/code&gt; およびmtfsb1命令にマップします。したがって、これらの命令は、指定されたビットを0または1に変更することによってFPSCR [32:63]ビットのみを変更しますそれぞれ。 &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 組み込みは、モードビットを丸め浮動小数点の両方を変化させることができます。引数は2ビット値です。引数は &lt;code&gt;const int&lt;/code&gt; のいずれかですまたは変数に格納されます。 &lt;code&gt;mffscrn&lt;/code&gt; 、可能な場合はISA 3.0命令mffscrnを使用します。それ以外の場合は、FPSCRを読み取り、現在の丸めモードビットと新しい値のORをマスクします。</target>
        </trans-unit>
        <trans-unit id="f74488ec411590dcc75315f19183a037dc14b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsf&lt;/code&gt; takes a constant 8-bit integer field mask and a double precision floating point argument and generates the &lt;code&gt;mtfsf&lt;/code&gt; (extended mnemonic) instruction to write new values to selected fields of the FPSCR. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">&lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; と &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 機能は、タイムベースレジスタを読み込むための命令を生成します。 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; の機能は、複数の命令を生成し、常にタイムベースレジスタの64ビットを返すことができます。 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 機能は、常に1つの命令を生成して、32ビット環境に離れて最も重要な言葉を投げ、unsigned long型としてタイムベースレジスタの値を返します。 &lt;code&gt;__builtin_mffs&lt;/code&gt; は、 FPSCRレジスタの値を返します。 ISA 3.0は &lt;code&gt;__builtin_mffsl()&lt;/code&gt; をサポートしていることに注意してくださいこれにより、ソフトウェアは、スティッキーステータスビットへのアクセスに関連する待ち時間を長くすることなく、FSPCRの制御ビットと非スティッキーステータスビットを読み取ることができます。 &lt;code&gt;__builtin_mtfsf&lt;/code&gt; は一定の8ビット整数フィールドマスクと倍精度浮動小数点引数を取り、生成 &lt;code&gt;mtfsf&lt;/code&gt; FPSCRの選択されたフィールドに新しい値を書き込む（拡張ニーモニック）命令。 &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; と &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; は、引数として変更にビットを取ります。有効なビット範囲は &lt;code&gt;mtfsb1&lt;/code&gt; は &lt;code&gt;mtfsb0&lt;/code&gt; およびmtfsb1にマップされます。引数を取り、32を加算する命令。したがって、これらの命令は、指定されたビットをそれぞれ0または1に変更することによって、FPSCR [32:63]ビットのみを変更します。 &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 組み込みは、モードビットを丸め浮動小数点の両方を変化させることができます。引数は2ビット値です。引数は、 &lt;code&gt;const int&lt;/code&gt; にすることも、変数に格納することもできます。 &lt;code&gt;mffscrn&lt;/code&gt; 、使用可能な場合はISA 3.0命令mffscrnを使用します。それ以外の場合は、FPSCRを読み取り、現在の丸めモードのビットをマスクし、新しい値のORをマスクします。</target>
        </trans-unit>
        <trans-unit id="198788e1a597fcc05831a074890ff7147c3e1998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_recipdiv&lt;/code&gt;, and &lt;code&gt;__builtin_recipdivf&lt;/code&gt; functions generate multiple instructions to implement division using the reciprocal estimate instructions.</source>
          <target state="translated">&lt;code&gt;__builtin_recipdiv&lt;/code&gt; 、及び &lt;code&gt;__builtin_recipdivf&lt;/code&gt; 機能が相互推定手順を使用して分割を実装する複数の命令を生成します。</target>
        </trans-unit>
        <trans-unit id="eca84e06c376750982f7cbde8f6e8edd81f796b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; function takes a &lt;code&gt;__ibm128&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;__ibm128&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; の機能がかかり &lt;code&gt;__ibm128&lt;/code&gt; の引数と定数は0、最初の場合は0または1のコンパイル時定数 &lt;code&gt;double&lt;/code&gt; 内 &lt;code&gt;__ibm128&lt;/code&gt; 返され、そうでなければ第 &lt;code&gt;double&lt;/code&gt; 返されています。</target>
        </trans-unit>
        <trans-unit id="48855b25f6a50b8b8736a064f19a8b37e730a064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function takes a &lt;code&gt;long double&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;long double&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned. The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">&lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 関数がかかり &lt;code&gt;long double&lt;/code&gt; 引数と0または1の定数が0である場合のコンパイル時定数、第 &lt;code&gt;double&lt;/code&gt; 内の &lt;code&gt;long double&lt;/code&gt; 返され、そうでなければ第 &lt;code&gt;double&lt;/code&gt; 返されています。 &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 機能がある場合にのみ使用可能です &lt;code&gt;long double&lt;/code&gt; IBMは、二重の表現を拡張用途。</target>
        </trans-unit>
        <trans-unit id="cf7f4f10325e1d8819fa9c82ff898e127032c07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__flash&lt;/code&gt; qualifier locates data in the &lt;code&gt;.progmem.data&lt;/code&gt; section. Data is read using the &lt;code&gt;LPM&lt;/code&gt; instruction. Pointers to this address space are 16 bits wide.</source>
          <target state="translated">&lt;code&gt;__flash&lt;/code&gt; でデータを検索します修飾子 &lt;code&gt;.progmem.data&lt;/code&gt; セクション。データは、 &lt;code&gt;LPM&lt;/code&gt; 命令を使用して読み取られます。このアドレス空間へのポインタは16ビット幅です。</target>
        </trans-unit>
        <trans-unit id="097ea3d6342e0a23a9235845e85db17d4022ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__fp16&lt;/code&gt; type may only be used as an argument to intrinsics defined in &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt;, or as a storage format. For purposes of arithmetic and other operations, &lt;code&gt;__fp16&lt;/code&gt; values in C or C++ expressions are automatically promoted to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__fp16&lt;/code&gt; のタイプのみで定義された組み込み関数の引数として使用することができる &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt; 、または保存形式として。算術演算やその他の演算のために、CまたはC ++式の &lt;code&gt;__fp16&lt;/code&gt; 値は自動的に &lt;code&gt;float&lt;/code&gt; に昇格されます。</target>
        </trans-unit>
        <trans-unit id="ec03917f805a8e50fbb98586530e665bfe69da73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier can be applied only to the names of objects and to anonymous unions.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; の指定子は唯一のオブジェクトの名前にし、匿名組合に適用することができます。</target>
        </trans-unit>
        <trans-unit id="f3af60ab1131c66623c0fb9cd375a6e888cff899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 指定子は、任意のグローバル、ファイルスコープの静的、関数スコープの静的、またはクラスの静的データメンバに適用することができます。ブロックスコープの自動または非静的データメンバーには適用できません。</target>
        </trans-unit>
        <trans-unit id="d8177fe879ae4fe2cff503c3513d84606c176b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, with the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers, but with no other storage class specifier. When used with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;__thread&lt;/code&gt; must appear immediately after the other storage class specifier.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 指定子と、単独で使用してもよい &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; 指定子、ない他の記憶クラス指定子で。 &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; とともに使用する場合、 &lt;code&gt;__thread&lt;/code&gt; は他のストレージクラス指定子の直後に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="63dae9f24b29dc710773ce4dac88b4e87c3c52d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier shall be used only with variables.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; の指定子は変数のみで使用されなければなりません。</target>
        </trans-unit>
        <trans-unit id="adf603edfc142efac4a9a3b77d51d44293820a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__trampolines_start&lt;/code&gt; symbol is defined in the linker script.</source>
          <target state="translated">&lt;code&gt;__trampolines_start&lt;/code&gt; のシンボルは、リンカスクリプトで定義されています。</target>
        </trans-unit>
        <trans-unit id="375e8541e5237f24ef902439af8b3c21cd835020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; registers. This class is used for instructions that return double word results in the &lt;code&gt;ax:dx&lt;/code&gt; register pair. Single word values will be allocated either in &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. For example on i386 the following implements &lt;code&gt;rdtsc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;d&lt;/code&gt; のレジスタ。このクラスは、ダブルワードの結果を &lt;code&gt;ax:dx&lt;/code&gt; レジスタペアで返す命令に使用されます。単一のワード値は、 &lt;code&gt;ax&lt;/code&gt; または &lt;code&gt;dx&lt;/code&gt; のいずれかに割り当てられます。たとえば、i386では次のように &lt;code&gt;rdtsc&lt;/code&gt; を実装します。</target>
        </trans-unit>
        <trans-unit id="a0d40f91f92592e29ec24cddc648e15fc94fdbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="bf9b97f6ebb578cc8aa854722849a8e5b4602c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abi_tag&lt;/code&gt; attribute can be applied to a function, variable, or class declaration. It modifies the mangled name of the entity to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.</source>
          <target state="translated">&lt;code&gt;abi_tag&lt;/code&gt; の属性は、関数、変数、またはクラス宣言に適用することができます。エンティティのマングルされた名前を変更してタグ名を組み込み、関数またはクラスを異なるABIを持つ以前のバージョンと区別します。おそらくクラスのサイズが変更されたか、関数にマングルされた名前でエンコードされていない異なる戻り値の型があります。</target>
        </trans-unit>
        <trans-unit id="7fe3aef8751a598cb1fd1f579f51dc2e77fc03d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute enables the detection of invalid or unsafe accesses by functions to which they apply or their callers, as well as write-only accesses to objects that are never read from. Such accesses may be diagnosed by warnings such as</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 属性は、それらが適用される機能やその発信者が無効または危険なアクセスを検出することができるだけでなく、書き込み専用から読み取ることはありませんされているオブジェクトにアクセスします。このようなアクセスは、次のような警告によって診断される場合があります。</target>
        </trans-unit>
        <trans-unit id="3485b263c83290ae97682123760b0adc0b05426c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute specifies that a function to whose by-reference arguments the attribute applies accesses the referenced object according to &lt;var&gt;access-mode&lt;/var&gt;. The &lt;var&gt;access-mode&lt;/var&gt; argument is required and must be one of three names: &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;read_write&lt;/code&gt;, or &lt;code&gt;write_only&lt;/code&gt;. The remaining two are positional arguments.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 属性を指定する属性が適用され、その参照による引数に関数は、に応じて参照されたオブジェクトにアクセスする &lt;var&gt;access-mode&lt;/var&gt; 。 &lt;var&gt;access-mode&lt;/var&gt; 引数が必要とされ、3つの名前のいずれかでなければなりません： &lt;code&gt;read_only&lt;/code&gt; 、 &lt;code&gt;read_write&lt;/code&gt; 、または &lt;code&gt;write_only&lt;/code&gt; 。残りの2つは位置引数です。</target>
        </trans-unit>
        <trans-unit id="2ecdfed9d96d6be598a27e07d494142206025586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance,</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 属性が宣言が指定されなければならない他のシンボルの別名として放出させます。例えば、</target>
        </trans-unit>
        <trans-unit id="7e61edae77066dd3dc159fcdac928cd068378010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must have been previously declared with the same type, and for variables, also the same size and alignment. Declaring an alias with a different type than the target is undefined and may be diagnosed. As an example, the following declarations:</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 属性が宣言が以前に同じ型で宣言されていなければならない他のシンボルの別名として放出させ、変数、また同じサイズおよび位置合わせのため。ターゲットとは異なるタイプのエイリアスを宣言することは未定義であり、診断される可能性があります。例として、次の宣言：</target>
        </trans-unit>
        <trans-unit id="eb2be5f23f4d95994e296cf8157df7b27aa96115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; variable attribute causes the declaration to be emitted as an alias for another symbol known as an &lt;em&gt;alias target&lt;/em&gt;. Except for top-level qualifiers the alias target must have the same type as the alias. For instance, the following</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 変数属性は、宣言として知られる別のシンボルの別名として出射させる&lt;em&gt;エイリアスターゲット&lt;/em&gt;。トップレベルの修飾子を除いて、エイリアスターゲットはエイリアスと同じタイプである必要があります。たとえば、次の</target>
        </trans-unit>
        <trans-unit id="0bf61029ae4ce438827c598f61cf786192d3f583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性も（参照機能のために使用することができ&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;、共通機能の属性を&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="116110dd4cf7976fa8985541dcc415370c4044c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for variables and fields (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性は、変数やフィールドに使用することができます（参照&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数の属性を&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5b5ae34d39ede17878fd463e5860c5561589d603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment (in bytes) for variables of the specified type. When specified, &lt;var&gt;alignment&lt;/var&gt; must be a power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes. For example, the declarations:</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性が指定されたタイプの変数の（バイト）最小アラインメントを指定します。指定する場合、 &lt;var&gt;alignment&lt;/var&gt; は2の累乗でなければなりません &lt;var&gt;alignment&lt;/var&gt; 引数を指定しないことは、ターゲットの最大の境界整列を意味します。これは、多くの場合、常にではありませんが、8バイトまたは16バイトです。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="84a176d406c41abb708c1f3ca71eadfaf0924f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the first instruction of the function, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the ideal alignment for the target. The &lt;code&gt;__alignof__&lt;/code&gt; operator can be used to determine what that is (see &lt;a href=&quot;alignment#Alignment&quot;&gt;Alignment&lt;/a&gt;). The attribute has no effect when a definition for the function is not provided in the same translation unit.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性は、バイト単位で測定された関数の最初の命令の最小アラインメントを指定します。指定する場合、 &lt;var&gt;alignment&lt;/var&gt; は2の整数定数乗でなければなりません &lt;var&gt;alignment&lt;/var&gt; 引数を指定しないと、ターゲットの理想的な配置になります。 &lt;code&gt;__alignof__&lt;/code&gt; のオペレータは、（参照それが何であるかを決定するために使用することができる&lt;a href=&quot;alignment#Alignment&quot;&gt;アライメントを&lt;/a&gt;）。関数の定義が同じ変換単位で提供されていない場合、この属性は効果がありません。</target>
        </trans-unit>
        <trans-unit id="8ba9bd3f254f0cc2bc69cd8b105c1d09efd2f77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the variable or structure field, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性は、バイト単位で測定された変数または構造体フィールドの最小アラインメントを、指定します。指定する場合、 &lt;var&gt;alignment&lt;/var&gt; は2の整数定数乗である必要があります &lt;var&gt;alignment&lt;/var&gt; 引数を指定しないと、ターゲットの最大の境界整列を意味します。これは、多くの場合、常に8バイトまたは16バイトです。</target>
        </trans-unit>
        <trans-unit id="f46b2b0bb9e3e850ca63944ddf914702b4818ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_align&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer is aligned on a boundary given by the function argument at &lt;var&gt;position&lt;/var&gt;. Meaningful alignments are powers of 2 greater than one. GCC uses this information to improve pointer alignment analysis.</source>
          <target state="translated">&lt;code&gt;alloc_align&lt;/code&gt; 属性は、ポインタを返し、整数または列挙型の少なくとも一つの引数を取る関数に適用してもよいです。これは、返されたポインタがで関数の引数で与えられた境界上に整列されていることを示し &lt;var&gt;position&lt;/var&gt; 。意味のある配置とは、1より大きい2の累乗です。GCCはこの情報を使用して、ポインターの位置合わせ分析を改善します。</target>
        </trans-unit>
        <trans-unit id="8797cd128649602028c5dfdc7369a0575f411979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer points to memory whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; の属性は、リターンポインタ関数に適用され、整数または列挙タイプの少なくとも一つの引数を取ることができます。これは、返されたポインタが、 &lt;var&gt;position-1&lt;/var&gt; の関数引数、または &lt;var&gt;position-1&lt;/var&gt; と &lt;var&gt;position-2&lt;/var&gt; の引数の積によってサイズが指定されているメモリを指していることを示しています。意味のあるサイズは、 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; より小さい正の値です。 GCCはこの情報を使用して、 &lt;code&gt;__builtin_object_size&lt;/code&gt; の結果を改善します。</target>
        </trans-unit>
        <trans-unit id="f06aab07630994254a1a8fb1c75da104d280fc4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; type attribute may be applied to the definition of a type of a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; の type属性は、ポインタを返し、整数型の少なくとも一つの引数を取る関数の型の定義に適用されてもよいです。これは、返されたポインターが、 &lt;var&gt;position-1&lt;/var&gt; の関数引数、または &lt;var&gt;position-1&lt;/var&gt; と &lt;var&gt;position-2&lt;/var&gt; の引数の積によって指定されるサイズのオブジェクトを指していることを示します。意味のあるサイズは、 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; より小さい正の値です。他のサイズは、検出されると無視されます。 GCCはこの情報を使用して、 &lt;code&gt;__builtin_object_size&lt;/code&gt; の結果を改善します。</target>
        </trans-unit>
        <trans-unit id="065a219ddaff6d679a0be49eb2bd7f719e312c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; variable attribute may be applied to the declaration of a pointer to a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; 変数属性は、ポインタを返し、整数型の少なくとも一つの引数を取る関数へのポインタの宣言に適用されてもよいです。これは、返されたポインターが、 &lt;var&gt;position-1&lt;/var&gt; の関数引数、または &lt;var&gt;position-1&lt;/var&gt; と &lt;var&gt;position-2&lt;/var&gt; の引数の積によって指定されるサイズのオブジェクトを指していることを示します。意味のあるサイズは、 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; より小さい正の値です。他のサイズは、検出されると無視されます。 GCCはこの情報を使用して、 &lt;code&gt;__builtin_object_size&lt;/code&gt; の結果を改善します。</target>
        </trans-unit>
        <trans-unit id="cbdc1421fb579e3bcb9c9ed2bb5181ffe0b47ee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline &lt;code&gt;asm&lt;/code&gt; statements. A &lt;em&gt;basic &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement is one with no operands (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;), while an &lt;em&gt;extended &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; キーワードは、Cコード内埋め込みアセンブラ命令にあなたを可能にします。GCCは、2つの形式のインライン &lt;code&gt;asm&lt;/code&gt; ステートメントを提供します。&lt;em&gt;基本 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt;文は、（参照なしのオペランドを有するものである&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;基本ASMを&lt;/a&gt;しながら、）&lt;em&gt;拡張 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt;文の（参照&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;拡張ASMを&lt;/a&gt;）一個の以上のオペランドを含んでいます。拡張形式は、関数内でC言語とアセンブリ言語を混在させるのに適していますが、アセンブリ言語を最上位に含めるには、基本的な &lt;code&gt;asm&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c83f20d0e6ffe18a83c8f1ea64e1025e8b4e3b79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword is a GNU extension. When writing code that can be compiled with</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; キーワードはGNUの拡張です。でコンパイルできるコードを書くとき</target>
        </trans-unit>
        <trans-unit id="5154cd3afb55ec67fd254011d045e0b4c9d93a08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 文は、Cのコード内で直接アセンブリ命令を含めることができます。これは、時間に敏感なコードのパフォーマンスを最大化したり、Cプログラムですぐに利用できないアセンブリ命令にアクセスしたりするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="889a71d5c542b05221a1fea4fb081bfa156749e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assume_aligned&lt;/code&gt; attribute may be applied to a function that returns a pointer. It indicates that the returned pointer is aligned on a boundary given by &lt;var&gt;alignment&lt;/var&gt;. If the attribute has two arguments, the second argument is misalignment &lt;var&gt;offset&lt;/var&gt;. Meaningful values of &lt;var&gt;alignment&lt;/var&gt; are powers of 2 greater than one. Meaningful values of &lt;var&gt;offset&lt;/var&gt; are greater than zero and less than &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;assume_aligned&lt;/code&gt; 属性は、ポインタを返す関数に適用してもよいです。これは、返されたポインタが、 &lt;var&gt;alignment&lt;/var&gt; で指定された境界に揃えられていることを示しています。属性に2つの引数がある場合、2番目の引数はミスアライメント &lt;var&gt;offset&lt;/var&gt; です。 &lt;var&gt;alignment&lt;/var&gt; 意味のある値は、1より大きい2の累乗です。 &lt;var&gt;offset&lt;/var&gt; 意味のある値は、ゼロより大きく、 &lt;var&gt;alignment&lt;/var&gt; より小さいです。</target>
        </trans-unit>
        <trans-unit id="e7eb78f1e02d22076254e95ec303c8093068484f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aux&lt;/code&gt; attribute is used to directly access the ARC&amp;rsquo;s auxiliary register space from C. The auxilirary register number is given via attribute argument.</source>
          <target state="translated">&lt;code&gt;aux&lt;/code&gt; 属性が直接auxiliraryレジスタ番号が属性引数を経由して与えられているC.からARCの補助レジスタ空間にアクセスするために使用されます。</target>
        </trans-unit>
        <trans-unit id="b63bd6b23aa2da11430c3217df7f40955b5b703f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;b&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="0166d882668eb629f4c81b26d5f43ba89f13484a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="07fada73a7cf214a1328d2a6e8cd842b7cf5c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cf_check&lt;/code&gt; attribute on a function is used to inform the compiler that ENDBR instruction should be placed at the function entry when</source>
          <target state="translated">関数の &lt;code&gt;cf_check&lt;/code&gt; 属性は、次の場合にENDBR命令を関数エントリに配置する必要があることをコンパイラに通知するために使用されます</target>
        </trans-unit>
        <trans-unit id="ca2675a5f39c8ca20fe391d93c61cca5056e32cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</source>
          <target state="translated">&lt;code&gt;cleanup&lt;/code&gt; 属性は、変数がスコープ外になる機能を実行します。この属性は、自動関数スコープ変数にのみ適用できます。静的な保存期間を持つパラメータまたは変数には適用できません。関数は1つのパラメーター、つまり変数と互換性のある型へのポインターを受け取る必要があります。関数の戻り値（存在する場合）は無視されます。</target>
        </trans-unit>
        <trans-unit id="85d44203c9f2ae9c43811502121d3c877febd137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program. The paths leading to calls of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as &lt;code&gt;perror&lt;/code&gt;, as cold to improve optimization of hot functions that do call marked functions in rare occasions.</source>
          <target state="translated">関数の &lt;code&gt;cold&lt;/code&gt; 属性は、関数が実行される可能性が低いことをコンパイラーに通知するために使用されます。関数は速度ではなくサイズが最適化されており、多くのターゲットではテキストセクションの特別なサブセクションに配置されるため、すべてのコールド関数が接近して表示され、プログラムの非コールド部分のコードの局所性が向上します。コード内でコールド関数の呼び出しにつながるパスは、分岐予測メカニズムではありそうもないものとしてマークされます。したがって、まれにマークされた関数を呼び出すホット関数の最適化を改善するために、 &lt;code&gt;perror&lt;/code&gt; などのあり得ない条件を処理するために使用される関数をコールドとしてマークすることは有用です。</target>
        </trans-unit>
        <trans-unit id="baaebf592a1c26312204d234ba4d0961fa9cfdc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">ラベルの &lt;code&gt;cold&lt;/code&gt; 属性は、ラベルに続くパスが実行される可能性が低いことをコンパイラーに通知するために使用されます。この属性は、 &lt;code&gt;__builtin_expect&lt;/code&gt; が使用できない場合、たとえば計算されたgotoまたは &lt;code&gt;asm goto&lt;/code&gt; で使用されます。</target>
        </trans-unit>
        <trans-unit id="84aae041fbfd493303c7dc6f97608b2aa0f0cfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;common&lt;/code&gt; attribute requests GCC to place a variable in &amp;ldquo;common&amp;rdquo; storage. The &lt;code&gt;nocommon&lt;/code&gt; attribute requests the opposite&amp;mdash;to allocate space for it directly.</source>
          <target state="translated">&lt;code&gt;common&lt;/code&gt; 属性は、「一般的な」ストレージ内の変数を配置するためにGCCを要求します。 &lt;code&gt;nocommon&lt;/code&gt; の属性は、逆に直接のための領域を割り当てを要求します。</target>
        </trans-unit>
        <trans-unit id="09440712407e39d94a0cdcf960e85948cfc3c350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute imposes greater restrictions on a function&amp;rsquo;s definition than the similar &lt;code&gt;pure&lt;/code&gt; attribute. Declaring the same function with both the &lt;code&gt;const&lt;/code&gt; and the &lt;code&gt;pure&lt;/code&gt; attribute is diagnosed. Because a const function cannot have any observable side effects it does not make sense for it to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 属性が類似したよりも、関数の定義に大きな制限が課され &lt;code&gt;pure&lt;/code&gt; 属性を。 &lt;code&gt;const&lt;/code&gt; 属性と &lt;code&gt;pure&lt;/code&gt; 属性の両方で同じ関数を宣言すると、診断されます。const関数には目に見える副作用がないため、 &lt;code&gt;void&lt;/code&gt; を返すことは意味がありません。そのような関数の宣言が診断されます。</target>
        </trans-unit>
        <trans-unit id="db8d892c81dcdfdd626d5be4bd09dab512df4f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute prohibits a function from reading objects that affect its return value between successive invocations. However, functions declared with the attribute can safely read objects that do not change their return value, such as non-volatile constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 属性は、連続呼び出しの間にその戻り値に影響を与えるオブジェクトを読んでから機能を禁止しています。ただし、この属性で宣言された関数は、不揮発性定数など、戻り値を変更しないオブジェクトを安全に読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="99106b80230d2cf73a73b452a0a31c02c4de491f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; attribute causes the function to be called automatically before execution enters &lt;code&gt;main ()&lt;/code&gt;. Similarly, the &lt;code&gt;destructor&lt;/code&gt; attribute causes the function to be called automatically after &lt;code&gt;main ()&lt;/code&gt; completes or &lt;code&gt;exit ()&lt;/code&gt; is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; 実行が入る前に、属性が自動的に呼び出される関数の原因となる &lt;code&gt;main ()&lt;/code&gt; 。同様に、 &lt;code&gt;destructor&lt;/code&gt; 属性により、 &lt;code&gt;main ()&lt;/code&gt; 完了するか、 &lt;code&gt;exit ()&lt;/code&gt; が呼び出された後に、関数が自動的に呼び出されます。これらの属性を持つ関数は、プログラムの実行中に暗黙的に使用されるデータを初期化するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="7f891d087177f42fcc2b6b6abd03f036315d60bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; and &lt;code&gt;target_clones&lt;/code&gt; attribute are also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 属性は、一連の属性適用される &lt;var&gt;function&lt;/var&gt; 属性が適用される関数の宣言に宣言されました。この属性は、ターゲットと同じ属性のセットを指定することが期待されるエイリアスまたは関数リゾルバーを定義するライブラリ用に設計されています。 &lt;code&gt;copy&lt;/code&gt; 属性は、関数、変数、またはタイプで使用することができます。ただし、属性が適用されるシンボルの種類（関数または変数）は、引数が参照するシンボルの種類と一致する必要があります。 &lt;code&gt;copy&lt;/code&gt; のようなシンボルのリンケージや可視性に影響を与える属性のみをコピー構文と意味属性ではなく、属性 &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;visibility&lt;/code&gt; 、または &lt;code&gt;weak&lt;/code&gt; 。 &lt;code&gt;deprecated&lt;/code&gt; と &lt;code&gt;target_clones&lt;/code&gt; 属性もコピーされません。&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common TypeAttributesを&lt;/a&gt;参照してください。&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1214564b5cbc84df3e7da6094de27b7006df5a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 属性は、一連の属性適用される &lt;var&gt;function&lt;/var&gt; 属性が適用される関数の宣言に宣言されました。属性は、ターゲットと同じ属性のセットを指定することが期待されるエイリアスまたは関数リゾルバーを定義するライブラリー用に設計されています。 &lt;code&gt;copy&lt;/code&gt; 属性は、関数、変数、またはタイプで使用することができます。ただし、属性が適用されるシンボルの種類（関数または変数）は、引数が参照するシンボルの種類と一致する必要があります。 &lt;code&gt;copy&lt;/code&gt; のようなシンボルのリンケージや可視性に影響を与える属性のみをコピー構文と意味属性ではなく、属性 &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;visibility&lt;/code&gt; 、または &lt;code&gt;weak&lt;/code&gt; 。 &lt;code&gt;deprecated&lt;/code&gt; 属性もコピーされません。&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributesを&lt;/a&gt;参照してください。&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="592273a5e05d6744ed0bd5dc37c91bbe97b23cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;variable&lt;/var&gt; has been declared to the declaration of the variable to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with variables, functions or types. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 属性は、一連の属性適用される &lt;var&gt;variable&lt;/var&gt; 、属性が適用される変数の宣言に宣言されました。この属性は、エイリアスシンボルと同じ属性セットを指定することが予想されるエイリアスを定義するライブラリ用に設計されています。 &lt;code&gt;copy&lt;/code&gt; 属性は、変数、関数や型を使用することができます。ただし、属性が適用されるシンボルの種類（変数または関数）は、引数が参照するシンボルの種類と一致する必要があります。 &lt;code&gt;copy&lt;/code&gt; のようなシンボルのリンケージや可視性に影響を与える属性のみをコピー構文と意味属性ではなく、属性 &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;visibility&lt;/code&gt; 、または &lt;code&gt;weak&lt;/code&gt; 。 &lt;code&gt;deprecated&lt;/code&gt; 属性もコピーされません。&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributesを&lt;/a&gt;参照してください。&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a505e2a0a73ab045449836d4a18bec5c0bc8127e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which the type of the &lt;var&gt;expression&lt;/var&gt; has been declared to the declaration of the type to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with types, variables, or functions. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 属性がの種類れる属性のセット適用 &lt;var&gt;expression&lt;/var&gt; 、属性が適用された型の宣言に宣言されました。この属性は、エイリアスシンボルと同じ属性セットを指定することが予想されるエイリアスを定義するライブラリ用に設計されています。 &lt;code&gt;copy&lt;/code&gt; 属性は、型、変数、または関数で使用することができます。ただし、属性が適用されるシンボルの種類（変数または関数）は、引数が参照するシンボルの種類と一致する必要があります。 &lt;code&gt;copy&lt;/code&gt; のようなシンボルのリンケージや可視性に影響を与える属性のみをコピー構文と意味属性ではなく、属性 &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;visibility&lt;/code&gt; 、または &lt;code&gt;weak&lt;/code&gt; 。 &lt;code&gt;deprecated&lt;/code&gt; 属性もコピーされません。&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributesを&lt;/a&gt;参照してください。&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f8a4a7841fe7fe34c4f48a65b187a7fb8df9b582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="024895282c898bc3d4211d4724e2af4880224cde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and types (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性も（参照関数と型のために使用することができる&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通機能の属性を&lt;/a&gt;参照して、&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;一般的なタイプの属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="162fc2b6ed9e6c2908900a7eb89f4726020462d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and variables (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性も関数や変数のために使用することができます（参照&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照して、&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数の属性を&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b2cfdb164eda8f42cf6433c514a0ea224366c785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for variables and types (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、変数と型に使用することができます（参照&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数の属性を&lt;/a&gt;、参照&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;型の属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="cad1e87fce264d36291150600cb66c57e91c1432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the enumerator is used anywhere in the source file. This is useful when identifying enumerators that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated enumerator, to enable users to easily find further information about why the enumerator is deprecated, or what they should do instead. Note that the warnings only occurs for uses.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 警告の属性の結果は、列挙子は、ソースファイルの任意の場所で使用されている場合。これは、プログラムの将来のバージョンで削除される予定の列挙子を識別するときに役立ちます。警告には、非推奨の列挙子の宣言の場所も含まれています。これにより、ユーザーは、列挙子が非推奨となった理由、または代わりに何をすべきかに関する詳細情報を簡単に見つけることができます。警告は使用目的でのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="20e0cb154d9e21da1f2de2ead88f358575c22b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 警告の属性の結果は、関数は、ソースファイルの任意の場所で使用されている場合。これは、プログラムの将来のバージョンで削除される予定の関数を識別するときに役立ちます。警告には、非推奨の関数の宣言の場所も含まれています。これにより、ユーザーは、関数が非推奨である理由、または代わりに何をすべきかに関する詳細情報を簡単に見つけることができます。警告は次の用途でのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="7280557c8bb44f2fb4dbaff815426552ad4804e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 警告の属性の結果は、タイプは、ソースファイルの任意の場所で使用されている場合。これは、プログラムの将来のバージョンで削除される予定のタイプを識別するときに役立ちます。可能であれば、警告には非推奨の型の宣言の場所も含まれ、ユーザーがその型が非推奨である理由、または代わりに何をすべきかに関する詳細情報を簡単に見つけることができます。警告は使用目的でのみ発生し、そのタイプが非推奨として宣言されていない識別子に適用されている場合にのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="597712de9335903c130e7df57d7a0ba95b08639b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the variable is used anywhere in the source file. This is useful when identifying variables that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated variable, to enable users to easily find further information about why the variable is deprecated, or what they should do instead. Note that the warning only occurs for uses:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 警告の属性の結果は、変数は、ソースファイルの任意の場所で使用されている場合。これは、プログラムの将来のバージョンで削除される予定の変数を識別するときに役立ちます。警告には、廃止された変数の宣言の場所も含まれています。これにより、ユーザーは変数が廃止された理由、または代わりに何をすべきかに関する詳細情報を簡単に見つけることができます。警告は次の用途でのみ発生します。</target>
        </trans-unit>
        <trans-unit id="344b31eee254fd7731082259002ff33f9b48b98f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;di&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;di&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="1650914162ce3f6c59a952f96564a05c9635bff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dllimport&lt;/code&gt; and &lt;code&gt;dllexport&lt;/code&gt; attributes are described in &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dllimport&lt;/code&gt; と &lt;code&gt;dllexport&lt;/code&gt; 属性に記述されている&lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windowsの機能の属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="602269999e7f262d03410dcdc10e151a9ba7ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;either&lt;/code&gt; attribute is special. It tells the linker to place the object into the corresponding &lt;code&gt;lower&lt;/code&gt; section if there is room for it. If there is insufficient room then the object is placed into the corresponding &lt;code&gt;upper&lt;/code&gt; section instead. Note that the placement algorithm is not very sophisticated. It does not attempt to find an optimal packing of the &lt;code&gt;lower&lt;/code&gt; sections. It just makes one pass over the objects and does the best that it can. Using the</source>
          <target state="translated">&lt;code&gt;either&lt;/code&gt; 属性は特別です。オブジェクトにスペースがある場合は、対応する &lt;code&gt;lower&lt;/code&gt; セクションにオブジェクトを配置するようリンカーに指示します。十分なスペースがない場合、オブジェクトは対応する &lt;code&gt;upper&lt;/code&gt; セクションに配置されます。配置アルゴリズムはあまり洗練されていないことに注意してください。 &lt;code&gt;lower&lt;/code&gt; セクションの最適なパッキングを見つけることは試みません。オブジェクトを1回通過するだけで、できる限りのことを行います。を使用して</target>
        </trans-unit>
        <trans-unit id="127ffb86a9524294853f3ef1fc5800cb8a1c3768" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallthrough&lt;/code&gt; attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the</source>
          <target state="translated">&lt;code&gt;fallthrough&lt;/code&gt; NULL文と属性がフォールスルーのステートメントとして機能します。別のケースラベルまたはswitchステートメントのユーザー定義ラベルに該当するステートメントは意図的なものであり、したがって</target>
        </trans-unit>
        <trans-unit id="6830b1617bcd576d4ef6cff9b6f00ee4b5966d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixincludes&lt;/code&gt; script interacts badly with automounters; if the directory of system header files is automounted, it tends to be unmounted while &lt;code&gt;fixincludes&lt;/code&gt; is running. This would seem to be a bug in the automounter. We don&amp;rsquo;t know any good way to work around it.</source>
          <target state="translated">&lt;code&gt;fixincludes&lt;/code&gt; のスクリプトは、オートマウンタでひどく相互作用します; システムヘッダーファイルのディレクトリが自動マウントされている場合、 &lt;code&gt;fixincludes&lt;/code&gt; の実行中にアンマウントされる傾向があります。これはオートマウンタのバグのようです。私たちはそれを回避する良い方法を知りません。</target>
        </trans-unit>
        <trans-unit id="c63425a2cbc7b99cbe7ca99c3dbf9d57e95519bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute allows you to identify your own functions that take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 属性を使用すると、GCCは、エラーのためにこれらの関数の呼び出しを確認することができますのでことを、引数としてフォーマット文字列を取り、独自の機能を識別することができます。コンパイラは常に（ただし、</target>
        </trans-unit>
        <trans-unit id="8186a0d48987dddde9af17dcccbd13ea17379b53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments that should be type-checked against a format string. For example, the declaration:</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 属性は、関数が &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 、 &lt;code&gt;strftime&lt;/code&gt; または &lt;code&gt;strfmon&lt;/code&gt; スタイルの引数を取ることを指定します。これらの引数は、フォーマット文字列に対して型チェックする必要があります。たとえば、宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="85cee214b83f923e35c9402c26181e376eaa3ea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute allows you to identify your own functions that modify format strings, so that GCC can check the calls to &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; type function whose operands are a call to one of your own function. The compiler always treats &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, and &lt;code&gt;dcgettext&lt;/code&gt; in this manner except when strict ISO C support is requested by</source>
          <target state="translated">&lt;code&gt;format_arg&lt;/code&gt; 属性は、GCCはへの呼び出しをチェックできるように、変更のフォーマット文字列という独自の機能を識別することを可能にする &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 関数、 &lt;code&gt;strftime&lt;/code&gt; のか &lt;code&gt;strfmon&lt;/code&gt; そのオペランド独自の機能の一つに呼び出しているタイプの機能。コンパイラーは、厳密なISO Cサポートが要求された場合を除いて、常にこの方法で &lt;code&gt;gettext&lt;/code&gt; 、 &lt;code&gt;dgettext&lt;/code&gt; 、および &lt;code&gt;dcgettext&lt;/code&gt; を処理します。</target>
        </trans-unit>
        <trans-unit id="3daa7d7140f7871d6b8af467ff44e71c895472e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute specifies that a function takes one or more format strings for a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function and modifies it (for example, to translate it into another language), so the result can be passed to a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). Multiple &lt;code&gt;format_arg&lt;/code&gt; attributes may be applied to the same function, each designating a distinct parameter as a format string. For example, the declaration:</source>
          <target state="translated">&lt;code&gt;format_arg&lt;/code&gt; 機能は、1つ以上のフォーマット文字列かかる属性が指定する &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 関数、 &lt;code&gt;strftime&lt;/code&gt; のか &lt;code&gt;strfmon&lt;/code&gt; 結果がに渡すことができますので、スタイル機能や修正、それを（例えば、別の言語に翻訳する） &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 関数、 &lt;code&gt;strftime&lt;/code&gt; または &lt;code&gt;strfmon&lt;/code&gt; スタイル関数（フォーマット関数への残りの引数は、変更されていない文字列の場合と同じです）。複数の &lt;code&gt;format_arg&lt;/code&gt; 属性を同じ関数に適用でき、それぞれが個別のパラメーターをフォーマット文字列として指定します。たとえば、宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cca4e3fc744cfd6bb4409a911b1eaa70a4a7b0f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gcc&lt;/code&gt; program accepts options and file names as operands. Many options have multi-letter names; therefore multiple single-letter options may &lt;em&gt;not&lt;/em&gt; be grouped:</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; プログラムは、オペランドなどのオプションとファイル名を受け入れます。多くのオプションには複数文字の名前があります。したがって、複数の1文字のオプションはグループ化でき&lt;em&gt;ませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="13501a1cf6115328de048bf9d04f10c4c82f956e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getenv&lt;/code&gt; spec function takes two arguments: an environment variable name and a string. If the environment variable is not defined, a fatal error is issued. Otherwise, the return value is the value of the environment variable concatenated with the string. For example, if &lt;code&gt;TOPDIR&lt;/code&gt; is defined as</source>
          <target state="translated">&lt;code&gt;getenv&lt;/code&gt; は、環境変数名と文字列：仕様機能は2つの引数を取ります。環境変数が定義されていない場合、致命的なエラーが発行されます。それ以外の場合、戻り値は、文字列と連結された環境変数の値です。たとえば、 &lt;code&gt;TOPDIR&lt;/code&gt; が次のように定義されている場合</target>
        </trans-unit>
        <trans-unit id="7e47220a0b9fe1eafb603003bb97378e81c55693" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many targets it is placed into a special subsection of the text section so all hot functions appear close together, improving locality.</source>
          <target state="translated">関数の &lt;code&gt;hot&lt;/code&gt; 属性は、関数がコンパイル済みプログラムのホットスポットであることをコンパイラに通知するために使用されます。関数はより積極的に最適化され、多くのターゲットでテキストセクションの特別なサブセクションに配置されるため、すべてのホット関数が近接して表示され、局所性が向上します。</target>
        </trans-unit>
        <trans-unit id="bdc71e7bb730a8ac55c634493d73dbda68f4ce5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a label is used to inform the compiler that the path following the label is more likely than paths that are not so annotated. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">ラベルの &lt;code&gt;hot&lt;/code&gt; 属性を使用して、ラベルに続くパスがそれほど注釈が付けられていないパスよりも可能性が高いことをコンパイラーに通知します。この属性は、 &lt;code&gt;__builtin_expect&lt;/code&gt; が使用できない場合、たとえば計算されたgotoまたは &lt;code&gt;asm goto&lt;/code&gt; で使用されます。</target>
        </trans-unit>
        <trans-unit id="f61dd8421805c3f1f1761646164b13228bc83b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists-else&lt;/code&gt; spec function is similar to the &lt;code&gt;if-exists&lt;/code&gt; spec function, except that it takes two arguments. The first argument is an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists-else&lt;/code&gt; returns the pathname. If it does not exist, it returns the second argument. This way, &lt;code&gt;if-exists-else&lt;/code&gt; can be used to select one file or another, based on the existence of the first. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;if-exists-else&lt;/code&gt; スペック関数はに似て &lt;code&gt;if-exists&lt;/code&gt; 、それは二つの引数を取ることを除いて、スペックの機能を。最初の引数はファイルへの絶対パス名です。ファイルが存在する場合、 &lt;code&gt;if-exists-else&lt;/code&gt; はパス名を返します。存在しない場合は、2番目の引数を返します。このように、 &lt;code&gt;if-exists-else&lt;/code&gt; を使用して、最初のファイルの存在に基づいて、ファイルを選択できます。以下は、その使用例です。</target>
        </trans-unit>
        <trans-unit id="ca2fcf31ed2dc4dabd85a0634ae9ce4991a720f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists&lt;/code&gt; spec function takes one argument, an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists&lt;/code&gt; returns the pathname. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;if-exists&lt;/code&gt; 仕様の機能を一つの引数、ファイルへの絶対パス名を取ります。ファイルが存在する場合、 &lt;code&gt;if-exists&lt;/code&gt; はパス名を返します。以下は、その使用例です。</target>
        </trans-unit>
        <trans-unit id="2f39b443650f9aa0609294fd86fb2e3c92efa3ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifunc&lt;/code&gt; attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine to be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions&amp;rsquo; declarations must match the API of the function being implemented. The resolver should be declared to be a function taking no arguments and returning a pointer to a function of the same type as the implementation. For example:</source>
          <target state="translated">&lt;code&gt;ifunc&lt;/code&gt; の属性は、ELF標準にSTT_GNU_IFUNCシンボル型エクステンションを用いた間接関数としての機能をマークするために使用されます。これにより、ロード時にシンボル値の解決を動的に決定し、特定された特定のプロセッサまたは他のシステム特性に対して決定されたルーチンの最適化バージョンを選択できます。この属性を使用するには、まず、使用可能な実装関数と、選択した実装関数へのポインターを返すリゾルバー関数を定義します。実装関数の宣言は、実装される関数のAPIと一致する必要があります。リゾルバーは、引数を取らず、実装と同じ型の関数へのポインターを返す関数として宣言する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="c93b19f3af6a498a18dbae7f15fda07496789c8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indirect_return&lt;/code&gt; attribute can be applied to a function, as well as variable or type of function pointer to inform the compiler that the function may return via indirect branch.</source>
          <target state="translated">&lt;code&gt;indirect_return&lt;/code&gt; の属性は、関数が間接分岐を経由して返すことがコンパイラに通知する機能だけでなく、変数や関数ポインタの型に適用することができます。</target>
        </trans-unit>
        <trans-unit id="f9d323a0cf85010c427cc0692ec1f74e288bfb70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; type specifies the &lt;em&gt;base type&lt;/em&gt;, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the &lt;code&gt;v4si&lt;/code&gt; type to be 16 bytes wide and divided into &lt;code&gt;int&lt;/code&gt; sized units. For a 32-bit &lt;code&gt;int&lt;/code&gt; this means a vector of 4 units of 4 bytes, and the corresponding mode of &lt;code&gt;foo&lt;/code&gt; is V4SI.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; タイプを指定し&lt;em&gt;、ベースタイプを&lt;/em&gt;属性は、バイト単位で測定された変数のベクトルの大きさを指定しながら、。たとえば、上記の宣言により、コンパイラーは &lt;code&gt;v4si&lt;/code&gt; タイプのモードを16バイト幅に設定し、 &lt;code&gt;int&lt;/code&gt; サイズのユニットに分割します。32ビット &lt;code&gt;int&lt;/code&gt; 場合、これは4バイトの4ユニットのベクトルを意味し、対応する &lt;code&gt;foo&lt;/code&gt; のモードはV4SIです。</target>
        </trans-unit>
        <trans-unit id="2ad85eea7d52841e376253f17a96317ee40b42d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; register. Use this register to store values that are no bigger than a word.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; レジスタ。このレジスタを使用して、ワード以下の値を格納します。</target>
        </trans-unit>
        <trans-unit id="d59f696ee7163d6ae5bf39bf73c4a8eee9fb142c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; の属性は、関数が遠く呼び出しサイトから可能と異なる（より高価な）呼び出しシーケンスを必要とするかもしれないことを示しています。 &lt;code&gt;shortcall&lt;/code&gt; の属性は、関数が常に使用される短い呼び出しシーケンスのために十分に近いことを示しています。これらの属性は、</target>
        </trans-unit>
        <trans-unit id="fcca42c392befdcaa88d2e6501ea9388ada93b12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; の属性は、関数が遠く呼び出しサイトから可能と異なる（より高価な）呼び出しシーケンスを必要とするかもしれないことを示しています。 &lt;code&gt;shortcall&lt;/code&gt; の属性は、関数が常に使用される短い呼び出しシーケンスのために十分に近いことを示しています。これらの属性は、</target>
        </trans-unit>
        <trans-unit id="dc876d3a5eef5293c3403c1a8361253a45afc935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movf&lt;/code&gt; functions are similar but use &lt;code&gt;movf.ps&lt;/code&gt; instead of &lt;code&gt;movt.ps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;movf&lt;/code&gt; 機能は似ていますが、使用している &lt;code&gt;movf.ps&lt;/code&gt; の代わり &lt;code&gt;movt.ps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7edfc9a06b3d4812f5bd4584647b1d884b0e5206" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movt&lt;/code&gt; functions return the value &lt;var&gt;x&lt;/var&gt; computed by:</source>
          <target state="translated">&lt;code&gt;movt&lt;/code&gt; 関数は値を返す &lt;var&gt;x&lt;/var&gt; はによって計算します：</target>
        </trans-unit>
        <trans-unit id="2610b35bdca1d94154ca3ae8683caf9dc99891a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutationsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is used to keep track of mutations. It should point to a number; before working on each object, the fast enumeration loop will check that this number has not changed. If it has, a mutation has happened and the fast enumeration will abort. So, &lt;code&gt;mutationsPtr&lt;/code&gt; could be set to point to some sort of version number of your collection, which is increased by one every time there is a change (for example when an object is added or removed). Or, if you are content with less strict mutation checks, it could point to the number of objects in your collection or some other value that can be checked to perform an approximate check that the collection has not been mutated.</source>
          <target state="translated">&lt;code&gt;mutationsPtr&lt;/code&gt; の分野 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; は変異を追跡するために使用されます。数字を指す必要があります。各オブジェクトで作業する前に、高速列挙ループはこの数が変更されていないことを確認します。変更されている場合、突然変異が発生しており、高速列挙が中止されます。したがって、 &lt;code&gt;mutationsPtr&lt;/code&gt; は、コレクションのある種のバージョン番号を指すように設定できます。これは、変更があるたびに（たとえば、オブジェクトが追加または削除されたときに）1ずつ増加します。または、変更チェックの厳密性が低い場合は、コレクション内のオブジェクトの数、またはコレクションが変更されていないというおおよそのチェックを実行するためにチェックできるその他の値を指している可能性があります。</target>
        </trans-unit>
        <trans-unit id="eba0a2fef84c6754af39561a4cc5765385e357d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_profile_instrument_function&lt;/code&gt; attribute on functions is used to inform the compiler that it should not process any profile feedback based optimization code instrumentation.</source>
          <target state="translated">関数の &lt;code&gt;no_profile_instrument_function&lt;/code&gt; 属性は、プロファイルフィードバックに基づく最適化コードのインストルメンテーションを処理してはならないことをコンパイラーに通知するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0918428dc764c04c359b85f748a679bc412726a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of all options mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by</source>
          <target state="translated">関数の &lt;code&gt;no_sanitize&lt;/code&gt; 属性は、 &lt;var&gt;sanitize_option&lt;/var&gt; で言及されているすべてのオプションのサニタイズを行うべきではないことをコンパイラーに通知するために使用されます。受け入れ可能な値のリスト</target>
        </trans-unit>
        <trans-unit id="9e7127aec5521f1afa980b41ce3dbea36752798e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of any option mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by the</source>
          <target state="translated">関数の &lt;code&gt;no_sanitize&lt;/code&gt; 属性は、 &lt;var&gt;sanitize_option&lt;/var&gt; に記載されているオプションのサニタイズを実行しないようにコンパイラーに通知するために使用されます。によって受け入れられる値のリスト</target>
        </trans-unit>
        <trans-unit id="598d3a3720c7288dc59d302cd06d4d62ac827b23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_address&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">関数の &lt;code&gt;no_sanitize_address&lt;/code&gt; 属性は、コンパイラーに、関数でのメモリアクセスを計測して、</target>
        </trans-unit>
        <trans-unit id="b0f00909d80fd99a1bd86005010002c8eae19649" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_thread&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">関数の &lt;code&gt;no_sanitize_thread&lt;/code&gt; 属性を使用して、コンパイラに、関数でのメモリアクセスを、</target>
        </trans-unit>
        <trans-unit id="7a12b0e3b686d055271b195be15ed20337782164" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_undefined&lt;/code&gt; attribute on functions is used to inform the compiler that it should not check for undefined behavior in the function when compiling with the</source>
          <target state="translated">関数の &lt;code&gt;no_sanitize_undefined&lt;/code&gt; 属性は、コンパイラーに、</target>
        </trans-unit>
        <trans-unit id="fc8d4f077478dc90f16e53c6d13ee06401059297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute is applied to an object&amp;rsquo;s type. In case of assignment of a function address or a function pointer to another pointer, the attribute is not carried over from the right-hand object&amp;rsquo;s type; the type of left-hand object stays unchanged. The compiler checks for &lt;code&gt;nocf_check&lt;/code&gt; attribute mismatch and reports a warning in case of mismatch.</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; の属性は、オブジェクトの種類に適用されます。関数アドレスまたは関数ポインタを別のポインタに割り当てる場合、属性は右側のオブジェクトの型から引き継がれません。左側のオブジェクトのタイプは変更されません。コンパイラーは &lt;code&gt;nocf_check&lt;/code&gt; 属性の不一致をチェックし、不一致の場合は警告を報告します。</target>
        </trans-unit>
        <trans-unit id="037064bc2bccfb10212ace859111994bc55ff79f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a function is used to inform the compiler that the function&amp;rsquo;s prologue should not be instrumented when compiled with the</source>
          <target state="translated">関数の &lt;code&gt;nocf_check&lt;/code&gt; 属性は、関数のプロローグを、</target>
        </trans-unit>
        <trans-unit id="59968503e9385085cb3eaa290a16cdafff616101" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a type of pointer to function is used to inform the compiler that a call through the pointer should not be instrumented when compiled with the</source>
          <target state="translated">関数へのポインターのタイプの &lt;code&gt;nocf_check&lt;/code&gt; 属性を使用して、ポインターを介した呼び出しは、</target>
        </trans-unit>
        <trans-unit id="814b4e15c6c880738e37bebfa650ba3630bcdb26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonnull&lt;/code&gt; attribute may be applied to a function that takes at least one argument of a pointer type. It indicates that the referenced arguments must be non-null pointers. For instance, the declaration:</source>
          <target state="translated">&lt;code&gt;nonnull&lt;/code&gt; 属性は、ポインタ型の少なくとも一つの引数を取る関数に適用してもよいです。参照される引数はnull以外のポインタでなければならないことを示しています。たとえば、宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="390c2fb36f2ab88e24c7fbba27c3b067ccacf7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonstring&lt;/code&gt; variable attribute specifies that an object or member declaration with type array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, or &lt;code&gt;unsigned char&lt;/code&gt;, or pointer to such a type is intended to store character arrays that do not necessarily contain a terminating &lt;code&gt;NUL&lt;/code&gt;. This is useful in detecting uses of such arrays or pointers with functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings, and to avoid warnings when such an array or pointer is used as an argument to a bounded string manipulation function such as &lt;code&gt;strncpy&lt;/code&gt;. For example, without the attribute, GCC will issue a warning for the &lt;code&gt;strncpy&lt;/code&gt; call below because it may truncate the copy without appending the terminating &lt;code&gt;NUL&lt;/code&gt; character. Using the attribute makes it possible to suppress the warning. However, when the array is declared with the attribute the call to &lt;code&gt;strlen&lt;/code&gt; is diagnosed because when the array doesn&amp;rsquo;t contain a &lt;code&gt;NUL&lt;/code&gt;-terminated string the call is undefined. To copy, compare, of search non-string character arrays use the &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, and other functions that operate on arrays of bytes. In addition, calling &lt;code&gt;strnlen&lt;/code&gt; and &lt;code&gt;strndup&lt;/code&gt; with such arrays is safe provided a suitable bound is specified, and not diagnosed.</source>
          <target state="translated">非 &lt;code&gt;nonstring&lt;/code&gt; 変数属性は、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;signed char&lt;/code&gt; 、または &lt;code&gt;unsigned char&lt;/code&gt; の型配列を持つオブジェクトまたはメンバー宣言、またはそのような型へのポインターが、終了 &lt;code&gt;NUL&lt;/code&gt; を必ずしも含まない文字配列を格納することを意図していることを指定します。これは、 &lt;code&gt;NUL&lt;/code&gt; で終了する文字列を期待する関数でそのような配列またはポインターの使用を検出し、そのような配列またはポインターが &lt;code&gt;strncpy&lt;/code&gt; などの制限された文字列操作関数の引数として使用される場合の警告を回避するのに役立ちます。たとえば、属性がない場合、GCCは &lt;code&gt;strncpy&lt;/code&gt; に対して警告を発行します末尾の &lt;code&gt;NUL&lt;/code&gt; 文字を追加せずにコピーを切り詰める可能性があるため、以下を呼び出します。この属性を使用すると、警告を抑制することができます。ただし、配列が属性で宣言されている場合、 &lt;code&gt;strlen&lt;/code&gt; の呼び出しは診断されます。これは、配列に &lt;code&gt;NUL&lt;/code&gt; で終了する文字列が含まれていない場合、呼び出しは未定義であるためです。文字列以外の文字配列をコピー、比較、検索するには、 &lt;code&gt;memcpy&lt;/code&gt; 、 &lt;code&gt;memcmp&lt;/code&gt; 、 &lt;code&gt;memchr&lt;/code&gt; 、およびバイトの配列を操作するその他の関数を使用します。さらに、適切な境界が指定されていて診断されていない場合、そのような配列で &lt;code&gt;strnlen&lt;/code&gt; および &lt;code&gt;strndup&lt;/code&gt; を呼び出すことは安全です。</target>
        </trans-unit>
        <trans-unit id="bfce49165a44d874594bfffebd1dbb2dbd0c7094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute is the counterpart to option</source>
          <target state="translated">&lt;code&gt;noplt&lt;/code&gt; の属性はオプションに対応するものです</target>
        </trans-unit>
        <trans-unit id="0300bf5cb9eee09bcd3c5b59946b4122f915396c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute on function &lt;code&gt;foo&lt;/code&gt; tells the compiler to assume that the function &lt;code&gt;foo&lt;/code&gt; is externally defined and that the call to &lt;code&gt;foo&lt;/code&gt; must avoid the PLT in position-independent code.</source>
          <target state="translated">関数 &lt;code&gt;foo&lt;/code&gt; の &lt;code&gt;noplt&lt;/code&gt; 属性は、関数 &lt;code&gt;foo&lt;/code&gt; が外部で定義され、 &lt;code&gt;foo&lt;/code&gt; への呼び出しは位置に依存しないコードのPLTを回避する必要があると想定するようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="3e2a9d3dba3dc91ebe5e03bbafab67f8838787f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword does not affect the exceptional path when that applies: a &lt;code&gt;noreturn&lt;/code&gt;-marked function may still return to the caller by throwing an exception or calling &lt;code&gt;longjmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; ：それが適用される際のキーワードは、優れたパスに影響を与えません &lt;code&gt;noreturn&lt;/code&gt; -marked機能はまだ例外をスローするか、呼び出すことにより、呼び出し側に返すことが &lt;code&gt;longjmp&lt;/code&gt; をします。</target>
        </trans-unit>
        <trans-unit id="0ede64b6031c14f35d5f8cb3935b7f6f8ada1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword tells the compiler to assume that &lt;code&gt;fatal&lt;/code&gt; cannot return. It can then optimize without regard to what would happen if &lt;code&gt;fatal&lt;/code&gt; ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; キーワードは、と仮定するようにコンパイラーに指示します &lt;code&gt;fatal&lt;/code&gt; 缶が戻りません。その後、 &lt;code&gt;fatal&lt;/code&gt; が戻った場合に何が起こるかを考慮せずに最適化できます。これは少し良いコードになります。さらに重要なことは、初期化されていない変数の誤った警告を回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="322a4c52099d05e4a78d3c92d5bcf0059fa4fd77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nothrow&lt;/code&gt; attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of &lt;code&gt;qsort&lt;/code&gt; and &lt;code&gt;bsearch&lt;/code&gt; that take function pointer arguments.</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; の属性は、関数が例外をスローすることができないことをコンパイラに通知するために使用されます。たとえば、標準Cライブラリのほとんどの関数は、関数ポインタ引数を取る &lt;code&gt;qsort&lt;/code&gt; と &lt;code&gt;bsearch&lt;/code&gt; の注目すべき例外で例外をスローしないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="207d7791a2ec8b451439c9235cbe7bcf5c27be6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimize&lt;/code&gt; attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Valid arguments are constant non-negative integers and strings. Each numeric argument specifies an optimization &lt;var&gt;level&lt;/var&gt;. Each &lt;var&gt;string&lt;/var&gt; argument consists of one or more comma-separated substrings. Each substring that begins with the letter &lt;code&gt;O&lt;/code&gt; refers to an optimization option such as</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 属性は、関数は、コマンドラインで指定とは異なる最適化オプションを指定してコンパイルされることを指定するために使用されます。有効な引数は、負でない定数の整数と文字列です。各数値引数は、最適化 &lt;var&gt;level&lt;/var&gt; 指定します。各 &lt;var&gt;string&lt;/var&gt; 引数は、1つ以上のコンマ区切りの部分文字列で構成されます。文字 &lt;code&gt;O&lt;/code&gt; で始まる各部分文字列は、次のような最適化オプションを指します。</target>
        </trans-unit>
        <trans-unit id="826d9e0c3c8b85ab7196ae31fb079d73a80bdae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; attribute specifies that a structure member should have the smallest possible alignment&amp;mdash;one bit for a bit-field and one byte otherwise, unless a larger value is specified with the &lt;code&gt;aligned&lt;/code&gt; attribute. The attribute does not apply to non-member objects.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 大きな値を用いて指定されない限り、構造部材は、さもなければビットフィールドと、1バイトの最小の可能なアライメント-1ビットを有するべきであることを属性指定 &lt;code&gt;aligned&lt;/code&gt; 属性。この属性は、非メンバーオブジェクトには適用されません。</target>
        </trans-unit>
        <trans-unit id="39beb9f00633eee839c4a2a5158a15d6e464e28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass-through-libs&lt;/code&gt; spec function takes any number of arguments. It finds any</source>
          <target state="translated">&lt;code&gt;pass-through-libs&lt;/code&gt; スペック機能は、任意の数の引数を取ります。それは見つけます</target>
        </trans-unit>
        <trans-unit id="89c9a7db255ec3b8e7cca6652c90ae20f65b9a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;patchable_function_entry&lt;/code&gt; function attribute can be used to change the number of NOPs to any desired value. The two-value syntax is the same as for the command-line switch</source>
          <target state="translated">&lt;code&gt;patchable_function_entry&lt;/code&gt; の関数属性は、任意の所望の値までのNOPの数を変更するために使用することができます。2つの値の構文は、コマンドラインスイッチと同じです。</target>
        </trans-unit>
        <trans-unit id="e838ae744489fc704636367520fe3b637d47e7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcs&lt;/code&gt; attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use.</source>
          <target state="translated">&lt;code&gt;pcs&lt;/code&gt; 属性は、ARMの機能に使用される呼び出し規約を制御するために使用することができます。この属性は、使用する呼び出し規約を指定する引数を取ります。</target>
        </trans-unit>
        <trans-unit id="bbf4d6b72a577c7b95004980e1bce0048594d8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print-asm-header&lt;/code&gt; function takes no arguments and simply prints a banner like:</source>
          <target state="translated">&lt;code&gt;print-asm-header&lt;/code&gt; 関数は、引数を取らず、単にようなバナーを印刷します。</target>
        </trans-unit>
        <trans-unit id="cb4fc17c6269a43f696bb9bef92ec98733094225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute imposes similar but looser restrictions on a function&amp;rsquo;s definition than the &lt;code&gt;const&lt;/code&gt; attribute: &lt;code&gt;pure&lt;/code&gt; allows the function to read any non-volatile memory, even if it changes in between successive invocations of the function. Declaring the same function with both the &lt;code&gt;pure&lt;/code&gt; and the &lt;code&gt;const&lt;/code&gt; attribute is diagnosed. Because a pure function cannot have any observable side effects it does not make sense for such a function to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 属性は以下の関数の定義に似ていますが、より緩やかな制限が課される &lt;code&gt;const&lt;/code&gt; 属性を： &lt;code&gt;pure&lt;/code&gt; それは、関数の連続呼び出しの間に変化しても、関数は任意の不揮発性メモリを読み取ることができます。 &lt;code&gt;pure&lt;/code&gt; 関数と &lt;code&gt;const&lt;/code&gt; 属性の両方で同じ関数を宣言すると、診断されます。純粋な関数には目に見える副作用がないため、そのような関数が &lt;code&gt;void&lt;/code&gt; を返すことは意味がありません。そのような関数の宣言が診断されます。</target>
        </trans-unit>
        <trans-unit id="323eb04f8039811b3bb58c82bccb097f2a6f7bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute prohibits a function from modifying the state of the program that is observable by means other than inspecting the function&amp;rsquo;s return value. However, functions declared with the &lt;code&gt;pure&lt;/code&gt; attribute can safely read any non-volatile objects, and modify the value of objects in a way that does not affect their return value or the observable state of the program.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 属性は、関数の戻り値を検査する以外の手段で観察されたプログラムの状態を変更することから、機能を禁止しています。ただし、 &lt;code&gt;pure&lt;/code&gt; 属性を使用して宣言された関数は、不揮発性オブジェクトを安全に読み取り、戻り値やプログラムの監視可能な状態に影響を与えない方法でオブジェクトの値を変更できます。</target>
        </trans-unit>
        <trans-unit id="24119821985c46d89b11400454926b0593b3b50d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_only&lt;/code&gt; access mode specifies that the pointer to which it applies is used to read the referenced object but not write to it. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the referenced object must be initialized. The mode implies a stronger guarantee than the &lt;code&gt;const&lt;/code&gt; qualifier which, when cast away from a pointer, does not prevent the pointed-to object from being modified. Examples of the use of the &lt;code&gt;read_only&lt;/code&gt; access mode is the argument to the &lt;code&gt;puts&lt;/code&gt; function, or the second and third arguments to the &lt;code&gt;memcpy&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;read_only&lt;/code&gt; それが適用されるポインタが参照されたオブジェクトを読み、それに書き込めないために使用されていることをアクセスモードを指定します。 &lt;var&gt;size-index&lt;/var&gt; で示されるアクセスのサイズを指定する引数がゼロでない限り、参照されるオブジェクトを初期化する必要があります。このモードは、ポインターからキャストされたときに、ポイントされたオブジェクトの変更を妨げない &lt;code&gt;const&lt;/code&gt; 修飾子よりも強力な保証を意味します。 &lt;code&gt;read_only&lt;/code&gt; アクセスモードの使用例は、 &lt;code&gt;puts&lt;/code&gt; 関数の引数、または &lt;code&gt;memcpy&lt;/code&gt; 関数の2番目と3番目の引数です。</target>
        </trans-unit>
        <trans-unit id="88a3f3d3b23da8341683a81df31a980b08cf319c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_write&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to both read and write the referenced object. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the object referenced by the pointer must be initialized. An example of the use of the &lt;code&gt;read_write&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcat&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; アクセスモードはなしポインタ型の引数に適用される &lt;code&gt;const&lt;/code&gt; 修飾子。それが適用されるポインタが、参照されるオブジェクトの読み取りと書き込みの両方に使用されることを指定します。 &lt;var&gt;size-index&lt;/var&gt; で示されるアクセスのサイズを指定する引数がゼロでない限り、ポインターによって参照されるオブジェクトを初期化する必要があります。 &lt;code&gt;read_write&lt;/code&gt; アクセスモードの使用例は、 &lt;code&gt;strcat&lt;/code&gt; 関数の最初の引数です。</target>
        </trans-unit>
        <trans-unit id="1720331b79d485f642342587a0a4961224f570c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; specifier affects code generation only in these ways:</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 指定子は、のみこれらの方法でコード生成に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="a5258162416b278a0bfac9c4c7558d341c9154f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove-outfile&lt;/code&gt; spec function takes one argument. It looks for the first argument in the outfiles array and removes it. Here is a small example its usage:</source>
          <target state="translated">&lt;code&gt;remove-outfile&lt;/code&gt; スペック関数は、1つの引数を取ります。これは、outfiles配列の最初の引数を探して削除します。以下は、その使用例です。</target>
        </trans-unit>
        <trans-unit id="55bb4e8d3fe19956428bf774ea204bd862418b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace-outfile&lt;/code&gt; spec function takes two arguments. It looks for the first argument in the outfiles array and replaces it with the second argument. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;replace-outfile&lt;/code&gt; スペック機能は2つの引数を取ります。outfiles配列で最初の引数を探し、2番目の引数で置き換えます。以下は、その使用例です。</target>
        </trans-unit>
        <trans-unit id="9408f2030b23dd54137985158e8c003e073220be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_nonnull&lt;/code&gt; attribute specifies that the function return value should be a non-null pointer. For instance, the declaration:</source>
          <target state="translated">&lt;code&gt;returns_nonnull&lt;/code&gt; 関数の戻り値がnullポインタでなければならないこと属性を指定します。たとえば、宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3e04bc9de35eb5e502accce1b00b75bbadd857dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_twice&lt;/code&gt; attribute tells the compiler that a function may return more than one time. The compiler ensures that all registers are dead before calling such a function and emits a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;vfork&lt;/code&gt;. The &lt;code&gt;longjmp&lt;/code&gt;-like counterpart of such function, if any, might need to be marked with the &lt;code&gt;noreturn&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;returns_twice&lt;/code&gt; の属性は、関数が1つ以上の時間を返すことをコンパイラに指示します。コンパイラーは、そのような関数を呼び出す前にすべてのレジスターが停止していることを確認し、関数からの2回目の戻りの後に破壊される可能性がある変数に関する警告を発行します。そのような関数の例は、 &lt;code&gt;setjmp&lt;/code&gt; と &lt;code&gt;vfork&lt;/code&gt; です。そのような関数の &lt;code&gt;longjmp&lt;/code&gt; に相当するものがある場合は、それを &lt;code&gt;noreturn&lt;/code&gt; 属性でマークする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d109540c91de909173d68023125715d31c5696c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rtd&lt;/code&gt; instruction is supported by the 68010, 68020, 68030, 68040, 68060 and CPU32 processors, but not by the 68000 or 5200.</source>
          <target state="translated">&lt;code&gt;rtd&lt;/code&gt; 命令はなく、68000または5200によって、68010、68020、68030、68040、68060およびCPU32プロセッサによってサポートされています。</target>
        </trans-unit>
        <trans-unit id="d6a97b87fbba98b99c49488ce8d99f3965e9820d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt;, and &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; built-in functions return a non-zero value if &lt;code&gt;arg1&lt;/code&gt; is greater than, less than, equal to, or not comparable to &lt;code&gt;arg2&lt;/code&gt; respectively. The arguments are not comparable if one or the other equals NaN (not a number).</source>
          <target state="translated">&lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt; 、 &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt; 、 &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt; 、及び &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; 場合組み込み関数はゼロ以外の値を返す &lt;code&gt;arg1&lt;/code&gt; より小さい、より大きい、に匹敵する、または等しくない &lt;code&gt;arg2&lt;/code&gt; で指定それぞれ。どちらかがNaN（数値ではない）と等しい場合、引数は比較できません。</target>
        </trans-unit>
        <trans-unit id="8ed56e8dd6f8e41dde6e37a24332591f1ce27f7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;scalar_extract_exp&lt;/code&gt; と &lt;code&gt;scalar_extract_sig&lt;/code&gt; 機能は、ISA 3.0以降をサポートする64ビットの環境を必要とします。 &lt;code&gt;scalar_extract_exp&lt;/code&gt; と &lt;code&gt;scalar_extract_sig&lt;/code&gt; 組み込み関数は、それぞれ自分の仮数とバイアス指数値を返す &lt;code&gt;source&lt;/code&gt; 引数。 64ビットが供給されると &lt;code&gt;source&lt;/code&gt; 引数によって返される結果 &lt;code&gt;scalar_extract_sig&lt;/code&gt; を有する &lt;code&gt;0x0010000000000000&lt;/code&gt; 関数の場合にビットセットを &lt;code&gt;source&lt;/code&gt; 引数は正規化された形式です。それ以外の場合、このビットは0に設定されます。128ビットの &lt;code&gt;source&lt;/code&gt; 引数を指定すると、 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 結果のビットは同様に扱われます。 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 数の符号は、scalar_extract_sig関数から返される結果には表されないことに注意してください。 &lt;code&gt;scalar_test_neg&lt;/code&gt; 関数を使用して、 &lt;code&gt;double&lt;/code&gt; 引数の符号をテストします。</target>
        </trans-unit>
        <trans-unit id="1f38aa375929331668f316b9a82c74ab6cc36489" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument. The &lt;code&gt;vec_msum&lt;/code&gt; functions perform a vector multiply-sum, returning the result of arg1*arg2+arg3. ISA 3.0 adds support for vec_msum returning a vector int128 result.</source>
          <target state="translated">&lt;code&gt;scalar_extract_exp&lt;/code&gt; と &lt;code&gt;scalar_extract_sig&lt;/code&gt; 機能は、ISA 3.0以降をサポートする64ビットの環境を必要とします。 &lt;code&gt;scalar_extract_exp&lt;/code&gt; と &lt;code&gt;scalar_extract_sig&lt;/code&gt; 組み込み関数は、それぞれ自分の仮数とバイアス指数値を返す &lt;code&gt;source&lt;/code&gt; 引数。 64ビットが供給されると &lt;code&gt;source&lt;/code&gt; 引数によって返される結果 &lt;code&gt;scalar_extract_sig&lt;/code&gt; を有する &lt;code&gt;0x0010000000000000&lt;/code&gt; 関数の場合にビットセットを &lt;code&gt;source&lt;/code&gt; 引数は正規化された形式です。それ以外の場合、このビットは0に設定されます。128ビットの &lt;code&gt;source&lt;/code&gt; 引数が指定されている場合、 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 結果のビットも同様に扱われます。 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 数の符号は、scalar_extract_sig関数から返される結果には表されないことに注意してください。 &lt;code&gt;scalar_test_neg&lt;/code&gt; 関数を使用して、その &lt;code&gt;double&lt;/code&gt; 引数の符号をテストします。 &lt;code&gt;vec_msum&lt;/code&gt; の機能は、ARG1 * ARG2 + ARG3の結果を返す、ベクトル乗算-加算を行います。 ISA 3.0は、ベクトルint128の結果を返すvec_msumのサポートを追加します。</target>
        </trans-unit>
        <trans-unit id="a572c2c2b0d3df765ec4322dbf92c35c2e4cbc19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_insert_exp&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. When supplied with a 64-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a double-precision floating point value that is constructed by assembling the values of its &lt;code&gt;significand&lt;/code&gt; and &lt;code&gt;exponent&lt;/code&gt; arguments. The sign of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 11 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 52 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">&lt;code&gt;scalar_insert_exp&lt;/code&gt; の機能は、ISA 3.0以降をサポートする64ビット環境が必要です。 64ビットの最初の引数を指定すると、 &lt;code&gt;scalar_insert_exp&lt;/code&gt; 組み込み関数は、その &lt;code&gt;significand&lt;/code&gt; および &lt;code&gt;exponent&lt;/code&gt; 引数の値を組み立てることによって構成される倍精度浮動小数点値を返します。結果の符号は、の最上位ビットからコピーされた &lt;code&gt;significand&lt;/code&gt; 引数。結果の仮数部と指数部は、それぞれ、 &lt;code&gt;exponent&lt;/code&gt; 引数の最下位11ビットと &lt;code&gt;significand&lt;/code&gt; 引数の最下位52ビットで構成されます。</target>
        </trans-unit>
        <trans-unit id="30e5f673754badb55457e9f6e18bad2fb7c8867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_data_class&lt;/code&gt; built-in function returns 1 if any of the condition tests enabled by the value of the &lt;code&gt;condition&lt;/code&gt; variable are true, and 0 otherwise. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;scalar_test_data_class&lt;/code&gt; 組み込み関数リターン1条件テストのいずれかの値で有効になっている場合 &lt;code&gt;condition&lt;/code&gt; 変数が真であり、そうでなければ0。 &lt;code&gt;condition&lt;/code&gt; 引数は、値が127を超えないとコンパイル時定数の整数でなければならない &lt;code&gt;condition&lt;/code&gt; ：以下によって特徴付けられる引数は、各ビットが異なる条件の試験を可能とビットマスクとして符号化されます</target>
        </trans-unit>
        <trans-unit id="8baf3f4610726735a8a214eff212593a1cbf0b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_neg&lt;/code&gt; built-in function returns 1 if its &lt;code&gt;source&lt;/code&gt; argument holds a negative value, 0 otherwise.</source>
          <target state="translated">&lt;code&gt;scalar_test_neg&lt;/code&gt; は組み込み関数リターン1の場合 &lt;code&gt;source&lt;/code&gt; 引数が負の値、そうでない場合は0を保持しています。</target>
        </trans-unit>
        <trans-unit id="312b5b4b73e9b711ee72f43d70d664005613348e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute causes an initialized global variable to have link-once semantics. When multiple definitions of the variable are encountered by the linker, the first is selected and the remainder are discarded. Following usage by the Microsoft compiler, the linker is told &lt;em&gt;not&lt;/em&gt; to warn about size or content differences of the multiple definitions.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; の属性は、リンクワンスセマンティクスを持つように初期化グローバル変数の原因となります。リンカが変数の複数の定義に遭遇すると、最初のものが選択され、残りは破棄されます。Microsoftコンパイラによる使用に続いて、リンカは複数の定義のサイズまたは内容の違いについて警告し&lt;em&gt;ない&lt;/em&gt;ように指示されます。</target>
        </trans-unit>
        <trans-unit id="7bbd5708df7b8ad51e26c82827c5a8837087e1d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute is only available on Microsoft Windows targets. You can use &lt;code&gt;__declspec (selectany)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; の属性は、Microsoft Windowsのターゲットでのみ使用可能です。他のコンパイラとの互換性のために、 &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; &lt;code&gt;__declspec (selectany)&lt;/code&gt; を__attribute__（（selectany））の同義語として使用できます。</target>
        </trans-unit>
        <trans-unit id="14873a7d123565ace388d75f6ab559389f994c52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute is only available on Microsoft Windows.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 属性は、Microsoft Windows上でのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="9085a2da6609ed3bc0fa42e0bccb84c58724a810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;si&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;si&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="5a2831e5752e0e20c3cf70a499fe35cbe998dc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; fields of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; structure allows your collection object to keep track of the state of the enumeration. In a simple array implementation, &lt;code&gt;state&lt;/code&gt; may keep track of the index of the last object that was returned, and &lt;code&gt;extra&lt;/code&gt; may be unused.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 構造の &lt;code&gt;state&lt;/code&gt; フィールドと &lt;code&gt;extra&lt;/code&gt; フィールドにより、コレクションオブジェクトは列挙の状態を追跡できます。単純な配列実装では、返された最後のオブジェクトのインデックスを &lt;code&gt;state&lt;/code&gt; が追跡し、 &lt;code&gt;extra&lt;/code&gt; が使用されない場合があります。</target>
        </trans-unit>
        <trans-unit id="3c61038602bd0b5479d4058a6d4baafd6a0c2107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct __htm_tdb&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; describes the structure of the transaction diagnostic block as specified in the Principles of Operation manual chapter 5-91.</source>
          <target state="translated">&lt;code&gt;struct __htm_tdb&lt;/code&gt; で定義された &lt;code&gt;htmintrin.h&lt;/code&gt; は、取扱説明書章5-91の原則に指定されたトランザクションの診断ブロックの構成について説明します。</target>
        </trans-unit>
        <trans-unit id="1669605966a6a01f0ff15b0d1cc0c388abd2971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute can be used for instance to have a function compiled with a different ISA (instruction set architecture) than the default. &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 属性は、デフォルトとは異なるISA（命令セットアーキテクチャ）でコンパイルされた機能を有するように、例えば、使用することができます。」</target>
        </trans-unit>
        <trans-unit id="9c500ff15f72b79070a64c0e0436e7dcdc9aaf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_clones&lt;/code&gt; attribute is used to specify that a function be cloned into multiple versions compiled with different target options than specified on the command line. The supported options and restrictions are the same as for &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;target_clones&lt;/code&gt; の属性は、コマンドラインで指定されたよりも機能が異なるターゲットオプションでコンパイル複数のバージョンにクローン化することを指定するために使用されます。サポートされるオプションと制限は、 &lt;code&gt;target&lt;/code&gt; 属性の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="ccf91998c7f416dcbd90db0b120c7a4f8d3b089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tls_model&lt;/code&gt; attribute sets thread-local storage model (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;) of a particular &lt;code&gt;__thread&lt;/code&gt; variable, overriding</source>
          <target state="translated">&lt;code&gt;tls_model&lt;/code&gt; 属性セットのスレッドローカルストレージ・モデル（参照&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;スレッドローカル&lt;/a&gt;の特定の） &lt;code&gt;__thread&lt;/code&gt; の上書き変数、</target>
        </trans-unit>
        <trans-unit id="2f43feeb5f6870d9594f888564bad52895276f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_absd&lt;/code&gt;, &lt;code&gt;vec_absdb&lt;/code&gt;, &lt;code&gt;vec_absdh&lt;/code&gt;, and &lt;code&gt;vec_absdw&lt;/code&gt; built-in functions each computes the absolute differences of the pairs of vector elements supplied in its two vector arguments, placing the absolute differences into the corresponding elements of the vector result.</source>
          <target state="translated">&lt;code&gt;vec_absd&lt;/code&gt; 、 &lt;code&gt;vec_absdb&lt;/code&gt; 、 &lt;code&gt;vec_absdh&lt;/code&gt; 、及び &lt;code&gt;vec_absdw&lt;/code&gt; 組み込み関数各ベクトル結果の対応する要素に差分絶対値を配置し、その2つのベクトル引数で供給されるベクトル要素のペアの絶対差を計算します。</target>
        </trans-unit>
        <trans-unit id="cc17321076f6146e9d0eff176ccfd2642bdf04e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_all_nez&lt;/code&gt;, &lt;code&gt;vec_any_eqz&lt;/code&gt;, and &lt;code&gt;vec_cmpnez&lt;/code&gt; perform pairwise comparisons between the elements at the same positions within their two vector arguments. The &lt;code&gt;vec_all_nez&lt;/code&gt; function returns a non-zero value if and only if all pairwise comparisons are not equal and no element of either vector argument contains a zero. The &lt;code&gt;vec_any_eqz&lt;/code&gt; function returns a non-zero value if and only if at least one pairwise comparison is equal or if at least one element of either vector argument contains a zero. The &lt;code&gt;vec_cmpnez&lt;/code&gt; function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that either the corresponding elements of the incoming arguments are not equal or that at least one of the corresponding elements contains zero. Otherwise, the element of the returned vector contains all zeros.</source>
          <target state="translated">&lt;code&gt;vec_all_nez&lt;/code&gt; 、 &lt;code&gt;vec_any_eqz&lt;/code&gt; 、及び &lt;code&gt;vec_cmpnez&lt;/code&gt; は、それら2つのベクトル引数内の同じ位置の要素間のペアワイズ比較を実行します。 &lt;code&gt;vec_all_nez&lt;/code&gt; の関数は、非ゼロ値を返した場合、すべてのペアワイズ比較が等しくないといずれかのベクトル引数のない要素がゼロを含まない場合にのみ。 &lt;code&gt;vec_any_eqz&lt;/code&gt; の関数は、非ゼロ値を返した場合は少なくとも1つのペアワイズ比較は等しいかのいずれかで、ベクトル引数の少なくとも一つの要素がゼロを含む場合である場合にのみ。 &lt;code&gt;vec_cmpnez&lt;/code&gt; functionは、2つの引数と同じ型のベクトルを返します。各要素はすべて1で構成され、入力引数の対応する要素が等しくないか、対応する要素の少なくとも1つにゼロが含まれていることを示します。それ以外の場合、返されるベクトルの要素にはすべてゼロが含まれます。</target>
        </trans-unit>
        <trans-unit id="a9ea2035fded0002d7bb2f5901563d260d2323cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; function returns the count of the number of consecutive leading byte elements (starting from position 0 within the supplied vector argument) for which the least-significant bit equals zero. The &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; function returns the count of the number of consecutive trailing byte elements (starting from position 15 and counting backwards within the supplied vector argument) for which the least-significant bit equals zero.</source>
          <target state="translated">&lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; の機能は、最下位ビットが0に等しいため連続先頭バイト要素（付属ベクトル引数内の位置0から始まる）の数を返します。 &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; の機能は、最下位ビットが0に等しいため連続後続バイト要素（付属ベクトル引数内の位置15及び計数後方から始まる）の数を返します。</target>
        </trans-unit>
        <trans-unit id="01b02bbdd65d95e68fbfa45f0222f7cae6e029b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_extract_sig&lt;/code&gt; and &lt;code&gt;vec_extract_exp&lt;/code&gt; built-in functions return vectors representing the significands and biased exponent values of their &lt;code&gt;source&lt;/code&gt; arguments respectively. Within the result vector returned by &lt;code&gt;vec_extract_sig&lt;/code&gt;, the &lt;code&gt;0x800000&lt;/code&gt; bit of each vector element returned when the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;float&lt;/code&gt; is set to 1 if the corresponding floating point value is in normalized form. Otherwise, this bit is set to 0. When the &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;double&lt;/code&gt;, the &lt;code&gt;0x10000000000000&lt;/code&gt; bit within each of the result vector&amp;rsquo;s elements is set according to the same rules. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;vec_extract_sig&lt;/code&gt; function. To extract the sign bits, use the &lt;code&gt;vec_cpsgn&lt;/code&gt; function, which returns a new vector within which all of the sign bits of its second argument vector are overwritten with the sign bits copied from the coresponding elements of its first argument vector, and all other (non-sign) bits of the second argument vector are copied unchanged into the result vector.</source>
          <target state="translated">&lt;code&gt;vec_extract_sig&lt;/code&gt; と &lt;code&gt;vec_extract_exp&lt;/code&gt; 組み込み関数は、それらの仮数とバイアス指数値を表すベクトルを返す &lt;code&gt;source&lt;/code&gt; それぞれ引数。返される結果ベクトル内 &lt;code&gt;vec_extract_sig&lt;/code&gt; 、 &lt;code&gt;0x800000&lt;/code&gt; 各ベクトル要素のビットは、関数のときに返さ &lt;code&gt;source&lt;/code&gt; 引数は、型のものである &lt;code&gt;float&lt;/code&gt; 対応する浮動小数点値は、正規化された形式である場合に1に設定されています。それ以外の場合、このビットは0に設定されます。 &lt;code&gt;source&lt;/code&gt; 引数のタイプが &lt;code&gt;double&lt;/code&gt; の場合、 &lt;code&gt;0x10000000000000&lt;/code&gt; 結果ベクトルの各要素内のビットは、同じ規則に従って設定されます。 &lt;code&gt;vec_extract_sig&lt;/code&gt; 数の符号は、vec_extract_sig関数から返される結果には表されないことに注意してください。符号ビットを抽出するには、 &lt;code&gt;vec_cpsgn&lt;/code&gt; 関数を使用します。この関数は、2番目の引数ベクトルのすべての符号ビットが、最初の引数ベクトルの対応する要素からコピーされた符号ビットで上書きされる新しいベクトルと、その他すべての（非-sign）2番目の引数ベクトルのビットが変更されずに結果ベクトルにコピーされます。</target>
        </trans-unit>
        <trans-unit id="5a829a08652f6801fcbd433b37bbf07c5d838fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_insert_exp&lt;/code&gt; built-in functions return a vector of single- or double-precision floating point values constructed by assembling the values of their &lt;code&gt;significands&lt;/code&gt; and &lt;code&gt;exponents&lt;/code&gt; arguments into the corresponding elements of the returned vector. The sign of each element of the result is copied from the most significant bit of the corresponding entry within the &lt;code&gt;significands&lt;/code&gt; argument. Note that the relevant bits of the &lt;code&gt;significands&lt;/code&gt; argument are the same, for both integer and floating point types. The significand and exponent components of each element of the result are composed of the least significant bits of the corresponding &lt;code&gt;significands&lt;/code&gt; element and the least significant bits of the corresponding &lt;code&gt;exponents&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;vec_insert_exp&lt;/code&gt; 組み込み関数は、それらの値を組み立てることによって構築単一または倍精度浮動小数点値のベクトルを返す &lt;code&gt;significands&lt;/code&gt; と &lt;code&gt;exponents&lt;/code&gt; 返却ベクトルの対応する要素に引数。結果の各要素の符号は、 &lt;code&gt;significands&lt;/code&gt; 引数内の対応するエントリの最上位ビットからコピーされます。整数型と浮動小数点型の両方で、仮数引数の関連ビットは同じである &lt;code&gt;significands&lt;/code&gt; 注意してください。結果の各要素の仮数部と指数部は、対応する &lt;code&gt;significands&lt;/code&gt; 最下位ビットで構成されます要素および対応する &lt;code&gt;exponents&lt;/code&gt; 要素の最下位ビット。</target>
        </trans-unit>
        <trans-unit id="0a91af05019f6d272dc741d0e069fe70406b3512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_revb&lt;/code&gt; built-in function reverses the bytes on an element by element basis. A vector of &lt;code&gt;vector unsigned char&lt;/code&gt; or &lt;code&gt;vector signed char&lt;/code&gt; reverses the bytes in the whole word.</source>
          <target state="translated">&lt;code&gt;vec_revb&lt;/code&gt; 組み込み関数は、要素ごとに要素のバイトを反転させます。ベクトル &lt;code&gt;vector unsigned char&lt;/code&gt; または &lt;code&gt;vector signed char&lt;/code&gt; 全体のワード内のバイトを反転させます。</target>
        </trans-unit>
        <trans-unit id="9de89009a6ac207492ea21a351e324b964d19bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_rsqrt&lt;/code&gt;, &lt;code&gt;__builtin_rsqrt&lt;/code&gt;, and &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; functions generate multiple instructions to implement the reciprocal sqrt functionality using reciprocal sqrt estimate instructions.</source>
          <target state="translated">&lt;code&gt;vec_rsqrt&lt;/code&gt; 、 &lt;code&gt;__builtin_rsqrt&lt;/code&gt; 、および &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; 機能が相反SQRT推定値命令を使用して相互のSQRT機能を実装するための複数の命令を生成します。</target>
        </trans-unit>
        <trans-unit id="246e48e9c9edd5f446bb04be8d23c0491da1918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_slv&lt;/code&gt; and &lt;code&gt;vec_srv&lt;/code&gt; functions operate on all of the bytes of their &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;shift_distance&lt;/code&gt; arguments in parallel. The behavior of the &lt;code&gt;vec_slv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;slv_array&lt;/code&gt; within which elements 0 through 15 are the same as the entries in the &lt;code&gt;src&lt;/code&gt; array and element 16 equals 0. The result returned from the &lt;code&gt;vec_slv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp;
shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type. The behavior of the &lt;code&gt;vec_srv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;srv_array&lt;/code&gt; within which element 0 equals zero and elements 1 through 16 equal the elements 0 through 15 of the &lt;code&gt;src&lt;/code&gt; array. The result returned from the &lt;code&gt;vec_srv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt;
(0x07 &amp;amp; shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;vec_slv&lt;/code&gt; と &lt;code&gt;vec_srv&lt;/code&gt; 関数は、そのバイトのすべてで動作する &lt;code&gt;src&lt;/code&gt; と &lt;code&gt;shift_distance&lt;/code&gt; 並列で引数。 &lt;code&gt;vec_slv&lt;/code&gt; の動作は、要素0〜15が &lt;code&gt;src&lt;/code&gt; 配列のエントリと同じで、要素16が0に等しい17の符号なし文字 &lt;code&gt;slv_array&lt;/code&gt; の一時配列が存在するかのようです &lt;code&gt;vec_slv&lt;/code&gt; 関数から返される結果は &lt;code&gt;__vector&lt;/code&gt; です。要素 &lt;code&gt;i&lt;/code&gt; がC式 &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; を使用して計算される16の符号なし文字の、この結果の値は &lt;code&gt;unsigned char&lt;/code&gt; 型に強制変換されます。 &lt;code&gt;vec_srv&lt;/code&gt; の動作は、要素0がゼロに等しく、要素 &lt;code&gt;srv_array&lt;/code&gt; が &lt;code&gt;src&lt;/code&gt; 配列の要素0〜15に等しい17の符号なし文字srv_arrayの一時配列が存在するかのようです。 &lt;code&gt;vec_srv&lt;/code&gt; 関数から返される結果は、16個の符号なし文字の &lt;code&gt;__vector&lt;/code&gt; であり、その中で要素 &lt;code&gt;i&lt;/code&gt; はC式 &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; を使用して計算されます）、この結果の値は &lt;code&gt;unsigned char&lt;/code&gt; 型に強制変換されます。</target>
        </trans-unit>
        <trans-unit id="6a1b591d1d5bc9da82b7b03dcf8d2e3d88da8bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_test_data_class&lt;/code&gt; built-in function returns a vector representing the results of testing the &lt;code&gt;source&lt;/code&gt; vector for the condition selected by the &lt;code&gt;condition&lt;/code&gt; argument. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;vec_test_data_class&lt;/code&gt; 組み込み関数は、テストの結果を表すベクトルを返し &lt;code&gt;source&lt;/code&gt; によって選択された条件のベクトル &lt;code&gt;condition&lt;/code&gt; 引数。 &lt;code&gt;condition&lt;/code&gt; 引数は、値が127を超えないとコンパイル時定数の整数でなければならない &lt;code&gt;condition&lt;/code&gt; ：以下によって特徴付けられる引数は、各ビットが異なる条件の試験を可能とビットマスクとして符号化されます</target>
        </trans-unit>
        <trans-unit id="991ae395a453d861dfb8c7b24fc2cbc3ce4b3da0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;vec_xl_len&lt;/code&gt; function loads a variable length vector from memory. The &lt;code&gt;vec_xst_len&lt;/code&gt; function stores a variable length vector to memory. With both the &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions, the &lt;code&gt;addr&lt;/code&gt; argument represents the memory address to or from which data will be transferred, and the &lt;code&gt;len&lt;/code&gt; argument represents the number of bytes to be transferred, as computed by the C expression &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt;. If this expression&amp;rsquo;s value is not a multiple of the vector element&amp;rsquo;s size, the behavior of this function is undefined. In the case that the underlying computer is configured to run in big-endian mode, the data transfer moves bytes 0 to &lt;code&gt;(len - 1)&lt;/code&gt; of the corresponding vector. In little-endian mode, the data transfer moves bytes &lt;code&gt;(16 - len)&lt;/code&gt; to &lt;code&gt;15&lt;/code&gt; of the corresponding vector. For the load function, any bytes of the result vector that are not loaded from memory are set to zero. The value of the &lt;code&gt;addr&lt;/code&gt; argument need not be aligned on a multiple of the vector&amp;rsquo;s element size.</source>
          <target state="translated">&lt;code&gt;vec_xl_len&lt;/code&gt; と &lt;code&gt;vec_xst_len&lt;/code&gt; 機能は、ISA 3.0以降をサポートする64ビットの環境を必要とします。 &lt;code&gt;vec_xl_len&lt;/code&gt; 機能ロードメモリから可変長ベクトル。 &lt;code&gt;vec_xst_len&lt;/code&gt; 関数をメモリに可変長ベクトル。双方で &lt;code&gt;vec_xl_len&lt;/code&gt; と &lt;code&gt;vec_xst_len&lt;/code&gt; 機能、 &lt;code&gt;addr&lt;/code&gt; 引数は、データが転送されるまで、またはからメモリアドレスを表し、および &lt;code&gt;len&lt;/code&gt; の引数はC発現によって計算される、転送されるバイトの数を表す &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt; 。この式の値がベクトル要素のサイズの倍数でない場合、この関数の動作は未定義です。基盤となるコンピューターがビッグエンディアンモードで実行するように構成されている場合、データ転送により、対応するベクトルのバイト0から &lt;code&gt;(len - 1)&lt;/code&gt; に移動します。リトルエンディアンモードでは、データ転送はバイト &lt;code&gt;(16 - len)&lt;/code&gt; を対応するベクトルの &lt;code&gt;15&lt;/code&gt; に移動します。関数loadの場合、メモリから読み込まれない結果ベクトルのバイトはすべてゼロに設定されます。 &lt;code&gt;addr&lt;/code&gt; 引数の値は、ベクトルの要素サイズの倍数に揃える必要はありません。</target>
        </trans-unit>
        <trans-unit id="32f436c7a33759092d0385b9b27659581036ece3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xlx&lt;/code&gt; and &lt;code&gt;vec_xrx&lt;/code&gt; functions extract the single element selected by the &lt;code&gt;index&lt;/code&gt; argument from the vector represented by the &lt;code&gt;data&lt;/code&gt; argument. The &lt;code&gt;index&lt;/code&gt; argument always specifies a byte offset, regardless of the size of the vector element. With &lt;code&gt;vec_xlx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; is the offset of the first byte of the element to be extracted. With &lt;code&gt;vec_xrx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; represents the last byte of the element to be extracted, measured from the right end of the vector. In other words, the last byte of the element to be extracted is found at position &lt;code&gt;(15 - index)&lt;/code&gt;. There is no requirement that &lt;code&gt;index&lt;/code&gt; be a multiple of the vector element size. However, if the size of the vector element added to &lt;code&gt;index&lt;/code&gt; is greater than 15, the content of the returned value is undefined.</source>
          <target state="translated">&lt;code&gt;vec_xlx&lt;/code&gt; と &lt;code&gt;vec_xrx&lt;/code&gt; 関数はによって選択された単一要素抽出 &lt;code&gt;index&lt;/code&gt; によって表されるベクトルからの引数 &lt;code&gt;data&lt;/code&gt; 引数。 &lt;code&gt;index&lt;/code&gt; 引数は関係なく、常にベクトル要素の大きさの、バイトオフセットを指定します。 &lt;code&gt;vec_xlx&lt;/code&gt; 、 &lt;code&gt;index&lt;/code&gt; 抽出する要素の最初のバイトのオフセットです。 &lt;code&gt;vec_xrx&lt;/code&gt; 、 &lt;code&gt;index&lt;/code&gt; 、ベクトルの右端から測定し、抽出する要素の最後のバイトを表しています。つまり、抽出される要素の最後のバイトは、位置 &lt;code&gt;(15 - index)&lt;/code&gt; ます。 &lt;code&gt;index&lt;/code&gt; 必要はありませんベクトル要素サイズの倍数になります。ただし、 &lt;code&gt;index&lt;/code&gt; 追加されたベクター要素のサイズが15より大きい場合、戻り値の内容は未定義です。</target>
        </trans-unit>
        <trans-unit id="1ebaac2fb10fbefef121de501464e717714b8367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vector_size&lt;/code&gt; attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are positive power-of-two multiples of the base type size are currently allowed.</source>
          <target state="translated">&lt;code&gt;vector_size&lt;/code&gt; の配列、ポインタ、関数の戻り値はこの構造と関連して許可されているが、属性は、整数および浮動スカラにのみ適用されます。現在、基本タイプサイズの2のべき乗の倍数であるサイズのみが許可されています。</target>
        </trans-unit>
        <trans-unit id="837b5049d27cb5d3caabb0997e45a1cbb234446d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vliw&lt;/code&gt; attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command-line options.</source>
          <target state="translated">&lt;code&gt;vliw&lt;/code&gt; 属性は、VLIWモードの代わりに、コアモードで発光命令にコンパイラに指示します。この属性は、VLIWコプロセッサーが構成され、コマンドラインオプションで有効にされていない限り、許可されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="42d2812dccb310da3b37a59c6a8e7a142b29dac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warn_unused_result&lt;/code&gt; attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;warn_unused_result&lt;/code&gt; の属性は、この属性を持つ関数の呼び出し元が、その戻り値を使用していない場合には警告が発せられることになり。これは、結果をチェックしないことがセキュリティ上の問題であるか、 &lt;code&gt;realloc&lt;/code&gt; などの常にバグである関数に役立ちます。</target>
        </trans-unit>
        <trans-unit id="0d86cabe39f6b2eca4b3f76217c522746181a80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes a declaration of an external symbol to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. The overriding symbol must have the same type as the weak symbol. In addition, if it designates a variable it must also have the same size and alignment as the weak symbol. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 属性ではなく、グローバルより弱いシンボルとして放出される外部シンボルの宣言を引き起こします。これは主に、ユーザーコードでオーバーライドできるライブラリ関数を定義する場合に役立ちますが、関数以外の宣言でも使用できます。オーバーライドするシンボルは、弱いシンボルと同じタイプである必要があります。さらに、変数を指定する場合は、弱い記号と同じサイズと配置にする必要があります。弱いシンボルは、ELFターゲット、およびGNUアセンブラとリンカーを使用する場合のa.outターゲットでサポートされます。</target>
        </trans-unit>
        <trans-unit id="d64e3cfe5255e69eafb7d485c8c088e61fa4d8a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 属性ではなく、グローバルより弱いシンボルとして放出される宣言を引き起こします。これは主に、ユーザーコードでオーバーライドできるライブラリ関数を定義するのに役立ちますが、関数以外の宣言でも使用できます。弱いシンボルは、ELFターゲットでサポートされています。また、GNUアセンブラーとリンカーを使用する場合は、a.outターゲットでもサポートされます。</target>
        </trans-unit>
        <trans-unit id="4250f8084c2d37890c56691349397dd644e93eba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 属性がに記述されている&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;一般的な機能の属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fd7b693a88b68899809d3dfabebee19f1a4688b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Alternatively, &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself, naming the target definition of the alias. The &lt;var&gt;target&lt;/var&gt; must have the same type as the declaration. In addition, if it designates a variable it must also have the same size and alignment as the declaration. In either form of the declaration &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declared symbol as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt; given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt; (in that case the declaration may be &lt;code&gt;extern&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;weakref&lt;/code&gt; 属性マーク弱参照として宣言。引数がない場合は、ターゲットシンボルに名前を付ける &lt;code&gt;alias&lt;/code&gt; 属性を付ける必要があります。あるいは、 &lt;var&gt;target&lt;/var&gt; を &lt;code&gt;weakref&lt;/code&gt; 自体への引数として指定し、エイリアスのターゲット定義に名前を付けることもできます。 &lt;var&gt;target&lt;/var&gt; 宣言と同じタイプを持っている必要があります。さらに、変数を指定する場合は、宣言と同じサイズと配置にする必要があります。どちらの形式の宣言でも、 &lt;code&gt;weakref&lt;/code&gt; は宣言されたシンボルを &lt;code&gt;weak&lt;/code&gt; として暗黙的にマークします。 &lt;code&gt;weakref&lt;/code&gt; または &lt;code&gt;alias&lt;/code&gt; への引数として指定された &lt;var&gt;target&lt;/var&gt; ない場合、 &lt;code&gt;weakref&lt;/code&gt; は、と等価である &lt;code&gt;weak&lt;/code&gt; （その場合、宣言があってもよい &lt;code&gt;extern&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="362aefd1f311374abf7ac9d8d10e9633ea762db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Optionally, the &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself. In either case, &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declaration as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt;, given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weakref&lt;/code&gt; 属性マーク弱参照として宣言。引数がない場合は、ターゲットシンボルに名前を付ける &lt;code&gt;alias&lt;/code&gt; 属性を伴う必要があります。オプションで、 &lt;var&gt;target&lt;/var&gt; を &lt;code&gt;weakref&lt;/code&gt; 自体の引数として指定できます。どちらの場合でも、 &lt;code&gt;weakref&lt;/code&gt; は宣言を暗黙的に &lt;code&gt;weak&lt;/code&gt; としてマークします。なし &lt;var&gt;target&lt;/var&gt; への引数として与えられ、 &lt;code&gt;weakref&lt;/code&gt; 又はへ &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;weakref&lt;/code&gt; はに相当する &lt;code&gt;weak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31c2b38693187358ef61afd2bbcd821fce4cea47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_only&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to write to the referenced object but not read from it. The object referenced by the pointer need not be initialized. An example of the use of the &lt;code&gt;write_only&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcpy&lt;/code&gt; function, or the first two arguments to the &lt;code&gt;fgets&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;write_only&lt;/code&gt; アクセスモードはなしポインタ型の引数に適用される &lt;code&gt;const&lt;/code&gt; 修飾子。これは、それが適用されるポインターが、参照されるオブジェクトへの書き込みに使用されるが、オブジェクトからの読み取りには使用されないことを指定します。ポインタによって参照されるオブジェクトを初期化する必要はありません。 &lt;code&gt;write_only&lt;/code&gt; アクセスモードの使用例は、 &lt;code&gt;strcpy&lt;/code&gt; 関数の最初の引数、または &lt;code&gt;fgets&lt;/code&gt; 関数の最初の2つの引数です。</target>
        </trans-unit>
        <trans-unit id="a5580c84e305bbd75698ac25971a0df43ef6cc5f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;call_exp&lt;/var&gt; expression must be a function call, and the &lt;var&gt;pointer_exp&lt;/var&gt; expression must be a pointer. The &lt;var&gt;pointer_exp&lt;/var&gt; is passed to the function call in the target&amp;rsquo;s static chain location. The result of builtin is the result of the function call.</source>
          <target state="translated">&lt;var&gt;call_exp&lt;/var&gt; の式は、関数呼び出しでなければならない、と &lt;var&gt;pointer_exp&lt;/var&gt; の式はポインタでなければなりません。 &lt;var&gt;pointer_exp&lt;/var&gt; は、ターゲットの静的なチェーンの場所にある関数呼び出しに渡されます。組み込みの結果は、関数呼び出しの結果です。</target>
        </trans-unit>
        <trans-unit id="47808f5c44d74211446dd3107371068aa638bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;information&lt;/var&gt; is human readable, but designed to be simple enough for machine parsing too.</source>
          <target state="translated">&lt;var&gt;information&lt;/var&gt; 人間が読めるが、マシンがあまりにも解析するためのシンプルな十分になるように設計されています。</target>
        </trans-unit>
        <trans-unit id="2e82b6b86f048807c7ae6131df8cf24c8fb6345a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument must be a constant integer.</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; 引数は整数定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2457707eff68e08cd199be4e3c699bc3aefc86a0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; 引数は、次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e08ee76b1da2a0a7eab6aae9dc5ab5a92291dc1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; can be one of:</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="07133152e9a0d85287182cf9221be477141dff40" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;oldname&lt;/var&gt; used by &lt;code&gt;#pragma redefine_extname&lt;/code&gt; is always the C-language name.</source>
          <target state="translated">&lt;var&gt;oldname&lt;/var&gt; で使用される &lt;code&gt;#pragma redefine_extname&lt;/code&gt; 常にC言語の名前です。</target>
        </trans-unit>
        <trans-unit id="f9388ad5137ed5dfa5588bcfa11755abc3ce7181" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;options&lt;/var&gt; can be divided into three groups:</source>
          <target state="translated">&lt;var&gt;options&lt;/var&gt; 3つのグループに分けることができます。</target>
        </trans-unit>
        <trans-unit id="c19aabaea762edf72b5cc0612746c317d8ff2de8" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;os&lt;/var&gt; argument is the object size &lt;var&gt;s&lt;/var&gt; points to, like in the other built-in functions. There is a small difference in the behavior though, if &lt;var&gt;os&lt;/var&gt; is &lt;code&gt;(size_t) -1&lt;/code&gt;, the built-in functions are optimized into the non-checking functions only if &lt;var&gt;flag&lt;/var&gt; is 0, otherwise the checking function is called with &lt;var&gt;os&lt;/var&gt; argument set to &lt;code&gt;(size_t) -1&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;os&lt;/var&gt; 引数は、オブジェクトの大きさ &lt;var&gt;s&lt;/var&gt; 他の組み込み関数のようにポイント。動作には少し違いがありますが、 &lt;var&gt;os&lt;/var&gt; が &lt;code&gt;(size_t) -1&lt;/code&gt; 場合、組み込み関数は &lt;var&gt;flag&lt;/var&gt; が0の場合にのみ非チェック関数に最適化されます。それ以外の場合、チェック関数は &lt;var&gt;os&lt;/var&gt; 引数を &lt;code&gt;(size_t) -1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99051c6bb8529049d31b5150a695460a96f0eb50" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; can either be a number (decimal, octal or hex) or an arbitrary string (in which case it&amp;rsquo;s converted to a number by computing CRC32).</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; いずれかの番号（10進数、8進数、またはヘックス）または任意の文字列（この場合、それはCRC32を計算することによって数値に変換されます）であることができます。</target>
        </trans-unit>
        <trans-unit id="e2a9a665b951d617734d12093bb7933ae309b7f0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; should be different for every file you compile.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; コンパイルすべてのファイルのために異なっている必要があります。</target>
        </trans-unit>
        <trans-unit id="e5cf6b74b693d7f4748254b48ea16e3b5621f730" translate="yes" xml:space="preserve">
          <source>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</source>
          <target state="translated">ABIタグは名前に適用されるので、テンプレートのすべてのインスタンス化と特殊化は同じタグを持ちます。この属性は、明示的な特殊化やインスタンス化に適用された場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="d6e578589905c0491635616be2b8a8085308fc15" translate="yes" xml:space="preserve">
          <source>The AIX calling convention was extended but not initially documented to handle an obscure K&amp;amp;R C case of calling a function that takes the address of its arguments with fewer arguments than declared. IBM XL compilers access floating-point arguments that do not fit in the RSA from the stack when a subroutine is compiled without optimization. Because always storing floating-point arguments on the stack is inefficient and rarely needed, this option is not enabled by default and only is necessary when calling subroutines compiled by IBM XL compilers without optimization.</source>
          <target state="translated">AIX呼び出し規約は拡張されましたが、宣言されたよりも少ない引数で引数のアドレスを受け取る関数を呼び出すというあいまいなK＆R Cケースを処理するように最初に文書化されていません。 IBM XLコンパイラーは、サブルーチンを最適化せずにコンパイルすると、スタックからRSAに適合しない浮動小数点引数にアクセスします。スタックに浮動小数点引数を常に格納することは非効率的でほとんど必要とされないため、このオプションはデフォルトでは有効ではなく、最適化なしでIBM XLコンパイラーによってコンパイルされたサブルーチンを呼び出す場合にのみ必要です。</target>
        </trans-unit>
        <trans-unit id="0286e5ab4aaa67941386b2ad2370f9a09da6cea5" translate="yes" xml:space="preserve">
          <source>The ARM attribute &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; is set in the generated object file to either true or false, depending upon the setting of this option. If unaligned access is enabled then the preprocessor symbol &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; is also defined.</source>
          <target state="translated">ARM属性 &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; は、このオプションの設定に応じて、生成されたオブジェクトファイルでtrueまたはfalseに設定されます。非境界整列アクセスが有効な場合、プリプロセッサシンボル &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; も定義されます。</target>
        </trans-unit>
        <trans-unit id="38b655dda41c627fb0c53750526171175cc9f72b" translate="yes" xml:space="preserve">
          <source>The ARM target defines pragmas for controlling the default addition of &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;short_call&lt;/code&gt; attributes to functions. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for information about the effects of these attributes.</source>
          <target state="translated">ARMターゲットは、関数への &lt;code&gt;long_call&lt;/code&gt; および &lt;code&gt;short_call&lt;/code&gt; 属性のデフォルトの追加を制御するためのプラグマを定義します。これらの属性の影響については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="180b9a433ddcfbb50e74358632373510b9ae0866" translate="yes" xml:space="preserve">
          <source>The ARM target provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; values as an extension to VFP and NEON (Advanced SIMD), and from ARMv8-A provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; values. GCC generates code using these hardware instructions if you compile with options to select an FPU that provides them; for example,</source>
          <target state="translated">ARMターゲットは、VFPとNEON（Advanced SIMD）の拡張機能として、 &lt;code&gt;__fp16&lt;/code&gt; と &lt;code&gt;float&lt;/code&gt; 値間の変換のハードウェアサポートを提供し、ARMv8-Aは、 &lt;code&gt;__fp16&lt;/code&gt; と &lt;code&gt;double&lt;/code&gt; 値間の変換のハードウェアサポートを提供します。それらを提供するFPUを選択するオプションでコンパイルすると、GCCはこれらのハードウェア命令を使用してコードを生成します。例えば、</target>
        </trans-unit>
        <trans-unit id="74677651175ff4a21af34df2adc4b16af0c62864" translate="yes" xml:space="preserve">
          <source>The ARM-state integer division instructions.</source>
          <target state="translated">ARM状態の整数除算命令です。</target>
        </trans-unit>
        <trans-unit id="25504eb2b5db6b1309f7e3ea71e7847bbe69ef9e" translate="yes" xml:space="preserve">
          <source>The ARMv8-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8-A Advanced SIMDと浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="7f8a18de7f60ebb2b7344b3e4891cc4342f1a12d" translate="yes" xml:space="preserve">
          <source>The ARMv8.1-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8.1-AアドバンスドSIMDと浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="33734522bf6eef68d24bf96c977fe3c147340232" translate="yes" xml:space="preserve">
          <source>The ARMv8.3-A Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">ARMv8.3-A Advanced SIMDと浮動小数点命令だけでなく、Dot Productの拡張機能も搭載しています。</target>
        </trans-unit>
        <trans-unit id="2e1c8ef545821a2ae5bcfc55a26fd3b81629816e" translate="yes" xml:space="preserve">
          <source>The AT&amp;amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</source>
          <target state="translated">AT＆T C ++トランスレータであるCfrontは、自動的に維持されるテンプレートインスタンスが格納される場所であるテンプレートリポジトリの概念を作成することにより、テンプレートのインスタンス化の問題を解決しました。リポジトリの最新バージョンは次のように機能します。個々のオブジェクトファイルがビルドされると、コンパイラは、リポジトリで検出されたテンプレート定義とインスタンス化を配置します。リンク時に、リンクラッパーはリポジトリ内のオブジェクトを追加し、以前に発行されなかった必要なインスタンスをコンパイルします。このモデルの利点は、より最適なコンパイル速度とシステムリンカーを使用できることです。 Borlandモデルを実装するには、コンパイラベンダーもリンカーを置き換える必要があります。不利な点は、複雑さが大幅に増大することであり、したがってエラーの可能性があります。一部のコードでは、これは同様に透過的です。しかし実際には、1つのディレクトリに複数のプログラムを作成し、複数のディレクトリに1つのプログラムを作成するのは非常に困難な場合があります。このモデル用に作成されたコードは、非インラインメンバーテンプレートの定義を個別にコンパイルする必要がある個別のファイルに分離する傾向があります。</target>
        </trans-unit>
        <trans-unit id="b2f96e374cb7c3be8b863693d2e8387693d91334" translate="yes" xml:space="preserve">
          <source>The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the &lt;code&gt;signal&lt;/code&gt; attribute do not re-enable interrupts. It is save to enable interrupts in a &lt;code&gt;signal&lt;/code&gt; handler. This &amp;ldquo;save&amp;rdquo; only applies to the code generated by the compiler and not to the IRQ layout of the application which is responsibility of the application.</source>
          <target state="translated">割り込みが実行されると、AVRハードウェアは割り込みをグローバルに無効にします。 &lt;code&gt;signal&lt;/code&gt; 属性で定義された割り込みハンドラー関数は、割り込みを再度有効にしません。 &lt;code&gt;signal&lt;/code&gt; ハンドラーで割り込みを有効にすることは保存されます。この「保存」は、コンパイラーによって生成されたコードにのみ適用され、アプリケーションの責任であるアプリケーションのIRQレイアウトには適用されません。</target>
        </trans-unit>
        <trans-unit id="819e5dd1ebff38014ce3cc47fe71028f5e880298" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions, with the half-precision floating-point conversion operations.</source>
          <target state="translated">Advanced SIMD (Neon)v1とVFPv3の浮動小数点命令で、半精度浮動小数点変換演算を行います。</target>
        </trans-unit>
        <trans-unit id="04a974f086b15b184d16af3fa03c2b5403d55b20" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v1およびVFPv3浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="3b1828fb03b38714492461b5c83b7a35d9811c07" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extensions &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v1およびVFPv3浮動小数点命令。拡張機能 '</target>
        </trans-unit>
        <trans-unit id="25f15c2fd3a5e4f09bf2de0e8dd88934f187e30c" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions.</source>
          <target state="translated">Advanced SIMD (Neon)v2とVFPv4浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="8fb627100c24fb77ea39c11992a8aa490fe9b6bf" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v2およびVFPv4浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="a0b4e865040163440dd355cb51993ec44628f3a4" translate="yes" xml:space="preserve">
          <source>The Alpha architecture implements floating-point hardware optimized for maximum performance. It is mostly compliant with the IEEE floating-point standard. However, for full compliance, software assistance is required. This option generates code fully IEEE-compliant code &lt;em&gt;except&lt;/em&gt; that the &lt;var&gt;inexact-flag&lt;/var&gt; is not maintained (see below). If this option is turned on, the preprocessor macro &lt;code&gt;_IEEE_FP&lt;/code&gt; is defined during compilation. The resulting code is less efficient but is able to correctly support denormalized numbers and exceptional IEEE values such as not-a-number and plus/minus infinity. Other Alpha compilers call this option</source>
          <target state="translated">Alphaアーキテクチャは、最大のパフォーマンスのために最適化された浮動小数点ハードウェアを実装しています。ほとんどの場合、IEEE浮動小数点標準に準拠しています。ただし、完全に準拠するには、ソフトウェアの支援が必要です。このオプションは、 &lt;var&gt;inexact-flag&lt;/var&gt; が維持されないこと&lt;em&gt;を除い&lt;/em&gt;て、完全にIEEE準拠のコード&lt;em&gt;を&lt;/em&gt;生成します（以下を参照）。このオプションをオンにすると、プリプロセッサマクロ &lt;code&gt;_IEEE_FP&lt;/code&gt; がコンパイル時に定義されます。結果のコードは効率が低下しますが、非正規化数と、非数やプラス/マイナス無限大などの例外的なIEEE値を正しくサポートできます。他のAlphaコンパイラはこのオプションを呼び出します</target>
        </trans-unit>
        <trans-unit id="a224b29d0d210a4ad06df789e64da22f568f6054" translate="yes" xml:space="preserve">
          <source>The AltiVec built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.06 or later. These are normally enabled by adding</source>
          <target state="translated">このセクションで説明する AltiVec ビルトイン機能は、ISA 2.06 以降の PowerPC ファミリのプロセッサで利用できます。これらの機能は通常</target>
        </trans-unit>
        <trans-unit id="224e64a8094f6a857fb86e36e422aa4067f4740c" translate="yes" xml:space="preserve">
          <source>The C and C++ language specifications differ when an object is accessed in a void context:</source>
          <target state="translated">C言語とC++言語では、オブジェクトがvoidコンテキストでアクセスされる場合の仕様が異なります。</target>
        </trans-unit>
        <trans-unit id="0ef06715d23eab6e0953d0e3dffa82f688ece5af" translate="yes" xml:space="preserve">
          <source>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of &lt;em&gt;sequence points&lt;/em&gt;, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;? :&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt; (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap.</source>
          <target state="translated">CおよびC ++標準は、C / C ++プログラムの式が&lt;em&gt;シーケンスポイントの&lt;/em&gt;観点から評価される順序を定義します。これは、プログラムの部分の実行の間の部分的な順序を表します：シーケンスポイントの前に実行されるものと後に実行されるものそれ。これらは、完全な式（より大きな式の一部ではない式）の評価後、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;||&lt;/code&gt; の最初のオペランドの評価後に発生します。、 &lt;code&gt;? :&lt;/code&gt; または &lt;code&gt;,&lt;/code&gt; （カンマ）演算子、関数が呼び出される前（ただし、その引数と呼び出された関数を表す式の評価後）、および他の特定の場所。シーケンスポイントルールによって表現される場合を除き、式の部分式の評価順序は指定されていません。これらのルールはすべて、全体の順序ではなく部分的な順序のみを記述します。たとえば、2つの関数が1つの式内で呼び出され、その間にシーケンスポイントがない場合、関数が呼び出される順序は指定されません。ただし、標準化委員会は、関数呼び出しが重複しないように決定しました。</target>
        </trans-unit>
        <trans-unit id="ef19b8344a45aab20d25a471f2eb0b887d44fb1e" translate="yes" xml:space="preserve">
          <source>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.</source>
          <target state="translated">C++ABI では、コンストラクタとデストラクタに複数のエントリ・ポイントが必要となります。仮想ベースを持つ階層では、ベースと完全なバリアントはクローンであり、これは関数の2つのコピーを意味します。このオプションを指定すると、ベースと完全バリアントは共通の実装を呼び出すサンクに変更されます。</target>
        </trans-unit>
        <trans-unit id="e88e1274e3c31338e664afbec99b09eac3f5a529" translate="yes" xml:space="preserve">
          <source>The C++ front end implements syntactic extensions that allow compile-time determination of various characteristics of a type (or of a pair of types).</source>
          <target state="translated">C++フロントエンドは、型(または型のペア)のさまざまな特性をコンパイル時に決定できるようにする構文拡張を実装しています。</target>
        </trans-unit>
        <trans-unit id="ec04375b745b1f1c4ce1f6fa5f903e079a94852c" translate="yes" xml:space="preserve">
          <source>The C++ language was further revised in 2017 and ISO/IEC 14882:2017 was published. This is referred to as C++17, and before publication was often referred to as C++1z. GCC supports all the changes in the new specification. For further details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;. Use the option</source>
          <target state="translated">C ++言語は2017年にさらに改訂され、ISO / IEC 14882：2017が公開されました。これはC ++ 17と呼ばれ、発行前はしばしばC ++ 1zと呼ばれていました。GCCは、新しい仕様のすべての変更をサポートしています。詳細については、&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https：//gcc.gnu.org/projects/cxx-status.html#cxx1zを&lt;/a&gt;参照してください。オプションを使用する</target>
        </trans-unit>
        <trans-unit id="bcdb3a64fa68982d2e2c4cbdd5d9be1a69decab7" translate="yes" xml:space="preserve">
          <source>The C++ library used with a C++ compiler includes the Standard C++ Library, with functionality defined in the C++ Standard, plus language runtime support. The runtime support is included in a C++ ABI, but there is no formal ABI for the Standard C++ Library. Two implementations of that library are interoperable if one follows the de-facto ABI of the other and if they are both built with the same compiler, or with compilers that conform to the same ABI for C++ compiler and runtime support.</source>
          <target state="translated">C++コンパイラで使用される C++ライブラリには、C++標準で定義されている機能を持つ標準 C++ライブラリと言語ランタイム・サポートが含まれています。ランタイム・サポートは C++ABI に含まれていますが、標準 C++ライブラリには正式な ABI はありません。そのライブラリの 2 つの実装は、一方が他方のデファクト ABI に従い、両方とも同じコンパイラを使用してビルドされるか、C++コンパイラとランタイム・サポートのための同じ ABI に準拠したコンパイラを使用してビルドされる場合、相互運用可能です。</target>
        </trans-unit>
        <trans-unit id="b030a2dbb3c8b3c3ceafa77d7dbaf4d97c312843" translate="yes" xml:space="preserve">
          <source>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases. This option also causes G++ to call trivial member functions which otherwise would be expanded inline.</source>
          <target state="translated">C++標準では、同じ型の別のオブジェクトの初期化にのみ使用されるテンポラリの作成を省略できるようになっています。このオプションを指定すると、その最適化が無効になり、G++はすべてのケースでコピー・コンストラクタを強制的に呼び出します。また、このオプションを指定すると、通常はインラインで展開されるような些細なメンバ関数が G++によって呼び出されるようになります。</target>
        </trans-unit>
        <trans-unit id="c549c47d787f5172f4a63d73dccb4d86a5de3eaa" translate="yes" xml:space="preserve">
          <source>The C++ standard differs from the C standard in its treatment of volatile objects. It fails to specify what constitutes a volatile access, except to say that C++ should behave in a similar manner to C with respect to volatiles, where possible. However, the different lvalueness of expressions between C and C++ complicate the behavior. G++ behaves the same as GCC for volatile access, See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;, for a description of GCC&amp;rsquo;s behavior.</source>
          <target state="translated">C ++標準は、揮発性オブジェクトの処理においてC標準とは異なります。C ++が揮発性に関してCと同じように動作する必要がある場合を除いて、揮発性アクセスを構成するものを指定することはできません。ただし、CとC ++で式の左辺値が異なるため、動作が複雑になります。G ++は、揮発性アクセスについてはGCC と同じように動作します。GCCの動作の説明については、&lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatilesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="949a50a0730c5f7ad89696edd9c2072338129167" translate="yes" xml:space="preserve">
          <source>The C++ standard just uses the term &amp;ldquo;dependent&amp;rdquo; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</source>
          <target state="translated">C ++標準では、テンプレートパラメータのタイプまたは値に依存する名前に「依存」という用語を使用しています。この短い用語は、このセクションの残りの部分でも使用されます。</target>
        </trans-unit>
        <trans-unit id="7681d0e5c1533a0361ba254a5958bd845de12e17" translate="yes" xml:space="preserve">
          <source>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Only names that are dependent are looked up at the point of instantiation. For example, consider</source>
          <target state="translated">C ++標準では、テンプレート関数またはクラスを解析するときに、テンプレートパラメーターに依存しないすべての名前が現在の定義にバインドされると規定されています。&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;従属している名前のみがインスタンス化の時点で検索されます。たとえば、</target>
        </trans-unit>
        <trans-unit id="253e6af722c0841d38d6e4f298c9a3cde3c002be" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that &amp;lsquo;</source>
          <target state="translated">C ++標準では、</target>
        </trans-unit>
        <trans-unit id="7e51d56fadfe74149ae162a54ac1fe3c8b16dbb0" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access. There is reason to believe that it is, because otherwise certain simple expressions become undefined. However, because it would surprise most programmers, G++ treats dereferencing a pointer to volatile object of complete type as GCC would do for an equivalent type in C. When the object has incomplete type, G++ issues a warning; if you wish to force an error, you must force a conversion to rvalue with, for instance, a static cast.</source>
          <target state="translated">C++標準では、このような式は lvalue から rvalue への変換を行わず、参照元オブジェクトの型が不完全である可能性があることを規定しています。C++標準では、アクセスの原因となるのは lvalue から rvalue への変換であることを明示的に指定していません。そうでないと、特定の単純な式が未定義になってしまうため、それが原因であると考える理由があります。しかし、ほとんどのプログラマーを驚かせることになるので、G++では、完全型の揮発性オブジェクトへのポインタの参照を GCC が C の等価型に対して行うのと同じように扱います。</target>
        </trans-unit>
        <trans-unit id="73a31b9577ac049499e169205951815b4d802407" translate="yes" xml:space="preserve">
          <source>The C++11 and OpenMP standards allow &lt;code&gt;thread_local&lt;/code&gt; and &lt;code&gt;threadprivate&lt;/code&gt; variables to have dynamic (runtime) initialization. To support this, any use of such a variable goes through a wrapper function that performs any necessary initialization. When the use and definition of the variable are in the same translation unit, this overhead can be optimized away, but when the use is in a different translation unit there is significant overhead even if the variable doesn&amp;rsquo;t actually need dynamic initialization. If the programmer can be sure that no use of the variable in a non-defining TU needs to trigger dynamic initialization (either because the variable is statically initialized, or a use of the variable in the defining TU will be executed before any uses in another TU), they can avoid this overhead with the</source>
          <target state="translated">C ++ 11およびOpenMP標準は、 &lt;code&gt;thread_local&lt;/code&gt; およびthreadprivateを許可し &lt;code&gt;threadprivate&lt;/code&gt; 動的（ランタイム）初期化を行う変数。これをサポートするために、そのような変数の使用は、必要な初期化を実行するラッパー関数を通過します。変数の使用と定義が同じ変換単位にある場合、このオーバーヘッドは最適化されますが、使用が別の変換単位にある場合、変数が実際に動的初期化を必要としなくても、かなりのオーバーヘッドがあります。プログラマが、非定義TUでの変数の使用が動的初期化をトリガーする必要がないことを確認できる場合（変数が静的に初期化されているか、または定義TUでの変数の使用が、別の使用で使用される前に実行されます） TU）、彼らはこのオーバーヘッドを回避できます</target>
        </trans-unit>
        <trans-unit id="da8ab7209d2ba607c1022648449bd576dc30ecb4" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this option will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C++17 標準では、より多くの場合でオペランドの評価順序が定義されます。特に、代入の右辺を左辺よりも前に評価することが要求されるため、上記の例はもはや未定義ではありません。しかし、このオプションは、C やそれ以前のリビジョンの C++で未定義のコードを書かないようにするために、これらの例について警告します。</target>
        </trans-unit>
        <trans-unit id="463aa5596934552e20b1c86daa9eff2befcfafd9" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this warning will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C++17 標準では、オペランドの評価順序がより多くの場合に定義されます。特に、代入の右辺を左辺よりも先に評価することが要求されるため、上記の例はもはや未定義ではありません。特に、代入の右辺が左辺よりも前に評価されることが要求されるため、上記の例はもはや未定義ではなくなりましたが、この警告では、C や C++の以前のリビジョンで未定義のコードを書かないようにするために、これらの例について警告します。</target>
        </trans-unit>
        <trans-unit id="3f8518a5ffcdc724e580f436c8e8861c47a79dbf" translate="yes" xml:space="preserve">
          <source>The CC register.</source>
          <target state="translated">CCレジスターです。</target>
        </trans-unit>
        <trans-unit id="aac83138ffc7dedbba141af64e9e3833a7581060" translate="yes" xml:space="preserve">
          <source>The Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">巡回冗長検査(CRC)命令。</target>
        </trans-unit>
        <trans-unit id="26d3b88b25735a58406b058569b742cd7ef6e371" translate="yes" xml:space="preserve">
          <source>The DSP instructions.</source>
          <target state="translated">DSPの命令。</target>
        </trans-unit>
        <trans-unit id="8a394fdb5f659a018583a4b282fa046a537ed960" translate="yes" xml:space="preserve">
          <source>The Darwin tools vary in their behavior when presented with an ISA mismatch. The assembler,</source>
          <target state="translated">Darwinツールは、ISAの不一致が提示されたときの動作が異なります。アセンブラ。</target>
        </trans-unit>
        <trans-unit id="c474ab61fc35bcc3be354a3a5837d9c0d40e8830" translate="yes" xml:space="preserve">
          <source>The GCC port for AArch64 only supports the IEEE 754-2008 format, and does not require use of the</source>
          <target state="translated">AArch64 用の GCC ポートは IEEE 754-2008 フォーマットのみをサポートしており</target>
        </trans-unit>
        <trans-unit id="0079c12261c57d6bab6a15c723b1304a15531596" translate="yes" xml:space="preserve">
          <source>The GNU C compiler supports both dialects; you can specify the signed dialect with</source>
          <target state="translated">GNU Cコンパイラは両方の方言をサポートしています。</target>
        </trans-unit>
        <trans-unit id="9a9482fb99a743f48dbd7859a7e8e12b5401b580" translate="yes" xml:space="preserve">
          <source>The GNU C preprocessor recognizes several pragmas in addition to the compiler pragmas documented here. Refer to the CPP manual for more information.</source>
          <target state="translated">GNU Cプリプロセッサは、ここに文書化されているコンパイラ・プラ グマに加えて、いくつかのプラグマを認識します。詳細はCPPマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="0227d0ba5f10912bdc54f8efb32ad7ab5a1942f8" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a hook, called &lt;code&gt;__objc_msg_forward2&lt;/code&gt;, which is called by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; when it cannot find a method implementation in the runtime tables and after calling &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;+resolveClassMethod:&lt;/code&gt; has been attempted and did not succeed in dynamically registering the method.</source>
          <target state="translated">GNU Objective-Cランタイムは、 &lt;code&gt;__objc_msg_forward2&lt;/code&gt; と呼ばれるフックを提供します。これは、ランタイムテーブルでメソッド実装が見つからず、 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; および &lt;code&gt;+resolveClassMethod:&lt;/code&gt; が呼び出された後、動的に成功しなかったときに &lt;code&gt;objc_msg_lookup()&lt;/code&gt; によって呼び出されます。メソッドの登録。</target>
        </trans-unit>
        <trans-unit id="c32c2c0d5cf1c06ca2fc7f8fc5108f046c90f6d6" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a way that allows you to execute code before the execution of the program enters the &lt;code&gt;main&lt;/code&gt; function. The code is executed on a per-class and a per-category basis, through a special class method &lt;code&gt;+load&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-Cランタイムは、プログラムの実行が &lt;code&gt;main&lt;/code&gt; 関数に入る前にコードを実行できる方法を提供します。コードは、特別なクラスメソッド &lt;code&gt;+load&lt;/code&gt; を介して、クラスごとおよびカテゴリごとに実行されます。</target>
        </trans-unit>
        <trans-unit id="6204b4438d0b4bf08e65cf328298ab3f8520d1f5" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API that allows you to interact with the Objective-C runtime system, querying the live runtime structures and even manipulating them. This allows you for example to inspect and navigate classes, methods and protocols; to define new classes or new methods, and even to modify existing classes or protocols.</source>
          <target state="translated">GNU Objective-C ランタイムは、Objective-C ランタイムシステムとの対話を可能にする API を提供します。これにより、例えば、クラス、メソッド、プロトコルを検査したり、ナビゲートしたり、新しいクラスや新しいメソッドを定義したり、既存のクラスやプロトコルを変更したりすることができます。</target>
        </trans-unit>
        <trans-unit id="4882007657bbd3b9904317ecd7c9122b201adae0" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API which is similar to the one provided by the &amp;ldquo;Objective-C 2.0&amp;rdquo; Apple/NeXT Objective-C runtime. The API is documented in the public header files of the GNU Objective-C runtime:</source>
          <target state="translated">GNU Objective-Cランタイムは、「Objective-C 2.0」Apple / NeXT Objective-Cランタイムによって提供されるものと同様のAPIを提供します。APIは、GNU Objective-Cランタイムのパブリックヘッダーファイルに記載されています。</target>
        </trans-unit>
        <trans-unit id="bda523f70e2cc81aec3a5420312f2dc14631e90d" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime used to provide a different API, which we call the &amp;ldquo;traditional&amp;rdquo; GNU Objective-C runtime API. Functions belonging to this API are easy to recognize because they use a different naming convention, such as &lt;code&gt;class_get_super_class()&lt;/code&gt; (traditional API) instead of &lt;code&gt;class_getSuperclass()&lt;/code&gt; (modern API). Software using this API includes the file</source>
          <target state="translated">「従来の」GNU Objective-CランタイムAPIと呼ばれる別のAPIを提供するために使用されたGNU Objective-Cランタイム。このAPIに属する関数は、 &lt;code&gt;class_getSuperclass()&lt;/code&gt; （最新のAPI）ではなく &lt;code&gt;class_get_super_class()&lt;/code&gt; （従来のAPI）などの異なる命名規則を使用しているため、簡単に認識できます。このAPIを使用するソフトウェアにはファイルが含まれています</target>
        </trans-unit>
        <trans-unit id="a580b32a37e3e1afb84412437056129293c1db6e" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux</source>
          <target state="translated">GNUプロジェクトとGNU/Linux</target>
        </trans-unit>
        <trans-unit id="fbf08e863571f4a8147fed0d98f89d3a6cc1c1c5" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux.</source>
          <target state="translated">GNUプロジェクトとGNU/Linux。</target>
        </trans-unit>
        <trans-unit id="565581be4558eda62440473a382dca36e2293950" translate="yes" xml:space="preserve">
          <source>The GNU compiler can produce two kinds of diagnostics: errors and warnings. Each kind has a different purpose:</source>
          <target state="translated">GNUコンパイラは2種類の診断を生成することができます:エラーと警告です。それぞれの種類には異なる目的があります。</target>
        </trans-unit>
        <trans-unit id="0ef6aa50a29b9e95c494d3259dc5f4a2758d594d" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="translated">GNUコンパイラは、C ++言語にこれらの拡張機能を提供します（C ++プログラムでC言語拡張機能のほとんどを使用することもできます）。これらの機能が利用可能かどうかを確認するコードを記述したい場合は、Cプログラムと同じ方法でGNUコンパイラをテストできます。事前定義されたマクロ &lt;code&gt;__GNUC__&lt;/code&gt; を確認します。 &lt;code&gt;__GNUG__&lt;/code&gt; を使用して、特にGNU C ++をテストすることもできます（GNU Cプリプロセッサの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;事前定義マクロ&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="fdd4d4c02d395886b71e823798e0aedf04f540c0" translate="yes" xml:space="preserve">
          <source>The GNU linker (beginning with version 2.16) has the necessary support for this option. If your linker does not support this option, the header file aspect of</source>
          <target state="translated">GNUリンカ(バージョン2.16以降)はこのオプションを必要に応じてサポートしています。お使いのリンカがこのオプションをサポートしていない場合は</target>
        </trans-unit>
        <trans-unit id="649e8f725ce325928e9d3758e5501f5eb08d8098" translate="yes" xml:space="preserve">
          <source>The HP-UX implementation of setlocale in libc has a dependency on libdld.sl. There isn&amp;rsquo;t an archive version of libdld.sl. Thus, when the</source>
          <target state="translated">libcのsetlocaleのHP-UX実装は、libdld.slに依存しています。libdld.slのアーカイブバージョンはありません。したがって、</target>
        </trans-unit>
        <trans-unit id="e6712fd16e48687aa09a28dcd06ca5cfec22cf46" translate="yes" xml:space="preserve">
          <source>The HTM builtins (with the exception of &lt;code&gt;__builtin_tbegin&lt;/code&gt;) return the full 4-bit condition register value set by their associated hardware instruction. The header file &lt;code&gt;htmintrin.h&lt;/code&gt; defines some macros that can be used to decipher the return value. The &lt;code&gt;__builtin_tbegin&lt;/code&gt; builtin returns a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; value depending on whether a transaction was successfully started or not. The arguments of the builtins match exactly the type and order of the associated hardware instruction&amp;rsquo;s operands, except for the &lt;code&gt;__builtin_tcheck&lt;/code&gt; builtin, which does not take any input arguments. Refer to the ISA manual for a description of each instruction&amp;rsquo;s operands.</source>
          <target state="translated">HTMビルトイン（ &lt;code&gt;__builtin_tbegin&lt;/code&gt; を除く）は、関連するハードウェア命令によって設定された完全な4ビット条件レジスタ値を返します。ヘッダーファイル &lt;code&gt;htmintrin.h&lt;/code&gt; は、戻り値を解読するために使用できるいくつかのマクロを定義します。 &lt;code&gt;__builtin_tbegin&lt;/code&gt; シンプルなリターン組み込み &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 値は、トランザクションが正常に起動されたかどうかに依存します。組み込み関数の引数は、入力引数をとらない &lt;code&gt;__builtin_tcheck&lt;/code&gt; 組み込み関数を除いて、関連するハードウェア命令のオペランドのタイプと順序と正確に一致します。各命令のオペランドの説明については、ISAのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="87dbb117c6f13df65961818e4b7b41562cf362b8" translate="yes" xml:space="preserve">
          <source>The IA-64 back end supports the following variable attribute:</source>
          <target state="translated">IA-64バックエンドは以下の変数属性をサポートしています。</target>
        </trans-unit>
        <trans-unit id="03f6d255f23aeee8dc7ee63e3c04d489d6fd6b28" translate="yes" xml:space="preserve">
          <source>The ISA and hardware multiply supported for the different MCUs is hard-coded into GCC. However, an external &amp;lsquo;</source>
          <target state="translated">さまざまなMCUで複数サポートされているISAとハードウェアは、GCCにハードコードされています。ただし、外部の '</target>
        </trans-unit>
        <trans-unit id="a2f39a7601ef937b791997651319caebaf1d1db8" translate="yes" xml:space="preserve">
          <source>The ISO C standard defines (in clause 4) two classes of conforming implementation. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; supports the whole standard including all the library facilities; a &lt;em&gt;conforming freestanding implementation&lt;/em&gt; is only required to provide certain library facilities: those in &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;; since AMD1, also those in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;; since C99, also those in &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;; and since C11, also those in &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</source>
          <target state="translated">ISO C規格は、（4節で）準拠する実装の2つのクラスを定義しています。&lt;em&gt;準拠したホストされた実装では、&lt;/em&gt;すべてのライブラリ施設を含む全体の標準をサポートしています。&lt;em&gt;準拠した自立型の実装は&lt;/em&gt;唯一の特定のライブラリ機能を提供するために必要とされていますのもの &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 。 AMD1以降、 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 内のものも含まれます。 C99以降、 &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; にも含まれます。 C11以降、 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; の C11以降。さらに、C99で追加された複合型は、独立型実装には必要ありません。</target>
        </trans-unit>
        <trans-unit id="4df8e4ece265376ae0055a7b2b932c764c91156b" translate="yes" xml:space="preserve">
          <source>The ISO C standard leaves it up to the implementation whether a bit-field declared plain &lt;code&gt;int&lt;/code&gt; is signed or not. This in effect creates two alternative dialects of C.</source>
          <target state="translated">ISO C標準では、ビットフィールドで宣言されたplain &lt;code&gt;int&lt;/code&gt; が署名されているかどうかにかかわらず、実装に任されています。これは事実上、Cの2つの代替方言を作成します。</target>
        </trans-unit>
        <trans-unit id="bced80c01ede6829408bc604cd122f3ce07d3569" translate="yes" xml:space="preserve">
          <source>The ISO C++14 library also defines the &amp;lsquo;</source>
          <target state="translated">ISO C ++ 14ライブラリでは、「</target>
        </trans-unit>
        <trans-unit id="de0f27c3596685d686fd3d285d5ba869620aa947" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">ISO C90機能が &lt;code&gt;abort&lt;/code&gt; 、 &lt;code&gt;abs&lt;/code&gt; 、 &lt;code&gt;acos&lt;/code&gt; 、 &lt;code&gt;asin&lt;/code&gt; 、 &lt;code&gt;atan2&lt;/code&gt; 、 &lt;code&gt;atan&lt;/code&gt; 、 &lt;code&gt;calloc&lt;/code&gt; 、 &lt;code&gt;ceil&lt;/code&gt; 、 &lt;code&gt;cosh&lt;/code&gt; 、 &lt;code&gt;cos&lt;/code&gt; 、 &lt;code&gt;exit&lt;/code&gt; 、 &lt;code&gt;exp&lt;/code&gt; 、 &lt;code&gt;fabs&lt;/code&gt; 、 &lt;code&gt;floor&lt;/code&gt; 、 &lt;code&gt;fmod&lt;/code&gt; 、 &lt;code&gt;fprintf&lt;/code&gt; 、 &lt;code&gt;fputs&lt;/code&gt; 、 &lt;code&gt;free&lt;/code&gt; 、 &lt;code&gt;frexp&lt;/code&gt; 、 &lt;code&gt;fscanf&lt;/code&gt; は、 &lt;code&gt;isalnum&lt;/code&gt; 、 &lt;code&gt;isalpha&lt;/code&gt; 、 &lt;code&gt;iscntrl&lt;/code&gt; は、 &lt;code&gt;isdigit&lt;/code&gt; 、 &lt;code&gt;isgraph&lt;/code&gt; 、 &lt;code&gt;islower&lt;/code&gt; は、 &lt;code&gt;isprint&lt;/code&gt; は、 &lt;code&gt;ispunct&lt;/code&gt; 、 &lt;code&gt;isspace&lt;/code&gt; 、 &lt;code&gt;isupper&lt;/code&gt; 、 &lt;code&gt;isxdigit&lt;/code&gt; 、 &lt;code&gt;tolower&lt;/code&gt; 、 &lt;code&gt;toupper&lt;/code&gt; 、 &lt;code&gt;labs&lt;/code&gt; 、 &lt;code&gt;ldexp&lt;/code&gt; 、 &lt;code&gt;log10&lt;/code&gt; 、 &lt;code&gt;log&lt;/code&gt; 、 &lt;code&gt;malloc&lt;/code&gt; 関数、 &lt;code&gt;memchr&lt;/code&gt; 、 &lt;code&gt;memcmp&lt;/code&gt; 、 &lt;code&gt;memcpy&lt;/code&gt; 、 &lt;code&gt;memset&lt;/code&gt; を、 &lt;code&gt;modf&lt;/code&gt; 、 &lt;code&gt;pow&lt;/code&gt; 、 &lt;code&gt;printf&lt;/code&gt; 関数、 &lt;code&gt;putchar&lt;/code&gt; 、 &lt;code&gt;puts&lt;/code&gt; 、 &lt;code&gt;realloc&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 関数、 &lt;code&gt;sinh&lt;/code&gt; 、 &lt;code&gt;sin&lt;/code&gt; 、 &lt;code&gt;snprintf&lt;/code&gt; の、 &lt;code&gt;sprintf&lt;/code&gt; の、 &lt;code&gt;sqrt&lt;/code&gt; 、 &lt;code&gt;sscanf&lt;/code&gt; は、 &lt;code&gt;strcat&lt;/code&gt; 、 &lt;code&gt;strchr&lt;/code&gt; 、 &lt;code&gt;strcmp&lt;/code&gt; 、 &lt;code&gt;strcpy&lt;/code&gt; の、 &lt;code&gt;strcspn&lt;/code&gt; 、 &lt;code&gt;strlen&lt;/code&gt; 、 &lt;code&gt;strncat&lt;/code&gt; 、 &lt;code&gt;strncmp&lt;/code&gt; は、 &lt;code&gt;strncpy&lt;/code&gt; を、 &lt;code&gt;strpbrk&lt;/code&gt; 、 &lt;code&gt;strrchr&lt;/code&gt; 、 &lt;code&gt;strspn&lt;/code&gt; 、 &lt;code&gt;strstr&lt;/code&gt; 、 &lt;code&gt;tanh&lt;/code&gt; 、 &lt;code&gt;tan&lt;/code&gt; 、 &lt;code&gt;vfprintf&lt;/code&gt; 、 &lt;code&gt;vprintf&lt;/code&gt; と &lt;code&gt;vsprintf&lt;/code&gt; のは、すべての組み込みとして認識され関数内でない限り</target>
        </trans-unit>
        <trans-unit id="67ca06952bac1aee629481893fc1242a0df75d20" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">ISO C90機能が &lt;code&gt;abort&lt;/code&gt; 、 &lt;code&gt;abs&lt;/code&gt; 、 &lt;code&gt;acos&lt;/code&gt; 、 &lt;code&gt;asin&lt;/code&gt; 、 &lt;code&gt;atan2&lt;/code&gt; 、 &lt;code&gt;atan&lt;/code&gt; 、 &lt;code&gt;calloc&lt;/code&gt; 、 &lt;code&gt;ceil&lt;/code&gt; 、 &lt;code&gt;cosh&lt;/code&gt; 、 &lt;code&gt;cos&lt;/code&gt; 、 &lt;code&gt;exit&lt;/code&gt; 、 &lt;code&gt;exp&lt;/code&gt; 、 &lt;code&gt;fabs&lt;/code&gt; 、 &lt;code&gt;floor&lt;/code&gt; 、 &lt;code&gt;fmod&lt;/code&gt; 、 &lt;code&gt;fprintf&lt;/code&gt; 、 &lt;code&gt;fputs&lt;/code&gt; 、 &lt;code&gt;frexp&lt;/code&gt; 、 &lt;code&gt;fscanf&lt;/code&gt; は、 &lt;code&gt;isalnum&lt;/code&gt; 、 &lt;code&gt;isalpha&lt;/code&gt; 、 &lt;code&gt;iscntrl&lt;/code&gt; は、 &lt;code&gt;isdigit&lt;/code&gt; 、 &lt;code&gt;isgraph&lt;/code&gt; 、 &lt;code&gt;islower&lt;/code&gt; 、 &lt;code&gt;isprint&lt;/code&gt; は、 &lt;code&gt;ispunct&lt;/code&gt; 、 &lt;code&gt;isspace&lt;/code&gt; 、 &lt;code&gt;isupper&lt;/code&gt; 、 &lt;code&gt;isxdigit&lt;/code&gt; 、 &lt;code&gt;tolower&lt;/code&gt; 、 &lt;code&gt;toupper&lt;/code&gt; 、 &lt;code&gt;labs&lt;/code&gt; 、 &lt;code&gt;ldexp&lt;/code&gt; 、 &lt;code&gt;log10&lt;/code&gt; の、 &lt;code&gt;log&lt;/code&gt; 、 &lt;code&gt;malloc&lt;/code&gt; 関数、 &lt;code&gt;memchr&lt;/code&gt; 、 &lt;code&gt;memcmp&lt;/code&gt; 、 &lt;code&gt;memcpy&lt;/code&gt; を、 &lt;code&gt;memset&lt;/code&gt; と、 &lt;code&gt;modf&lt;/code&gt; 、 &lt;code&gt;pow&lt;/code&gt; 、 &lt;code&gt;printf&lt;/code&gt; 関数、 &lt;code&gt;putchar&lt;/code&gt; 、 &lt;code&gt;puts&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 関数、 &lt;code&gt;sinh&lt;/code&gt; 、 &lt;code&gt;sin&lt;/code&gt; 、 &lt;code&gt;snprintf&lt;/code&gt; 、 &lt;code&gt;sprintf&lt;/code&gt; の、 &lt;code&gt;sqrt&lt;/code&gt; 、 &lt;code&gt;sscanf&lt;/code&gt; は、 &lt;code&gt;strcat&lt;/code&gt; は、 &lt;code&gt;strchr&lt;/code&gt; 、 &lt;code&gt;strcmp&lt;/code&gt; の、 &lt;code&gt;strcpy&lt;/code&gt; の、 &lt;code&gt;strcspn&lt;/code&gt; 、 &lt;code&gt;strlen&lt;/code&gt; を、 &lt;code&gt;strncat&lt;/code&gt; 、 &lt;code&gt;strncmp&lt;/code&gt; は、 &lt;code&gt;strncpy&lt;/code&gt; を、 &lt;code&gt;strpbrk&lt;/code&gt; 、 &lt;code&gt;strrchr&lt;/code&gt; 、 &lt;code&gt;strspn&lt;/code&gt; 、 &lt;code&gt;strstr&lt;/code&gt; 、 &lt;code&gt;tanh&lt;/code&gt; 、 &lt;code&gt;tan&lt;/code&gt; 、 &lt;code&gt;vfprintf&lt;/code&gt; 、 &lt;code&gt;vprintf&lt;/code&gt; と &lt;code&gt;vsprintf&lt;/code&gt; のは、組み込みのような機能のすべて認識されない限り、</target>
        </trans-unit>
        <trans-unit id="ae47f0c159fa493b3beadffa3ea4146c32c1e50a" translate="yes" xml:space="preserve">
          <source>The ISO C94 functions &lt;code&gt;iswalnum&lt;/code&gt;, &lt;code&gt;iswalpha&lt;/code&gt;, &lt;code&gt;iswcntrl&lt;/code&gt;, &lt;code&gt;iswdigit&lt;/code&gt;, &lt;code&gt;iswgraph&lt;/code&gt;, &lt;code&gt;iswlower&lt;/code&gt;, &lt;code&gt;iswprint&lt;/code&gt;, &lt;code&gt;iswpunct&lt;/code&gt;, &lt;code&gt;iswspace&lt;/code&gt;, &lt;code&gt;iswupper&lt;/code&gt;, &lt;code&gt;iswxdigit&lt;/code&gt;, &lt;code&gt;towlower&lt;/code&gt; and &lt;code&gt;towupper&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">ISO C94関数 &lt;code&gt;iswalnum&lt;/code&gt; 、 &lt;code&gt;iswalpha&lt;/code&gt; 、 &lt;code&gt;iswcntrl&lt;/code&gt; 、 &lt;code&gt;iswdigit&lt;/code&gt; 、 &lt;code&gt;iswgraph&lt;/code&gt; 、 &lt;code&gt;iswlower&lt;/code&gt; 、 &lt;code&gt;iswprint&lt;/code&gt; 、 &lt;code&gt;iswpunct&lt;/code&gt; 、 &lt;code&gt;iswspace&lt;/code&gt; 、 &lt;code&gt;iswupper&lt;/code&gt; 、 &lt;code&gt;iswxdigit&lt;/code&gt; 、 &lt;code&gt;towlower&lt;/code&gt; 、 &lt;code&gt;towupper&lt;/code&gt; は、厳密なISO C90モード以外では組み込み関数として処理されます（</target>
        </trans-unit>
        <trans-unit id="6cca21d213324c7eb2448728bd34ae61f7e19024" translate="yes" xml:space="preserve">
          <source>The ISO C99 functions &lt;code&gt;_Exit&lt;/code&gt;, &lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt;, &lt;code&gt;carg&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt;, &lt;code&gt;cbrtf&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;copysignf&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt;, &lt;code&gt;cproj&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt;, &lt;code&gt;erfcf&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;erff&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;exp2f&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;expm1f&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;fdimf&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt;, &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fmal&lt;/code&gt;, &lt;code&gt;fmaxf&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, &lt;code&gt;fminf&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt;, &lt;code&gt;hypotf&lt;/code&gt;, &lt;code&gt;hypotl&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;ilogbf&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;imaxabs&lt;/code&gt;, &lt;code&gt;isblank&lt;/code&gt;, &lt;code&gt;iswblank&lt;/code&gt;, &lt;code&gt;lgammaf&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;, &lt;code&gt;llabs&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt;, &lt;code&gt;log1pf&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;log2f&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logbf&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;nearbyintf&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;nextafterf&lt;/code&gt;, &lt;code&gt;nextafterl&lt;/code&gt;, &lt;code&gt;nextafter&lt;/code&gt;, &lt;code&gt;nexttowardf&lt;/code&gt;, &lt;code&gt;nexttowardl&lt;/code&gt;, &lt;code&gt;nexttoward&lt;/code&gt;, &lt;code&gt;remainderf&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;remquof&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt;, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;scalblnf&lt;/code&gt;, &lt;code&gt;scalblnl&lt;/code&gt;, &lt;code&gt;scalbln&lt;/code&gt;, &lt;code&gt;scalbnf&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;tgammaf&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;truncf&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;vfscanf&lt;/code&gt;, &lt;code&gt;vscanf&lt;/code&gt;, &lt;code&gt;vsnprintf&lt;/code&gt; and &lt;code&gt;vsscanf&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">ISO C99関数 &lt;code&gt;_Exit&lt;/code&gt; 、 &lt;code&gt;acoshf&lt;/code&gt; 、 &lt;code&gt;acoshl&lt;/code&gt; 、 &lt;code&gt;acosh&lt;/code&gt; 、 &lt;code&gt;asinhf&lt;/code&gt; 、 &lt;code&gt;asinhl&lt;/code&gt; 、 &lt;code&gt;asinh&lt;/code&gt; 、 &lt;code&gt;atanhf&lt;/code&gt; 、 &lt;code&gt;atanhl&lt;/code&gt; 、 &lt;code&gt;atanh&lt;/code&gt; 、 &lt;code&gt;cabsf&lt;/code&gt; 、 &lt;code&gt;cabsl&lt;/code&gt; 、 &lt;code&gt;cabs&lt;/code&gt; 、 &lt;code&gt;cacosf&lt;/code&gt; 、 &lt;code&gt;cacoshf&lt;/code&gt; 、 &lt;code&gt;cacoshl&lt;/code&gt; 、 &lt;code&gt;cacosh&lt;/code&gt; 、 &lt;code&gt;cacosl&lt;/code&gt; 、 &lt;code&gt;cacos&lt;/code&gt; 、 &lt;code&gt;cargf&lt;/code&gt; 、 &lt;code&gt;cargl&lt;/code&gt; 、 &lt;code&gt;carg&lt;/code&gt; 、 &lt;code&gt;casinf&lt;/code&gt; 、ca、car、ca、 &lt;code&gt;casinhf&lt;/code&gt; 、 &lt;code&gt;casinhl&lt;/code&gt; 、 &lt;code&gt;casinh&lt;/code&gt; 、 &lt;code&gt;casinl&lt;/code&gt; 、 &lt;code&gt;casin&lt;/code&gt; 、 &lt;code&gt;catanf&lt;/code&gt; 、 &lt;code&gt;catanhf&lt;/code&gt; 、 &lt;code&gt;catanhl&lt;/code&gt; 、 &lt;code&gt;catanh&lt;/code&gt; 、 &lt;code&gt;catanl&lt;/code&gt; 、 &lt;code&gt;catan&lt;/code&gt; 、 &lt;code&gt;cbrtf&lt;/code&gt; 、 &lt;code&gt;cbrtl&lt;/code&gt; 、 &lt;code&gt;cbrt&lt;/code&gt; 、 &lt;code&gt;ccosf&lt;/code&gt; 、 &lt;code&gt;ccoshf&lt;/code&gt; 、 &lt;code&gt;ccoshl&lt;/code&gt; 、 &lt;code&gt;ccosh&lt;/code&gt; 、 &lt;code&gt;ccosl&lt;/code&gt; 、 &lt;code&gt;ccos&lt;/code&gt; 、 &lt;code&gt;cexpf&lt;/code&gt; 、 &lt;code&gt;cexpl&lt;/code&gt; 、 &lt;code&gt;cexp&lt;/code&gt; 、 &lt;code&gt;cimagf&lt;/code&gt; 、 &lt;code&gt;cimagl&lt;/code&gt; 、 &lt;code&gt;cimag&lt;/code&gt; 、 &lt;code&gt;clogf&lt;/code&gt; 、 &lt;code&gt;clogl&lt;/code&gt; 、 &lt;code&gt;clog&lt;/code&gt; 、 &lt;code&gt;conjf&lt;/code&gt; 、 &lt;code&gt;conjl&lt;/code&gt; 、 &lt;code&gt;conj&lt;/code&gt; 、 &lt;code&gt;copysignf&lt;/code&gt; 、 &lt;code&gt;copysignl&lt;/code&gt; 、 &lt;code&gt;copysign&lt;/code&gt; 、 &lt;code&gt;cpowf&lt;/code&gt; 、 &lt;code&gt;cpowl&lt;/code&gt; 、 &lt;code&gt;cpow&lt;/code&gt; 、 &lt;code&gt;cprojf&lt;/code&gt; 、 &lt;code&gt;cprojl&lt;/code&gt; 、 &lt;code&gt;cproj&lt;/code&gt; 、 &lt;code&gt;crealf&lt;/code&gt; 、 &lt;code&gt;creall&lt;/code&gt; 、 &lt;code&gt;creal&lt;/code&gt; 、 &lt;code&gt;csinf&lt;/code&gt; 、 &lt;code&gt;csinhf&lt;/code&gt; 、 &lt;code&gt;csinhl&lt;/code&gt; 、 &lt;code&gt;csinh&lt;/code&gt; 、 &lt;code&gt;csinl&lt;/code&gt; 、 &lt;code&gt;csin&lt;/code&gt; 、 &lt;code&gt;csqrtf&lt;/code&gt; 、 &lt;code&gt;csqrtl&lt;/code&gt; 、 &lt;code&gt;csqrt&lt;/code&gt; 、 &lt;code&gt;ctanf&lt;/code&gt; 、 &lt;code&gt;ctanhf&lt;/code&gt; 、 &lt;code&gt;ctanhl&lt;/code&gt; 、 &lt;code&gt;ctanh&lt;/code&gt; 、 &lt;code&gt;ctanl&lt;/code&gt; 、 &lt;code&gt;ctan&lt;/code&gt; 、 &lt;code&gt;erfcf&lt;/code&gt; 、 &lt;code&gt;erfcl&lt;/code&gt; 、 &lt;code&gt;erfc&lt;/code&gt; 、 &lt;code&gt;erff&lt;/code&gt; 、 &lt;code&gt;erfl&lt;/code&gt; 、 &lt;code&gt;erf&lt;/code&gt; 、 &lt;code&gt;exp2f&lt;/code&gt; 、 &lt;code&gt;exp2l&lt;/code&gt; 、 &lt;code&gt;exp2&lt;/code&gt; 、 &lt;code&gt;expm1f&lt;/code&gt; 、 &lt;code&gt;expm1l&lt;/code&gt; 、 &lt;code&gt;expm1&lt;/code&gt; 、 &lt;code&gt;fdimf&lt;/code&gt; 、 &lt;code&gt;fdiml&lt;/code&gt; 、 &lt;code&gt;fdim&lt;/code&gt; 、 &lt;code&gt;fmaf&lt;/code&gt; 、 &lt;code&gt;fmal&lt;/code&gt; 、 &lt;code&gt;fmaxf&lt;/code&gt; 、 &lt;code&gt;fmaxl&lt;/code&gt; 、 &lt;code&gt;fmax&lt;/code&gt; 、 &lt;code&gt;fma&lt;/code&gt; 、 &lt;code&gt;fminf&lt;/code&gt; 、 &lt;code&gt;fminl&lt;/code&gt; 、 &lt;code&gt;fmin&lt;/code&gt; 、 &lt;code&gt;hypotf&lt;/code&gt; 、 &lt;code&gt;hypotl&lt;/code&gt; 、 &lt;code&gt;hypot&lt;/code&gt; 、 &lt;code&gt;ilogbf&lt;/code&gt; 、 &lt;code&gt;ilogbl&lt;/code&gt; 、 &lt;code&gt;ilogb&lt;/code&gt; 、 &lt;code&gt;imaxabs&lt;/code&gt; 、 &lt;code&gt;isblank&lt;/code&gt; 、 &lt;code&gt;iswblank&lt;/code&gt; 、 &lt;code&gt;lgammaf&lt;/code&gt; 、 &lt;code&gt;lgammal&lt;/code&gt; 、 &lt;code&gt;lgamma&lt;/code&gt; 、 &lt;code&gt;llabs&lt;/code&gt; 、 &lt;code&gt;llrintf&lt;/code&gt; 、 &lt;code&gt;llrintl&lt;/code&gt; 、 &lt;code&gt;llrint&lt;/code&gt; 、 &lt;code&gt;llroundf&lt;/code&gt; 、 &lt;code&gt;llroundl&lt;/code&gt; 、 &lt;code&gt;llround&lt;/code&gt; 、 &lt;code&gt;log1pf&lt;/code&gt; 、 &lt;code&gt;log1pl&lt;/code&gt; 、 &lt;code&gt;log1p&lt;/code&gt; 、 &lt;code&gt;log2f&lt;/code&gt; 、 &lt;code&gt;log2l&lt;/code&gt; 、 &lt;code&gt;log2&lt;/code&gt; 、 &lt;code&gt;logbf&lt;/code&gt; 、 &lt;code&gt;logbl&lt;/code&gt; 、 &lt;code&gt;logb&lt;/code&gt; 、 &lt;code&gt;lrintf&lt;/code&gt; 、 &lt;code&gt;lrintl&lt;/code&gt; 、 &lt;code&gt;lrint&lt;/code&gt; 、 &lt;code&gt;lroundf&lt;/code&gt; 、 &lt;code&gt;lroundl&lt;/code&gt; 、 &lt;code&gt;lround&lt;/code&gt; 、 &lt;code&gt;nearbyintf&lt;/code&gt; 、 &lt;code&gt;nearbyintl&lt;/code&gt; 、 &lt;code&gt;nearbyint&lt;/code&gt; 、 &lt;code&gt;nextafterf&lt;/code&gt; 、 &lt;code&gt;nextafterl&lt;/code&gt; 、 &lt;code&gt;nextafter&lt;/code&gt; 、 &lt;code&gt;nexttowardf&lt;/code&gt; 、 &lt;code&gt;nexttowardl&lt;/code&gt; 、 &lt;code&gt;nexttoward&lt;/code&gt; 、 &lt;code&gt;remainderf&lt;/code&gt; 、 &lt;code&gt;remainderl&lt;/code&gt; 、 &lt;code&gt;remainder&lt;/code&gt; 、 &lt;code&gt;remquof&lt;/code&gt; 、 &lt;code&gt;remquol&lt;/code&gt; 、 &lt;code&gt;remquo&lt;/code&gt; 、 &lt;code&gt;rintf&lt;/code&gt; 、 &lt;code&gt;rintl&lt;/code&gt; 、 &lt;code&gt;rint&lt;/code&gt; 、 &lt;code&gt;roundf&lt;/code&gt; 、 &lt;code&gt;roundl&lt;/code&gt; 、 &lt;code&gt;round&lt;/code&gt; 、 &lt;code&gt;scalblnf&lt;/code&gt; 、 &lt;code&gt;scalblnl&lt;/code&gt; 、 &lt;code&gt;scalbln&lt;/code&gt; 、 &lt;code&gt;scalbnf&lt;/code&gt; 、 &lt;code&gt;scalbnl&lt;/code&gt; 、 &lt;code&gt;scalbn&lt;/code&gt; 、 &lt;code&gt;snprintf&lt;/code&gt; の、 &lt;code&gt;tgammaf&lt;/code&gt; 、 &lt;code&gt;tgammal&lt;/code&gt; 、 &lt;code&gt;tgamma&lt;/code&gt; 、 &lt;code&gt;truncf&lt;/code&gt; 、 &lt;code&gt;truncl&lt;/code&gt; 、 &lt;code&gt;trunc&lt;/code&gt; 、 &lt;code&gt;vfscanf&lt;/code&gt; 、 &lt;code&gt;vscanf&lt;/code&gt; 、 &lt;code&gt;vsnprintf&lt;/code&gt; 、 &lt;code&gt;vsscanf&lt;/code&gt; は、厳密なISO C90モード（</target>
        </trans-unit>
        <trans-unit id="2784e50b776c95c529ea8bb486ce2750890944bf" translate="yes" xml:space="preserve">
          <source>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about.</source>
          <target state="translated">整数定数のISO型は、従来の型とは異なる幅または符号付きである。この警告は、定数の基底値が10の場合にのみ発行されます。つまり、一般的にビットパターンを表す16進数や8進数の値は警告されません。</target>
        </trans-unit>
        <trans-unit id="82a12be836835137fbdc59e2c7d2766dbca00a8c" translate="yes" xml:space="preserve">
          <source>The JSON is emitted as one line, without formatting; the examples below have been formatted for clarity.</source>
          <target state="translated">JSONはフォーマットなしで1行で出力されます。</target>
        </trans-unit>
        <trans-unit id="a08b3636d7c444216df0829b96c5cf7186a63397" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer and single precision floating-point instructions.</source>
          <target state="translated">M-Profile Vector Extension (MVE)の整数および単精度浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="121628a4764ae0bea2f22e038677fd81cecafe48" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer instructions.</source>
          <target state="translated">M-Profile Vector Extension (MVE)の整数命令。</target>
        </trans-unit>
        <trans-unit id="4a22ef3a7780246abe5b933d687f802ceaac7fd9" translate="yes" xml:space="preserve">
          <source>The MIPS DSP Application-Specific Extension (ASE) includes new instructions that are designed to improve the performance of DSP and media applications. It provides instructions that operate on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.</source>
          <target state="translated">MIPS DSP Application-Specific Extension (ASE)には、DSP およびメディア アプリケーションのパフォーマンスを向上させるように設計された新しい命令が含まれています。これは、パックされた8ビット/16ビット整数データ、Q7、Q15、およびQ31の小数データで動作する命令を提供します。</target>
        </trans-unit>
        <trans-unit id="f5ed4155655f597ba1ea8fb1a082975a691dee38" translate="yes" xml:space="preserve">
          <source>The MIPS-3D Application-Specific Extension (ASE) includes additional paired-single instructions that are designed to improve the performance of 3D graphics operations. Support for these instructions is controlled by the</source>
          <target state="translated">MIPS-3D Application-Specific Extension (ASE)には、3D グラフィックス処理のパフォーマンスを向上させるように設計された、追加のペア・シングル命令が含まれています。これらの命令のサポートは</target>
        </trans-unit>
        <trans-unit id="2568887586875d72638add2c316850a652079522" translate="yes" xml:space="preserve">
          <source>The MIPS64 architecture includes a number of instructions that operate on pairs of single-precision floating-point values. Each pair is packed into a 64-bit floating-point register, with one element being designated the &amp;ldquo;upper half&amp;rdquo; and the other being designated the &amp;ldquo;lower half&amp;rdquo;.</source>
          <target state="translated">MIPS64アーキテクチャには、単精度浮動小数点値のペアを操作する多くの命令が含まれています。各ペアは64ビット浮動小数点レジスタにパックされ、1つの要素が「上半分」と指定され、もう1つの要素が「下半分」と指定されます。</target>
        </trans-unit>
        <trans-unit id="19791c6fc0c7878cc7c0d81440fdc8b3deac6cc4" translate="yes" xml:space="preserve">
          <source>The MSP430 hardware ensures that interrupts are disabled on entry to &lt;code&gt;interrupt&lt;/code&gt; functions, and restores the previous interrupt state on exit. The &lt;code&gt;critical&lt;/code&gt; attribute is therefore redundant on &lt;code&gt;interrupt&lt;/code&gt; functions.</source>
          <target state="translated">MSP430のハードウェア性を保証割り込みがへのエントリで無効にされていることを &lt;code&gt;interrupt&lt;/code&gt; 機能、および終了時に、前の割り込みの状態を復元します。 &lt;code&gt;critical&lt;/code&gt; 属性は、そのために冗長である &lt;code&gt;interrupt&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="324add0fab22223316ad270b660243d491e201b4" translate="yes" xml:space="preserve">
          <source>The MeP target has a number of addressing modes and busses. The &lt;code&gt;near&lt;/code&gt; space spans the standard memory space&amp;rsquo;s first 16 megabytes (24 bits). The &lt;code&gt;far&lt;/code&gt; space spans the entire 32-bit memory space. The &lt;code&gt;based&lt;/code&gt; space is a 128-byte region in the memory space that is addressed relative to the &lt;code&gt;$tp&lt;/code&gt; register. The &lt;code&gt;tiny&lt;/code&gt; space is a 65536-byte region relative to the &lt;code&gt;$gp&lt;/code&gt; register. In addition to these memory regions, the MeP target has a separate 16-bit control bus which is specified with &lt;code&gt;cb&lt;/code&gt; attributes.</source>
          <target state="translated">MePターゲットには、いくつかのアドレッシングモードとバスがあります。 &lt;code&gt;near&lt;/code&gt; 空間は、標準的なメモリ空間の最初の16メガバイト（24ビット）に及びます。 &lt;code&gt;far&lt;/code&gt; のスペースは、全体の32ビットのメモリ空間をまたがります。 &lt;code&gt;based&lt;/code&gt; スペースがに対するアドレス指定されたメモリ空間の128バイトの領域であり、 &lt;code&gt;$tp&lt;/code&gt; 登録します。 &lt;code&gt;tiny&lt;/code&gt; スペースがに対する65536バイトの領域であり、 &lt;code&gt;$gp&lt;/code&gt; 登録します。これらのメモリ領域に加えて、MePターゲットには、 &lt;code&gt;cb&lt;/code&gt; 属性で指定される個別の16ビット制御バスがあります。</target>
        </trans-unit>
        <trans-unit id="5d8a7015c96baf068daea7c993c23e530f568f5f" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</source>
          <target state="translated">組み込みシステム用のミディアム/どこでもコードモデル。64 ビット・アドレスは、テキスト・セグメントとデータ・セグメントのサイズが 2GB 未満である必要があり、両方ともメモリ内の任意の場所で開始します (リンク時に決定されます)。グローバル・レジスタ %g4 は、データ・セグメントのベースを指します。プログラムは静的にリンクされており、PIC はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="cc31a18cddf7a0f78efe693458fe2d9afe6d7019" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">ミディアム/どこでもコードモデル。64ビットアドレス、プログラムはメモリ内の任意の場所にリンクすることができ、テキストセグメントとデータセグメントのサイズは2GB未満で、データセグメントはテキストセグメントの2GB以内に配置されている必要があります。</target>
        </trans-unit>
        <trans-unit id="7e3c5ad40e25357a2525dfa3cd571c1d3bd7d34a" translate="yes" xml:space="preserve">
          <source>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.</source>
          <target state="translated">ミディアム/ローコードモデル。64ビットアドレス、プログラムはメモリの下位32ビットでリンクする必要があります。プログラムは静的または動的にリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="3b39ba546b4adedbbf99b1b31d01ec7fac76520a" translate="yes" xml:space="preserve">
          <source>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">ミディアム/ミドルコードモデルです。64ビットのアドレス、プログラムは44ビットの下位メモリでリンクされていなければならず、テキストとデータセグメントは2GB以下のサイズでなければならず、データセグメントはテキストセグメントの2GB以内に配置されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="da2b29936b818cfc1e5a3a58f7738a9fa0c881c1" translate="yes" xml:space="preserve">
          <source>The Microsoft structure layout algorithm is fairly simple with the exception of the bit-field packing. The padding and alignment of members of structures and whether a bit-field can straddle a storage-unit boundary are determine by these rules:</source>
          <target state="translated">マイクロソフトの構造体レイアウトアルゴリズムは、ビットフィールドのパッキングを除いてはかなり単純です。構造体のメンバのパディングとアラインメント、およびビットフィールドがストレージユニットの境界をまたぐことができるかどうかは、これらのルールによって決定されます。</target>
        </trans-unit>
        <trans-unit id="aeff520b5677f801f6da4eeb7f1e51a9a569cd01" translate="yes" xml:space="preserve">
          <source>The NOP instructions are inserted at&amp;mdash;and maybe before, depending on &lt;var&gt;M&lt;/var&gt;&amp;mdash;the function entry address, even before the prologue.</source>
          <target state="translated">NOP命令は、プロローグの前であっても、関数の入り口アドレスに（場合によっては &lt;var&gt;M&lt;/var&gt; によって）挿入されます。</target>
        </trans-unit>
        <trans-unit id="ff55b141ae724be4a1c090f09197c4cc8d0b49e5" translate="yes" xml:space="preserve">
          <source>The Objective-C 2.0 language extensions and features are automatically enabled; they include properties (via the &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic keywords&lt;/code&gt;), fast enumeration (not available in Objective-C++), attributes for methods (such as &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;), the &lt;code&gt;unused&lt;/code&gt; attribute for method arguments, the &lt;code&gt;@package&lt;/code&gt; keyword for instance variables and the &lt;code&gt;@optional&lt;/code&gt; and &lt;code&gt;@required&lt;/code&gt; keywords in protocols. You can disable all these Objective-C 2.0 language extensions with the option</source>
          <target state="translated">Objective-C 2.0言語の拡張機能は自動的に有効になります。これらには、プロパティ（ &lt;code&gt;@property&lt;/code&gt; 、 &lt;code&gt;@synthesize&lt;/code&gt; および &lt;code&gt;@dynamic keywords&lt;/code&gt; ）、高速列挙（Objective-C ++では使用できません）、メソッドの属性（ &lt;code&gt;deprecated&lt;/code&gt; 、 &lt;code&gt;noreturn&lt;/code&gt; 、 &lt;code&gt;sentinel&lt;/code&gt; 、 &lt;code&gt;format&lt;/code&gt; など）、メソッド引数の &lt;code&gt;unused&lt;/code&gt; 属性が含まれます。 &lt;code&gt;@package&lt;/code&gt; のインスタンス変数とのキーワード &lt;code&gt;@optional&lt;/code&gt; と &lt;code&gt;@required&lt;/code&gt; プロトコルのキーワード。オプションでこれらのObjective-C 2.0言語拡張機能をすべて無効にできます</target>
        </trans-unit>
        <trans-unit id="c6923a9108193e35102064afa9eda743cb37bdd9" translate="yes" xml:space="preserve">
          <source>The Objective-C compiler generates type encodings for all the types. These type encodings are used at runtime to find out information about selectors and methods and about objects and classes.</source>
          <target state="translated">Objective-C コンパイラは、すべての型に対して型エンコーディングを生成します。これらの型エンコーディングは、実行時にセレクタやメソッド、オブジェクトやクラスに関する情報を見つけるために使用されます。</target>
        </trans-unit>
        <trans-unit id="e464bd6510d0d75994dbae5961cb9df5baed7b28" translate="yes" xml:space="preserve">
          <source>The Objective-C exception and synchronization syntax (that is, the keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;) is supported by GCC and is enabled with the option</source>
          <target state="translated">Objective-Cの例外と同期の構文（キーワードは、ある &lt;code&gt;@try&lt;/code&gt; 、 &lt;code&gt;@throw&lt;/code&gt; 、 &lt;code&gt;@catch&lt;/code&gt; 、 &lt;code&gt;@finally&lt;/code&gt; と &lt;code&gt;@synchronized&lt;/code&gt; は）GCCによってサポートされており、オプションで有効になっています</target>
        </trans-unit>
        <trans-unit id="504b920d3ddaa29eaf4f4d2837867a09bb928c21" translate="yes" xml:space="preserve">
          <source>The One Definition Rule is relaxed for types without explicit visibility specifications that are defined in more than one shared object: those declarations are permitted if they are permitted when this option is not used.</source>
          <target state="translated">1つの定義ルールは、複数の共有オブジェクトで定義されている明示的な可視性の指定がない型に対して緩和されています:このオプションが使用されていない場合、それらの宣言が許可されている場合は許可されます。</target>
        </trans-unit>
        <trans-unit id="2d22810fdfaa073bc94d2050ac8533154c085f11" translate="yes" xml:space="preserve">
          <source>The RL78 back end supports the &lt;code&gt;saddr&lt;/code&gt; variable attribute. This specifies placement of the corresponding variable in the SADDR area, which can be accessed more efficiently than the default memory region.</source>
          <target state="translated">RL78バックエンドは、 &lt;code&gt;saddr&lt;/code&gt; 変数属性をサポートしています。これにより、対応する変数のSADDR領域への配置が指定されます。これは、デフォルトのメモリ領域よりも効率的にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1c75a1f23dddf5a55d85a877757468d10500aab3" translate="yes" xml:space="preserve">
          <source>The RS/6000 and PowerPC targets define one pragma for controlling whether or not the &lt;code&gt;longcall&lt;/code&gt; attribute is added to function declarations by default. This pragma overrides the</source>
          <target state="translated">RS / 6000およびPowerPCターゲットは、 &lt;code&gt;longcall&lt;/code&gt; 属性が関数宣言に追加されるかどうかを制御するための1つのプラグマを定義します。このプラグマは、</target>
        </trans-unit>
        <trans-unit id="549fc0bcd99c9fa57f4b149326299d99007e47ae" translate="yes" xml:space="preserve">
          <source>The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler does not delete these instructions and it does not delete calls to functions containing these instructions.</source>
          <target state="translated">ビッ トはグローバルです。WRDSP、EXTPDP、EXTPDPV、およびMTHLIP 命令は、SCOUNT および POS ビッ トを変更します。最適化中、コンパイラはこれらの命令を削除せず、これらの命令を含む関数の呼び出しも削除しません。</target>
        </trans-unit>
        <trans-unit id="feed8b7325d666bcdf4c1efd5aa692caea9e4e2d" translate="yes" xml:space="preserve">
          <source>The SPU supports the &lt;code&gt;spu_vector&lt;/code&gt; attribute for variables. For documentation of this attribute please see the documentation in &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes&lt;/a&gt;.</source>
          <target state="translated">SPUは変数の &lt;code&gt;spu_vector&lt;/code&gt; 属性をサポートします。この属性のドキュメントについては、&lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPUタイプ属性の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e00194fefd3abe9f6e9c4ed0e24c5f1cdb3e71d6" translate="yes" xml:space="preserve">
          <source>The Solaris target supports &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (see &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;). It also supports additional &lt;code&gt;#pragma&lt;/code&gt; directives for compatibility with the system compiler.</source>
          <target state="translated">Solarisターゲットは &lt;code&gt;#pragma redefine_extname&lt;/code&gt; をサポートしています（&lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;シンボル名の変更プラグマを&lt;/a&gt;参照）。また、システムコンパイラとの互換性のために追加の &lt;code&gt;#pragma&lt;/code&gt; ディレクティブをサポートしています。</target>
        </trans-unit>
        <trans-unit id="b577e7bfa4d5d277a90aa967bc9fa309870fa29b" translate="yes" xml:space="preserve">
          <source>The V850 back end supports these function attributes:</source>
          <target state="translated">V850 バックエンドでは、これらの機能属性をサポートしています。</target>
        </trans-unit>
        <trans-unit id="87ba99adc7a79652db01be899ada60245b8a9d21" translate="yes" xml:space="preserve">
          <source>The VFPv2 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">VFPv2浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="259f6621f353addf35de203c6cc21ec70166871f" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">16個の倍精度レジスタを持つVFPv3浮動小数点命令と、半精度浮動小数点変換演算を行います。</target>
        </trans-unit>
        <trans-unit id="69bbc2d35ac5910370025649743d2c9e7aba8bec" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers. The extension +vfpv3-d16 can be used as an alias for this extension.</source>
          <target state="translated">16個の倍精度レジスタを持つVFPv3浮動小数点命令です。拡張子 +vfpv3-d16 は、この拡張子のエイリアスとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="7d392f4c1ad45a7ce6a0755dbe2047b64e45ba0e" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">VFPv3の浮動小数点命令で、16個の倍精度レジスタと半精度浮動小数点変換演算を行います。</target>
        </trans-unit>
        <trans-unit id="9ea0bf30af6241dd74e66058037f24ca2aa3b024" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">16個の倍精度レジスタを持つVFPv3浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="8c44d40609c70bac64a3214e9aba6ea5f2799b31" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">16の倍精度レジスタを備えたVFPv3浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="69ba42177cf602fb7a0ed600eac827a8de6a449b" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">VFPv3の浮動小数点命令で、32個の倍精度レジスタと半精度浮動小数点変換演算を行います。</target>
        </trans-unit>
        <trans-unit id="193d13643a69320727d206517bd62145a8c8f03c" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">VFPv3の浮動小数点命令で、32個の倍精度レジスタを備えています。</target>
        </trans-unit>
        <trans-unit id="a0936e97cd9c57c2c85efdbe6388f42baca5f03d" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">16個の倍精度レジスタを持つVFPv4浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="103d1acc3dfe417798e6bd838ba4fc9709451552" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">16の倍精度レジスタを備えたVFPv4浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="06ddcf864547f4dbeda808689e788fca6e819171" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">VFPv4の浮動小数点命令で、32個の倍精度レジスタを備えています。</target>
        </trans-unit>
        <trans-unit id="9285ccf7646c59c98d31930bdd84e56c45d5fd26" translate="yes" xml:space="preserve">
          <source>The VR4130 pipeline is two-way superscalar, but can only issue two instructions together if the first one is 8-byte aligned. When this option is enabled, GCC aligns pairs of instructions that it thinks should execute in parallel.</source>
          <target state="translated">パ イ プ ラ イ ンは双方向スーパースケーラですが、 最初の命令が8 バ イ ト ア ラ イ ン グの場合にのみ2 つの命令を同時に発行で き ます。このオプションを有効にすると、GCC は並列実行すべきと考える命令のペアをアラインメントします。</target>
        </trans-unit>
        <trans-unit id="cb154aff394215a4189b3dafa08992907beaeea3" translate="yes" xml:space="preserve">
          <source>The VSX instruction set (</source>
          <target state="translated">VSX 命令セット (</target>
        </trans-unit>
        <trans-unit id="5a0171ba1b31d3315fbbfaace918d589c6b61613" translate="yes" xml:space="preserve">
          <source>The abbreviation &lt;em&gt;GCC&lt;/em&gt; has multiple meanings in common use. The current official meaning is &amp;ldquo;GNU Compiler Collection&amp;rdquo;, which refers generically to the complete suite of tools. The name historically stood for &amp;ldquo;GNU C Compiler&amp;rdquo;, and this usage is still common when the emphasis is on compiling C programs. Finally, the name is also used when speaking of the &lt;em&gt;language-independent&lt;/em&gt; component of GCC: code shared among the compilers for all supported languages.</source>
          <target state="translated">略語&lt;em&gt;GCCに&lt;/em&gt;は、一般的に使用される複数の意味があります。現在の公式の意味は「GNU Compiler Collection」であり、総称して完全なツールスイートを指します。その名前は歴史的に「GNU Cコンパイラ」を意味し、Cプログラムのコンパイルに重点が置かれている場合でも、この使用法は一般的です。最後に、この名前は、GCCの&lt;em&gt;言語に依存しない&lt;/em&gt;コンポーネント（すべてのサポートされている言語のコンパイラ間で共有されるコード）を話すときにも使用されます。</target>
        </trans-unit>
        <trans-unit id="3a9d23d169ba3b72eeef6725cec43a13a50013c2" translate="yes" xml:space="preserve">
          <source>The above generates bytecode for</source>
          <target state="translated">のバイトコードを生成します。</target>
        </trans-unit>
        <trans-unit id="34a36dd9deec63b753f5d433c0dd87cbce7edcf4" translate="yes" xml:space="preserve">
          <source>The above lines are equivalent to the following:</source>
          <target state="translated">上記の行は、以下に相当します。</target>
        </trans-unit>
        <trans-unit id="a39976e643ac6d1dc6fe3e4366ed3a13dea2466b" translate="yes" xml:space="preserve">
          <source>The above target attributes can be specified as follows:</source>
          <target state="translated">上記の対象属性は、以下のように指定することができます。</target>
        </trans-unit>
        <trans-unit id="ed1f637f7dae694f5c4cfc72955bdf63e2cee6a2" translate="yes" xml:space="preserve">
          <source>The accuracy is unknown.</source>
          <target state="translated">精度は不明です。</target>
        </trans-unit>
        <trans-unit id="120b6f184277986efda6f906c93a195e4dc7e853" translate="yes" xml:space="preserve">
          <source>The accuracy of the floating-point operations and of the library functions in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; that return floating-point results (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">浮動小数点演算と、浮動小数点の結果を返す &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; のライブラリ関数の精度（C90、C99およびC11 5.2.4.2.2）。</target>
        </trans-unit>
        <trans-unit id="80f0b076d52d6244bc6636b163e80827a773f50c" translate="yes" xml:space="preserve">
          <source>The actual register chosen to hold the constant data base address depends upon whether the</source>
          <target state="translated">定数データベースアドレスを保持するために選択される実際のレジスタは</target>
        </trans-unit>
        <trans-unit id="a30a65f7051569a9a9c6241a0c50efdd3d1de863" translate="yes" xml:space="preserve">
          <source>The added &lt;var&gt;flag&lt;/var&gt; argument is passed unchanged to &lt;code&gt;__sprintf_chk&lt;/code&gt; etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling &lt;code&gt;%n&lt;/code&gt; differently.</source>
          <target state="translated">追加された &lt;var&gt;flag&lt;/var&gt; 引数は、 &lt;code&gt;__sprintf_chk&lt;/code&gt; などの関数に変更されずに渡され、 &lt;code&gt;%n&lt;/code&gt; の処理方法など、チェック関数が取る可能性のある追加のセキュリティ対策に関する実装固有のフラグを含めることができます。</target>
        </trans-unit>
        <trans-unit id="8e6f66f554f454fd60e4196cbe8c25320dedb4b7" translate="yes" xml:space="preserve">
          <source>The added comments include:</source>
          <target state="translated">追加されたコメントには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5c6f1012ead9ec76811fd2e9243c4b72f326472d" translate="yes" xml:space="preserve">
          <source>The additional block information is of the form</source>
          <target state="translated">追加のブロック情報は</target>
        </trans-unit>
        <trans-unit id="79eafbe5ef62b1bf562656c8ccc8660f517c4542" translate="yes" xml:space="preserve">
          <source>The address as returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; may have to be fed through this function to get the actual encoded address. For example, on the 31-bit S/390 platform the highest bit has to be masked out, or on SPARC platforms an offset has to be added for the true next instruction to be executed.</source>
          <target state="translated">&lt;code&gt;__builtin_return_address&lt;/code&gt; によって返されるアドレスは、実際にエンコードされたアドレスを取得するために、この関数を介して提供される必要がある場合があります。たとえば、31ビットのS / 390プラットフォームでは、最上位ビットをマスクする必要があります。SPARCプラットフォームでは、真の次の命令を実行するためにオフセットを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="9133fefd38b502d139962641eb1473acc29ca6ef" translate="yes" xml:space="preserve">
          <source>The addressability of a particular object can be set with the &lt;code&gt;model&lt;/code&gt; attribute.</source>
          <target state="translated">特定のオブジェクトのアドレス可能度は、 &lt;code&gt;model&lt;/code&gt; 属性で設定できます。</target>
        </trans-unit>
        <trans-unit id="8b38ea0caa823f37a2f086f0d1bc57b4b47d283c" translate="yes" xml:space="preserve">
          <source>The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">構造体の非ビットフィールドメンバのアラインメント(C90 6.5.2.1、C99及びC11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="322481284c6908feb9887b9dd7bb912960123985" translate="yes" xml:space="preserve">
          <source>The alternate keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__extension__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; continue to work despite</source>
          <target state="translated">別のキーワード &lt;code&gt;__asm__&lt;/code&gt; 、 &lt;code&gt;__extension__&lt;/code&gt; 、 &lt;code&gt;__inline__&lt;/code&gt; および &lt;code&gt;__typeof__&lt;/code&gt; にもかかわらず仕事を続けます</target>
        </trans-unit>
        <trans-unit id="8e728c9fa7b9e6ce4962fad39896909da2bde1ee" translate="yes" xml:space="preserve">
          <source>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, where one can do more than simply store label addresses in label variables.</source>
          <target state="translated">Fortran の類似の機能は代入された goto と呼ばれていますが、ラベル変数に単にラベルアドレスを格納するだけでなく、それ以上のことができる C では、この名前は適切ではないように思えます。</target>
        </trans-unit>
        <trans-unit id="14c11777761d5f46c1a9fb516ac0c2ee4a9cb68d" translate="yes" xml:space="preserve">
          <source>The application binary interface implemented by a C or C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">C または C++コンパイラによって実装されたアプリケーション バイナリ インターフェイスは、コードの生成とランタイム サポートに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="29b549ce42574a44cc4510011757b7ba9fd1935c" translate="yes" xml:space="preserve">
          <source>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.</source>
          <target state="translated">グローバル共通副式除去最適化を実行するために割り当てられるメモリのおおよその最大量。指定した以上のメモリが必要な場合は、最適化は行われません。</target>
        </trans-unit>
        <trans-unit id="01165ed876927994264f7a9cab383ccc4af10540" translate="yes" xml:space="preserve">
          <source>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</source>
          <target state="translated">引数には任意の長さの文字列のリストを指定できます。文字列は出力時にソートされるので、リストの順番は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="59d49582cbfaa16c6712e0f374a5a6c15a857459" translate="yes" xml:space="preserve">
          <source>The argument to</source>
          <target state="translated">への議論</target>
        </trans-unit>
        <trans-unit id="d44a319a963da0f3902d413f244d251258e282dd" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are interpreted as function pointers, and how many as the arguments to the called function.</source>
          <target state="translated">&lt;code&gt;__builtin_tgmath&lt;/code&gt; への引数は、関数への少なくとも2つのポインターであり、その後に型選択マクロへの引数が続きます（選択された関数への引数として渡されます）。関数へのすべてのポインターは、プロトタイプ関数へのポインターである必要があり、それらのいずれも可変引数を持つことはできず、すべて同じ数のパラメーターを持つ必要があります。最初の関数のパラメーターの数は、 &lt;code&gt;__builtin_tgmath&lt;/code&gt; への引数が関数ポインターとして解釈される数、および呼び出された関数への引数の数を決定します。</target>
        </trans-unit>
        <trans-unit id="966ac956bf197ec8f0ba6771423c919858f24a7d" translate="yes" xml:space="preserve">
          <source>The arguments to the built-in functions can be divided into three groups: register numbers, compile-time constants and run-time values. In order to make this classification clear at a glance, the arguments and return values are given the following pseudo types:</source>
          <target state="translated">組込み関数の引数は、レジスタ番号、コンパイル時定数、ランタイム値の3つのグループに分けることができます。この分類が一目でわかるように、引数と戻り値には次のような擬似型が与えられています。</target>
        </trans-unit>
        <trans-unit id="c829863ade5431c1682f5d64360267aae12a2fb8" translate="yes" xml:space="preserve">
          <source>The attribute can also be applied to an inline namespace, but does not affect the mangled name of the namespace; in this case it is only used for</source>
          <target state="translated">この属性はインラインの名前空間にも適用することができますが、名前空間のマングルされた名前には影響しません。</target>
        </trans-unit>
        <trans-unit id="ed02eb26a29f10b556adacd30701241deccd245e" translate="yes" xml:space="preserve">
          <source>The attribute cannot be used to decrease the alignment of a function previously declared with a more restrictive alignment; only to increase it. Attempts to do otherwise are diagnosed. Some targets specify a minimum default alignment for functions that is greater than 1. On such targets, specifying a less restrictive alignment is silently ignored. Using the attribute overrides the effect of the</source>
          <target state="translated">この属性は、以前により制限的なアライメントで宣言された関数のアライメントを減少させるために使用することはできず、増加させるためだけに使用されます。それ以外の方法を試みようとすると、診断されます。ターゲットによっては、関数のデフォルトの最小アラインメントを1よりも大きく指定しているものがあります。 そのようなターゲットでは、制限の少ないアラインメントを指定しても、静かに無視されます。この属性を使用すると</target>
        </trans-unit>
        <trans-unit id="ae26e49e643c3950ed6f72c5632f4fffd355af07" translate="yes" xml:space="preserve">
          <source>The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link-time optimization. For this reason the attribute is not allowed on types to annotate indirect calls.</source>
          <target state="translated">この属性は、現在のコンパイルユニット内で定義されている関数には影響を与えません。これは、例えばリンク時間の最適化を使用して、複数のコンパイル・ユニットを簡単に1つにマージできるようにするためです。この理由から、間接的な呼び出しをアノテーションする型に対しては、この属性は許可されていません。</target>
        </trans-unit>
        <trans-unit id="87e6916763209960cf7a9bdaddf003a5218d3bef" translate="yes" xml:space="preserve">
          <source>The attribute is automatically set with a position of 0 for the built-in functions &lt;code&gt;execl&lt;/code&gt; and &lt;code&gt;execlp&lt;/code&gt;. The built-in function &lt;code&gt;execle&lt;/code&gt; has the attribute set with a position of 1.</source>
          <target state="translated">この属性は、組み込み関数 &lt;code&gt;execl&lt;/code&gt; および &lt;code&gt;execlp&lt;/code&gt; の位置が0に自動的に設定されます。組み込み関数 &lt;code&gt;execle&lt;/code&gt; には、位置が1に設定された属性があります。</target>
        </trans-unit>
        <trans-unit id="fe2a754094a48aee11cc854617f21a28a6c915b2" translate="yes" xml:space="preserve">
          <source>The attribute is ignored for undefined symbols.</source>
          <target state="translated">この属性は未定義のシンボルに対しては無視されます。</target>
        </trans-unit>
        <trans-unit id="c20b877bf7007b2fcc50da9d21f8618882a3644d" translate="yes" xml:space="preserve">
          <source>The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit cannot be used or modified by the leaf function. For example, the &lt;code&gt;sin&lt;/code&gt; function is a leaf function, but &lt;code&gt;qsort&lt;/code&gt; is not.</source>
          <target state="translated">この属性は、データフロー分析を改善するライブラリ関数を対象としています。コンパイラーは、現在のコンパイル単位をエスケープしていないデータは、リーフ関数で使用または変更できないというヒントを受け取ります。たとえば、 &lt;code&gt;sin&lt;/code&gt; 関数はリーフ関数ですが、 &lt;code&gt;qsort&lt;/code&gt; はそうではありません。</target>
        </trans-unit>
        <trans-unit id="cdb101c8aa868b197540d1e1e07e514397c2827e" translate="yes" xml:space="preserve">
          <source>The attribute parameters configure what values are passed into the kernel function by the GPU drivers, via the initial register state. Some values are used by the compiler, and therefore forced on. Enabling other options may break assumptions in the compiler and/or run-time libraries.</source>
          <target state="translated">属性パラメータは、初期レジスタの状態を介して GPU ドライバがカーネル関数に渡す値を設定します。いくつかの値はコンパイラによって使用されるため、強制的に有効になります。他のオプションを有効にすると、コンパイラやランタイムライブラリの前提条件が崩れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f37e3b5bceea5d68174fbdb23337f013d5dc061b" translate="yes" xml:space="preserve">
          <source>The attributes work in conjunction with a linker script that has been augmented to specify where to place sections with a &lt;code&gt;.lower&lt;/code&gt; and a &lt;code&gt;.upper&lt;/code&gt; prefix. So, for example, as well as placing the &lt;code&gt;.data&lt;/code&gt; section, the script also specifies the placement of a &lt;code&gt;.lower.data&lt;/code&gt; and a &lt;code&gt;.upper.data&lt;/code&gt; section. The intention is that &lt;code&gt;lower&lt;/code&gt; sections are placed into a small but easier to access memory region and the upper sections are placed into a larger, but slower to access, region.</source>
          <target state="translated">属性は、 &lt;code&gt;.lower&lt;/code&gt; および &lt;code&gt;.upper&lt;/code&gt; プレフィックスを持つセクションを配置する場所を指定するように拡張されたリンカースクリプトと連携して機能します。したがって、たとえば、 &lt;code&gt;.data&lt;/code&gt; セクションを配置するだけでなく、スクリプトは &lt;code&gt;.lower.data&lt;/code&gt; および &lt;code&gt;.upper.data&lt;/code&gt; セクションの配置も指定します。意図は、 &lt;code&gt;lower&lt;/code&gt; セクションは小さいがアクセスが容易なメモリ領域に配置され、上のセクションは大きいがアクセスが遅い領域に配置されることです。</target>
        </trans-unit>
        <trans-unit id="10feff4fc0898bcb9645a7662553ea298f34abd3" translate="yes" xml:space="preserve">
          <source>The authoritative manual on Objective-C 2.0 is available from Apple:</source>
          <target state="translated">Objective-C 2.0の権威あるマニュアルはAppleから入手可能です。</target>
        </trans-unit>
        <trans-unit id="f6ef9f24ededd45d5c51229d5801270991d5579a" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.05 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">このセクションで説明する基本的な組み込み機能は、ISA 2.05 以降の PowerPC ファミリのプロセッサで利用できます。コマンドラインで特定のオプションが明示的に無効化されていない限り、オプション</target>
        </trans-unit>
        <trans-unit id="edbf04361cb171c9ec574af51f9f9931b1811352" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.07 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">このセクションで説明する基本的な組み込み機能は、ISA 2.07 以降の PowerPC ファミリのプロセッサで利用できます。コマンドラインで特定のオプションが明示的に無効化されていない限り、オプション</target>
        </trans-unit>
        <trans-unit id="70f8648696a80bbf371453c7d66873b6ed3c1e9f" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 3.0 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">このセクションで説明する基本的な組み込み機能は、ISA 3.0 以降の PowerPC ファミリのプロセッサで利用できます。コマンドラインで特定のオプションが明示的に無効化されていない限り、オプション</target>
        </trans-unit>
        <trans-unit id="b5753c392332963f289e128617ea50b9de09b52f" translate="yes" xml:space="preserve">
          <source>The behavior of most of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">これらの点のほとんどの動作はCライブラリの実装に依存しており、GCC自体では定義されていません。</target>
        </trans-unit>
        <trans-unit id="12799856c643d4a305ab2b4319a6be1f011a91bc" translate="yes" xml:space="preserve">
          <source>The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">これらの点の動作はCライブラリの実装に依存しており、GCC自体では定義されていません。</target>
        </trans-unit>
        <trans-unit id="98ca99f07d3faae58eb40bce10f1e4e864f854e3" translate="yes" xml:space="preserve">
          <source>The behavior of this switch is not quite the same as marking the methods as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one shared object.</source>
          <target state="translated">このスイッチの動作は、関数のローカルな静的変数に影響を与えたり、コンパイラが関数が 1 つの共有オブジェクトでのみ定義されていると推論したりすることがないため、メソッドを直接 hidden としてマークするのとは異なります。</target>
        </trans-unit>
        <trans-unit id="7d6b7cdf4a6f4c034253043f3e78682296fde54a" translate="yes" xml:space="preserve">
          <source>The behavior on each recognized non-&lt;code&gt;STDC #pragma&lt;/code&gt; directive (C90 6.8.6, C99 and C11 6.10.6).</source>
          <target state="translated">認識された各非 &lt;code&gt;STDC #pragma&lt;/code&gt; ディレクティブの動作（C90 6.8.6、C99およびC11 6.10.6）。</target>
        </trans-unit>
        <trans-unit id="78838b89d1e6169626813ca34b5663bfb106ff9a" translate="yes" xml:space="preserve">
          <source>The best solution to such a problem is to put the text into an actual C comment delimited by &amp;lsquo;</source>
          <target state="translated">このような問題に対する最善の解決策は、テキストを 'で区切られた実際のCコメントに入れることです。</target>
        </trans-unit>
        <trans-unit id="cbc968ad31a477faa2208668bddbf016d38a55ba" translate="yes" xml:space="preserve">
          <source>The built-in compare types&amp;ndash;eq, ne, gtu, ltu, geu, and leu.</source>
          <target state="translated">組み込みの比較タイプ&amp;ndash; eq、ne、gtu、ltu、geu、およびleu。</target>
        </trans-unit>
        <trans-unit id="ce0a88d34ad669c64ab3760c61374b2e37e4cc3c" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_complex&lt;/code&gt; is provided for use in implementing the ISO C11 macros &lt;code&gt;CMPLXF&lt;/code&gt;, &lt;code&gt;CMPLX&lt;/code&gt; and &lt;code&gt;CMPLXL&lt;/code&gt;. &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt; must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt;. Unlike &amp;lsquo;</source>
          <target state="translated">組み込み関数 &lt;code&gt;__builtin_complex&lt;/code&gt; は、ISO C11マクロ &lt;code&gt;CMPLXF&lt;/code&gt; 、 &lt;code&gt;CMPLX&lt;/code&gt; 、および &lt;code&gt;CMPLXL&lt;/code&gt; の実装に使用するために提供されています。 &lt;var&gt;real&lt;/var&gt; と &lt;var&gt;imag&lt;/var&gt; は同じ型、実数の2進浮動小数点型でなければならず、結果には実数部と虚数部が &lt;var&gt;real&lt;/var&gt; と &lt;var&gt;imag&lt;/var&gt; の対応する複素数型があります。とは異なり</target>
        </trans-unit>
        <trans-unit id="4172235cf37ce3bd8136a03cb1f1f52ca1bd1d30" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_tgmath&lt;/code&gt;, available only for C and Objective-C, calls a function determined according to the rules of &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros than implementations using other GNU C language features. For example, the &lt;code&gt;pow&lt;/code&gt; type-generic macro might be defined as:</source>
          <target state="translated">組み込み関数 &lt;code&gt;__builtin_tgmath&lt;/code&gt; は、CおよびObjective-Cでのみ使用でき、 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; マクロの規則に従って決定された関数を呼び出します。これは、そのヘッダーの実装で使用することを目的としているため、そのヘッダーからのマクロの展開は各引数を1回だけ展開し、そのようなマクロへの呼び出しがそのようなマクロの他の呼び出しの引数内にネストされている場合の問題を回避します。さらに、他のGNU C言語機能を使用する実装よりも、 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; マクロへの無効な呼び出しの診断が向上します。たとえば、 &lt;code&gt;pow&lt;/code&gt; タイプの汎用マクロは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="a4ab6bdc7a525221a10db36f04ba0ea776ca5cba" translate="yes" xml:space="preserve">
          <source>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function:</source>
          <target state="translated">組み込み関数は、変数が安全に使用されているように見える場合に使用することができますが、CPUは投機的な実行のために、一時的に境界線チェックを無視することがあります。例えば、次のような関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a003f5f8fd45a849966ac7beaa6dcf85e370f177" translate="yes" xml:space="preserve">
          <source>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of &lt;code&gt;untrusted_value&lt;/code&gt; if that exceeds the limit.</source>
          <target state="translated">組み込み関数は、条件付きブランチが完全に解決されるまで実行を停止させるか、投機的実行を続行できるようにしますが、制限を超える場合は &lt;code&gt;untrusted_value&lt;/code&gt; の代わりに0を使用します。</target>
        </trans-unit>
        <trans-unit id="23fbf2c81175bf34ed4b14a9d7849c7a6ed67337" translate="yes" xml:space="preserve">
          <source>The built-in functions are optimized into the normal string functions like &lt;code&gt;memcpy&lt;/code&gt; if the last argument is &lt;code&gt;(size_t) -1&lt;/code&gt; or if it is known at compile time that the destination object will not be overflowed. If the compiler can determine at compile time that the object will always be overflowed, it issues a warning.</source>
          <target state="translated">組み込み関数は、最後の引数が &lt;code&gt;(size_t) -1&lt;/code&gt; 場合、またはコンパイル時に宛先オブジェクトがオーバーフローしないことがわかっている場合、 &lt;code&gt;memcpy&lt;/code&gt; などの通常の文字列関数に最適化されます。コンパイラは、オブジェクトが常にオーバーフローすることをコンパイル時に決定できる場合、警告を発行します。</target>
        </trans-unit>
        <trans-unit id="97b0909bb726639d57f4621d69b4f030cedbb5e2" translate="yes" xml:space="preserve">
          <source>The built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type of the third argument. If the cast result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. The value of the third argument is ignored, just the side effects in the third argument are evaluated, and no integral argument promotions are performed on the last argument. If the third argument is a bit-field, the type used for the result cast has the precision and signedness of the given bit-field, rather than precision and signedness of the underlying type.</source>
          <target state="translated">組み込み関数は、最初の2つのオペランドを無限精度の符号付き型にプロモートし、プロモートされたオペランドに対して加算を実行します。結果は、3番目の引数の型にキャストされます。キャスト結果が無限精度の結果と等しい場合、組み込み関数は &lt;code&gt;false&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;true&lt;/code&gt; を返します。 3番目の引数の値は無視され、3番目の引数の副作用のみが評価され、最後の引数に対して整数引数の昇格は実行されません。 3番目の引数がビットフィールドの場合、結果のキャストに使用される型は、基になる型の精度と符号ではなく、指定されたビットフィールドの精度と符号を持ちます。</target>
        </trans-unit>
        <trans-unit id="b3bbc4c3c1cb9c4fe70210b2dfdbc17fe5153882" translate="yes" xml:space="preserve">
          <source>The built-in functions supported are:</source>
          <target state="translated">サポートされている内蔵機能は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="334b3175e81dee6f1e168a0be44f3b7d957b1be7" translate="yes" xml:space="preserve">
          <source>The built-in macros&amp;rsquo; names follow the scheme &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; where &lt;var&gt;Device&lt;/var&gt; is the device name as from the AVR user manual. The difference between &lt;var&gt;Device&lt;/var&gt; in the built-in macro and &lt;var&gt;device&lt;/var&gt; in</source>
          <target state="translated">組み込みマクロの名前は、スキーム &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; 従います。 &lt;var&gt;Device&lt;/var&gt; は、AVRユーザーマニュアルのデバイス名です。差 &lt;var&gt;Device&lt;/var&gt; 組み込みマクロで &lt;var&gt;device&lt;/var&gt; に</target>
        </trans-unit>
        <trans-unit id="62f099d3393656bddb7d8b0dd222e5a223f8d688" translate="yes" xml:space="preserve">
          <source>The built-in versions of these functions use GCC&amp;rsquo;s normal mechanisms to save and restore registers using the stack on function entry and exit. The jump buffer argument &lt;var&gt;buf&lt;/var&gt; holds only the information needed to restore the stack frame, rather than the entire set of saved register values.</source>
          <target state="translated">これらの関数の組み込みバージョンは、GCCの通常のメカニズムを使用して、関数の入り口と出口でスタックを使用してレジスタを保存および復元します。ジャンプバッファ引数 &lt;var&gt;buf&lt;/var&gt; は、保存されたレジスタ値のセット全体ではなく、スタックフレームの復元に必要な情報のみを保持します。</target>
        </trans-unit>
        <trans-unit id="4488c1d75b7b81f78b64d60c26fdf9ed24d8f3bf" translate="yes" xml:space="preserve">
          <source>The call-clobbered integer registers.</source>
          <target state="translated">コールクロバリングされた整数レジスタ。</target>
        </trans-unit>
        <trans-unit id="0b277cbf75c7f621fb1dabe16f1a3a2fa8a7f4cc" translate="yes" xml:space="preserve">
          <source>The caller copies function arguments passed by hidden reference. This option should be used with care as it is not compatible with the default 32-bit runtime. However, only aggregates larger than eight bytes are passed by hidden reference and the option provides better compatibility with OpenMP.</source>
          <target state="translated">呼び出し元は、隠された参照によって渡された関数引数をコピーします。このオプションはデフォルトの32ビットランタイムとの互換性がないため、注意して使用する必要があります。しかし、8バイトよりも大きな集合体のみが hidden reference で渡され、このオプションは OpenMP との互換性を高めています。</target>
        </trans-unit>
        <trans-unit id="b583bb229dda327522feb6b40a364f4908fd1bf3" translate="yes" xml:space="preserve">
          <source>The carry register.</source>
          <target state="translated">キャリーレジスターです。</target>
        </trans-unit>
        <trans-unit id="c7287b1af6a41a31db6c4fc8adca45c0df1d456b" translate="yes" xml:space="preserve">
          <source>The change to the types of UTF-8 string and character literals introduces incompatibilities with ISO C++11 and later standards. For example, the following code is well-formed under ISO C++11, but is ill-formed when</source>
          <target state="translated">UTF-8 文字列および文字リテラルの型の変更により、ISO C++11 以降の規格との非互換性が導入されました。たとえば、次のコードは ISO C++11 の下では良好な形式になっていますが、以下のように</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">キャラクター '</target>
        </trans-unit>
        <trans-unit id="519631b15cf0936ab9bd0c60033ca6acf8715c58" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are the same as for</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; の選択は、</target>
        </trans-unit>
        <trans-unit id="682ea402eec35d575ae857912b781a6cde1e0d53" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are:</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; の選択肢は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8623d02fccd10cdf135414efb4d8dedf3d5298b1" translate="yes" xml:space="preserve">
          <source>The code above would iterate over all objects in &lt;code&gt;array&lt;/code&gt;. For each of them, it assigns it to &lt;code&gt;object&lt;/code&gt;, then executes the &lt;code&gt;Do something with 'object'&lt;/code&gt; statements.</source>
          <target state="translated">上記のコードは、 &lt;code&gt;array&lt;/code&gt; 内のすべてのオブジェクトを反復処理します。それらのそれぞれについて、それを &lt;code&gt;object&lt;/code&gt; に割り当て、次に &lt;code&gt;Do something with 'object'&lt;/code&gt; ステートメントで何かを実行します。</target>
        </trans-unit>
        <trans-unit id="990cbdb236536d3c2c7b3b4ad41a30dc08b70c1d" translate="yes" xml:space="preserve">
          <source>The colors are defined by the environment variable &lt;code&gt;GCC_COLORS&lt;/code&gt;. Its value is a colon-separated list of capabilities and Select Graphic Rendition (SGR) substrings. SGR commands are interpreted by the terminal or terminal emulator. (See the section in the documentation of your text terminal for permitted values and their meanings as character attributes.) These substring values are integers in decimal representation and can be concatenated with semicolons. Common values to concatenate include &amp;lsquo;</source>
          <target state="translated">色は、環境変数 &lt;code&gt;GCC_COLORS&lt;/code&gt; によって定義されます。その値は、コロンで区切られた機能のリストとSelect Graphic Rendition（SGR）サブストリングです。SGRコマンドは、端末または端末エミュレーターによって解釈されます。（許可される値と文字属性としての意味については、テキスト端末のドキュメントのセクションを参照してください。）これらの部分文字列値は、10進表記の整数であり、セミコロンで連結できます。連結する一般的な値は次のとおりです '</target>
        </trans-unit>
        <trans-unit id="34aa8249352c8e598246fe5c42924ea343806e93" translate="yes" xml:space="preserve">
          <source>The comment needs to be followed after optional whitespace and other comments by &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; keywords or by a user label that precedes some &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label.</source>
          <target state="translated">コメントの後には、オプションの空白や他のコメントの後に、 &lt;code&gt;case&lt;/code&gt; や &lt;code&gt;default&lt;/code&gt; キーワード、または &lt;code&gt;case&lt;/code&gt; や &lt;code&gt;default&lt;/code&gt; ラベルの前にあるユーザーラベルが続く必要があります。</target>
        </trans-unit>
        <trans-unit id="f4f1f40d78278988845f6e6d5dd1df865371c25c" translate="yes" xml:space="preserve">
          <source>The comments are intended for humans rather than machines and hence the precise format of the comments is subject to change.</source>
          <target state="translated">コメントは機械ではなく人間を対象としているため、コメントの正確な形式は変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="92f39136333428ef92d0ab34cd6ec4175f20f2a6" translate="yes" xml:space="preserve">
          <source>The common src/dest memory addressing modes.</source>
          <target state="translated">共通の src/dest メモリアドレッシングモード。</target>
        </trans-unit>
        <trans-unit id="23d24a28b1d2dd308a7ff9954bb96ae5aaa048ba" translate="yes" xml:space="preserve">
          <source>The common subset of the ARMv7-A, ARMv7-R and ARMv7-M architectures.</source>
          <target state="translated">ARMv7-A、ARMv7-R、ARMv7-Mアーキテクチャの共通サブセット。</target>
        </trans-unit>
        <trans-unit id="17c10738c483ffe85f7448f4cbfe545afae5514b" translate="yes" xml:space="preserve">
          <source>The compiler assumes that &lt;code&gt;EIND&lt;/code&gt; never changes during the startup code or during the application. In particular, &lt;code&gt;EIND&lt;/code&gt; is not saved/restored in function or interrupt service routine prologue/epilogue.</source>
          <target state="translated">コンパイラーは、起動コード中またはアプリケーション中に &lt;code&gt;EIND&lt;/code&gt; が変更されることはないと想定しています。特に、 &lt;code&gt;EIND&lt;/code&gt; は、関数または割り込みサービスルーチンのプロローグ/エピローグで保存/復元されません。</target>
        </trans-unit>
        <trans-unit id="8983abbfe719941604e388ad4f86efe2a35d89a4" translate="yes" xml:space="preserve">
          <source>The compiler automatically sets the alignment for the declared variable or field to &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way. Note that the value of &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; may change depending on command-line options.</source>
          <target state="translated">コンパイラは、宣言された変数またはフィールドの配置を &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; に自動的に設定します。これにより、コンパイラーは、この方法で整列した変数またはフィールドとの間でコピーを実行するときに、メモリの最大のチャンクをコピーする命令を使用できるため、コピー操作がより効率的になります。 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; の値は、コマンドラインオプションによって異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9e7e2956c5fa63410dcde9892cdb317e8b9bdabe" translate="yes" xml:space="preserve">
          <source>The compiler can accept several base standards, such as &amp;lsquo;</source>
          <target state="translated">コンパイラは、 'などのいくつかの基本標準を受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="ae77b7d999c147c822471a0c6078013beaa6bc78" translate="yes" xml:space="preserve">
          <source>The compiler checks to see if the path provided by</source>
          <target state="translated">コンパイラは</target>
        </trans-unit>
        <trans-unit id="e75bc3167776cc7681a2a3309af02b07eee5f4ff" translate="yes" xml:space="preserve">
          <source>The compiler contains estimates of the number of clock cycles for &amp;ldquo;typical&amp;rdquo; EV4 &amp;amp; EV5 hardware for the Level 1, 2 &amp;amp; 3 caches (also called Dcache, Scache, and Bcache), as well as to main memory. Note that L3 is only valid for EV5.</source>
          <target state="translated">コンパイラーには、レベル1、2、3のキャッシュ（Dcache、Scache、Bcacheとも呼ばれます）とメインメモリーの「典型的な」EV4＆EV5ハードウェアのクロックサイクル数の見積もりが含まれています。L3はEV5に対してのみ有効であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8338416b67f14201602d466304368b7f468175f5" translate="yes" xml:space="preserve">
          <source>The compiler copies the assembler instructions in a basic &lt;code&gt;asm&lt;/code&gt; verbatim to the assembly language output file, without processing dialects or any of the &amp;lsquo;</source>
          <target state="translated">コンパイラーは、基本的な &lt;code&gt;asm&lt;/code&gt; のアセンブラー命令をそのまま、アセンブリ言語の出力ファイルにコピーします。方言や '</target>
        </trans-unit>
        <trans-unit id="d28532eae1da814b4665d28f7dd4fbb9e0aec8b2" translate="yes" xml:space="preserve">
          <source>The compiler driver program runs one or more of the subprograms &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. It tries &lt;var&gt;prefix&lt;/var&gt; as a prefix for each program it tries to run, both with and without &amp;lsquo;</source>
          <target state="translated">コンパイラドライバプログラムは、サブプログラムのの一つ以上走る &lt;code&gt;cpp&lt;/code&gt; 、 &lt;code&gt;cc1&lt;/code&gt; 、 &lt;code&gt;as&lt;/code&gt; と &lt;code&gt;ld&lt;/code&gt; 。それはしようとする &lt;var&gt;prefix&lt;/var&gt; 'でとなしの両方、それが実行しようと、各プログラムのプレフィックスとして</target>
        </trans-unit>
        <trans-unit id="9b9b15ff6acdc5c85d5777579b9105147bc703cb" translate="yes" xml:space="preserve">
          <source>The compiler emits such &lt;code&gt;gs&lt;/code&gt; modifiers for code labels in the following situations:</source>
          <target state="translated">コンパイラーは、次の状況でコードラベルに対してこのような &lt;code&gt;gs&lt;/code&gt; 修飾子を発行します。</target>
        </trans-unit>
        <trans-unit id="1aa76bdb9ae1bbf7aa774ff7d0e6d298e86f04a3" translate="yes" xml:space="preserve">
          <source>The compiler generates special code to access the variable &lt;code&gt;i&lt;/code&gt;. It may use runtime library support, or generate special machine instructions to access that address space.</source>
          <target state="translated">コンパイラーは、変数 &lt;code&gt;i&lt;/code&gt; にアクセスするための特別なコードを生成します。ランタイムライブラリサポートを使用するか、特別なマシン命令を生成してそのアドレススペースにアクセスします。</target>
        </trans-unit>
        <trans-unit id="6d157d680a0dc51afbbd2163137f4b54277c4701" translate="yes" xml:space="preserve">
          <source>The compiler is configured to be used together with AVR-Libc. See the</source>
          <target state="translated">コンパイラはAVR-Libcと一緒に使用するように設定されています。を参照してください。</target>
        </trans-unit>
        <trans-unit id="fdab34c680d8fa9373eabc63f94733d605cf2016" translate="yes" xml:space="preserve">
          <source>The compiler may generate calls to &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;. These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified.</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;memcmp&lt;/code&gt; 、 &lt;code&gt;memset&lt;/code&gt; 、 &lt;code&gt;memcpy&lt;/code&gt; 、および &lt;code&gt;memmove&lt;/code&gt; の呼び出しを生成する場合があります。これらのエントリは通常、libcのエントリによって解決されます。このオプションが指定されている場合、これらのエントリポイントは他のメカニズムを介して提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="197f6accb1b57a2d3b7bbd9dc901a8f9853c9909" translate="yes" xml:space="preserve">
          <source>The compiler may move the addition back before the &lt;code&gt;volatile asm&lt;/code&gt; statement. To make it work as expected, add an artificial dependency to the &lt;code&gt;asm&lt;/code&gt; by referencing a variable in the subsequent code, for example:</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;volatile asm&lt;/code&gt; ステートメントの前に追加を戻す場合があります。期待どおりに機能させるには、次の例のように、後続のコードで変数を参照して、 &lt;code&gt;asm&lt;/code&gt; に人工的な依存関係を追加します。</target>
        </trans-unit>
        <trans-unit id="2d9dc939c11511961a2efd9a38375989ea973bee" translate="yes" xml:space="preserve">
          <source>The compiler never sets &lt;code&gt;EIND&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは &lt;code&gt;EIND&lt;/code&gt; を設定しません。</target>
        </trans-unit>
        <trans-unit id="d5c65d66d80d8006703599470ce9ad6d678c7518" translate="yes" xml:space="preserve">
          <source>The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</source>
          <target state="translated">コンパイラは、プログラムの知識に基づいて最適化を行います。複数のファイルを一度に1つの出力ファイルモードにコンパイルすることで、コンパイラは各ファイルをコンパイルする際に、すべてのファイルから得た情報を利用することができます。</target>
        </trans-unit>
        <trans-unit id="059a79983e1d0cd8bbb8de563c5411cbd5695493" translate="yes" xml:space="preserve">
          <source>The compiler rearranges the member initializers for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to match the declaration order of the members, emitting a warning to that effect. This warning is enabled by</source>
          <target state="translated">コンパイラーは、メンバーの宣言順序と一致するように &lt;code&gt;i&lt;/code&gt; および &lt;code&gt;j&lt;/code&gt; のメンバー初期化子を再配置し、その旨の警告を発します。この警告は</target>
        </trans-unit>
        <trans-unit id="6f7ea77386532c48049a0ac434d425f5c9cdb9e9" translate="yes" xml:space="preserve">
          <source>The compiler uses &lt;code&gt;EIND&lt;/code&gt; implicitly in &lt;code&gt;EICALL&lt;/code&gt;/&lt;code&gt;EIJMP&lt;/code&gt; instructions or might read &lt;code&gt;EIND&lt;/code&gt; directly in order to emulate an indirect call/jump by means of a &lt;code&gt;RET&lt;/code&gt; instruction.</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;EIND&lt;/code&gt; を &lt;code&gt;EICALL&lt;/code&gt; / &lt;code&gt;EIJMP&lt;/code&gt; 命令で暗黙的に使用するか、 &lt;code&gt;RET&lt;/code&gt; 命令を使用して間接呼び出し/ジャンプをエミュレートするために &lt;code&gt;EIND&lt;/code&gt; を直接読み取る場合があります。</target>
        </trans-unit>
        <trans-unit id="a697129b447131da9ef72d7d16ecc19d13cde06f" translate="yes" xml:space="preserve">
          <source>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by</source>
          <target state="translated">コンパイラは、関数をインライン化するかどうかを判断するためにさまざまなヒューリスティックを使用します。たとえば、コンパイラはインライン化する関数のサイズと現在の関数ですでに行われているインライン化の量を考慮に入れます。そのため、一見取るに足らないように見えるソースプログラムの変更でも</target>
        </trans-unit>
        <trans-unit id="37e71b48c058bf8bd050867961b9167f5825927e" translate="yes" xml:space="preserve">
          <source>The compiler will attempt to use hardware instructions to implement these built-in functions where possible, like conditional jump on overflow after addition, conditional jump on carry etc.</source>
          <target state="translated">コンパイラは、追加後のオーバーフロー時の条件付きジャンプ、キャリー時の条件付きジャンプなど、可能な限りハードウェア命令を使用してこれらの組み込み関数を実装しようとします。</target>
        </trans-unit>
        <trans-unit id="1f76bb0a6a769fd6051ac5f386b3821fb4f8794e" translate="yes" xml:space="preserve">
          <source>The concatenated &lt;code&gt;hi&lt;/code&gt; and &lt;code&gt;lo&lt;/code&gt; registers. Use this register to store doubleword values.</source>
          <target state="translated">連結された &lt;code&gt;hi&lt;/code&gt; および &lt;code&gt;lo&lt;/code&gt; レジスタ。このレジスタを使用して、ダブルワード値を格納します。</target>
        </trans-unit>
        <trans-unit id="99e27c97d9f5e63a4ed1ab3fd7f4a5a1d329e043" translate="yes" xml:space="preserve">
          <source>The conditional text &lt;code&gt;X&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">'内の条件付きテキスト &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a43dc662cd7d08ba0c1419ce7462e0ce31ad7cad" translate="yes" xml:space="preserve">
          <source>The constant -1</source>
          <target state="translated">定数 -1</target>
        </trans-unit>
        <trans-unit id="b06d0b57697105de48b17a361b846597d95ea06a" translate="yes" xml:space="preserve">
          <source>The constant 0.</source>
          <target state="translated">定数0です。</target>
        </trans-unit>
        <trans-unit id="40c6bdbaee6c04b3fea04b89e43f4576ad393c2b" translate="yes" xml:space="preserve">
          <source>The constant 4096</source>
          <target state="translated">定数4096</target>
        </trans-unit>
        <trans-unit id="2dcf3547f5273811228bed3353ffa4e638845233" translate="yes" xml:space="preserve">
          <source>The constant all-ones, for floating-point.</source>
          <target state="translated">浮動小数点の定数オールワン。</target>
        </trans-unit>
        <trans-unit id="d766b475adfc1a095915836fa6b0ad31150ade7f" translate="yes" xml:space="preserve">
          <source>The constant string objects are by default instances of the &lt;code&gt;NXConstantString&lt;/code&gt; class which is provided by the GNU Objective-C runtime. To get the definition of this class you must include the</source>
          <target state="translated">定数文字列オブジェクトは、デフォルトでは、GNU Objective-Cランタイムによって提供される &lt;code&gt;NXConstantString&lt;/code&gt; クラスのインスタンスです。このクラスの定義を取得するには、</target>
        </trans-unit>
        <trans-unit id="66bea79ec7c08d8354c118573be3f32ece7da1fe" translate="yes" xml:space="preserve">
          <source>The constant zero</source>
          <target state="translated">定数ゼロ</target>
        </trans-unit>
        <trans-unit id="0934955261fabaea67e58ba0c7b8bdff156718f6" translate="yes" xml:space="preserve">
          <source>The constant zero or one</source>
          <target state="translated">定数ゼロまたは1</target>
        </trans-unit>
        <trans-unit id="910f5457ff53fa25b37247787227a27d85f14892" translate="yes" xml:space="preserve">
          <source>The constraint matches if the specified part of a constant has a value different from its other parts.</source>
          <target state="translated">この制約は、定数の指定された部分の値が他の部分と異なる場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="d2273d82451da8273035b5677a47ae31f7f347c8" translate="yes" xml:space="preserve">
          <source>The contents of &lt;var&gt;definition&lt;/var&gt; are tokenized and processed as if they appeared during translation phase three in a &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;definition&lt;/var&gt; の内容はトークン化され、 'の翻訳フェーズ3で出現したかのように処理されます。</target>
        </trans-unit>
        <trans-unit id="3b752ddcb3035f47ee09a797efcd12407968ef21" translate="yes" xml:space="preserve">
          <source>The convenience of this extension is that &lt;code&gt;f1&lt;/code&gt; has the desired type, eliminating the need to consistently refer to &lt;code&gt;f2.f1&lt;/code&gt;.</source>
          <target state="translated">この拡張機能の便利な点は、 &lt;code&gt;f1&lt;/code&gt; に目的のタイプがあり、一貫して &lt;code&gt;f2.f1&lt;/code&gt; を参照する必要がないことです。</target>
        </trans-unit>
        <trans-unit id="6eb402cf1ad5d2ebe2ca4cbf79d4710d25aab043" translate="yes" xml:space="preserve">
          <source>The correct solution of the above problem is to use the &lt;code&gt;+load&lt;/code&gt; method instead of &lt;code&gt;+initialize&lt;/code&gt;:</source>
          <target state="translated">上記の問題の正しい解決策は、 &lt;code&gt;+initialize&lt;/code&gt; の代わりに+ &lt;code&gt;+load&lt;/code&gt; メソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="195548e33bab5979c07277ae9248599cd2872bd1" translate="yes" xml:space="preserve">
          <source>The count register, &lt;code&gt;ctr&lt;/code&gt;.</source>
          <target state="translated">カウントレジスタ、 &lt;code&gt;ctr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5773d425eed0cc1da37ec24e48650c9ef1f3309" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions.</source>
          <target state="translated">暗号化された命令。</target>
        </trans-unit>
        <trans-unit id="3b148cbd7e0801501003f1c6b7a5b5ed93ac8a89" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">暗号化命令です。これにより、高度なSIMD命令や浮動小数点命令だけでなく、ドットプロダクトの拡張機能も有効になります。</target>
        </trans-unit>
        <trans-unit id="bebf33834922696e2e3f146a7028c6f38f3d8ce5" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">暗号化命令です。これにより、高度なSIMD命令や浮動小数点命令も可能になります。</target>
        </trans-unit>
        <trans-unit id="3b57febbf4c477f2667a31f8b5a1e7554fec41ce" translate="yes" xml:space="preserve">
          <source>The current</source>
          <target state="translated">現在の</target>
        </trans-unit>
        <trans-unit id="0c616918c11c60074662af2cce8d7bf0b00b006e" translate="yes" xml:space="preserve">
          <source>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC do not work with an older or newer version of GCC.</source>
          <target state="translated">現在の LTO の実装では、異なるタイプのホスト間で移植可能なバイトコードを生成しようとはしていません。バイトコードファイルはバージョン管理されており、厳密なバージョンチェックが行われているため、あるバージョンの GCC で生成されたバイトコードファイルは、古いバージョンや新しいバージョンの GCC では動作しません。</target>
        </trans-unit>
        <trans-unit id="3c2f64218f4b3df3bf76a18bea506a72c2b53fb3" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">拡張実行文字集合のメンバに対応するマルチバイトの一文字からなる幅広文字定数を、対応する幅広文字コードに変換するために用いられる現在のロケール(C90 6.1.3.4,C99,C11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="a8b517f5ebe96bc26ba29bd9df7b451bc7264848" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide string literal into corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">幅広文字列リテラルを、対応する幅広文字コードに変換するために用いられるカレントロケール (C90 6.1.4,C99 ・ C11 6.4.5)。</target>
        </trans-unit>
        <trans-unit id="cdee0986787f12266222c4757db3c96510d2856b" translate="yes" xml:space="preserve">
          <source>The data in the</source>
          <target state="translated">のデータは</target>
        </trans-unit>
        <trans-unit id="ad21981df5f9d5df0a92c3202b31e09f62748eca" translate="yes" xml:space="preserve">
          <source>The data segment must be within 512KB while the read-only data segment can be within 4GB addressing space. The text segment should be still within 16MB addressing space.</source>
          <target state="translated">データセグメントは512KB以内でなければなりませんが、読み取り専用のデータセグメントは4GBのアドレス空間内であることができます。テキストセグメントは、まだ16MBのアドレス空間内にあるべきです。</target>
        </trans-unit>
        <trans-unit id="308218254edaf858c826e3717d9728c20e8ea1e8" translate="yes" xml:space="preserve">
          <source>The decimal floating types are &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt;. They use a radix of ten, unlike the floating types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; whose radix is not specified by the C standard but is usually two.</source>
          <target state="translated">10進浮動小数点型は、 &lt;code&gt;_Decimal32&lt;/code&gt; 、 &lt;code&gt;_Decimal64&lt;/code&gt; 、および &lt;code&gt;_Decimal128&lt;/code&gt; です。浮動小数点型 &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;long double&lt;/code&gt; とは異なり、基数はC標準で指定されていませんが、通常は2です。</target>
        </trans-unit>
        <trans-unit id="4ed195636dddaed157754b6f5efb512126f16823" translate="yes" xml:space="preserve">
          <source>The declaration of an identifier for a variable that has block scope that specifies &lt;code&gt;__thread&lt;/code&gt; shall also specify either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; を指定するブロックスコープを持つ変数の識別子の宣言では、 &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="translated">デフォルトの</target>
        </trans-unit>
        <trans-unit id="2d93ba84906186c36a266b5450164ecc57295a2f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;GCC_COLORS&lt;/code&gt; is</source>
          <target state="translated">デフォルトの &lt;code&gt;GCC_COLORS&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="cd78088e10f5ca7d05051ca6c08ccd0393bc0395" translate="yes" xml:space="preserve">
          <source>The default choice depends on the target.</source>
          <target state="translated">デフォルトの選択はターゲットによって異なります。</target>
        </trans-unit>
        <trans-unit id="24583facb0777645f4006ae576dc03c661b296bf" translate="yes" xml:space="preserve">
          <source>The default depends on how the compiler has been configured. It can be any of the above &lt;var&gt;WHEN&lt;/var&gt; options.</source>
          <target state="translated">デフォルトは、コンパイラーの構成方法によって異なります。上記の &lt;var&gt;WHEN&lt;/var&gt; オプションのいずれかです。</target>
        </trans-unit>
        <trans-unit id="821efaa8e812e852d4a90373d231a1a43df2b45f" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">デフォルトは特定のターゲット設定に依存します。LP64とILP32のABIはリンク互換性がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="073f483a59a39bdd6290fbf3294619a632dc2b8a" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">デフォルトは特定のターゲット設定に依存します。ハードフロートABIとソフトフロートABIはリンク互換性がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="83926f7ff8324784f23d17c03f2640efad441ea9" translate="yes" xml:space="preserve">
          <source>The default for</source>
          <target state="translated">のデフォルトは</target>
        </trans-unit>
        <trans-unit id="c9e7e18cf6d489e9159a83316e730a739e99cc90" translate="yes" xml:space="preserve">
          <source>The default for this argument is system dependent, users who want a specific calling convention should specify one explicitly. The valid calling conventions are: &amp;lsquo;</source>
          <target state="translated">この引数のデフォルトはシステムに依存するため、特定の呼び出し規約が必要なユーザーは、明示的に指定する必要があります。有効な呼び出し規約は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="92d2141e4257c252bb28809158d1f4e1362f7a44" translate="yes" xml:space="preserve">
          <source>The default for this option is &amp;lsquo;</source>
          <target state="translated">このオプションのデフォルトは '</target>
        </trans-unit>
        <trans-unit id="5842694f6173b42e85122f8c60c286aa7ddb9932" translate="yes" xml:space="preserve">
          <source>The default is</source>
          <target state="translated">デフォルトは</target>
        </trans-unit>
        <trans-unit id="f12e5a4f7dd6f8646e20a0f33147742e17617209" translate="yes" xml:space="preserve">
          <source>The default is &amp;lsquo;</source>
          <target state="translated">デフォルトは '</target>
        </trans-unit>
        <trans-unit id="5d068c3eaa8d9ce215b5361f4b44c855149b5984" translate="yes" xml:space="preserve">
          <source>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &amp;gt;= 1GB. If &lt;code&gt;getrlimit&lt;/code&gt; is available, the notion of &amp;ldquo;RAM&amp;rdquo; is the smallest of actual RAM and &lt;code&gt;RLIMIT_DATA&lt;/code&gt; or &lt;code&gt;RLIMIT_AS&lt;/code&gt;. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and</source>
          <target state="translated">デフォルトは30％+ 70％*（RAM / 1GB）で、RAM&amp;gt; = 1GBの場合、上限は100％です。 &lt;code&gt;getrlimit&lt;/code&gt; が使用可能な場合、「RAM」の概念は、実際のRAMおよび &lt;code&gt;RLIMIT_DATA&lt;/code&gt; または &lt;code&gt;RLIMIT_AS&lt;/code&gt; の最小値です。GCCが特定のプラットフォームでRAMを計算できない場合は、30％の下限が使用されます。このパラメータの設定と</target>
        </trans-unit>
        <trans-unit id="cce96b424afaca2d610cda8bfb3dce73bc563484" translate="yes" xml:space="preserve">
          <source>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and</source>
          <target state="translated">デフォルトは、RAM/8、RLIMIT_RSS、またはRLIMIT_DATAまたはRLIMIT_ASを超えないようにしようとする制限値のうち、下限が4096(4メガバイト)、上限が131072(128メガバイト)の小さい方です。GCCが特定のプラットフォームでRAMを計算できない場合は、下限値が使用されます。このパラメータを非常に大きく設定すると、ガベージコレクションを効果的に無効にします。このパラメータと</target>
        </trans-unit>
        <trans-unit id="cfa3b0a93016b2ef8689d14e510c93e9df2d4e56" translate="yes" xml:space="preserve">
          <source>The default is to allow these instructions, but it is not possible for GCC to reliably detect all circumstances where a string instruction might be used to access an I/O register, so their use cannot be disabled automatically. Instead it is reliant upon the programmer to use the</source>
          <target state="translated">デフォルトではこれらの命令を許可するようになっていますが、GCCは文字列命令がI/Oレジスタにアクセスするために使用される可能性があるすべての状況を確実に検出することは不可能なので、これらの命令の使用を自動的に無効にすることはできません。その代わりに、プログラマーが</target>
        </trans-unit>
        <trans-unit id="b3f67e8f5424b41ebf8e66523efa318016a862fb" translate="yes" xml:space="preserve">
          <source>The default is to not maintain the backchain.</source>
          <target state="translated">デフォルトではバックチェーンを維持しないようになっています。</target>
        </trans-unit>
        <trans-unit id="a0a0e13c8768face52cb8f602f8efb80a446348b" translate="yes" xml:space="preserve">
          <source>The default is to not use the packed stack layout.</source>
          <target state="translated">デフォルトでは、パックされたスタックレイアウトを使用しないようになっています。</target>
        </trans-unit>
        <trans-unit id="edb857f688cb7de8ba1fbdc52989269bb35500d9" translate="yes" xml:space="preserve">
          <source>The default is usually</source>
          <target state="translated">デフォルトは通常</target>
        </trans-unit>
        <trans-unit id="d74d1893ecb7357c9e0df6cf36fc2bbcbd00a365" translate="yes" xml:space="preserve">
          <source>The default linker script is arranged for code with &lt;code&gt;EIND = 0&lt;/code&gt;. If code is supposed to work for a setup with &lt;code&gt;EIND != 0&lt;/code&gt;, a custom linker script has to be used in order to place the sections whose name start with &lt;code&gt;.trampolines&lt;/code&gt; into the segment where &lt;code&gt;EIND&lt;/code&gt; points to.</source>
          <target state="translated">デフォルトのリンカースクリプトは、 &lt;code&gt;EIND = 0&lt;/code&gt; コード用に用意されています。 &lt;code&gt;EIND != 0&lt;/code&gt; 設定でコードが機能する場合、名前が &lt;code&gt;.trampolines&lt;/code&gt; で始まるセクションを &lt;code&gt;EIND&lt;/code&gt; が指すセグメントに配置するために、カスタムリンカースクリプトを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="27ca561e84dd9753757548b177e64c001dc72487" translate="yes" xml:space="preserve">
          <source>The default memory model for the processor and operating system.</source>
          <target state="translated">プロセッサとオペレーティングシステムのデフォルトのメモリモデル。</target>
        </trans-unit>
        <trans-unit id="1d2c3331e29b4e0f75190cbcac7d2cc2935baa6d" translate="yes" xml:space="preserve">
          <source>The default size of &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;long&lt;/code&gt;s and pointers depends on the ABI. All the supported ABIs use 32-bit &lt;code&gt;int&lt;/code&gt;s. The n64 ABI uses 64-bit &lt;code&gt;long&lt;/code&gt;s, as does the 64-bit EABI; the others use 32-bit &lt;code&gt;long&lt;/code&gt;s. Pointers are the same size as &lt;code&gt;long&lt;/code&gt;s, or the same size as integer registers, whichever is smaller.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、およびポインタのデフォルトサイズは、ABIによって異なります。サポートされているすべてのABIは32ビットの &lt;code&gt;int&lt;/code&gt; 使用します。n64 ABIは64 ビットEABIと同様に64 ビット &lt;code&gt;long&lt;/code&gt; を使用します。他は32ビット &lt;code&gt;long&lt;/code&gt; を使用します。ポインターは &lt;code&gt;long&lt;/code&gt; と同じサイズか、整数レジスターと同じサイズのいずれか小さい方です。</target>
        </trans-unit>
        <trans-unit id="c7b0f9504e79ddd153856cb5f4d8eb1074e6f4cb" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma (C99 and C11 7.6.1).</source>
          <target state="translated">&lt;code&gt;FENV_ACCESS&lt;/code&gt; プラグマのデフォルトの状態（C99およびC11 7.6.1）。</target>
        </trans-unit>
        <trans-unit id="177e9fccdcf6129808c994646c54fbba2a07d2f1" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 7.12.2).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; プラグマのデフォルトの状態（C99およびC11 7.12.2）。</target>
        </trans-unit>
        <trans-unit id="2aba487b3647bdb911ee4d93a6d6e3bbfd1ab912" translate="yes" xml:space="preserve">
          <source>The default target is automatically quoted, as if it were given with</source>
          <target state="translated">デフォルトのターゲットは、あたかも</target>
        </trans-unit>
        <trans-unit id="33b715cc53246030b15f24132e973369879e225c" translate="yes" xml:space="preserve">
          <source>The default value is zero, which disables this feature. Note, this feature is not enabled by default with higher optimization levels (</source>
          <target state="translated">デフォルト値はゼロで、この機能は無効になります。この機能は、より高い最適化レベル (</target>
        </trans-unit>
        <trans-unit id="bbd9601e22b31b48a224ffc4033c0ab4f7fbfa78" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; のデフォルト値は</target>
        </trans-unit>
        <trans-unit id="209814b876827ae56a611572209eb49a8bba5de1" translate="yes" xml:space="preserve">
          <source>The default value of this option is determined by the application binary interface for the target processor.</source>
          <target state="translated">このオプションのデフォルト値は、ターゲットプロセッサのアプリケーションバイナリインターフェイスによって決定されます。</target>
        </trans-unit>
        <trans-unit id="59182b861f448516d9a37ab74276ea6b6b33c147" translate="yes" xml:space="preserve">
          <source>The default value of this option is enabled, thus the only useful form of the option is</source>
          <target state="translated">このオプションのデフォルト値は有効なので、このオプションの唯一の有用な形式は</target>
        </trans-unit>
        <trans-unit id="1a823e9ffdad4eb9044013582624dc9752e06eea" translate="yes" xml:space="preserve">
          <source>The default warning level of the</source>
          <target state="translated">のデフォルトの警告レベルは</target>
        </trans-unit>
        <trans-unit id="c7308db0e02a6c747424ae6a4742ab7d5a6523ec" translate="yes" xml:space="preserve">
          <source>The default when in a standards compliant mode (</source>
          <target state="translated">標準準拠モードの場合のデフォルト (</target>
        </trans-unit>
        <trans-unit id="c45a650c66e86b129ff1159a971751cec60bc96d" translate="yes" xml:space="preserve">
          <source>The default without</source>
          <target state="translated">なしのデフォルト</target>
        </trans-unit>
        <trans-unit id="ecb6ca065b9096c7acde0b3f9da92272ca10172c" translate="yes" xml:space="preserve">
          <source>The default x86-32 ABI assumes that the callee pops the stack for hidden pointer. However, on x86-32 Microsoft Windows targets, the compiler assumes that the caller pops the stack for hidden pointer.</source>
          <target state="translated">既定の x86-32 ABI では、呼び出し元がスタックを非表示ポインタ用にポップすることを前提としています。しかし、x86-32 Microsoft Windowsターゲットでは、コンパイラは呼び出し元がスタックを非表示ポインタ用にポップすると仮定しています。</target>
        </trans-unit>
        <trans-unit id="a2e6fba24182b6c22f37f14e5bbdf01ab49ea815" translate="yes" xml:space="preserve">
          <source>The default, if no C language dialect options are given, is</source>
          <target state="translated">C 言語の方言オプションが指定されていない場合のデフォルトは</target>
        </trans-unit>
        <trans-unit id="94e40f79f518daef10239cd573498a0a9fbea872" translate="yes" xml:space="preserve">
          <source>The default, if no C++ language dialect options are given, is</source>
          <target state="translated">C++言語の方言オプションが与えられていない場合のデフォルトは</target>
        </trans-unit>
        <trans-unit id="63d161b7c381e191c75f2893e8fc452452e1e3d3" translate="yes" xml:space="preserve">
          <source>The definition given in the Intel documentation allows only for the use of the types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt; or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type &lt;code&gt;_Bool&lt;/code&gt; or the C++ type &lt;code&gt;bool&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">Intelのドキュメントで定義されている定義では、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 型、またはそれらの符号なしの型の使用のみが許可されています。GCCは、Cタイプの &lt;code&gt;_Bool&lt;/code&gt; またはC ++タイプの &lt;code&gt;bool&lt;/code&gt; 以外のサイズが1、2、4、または8バイトのスカラータイプを許可します。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインターが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="12d18656502db6e4e9c93de0479a82b56cb9d524" translate="yes" xml:space="preserve">
          <source>The definitions for &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; when respectively, the date and time of translation are not available (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</source>
          <target state="translated">翻訳の日付と時刻がそれぞれ利用できない場合の &lt;code&gt;__DATE__&lt;/code&gt; および &lt;code&gt;__TIME__&lt;/code&gt; の定義（C90 6.8.8、C99 6.10.8、C11 6.10.8.1）。</target>
        </trans-unit>
        <trans-unit id="d50e31983578e620136495305e55ed145625f1a3" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the execution frequency of the entry block of a function that a basic block of this function needs to at least have in order to be considered hot. The default is 1000, which means that a basic block is considered hot in a function if it is executed more frequently than 1/1000 of the frequency of the entry block of the function. 0 means that it is never considered hot.</source>
          <target state="translated">この関数の基本ブロックがホットとみなされるために少なくとも必要な関数のエントリブロックの実行頻度の1/nの分母n。デフォルトは1000で、基本ブロックが関数のエントリブロックの実行頻度の1/1000以上の頻度で実行された場合、関数内でホットとみなされることを意味します。0は、決してホットとみなされないことを意味します。</target>
        </trans-unit>
        <trans-unit id="75cdf285dab576e728fe4c1726581875dabc3071" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the maximal execution count of a basic block in the entire program that a basic block needs to at least have in order to be considered hot. The default is 10000, which means that a basic block is considered hot if its execution count is greater than 1/10000 of the maximal execution count. 0 means that it is never considered hot. Used in non-LTO mode.</source>
          <target state="translated">プログラム全体における基本ブロックの最大実行回数の 1/n の分母 n の端数。デフォルトは 10000 で、基本ブロックの実行回数が最大実行回数の 1/10000 より大きい場合にホットとみなされることを意味します。0 は、ホットとみなされないことを意味します。非LTOモードで使用されます。</target>
        </trans-unit>
        <trans-unit id="d8711313846a248f0818ef2198a1524b06952be7" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the number of profiled runs of the entire program below which the execution count of a basic block must be in order for the basic block to be considered unlikely executed. The default is 20, which means that a basic block is considered unlikely executed if it is executed in fewer than 1/20, or 5%, of the runs of the program. 0 means that it is always considered unlikely executed.</source>
          <target state="translated">基本ブロックが実行される可能性が低いとみなされるためには、基本ブロックの実行回数がそれ以下でなければならないプログラム全体のプロファイリングされた実行回数 1/n の分母 n。デフォルトは20で、プログラムの実行回数の1/20、つまり5%未満で実行された場合、基本ブロックは実行される可能性が低いとみなされることを意味します。0 は、常に実行される可能性が低いと見なされることを意味します。</target>
        </trans-unit>
        <trans-unit id="a09ae46c0bc04395fafa29f4371d3dd1f0905098" translate="yes" xml:space="preserve">
          <source>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions.</source>
          <target state="translated">巻き上げる式のドミネータツリーでの探索の深さを指定します。これは、起伏アルゴリズムにおける二次的な振る舞いを避けるために使用されます。0の値は探索の制限にはなりませんが、巨大な関数のコンパイルが遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="14934208c61e859a6e7eb6b441a06008f55e391f" translate="yes" xml:space="preserve">
          <source>The device / architecture belongs to the XMEGA family of devices.</source>
          <target state="translated">デバイス/アーキテクチャはXMEGAファミリーに属しています。</target>
        </trans-unit>
        <trans-unit id="0848b55d6ef92bf5b121f28a3f70167cf843e9f0" translate="yes" xml:space="preserve">
          <source>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT).</source>
          <target state="translated">デバイスには、Read-Modify-Write命令(XCH、LAC、LAS、LAT)があります。</target>
        </trans-unit>
        <trans-unit id="c94be4f62c4adcfc5a43023ae724a73e574f4d44" translate="yes" xml:space="preserve">
          <source>The device has a hardware multiplier.</source>
          <target state="translated">このデバイスは、ハードウェアの乗算器を持っています。</target>
        </trans-unit>
        <trans-unit id="40eec38c7059a6f4d65d7d4102f16aec3f9f23ce" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;EIJMP&lt;/code&gt; and &lt;code&gt;EICALL&lt;/code&gt; instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide.</source>
          <target state="translated">デバイスには、 &lt;code&gt;EIJMP&lt;/code&gt; および &lt;code&gt;EICALL&lt;/code&gt; 命令があります。これは、プログラムメモリが128 KiBを超えるデバイスの場合です。これは、プログラムカウンタ（PC）の幅が3バイトであることも意味します。</target>
        </trans-unit>
        <trans-unit id="7183cfd675e5fad71be960e9de6faa5f999d51c4" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;ELPM
R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">デバイスには &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; および &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 命令があります。</target>
        </trans-unit>
        <trans-unit id="124acdeb9487e33b6bf2adad9222c95480d5e077" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">デバイスには &lt;code&gt;ELPM&lt;/code&gt; 命令があります。</target>
        </trans-unit>
        <trans-unit id="ace169ce6eef96ce4c8d2efd5bee4eef88f9d4da" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;JMP&lt;/code&gt; and &lt;code&gt;CALL&lt;/code&gt; instructions. This is the case for devices with more than 8 KiB of program memory.</source>
          <target state="translated">デバイスには、 &lt;code&gt;JMP&lt;/code&gt; および &lt;code&gt;CALL&lt;/code&gt; 命令があります。これは、プログラムメモリが8 KiBを超えるデバイスの場合です。</target>
        </trans-unit>
        <trans-unit id="c648d34bf5dc6505ae5b97362b5aa073400b3ded" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">デバイスには、 &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; および &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 命令があります。</target>
        </trans-unit>
        <trans-unit id="aeb599358087e9ab1d870c33d3b39e9eeb6c15cf" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;MOVW&lt;/code&gt; instruction to perform 16-bit register-register moves.</source>
          <target state="translated">デバイスには、16ビットのレジスタ間移動を実行する &lt;code&gt;MOVW&lt;/code&gt; 命令があります。</target>
        </trans-unit>
        <trans-unit id="83a1356b9ac9ce24c84c12bd07e29feb04f94c12" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;RAMPD&lt;/code&gt;, &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively.</source>
          <target state="translated">デバイスには、 &lt;code&gt;RAMPD&lt;/code&gt; 、 &lt;code&gt;RAMPX&lt;/code&gt; 、 &lt;code&gt;RAMPY&lt;/code&gt; 、 &lt;code&gt;RAMPZ&lt;/code&gt; 特殊機能レジスタがあります。</target>
        </trans-unit>
        <trans-unit id="7440edf5c9a0d8bde64b1ecefe74df7b62918795" translate="yes" xml:space="preserve">
          <source>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by</source>
          <target state="translated">デバイスはそれぞれSPH(スタックポインタの上位部分)特殊関数レジスタを持っているか、8ビットのスタックポインタを持っています。これらのマクロの定義は</target>
        </trans-unit>
        <trans-unit id="a15f34c198926a24e4b29d121787f367b6273a1a" translate="yes" xml:space="preserve">
          <source>The diff may or may not be colorized, following the same rules as for diagnostics (see</source>
          <target state="translated">diffは、診断と同じルールに従って、カラー化してもしなくてもかまいません (</target>
        </trans-unit>
        <trans-unit id="bfb8bac86341e0faa063bc2c7464731f3754920b" translate="yes" xml:space="preserve">
          <source>The differences to the &lt;code&gt;naked&lt;/code&gt; function attribute are:</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 関数属性との違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="caa2f3d0586724648ad5dc95b2dd6a57770fcc55" translate="yes" xml:space="preserve">
          <source>The direction of rounding when a floating-point number is converted to a narrower floating-point number (C90 6.2.1.4, C99 and C11 6.3.1.5).</source>
          <target state="translated">浮動小数点数を狭い浮動小数点数に変換する場合の丸めの方向(C90 6.2.1.4、C99、C11 6.3.1.5)。</target>
        </trans-unit>
        <trans-unit id="26fb3de478c5cf1596d7cf8a88ab611eedc18b11" translate="yes" xml:space="preserve">
          <source>The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value (C90 6.2.1.3, C99 and C11 6.3.1.4).</source>
          <target state="translated">整数を元の値を正確に表すことができない浮動小数点数に変換したときの丸めの方向(C90 6.2.1.3、C99、C11 6.3.1.4)。</target>
        </trans-unit>
        <trans-unit id="9c2a89eb8a493cddb0e17d65209367b348e4e331" translate="yes" xml:space="preserve">
          <source>The earliest version of MacOS X that this executable will run on is &lt;var&gt;version&lt;/var&gt;. Typical values of &lt;var&gt;version&lt;/var&gt; include &lt;code&gt;10.1&lt;/code&gt;, &lt;code&gt;10.2&lt;/code&gt;, and &lt;code&gt;10.3.9&lt;/code&gt;.</source>
          <target state="translated">この実行可能ファイルが実行されるMacOS Xの最も古いバージョンは &lt;var&gt;version&lt;/var&gt; です。典型的な値 &lt;var&gt;version&lt;/var&gt; 含ま &lt;code&gt;10.1&lt;/code&gt; 、 &lt;code&gt;10.2&lt;/code&gt; 、および &lt;code&gt;10.3.9&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc00d4d1ee11aa29f8972e4481c89ebd51afb01" translate="yes" xml:space="preserve">
          <source>The easiest way of satisfying these restrictions is to compile and link every module with the same</source>
          <target state="translated">これらの制限を満たす最も簡単な方法は、すべてのモジュールをコンパイルして同じ</target>
        </trans-unit>
        <trans-unit id="ee24dbb06c4125c8c59c873450e471ac0298f125" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (i.e. &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">この効果は、エイリアスへのすべての参照を別の翻訳ユニットに移動し、エイリアスの名前をエイリアスシンボルに変更し、弱いものとして宣言し、2つの別々の翻訳ユニットをコンパイルし、再配置可能な出力（つまり、 &lt;code&gt;ld -r&lt;/code&gt; ）でリンクを実行するのと同じです。それら。</target>
        </trans-unit>
        <trans-unit id="40ce96812102dd380fc896f02591a99db980d416" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (ie: &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">この効果は、エイリアスへのすべての参照を別の変換単位に移動し、エイリアスの名前をエイリアスシンボルに変更し、それを弱いものとして宣言し、2つの個別の変換単位をコンパイルして、再配置可能な出力とのリンクを実行する（つまり、 &lt;code&gt;ld -r&lt;/code&gt; ）のと同じです。それらの上に。</target>
        </trans-unit>
        <trans-unit id="2fcdd3faf7319592c843ba96ea56c638eff89d9c" translate="yes" xml:space="preserve">
          <source>The effect of this is that GCC may, effectively, mark inline methods with &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; so that they do not appear in the export table of a DSO and do not require a PLT indirection when used within the DSO. Enabling this option can have a dramatic effect on load and link times of a DSO as it massively reduces the size of the dynamic export table when the library makes heavy use of templates.</source>
          <target state="translated">これの効果は、GCCが効果的にインラインメソッドを &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; でマークし、DSOのエクスポートテーブルに表示されないようにして、 DSO。このオプションを有効にすると、ライブラリがテンプレートを頻繁に使用するときに動的エクスポートテーブルのサイズが大幅に減少するため、DSOの読み込み時間とリンク時間に劇的な影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="0339dc59fd2ec7a99f69b1c58fc9500261d6af02" translate="yes" xml:space="preserve">
          <source>The effectiveness of some warnings depends on optimizations also being enabled. For example</source>
          <target state="translated">いくつかの警告の有効性は、最適化が有効になっているかどうかに依存します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a80b8b3ee96e1537d805054b77f62723800f759b" translate="yes" xml:space="preserve">
          <source>The elements of the input vectors are numbered in memory ordering of &lt;var&gt;vec0&lt;/var&gt; beginning at 0 and &lt;var&gt;vec1&lt;/var&gt; beginning at &lt;var&gt;N&lt;/var&gt;. The elements of &lt;var&gt;mask&lt;/var&gt; are considered modulo &lt;var&gt;N&lt;/var&gt; in the single-operand case and modulo &lt;em&gt;2*&lt;var&gt;N&lt;/var&gt;&lt;/em&gt; in the two-operand case.</source>
          <target state="translated">入力ベクトルの要素は、0から始まる &lt;var&gt;vec0&lt;/var&gt; と &lt;var&gt;N&lt;/var&gt; から始まる &lt;var&gt;vec1&lt;/var&gt; のメモリ順序で番号が付けられています。要素 &lt;var&gt;mask&lt;/var&gt; モジュロと考えられる &lt;var&gt;N&lt;/var&gt; 単一オペランド場合にモジュロ&lt;em&gt;2 * &lt;/em&gt;&lt;em&gt; &lt;var&gt;N&lt;/var&gt; を&lt;/em&gt; 2オペランド場合。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03329c8955d8e056ec3aa9ef42249119fe358d03" translate="yes" xml:space="preserve">
          <source>The encoding of any of &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, and &lt;code&gt;char32_t&lt;/code&gt; where the corresponding standard encoding macro (&lt;code&gt;__STDC_ISO_10646__&lt;/code&gt;, &lt;code&gt;__STDC_UTF_16__&lt;/code&gt;, or &lt;code&gt;__STDC_UTF_32__&lt;/code&gt;) is not defined (C11 6.10.8.2).</source>
          <target state="translated">対応する標準エンコーディングマクロ（ &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; 、 &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; 、または &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; ）が定義されていない &lt;code&gt;wchar_t&lt;/code&gt; 、 &lt;code&gt;char16_t&lt;/code&gt; 、および &lt;code&gt;char32_t&lt;/code&gt; のいずれかのエンコーディング（C11 6.10.8.2）。</target>
        </trans-unit>
        <trans-unit id="f0c42b29af2e3bb28afd21f635c0f39721670e06" translate="yes" xml:space="preserve">
          <source>The encoding of bit-fields has changed to allow bit-fields to be properly handled by the runtime functions that compute sizes and alignments of types that contain bit-fields. The previous encoding contained only the size of the bit-field. Using only this information it is not possible to reliably compute the size occupied by the bit-field. This is very important in the presence of the Boehm&amp;rsquo;s garbage collector because the objects are allocated using the typed memory facility available in this collector. The typed memory allocation requires information about where the pointers are located inside the object.</source>
          <target state="translated">ビットフィールドを含むタイプのサイズと配置を計算するランタイム関数がビットフィールドを適切に処理できるように、ビットフィールドのエンコーディングが変更されました。以前のエンコーディングには、ビットフィールドのサイズのみが含まれていました。この情報だけを使用しても、ビットフィールドが占めるサイズを確実に計算することはできません。オブジェクトはこのコレクターで使用可能な型付きメモリ機能を使用して割り当てられるため、これはBoehmのガベージコレクターの存在下で非常に重要です。型付きメモリの割り当てには、ポインタがオブジェクト内のどこにあるかに関する情報が必要です。</target>
        </trans-unit>
        <trans-unit id="32de7cb2a746befc3519adabd406682f138c91dc" translate="yes" xml:space="preserve">
          <source>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.</source>
          <target state="translated">ブランチヒント命令のエンコーディングは、ヒントが影響を受けるブランチの256命令以内に収まるように制限します。デフォルトでは、GCC は 125 命令以内であることを確認します。</target>
        </trans-unit>
        <trans-unit id="86931df671f82bbbca9166c366a69eb90410e2f2" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt;, if defined, non-empty and nonzero, implicitly enables</source>
          <target state="translated">環境変数 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; が定義されている場合、空でもゼロでもない場合、暗黙的に有効になります</target>
        </trans-unit>
        <trans-unit id="f1abddc031f4887620e779e03fa9bce246eca769" translate="yes" xml:space="preserve">
          <source>The error is only generated if the pragma is present in the code after pre-processing has been completed. It does not matter however if the code containing the pragma is unreachable:</source>
          <target state="translated">エラーが発生するのは、前処理が完了した後のコードにプラグマが存在する場合のみです。しかし、プラグマを含むコードが到達不可能な場合は問題ではありません。</target>
        </trans-unit>
        <trans-unit id="62217b180fda693fac806123c3cedff899bcd7c2" translate="yes" xml:space="preserve">
          <source>The evaluation methods characterized by non-standard negative values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 and C11 5.2.4.2.2).</source>
          <target state="translated">&lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; の非標準の負の値を特徴とする評価方法（C99およびC11 5.2.4.2.2）。</target>
        </trans-unit>
        <trans-unit id="e7ca0d5b7ee5cf7cc21b906f53631f0432c41aa1" translate="yes" xml:space="preserve">
          <source>The example above is correctly written as:</source>
          <target state="translated">上の例では、正しくは次のように書きます。</target>
        </trans-unit>
        <trans-unit id="2262d7979d1e6f669d9d267628d7f1a5e043c047" translate="yes" xml:space="preserve">
          <source>The execution counts are cumulative. If the example program were executed again without removing the</source>
          <target state="translated">実行回数は累積されます。例題のプログラムが</target>
        </trans-unit>
        <trans-unit id="30cd9cacada80b254b465216587c60514745e9e0" translate="yes" xml:space="preserve">
          <source>The exported header file declaring the function the user calls would contain:</source>
          <target state="translated">ユーザーが呼び出す関数が含まれることを宣言するエクスポートされたヘッダーファイル。</target>
        </trans-unit>
        <trans-unit id="6a3b0d1b517a2735ccea32622e6c16bbe062c918" translate="yes" xml:space="preserve">
          <source>The extended version of &lt;code&gt;__builtin_expect&lt;/code&gt; is not supported.</source>
          <target state="translated">&lt;code&gt;__builtin_expect&lt;/code&gt; の拡張バージョンはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e5f79933f130a6010408a53873b5c18d791196b0" translate="yes" xml:space="preserve">
          <source>The extended version of the ARMv7-A architecture with support for virtualization.</source>
          <target state="translated">仮想化をサポートするARMv7-Aアーキテクチャの拡張バージョン。</target>
        </trans-unit>
        <trans-unit id="f69903151111d03e37009b513bcf8f14816a93e4" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the &lt;code&gt;register&lt;/code&gt; storage-class specifier are effective (C90 6.5.1, C99 and C11 6.7.1).</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; ストレージクラス指定子を使用して行われた提案が有効である範囲（C90 6.5.1、C99およびC11 6.7.1）。</target>
        </trans-unit>
        <trans-unit id="99d4acdb059ef7e8275eb6991f7b3fdb57cb4d7e" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the inline function specifier are effective (C99 and C11 6.7.4).</source>
          <target state="translated">インライン関数指定子を用いた提案がどの程度有効であるか(C99、C11 6.7.4)。</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">ファイル</target>
        </trans-unit>
        <trans-unit id="be1544009a06e2ed9b8c04313febbe4a5054a34c" translate="yes" xml:space="preserve">
          <source>The filename and replacement string escape backslash as &amp;ldquo;\\&quot;, tab as &amp;ldquo;\t&amp;rdquo;, newline as &amp;ldquo;\n&amp;rdquo;, double quotes as &amp;ldquo;\&quot;&amp;rdquo;, non-printable characters as octal (e.g. vertical tab as &amp;ldquo;\013&amp;rdquo;).</source>
          <target state="translated">ファイル名と置換文字列は、バックスラッシュを「\\」、タブを「\ t」、改行を「\ n」、二重引用符を「\」、エスケープできない文字を8進数でエスケープします（例：垂直タブを「\ 013」） ）。</target>
        </trans-unit>
        <trans-unit id="052b9a9ce595b22df1664059ccb4ac71ceb3b652" translate="yes" xml:space="preserve">
          <source>The files used by gcov.</source>
          <target state="translated">gcovが使用するファイル。</target>
        </trans-unit>
        <trans-unit id="5f9146bf44aa8a552083fbcdde4f12b382de6ccc" translate="yes" xml:space="preserve">
          <source>The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.</source>
          <target state="translated">最初の引数は、現在の関数の開始位置のアドレスで、シンボルテーブルで正確に調べることができます。</target>
        </trans-unit>
        <trans-unit id="d40b2392c804eafb9e2a38b040dcc6ad4b8a38cb" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register, the second argument, &lt;var&gt;val&lt;/var&gt;, is a compile time constant to be written to the register. Generates:</source>
          <target state="translated">最初の引数 &lt;var&gt;auxv&lt;/var&gt; は補助レジスターのアドレス、2番目の引数 &lt;var&gt;val&lt;/var&gt; はレジスターに書き込まれるコンパイル時定数です。生成：</target>
        </trans-unit>
        <trans-unit id="1bb8468783d812fcfe3a90c5c3005fc31c3a8b43" translate="yes" xml:space="preserve">
          <source>The first built-in function allows arbitrary integral types for operands and the result type must be pointer to some integral type other than enumerated or boolean type, the rest of the built-in functions have explicit integer types.</source>
          <target state="translated">最初の組み込み関数では,オペランドに任意の積分型を指定することができ,結果の型は列挙型やブール型以外の積分型へのポインタでなければなりません.</target>
        </trans-unit>
        <trans-unit id="766dbe1354f0d010e9b9752b025269447d8bacdc" translate="yes" xml:space="preserve">
          <source>The first number on each line is the &amp;ldquo;user time&amp;rdquo;, that is time spent executing the program itself. The second number is &amp;ldquo;system time&amp;rdquo;, time spent executing operating system routines on behalf of the program. Both numbers are in seconds.</source>
          <target state="translated">各行の最初の数字は「ユーザー時間」、つまりプログラム自体の実行に費やされた時間です。2番目の数値は「システム時間」で、プログラムに代わってオペレーティングシステムルーチンの実行に費やされた時間です。どちらの数値も秒単位です。</target>
        </trans-unit>
        <trans-unit id="7705a0a1f8fdbe72b6eed476ebaac5e4596393cb" translate="yes" xml:space="preserve">
          <source>The first operand is the number of a register to be written, the second operand is a compile time constant to write into that register. Generates:</source>
          <target state="translated">1番目のオペランドは書き込まれるレジスタの番号で、2番目のオペランドはそのレジスタに書き込むコンパイル時定数です。生成します。</target>
        </trans-unit>
        <trans-unit id="5403326826a0ff4e3670389f165daf4e08127b0b" translate="yes" xml:space="preserve">
          <source>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate &lt;code&gt;typedef&lt;/code&gt;:</source>
          <target state="translated">これらの拡張機能を使用する最初のステップは、必要なデータ型を提供することです。これは、適切な &lt;code&gt;typedef&lt;/code&gt; を使用して行う必要があります。</target>
        </trans-unit>
        <trans-unit id="0180fb5f9566434bbaf5187f78b901ca8a7ed3d8" translate="yes" xml:space="preserve">
          <source>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside</source>
          <target state="translated">GCC の最初の二つの呼び出しは、GIMPLE のバイトコード表現を</target>
        </trans-unit>
        <trans-unit id="d7463018cc3efdf04fea2a1a9520f2dcaa8a917d" translate="yes" xml:space="preserve">
          <source>The fixed-point types are &lt;code&gt;short _Fract&lt;/code&gt;, &lt;code&gt;_Fract&lt;/code&gt;, &lt;code&gt;long _Fract&lt;/code&gt;, &lt;code&gt;long long _Fract&lt;/code&gt;, &lt;code&gt;unsigned short _Fract&lt;/code&gt;, &lt;code&gt;unsigned _Fract&lt;/code&gt;, &lt;code&gt;unsigned long _Fract&lt;/code&gt;, &lt;code&gt;unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat short _Fract&lt;/code&gt;, &lt;code&gt;_Sat _Fract&lt;/code&gt;, &lt;code&gt;_Sat long _Fract&lt;/code&gt;, &lt;code&gt;_Sat long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;short _Accum&lt;/code&gt;, &lt;code&gt;_Accum&lt;/code&gt;, &lt;code&gt;long _Accum&lt;/code&gt;, &lt;code&gt;long long _Accum&lt;/code&gt;, &lt;code&gt;unsigned short _Accum&lt;/code&gt;, &lt;code&gt;unsigned _Accum&lt;/code&gt;, &lt;code&gt;unsigned long _Accum&lt;/code&gt;, &lt;code&gt;unsigned long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat short _Accum&lt;/code&gt;, &lt;code&gt;_Sat _Accum&lt;/code&gt;, &lt;code&gt;_Sat long _Accum&lt;/code&gt;, &lt;code&gt;_Sat long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt;.</source>
          <target state="translated">固定小数点型は、 &lt;code&gt;short _Fract&lt;/code&gt; 、 &lt;code&gt;_Fract&lt;/code&gt; 、 &lt;code&gt;long _Fract&lt;/code&gt; 、 &lt;code&gt;long long _Fract&lt;/code&gt; 、 &lt;code&gt;unsigned short _Fract&lt;/code&gt; 、 &lt;code&gt;unsigned _Fract&lt;/code&gt; 、 &lt;code&gt;unsigned long _Fract&lt;/code&gt; 、 &lt;code&gt;unsigned long long _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat short _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat long _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat long long _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt; 、 &lt;code&gt;short _Accum&lt;/code&gt; 、 &lt;code&gt;_Accum&lt;/code&gt; 、 &lt;code&gt;long _Accum&lt;/code&gt; 、 &lt;code&gt;long long _Accum&lt;/code&gt; 、 &lt;code&gt;unsigned short _Accum&lt;/code&gt; 、 &lt;code&gt;unsigned _Accum&lt;/code&gt; 、 &lt;code&gt;unsigned long _Accum&lt;/code&gt; 、 &lt;code&gt;unsigned long long _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat short _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat long _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat long long _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt; 、 &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3caefb409c9894c159fb9e3de06457a892f7b065" translate="yes" xml:space="preserve">
          <source>The flag makes these changes to GCC&amp;rsquo;s linkage model:</source>
          <target state="translated">このフラグは、GCCのリンケージモデルに次の変更を加えます。</target>
        </trans-unit>
        <trans-unit id="e89357c25217d9e6ea0399e085ee6ac916e2228f" translate="yes" xml:space="preserve">
          <source>The flag output constraints are not supported in thumb1 mode.</source>
          <target state="translated">thumb1モードでは、フラグ出力制約はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="398abcfd0bda984ca55650d923231a3e23d99caf" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the ARM family are of the form &amp;lsquo;</source>
          <target state="translated">ARMファミリのフラグ出力制約は次の形式です。</target>
        </trans-unit>
        <trans-unit id="467579e58b2ed3f9e1f5da092ecc00a08220e553" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the x86 family are of the form &amp;lsquo;</source>
          <target state="translated">x86ファミリのフラグ出力制約は次の形式です。</target>
        </trans-unit>
        <trans-unit id="08b70c97084691cff3ef37f7ca63544f38157171" translate="yes" xml:space="preserve">
          <source>The flags register.</source>
          <target state="translated">フラグレジスタです。</target>
        </trans-unit>
        <trans-unit id="bdec47de335eba5411aba4ed82b1290026a8b9df" translate="yes" xml:space="preserve">
          <source>The floating-point constant 0.0</source>
          <target state="translated">浮動小数点定数 0.0</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3c5af523cdaaa4e1970de9cf32fc6b6194b0929d" translate="yes" xml:space="preserve">
          <source>The following CPU names can be detected:</source>
          <target state="translated">以下のCPU名を検出することができます。</target>
        </trans-unit>
        <trans-unit id="5f10647ac5c4280bde68061d0442176ac21bf7e2" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 (</source>
          <target state="translated">ISA 3.0(以降、PowerPC ファミリのプロセッサでは、以下の追加のビルトイン機能も利用可能です。</target>
        </trans-unit>
        <trans-unit id="1929bf7289a9ecdc2dad5969b2604877133b0494" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later:</source>
          <target state="translated">ISA 3.0以降から始まるPowerPCファミリのプロセッサには、以下の追加の内蔵機能も用意されています。</target>
        </trans-unit>
        <trans-unit id="8b6e450e5b4547d8cc58a1ea785d39c551b41c7f" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 14882:1998 (aka C++98) that document the exact semantics of the language extension.</source>
          <target state="translated">以下は、ISO/IEC 14882:1998 (別名 C++98)の変更点のセットで、言語拡張の正確なセマンティクスを文書化したものです。</target>
        </trans-unit>
        <trans-unit id="973ba60cc5ca780083859b39f3e2346700d51250" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 9899:1999 (aka C99) that document the exact semantics of the language extension.</source>
          <target state="translated">以下は、ISO/IEC 9899:1999(別名C99)の変更点のセットで、言語拡張の正確なセマンティクスを文書化したものです。</target>
        </trans-unit>
        <trans-unit id="ebfbe098b1dd5eca0cbfbb3ca87cce639c317631" translate="yes" xml:space="preserve">
          <source>The following attributes are available on Microsoft Windows and Symbian OS targets.</source>
          <target state="translated">以下の属性は、Microsoft Windows および Symbian OS ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="75d2d7b6e92a2c518243634b77f2438ea7a789b2" translate="yes" xml:space="preserve">
          <source>The following attributes are supported on most targets.</source>
          <target state="translated">以下の属性は、ほとんどのターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="f3abf3f6e4762f0945d50d1dadcf30c08d9bb36f" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions require</source>
          <target state="translated">以下の基本的な組み込み機能が必要です。</target>
        </trans-unit>
        <trans-unit id="e3618b6444ab4403d286bb790c65250955a9b750" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions, which are also supported on x86 targets, require</source>
          <target state="translated">以下の基本的な組み込み関数は、x86 ターゲットでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="369096374260c4b128f072244e93419c1bf1630f" translate="yes" xml:space="preserve">
          <source>The following built-in function is always available.</source>
          <target state="translated">以下のような内蔵機能を常時搭載しています。</target>
        </trans-unit>
        <trans-unit id="d0dad43e81aa335fef875c6f114a13ef9920a9d7" translate="yes" xml:space="preserve">
          <source>The following built-in function is available when</source>
          <target state="translated">以下の内蔵機能は、以下の場合に利用可能です。</target>
        </trans-unit>
        <trans-unit id="04398186d020848766aea5fdd0b1552e99124d98" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow checking if simple arithmetic operation would overflow.</source>
          <target state="translated">以下の組み込み関数では、単純な演算がオーバーフローするかどうかをチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="3c890e563c5fad880f7759533a175fe222845037" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow performing simple arithmetic operations together with checking whether the operations overflowed.</source>
          <target state="translated">以下の機能を内蔵しており、簡単な算術演算とオーバーフローしていないかのチェックを行うことができます。</target>
        </trans-unit>
        <trans-unit id="036eb93cb5a048428c65535ab685e9ef099b6ed1" translate="yes" xml:space="preserve">
          <source>The following built-in functions approximately match the requirements for the C++11 memory model. They are all identified by being prefixed with &amp;lsquo;</source>
          <target state="translated">次の組み込み関数は、C ++ 11メモリモデルの要件にほぼ一致しています。それらはすべて 'の接頭辞で識別されます</target>
        </trans-unit>
        <trans-unit id="bdf24977f571452f19f365486502e966dab5d0e9" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">以下の内蔵機能は、ISA 3.0 以降の PowerPC ファミリのプロセッサでも利用可能です (</target>
        </trans-unit>
        <trans-unit id="3d2195469599cbd3dc33d7718d1e125824d6001b" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available on all PowerPC processors:</source>
          <target state="translated">また、以下の内蔵機能は、すべてのPowerPCプロセッサで利用可能です。</target>
        </trans-unit>
        <trans-unit id="813e5a763e7aaceeb023e2843416ac3c7a436f0e" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available and can be used to check the target platform type.</source>
          <target state="translated">以下の組み込み機能が常時利用可能で、対象となるプラットフォームの種類を確認するために利用できます。</target>
        </trans-unit>
        <trans-unit id="a3a8ba0cceaa78de81b273be464b1e1bbe129653" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available.</source>
          <target state="translated">以下のような内蔵機能を常時搭載しています。</target>
        </trans-unit>
        <trans-unit id="ecfceed60efae2019076e7ea0c389384453f2603" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate a Nios II Custom Instruction. The name of the function represents the types that the function takes and returns. The letter before the &lt;code&gt;n&lt;/code&gt; is the return type or void if absent. The &lt;code&gt;n&lt;/code&gt; represents the first parameter to all the custom instructions, the custom instruction number. The two letters after the &lt;code&gt;n&lt;/code&gt; represent the up to two parameters to the function.</source>
          <target state="translated">次の組み込み関数は常に使用できます。それらはすべてNios IIカスタム命令を生成します。関数の名前は、関数が取り、返す型を表します。 &lt;code&gt;n&lt;/code&gt; の前の文字は戻り値の型、存在しない場合はvoidです。 &lt;code&gt;n&lt;/code&gt; 、すべてのカスタム命令、カスタム命令番号の最初のパラメータを表します。 &lt;code&gt;n&lt;/code&gt; の後の2文字は、関数の最大2つのパラメーターを表します。</target>
        </trans-unit>
        <trans-unit id="1af31ca0a6a69044f40261c9e3766a7bcb45f606" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate the machine instruction that is part of the name.</source>
          <target state="translated">以下の組み込み関数が常に利用可能です。これらはすべて名前の一部である機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="f2ff9df600bfad81ae439ad951e20e63358dbf59" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always with</source>
          <target state="translated">以下の内蔵機能は、常に</target>
        </trans-unit>
        <trans-unit id="458872e50bacb1837e94edbee1f56e422633f9ac" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for eBPF targets.</source>
          <target state="translated">eBPFターゲットには、以下のような機能が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="a04c80c36791193b7507cbe8aa1b633c63c489df" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">以下のビルトイン機能は、ISA 3.0 以降の PowerPC ファミリのプロセッサで利用可能です (</target>
        </trans-unit>
        <trans-unit id="f55e084e6b2bbe2c1d4a74d78f9b5a79a08af791" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on Linux 64-bit systems that use the ISA 3.0 instruction set (</source>
          <target state="translated">以下の組み込み関数は、ISA 3.0 命令セット (</target>
        </trans-unit>
        <trans-unit id="60ee9c1229ed14f7445701a16ac0e8900c850fff" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on systems that use the OSF/1 PALcode. Normally they invoke the &lt;code&gt;rduniq&lt;/code&gt; and &lt;code&gt;wruniq&lt;/code&gt; PAL calls, but when invoked with</source>
          <target state="translated">以下の組み込み関数は、OSF / 1 PALcodeを使用するシステムで使用できます。通常は &lt;code&gt;rduniq&lt;/code&gt; および &lt;code&gt;wruniq&lt;/code&gt; PAL呼び出しを呼び出しますが、</target>
        </trans-unit>
        <trans-unit id="b74dd20c718ebc6e02b444b4df3b1293b7b777b2" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when</source>
          <target state="translated">以下の内蔵機能は、以下の場合に利用可能です。</target>
        </trans-unit>
        <trans-unit id="776fae37ac2c3903c04468f14c58000c2d1da4aa" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when hardware decimal floating point (</source>
          <target state="translated">ハードウェア10進数浮動小数点(</target>
        </trans-unit>
        <trans-unit id="8714301d00c50c02cc49a9653de9815ca07de516" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.1 instructions when</source>
          <target state="translated">以下の組み込み関数が変更され、新しいSSE4.1命令が生成されるようになりました。</target>
        </trans-unit>
        <trans-unit id="b44b1444a99a16bc850f8161bf3acb0269e3baa5" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.2 instructions when</source>
          <target state="translated">以下の組み込み関数が変更され、新しいSSE4.2命令が生成されるようになりました。</target>
        </trans-unit>
        <trans-unit id="eabb92d44c62afaf48fdd22b40e596e4fd090919" translate="yes" xml:space="preserve">
          <source>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the &amp;lsquo;</source>
          <target state="translated">次の組み込み関数は、インテルItaniumプロセッサ固有のアプリケーションバイナリインターフェイス、セクション7.4で説明されているものとの互換性を目的としています。そのため、彼らは「</target>
        </trans-unit>
        <trans-unit id="831ee0ed207b248768e0caf3e133139a3eef8c8d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available by</source>
          <target state="translated">以下の内蔵機能は</target>
        </trans-unit>
        <trans-unit id="919b7b433192dee8b53ccb79ce4649060e122b82" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available either with</source>
          <target state="translated">以下の内蔵機能は、以下のいずれかの方法で利用可能です。</target>
        </trans-unit>
        <trans-unit id="6ccb74ff52e53e43a5c01fd32034e69dc2ae153d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are provided for ARC targets. The built-ins generate the corresponding assembly instructions. In the examples given below, the generated code often requires an operand or result to be in a register. Where necessary further code will be generated to ensure this is true, but for brevity this is not described in each case.</source>
          <target state="translated">ARCターゲットには、以下の組み込み機能が用意されています。ビルトインは対応するアセンブリ命令を生成します。以下の例では、生成されたコードはオペランドや結果がレジスタ内にあることを必要とすることがよくあります。必要に応じて、これが真であることを確認するためにさらにコードが生成されますが、簡潔のために各ケースでは説明していません。</target>
        </trans-unit>
        <trans-unit id="75e740a11dbfb99edbd20d26c1a8e83fccd42794" translate="yes" xml:space="preserve">
          <source>The following built-in functions are supported on the SH1, SH2, SH3 and SH4 families of processors:</source>
          <target state="translated">プロセッサのSH1、SH2、SH3、SH4ファミリーでは、以下の機能を内蔵しています。</target>
        </trans-unit>
        <trans-unit id="f89feba67398daada2fcc2ab442cabeeabf1732a" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下のビルトイン関数は、特定のMIPS DSP REV 2 命令に直接マッピングされます。各命令の動作の詳細については、 アーキテ ク チ ャ 仕様を参照 し て く だ さ い。</target>
        </trans-unit>
        <trans-unit id="f21bc507e92bf45d2cc2ac3a1f9c044c10482e71" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下のビルトイン関数は、特定のMIPS DSP 命令に直接マッピングされます。各命令の動作の詳細については、 アーキテ ク チ ャ 仕様を参照して く ださい。</target>
        </trans-unit>
        <trans-unit id="b9487d4f044e41716b6891b45e9753c6c90cda37" translate="yes" xml:space="preserve">
          <source>The following built-in spec functions are provided:</source>
          <target state="translated">以下のスペック機能を内蔵しています。</target>
        </trans-unit>
        <trans-unit id="2786d4ea3cbfa4ab2030f517cdaa8499a49060e7" translate="yes" xml:space="preserve">
          <source>The following built-in vector functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">以下の組み込みベクトル関数は、ISA 3.0 以降の PowerPC ファミリのプロセッサで利用可能です (</target>
        </trans-unit>
        <trans-unit id="1a38882cce5b0e920f7bd6e773e987b24fc62b96" translate="yes" xml:space="preserve">
          <source>The following choices of &lt;var&gt;name&lt;/var&gt; are available on AArch64 targets:</source>
          <target state="translated">AArch64ターゲットでは、次の &lt;var&gt;name&lt;/var&gt; 選択肢を使用できます。</target>
        </trans-unit>
        <trans-unit id="ffd16ee07975a361776687491f1d62adb24d9f69" translate="yes" xml:space="preserve">
          <source>The following code initializes a variable &lt;code&gt;pfoo&lt;/code&gt; located in static storage with a 24-bit address:</source>
          <target state="translated">次のコードは、静的ストレージにある変数 &lt;code&gt;pfoo&lt;/code&gt; を 24ビットアドレスで初期化します。</target>
        </trans-unit>
        <trans-unit id="8780ef62a5e7e11e92254999b8a74301b194fac1" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a case where you need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier. It uses the x86 &lt;code&gt;rdtsc&lt;/code&gt; instruction, which reads the computer&amp;rsquo;s time-stamp counter. Without the &lt;code&gt;volatile&lt;/code&gt; qualifier, the optimizers might assume that the &lt;code&gt;asm&lt;/code&gt; block will always return the same value and therefore optimize away the second call.</source>
          <target state="translated">次の例は、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用する必要がある場合を示しています。コンピューターのタイムスタンプカウンターを読み取るx86 &lt;code&gt;rdtsc&lt;/code&gt; 命令を使用します。なければ &lt;code&gt;volatile&lt;/code&gt; 修飾子、オプティマイザは、と仮定かもしれない &lt;code&gt;asm&lt;/code&gt; ブロックは常に同じ値を返すため、2回目の呼び出しを離れて最適化します。</target>
        </trans-unit>
        <trans-unit id="4b55ceed13d64aeb896ca2cdaff9ea36b6ca968e" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;asm goto&lt;/code&gt; that uses a memory clobber.</source>
          <target state="translated">次の例は、メモリクロバーを使用する &lt;code&gt;asm goto&lt;/code&gt; を示しています。</target>
        </trans-unit>
        <trans-unit id="1ff7cf2e98d1cdb33c85dfebf8c45ca797099418" translate="yes" xml:space="preserve">
          <source>The following examples are all valid uses of these attributes on Epiphany targets:</source>
          <target state="translated">以下の例は Epiphany ターゲットでこれらの属性を有効に使用しています。</target>
        </trans-unit>
        <trans-unit id="133fac7dc52d4be5d02e2ee9f610bd07e27fcb98" translate="yes" xml:space="preserve">
          <source>The following extension options are common to the listed CPUs:</source>
          <target state="translated">以下の拡張オプションは、リストアップされたCPUに共通しています。</target>
        </trans-unit>
        <trans-unit id="585cd94a6c81e37ef942855a4e92760bf2aec5f9" translate="yes" xml:space="preserve">
          <source>The following features can be detected:</source>
          <target state="translated">以下のような特徴を検出することができます。</target>
        </trans-unit>
        <trans-unit id="4cbf90dbd434ca4f2150e22b1aa4b1a78b14c334" translate="yes" xml:space="preserve">
          <source>The following floating-point built-in functions are always available. All of them implement the function that is part of the name.</source>
          <target state="translated">以下のような浮動小数点型の組み込み関数が常に利用可能です。これらの関数はすべて、名前の一部である関数を実装しています。</target>
        </trans-unit>
        <trans-unit id="e1be7f4828f104915bab6627d884213aaa11c9fc" translate="yes" xml:space="preserve">
          <source>The following functions require</source>
          <target state="translated">以下の機能が必要です。</target>
        </trans-unit>
        <trans-unit id="31dedf0887f3cce8587f9fc85d3da325ab3058ce" translate="yes" xml:space="preserve">
          <source>The following functions require option</source>
          <target state="translated">以下の機能にはオプションが必要です。</target>
        </trans-unit>
        <trans-unit id="f640e02367945c84624ea0fa79ae818fc5491bf9" translate="yes" xml:space="preserve">
          <source>The following high level HTM interface is made available by including &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">次の高レベルHTMインターフェイスは、 &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; をインクルードして使用することで利用可能になります</target>
        </trans-unit>
        <trans-unit id="102c1a366ea24351d92a6971e3810fc18f2df2f4" translate="yes" xml:space="preserve">
          <source>The following i386 example uses the &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names &lt;code&gt;aIndex&lt;/code&gt; and &lt;code&gt;aMask&lt;/code&gt; are only used in this example to emphasize which names get used where. It is acceptable to reuse the names &lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Mask&lt;/code&gt;.</source>
          <target state="translated">次のi386の例では、 &lt;var&gt;asmSymbolicName&lt;/var&gt; 構文を使用しています。上記のコードと同じ結果になりますが、オペランドを追加または削除するときにインデックス番号を並べ替える必要がないため、読みやすく、または保守しやすいと考える人もいます。この例では、 &lt;code&gt;aIndex&lt;/code&gt; と &lt;code&gt;aMask&lt;/code&gt; という名前は、どの名前がどこで使用されるかを強調するためにのみ使用されています。 &lt;code&gt;Index&lt;/code&gt; および &lt;code&gt;Mask&lt;/code&gt; という名前を再利用することは許容されます。</target>
        </trans-unit>
        <trans-unit id="b6e6249e0b2946138511bcb4a6acddccaf21d75a" translate="yes" xml:space="preserve">
          <source>The following interfaces are supported for the generic and specific AltiVec operations and the AltiVec predicates. In cases where there is a direct mapping between generic and specific operations, only the generic names are shown here, although the specific operations can also be used.</source>
          <target state="translated">AltiVec の一般的な操作と特定の操作、および AltiVec の述語については、以下のインターフェイスがサポートされています。一般的な操作と特定の操作が直接マッピングされている場合は、ここでは一般的な操作名のみを示しますが、特定の操作を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="641482ab6aae43e810063e867385af29b325d058" translate="yes" xml:space="preserve">
          <source>The following is a complete list of all the SIMD built-ins provided for ARC, grouped by calling signature.</source>
          <target state="translated">以下はARCで提供されているすべてのSIMDビルトインの完全なリストで、呼出署名でグループ化されています。</target>
        </trans-unit>
        <trans-unit id="59aaf754b53dd8275d60f36863885f1f7f538958" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved for concepts.</source>
          <target state="translated">以下のキーワードは概念に予約されています。</target>
        </trans-unit>
        <trans-unit id="1ea9055e3c282c50c68c6d2aeac0047e44355ae3" translate="yes" xml:space="preserve">
          <source>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC.</source>
          <target state="translated">以下の言語に依存しないオプションは、特定の警告を有効にはしませんが、GCC が生成する診断の種類を制御します。</target>
        </trans-unit>
        <trans-unit id="d9f20c0f07be1621f3a5ece2a524e2a15cb445a2" translate="yes" xml:space="preserve">
          <source>The following low level built-in functions are available with</source>
          <target state="translated">以下の低レベルの内蔵機能は</target>
        </trans-unit>
        <trans-unit id="b73379da25dc8349b928d96eecb55babb0495892" translate="yes" xml:space="preserve">
          <source>The following machine modes are available for use with MMX built-in functions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;): &lt;code&gt;V2SI&lt;/code&gt; for a vector of two 32-bit integers, &lt;code&gt;V4HI&lt;/code&gt; for a vector of four 16-bit integers, and &lt;code&gt;V8QI&lt;/code&gt; for a vector of eight 8-bit integers. Some of the built-in functions operate on MMX registers as a whole 64-bit entity, these use &lt;code&gt;V1DI&lt;/code&gt; as their mode.</source>
          <target state="translated">次のマシンモードがMMXで使用できる組み込み関数（参照&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル拡張機能&lt;/a&gt;）： &lt;code&gt;V2SI&lt;/code&gt; 2つの32ビット整数のベクトルのために、 &lt;code&gt;V4HI&lt;/code&gt; 4つの16ビット整数のベクトルのために、及び &lt;code&gt;V8QI&lt;/code&gt; 8個の8のベクトルのためにビット整数。一部の組み込み関数は、64ビットエンティティ全体としてMMXレジスタで動作し、これらはモードとして &lt;code&gt;V1DI&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7cf3a8e89705f68be72e746786d162672425cfef" translate="yes" xml:space="preserve">
          <source>The following multi-instruction functions are also available. In each case, &lt;var&gt;cond&lt;/var&gt; can be any of the 16 floating-point conditions: &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ueq&lt;/code&gt;, &lt;code&gt;olt&lt;/code&gt;, &lt;code&gt;ult&lt;/code&gt;, &lt;code&gt;ole&lt;/code&gt;, &lt;code&gt;ule&lt;/code&gt;, &lt;code&gt;sf&lt;/code&gt;, &lt;code&gt;ngle&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ngl&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;nge&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; or &lt;code&gt;ngt&lt;/code&gt;.</source>
          <target state="translated">以下のマルチ命令機能も利用できます。各場合において、 &lt;var&gt;cond&lt;/var&gt; ：16、浮動小数点状態のいずれかとすることができる &lt;code&gt;f&lt;/code&gt; 、 &lt;code&gt;un&lt;/code&gt; 、 &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ueq&lt;/code&gt; 、 &lt;code&gt;olt&lt;/code&gt; 、 &lt;code&gt;ult&lt;/code&gt; 、 &lt;code&gt;ole&lt;/code&gt; 、 &lt;code&gt;ule&lt;/code&gt; 、 &lt;code&gt;sf&lt;/code&gt; 、 &lt;code&gt;ngle&lt;/code&gt; 、 &lt;code&gt;seq&lt;/code&gt; 、 &lt;code&gt;ngl&lt;/code&gt; 、 &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;nge&lt;/code&gt; 、 &lt;code&gt;le&lt;/code&gt; 又は &lt;code&gt;ngt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d0ee4cac44eb1ea6ef3d346a27ca60807cc0101" translate="yes" xml:space="preserve">
          <source>The following option controls the dump verbosity:</source>
          <target state="translated">以下のオプションは、ダンプの冗長性を制御します。</target>
        </trans-unit>
        <trans-unit id="abb8267f4643a3a1e1226701a4af5aa70991f141" translate="yes" xml:space="preserve">
          <source>The following options are enabled:</source>
          <target state="translated">以下のオプションが有効になっています。</target>
        </trans-unit>
        <trans-unit id="81ad9c293f6f20ff40e11231422dcfe5f5c7994f" translate="yes" xml:space="preserve">
          <source>The following options are maintained for backward compatibility, but are now deprecated and will be removed in a future release:</source>
          <target state="translated">以下のオプションは下位互換性のために維持されていますが、現在は非推奨となっており、将来のリリースで削除される予定です。</target>
        </trans-unit>
        <trans-unit id="830e32827e2b8144f32b52b0121c8d7081e1b6a0" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the assembler, and also define preprocessor macro symbols.</source>
          <target state="translated">以下のオプションはアセンブラに渡され、プリプロセッサのマクロシンボルも定義されます。</target>
        </trans-unit>
        <trans-unit id="3893bff29544ccfaa517cc2326f9ca49c8a38aa9" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the linker:</source>
          <target state="translated">以下のオプションはリンカに渡されます。</target>
        </trans-unit>
        <trans-unit id="3c36d7938f4b3037d603daaacf0e18dc02039404" translate="yes" xml:space="preserve">
          <source>The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</source>
          <target state="translated">次のオプションは、浮動小数点演算に関するコンパイラの動作を制御します。これらのオプションは、速度と正確性の間でトレードオフになっています。すべてのオプションは特に有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="86976c9ace4c113da10573eddefe715e4cb2f672" translate="yes" xml:space="preserve">
          <source>The following options control how the assembly code is annotated:</source>
          <target state="translated">以下のオプションは、アセンブリ・コードのアノテーション方法を制御します。</target>
        </trans-unit>
        <trans-unit id="14f279a10a5e010786a9e225f2aacc08d5d8248b" translate="yes" xml:space="preserve">
          <source>The following options control optimizations that may improve performance, but are not enabled by any</source>
          <target state="translated">以下のオプションは、パフォーマンスを向上させる可能性のある最適化を制御します。</target>
        </trans-unit>
        <trans-unit id="55fd5087fff35ad2ed3317068955b447140094de" translate="yes" xml:space="preserve">
          <source>The following options control specific optimizations. They are either activated by</source>
          <target state="translated">以下のオプションは、特定の最適化を制御します。これらのオプションは</target>
        </trans-unit>
        <trans-unit id="97f1dd31a84415d7a8f21c8572a9ef06924b80bb" translate="yes" xml:space="preserve">
          <source>The following options control the analyzer.</source>
          <target state="translated">以下のオプションは、アナライザを制御します。</target>
        </trans-unit>
        <trans-unit id="d75b9b815cb70c1acb6a0a4fa3f69dee634495bb" translate="yes" xml:space="preserve">
          <source>The following options control the architecture variant for which code is being compiled:</source>
          <target state="translated">以下のオプションは、コードがコンパイルされるアーキテクチャのバリアントを制御します。</target>
        </trans-unit>
        <trans-unit id="99d7d28f2f9b185e45e491d2e2f8457796b4ee30" translate="yes" xml:space="preserve">
          <source>The following options control the dialect of C (or languages derived from C, such as C++, Objective-C and Objective-C++) that the compiler accepts:</source>
          <target state="translated">以下のオプションは、コンパイラが受け入れるC言語(またはC++、Objective-C、Objective-C++などのC言語から派生した言語)の方言を制御します。</target>
        </trans-unit>
        <trans-unit id="813aeaa760a029b92e3d877fed33fc8e7a96dc7f" translate="yes" xml:space="preserve">
          <source>The following options control the semantics of generated code:</source>
          <target state="translated">以下のオプションは、生成されたコードのセマンティクスを制御します。</target>
        </trans-unit>
        <trans-unit id="d3598ddb012ba205521fc6ee02e575b5bc46a933" translate="yes" xml:space="preserve">
          <source>The following options control which kinds of messages should be emitted:</source>
          <target state="translated">以下のオプションは、どのような種類のメッセージを送信するかを制御します。</target>
        </trans-unit>
        <trans-unit id="4d212367144c7ffb5256031004f3dbec4705f316" translate="yes" xml:space="preserve">
          <source>The following options fine tune code generation:</source>
          <target state="translated">以下のオプションは、コード生成を微調整します。</target>
        </trans-unit>
        <trans-unit id="e686313bb7d2bb5ed9fc2b2f596d5d6ba9508b34" translate="yes" xml:space="preserve">
          <source>The following paired-single functions map directly to a particular MIPS instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下のペア・シングル関数は、特定のMIPS 命令に直接マッピングされます。各命令が何をするかについての詳細は、アーキテクチャ仕様を参照してください。</target>
        </trans-unit>
        <trans-unit id="d31f26e42333950d2b2ffa071557eac8358219f6" translate="yes" xml:space="preserve">
          <source>The following pragmas are available for all architectures running the Darwin operating system. These are useful for compatibility with other Mac OS compilers.</source>
          <target state="translated">以下のプラグマは、Darwinオペレーティングシステムを実行するすべてのアーキテクチャで利用できます。これらは、他の Mac OS コンパイラとの互換性を保つのに便利です。</target>
        </trans-unit>
        <trans-unit id="5efd4f1d1fe7f21c34100607d9ffdb85cb1ed570" translate="yes" xml:space="preserve">
          <source>The following set of built-in functions are available to gain access to the HTM specific special purpose registers.</source>
          <target state="translated">以下の組み込み関数のセットは、HTM 固有の特殊目的レジスタへのアクセスを得るために利用可能です。</target>
        </trans-unit>
        <trans-unit id="fe37409b5b6fb37c45d0db10dbe34cd37d4dfd29" translate="yes" xml:space="preserve">
          <source>The following statements are identical:</source>
          <target state="translated">以下の記述は同一である。</target>
        </trans-unit>
        <trans-unit id="4c95f76a6048996b1dcedbb4002de26c05b62460" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and three &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile-time constant, identifying the 16-bit sub-register to be stored, the third argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the fourth argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下は、 &lt;code&gt;__v8hi&lt;/code&gt; 引数と3つの &lt;code&gt;int&lt;/code&gt; 引数を取り、結果を返しません。2番目の引数は、格納する16ビットサブレジスタを識別する3ビットのコンパイル時定数である必要があります。3番目の引数は、レジスタI0〜I7、および4番目のレジスタを示す3ビットのコンパイル時定数である必要があります。引数は、8ビットのコンパイル時定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5da4f813451b70864b4ac68a9c6bb25ff058833e" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下は、 &lt;code&gt;__v8hi&lt;/code&gt; 引数と2つの &lt;code&gt;int&lt;/code&gt; 引数を取り、__ &lt;code&gt;__v8hi&lt;/code&gt; 結果を返します。2番目の引数は、レジスタI0〜I7の1つを示す3ビットのコンパイル時定数でなければならず、3番目の引数は8ビットのコンパイル時定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="559f51894eceb199907d056ff4f4a6285c76d1d1" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下は、 &lt;code&gt;__v8hi&lt;/code&gt; 引数と2つの &lt;code&gt;int&lt;/code&gt; 引数を取り、結果を返しません。2番目の引数は、レジスタI0〜I7の1つを示す3ビットのコンパイル時定数でなければならず、3番目の引数は8ビットのコンパイル時定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="19babaec618194855f5c8b00e66e42a23a7c9b80" translate="yes" xml:space="preserve">
          <source>The following take a single &lt;code&gt;__v8hi&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下は、単一の &lt;code&gt;__v8hi&lt;/code&gt; 引数を取り、 &lt;code&gt;__v8hi&lt;/code&gt; 結果を返します。</target>
        </trans-unit>
        <trans-unit id="24b4a9f9391a5e9fb5aa4cf91d4033a4a1ba3911" translate="yes" xml:space="preserve">
          <source>The following take an &lt;code&gt;int&lt;/code&gt; argument and return no result:</source>
          <target state="translated">以下は、 &lt;code&gt;int&lt;/code&gt; 引数を取り、結果を返しません。</target>
        </trans-unit>
        <trans-unit id="1708876febe0e46c893dfd70681ac1b1b3aa8762" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; and one &lt;code&gt;int&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">次の例では、1つの &lt;code&gt;__v8hi&lt;/code&gt; 引数と1つの &lt;code&gt;int&lt;/code&gt; 引数を取り、 &lt;code&gt;__v8hi&lt;/code&gt; 結果を返します。</target>
        </trans-unit>
        <trans-unit id="3ad9bd81f972d4f83266bbddb59970dde24eddc0" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 3-bit compile time constant indicating a register number I0-I7. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下は、1つの &lt;code&gt;__v8hi&lt;/code&gt; 引数と1つの &lt;code&gt;int&lt;/code&gt; 引数を取ります。これらの引数は、レジスタ番号I0〜I7を示す3ビットのコンパイル時定数でなければなりません。 &lt;code&gt;__v8hi&lt;/code&gt; の結果を返します。</target>
        </trans-unit>
        <trans-unit id="bc2a1ecceb07161357bd0a5bf4b1cca5ccc19add" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 6-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下は、1つの &lt;code&gt;__v8hi&lt;/code&gt; 引数と、6ビットのコンパイル時定数でなければならない1つの &lt;code&gt;int&lt;/code&gt; 引数を取ります。 &lt;code&gt;__v8hi&lt;/code&gt; の結果を返します。</target>
        </trans-unit>
        <trans-unit id="c720afe018ece35380697d65f42b49460f2c3700" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下は、1つの &lt;code&gt;__v8hi&lt;/code&gt; 引数と、8ビットのコンパイル時定数でなければならない1つの &lt;code&gt;int&lt;/code&gt; 引数を取ります。 &lt;code&gt;__v8hi&lt;/code&gt; の結果を返します。</target>
        </trans-unit>
        <trans-unit id="0015b52d89388ff44035be55e55280be0b4aaeb6" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;__v8hi&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下は、2つの &lt;code&gt;__v8hi&lt;/code&gt; 引数を取り、 &lt;code&gt;__v8hi&lt;/code&gt; 結果を返します。</target>
        </trans-unit>
        <trans-unit id="074063c3bbf2515afebb90aeb39ce860c2e31da4" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The first argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the second argument must be an 8-bit compile time constant.</source>
          <target state="translated">次の例では、2つの &lt;code&gt;int&lt;/code&gt; 引数を取り、 &lt;code&gt;__v8hi&lt;/code&gt; の結果を返します。最初の引数は、レジスタI0〜I7の1つを示す3ビットのコンパイル時定数でなければならず、2番目の引数は8ビットのコンパイル時定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e5b1b82914edb80d2ca00848561437d84a1f1eb2" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The first argument must a 3-bit compile time constant indicating one of the DR0-DR7 DMA setup channels:</source>
          <target state="translated">以下は2つの &lt;code&gt;int&lt;/code&gt; 引数を取り、結果を返しません。最初の引数は、DR0-DR7 DMAセットアップチャネルの1つを示す3ビットのコンパイル時定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="14c057c170ec53d564774b373c4a36cf121034de" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result:</source>
          <target state="translated">以下は2つの &lt;code&gt;int&lt;/code&gt; 引数を取り、結果を返しません。</target>
        </trans-unit>
        <trans-unit id="c73d90b3764a03700faea9b5a80499c3a3c6ee74" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments, the second of which which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下は2つの &lt;code&gt;int&lt;/code&gt; 引数を取ります。2 番目の引数は8ビットのコンパイル時定数でなければなりません。それらは &lt;code&gt;__v8hi&lt;/code&gt; 結果を返します：</target>
        </trans-unit>
        <trans-unit id="7604a9689ceddf3a88ac390cfb640c35daa9929f" translate="yes" xml:space="preserve">
          <source>The following target-specific function attributes are available for the AArch64 target. For the most part, these options mirror the behavior of similar command-line options (see &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;), but on a per-function basis.</source>
          <target state="translated">AArch64ターゲットでは、次のターゲット固有の関数属性を使用できます。ほとんどの場合、これらのオプションは、同様のコマンドラインオプション（&lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64オプションを&lt;/a&gt;参照）の動作を反映していますが、関数ごとに異なります。</target>
        </trans-unit>
        <trans-unit id="2a9dcb7afea2063b88c3f0d0bf8b210d678cf434" translate="yes" xml:space="preserve">
          <source>The following type attributes are supported on most targets.</source>
          <target state="translated">以下のタイプ属性は、ほとんどのターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7ea3e81960cea1d06fa9fca33b75a29a1d4f2d4a" translate="yes" xml:space="preserve">
          <source>The following values of &lt;var&gt;insn&lt;/var&gt; are supported. Except as otherwise noted, floating-point operations are expected to be implemented with normal IEEE 754 semantics and correspond directly to the C operators or the equivalent GCC built-in functions (see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;insn&lt;/var&gt; の以下の値がサポートされています。特に明記しない限り、浮動小数点演算は通常のIEEE 754セマンティクスで実装され、C演算子または同等のGCC &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;組み込み&lt;/a&gt;関数に直接対応することが期待されます（他の組み込み関数を参照）。</target>
        </trans-unit>
        <trans-unit id="da10b4f1472639ab267cde98b6118ed2bb143912" translate="yes" xml:space="preserve">
          <source>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library&amp;rsquo;s limitations. However, if</source>
          <target state="translated">フォーマットは、GNU libcバージョン2.2でサポートされているフォーマット機能に対してチェックされます。これらには、ISO C90およびC99のすべての機能、およびSingle Unix Specificationの機能と一部のBSDおよびGNU拡張機能が含まれます。他のライブラリの実装では、これらの機能をすべてサポートしていない場合があります。 GCCは、特定のライブラリの制限を超える機能に関する警告をサポートしていません。ただし、</target>
        </trans-unit>
        <trans-unit id="3fd329b7b6e510f8c7f38ab04501976f2c6f4c71" translate="yes" xml:space="preserve">
          <source>The forwarding method implementation thus created is returned by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; and is executed as if it was a normal method implementation. When the forwarding method implementation is called, it is usually expected to pack all arguments into some sort of object (typically, an &lt;code&gt;NSInvocation&lt;/code&gt; in a &amp;ldquo;Foundation&amp;rdquo; library), and hand it over to the programmer (&lt;code&gt;forwardInvocation:&lt;/code&gt;) who is then allowed to manipulate the method invocation using a high-level API provided by the &amp;ldquo;Foundation&amp;rdquo; library. For example, the programmer may want to examine the method invocation arguments and name and potentially change them before forwarding the method invocation to one or more local objects (&lt;code&gt;performInvocation:&lt;/code&gt;) or even to remote objects (by using Distributed Objects or some other mechanism). When all this completes, the return value is passed back and must be returned correctly to the original caller.</source>
          <target state="translated">このようにして作成された転送メソッド実装は、 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; によって返され、通常のメソッド実装であるかのように実行されます。転送メソッドの実装が呼び出されると、通常、すべての引数をある種のオブジェクト（通常、「Foundation」ライブラリの &lt;code&gt;NSInvocation&lt;/code&gt; )にパックし、それをプログラマー（ &lt;code&gt;forwardInvocation:&lt;/code&gt; )に渡して、 「Foundation」ライブラリによって提供される高レベルAPIを使用してメソッド呼び出しを操作します。たとえば、プログラマーは、メソッド呼び出しの引数と名前を調べ、メソッド呼び出しを1つまたは複数のローカルオブジェクトに転送する前にそれらを変更することができます（ &lt;code&gt;performInvocation:&lt;/code&gt; ）またはリモートオブジェクトに対して（分散オブジェクトまたはその他のメカニズムを使用して）。これがすべて完了すると、戻り値が返され、元の呼び出し元に正しく返される必要があります。</target>
        </trans-unit>
        <trans-unit id="370cce3123cd6103545b49952aa7ecfe80d28686" translate="yes" xml:space="preserve">
          <source>The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. It uses the lock-free built-in function if the specific data type size makes that possible; otherwise, an external call is left to be resolved at run time. This external call is the same format with the addition of a &amp;lsquo;</source>
          <target state="translated">4つの非算術関数（load、store、exchange、compare_exchange）には、すべてジェネリックバージョンもあります。この汎用バージョンは、あらゆるデータタイプで機能します。特定のデータ型サイズで可能であれば、ロックフリーの組み込み関数を使用します。そうでない場合、外部呼び出しは実行時に解決されます。この外部呼び出しは、 'を追加した同じ形式です。</target>
        </trans-unit>
        <trans-unit id="bc7082dbfb46d172471e10794421761522292732" translate="yes" xml:space="preserve">
          <source>The frame is the area on the stack that holds local variables and saved registers. The frame address is normally the address of the first word pushed on to the stack by the function. However, the exact definition depends upon the processor and the calling convention. If the processor has a dedicated frame pointer register, and the function has a frame, then &lt;code&gt;__builtin_frame_address&lt;/code&gt; returns the value of the frame pointer register.</source>
          <target state="translated">フレームは、ローカル変数と保存されたレジスタを保持するスタック上の領域です。フレームアドレスは通常、関数によってスタックにプッシュされる最初のワードのアドレスです。ただし、正確な定義は、プロセッサと呼び出し規約によって異なります。プロセッサに専用のフレームポインタレジスタがあり、関数にフレームがある場合、 &lt;code&gt;__builtin_frame_address&lt;/code&gt; はフレームポインタレジスタの値を返します。</target>
        </trans-unit>
        <trans-unit id="91be25b4a97f2d4dcdca61df07841207c68074ea" translate="yes" xml:space="preserve">
          <source>The front end also exposes a number of internal mechanism that can be used to simplify the writing of type traits. Note that some of these traits are likely to be removed in the future.</source>
          <target state="translated">フロントエンドはまた、型の形質の記述を簡素化するために使用できる多くの内部機構を公開しています。これらの特徴のいくつかは将来的に削除される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0002fd6e851a03368550f6c8393985028e5a22a9" translate="yes" xml:space="preserve">
          <source>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case &lt;var&gt;val&lt;/var&gt; can be returned, as above); or</source>
          <target state="translated">関数は、コードが投機的に実行されなくなったことがわかるまで、実行を一時停止させる場合があります（この場合、上記のように &lt;var&gt;val&lt;/var&gt; が返されます）。または</target>
        </trans-unit>
        <trans-unit id="c285a5c6cfe9015607ff4a0e2ac733ad987d0e25" translate="yes" xml:space="preserve">
          <source>The function may use target-dependent speculation tracking state to cause &lt;var&gt;failval&lt;/var&gt; to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation.</source>
          <target state="translated">関数は、投機的実行が条件付き分岐演算を誤って予測したことがわかっている場合に、ターゲットに依存する投機追跡状態を使用して &lt;var&gt;failval&lt;/var&gt; を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="1910cbf4d249572210143c348f1416c66e710621" translate="yes" xml:space="preserve">
          <source>The function parameter denoting the allocated alignment is specified by one constant integer argument whose number is the argument of the attribute. Argument numbering starts at one.</source>
          <target state="translated">割り当てられたアラインメントを表す関数パラメータは、属性の引数である数が整数の定数1個の引数で指定されます。引数の番号は1から始まります。</target>
        </trans-unit>
        <trans-unit id="3b052040572f76188271e0e3e0c80c35be66f2c8" translate="yes" xml:space="preserve">
          <source>The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one for ordinary functions, and at two for C++ non-static member functions.</source>
          <target state="translated">割り当てられたサイズを示す関数パラメータは、属性に与えられた 1 つまたは 2 つの整数の引数で指定される。割り当てられるサイズは、指定された 1 つの関数引数の値、または指定された 2 つの関数引数の積のいずれかです。引数の番号付けは、通常の関数の場合は 1 から始まり、C++の非静的メンバ関数の場合は 2 から始まります。</target>
        </trans-unit>
        <trans-unit id="0ca979696b9a2800aa34523d4083bf5a14d799aa" translate="yes" xml:space="preserve">
          <source>The function saves the arg pointer register, structure value address, and all registers that might be used to pass arguments to a function into a block of memory allocated on the stack. Then it returns the address of that block.</source>
          <target state="translated">この関数は,引数ポインタレジスタ,構造体値アドレス,関数に引数を渡すために使用される可能性のあるすべてのレジスタを,スタック上に確保されたメモリブロックに保存します.そして、そのブロックのアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="6872e4d72d8fbbd9743faadfaad51d5d8e08d8dc" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V I-type instructions.</source>
          <target state="translated">以下の機能はFR-V I型の説明書に直接対応しています。</target>
        </trans-unit>
        <trans-unit id="c602f6bdf5c7225fe620c26f84e8de50c7071a07" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V M-type instructions.</source>
          <target state="translated">以下の機能はFR-V M型の説明書に直接対応しています。</target>
        </trans-unit>
        <trans-unit id="d757b37f17b7bb17dc67a24428e9f56b268f5c5e" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to a particular MIPS-3D instruction. Please refer to the architecture specification for more details on what each instruction does.</source>
          <target state="translated">以下に示す機能は、特定のMIPS-3D命令に直接対応しています。各命令の動作の詳細については、アーキテクチャ仕様書を参照してください。</target>
        </trans-unit>
        <trans-unit id="636b8102a37675bf78355f0f6bba2ff462438334" translate="yes" xml:space="preserve">
          <source>The functions supported are:</source>
          <target state="translated">対応している機能は</target>
        </trans-unit>
        <trans-unit id="ad7023ac286f3db88bfb11b7cae18fc097b31af2" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension and the half-precision floating-point fmla extension.</source>
          <target state="translated">半精度浮動小数点データ処理命令です。これにより、高度なSIMD命令や浮動小数点命令だけでなく、ドットプロダクト拡張や半精度浮動小数点fmla拡張も可能になります。</target>
        </trans-unit>
        <trans-unit id="58f4f715483c2871dde2ce2ca0d2db8aca84c869" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">半精度浮動小数点データ処理命令です。これにより、Advanced SIMD命令や浮動小数点命令も可能になります。</target>
        </trans-unit>
        <trans-unit id="11520bb64917989439d0bd1e50b448954652e968" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point fmla extension. This also enables the half-precision floating-point extension and Advanced SIMD and floating-point instructions.</source>
          <target state="translated">半精度浮動小数点fmla拡張です。これにより、半精度浮動小数点拡張とAdvanced SIMDと浮動小数点命令も可能になります。</target>
        </trans-unit>
        <trans-unit id="ddd47b9fa117c203d0b4afbba7a0a4bc59d68406" translate="yes" xml:space="preserve">
          <source>The hardware multiply routines disable interrupts whilst running and restore the previous interrupt state when they finish. This makes them safe to use inside interrupt handlers as well as in normal code.</source>
          <target state="translated">ハードウェア乗算ルーチンは、実行中は割り込みを無効にし、終了時に前の割り込み状態に戻します。これにより、通常のコードと同様に割り込みハンドラ内でも安全に使用することができます。</target>
        </trans-unit>
        <trans-unit id="1700f28ed95fcc91e5f3613066db6eabb50e9b1f" translate="yes" xml:space="preserve">
          <source>The header files contain detailed documentation for each function in the GNU Objective-C runtime API.</source>
          <target state="translated">ヘッダファイルには、GNU Objective-C ランタイム API の各関数の詳細なドキュメントが含まれています。</target>
        </trans-unit>
        <trans-unit id="bef3ae0649be61ff8ea14c16eb476e462ede9be4" translate="yes" xml:space="preserve">
          <source>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction</source>
          <target state="translated">命令から 4GB 以内のシンボルの PC 相対アドレスの上位部分(ビット 12 以降)。</target>
        </trans-unit>
        <trans-unit id="ea0d4a97e0e09b3d462961a102c172f60bf94df3" translate="yes" xml:space="preserve">
          <source>The iWMMX GR registers.</source>
          <target state="translated">iWMMXのGRレジスタです。</target>
        </trans-unit>
        <trans-unit id="2ad23a41b556be75b4554217ab7b7da89d6570d2" translate="yes" xml:space="preserve">
          <source>The iWMMX co-processor registers.</source>
          <target state="translated">iWMMXコプロセッサのレジスタです。</target>
        </trans-unit>
        <trans-unit id="b46a70e92f765a7f4dbecade6890d0ae606db8e1" translate="yes" xml:space="preserve">
          <source>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that&amp;rsquo;s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken.</source>
          <target state="translated">この背後にある考え方は、浮動小数点値を無限に正確な実数の近似値と見なすことが（プログラマにとって）便利な場合があるということです。これを実行している場合は、（コードを分析するなどの方法で）計算によって生じる最大またはおそらく最大のエラーを計算し、比較を実行するとき（および出力を生成するとき）にそれを許可する必要がありますが、それは別の問題）。特に、等しいかどうかをテストする代わりに、2つの値に重複する範囲があるかどうかを確認する必要があります。これは関係演算子で行われるため、等価比較はおそらく間違っています。</target>
        </trans-unit>
        <trans-unit id="c0a98af2de248cc10c278826d9411559e39eee26" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;__func__&lt;/code&gt; is implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration</source>
          <target state="translated">識別子 &lt;code&gt;__func__&lt;/code&gt; は、各関数定義の左中括弧の直後に、宣言が</target>
        </trans-unit>
        <trans-unit id="13fbfb86cc636b25b4f8dbf9788be6becd2407c7" translate="yes" xml:space="preserve">
          <source>The immediate value 0x01.</source>
          <target state="translated">即時値 0x01。</target>
        </trans-unit>
        <trans-unit id="52de78dd0ef761fa638ed2df23930f5359ca4c01" translate="yes" xml:space="preserve">
          <source>The immediate value 0x7ff.</source>
          <target state="translated">即時値 0x7ff。</target>
        </trans-unit>
        <trans-unit id="178295c2520a8328225a3e14f6430b205aa477b7" translate="yes" xml:space="preserve">
          <source>The immediate value 0xff.</source>
          <target state="translated">即時値0xff。</target>
        </trans-unit>
        <trans-unit id="ba38c21b26ea7ac3618ca4682f483633c0168822" translate="yes" xml:space="preserve">
          <source>The immediate value 0xffff.</source>
          <target state="translated">即時値 0xffff。</target>
        </trans-unit>
        <trans-unit id="f3edc2d2bcd9f411eb9c02f201cf5906b594ce1b" translate="yes" xml:space="preserve">
          <source>The immediate value that can be simply set high 20-bit.</source>
          <target state="translated">単純に20ビットを高く設定できる即値。</target>
        </trans-unit>
        <trans-unit id="f3b3ce3b975ce4bb65c0a8ad20428b556134b6e5" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2 minus 1.</source>
          <target state="translated">2の累乗マイナス1の即値。</target>
        </trans-unit>
        <trans-unit id="cdad57dc1c93e8c86249089910e5d64e47612ed8" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2.</source>
          <target state="translated">2の力を持つ即値。</target>
        </trans-unit>
        <trans-unit id="292bc2fc3bad9eb92ff6853193b506ffc6d78c40" translate="yes" xml:space="preserve">
          <source>The impacted functions are determined by the compiler&amp;rsquo;s interprocedural optimizations. For example, a caller is impacted when inlining a function into its caller, cloning a function and changing its caller to call this new clone, or extracting a function&amp;rsquo;s pureness/constness information to optimize its direct or indirect callers, etc.</source>
          <target state="translated">影響を受ける関数は、コンパイラーのプロシージャー間の最適化によって決定されます。たとえば、関数を呼び出し元にインライン化するとき、関数を複製してこの新しいクローンを呼び出すように呼び出し元を変更するとき、または直接または間接の呼び出し元を最適化するために関数の純粋性/一貫性情報を抽出するとき、呼び出し元は影響を受けます。</target>
        </trans-unit>
        <trans-unit id="788e9c101326291dabb53f85af22d398e9b836ec" translate="yes" xml:space="preserve">
          <source>The implementation of messaging in the GNU Objective-C runtime is designed to be portable, and so is based on standard C.</source>
          <target state="translated">GNU Objective-C ランタイムにおけるメッセージングの実装は、移植性を考慮して設計されており、標準 C をベースにしています。</target>
        </trans-unit>
        <trans-unit id="4de99bcf5ddd6a719a8ac7733daede651bd9f548" translate="yes" xml:space="preserve">
          <source>The important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link step. GCC automatically performs link-time optimization if any of the objects involved were compiled with the</source>
          <target state="translated">注意すべき重要なことは、リンク時間の最適化を有効にするには、リンクステップを実行するためにGCCドライバを使用する必要があるということです。GCC は、関係するオブジェクトのいずれかが</target>
        </trans-unit>
        <trans-unit id="9a2b4fb08fe8eee4956db02cb6f8d3c3fb54b6e4" translate="yes" xml:space="preserve">
          <source>The index values must be constant expressions, even if the array being initialized is automatic.</source>
          <target state="translated">初期化される配列が自動であっても、インデックスの値は定数式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="20238db563baf6821f8bed87f8777e30be3fd316" translate="yes" xml:space="preserve">
          <source>The induction variable optimizations give up on loops that contain more induction variable uses.</source>
          <target state="translated">誘導変数の最適化は、より多くの誘導変数の使用を含むループをあきらめます。</target>
        </trans-unit>
        <trans-unit id="99b9ae56dc4f69f455cd2846f1efc86548a4f0b0" translate="yes" xml:space="preserve">
          <source>The instructions generated by the following builtins are not considered as candidates for scheduling. They are not moved around by the compiler during scheduling, and thus can be expected to appear where they are put in the C code:</source>
          <target state="translated">以下のビルトインによって生成された命令は、スケジューリングの候補とはみなされません。これらの命令はスケジューリング中にコンパイラによって移動されることはありません。</target>
        </trans-unit>
        <trans-unit id="0143a1fa40596d46b920e516a49bccafb05c6756" translate="yes" xml:space="preserve">
          <source>The integer constant -1.</source>
          <target state="translated">整数定数-1。</target>
        </trans-unit>
        <trans-unit id="0304e4a19fa9d570fa64154ef073c85be9e9d234" translate="yes" xml:space="preserve">
          <source>The integer constant -2.</source>
          <target state="translated">整数定数-2。</target>
        </trans-unit>
        <trans-unit id="20219359f9654d4bb60ad841282922f1407f31ff" translate="yes" xml:space="preserve">
          <source>The integer constant 0.</source>
          <target state="translated">整数定数0。</target>
        </trans-unit>
        <trans-unit id="84b9a3c5e77c93a53f2664cad25c5af25a563160" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff.</source>
          <target state="translated">整数定数 0xffffffff。</target>
        </trans-unit>
        <trans-unit id="0900ba8234ff692dd368ac2562960d9c24b87490" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff00000000.</source>
          <target state="translated">整数定数 0xffffffff00000000。</target>
        </trans-unit>
        <trans-unit id="1704120ef6a8406a0d73d119b3bae3d2fd6db0c7" translate="yes" xml:space="preserve">
          <source>The integer constant 1.</source>
          <target state="translated">整数定数1である。</target>
        </trans-unit>
        <trans-unit id="f7733e70947e25f6ba4f15b855fbc6bb56230e77" translate="yes" xml:space="preserve">
          <source>The integer constant 2.</source>
          <target state="translated">整数定数2である。</target>
        </trans-unit>
        <trans-unit id="2e4afdbd5f6f64969b9a9086ed5845106d1e1df4" translate="yes" xml:space="preserve">
          <source>The integer type compatible with each enumerated type (C90 6.5.2.2, C99 and C11 6.7.2.2).</source>
          <target state="translated">各列挙型と互換性のある整数型(C90 6.5.2.2,C99,C11 6.7.2.2)。</target>
        </trans-unit>
        <trans-unit id="d4f4c82404325b1bedf2b678bda8824c1372dc16" translate="yes" xml:space="preserve">
          <source>The integer zero constant.</source>
          <target state="translated">整数のゼロ定数。</target>
        </trans-unit>
        <trans-unit id="7f5eb05da6eb2941255dd1f24db7755004fe0fb6" translate="yes" xml:space="preserve">
          <source>The intended use can be e.g.</source>
          <target state="translated">意図された用途は、例えば、以下のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="eec03e559122067c46321a3d23e2fe242aaa628b" translate="yes" xml:space="preserve">
          <source>The intrinsic &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; is used to guarantee that no network operations before it are reordered with those after it.</source>
          <target state="translated">組み込みの &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; は、前のネットワーク操作が後のネットワーク操作と並べ替えられないことを保証するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2b326f68cedc113119b7cfc329617004f7ca5d0f" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction to which it corresponds, with suffixes added as appropriate to distinguish intrinsics that expand to the same machine instruction yet have different argument types. Refer to the architecture documentation for a description of the functionality of each instruction.</source>
          <target state="translated">それぞれの名前は対応するマシン命令にちなんで付けられていますが、同じマシン命令に拡張されていても引数のタイプが異なる本質を区別するために適切な接尾辞が付け加えられています。各命令の機能の説明については、アーキテクチャのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3a0e26ddf5eff18eeea3fbd0b9d1cb136b8b4213" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction.</source>
          <target state="translated">提供される本質的なものは以下の通りで、それぞれが機械命令にちなんで命名されています。</target>
        </trans-unit>
        <trans-unit id="3eef6d5321de2f795448068015c7c54f1ed1296f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;@compatibility_alias&lt;/code&gt; allows you to define a class name as equivalent to another class name. For example:</source>
          <target state="translated">キーワード &lt;code&gt;@compatibility_alias&lt;/code&gt; を使用すると、クラス名を別のクラス名と同等のものとして定義できます。例えば：</target>
        </trans-unit>
        <trans-unit id="dae34f2a2b2a52f07242474e58c01e8458c373a3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__alignof__&lt;/code&gt; determines the alignment requirement of a function, object, or a type, or the minimum alignment usually required by a type. Its syntax is just like &lt;code&gt;sizeof&lt;/code&gt; and C11 &lt;code&gt;_Alignof&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;__alignof__&lt;/code&gt; は、関数、オブジェクト、または型の整列要件、または型で通常必要とされる最小の整列を決定します。構文は &lt;code&gt;sizeof&lt;/code&gt; やC11 &lt;code&gt;_Alignof&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="0e11754fcd951a085d6544dab003aaba8cd78a6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify special properties of variables, function parameters, or structure, union, and, in C++, class members. This &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses. Some attributes are currently defined generically for variables. Other attributes are defined for variables on particular target systems. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;). Other front ends might define more attributes (see &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;).</source>
          <target state="translated">キーワード &lt;code&gt;__attribute__&lt;/code&gt; を使用すると、変数、関数パラメーター、または構造体、共用体、さらにC ++ではクラスメンバーの特別なプロパティを指定できます。この &lt;code&gt;__attribute__&lt;/code&gt; キーワードの後に​​は、二重括弧で囲まれた属性指定が続きます。現在、一部の属性は変数に対して一般的に定義されています。その他の属性は、特定のターゲットシステム上の変数に対して定義されます。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、およびタイプ（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）で使用できます。他のフロントエンドは、より多くの属性を定義する場合があります（&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++言語の拡張機能&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4cf059503889f054506ae99e86330f0d94efc6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify various special properties of types. Some type attributes apply only to structure and union types, and in C++, also class types, while others can apply to any type defined via a &lt;code&gt;typedef&lt;/code&gt; declaration. Unless otherwise specified, the same restrictions and effects apply to attributes regardless of whether a type is a trivial structure or a C++ class with user-defined constructors, destructors, or a copy assignment.</source>
          <target state="translated">キーワード &lt;code&gt;__attribute__&lt;/code&gt; を使用すると、タイプのさまざまな特別なプロパティを指定できます。一部の型属性は構造体型と共用体型にのみ適用され、C ++ではクラス型にも適用できますが、 &lt;code&gt;typedef&lt;/code&gt; 宣言によって定義された任意の型に適用できるものもあります。特に指定のない限り、型が自明な構造であるか、ユーザー定義のコンストラクター、デストラクター、またはコピー割り当てを持つC ++クラスであるかに関係なく、同じ制限と効果が属性に適用されます。</target>
        </trans-unit>
        <trans-unit id="1572dc96be7f5e014878efc69fdfd49b0ae87eea" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__thread&lt;/code&gt; applied to a non-local object gives the object thread storage duration.</source>
          <target state="translated">非ローカルオブジェクトにキーワード &lt;code&gt;__thread&lt;/code&gt; を適用すると、オブジェクトスレッドの保存期間が与えられます。</target>
        </trans-unit>
        <trans-unit id="39b19603ff8ee793099ac42a05990562491ebaf2" translate="yes" xml:space="preserve">
          <source>The label declaration defines the label &lt;em&gt;name&lt;/em&gt;, but does not define the label itself. You must do this in the usual way, with &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt;, within the statements of the statement expression.</source>
          <target state="translated">ラベル宣言はラベル&lt;em&gt;名を&lt;/em&gt;定義しますが、ラベル自体は定義しません。ステートメント式のステートメント内で、 &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt; を使用して通常の方法でこれを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="428f4e4c9e8e6a37b249e009bb97c82a44c2fb8f" translate="yes" xml:space="preserve">
          <source>The language-independent component of GCC includes the majority of the optimizers, as well as the &amp;ldquo;back ends&amp;rdquo; that generate machine code for various processors.</source>
          <target state="translated">GCCの言語に依存しないコンポーネントには、オプティマイザの大部分と、さまざまなプロセッサのマシンコードを生成する「バックエンド」が含まれています。</target>
        </trans-unit>
        <trans-unit id="005fac6b181ca927cb2a738c000f5da953afe1b7" translate="yes" xml:space="preserve">
          <source>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type &lt;code&gt;void&lt;/code&gt;, and thus effectively no value.)</source>
          <target state="translated">複合ステートメントの最後は、セミコロンが後に続く式でなければなりません。この部分式の値は、構成全体の値として機能します。（他の種類のステートメントを中括弧内で最後に使用する場合、構文は &lt;code&gt;void&lt;/code&gt; 型になるため、実質的に値はありません。）</target>
        </trans-unit>
        <trans-unit id="206e1d46d7d3ee120b67ca48c1a3f104346b70ef" translate="yes" xml:space="preserve">
          <source>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with &lt;code&gt;sizeof&lt;/code&gt;.</source>
          <target state="translated">配列の長さは、ストレージが割り当てられたときに一度計算され、 &lt;code&gt;sizeof&lt;/code&gt; でアクセスした場合に備えて、配列のスコープとして記憶されます。</target>
        </trans-unit>
        <trans-unit id="ce058b55eed72e669ebdbd6e3aba9093499b97c5" translate="yes" xml:space="preserve">
          <source>The letters represent the following data types:</source>
          <target state="translated">文字は以下のデータ型を表しています。</target>
        </trans-unit>
        <trans-unit id="77263b459d57cfcd71f0acd14e32e54e7be714c9" translate="yes" xml:space="preserve">
          <source>The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries&amp;rsquo; stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.</source>
          <target state="translated">一時的に生成されるコンパイラーの存続期間は、C ++標準によって明確に定義されています。一時変数の存続期間が終了し、一時変数がメモリーに存在する場合、最適化コンパイラーは、そのスタック領域を他の一時変数またはそのライブ範囲が重複しないスコープ付きローカル変数で自由に再利用できます。ただし、一部のレガシーコードは、一時的なスタックスペースが再利用されない古いコンパイラの動作に依存しているため、積極的なスタックの再利用により、ランタイムエラーが発生する可能性があります。このオプションは、一時的なスタック再利用の最適化を制御するために使用されます。</target>
        </trans-unit>
        <trans-unit id="499ee472bf57c8d5ea52c4b866109362dfcc7841" translate="yes" xml:space="preserve">
          <source>The limit applies &lt;em&gt;after&lt;/em&gt; string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++.</source>
          <target state="translated">この制限は文字列定数の連結&lt;em&gt;後に&lt;/em&gt;適用さ&lt;em&gt;れ&lt;/em&gt;、末尾のNULはカウントされません。C90では、制限は509文字でした。C99では、それは4095に引き上げられました。C++ 98は規範的な最小の最大値を指定しないため、C ++では長すぎる文字列を診断しません。</target>
        </trans-unit>
        <trans-unit id="e6c688d4fc373af85820537cf244755f93f3571e" translate="yes" xml:space="preserve">
          <source>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much.</source>
          <target state="translated">大きなスタックフレームを指定する限界。インライン化している間は、アルゴリズムはこの限界をあまり超えないようにしようとしています。</target>
        </trans-unit>
        <trans-unit id="85f90ab304447934cd7fe1bd66dac4bb5697c076" translate="yes" xml:space="preserve">
          <source>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by</source>
          <target state="translated">大きな翻訳単位を指定する限界値です。この制限値より大きい単位のインライン化による成長は</target>
        </trans-unit>
        <trans-unit id="24d66aaeb77b8d51a696a30383b9a88d8d0ffec4" translate="yes" xml:space="preserve">
          <source>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by</source>
          <target state="translated">本当に大きな関数を指定する限界値。インライン化後にこの制限値よりも大きい関数の場合、インライン化は</target>
        </trans-unit>
        <trans-unit id="c3e28be9ccc81004da7fffd01a2901be4871fc54" translate="yes" xml:space="preserve">
          <source>The link register, &lt;code&gt;lr&lt;/code&gt;.</source>
          <target state="translated">リンクレジスタ、 &lt;code&gt;lr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f2bb016c8b0766650946224b7ac36870093175" translate="yes" xml:space="preserve">
          <source>The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with</source>
          <target state="translated">リンカは、ライブラリのディレクトリの標準リストを検索します。検索されるディレクトリには、いくつかの標準的なシステム・ディレクトリと</target>
        </trans-unit>
        <trans-unit id="78e4e4eb1e36ecbe1ce8c7bd81da2158dd82d6a9" translate="yes" xml:space="preserve">
          <source>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.</source>
          <target state="translated">SPU 用のローダーは動的な再配置を処理しません。デフォルトでは、動的な再配置を必要とするコードを生成すると、GCC はエラーを出します。</target>
        </trans-unit>
        <trans-unit id="168977c575f70c81d88c067d5911fa44bdb4a1dc" translate="yes" xml:space="preserve">
          <source>The local label feature is useful for complex macros. If a macro contains nested loops, a &lt;code&gt;goto&lt;/code&gt; can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label is multiply defined in that function. A local label avoids this problem. For example:</source>
          <target state="translated">ローカルラベル機能は、複雑なマクロに役立ちます。マクロにネストされたループが含まれている場合、 &lt;code&gt;goto&lt;/code&gt; はそれらを抜け出すのに役立ちます。ただし、関数全体をスコープとする通常のラベルは使用できません。1つの関数でマクロを複数回展開できる場合は、その関数でラベルが複数定義されています。ローカルラベルはこの問題を回避します。例えば：</target>
        </trans-unit>
        <trans-unit id="d40c92db025f666809a32030712abb46e10389b2" translate="yes" xml:space="preserve">
          <source>The location is expressed as a half-open range, expressed as a count of bytes, starting at byte 1 for the initial column. In the above example, bytes 3 through 20 of line 45 of &amp;ldquo;test.c&amp;rdquo; are to be replaced with the given string:</source>
          <target state="translated">場所は、最初の列のバイト1から始まる、バイト数として表される半分開いた範囲として表されます。上記の例では、「test.c」の行45のバイト3から20は、指定された文字列に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="068a4b98cf23f1dbecfe9f83dd38994bfe05765c" translate="yes" xml:space="preserve">
          <source>The locations within &lt;code&gt;#pragma&lt;/code&gt; directives where header name preprocessing tokens are recognized (C11 6.4, C11 6.4.7).</source>
          <target state="translated">&lt;code&gt;#pragma&lt;/code&gt; ディレクティブ内の、ヘッダー名の前処理トークンが認識される場所（C11 6.4、C11 6.4.7）。</target>
        </trans-unit>
        <trans-unit id="fc6965c74c684a5066713cd45514db9bb14c9963" translate="yes" xml:space="preserve">
          <source>The long long types are only implemented for 64-bit code generation.</source>
          <target state="translated">long long型は64ビットコード生成用にのみ実装されています。</target>
        </trans-unit>
        <trans-unit id="6b21e2c583138d02ccff65c0acb02831c06a2211" translate="yes" xml:space="preserve">
          <source>The low registers r0 - r15.</source>
          <target state="translated">ローレジスタ r0~r15。</target>
        </trans-unit>
        <trans-unit id="ed4899b603c3d7a32aa6ba260f62f9b063dd80a8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__CET__&lt;/code&gt; is defined when</source>
          <target state="translated">マクロ &lt;code&gt;__CET__&lt;/code&gt; は、次の場合に定義されます</target>
        </trans-unit>
        <trans-unit id="835cec1112f64c57bd44cb4fd1c6251993152130" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; is predefined when the</source>
          <target state="translated">マクロ &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="4af0e1087a3dafe7b329598208d0e7bd6efe70c3" translate="yes" xml:space="preserve">
          <source>The main use case of the built-in is to determine whether a &lt;code&gt;constexpr&lt;/code&gt; function is being called in a &lt;code&gt;constexpr&lt;/code&gt; context. A call to the function evaluates to a core constant expression with the value &lt;code&gt;true&lt;/code&gt; if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of &lt;code&gt;constexpr if&lt;/code&gt; statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard.</source>
          <target state="translated">組み込みの主な使用例は、 &lt;code&gt;constexpr&lt;/code&gt; 関数が &lt;code&gt;constexpr&lt;/code&gt; コンテキストで呼び出されているかどうかを判別することです。関数の呼び出しは、C ++標準で定義されているように明示的に定数評価される式または変換の評価内で発生する場合にのみ、値が &lt;code&gt;true&lt;/code&gt; のコア定数式に評価されます。 &lt;code&gt;constexpr if&lt;/code&gt; 評価されるコンテキストには、定数式、constexpr ifステートメントの条件、制約式、および定数式で使用できる変数の初期化子が含まれます。詳細については、C ++標準の最新リビジョンを参照してください。</target>
        </trans-unit>
        <trans-unit id="44703f46619b4bb3387fbb3a9a4987ca25838ebf" translate="yes" xml:space="preserve">
          <source>The mangling was changed in</source>
          <target state="translated">でマングリングを変更しました。</target>
        </trans-unit>
        <trans-unit id="86f9d67774b219fd5194ad2624b61ab77f3088cf" translate="yes" xml:space="preserve">
          <source>The mapping between physical source file multibyte characters and the source character set in translation phase 1 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">物理的なソースファイルのマルチバイト文字と、翻訳フェーズ1(C90、C99、C115.</target>
        </trans-unit>
        <trans-unit id="63322b3a774c9974339e8944410fb9a8c6f8ebf4" translate="yes" xml:space="preserve">
          <source>The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">ソース文字セット(文字定数及び文字列リテラルにおける)のメンバと実行文字セット(C90 6.1.3.4、C99及びC11 6.4.4.4、C90、C99及びC11 5.1.1.1.2)のメンバとのマッピング。</target>
        </trans-unit>
        <trans-unit id="6bc3864d5e277c6ac4690c5e9d3fdbf817cb1a7c" translate="yes" xml:space="preserve">
          <source>The max number of reload pseudos which are considered during spilling a non-reload pseudo.</source>
          <target state="translated">非リロード疑似の流出時に考慮されるリロード疑似の最大数。</target>
        </trans-unit>
        <trans-unit id="4f47dce047d8beaa87edf8a1fdc1bf827620a7f2" translate="yes" xml:space="preserve">
          <source>The maximum alignment for SIMD vector mode types. &lt;var&gt;num&lt;/var&gt; may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don&amp;rsquo;t use SIMD vector modes in places that affect size and/or alignment of relevant types.</source>
          <target state="translated">SIMDベクトルモードタイプの最大アライメント。 &lt;var&gt;num&lt;/var&gt; は4または8です。デフォルトは8です。これはABIの変更であることに注意してください。ただし、関連する型のサイズや配置に影響する場所でSIMDベクトルモードを使用しない場合、多くのライブラリ関数インターフェイスは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="666ee1692153a86b3ec75a197326eda3a0d60489" translate="yes" xml:space="preserve">
          <source>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging.</source>
          <target state="translated">関数の上を通過する際の最大反復回数。これは、ツリーテールマージのコンパイル時間を制限するために使用されます。</target>
        </trans-unit>
        <trans-unit id="89ecfe4db21e974dbc1daddf5e580b9450304991" translate="yes" xml:space="preserve">
          <source>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging.</source>
          <target state="translated">あるbbと比較する類似したbbの最大量。これは、ツリーテールのマージで二次的な挙動を避けるために使用されます。</target>
        </trans-unit>
        <trans-unit id="b6556ebb0621924348132da881ea97c1a248f5ac" translate="yes" xml:space="preserve">
          <source>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction.</source>
          <target state="translated">ジャンプではなく基本ブロックをコピーする場合の最大コードサイズの拡張係数。展開はジャンプ命令に対する相対的なものです。</target>
        </trans-unit>
        <trans-unit id="fce841f0d7fbba4e3b6b48cb84aa6e927eb09594" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for size.</source>
          <target state="translated">ジャンプテーブルに展開したときの最大コードサイズの成長率(パーセント)。このパラメータは、サイズの最適化を行う際に使用します。</target>
        </trans-unit>
        <trans-unit id="e2d12fa5294a85cba03b250f3a5bea21673f3bb2" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for speed.</source>
          <target state="translated">ジャンプテーブルに展開したときの最大コードサイズの成長率(パーセント)。このパラメータは、速度を最適化する際に使用します。</target>
        </trans-unit>
        <trans-unit id="936a590636d845b92624c7728a4827fce9d92d06" translate="yes" xml:space="preserve">
          <source>The maximum conflict delay for an insn to be considered for speculative motion.</source>
          <target state="translated">投機的な動きを考慮するために考慮される insn の最大コンフリクト遅延。</target>
        </trans-unit>
        <trans-unit id="fbb7200dcbf807a75160beecc432fa62ed3e9728" translate="yes" xml:space="preserve">
          <source>The maximum depth of a loop nest suitable for complete peeling.</source>
          <target state="translated">完全剥離に適したループネストの最大深さ。</target>
        </trans-unit>
        <trans-unit id="26a797ef806eaaf765b7a781b669b0a1ee2786d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursive inlining for non-inline functions.</source>
          <target state="translated">非線形関数の再帰的インライン化の最大深度。</target>
        </trans-unit>
        <trans-unit id="20b08dcc7587be3ab6eef2848d7ad81b5a152655" translate="yes" xml:space="preserve">
          <source>The maximum length of a constant string for a builtin string cmp call eligible for inlining.</source>
          <target state="translated">インライン化の対象となる組み込み文字列cmpコールの定数文字列の最大長。</target>
        </trans-unit>
        <trans-unit id="be0d3936975ebff6f26b92e20318105d1c7db49a" translate="yes" xml:space="preserve">
          <source>The maximum number of &amp;rsquo;after supernode&amp;rsquo; exploded nodes within the analyzer per supernode, before terminating analysis.</source>
          <target state="translated">分析を終了する前の、スーパーノードごとのアナライザー内の「スーパーノード後」の爆発ノードの最大数。</target>
        </trans-unit>
        <trans-unit id="38e85e4670d6f7ac0961160fd225824b117f4e1d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;case&lt;/code&gt; values in a &lt;code&gt;switch&lt;/code&gt; statement (C90 6.6.4.2).</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントの &lt;code&gt;case&lt;/code&gt; 値の最大数（C90 6.6.4.2）。</target>
        </trans-unit>
        <trans-unit id="0a2afaa6d3ae61c2d6492935df7934433f87eae8" translate="yes" xml:space="preserve">
          <source>The maximum number of SSA_NAME assignments to follow in determining a property of a variable such as its value. This limits the number of iterations or recursive calls GCC performs when optimizing certain statements or when determining their validity prior to issuing diagnostics.</source>
          <target state="translated">変数の値などのプロパティを決定する際に従うべきSSA_NAME代入の最大数。これは、特定の文を最適化するとき、または診断を発行する前にそれらの有効性を決定するときに、GCCが実行する反復や再帰的呼び出しの数を制限します。</target>
        </trans-unit>
        <trans-unit id="f915c9b0ddf0bbc0779c3cf7dd483c9574fb303a" translate="yes" xml:space="preserve">
          <source>The maximum number of artificial accesses that Scalar Replacement of Aggregates (SRA) will track, per one local variable, in order to facilitate copy propagation.</source>
          <target state="translated">コピー伝播を容易にするために、Scalar Replacement of Aggregates (SRA)が1つのローカル変数ごとに追跡する人工アクセスの最大数。</target>
        </trans-unit>
        <trans-unit id="1cfdd5d91556b4dd893a62b6a75874eee03cf513" translate="yes" xml:space="preserve">
          <source>The maximum number of assertions to add along the default edge of a switch statement during VRP.</source>
          <target state="translated">VRP中にスイッチ・ステートメントのデフォルト・エッジに沿って追加するアサーションの最大数。</target>
        </trans-unit>
        <trans-unit id="c6e6bc4dbd514d325e3c749eca0229393e1fb788" translate="yes" xml:space="preserve">
          <source>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.</source>
          <target state="translated">ループをモジュロスケジューリングする際にスケジューラが行うべきバックトラックの最大回数を指定します。この値を大きくするとコンパイル時間が指数関数的に増加します。</target>
        </trans-unit>
        <trans-unit id="018c7375a2caf17039c26fd694620cad7ebfaa5f" translate="yes" xml:space="preserve">
          <source>The maximum number of basic blocks on path that CSE considers.</source>
          <target state="translated">CSEが考慮するパス上の基本ブロックの最大数。</target>
        </trans-unit>
        <trans-unit id="c79967caf66fa10b13e953918175f64b9fd85351" translate="yes" xml:space="preserve">
          <source>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.</source>
          <target state="translated">選択スケジューラでリネームを考慮するレディリストの中で、最適な命令の最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="79a02e3d5ce6c0b561178810954860635f75b277" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for interblock scheduling.</source>
          <target state="translated">ブロック間スケジューリングのために考慮すべき領域内のブロックの最大数。</target>
        </trans-unit>
        <trans-unit id="3225f5aa45adb6a455e07adb58dbc4331ca98962" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">選択スケジューラでパイプライン化を考慮する領域内のブロックの最大数。</target>
        </trans-unit>
        <trans-unit id="d26d722dd2f733f712aeb0f605ec58066091d632" translate="yes" xml:space="preserve">
          <source>The maximum number of branches on the hot path through the peeled sequence.</source>
          <target state="translated">剥離したシーケンスを通るホットパス上の最大枝数。</target>
        </trans-unit>
        <trans-unit id="d2fe875bfce475e08e430e98ccc72ad1afca879e" translate="yes" xml:space="preserve">
          <source>The maximum number of branches unswitched in a single loop.</source>
          <target state="translated">1つのループ内でスイッチが入っていない分岐の最大数。</target>
        </trans-unit>
        <trans-unit id="9965c595ccb073bed98dc2ae6e76b73f1d6e9fe2" translate="yes" xml:space="preserve">
          <source>The maximum number of conditional store pairs that can be sunk. Set to 0 if either vectorization (</source>
          <target state="translated">沈められる条件付きストアペアの最大数。ベクトル化 (</target>
        </trans-unit>
        <trans-unit id="126cc6769740c4d71bac9ace9af0b249f19d3967" translate="yes" xml:space="preserve">
          <source>The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).</source>
          <target state="translated">算術型・構造体型・組合型を変更できる宣言子の最大数(C90 6.5.4)。</target>
        </trans-unit>
        <trans-unit id="4d5793f890c15f6b518ebfeeddd6bdf92fc933a4" translate="yes" xml:space="preserve">
          <source>The maximum number of exploded nodes per program point within the analyzer, before terminating analysis of that point.</source>
          <target state="translated">そのポイントの解析を終了する前に、アナライザ内のプログラム・ポイントごとに展開されるノードの最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="046b54d8dec00a923499bbe98f2011a4caa2c4d1" translate="yes" xml:space="preserve">
          <source>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by</source>
          <target state="translated">クロスジャンプのために考慮すべき着信エッジの最大数。で使用されるアルゴリズムは</target>
        </trans-unit>
        <trans-unit id="23db9a7b1aa156bfdeb79b1a74ceb92745f99df4" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for interblock scheduling.</source>
          <target state="translated">ブロック間スケジューリングのために考慮すべき領域内の最大数のinsns。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
