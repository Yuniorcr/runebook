<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="64755c0a10d7b896808172cc7335112d4911d239" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">選択スケジューラでパイプライン化を考慮する領域内の insns の最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="7549b9d59e547801a424f6394451c0c5eb284456" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in loop header duplicated by the copy loop headers pass.</source>
          <target state="translated">コピーループヘッダのパスで複製されるループヘッダ内のinsnの最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="557a1591041c896c87813c7c44591df470e1d549" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a completely peeled loop.</source>
          <target state="translated">完全に剥がれ落ちたループの最大イン数。</target>
        </trans-unit>
        <trans-unit id="6e77354bbeeb82418d9ce51f0cd208bdb1bdb528" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a peeled loop that rolls only once.</source>
          <target state="translated">1回しか転がらない剥き出しのループのイン数の最大値。</target>
        </trans-unit>
        <trans-unit id="e1366f0a190b8fba2e81ce94bc72ef8becba23f7" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of an unswitched loop.</source>
          <target state="translated">スイッチの入っていないループの最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="cf7612b99e9ada1082074daa96e9458c5473af04" translate="yes" xml:space="preserve">
          <source>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">命令のリロード回数の最大値は、同等のレジスタに対して後方を向くことです。値を大きくすると、より積極的な最適化を意味し、コンパイル時間が長くなりますが、パフォーマンスは若干向上します。</target>
        </trans-unit>
        <trans-unit id="9005923e6a32b4692818d139c898763d96182dda" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions CSE processes before flushing.</source>
          <target state="translated">フラッシュする前にCSEが処理する命令の最大数。</target>
        </trans-unit>
        <trans-unit id="c9f4ccd7bf5ad2020d3e593506c55f6c162a5002" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">ループがアンロールされなければならない可能性のあるループの実行確率に偏った命令の最大数を指定します。ループがアンロールされる場合、このパラメータはループコードのアンロール回数も決定します。</target>
        </trans-unit>
        <trans-unit id="6459fa6f8aa47f72deca9d3c9064156b11b3b7ad" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions non-inline function can grow to via recursive inlining.</source>
          <target state="translated">非インライン関数が再帰的インライン化によって成長できる最大命令数。</target>
        </trans-unit>
        <trans-unit id="f088738722ed99797643c1cd7fd24995b8cb099a" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.</source>
          <target state="translated">スケジューラが最初のスケジューリングパスの間に、いつでも考慮すべき発行準備の整った命令の最大数です。値を大きくすると、より徹底的な検索が必要となり、コンパイル時間が長くなりますが、ほとんどメリットはありません。</target>
        </trans-unit>
        <trans-unit id="751361661372b9f65beccbd7de6c9e13c4fb111d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.</source>
          <target state="translated">ループがピーリングされる可能性のある命令の最大数を指定します。ループがピーリングされている場合、このパラメータはループコードがピーリングされる回数も決定します。</target>
        </trans-unit>
        <trans-unit id="7edf4c141bc3a24bbf2d50e04de689b5700fa130" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">ループがアンロールされる可能性のある命令の最大数を指定します。ループがアンロールされている場合、このパラメータはループコードのアンロール回数も決定します。</target>
        </trans-unit>
        <trans-unit id="b5c3a913df725fc3842845c874668062bf683170" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an inner loop can have before the loop versioning pass considers it too big to copy.</source>
          <target state="translated">ループのバージョニングパスがコピーするには大きすぎると判断する前に、内部ループが持つことができる命令の最大数。</target>
        </trans-unit>
        <trans-unit id="0347a5207a00a0a94142de3b1cb1207696bb8750" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an outer loop can have before the loop versioning pass considers it too big to copy, discounting any instructions in inner loops that directly benefit from versioning.</source>
          <target state="translated">ループのバージョニングパスが大きすぎてコピーできないと判断する前に、外部ループが持つことができる命令の最大数を指定します。</target>
        </trans-unit>
        <trans-unit id="cd3296c189a6eb29be66f9d755ea47f2387ef49d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions the RTL combiner tries to combine.</source>
          <target state="translated">RTL コンバイナが結合しようとする命令の最大数。</target>
        </trans-unit>
        <trans-unit id="cf3b05a5fc34087d71a21bfbdc9daebc782fc835" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.</source>
          <target state="translated">遅延スロットを埋める命令を探す際に考慮すべき最大命令数です。この任意の数以上の命令が検索された場合、遅延スロットを埋めることによる時間の節約は最小限なので、検索を停止します。値を大きくすると、より積極的な最適化を意味し、コンパイル時間は増加しますが、実行時間の改善はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="f5be3b82586aa080f1846e1d109f72232bc815fe" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid &lt;em&gt;O(N^2)&lt;/em&gt; behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.</source>
          <target state="translated">計算されたgotoにジャンプするブロックに複製する命令の最大数。多くのパスで&lt;em&gt;O（N ^ 2）&lt;/em&gt;動作を回避するために、GCCはコンパイルプロセスの早い段階でgotoを計算し、可能な限り遅くそれらをunfactorsします。max-goto-duplication-insns以下の基本ブロックの最後に計算されたジャンプのみが分解されません。</target>
        </trans-unit>
        <trans-unit id="f826bd5a9f2e555af6e39cc55fa38f4c63598849" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.</source>
          <target state="translated">ループの反復回数の解析のためのブルートフォースアルゴリズムが評価しようとするループの反復回数の最大数。</target>
        </trans-unit>
        <trans-unit id="827bc9985068a19acb40103212322373c4817b20" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop to be suitable for complete peeling.</source>
          <target state="translated">完全剥離に適したループの反復回数の最大値。</target>
        </trans-unit>
        <trans-unit id="6ed380824467ca338cf023f1dcb3f2de07822555" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations through CFG to extend regions. A value of 0 disables region extensions.</source>
          <target state="translated">CFG で領域を拡張するための最大反復回数。0 を指定するとリージョン拡張を無効にします。</target>
        </trans-unit>
        <trans-unit id="3a4fe5f590fb9f1538c537c1032bfe7e933f8b30" translate="yes" xml:space="preserve">
          <source>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.</source>
          <target state="translated">統計的に予測するループの反復回数の最大値です。これは,関数が既知の境界を持つ1つのループと未知の境界を持つもう1つのループを含む場合に便利です.既知のループの反復回数は正しく予測されますが、未知のループの反復回数は平均して約10回になります。これは、境界のないループが他のループに比べて人為的に冷たく見えることを意味します。</target>
        </trans-unit>
        <trans-unit id="6c4f0955c671eedabc4872cd4110ae5643c1e035" translate="yes" xml:space="preserve">
          <source>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means no limit.</source>
          <target state="translated">ベクタライザのアクセスアライメントを強化するためのループピールの最大数を指定します。値 -1 は制限なしを意味します。</target>
        </trans-unit>
        <trans-unit id="15a4d50649a3963909b22c32025925dae63b4133" translate="yes" xml:space="preserve">
          <source>The maximum number of may-defs we analyze when looking for a must-def specifying the dynamic type of an object that invokes a virtual call we may be able to devirtualize speculatively.</source>
          <target state="translated">仮想呼び出しを呼び出すオブジェクトの動的な型を指定する must-def を探すときに分析する may-def の最大数は、私たちが推測で仮想化できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6a35d2bdd1c57297696d12360403e48281b63730" translate="yes" xml:space="preserve">
          <source>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">cselib が考慮すべきメモリロケーションの最大数。値を大きくすると、より積極的な最適化が行われ、コンパイル時間が増加し、パフォーマンスが若干向上することを意味します。</target>
        </trans-unit>
        <trans-unit id="d6a0df289b9860c6b27b724bd89cb2e25afbef7b" translate="yes" xml:space="preserve">
          <source>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.</source>
          <target state="translated">識別子に対する C++の名前検索が失敗した場合に、提案を参照する名前空間の最大数。</target>
        </trans-unit>
        <trans-unit id="511118b67bad71c8756d22dc67344a5b3d5a2116" translate="yes" xml:space="preserve">
          <source>The maximum number of peelings of a single loop.</source>
          <target state="translated">1ループの最大剥離数。</target>
        </trans-unit>
        <trans-unit id="e8f1f05653238e3a565a30b9f73246f26306aaea" translate="yes" xml:space="preserve">
          <source>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.</source>
          <target state="translated">現在の状態をフラッシュしてやり直す前に、スケジューリングが許す保留依存関係の最大数。ブランチやコールが少ない大規模な関数は、過度に大きなリストを作成してしまい、 メモリやリソースを無駄に消費してしまいます。</target>
        </trans-unit>
        <trans-unit id="f0e89b0526dda27a2d7f3e6b7314e208af696219" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.</source>
          <target state="translated">ベクタライザでエイリアスのループバージョニングを行う際に実行できるランタイムチェックの最大数。</target>
        </trans-unit>
        <trans-unit id="db0f184d4982d10802b0494be89c63889d9e1ea5" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.</source>
          <target state="translated">ベクタライザでアライメントのためのループバージョニングを行う際に実行できるランタイムチェックの最大数。</target>
        </trans-unit>
        <trans-unit id="50ff624d5ca7c27e89395fa51bbbe5ce28d3f9f1" translate="yes" xml:space="preserve">
          <source>The maximum number of stmts in a loop to be interchanged.</source>
          <target state="translated">ループ内で交換する最大数のstmtsを指定します。</target>
        </trans-unit>
        <trans-unit id="2862b2a5dc2c56cf5f469134e2bd6bad6e5964e7" translate="yes" xml:space="preserve">
          <source>The maximum number of stores to attempt to merge into wider stores in the store merging pass.</source>
          <target state="translated">店舗合流パスの中で、より広い店舗への合流を試みる店舗の最大数。</target>
        </trans-unit>
        <trans-unit id="ae1a00d3b58c9f16d33b3348661fd11eee89c1d8" translate="yes" xml:space="preserve">
          <source>The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.</source>
          <target state="translated">アナライザ内のコール・スタックにコールサイトが現れる最大回数を指定します。</target>
        </trans-unit>
        <trans-unit id="6caef17bd294964937582b8b58bab7601c99e27b" translate="yes" xml:space="preserve">
          <source>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined.</source>
          <target state="translated">選択スケジューリング中に命令がスケジューリングされる最大回数。これは命令をパイプライン化するための反復回数の制限です。</target>
        </trans-unit>
        <trans-unit id="ddefe1cfc3442fba935b71446bc04ed2a446b364" translate="yes" xml:space="preserve">
          <source>The maximum number of times the outer loop should be unrolled by the unroll-and-jam transformation.</source>
          <target state="translated">外側のループをアンロール&amp;ジャム変換でアンロールする最大回数を指定します。</target>
        </trans-unit>
        <trans-unit id="1df2840a57590d0c992c35b1f7cd4db504ccf715" translate="yes" xml:space="preserve">
          <source>The maximum number of unrollings of a single loop.</source>
          <target state="translated">1ループの最大アンロール数。</target>
        </trans-unit>
        <trans-unit id="06e4b31a55ed6d6ed41d2b2d48b6006b46bfa532" translate="yes" xml:space="preserve">
          <source>The maximum relative execution frequency (in percents) of the target block relative to a statement&amp;rsquo;s original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.</source>
          <target state="translated">ステートメントのステートメントシンクを可能にする、ステートメントの元のブロックに対するターゲットブロックの最大相対実行頻度（パーセント単位）。数値が大きいほど、より積極的なステートメントシンクになります。メモリオペランドを使用したステートメントには、小さなプラスの調整が適用されます。</target>
        </trans-unit>
        <trans-unit id="c4e2688875615cab366f32942394edf8b4b91705" translate="yes" xml:space="preserve">
          <source>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.</source>
          <target state="translated">疑似レジスタの最後の既知の値としてコンバイナ内の式に記録できるRTLの数として測定される最大サイズ。</target>
        </trans-unit>
        <trans-unit id="159ffd5e6070239f87afd549cbfcfd8ded2b299d" translate="yes" xml:space="preserve">
          <source>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions.</source>
          <target state="translated">選択的スケジューリングのルックヘッドウィンドウの最大サイズ。利用可能な命令の探索深さを表します。</target>
        </trans-unit>
        <trans-unit id="f3da3af33190929d9965056fd52af9e74099ff3d" translate="yes" xml:space="preserve">
          <source>The memory order parameter is a signed int, but only the lower 16 bits are reserved for the memory order. The remainder of the signed int is reserved for target use and should be 0. Use of the predefined atomic values ensures proper usage.</source>
          <target state="translated">メモリ順序パラメータは符号付き整数ですが、下位 16 ビットのみがメモリ順序のために予約されています。符号付き整数の残りはターゲット用に予約されており、0でなければなりません。 定義済みのアトミック値を使用することで、適切に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9c9000c0e6476a4bcab6775fb476be520bb235b5" translate="yes" xml:space="preserve">
          <source>The memory-based pseudo-registers $mem0 through $mem15.</source>
          <target state="translated">メモリベースの擬似レジスタ $mem0 ~ $mem15。</target>
        </trans-unit>
        <trans-unit id="5f9aeac04a443a9f208cd4c4e6f4207cbf2bb24b" translate="yes" xml:space="preserve">
          <source>The message attached to the attribute is affected by the setting of the</source>
          <target state="translated">属性に添付されているメッセージは</target>
        </trans-unit>
        <trans-unit id="535f4a6df8d49970089b47a9552616a59f08c505" translate="yes" xml:space="preserve">
          <source>The message is in keeping with the output of</source>
          <target state="translated">の出力と一致しています。</target>
        </trans-unit>
        <trans-unit id="22d9ad2ced8af2273cacd0833b5a4654b153618b" translate="yes" xml:space="preserve">
          <source>The method by which preprocessing tokens (possibly resulting from macro expansion) in a &lt;code&gt;#include&lt;/code&gt; directive are combined into a header name (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; ディレクティブの前処理トークン（おそらくマクロ展開の結果）をヘッダー名に組み合わせる方法（C90 6.8.2、C99およびC11 6.10.2）。</target>
        </trans-unit>
        <trans-unit id="64dacbdf1cd80117047022b9711381d6ea5221d3" translate="yes" xml:space="preserve">
          <source>The method is called repeatedly during a fast enumeration to retrieve batches of objects. Each invocation of the method should retrieve the next batch of objects.</source>
          <target state="translated">このメソッドは、オブジェクトのバッチを取得するために高速な列挙の間に繰り返し呼び出されます。メソッドを呼び出すたびに、次のバッチのオブジェクトを取得しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c7fa0fb8f65f5da5a26a900516ca2af75a19d924" translate="yes" xml:space="preserve">
          <source>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; tells GCC where to pass this address.</source>
          <target state="translated">GCCが使用するメソッドは次のとおりです。1、2、4、または8バイト長の構造体または共用体がスカラーのように返されます。他のサイズの構造体または共用体は、呼び出し元から提供されたアドレスに格納されます（通常、特殊な固定レジスターにありますが、一部のマシンではスタックに渡されます）。ターゲットフック &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; は、GCCにこのアドレスを渡す場所を指示します。</target>
        </trans-unit>
        <trans-unit id="cea71b7dec6652fd1c586605bdaf1afaabd9e0d7" translate="yes" xml:space="preserve">
          <source>The middle operand in a conditional expression may be omitted. Then if the first operand is nonzero, its value is the value of the conditional expression.</source>
          <target state="translated">条件式の中間のオペランドは省略することができます。そして、最初のオペランドが0でない場合、その値は条件式の値となります。</target>
        </trans-unit>
        <trans-unit id="6b9ca9444f11bb1174b6690d0f150eb398c757b0" translate="yes" xml:space="preserve">
          <source>The mini registers r0 - r7.</source>
          <target state="translated">ミニレジスタr0~r7です。</target>
        </trans-unit>
        <trans-unit id="e080de9f963115473e6c7f8a5387551ad83e48b0" translate="yes" xml:space="preserve">
          <source>The minimal probability of speculation success (in percents), so that speculative insns are scheduled.</source>
          <target state="translated">投機成功の最小確率(パーセンテージで)で、投機インが予定されているように。</target>
        </trans-unit>
        <trans-unit id="aaffaaa968786a2da6ad4d8b8e0d5b378cb65a74" translate="yes" xml:space="preserve">
          <source>The minimum cost of an expensive expression in the loop invariant motion.</source>
          <target state="translated">ループ不変運動における高価な式の最小コスト。</target>
        </trans-unit>
        <trans-unit id="efe3bb81fc851386e4b7cee22649ff792c38641a" translate="yes" xml:space="preserve">
          <source>The minimum fraction of profile runs a given basic block execution count must be not to be considered unlikely.</source>
          <target state="translated">与えられた基本ブロックの実行回数が、プロファイルの実行回数の最小値は、可能性が低いと考えられないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="92f1b567f7a83d5184bace5014aac03377eeb221" translate="yes" xml:space="preserve">
          <source>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched.</source>
          <target state="translated">2 つのブロックでクロスジャンプを実行する前に、2 つのブロックの最後にマッチしなければならない命令の最小数。この値は、クロスジャンプ元のブロック内のすべての命令がマッチしている場合には無視されます。</target>
        </trans-unit>
        <trans-unit id="02c154dc267dae6541e650ecc75738b7fc1946c1" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations per thread of an innermost parallelized loop for which the parallelized variant is preferred over the single threaded one. Note that for a parallelized loop nest the minimum number of iterations of the outermost loop per thread is two.</source>
          <target state="translated">1番内側の並列化されたループの1スレッドあたりの反復回数の最小値で、1スレッドのものよりも並列化されたバリアントの方が優先されます。並列化されたループのネストでは、スレッドあたりの最外周ループの最小反復回数は2であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2647f0a952db726e7e97cf159b9a0ce4dc6514c9" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations under which loops are not vectorized when</source>
          <target state="translated">ループがベクトル化されない場合の最小反復回数。</target>
        </trans-unit>
        <trans-unit id="a016de6d4b3751317d101162f7adccf0bba87a22" translate="yes" xml:space="preserve">
          <source>The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.</source>
          <target state="translated">呼び出しサイトでの効果の要約を考慮するための関数内のスーパーノードの最小数。</target>
        </trans-unit>
        <trans-unit id="44ff09fc2cb3e08a9eb4ff0c94daf816032e979a" translate="yes" xml:space="preserve">
          <source>The minimum percentage of memory references that must be optimized away for the unroll-and-jam transformation to be considered profitable.</source>
          <target state="translated">アンロール&amp;ジャム変換が収益性の高いものとみなされるために、最適化されていないといけないメモリ参照の最小割合。</target>
        </trans-unit>
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="translated">ブロック間投機的スケジューリングのためのソースブロックに到達する最小確率(パーセン ト単位)。</target>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="translated">スケジューラがそのエッジの状態を保存するために必要な最小の確率。</target>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="translated">インターチェンジのための2つのループのストライド間の最小比率は、利益を得ることができます。</target>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="translated">ループ内でプリフェッチを可能にするための命令数とメモリ参照数の最小比。</target>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="translated">ループ内でのプリフェッチを可能にするための命令数とプリフェッチ数の最小比。</target>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="translated">スタックスマッシング保護を受けるバッファ (配列など)の最小サイズ。</target>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="translated">最適化されていないときにスタックスロットの共有に参加する変数の最小サイズ。</target>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="translated">swing modulo スケジューラが生成するステージ数の最小値。</target>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="translated">プログラムをリンクして特定のC ++ライブラリを使用する最も簡単な方法は、デフォルトでそのC ++ライブラリを指定するC ++ドライバを使用することです。 &lt;code&gt;g++&lt;/code&gt; ドライバは、例えば、GCCのC ++ライブラリを見つけるためにリンカに指示します（</target>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="translated">マルチプロセッシングの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">関数の名前です。</target>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="translated">特定のパラメータの名前と値の意味は、コンパイラの内部に関連付けられており、将来のリリースでは予告なく変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="translated">ネイティブのLinux / GNUツールチェーンも値をサポートしています '</target>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="translated">ネストされた関数は、その定義の時点で可視である包含関数のすべての変数にアクセスできます。これは&lt;em&gt;字句スコープ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。たとえば、ここでは、 &lt;code&gt;offset&lt;/code&gt; という名前の継承された変数を使用するネストされた関数を示します。。</target>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="translated">入れ子関数の名前は、それが定義されているブロックに対してローカルです。たとえば、ここでは &lt;code&gt;square&lt;/code&gt; という名前のネストされた関数を定義します 2回呼び出します。</target>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; のネスト制限処理（C90 6.8.2、C99およびC11 6.10.2）。</target>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="translated">次の例は、関数の実行中に入力（ &lt;code&gt;dwSomeValue&lt;/code&gt; ）が変更されないことをオプティマイザーが認識できるため、 &lt;code&gt;asm&lt;/code&gt; をループの外に移動してより効率的なコードを生成できる場合を示しています。繰り返しますが、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用すると、このタイプの最適化が無効になります。</target>
        </trans-unit>
        <trans-unit id="90026784c98f629fb36fb07ae9132c36ffa32047" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">2020年に予定されているISO C++規格の次期リビジョン。サポートは非常に実験的なものであり、将来のリリースではほぼ確実に互換性のない方法で変更されます。</target>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">2020年に暫定的に予定されているISO C++規格の次の改訂版。サポートは非常に実験的なものであり、将来のリリースではほぼ確実に互換性のない方法で変更されます。</target>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="translated">ISO C標準の次のバージョンで、まだ開発中のものにGNU拡張を加えたものです。このバージョンのサポートは実験的で不完全です。</target>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="translated">まだ開発中のISO C規格の次期バージョン。このバージョンのサポートは実験的で不完全です。</target>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="translated">9つのトライグラフとそれに代わるものは</target>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="translated">汎用レジスタR0~R14、制御レジスタGBR、システムレジスタMACH、MACL、PRからなる19個の32ビットレジスタとベクトルテーブルのアドレスオフセットをレジスタバンクに保存します。レジスタバンクはファーストインラストアウト(FILO)の順序でスタックされます。バンクからの復帰は、RESBANK 命令を発行することで実行されます。</target>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="translated">非原子型は以下のようにエンコードされています。</target>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="translated">通常のベクトル抽出およびセット操作は、 &lt;var&gt;vector __int128&lt;/var&gt; および &lt;var&gt;vector __uint128&lt;/var&gt; タイプでますが、インデックス値は0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="translated">マクロが &lt;code&gt;NULL&lt;/code&gt; になるNULLポインター定数展開（C90 7.1.6、C99 7.17、C11 7.19）。</target>
        </trans-unit>
        <trans-unit id="28be55da2d33dfd035a16c7e12609f9fde68fbf1" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for double type. The precision of division is propotional to this param when division approximation is enabled. The default value is 2.</source>
          <target state="translated">double型の逆数を計算するためのニュートン反復回数を指定します.除算近似が有効な場合、除算の精度はこのパラメータに依存します。デフォルト値は2です.</target>
        </trans-unit>
        <trans-unit id="6669979f69801134fe5425b263914957ab4a88a7" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for float type. The precision of division is proportional to this param when division approximation is enabled. The default value is 1.</source>
          <target state="translated">float 型の逆数を計算するためのニュートン反復回数を指定します.除算近似が有効な場合,除算の精度はこのパラメータに比例します.デフォルト値は 1 です.</target>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="translated">バイトのビット数(C90 3.4、C99、C11 3.6)。</target>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="translated">DFAを使用してコンフリクトをチェックする際にスイングモジュラスケジューラが考慮するサイクル数。</target>
        </trans-unit>
        <trans-unit id="4fb7b94d708168700c159e251d0f9d5fce1fc8c3" translate="yes" xml:space="preserve">
          <source>The number of elements for which hash table verification is done for each searched element.</source>
          <target state="translated">検索された要素ごとにハッシュテーブル検証を行う要素の数。</target>
        </trans-unit>
        <trans-unit id="0a72ad254c79a1eea72a19a4968bbd0e5a7dddcb" translate="yes" xml:space="preserve">
          <source>The number of executions of a basic block which is considered hot. The parameter is used only in GIMPLE FE.</source>
          <target state="translated">ホットとみなされる基本ブロックの実行回数を指定します。このパラメータは GIMPLE FE でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="ce1f697b40b6aa8756d941d13116c5069d63cf0d" translate="yes" xml:space="preserve">
          <source>The number of most executed permilles, ranging from 0 to 1000, of the profiled execution of the entire program to which the execution count of a basic block must be part of in order to be considered hot. The default is 990, which means that a basic block is considered hot if its execution count contributes to the upper 990 permilles, or 99.0%, of the profiled execution of the entire program. 0 means that it is never considered hot. Used in LTO mode.</source>
          <target state="translated">基本ブロックの実行回数がホットとみなされるためには、基本ブロックの実行回数がその一部でなければならないプログラム全体のプロファイリングされた実行のうち、最も多く実行されたパーミルの数を 0 から 1000 までの範囲で指定します。デフォルトは 990 で、基本ブロックの実行カウントがプログラム全体のプロファイル実行のうち、上位 990 パーミル、つまり 99.0% に寄与していればホットとみなされます。0 は、ホットとは見なされないことを意味します。LTO モードで使用されます。</target>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="translated">識別子に含まれる有効な初期文字の数(C90 6.</target>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="translated">任意のオブジェクト内のバイト数、順序及び符号化(この国際規格で明示的に規定されていない場合)(C99及びC11 6.2.6.1)。</target>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="translated">オブジェクトは、それぞれのセグメントのオーバーライド接頭辞でアクセスされます。</target>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="translated">第一引数で指し示されるオブジェクトは整数型かポインタ型でなければなりません。ブール型であってはなりません。</target>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="translated">第一引数で指し示されるオブジェクトは整数型かポインタ型でなければなりません。真偽値型であってはなりません。すべてのメモリオーダーが有効です。</target>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="translated">の唯一の違い '</target>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="translated">この機能の唯一のサポートされている用途は、Extended &lt;code&gt;asm&lt;/code&gt; を呼び出すときに、入力および出力オペランドのレジスターを指定することです（&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asmを&lt;/a&gt;参照）。これは、特定のマシンの制約が目的のレジスターを選択するための十分な制御を提供しない場合に必要になることがあります。オペランドをレジスタに強制するには、ローカル変数を作成し、変数の宣言の後にレジスタ名を指定します。次に、 &lt;code&gt;asm&lt;/code&gt; オペランドにローカル変数を使用して、レジスターと一致する制約文字を指定します。</target>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="translated">オペランドは、読み込まれるレジスタの番号です。生成します。</target>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; のオペランドは、可変的に変更された型の式またはそのような型の名前である場合にのみ、その副作用について評価されます。</target>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="translated">オペランド、 &lt;var&gt;auxv&lt;/var&gt; は、補助レジスターのアドレスであり、コンパイル時定数でなければなりません。生成：</target>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">操作はC ++ &lt;code&gt;valarrays&lt;/code&gt; のように動作します。加算は、オペランドの対応する要素の加算として定義されます。例えば、以下のコードで、4つの要素のそれぞれに対応する4つの要素に追加され &lt;var&gt;b&lt;/var&gt; 及び得られたベクターに格納されている &lt;var&gt;c&lt;/var&gt; 。 &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="translated">オペレーター '</target>
        </trans-unit>
        <trans-unit id="e6c35a6661bd8051bda6c84d11bcf3693039836f" translate="yes" xml:space="preserve">
          <source>The opposite</source>
          <target state="translated">反対の</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="translated">このオプションは、使用するISAも設定します。MCU名が430 ISAのみをサポートすることがわかっている場合はそれが選択され、そうでない場合は430X ISAが選択されます。の一般的なMCU名</target>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="translated">オプションには3つの形態があります。</target>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="translated">オプションは以下に相当します。</target>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="translated">オプションは以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="translated">オプションの動作は、</target>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="translated">オプションの &lt;code&gt;volatile&lt;/code&gt; 修飾子は効果がありません。すべての基本的な &lt;code&gt;asm&lt;/code&gt; ブロックは暗黙的に揮発性です。</target>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">オプションの &lt;var&gt;sirevision&lt;/var&gt; は、ターゲットBlackfinプロセッサーのシリコンリビジョンを指定します。ターゲットのシリコンリビジョンで利用可能な回避策は有効になっています。もし &lt;var&gt;sirevision&lt;/var&gt; は 'です</target>
        </trans-unit>
        <trans-unit id="875be52030ba25094435899fd42d910088a7a954" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;size-index&lt;/var&gt; positional argument denotes a function argument of integer type that specifies the maximum size of the access. The size is the number of elements of the type referenced by &lt;var&gt;ref-index&lt;/var&gt;, or the number of bytes when the pointer type is &lt;code&gt;void*&lt;/code&gt;. When no &lt;var&gt;size-index&lt;/var&gt; argument is specified, the pointer argument must be either null or point to a space that is suitably aligned and large for at least one object of the referenced type (this implies that a past-the-end pointer is not a valid argument). The actual size of the access may be less but it must not be more.</source>
          <target state="translated">オプションの &lt;var&gt;size-index&lt;/var&gt; 位置引数は、アクセスの最大サイズを指定する整数型の関数引数を示します。サイズは、 &lt;var&gt;ref-index&lt;/var&gt; によって参照されるタイプの要素の数、またはポインタータイプが &lt;code&gt;void*&lt;/code&gt; 場合のバイト数です。いかなる場合 &lt;var&gt;size-index&lt;/var&gt; 引数が指定されていない、ポインタ引数が適切に参照されるタイプの少なくとも一つの目的のために整列および大きい空間のいずれかにヌルまたはポイントでなければならない（これは過去エンドポインタがAではないことを意味有効な引数）。アクセスの実際のサイズはこれよりも小さい場合がありますが、それより大きくすることはできません。</target>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="translated">オプションの引数 &lt;var&gt;mask&lt;/var&gt; 値があり &lt;code&gt;notinbranch&lt;/code&gt; または &lt;code&gt;inbranch&lt;/code&gt; を、それに応じてマスクされていないか、マスクされたクローンを生成するようにコンパイラーに指示します。デフォルトでは、すべてのクローンが生成されます。</target>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="translated">括弧内にベクトル定数を指定するオプションの拡張はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="translated">オプションの最初の単語は、直接使用される構造体（ '</target>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="translated">オプションの2番目の単語は、指定を通常の構造体（ '</target>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="translated">各グループのオプションは重複しないので、自由に混在させることができます。ただし、競合があった場合は、コマンドライン上では後のオプションが前のオプションを上書きします。</target>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="translated">このセクションのオプションは、すべてのVxWorksターゲットに対して定義されています。ターゲットハードウェアに固有のオプションは、そのターゲットの他のオプションと一緒にリストアップされています。</target>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="translated">サポートされるオプションは各ターゲットに固有です。詳細については、「&lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86関数属性」&lt;/a&gt;、「&lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC関数属性」&lt;/a&gt;、「&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM関数属性」&lt;/a&gt;、「&lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64関数属性」&lt;/a&gt;、「&lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II関数属性」&lt;/a&gt;、および「&lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S / 390関数属性」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="translated">オプションは S/390 固有のコマンドラインオプションとまったく同じように動作します (接頭辞なし)</target>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; と &lt;code&gt;+initialize&lt;/code&gt; が呼び出される順序は、これが重要な場合に問題になる可能性があります。 &lt;code&gt;+load&lt;/code&gt; 内にオブジェクトを割り当てない場合は、 &lt;code&gt;+initialize&lt;/code&gt; の前に+ &lt;code&gt;+load&lt;/code&gt; が呼び出されることが保証されます。あなたは、オブジェクトの内部を作成する場合は &lt;code&gt;+load&lt;/code&gt; &lt;code&gt;+initialize&lt;/code&gt; オブジェクトのクラスのメソッドがあっても起動されます &lt;code&gt;+load&lt;/code&gt; 起動されていませんでした。クラスで &lt;code&gt;+initialize&lt;/code&gt; &lt;code&gt;+load&lt;/code&gt; を明示的に呼び出すと、+ initializeが最初に呼び出されます。起こり得る問題を回避するために、これらのメソッドの1つだけを実装するようにしてください。</target>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">単位内のビットフィールドの割り当て順序(C90 6.5.2.1、C99、C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="translated">これらのプリアンブル行の順序と数は、 &lt;code&gt;gcov&lt;/code&gt; の開発が進むにつれて増加します。それらが変更されていないことに依存しないでください。 &lt;var&gt;tag&lt;/var&gt; を使用して、特定のプリアンブルラインを見つけます。</target>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="translated">元のANSI C標準（X3.159-1989）は1989年に承認され、1990年に公開されました。この標準はISO標準（ISO / IEC 9899：1990）として1990年の後半に承認されました。これらの出版物に技術的な違いはありませんでした。 ANSI規格のセクションは番号が付け直され、ISO規格の条項になりました。 ISO規格ではなくANSI規格にもRationaleドキュメントが付属しています。この規格は、どちらの形式でも、批准の日付から一般に&lt;em&gt;C89&lt;/em&gt;、または場合によっては&lt;em&gt;C90&lt;/em&gt;として知られています。 GCCでこの標準を選択するには、いずれかのオプションを使用します</target>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="translated">元のISO C ++標準は、ISO標準（ISO / IEC 14882：1998）として公開され、2003年に発行されたTechnical Corrigenda（ISO / IEC 14882：2003）によって修正されました。これらの標準は、それぞれC ++ 98およびC ++ 03と呼ばれます。 GCCはC ++ 98の大部分（ &lt;code&gt;export&lt;/code&gt; は顕著な例外です）とC ++ 03のほとんどの変更を実装しています。 GCCでこの標準を選択するには、いずれかのオプションを使用します</target>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="translated">その他のオプションは、特定のプロセッサを指定します。これらのオプションで生成されたコードは、そのプロセッサ上で最もよく動作し、他のプロセッサでは全く動作しない場合があります。</target>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="translated">出力は以前のコマンドラインオプションの影響を受けやすいので、例えば</target>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="translated">出力は、最適化によって結合されたこのコードブロックが 100 回実行されたことを示しています。これらの4行すべてを表す命令が1つしかなかったので、ある意味ではこの結果は正しいです。しかし、この出力は、結果が何回0で、何回1であったかを示していません。</target>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="translated">パラメータ &lt;var&gt;archetype&lt;/var&gt; は、フォーマット文字列の解釈方法を決定し、 &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 、 &lt;code&gt;strftime&lt;/code&gt; 、 &lt;code&gt;gnu_printf&lt;/code&gt; 、 &lt;code&gt;gnu_scanf&lt;/code&gt; 、 &lt;code&gt;gnu_strftime&lt;/code&gt; または &lt;code&gt;strfmon&lt;/code&gt; である必要があります。（ &lt;code&gt;__printf__&lt;/code&gt; 、 &lt;code&gt;__scanf__&lt;/code&gt; 、 &lt;code&gt;__strftime__&lt;/code&gt; または &lt;code&gt;__strfmon__&lt;/code&gt; を使用することもできます。）MinGWターゲットには、 &lt;code&gt;ms_printf&lt;/code&gt; 、 &lt;code&gt;ms_scanf&lt;/code&gt; 、および &lt;code&gt;ms_strftime&lt;/code&gt; も存在します。 &lt;code&gt;printf&lt;/code&gt; などの &lt;var&gt;archetype&lt;/var&gt; 値 システムのCランタイムライブラリが受け入れる形式を参照し、値の前に「</target>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="translated">パラメーター &lt;var&gt;string-index&lt;/var&gt; は、どの引数がフォーマット文字列引数であるかを指定します（1から開始）。非静的C ++メソッドには暗黙の &lt;code&gt;this&lt;/code&gt; 引数があるため、そのようなメソッドの引数は2から数える必要があります。</target>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="translated">特定の言語に固有のコンパイラの部分は、「フロントエンド」と呼ばれます。GCCの統合コンポーネントであるフロントエンドに加えて、個別に保守される他のいくつかのフロントエンドがあります。これらは、MercuryやCOBOLなどの言語をサポートしています。これらを使用するには、GCC本体とともにビルドする必要があります。</target>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="translated">特定のCPUに設定された特定のオプションは、そのCPUに最適なコードを生成するように見える設定に応じて、コンパイラのバージョンによって異なります。実際のハードウェアの機能を必ずしも反映しているわけではありません。個々のオプションを特定の値に設定したい場合は、</target>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="translated">異なる部分は色で強調表示されます（この場合は「double」と「float」）。</target>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="translated">トレース形成でカバーする必要がある関数の割合(実行頻度で加重)。プロファイルフィードバックが利用可能な場合に使用します。</target>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; の許容値は '</target>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="translated">&lt;var&gt;feature&lt;/var&gt; の許容値は、次のサブセクションにリストされています。&lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-行進&lt;/samp&gt; そして &lt;samp&gt;-mcpu&lt;/samp&gt;機能修飾子&lt;/a&gt;。競合する機能修飾子が指定されている場合、最も右側の機能が使用されます。</target>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="translated">含まれるものを検索する場所 '</target>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="translated">ビットフィールド内の位置は、構造体の先頭に最も近いビットの位置で、ビット単位で数えます。</target>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="translated">&lt;var&gt;visibility_type&lt;/var&gt; の可能な値は、ELF gABIの可視性設定に対応しています。</target>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="translated">最近書き込まれたものとは別のユニオンメンバーから読み取る（「タイプパニング」と呼ばれる）習慣は一般的です。でもで</target>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="translated">AArch64 タ ーゲ ッ ト で定義 さ れたプ ラ グ マは、 AArch64 タ ーゲ ッ ト 関数属性に対応 し ます。以下のように指定できます。</target>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="translated">S/390ターゲットで定義されたプラグマは、S/390ターゲットの機能属性といくつかの追加オプションに対応しています。</target>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="translated">メモリ内の構造体を返すための正確な規則は、ターゲットの設定マクロに依存します。</target>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="translated">プリコンパイルされたヘッダーファイルは、現在のコンパイルと同じ言語用に作成する必要があります。CのプリコンパイルされたヘッダをC++のコンパイルに使用することはできません。</target>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="translated">プリコンパイルされたヘッダーファイルは、現在のコンパイルで使用しているものと同じコンパイラバイナリで作成されている必要があります。</target>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="translated">上記の &lt;code&gt;struct line&lt;/code&gt; などの可変長型を宣言するための推奨されるメカニズムは、ISO C99 &lt;em&gt;フレキシブル配列メンバーで&lt;/em&gt;、構文とセマンティクスが少し異なります。</target>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="translated">プリプロセッサ定数 &lt;code&gt;__v850&lt;/code&gt; および &lt;code&gt;__v851__&lt;/code&gt; は、ターゲットのプロセッサバリアントに関係なく、常に定義されています。</target>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="translated">プリプロセッサマクロ &lt;code&gt;__nios2_arch__&lt;/code&gt; は、ターゲットのISAレベルを示す値1または2でプログラムで使用できます。</target>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">プリプロセッサマクロ &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; および &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; を使用して、 &lt;code&gt;inline&lt;/code&gt; 関数に有効なセマンティクスを確認できます。Cプリプロセッサの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;一般的な事前定義マクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="translated">これらのアドレススペースがサポートされている場合、プリプロセッサシンボル &lt;code&gt;__SEG_FS&lt;/code&gt; および &lt;code&gt;__SEG_GS&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="translated">エスケープされた改行のプリプロセッサ処理は、改行がバックスラッシュの直後に続くことが必要なC90標準で指定されているものよりも緩和されています。 GCCの実装では、スペース、水平および垂直タブの形式の空白、およびバックスラッシュと後続の改行の間の改ページが許可されます。プリプロセッサーは警告を出しますが、それを有効なエスケープされた改行として扱い、2つの行を結合して1つの論理行を形成します。これは、コメントとトークン内だけでなく、トークン間でも機能します。コメントがされて&lt;em&gt;いない&lt;/em&gt;、彼らはまだ空白に置き換えられていないので、この緩和の目的のためにホワイトスペースとして処理しました。</target>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="translated">プログラムカウンタ(PC)は2バイト幅です。これは、最大128KiBのプログラムメモリを持つデバイスの場合です。</target>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="translated">ヘッダファイルを固定するプログラムは、シンボリックリンクを使用するこの特別な方法を理解していません;したがって、固定されたヘッダファイルのディレクトリは、それを構築するために使用されるマシンモデルのためだけに良いです。</target>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 修飾子とは、関数がスタックを動的に操作することを意味します。上記の静的割り当てに加えて、関数の本体でスタックの調整が行われます。たとえば、関数呼び出しの周りに引数をプッシュ/ポップします。 &lt;code&gt;bounded&lt;/code&gt; の修飾子も存在する場合、これらの調整の量はコンパイル時に制限され、2番目のフィールドは、関数によって使用されるスタックの総量の上限です。存在しない場合、これらの調整の量はコンパイル時に制限されず、2番目のフィールドは制限された部分のみを表します。</target>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 修飾子は、関数がスタックを静的に操作することを意味します。固定バイト数が関数の入り口でフレームに割り当てられ、関数の出口で解放されます。それ以外の場合、関数ではスタック調整は行われません。2番目のフィールドは、この固定バイト数です。</target>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="translated">同一精度の別の拡張整数型に対する任意の拡張整数型の順位(C99及びC11 6.3.1.1)。</target>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="translated">ローカル変数にアンダースコアで始まる名前を使用する理由 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; およびbに置き換えられる式内で発生する変数名との競合を回避するためです。最終的には、初期化子の後にのみスコープが始まる変数を宣言できる新しい形式の宣言構文を設計したいと考えています。これは、このような競合を防ぐためのより信頼できる方法です。</target>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="translated">引数と戻り値のレジスタ割り当ては同じですが、各スカラー値は、32ビットレジスタのペアではなく、単一の64ビットレジスタで渡されます。たとえば、スカラー浮動小数点値は '</target>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="translated">short insnsで使用可能なレジスタクラス。これはレジスタクラスの制約であるため、レジスタの割り当てを制御できます。この制約は、一致しない限り一致しません。</target>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="translated">short insnsで使用可能なレジスタグループ。この制約はレジスタクラスを使用しないため、適切なレジスタにパッシブに一致するだけで、レジスタの割り当ては行われません。</target>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="translated">Rxで示されたレジスタ(未実装)。</target>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="translated">割り込み用に予約されているレジスター（ &lt;code&gt;R24&lt;/code&gt; から &lt;code&gt;R31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="translated">オブジェクトの表現の関連するバイトは、アクセスに使用されるタイプのオブジェクトとして扱われます。&lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punningを&lt;/a&gt;参照してください。これはトラップ表現である可能性があります。</target>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="translated">このセクションの残りの部分はGNU C90のインライン化に特有のものです。</target>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="translated">残りの環境変数は、指定された特定の言語を前処理する場合にのみ適用されます。それぞれの環境変数は、検索されるディレクトリのリストを</target>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="translated">残りの関数は最適化のために提供されています。</target>
        </trans-unit>
        <trans-unit id="1f81fad037120bbd5cb1f32f0f1474309573caa7" translate="yes" xml:space="preserve">
          <source>The required &lt;var&gt;ref-index&lt;/var&gt; positional argument denotes a function argument of pointer (or in C++, reference) type that is subject to the access. The same pointer argument can be referenced by at most one distinct &lt;code&gt;access&lt;/code&gt; attribute.</source>
          <target state="translated">必要な &lt;var&gt;ref-index&lt;/var&gt; 位置引数は、アクセスの対象となるポインター（またはC ++では参照）タイプの関数引数を示します。同じポインタ引数は、多くても1つの異なる &lt;code&gt;access&lt;/code&gt; 属性で参照できます。</target>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="translated">それぞれのセグメントベースは、オペレーティングシステムに固有の方法で設定する必要があります。これらのアドレススペースは、セグメントベースを取得するために高価なシステムコールを必要とするのではなく、汎用（フラット）アドレススペースのサブスペースとは見なされません。つまり、これらのアドレス空間と汎用アドレス空間の間でポインターを変換するには、明示的なキャストが必要です。実際には、アプリケーションは &lt;code&gt;uintptr_t&lt;/code&gt; にキャストし、以前にインストールしたセグメントベースオフセットを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="translated">この議論の残りの部分では、説明のために以下のコードを使用しています。</target>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; の制限は、C ++標準の将来のバージョンで緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_rlmi&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転させ、それをマスクの下で2番目の引数ベクトルに挿入することによって取得されます。3番目の引数ベクトルには、各要素のビット11:15で始まるマスク、ビット19:23で終わるマスク、およびビット27:31のシフトカウントが含まれています。</target>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="translated">&lt;code&gt;vec_rlnm&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転し、2番目と3番目の引数ベクトルで指定されたマスクとAND 演算することによって取得されます。2番目の引数ベクトルには、下位バイトの各要素のシフトカウントが含まれます。3番目の引数ベクトルには、下位バイトの各要素のマスクの終わりが含まれ、マスクは次に高いバイトから始まります。</target>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_vrlnm&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転し、それをマスクとANDすることによって取得されます。2番目の引数ベクトルには、各要素のビット11:15で始まるマスク、ビット19:23で終わるマスク、およびビット27:31のシフトカウントが含まれています。</target>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="translated">自動またはスレッドストレージ期間を持つオブジェクトに、そのオブジェクトが関連付けられているスレッド以外から間接的にアクセスしようとした結果(C11 6.2.4)。</target>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="translated">ポインタを整数に変換した結果、またはその逆の結果(C90 6.3.4、C99、C11 6.3.2.3)。</target>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="translated">その型のオブジェクトで値を表すことができない場合に,整数を符号付き整数型に変換した結果又はそれによって生じた信号(C90 6.2.1.2,C99及びC11 6.3.1.3)。</target>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="translated">結果として得られるコードは、大多数の場合ではかなり高速になり、387コードの数値的不安定性の問題を回避できるはずですが、一時的に80ビットのテンポラリを期待する既存のコードが壊れてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="translated">符号付き整数に対するいくつかのビット演算の結果(C90 6.3、C99、C11 6.5)。</target>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="translated">型修飾子を含む戻りの型。たとえば、 &lt;code&gt;int&lt;/code&gt; を返すメソッドには、ここに &lt;code&gt;i&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="translated">戻り値は &lt;var&gt;exp&lt;/var&gt; の値であり、整数式でなければなりません。組み込みのセマンティクスは、 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; であることが期待されていることです。例えば：</target>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="translated">メソッドの戻り値は、現在のバッチ内のオブジェクトの数です。これは、呼び出し側から要求されたバッチの最大サイズである &lt;code&gt;len&lt;/code&gt; を超えてはなりません。バッチ自体は、 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 構造体の &lt;code&gt;itemsPtr&lt;/code&gt; フィールドに返されます。</target>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">&lt;code&gt;FLT_ROUNDS&lt;/code&gt; の非標準値（C90、C99およびC11 5.2.4.2.2）を特徴とする丸め動作。</target>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="translated">ランタイムサポートファイル</target>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="translated">このようなコードを書くための安全な方法は、一時的に名前を与えることで、名前のスコープが終わるまで強制的に残るようにすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="translated">同じ</target>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="translated">引数には、対応する &lt;code&gt;__atomic_op_fetch&lt;/code&gt; 組み込み関数と同じ制約が適用されます。すべてのメモリ順序が有効です。</target>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="translated">引数には、対応する &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; 組み込み関数と同じ制約が適用されます。</target>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="translated">1つの出力パラメーター（ &lt;var&gt;a&lt;/var&gt; ）がレジスター制約を許可し、別の出力パラメーター（ &lt;var&gt;b&lt;/var&gt; ）がメモリー制約を許可する場合にも、同じ問題が発生する可能性があります。メモリアドレスにアクセスするためのGCCによって生成されたコード &lt;var&gt;b&lt;/var&gt; 登録含有することができる&lt;em&gt;かもしれません&lt;/em&gt;で共有すること、およびGCCは、これらのレジスタは、ASMへの入力であると考えます。上記のように、GCCは、出力が書き込まれる前に、そのような入力レジスタが消費されることを想定しています。 &lt;code&gt;asm&lt;/code&gt; ステートメントが &lt;var&gt;b&lt;/var&gt; を使用 &lt;var&gt;a&lt;/var&gt; 前にaに書き込む場合、この仮定は誤った動作を引き起こす可能性があります。を組み合わせる &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="translated">の値は同じです。</target>
        </trans-unit>
        <trans-unit id="10b4b93db032b4ab2baad7ea49ce309b241f5e8b" translate="yes" xml:space="preserve">
          <source>The scale (in percents) applied to</source>
          <target state="translated">に適用されるスケール(パーセンテージ)は</target>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="translated">2番目と3番目の &lt;code&gt;FOO&lt;/code&gt; はコメントに含める必要があります。この警告はデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="translated">&lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; および &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; の2番目の引数は、0または1の定数整数でなければなりません。これらの組み込み関数の3番目の引数は、0〜15の範囲の定数整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="translated">2番目の引数 &lt;var&gt;failval&lt;/var&gt; はオプションであり、省略した場合のデフォルトはゼロです。</target>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="translated">このディレクティブの2番目の形式は、異なるディレクトリに同じ名前のヘッダーが複数ある場合に役立ちます。この形式を使用する場合、同じ文字列を '</target>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="translated">&lt;var&gt;n2&lt;/var&gt; ： &lt;var&gt;m2&lt;/var&gt; 値の2番目のペアでは、セカンダリアライメントを指定できます。</target>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="translated">セキュリティの延長線上にある</target>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="translated">修飾子の意味は、 'を前に付けることで反転できます。</target>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="translated">コンパイラ、アセンブラ、リンカ、言語ランタイムサポートなど、プログラムのバイナリ表現を扱うすべてのツールが従うランタイム規約のセット。ABIの中には、複数の関係者によって設計された、仕様書が書かれた形式的なものもあります。また、特定のツールセットによって実際に行われていることを単純に表しているものもあります。</target>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="translated">設定 '</target>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="translated">シャドウスタックの巻き戻しコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="translated">整数除算における剰余の符号(C90 6.3.5)。</target>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="translated">最も単純な種類の制約は文字列で、それぞれが許されるオペランドの種類を記述しています。ここに許可されている文字列があります。</target>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="translated">単精度および倍精度のFPv5浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="translated">単精度浮動小数点命令と倍精度浮動小数点命令です。</target>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="translated">単精度FPv5浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">倍精度16個のレジスタを持つ単精度VFPv3浮動小数点命令と半精度浮動小数点変換演算。</target>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">単精度VFPv3浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="translated">単精度VFPv4浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="translated">単精度浮動小数点命令です。</target>
        </trans-unit>
        <trans-unit id="2d2a7508c4cb1900d0918961e8e0427152b72902" translate="yes" xml:space="preserve">
          <source>The size in bits of &lt;code&gt;double&lt;/code&gt; if</source>
          <target state="translated">サイズをビット単位 &lt;code&gt;double&lt;/code&gt; の場合</target>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; のサイズは8バイトで、長さがゼロのビットフィールドです。長さゼロのビットフィールドが削除された場合、 &lt;code&gt;t1&lt;/code&gt; のサイズは4バイトになります。</target>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="translated">L1 データキャッシュのサイズをキロバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="translated">L2 データキャッシュのサイズをキロバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="translated">L1 データキャッシュのキャッシュラインのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="translated">同じ配列の要素へのポインタを2つ減算した結果のサイズ(C90 6.3.6,C99,C11 6.5.6)。</target>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="translated">すべての構造体と組合のサイズは、このオプシ ョ ンで設定したビ ッ ト 数の倍数に切り上げられます。許容される値は8、32、64です。デフォルト値はツールチェインによって異なります。COFF対象のツールチェインでは、デフォルト値は8です。 64の値は、基礎となるABIがそれをサポートしている場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="translated">小さなデータ領域は、セクション &lt;code&gt;.sdata&lt;/code&gt; と &lt;code&gt;.sbss&lt;/code&gt; で構成されています。オブジェクトは、これらのセクションのいずれかを使用して、 &lt;code&gt;section&lt;/code&gt; 属性を持つ小さなデータ領域に明示的に配置できます。</target>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="translated">条件分岐のツリーではなく、ジャンプテーブルを使用するのが最適な、異なる値の最小数。値が0の場合、マシンのデフォルト値を使用します。</target>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">解決策は、適切なシステムヘッダー（ISO Cヘッダーのあるシステムでは &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; )を使用するようにプログラムを変更し、システムヘッダーファイルで宣言されている場合は &lt;code&gt;time&lt;/code&gt; を宣言しないこと、または &lt;code&gt;time_t&lt;/code&gt; を &lt;code&gt;time&lt;/code&gt; 戻り型として使用できないようにすることです。。</target>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="translated">を使用しないことで解決します。</target>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="translated">これらの問題の解決策は、プログラムを変更して、これらの目的のために、文字列定数の代わりに初期化文字列を持つ &lt;code&gt;char&lt;/code&gt; -array変数を使用することです。</target>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="translated">std::terminate が呼ばれる前にスタックが巻き戻されません。</target>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="translated">スタックポインタ(SP)レジスタはコンパイラによってそれぞれ8ビット、16ビットのレジスタとして扱われます。これらのマクロの定義は</target>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="translated">スタックポインタレジスタ（ &lt;code&gt;SP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="translated">スタックポインタレジスタです。</target>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="translated">この標準では、プログラムの2つの環境も定義&lt;em&gt;しています&lt;/em&gt;。これは、すべての実装に必要な&lt;em&gt;独立型環境&lt;/em&gt;であり、プログラムの起動と終了の処理が実装定義である、独立型実装に必要なものを超えるライブラリ機能がない場合があります。そして&lt;em&gt;ホスト環境&lt;/em&gt;のすべてのライブラリの施設が設けられている、必要と起動が関数を介して行われていない、 &lt;code&gt;int main (void)&lt;/code&gt; または &lt;code&gt;int main (int, char *[])&lt;/code&gt; 。OSカーネルは、独立した環境で実行されるプログラムの例です。オペレーティングシステムの機能を使用するプログラムは、ホスト環境で実行されるプログラムの例です。</target>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="translated">標準は混乱を招くように表現されているため、微妙なケースではシーケンスポイントルールの正確な意味についていくつかの議論があります。提案された正式な定義を含む問題の議論へのリンクは、&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.htmlの&lt;/a&gt; GCCリーディングページにあります。</target>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="translated">&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; マクロの標準規則は、関数間で型が異なるパラメーターの引数の型から共通の型 &lt;var&gt;u&lt;/var&gt; を見つけるために使用されます。複雑な整数型（GNU拡張）は、この目的のために &lt;code&gt;_Complex double&lt;/code&gt; （または関数の戻り型がすべて &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; または &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x型の場合は &lt;code&gt;_Complex _Float64&lt;/code&gt; ）のように扱われます。関数の戻り値の型が異なる場合、またはすべて同じ整数型である場合、呼び出される関数は &lt;var&gt;t&lt;/var&gt; の関数です。が &lt;var&gt;u&lt;/var&gt; です、そのような関数がない場合はエラーになります。関数の戻り値の型がすべて同じ浮動小数点型である場合、型汎用の​​マクロは、結果をより狭い型に丸めるTS 18661のマクロの1つと見なされます。 &lt;var&gt;t&lt;/var&gt; が &lt;var&gt;u&lt;/var&gt; である関数が存在する場合、それが呼び出されます。それ以外の場合、 &lt;var&gt;t&lt;/var&gt; が少なくとも &lt;var&gt;u&lt;/var&gt; の範囲と精度を持つ最初の関数（存在する場合）が呼び出され、そのような関数がない場合はエラーになります。 。</target>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="translated">libgccの起動コードがEINDを設定することはあり &lt;code&gt;EIND&lt;/code&gt; 。スタートアップコードは、libgccとAVR-LibCのコードのブレンドであることに注意してください。上のAVR-のlibc影響を &lt;code&gt;EIND&lt;/code&gt; 、参照&lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-のlibcマニュアルを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="translated">スタートアップコードは、 &lt;code&gt;RAMP&lt;/code&gt; 特殊機能レジスタをゼロで初期化します。</target>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="translated">スレッド記憶期間のオブジェクトの記憶装置は,スレッド起動関数の最初の文の前に静的に初期化されなければならない。スレッド記憶期間のオブジェクトは,動的な初期化を必要としないものとする。</target>
        </trans-unit>
        <trans-unit id="641e9d242dbf689a8dfa4b2d4275700a77a5107c" translate="yes" xml:space="preserve">
          <source>The stored representation of the return address in memory may be different from the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt;. For example, on AArch64 the stored address may be mangled with return address signing whereas the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; is not.</source>
          <target state="translated">メモリに格納されている戻りアドレスの表現は、 &lt;code&gt;__builtin_return_address&lt;/code&gt; によって返されるアドレスとは異なる場合があります。返されたアドレスに対し、例えば、AArch64に格納されたアドレスは、リターンアドレスの署名とマングルすることができる &lt;code&gt;__builtin_return_address&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">構造のサイズはゼロです。C ++では、空の構造は言語の一部です。G ++は、空の構造体を &lt;code&gt;char&lt;/code&gt; 型の単一のメンバーがあるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="translated">作成されたファイルのサブタイプ（「</target>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">'内のテキスト &lt;code&gt;S&lt;/code&gt; に一致するスイッチ</target>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="translated">この拡張子の構文は</target>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="translated">合成比較タイプ&amp;ndash; gt、lt、ge、le。</target>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="translated">割り込みハンドラに入る前に、すべてのレジスタをスタックに保存するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="translated">割り込みハンドラに入る前に、呼び出し元のレジスタをスタックに保存するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="translated">次の表に、DSP ASE REV 2のハードウェアサポートが存在する &lt;code&gt;v2i16&lt;/code&gt; の動作を示します &lt;code&gt;e&lt;/code&gt; および &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;v2i16&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="translated">次の表は、ハードウェアサポートが存在する &lt;code&gt;v2sf&lt;/code&gt; 操作を示しています。 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; は &lt;code&gt;v2sf&lt;/code&gt; 値で、 &lt;code&gt;x&lt;/code&gt; はは整数値です。</target>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="translated">次の表は、ハードウェアサポートが存在する &lt;code&gt;v4i8&lt;/code&gt; および &lt;code&gt;v2q15&lt;/code&gt; 操作を示しています。 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;v4i8&lt;/code&gt; の値で、 &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;v2q15&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="translated">以下の表は、各アーキテクチャでサポートされている拡張機能の一覧です。記載されていないアーキテクチャは拡張機能をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="translated">下の表は、サポートされている修飾子の一覧とその効果を示しています。</target>
        </trans-unit>
        <trans-unit id="52323f293e0d860891a87bc29f48cbde573c5856" translate="yes" xml:space="preserve">
          <source>The table below summarizes the permissible values for &lt;var&gt;arch&lt;/var&gt; and the features that they enable by default:</source>
          <target state="translated">次の表は、 &lt;var&gt;arch&lt;/var&gt; の許容値と、それらがデフォルトで有効にする機能をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">ターゲットは、 &lt;code&gt;format-arg&lt;/code&gt; 属性で追加の型を許可する場合もあります。&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定のターゲットマシンに固有のフォーマットチェックを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">ターゲットは、追加タイプのフォーマットチェックを提供する場合もあります。&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定のターゲットマシンに固有のフォーマットチェックを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="translated">シブコールの呼び出しアドレスを保持するために使用できるレジスタのレジスタクラス。すなわち、呼び出し元が保存されたレジスタです。</target>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="translated">3番目の単語は、コンパイラがデバッグ情報を出力する必要のある構造体のソースファイルを指定します。その価値 '</target>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数で実行を開始するスレッドは、&lt;em&gt;メインスレッド&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。メインスレッド以外のスレッドを開始する関数がどのように指定または型付けされるかは、実装によって定義されます。このように指定された関数と &lt;code&gt;main&lt;/code&gt; 関数は、&lt;em&gt;スレッド起動関数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これは、スレッド起動関数が戻った場合にどうなるかを定義した実装です。これは、スレッド呼び出しが &lt;code&gt;exit&lt;/code&gt; ときに他のスレッドに何が起こるかを定義した実装です。</target>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="translated">3つのタイプのインライン化は、2つの重要なケースで同様に動作します。上記の例のように、 &lt;code&gt;static&lt;/code&gt; 関数で &lt;code&gt;inline&lt;/code&gt; キーワードが使用されている場合と、次のように関数が最初に &lt;code&gt;inline&lt;/code&gt; キーワードを使用せずに宣言され、次に &lt;code&gt;inline&lt;/code&gt; で定義されている場合：</target>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="translated">リロード後に部分的な冗長性の除去を行うための閾値比。</target>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="translated">リロード後の冗長性除去を可能にするクリティカルエッジの実行回数の閾値比。</target>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="translated">入力+出力+gotoオペランドの合計数は30個までです。</target>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="translated">すべてのパラメーターを渡すために必要な合計サイズ（バイト単位）。これには、2つの非表示パラメーター（オブジェクト &lt;code&gt;self&lt;/code&gt; とメソッドセレクター &lt;code&gt;_cmd&lt;/code&gt; ）が含まれます。</target>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="translated">トランザクションは、永続的な失敗のために中断されました。同じ状況での再実行は生産的ではありません。</target>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="translated">トランザクションはトランジェント障害のために中断されました。その場合、トランザクションは再実行されるべきです。</target>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="translated">トランザクションは、持続する可能性のある不確定な状態のために中断されました。</target>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="translated">2つのScalar Reduction of Aggregatesパス(SRAとIPA-SRA)は、集合体のスカラー部分を独立したスカラー変数で置き換えることを目的としています。これらのパラメータは、高速化のためにコンパイルする際に置き換えのために考慮される集合体の最大サイズを、ストレージ単位で制御します (</target>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型は、その動作が常にこれら2つのいずれかと同じである場合でも、常に &lt;code&gt;signed char&lt;/code&gt; または &lt;code&gt;unsigned char&lt;/code&gt; のそれぞれとは異なる型です。</target>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="translated">型 &lt;code&gt;int[]&lt;/code&gt; と &lt;code&gt;int[5]&lt;/code&gt; は互換性があります。一方、 &lt;code&gt;int&lt;/code&gt; と &lt;code&gt;char *&lt;/code&gt; は、特定のアーキテクチャで型のサイズが同じであっても互換性がありません。また、類似性を決定するときに、ポインターの間接参照の量も考慮されます。したがって、 &lt;code&gt;short *&lt;/code&gt; は &lt;code&gt;short **&lt;/code&gt; と似ていません。さらに、typedefされている2つの型は、その基礎となる型に互換性がある場合、互換性があると見なされます。</target>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="translated">スレッド格納期間を持つオブジェクトの型は,非自明デストラクタを持ってはならず,また,その要素が(直接または間接的に)非自明デストラクタを持つ配列型であってはならない。</target>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="translated">これらの定数のタイプは、8進数または16進数の整数定数と同じ規則に従うため、 'のような接尾辞</target>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="translated">型指定子は型の直前にエンコードされます。しかし、型とは異なり、型指定子はメソッドの引数型に現れたときにのみエンコードされます。</target>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="translated">型は以下のようにエンコードされています。</target>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="translated">この方法で定義された型は、通常のC操作のサブセットで使用できます。現在、GCCでは、これらのタイプで次の演算子を使用できます： &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="translated">使用される長い呼び出しの種類は、アセンブラとリンカの能力と生成されるコードの種類に依存します。長い絶対コールや長い pic シンボル差分や pc 相対コールをサポートしているシステムへの影響は比較的小さいはずです。しかし、32ビットELFシステムでは間接呼び出しがpicコードで使用されており、かなり長いです。</target>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="translated">指定する関数のタイプはすべて異なる必要がありますが、 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; のマクロによって選択される可能性のある関数のセットと同じように互いに関連しています。つまり、関数は、浮動小数点型 &lt;var&gt;t&lt;/var&gt; によってパラメーター化され、そのような関数ごとに異なります。関数の戻り型は、すべて同じタイプであってもよいし、またはそれらはあってもよい &lt;var&gt;t&lt;/var&gt; 機能ごとに、またはそれらが対応する実数型とすることができる &lt;var&gt;t&lt;/var&gt; の各機能（タイプのいくつかの場合のために &lt;var&gt;t&lt;/var&gt; 複雑です）。同様に、各パラメータの位置について、その位置におけるパラメータの種類は、常に同じ種類であってもよいし、とすることができる &lt;var&gt;t&lt;/var&gt; 各関数（この場合、少なくとも1つのパラメーター位置に適用する必要があります）、または各関数の &lt;var&gt;t&lt;/var&gt; に対応する実数型の場合があります。</target>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="translated">拡張 &lt;code&gt;asm&lt;/code&gt; ステートメントの一般的な用途は、入力値を操作して出力値を生成することです。ただし、 &lt;code&gt;asm&lt;/code&gt; ステートメントによって副作用が生じる場合もあります。その場合、特定の最適化を無効にするために &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用する必要がある場合があります。&lt;a href=&quot;#Volatile&quot;&gt;揮発性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="translated">単項プラス演算子です。</target>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="translated">基礎となるタイプ &lt;code&gt;type&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は列挙型（[dcl.enum]）である必要があります。</target>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="translated">標準アルファベットエスケープシーケンス(C90、C99及びC11 5.2.2.2)のそれぞれに対して生成された実行文字セットのメンバの一意の値。</target>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="translated">関数ポインタや関数型定義子など、標準では許可されていない場所でのデフォルト引数の使用は非推奨であり、将来のG++のバージョンからは削除される予定です。</target>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="translated">通常の呼び出し規約には、FPUがない場合でも、FPUレジスタに &lt;code&gt;float&lt;/code&gt; 型と &lt;code&gt;double&lt;/code&gt; 型の値を返す関数があります。この考え方は、オペレーティングシステムはFPUをエミュレートする必要があるということです。</target>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="translated">GCCを実行する通常の方法は、 &lt;code&gt;gcc&lt;/code&gt; と呼ばれる実行可能ファイル、またはクロスコンパイル時に &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; 、または特定のバージョンのGCCを実行するための &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; を実行することです。C ++プログラムをコンパイルするときは、代わりにGCCを &lt;code&gt;g++&lt;/code&gt; として呼び出す必要があります。&lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;C ++プログラム&lt;/a&gt;をコンパイルするときの &lt;code&gt;gcc&lt;/code&gt; と &lt;code&gt;g++&lt;/code&gt; 動作の違いについては、C ++プログラムのコンパイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序の変異体である &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 、および &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序の変異体である &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 、および &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序バリアントは、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、__ATOMIC_SEQ_CST、および &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="translated">値 '</target>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="translated">値 &lt;code&gt;branch&lt;/code&gt; は、間接的なブランチ命令（call / jmp命令）のポイントで制御フロー転送の有効性のチェックを実装するようコンパイラーに指示します。 &lt;code&gt;return&lt;/code&gt; 値は、関数から戻るときに有効性のチェックを実装します。値 &lt;code&gt;full&lt;/code&gt; は、 &lt;code&gt;branch&lt;/code&gt; と &lt;code&gt;return&lt;/code&gt; 両方を指定するためのエイリアスです。値 &lt;code&gt;none&lt;/code&gt; は、インスツルメンテーションをオフにします。</target>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="translated">値 &lt;var&gt;N&lt;/var&gt; の範囲は0〜4です。値0（デフォルト）または4は、任意のサイズの定数が許可されることを意味します。</target>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="translated">値は規格に規定されている通りであり、型はABIによって決定される。</target>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COMPILER_PATH&lt;/code&gt; の値は、 &lt;code&gt;PATH&lt;/code&gt; によく似た、コロンで区切られたディレクトリのリストです。GCCは、 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; を使用してサブプログラムを見つけることができない場合、サブプログラムを検索するときにこのように指定されたディレクトリを試みます。</target>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; の値は単なるファイル名にすることができます。この場合、Makeルールはそのファイルに書き込まれ、ソースファイル名からターゲット名を推測します。または、値の形式は '</target>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="translated">&lt;code&gt;LIBRARY_PATH&lt;/code&gt; の値は、 &lt;code&gt;PATH&lt;/code&gt; と同様に、コロンで区切られたディレクトリのリストです。ネイティブコンパイラとして構成されている場合、GCCは &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; を使用してそれらを見つけることができない場合、特別なリンカーファイルを検索するときに指定されたディレクトリを試します。GCCを使用したリンクでは、通常のライブラリを検索するときにこれらのディレクトリも使用します。</target>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; の値は、1970年1月1日00:00:00以降の秒数（うるう秒を除く）として定義されたUNIXタイムスタンプでなければなりません。'の出力と同じ</target>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; の値は、プリフェッチするメモリのアドレスです。オプションの引数には、 &lt;var&gt;rw&lt;/var&gt; と &lt;var&gt;locality&lt;/var&gt; の 2つがあります。 &lt;var&gt;rw&lt;/var&gt; の値は、コンパイル時の定数1または0です。1つは、プリフェッチがメモリアドレスへの書き込みの準備をしていることを意味し、0（デフォルト）は、プリフェッチが読み取りの準備をしていることを意味します。値 &lt;var&gt;locality&lt;/var&gt; 0から3までのコンパイル時定数整数でなければなりません。ゼロの値は、データに一時的な局所性がないことを意味するため、アクセス後にデータをキャッシュに残す必要はありません。値3は、データに高度な時間的局所性があり、可能なすべてのレベルのキャッシュに残す必要があることを意味します。1と2の値は、それぞれ低または中程度の時間的局所性を意味します。デフォルトは3です。</target>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="translated">&lt;var&gt;arguments&lt;/var&gt; の値は、 &lt;code&gt;__builtin_apply_args&lt;/code&gt; によって返される値である必要があります。引数の &lt;var&gt;size&lt;/var&gt; バイト単位で、引数のスタックデータのサイズを指定します。</target>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="translated">基本実行文字セット（C90 6.1.2.5、C99およびC11 6.2.5）のメンバー以外の文字が格納されている &lt;code&gt;char&lt;/code&gt; オブジェクトの値。</target>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">実行文字集合(C90 6.1.4、C99及びC11 6.4.5)で表現されていないマルチバイト文字又はエスケープシーケンスを含む文字列リテラルの値。</target>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">拡張実行文字集合の複数のメンバに対応するマルチバイト文字又は単一のマルチバイト文字を含む幅広文字定数の値、又は拡張実行文字集合に表れないマルチバイト文字又はエスケープシーケンスを含む幅広文字定数の値(C90 6.1.3.4、C99及びC11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">つ以上の文字を含む整数文字定数の値、又はシングルバイト実行文字にマッピングされない文字又はエスケープシーケンスを含む文字定数の値(C90 6.1.3.4、C99及びC11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; および &lt;code&gt;_Alignof&lt;/code&gt; 演算子の結果の値（C90 6.3.3.4、C99およびC11 6.5.3.4）。</target>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="translated">この値は、ソースやパッケージの最終修正時刻などの既知のタイムスタンプで、ビルドプロセスで設定します。</target>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="translated">その価値 '</target>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="translated">実行文字セット(C90、C99、C11 5.2.1)のメンバの値。</target>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; で指定されたマクロに割り当てられた値または式（C90、C99およびC11 5.2.4.2、C99 7.18.2、C99 7.18.3、 C11 7.20.2、C11 7.20.3）。</target>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="translated">ペアの単一の値に関連付けられたベクトルタイプは、通常 &lt;code&gt;v2sf&lt;/code&gt; と呼ばれます。Cでは次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="translated">仮想レジスタです。</target>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="translated">visibility属性は、そうでなければ外部リンクを持つ宣言にのみ適用されるべきである。属性は一貫して適用されるべきであり、同じ実体が属性の異なる設定で宣言されてはならない。</target>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="translated">&lt;code&gt;#line&lt;/code&gt; ディレクティブの後に警告が発行されることはありません。これは通常、自動生成されたコードを示しており、ディレクティブが参照するファイルのレイアウトについて想定できないためです。</target>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="translated">以下の例のような複数行のプリプロセッサ・ロジックを含むコードでは、警告は発生しません。</target>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="translated">制御可能な各警告の警告メッセージには、警告を制御するオプションが含まれています。そのオプションは</target>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="translated">センチネルが見つからなかったり、間違ったセンチネルがあった場合の警告は</target>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="translated">これらの問題を解決する方法は、</target>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="translated">分割正誤表の回避策は</target>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="translated">x86アーキテクチャは、ハードウェアロックエリシオンのための重要なセクションをマークするための追加のメモリ順序フラグをサポートしています。これらは、既存のメモリ順序に加えて、アトミックイントリニクスへのメモリ順序を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="translated">x86-32およびx86-64ファミリーのプロセッサーは、 &lt;code&gt;TF&lt;/code&gt; （ &lt;code&gt;__float128&lt;/code&gt; ）128ビット浮動小数点値および &lt;code&gt;TC&lt;/code&gt; 128ビット複素浮動小数点値を効率的に使用するために追加の組み込み関数を使用します。</target>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;create_gcov&lt;/code&gt; ツールを使用して、生のプロファイルデータをGCCで使用できる形式に変換します。プログラムのストリップされていないバイナリもこのツールに提供する必要があります。&lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdoを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="translated">すると、こんな感じでインデックス付きのラベルを選択することができます。</target>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="translated">指定できるメモリ順序は6種類あります。これらは、同じ名前のC ++ 11メモリオーダーにマッピングされます。詳細な定義については、C ++ 11標準または&lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;アトミック同期に関するGCC wikiを&lt;/a&gt;参照してください。個々のターゲットは、特定のアーキテクチャーで使用するための追加のメモリー順序もサポートする場合があります。これらの詳細については、ターゲットのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">GNU拡張関数 &lt;code&gt;clog10&lt;/code&gt; 、 &lt;code&gt;clog10f&lt;/code&gt; 、および &lt;code&gt;clog10l&lt;/code&gt; もあり、これらの名前は将来の使用のためにISO C99によって予約されています。これらのすべての関数には、 &lt;code&gt;__builtin_&lt;/code&gt; で始まるバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">そこにはまた、内蔵されている機能 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 、 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、 &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 及び &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、TS 18661から3つの関数に対応 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 、 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、 &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 及び &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; サポートされているタイプの、 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; と &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">あり、内蔵されているISO C99関数のバージョン &lt;code&gt;acosf&lt;/code&gt; 、 &lt;code&gt;acosl&lt;/code&gt; 、 &lt;code&gt;asinf&lt;/code&gt; 、 &lt;code&gt;asinl&lt;/code&gt; 、 &lt;code&gt;atan2f&lt;/code&gt; 、 &lt;code&gt;atan2l&lt;/code&gt; 、 &lt;code&gt;atanf&lt;/code&gt; 、 &lt;code&gt;atanl&lt;/code&gt; 、 &lt;code&gt;ceilf&lt;/code&gt; 、 &lt;code&gt;ceill&lt;/code&gt; 、 &lt;code&gt;cosf&lt;/code&gt; 、 &lt;code&gt;coshf&lt;/code&gt; 、 &lt;code&gt;coshl&lt;/code&gt; 、 &lt;code&gt;cosl&lt;/code&gt; 、 &lt;code&gt;expf&lt;/code&gt; 、 &lt;code&gt;expl&lt;/code&gt; 、 &lt;code&gt;fabsf&lt;/code&gt; 、 &lt;code&gt;fabsl&lt;/code&gt; 、 &lt;code&gt;floorf&lt;/code&gt; 、 &lt;code&gt;floorl&lt;/code&gt; 、 &lt;code&gt;fmodf&lt;/code&gt; 、 &lt;code&gt;fmodl&lt;/code&gt; 、 &lt;code&gt;frexpf&lt;/code&gt; 、 &lt;code&gt;frexpl&lt;/code&gt; 、はISOです。これらの名前は、ISO C99が使用する目的で使用されます。これらのすべての関数には、対応するバージョンの接頭辞が付いています &lt;code&gt;ldexpf&lt;/code&gt; 、 &lt;code&gt;ldexpl&lt;/code&gt; 、 &lt;code&gt;log10f&lt;/code&gt; 、 &lt;code&gt;log10l&lt;/code&gt; 、 &lt;code&gt;logf&lt;/code&gt; 、 &lt;code&gt;logl&lt;/code&gt; 、 &lt;code&gt;modfl&lt;/code&gt; 、 &lt;code&gt;modf&lt;/code&gt; 、 &lt;code&gt;powf&lt;/code&gt; 、 &lt;code&gt;powl&lt;/code&gt; 、 &lt;code&gt;sinf&lt;/code&gt; 、 &lt;code&gt;sinhf&lt;/code&gt; 、 &lt;code&gt;sinhl&lt;/code&gt; 、 &lt;code&gt;sinl&lt;/code&gt; 、 &lt;code&gt;sqrtf&lt;/code&gt; 、 &lt;code&gt;sqrtl&lt;/code&gt; 、 &lt;code&gt;tanf&lt;/code&gt; 、 &lt;code&gt;tanhf&lt;/code&gt; 、 &lt;code&gt;tanhl&lt;/code&gt; と &lt;code&gt;tanl&lt;/code&gt; &lt;code&gt;__builtin_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="translated">また、フォーマットされた出力関数については、組み込み関数のチェックもあります。</target>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="translated">多くの一般的な文字列操作関数に追加された組み込み関数があります。たとえば、 &lt;code&gt;memcpy&lt;/code&gt; &lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; 組み込み関数が提供されています。この組み込みには、最後の引数が追加されています。これは、 &lt;var&gt;dest&lt;/var&gt; 引数が指すオブジェクトに残っているバイト数、またはサイズが不明な場合は &lt;code&gt;(size_t) -1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="translated">GCCでサポートされている警告のレベルは4段階です。デフォルトは</target>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="translated">サポートされる &lt;var&gt;visibility_type&lt;/var&gt; 値は4つあります：デフォルト、非表示、保護、または内部の可視性。</target>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="translated">セクション7.18a.6のISO / IEC TR 18037「Embedded C」固定小数点関数を実装するために使用されるAVR固有の組み込み関数は他にもたくさんあります。これらのビルトインを直接使用する必要はありません。代わりに、GNU-C99で &lt;code&gt;stdfix.h&lt;/code&gt; ヘッダーによって提供される宣言を使用します。</target>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="translated">他にも、想像力や良識、ビルドシステムの制約などで制限される可能性はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="translated">これら2つの方法には他にも違いがあります。 &lt;code&gt;alloca&lt;/code&gt; で割り当てられたスペースは、それを含む&lt;em&gt;関数&lt;/em&gt;が戻るまで存在します。可変長配列のスペースは、このスコープで &lt;code&gt;alloca&lt;/code&gt; を使用しない限り、配列名のスコープが終了するとすぐに割り当て解除されます。</target>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="translated">新しい例外の仕組みを使うには、いくつかの注意点があります。</target>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="translated">C ++には、オブジェクトファイルにスペースを必要とするいくつかの構造がありますが、単一の変換単位に明確に関連付けられていません。これらの構造には「あいまいなリンケージ」があると私たちは言います。通常、このような構造は必要な場所に出力されますが、より賢い場合もあります。</target>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="translated">CのGNU CバージョンとK＆R（非ISO）バージョンの間には、いくつかの注目すべき非互換性があります。</target>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="translated">アプリケーションが共有の</target>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="translated">すべてのマシンでビットフィールドをデフォルトで符号なしにすることにはいくつかの議論があります。例えば、これが普遍的なデファクトスタンダードになれば、GCCがそれに沿って進むことは理にかなっているでしょう。これは将来的に検討すべきことです。</target>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="translated">バイトコードを生成する際にGCCによって保存されるコード生成フラグがいくつかありますが、これは最終的なリンク中に使用する必要があるためです。現在のところ、以下のオプションとその設定は、それらを明示的に指定する最初のオブジェクトファイルから取得されます。</target>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="translated">これを使用する方法にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="translated">C ++の属性のセマンティクスにはいくつかの問題があります。たとえば、属性のマングリングはありませんが、コード生成に影響する可能性があるため、属性付きの型をテンプレートまたはオーバーロードと組み合わせて使用​​すると問題が発生する可能性があります。同様に、 &lt;code&gt;typeid&lt;/code&gt; は異なる属性を持つタイプを区別しません。C ++での属性のサポートは、将来的には宣言の属性のみに制限され、ネストされた宣言子では制限されない可能性があります。</target>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; に引数を書き込むには、式を使用する方法と型を使用する方法の2つがあります。次に、式の例を示します。</target>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="translated">いわゆる&lt;em&gt;弱いポインター&lt;/em&gt;参照を宣言するために使用できる新しいランタイム関数 &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; があります。このようなポインターは、ガベージコレクターには基本的に非表示です。これは、特定の状況で、特に割り当てられたオブジェクトを追跡しながら、それらを収集できるようにする場合に役立ちます。この種のポインターはオブジェクトのメンバーにのみなることができ、グローバルポインターを弱い参照として宣言することはできません。ポインター型であるすべての型は、 &lt;code&gt;id&lt;/code&gt; 、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;SEL&lt;/code&gt; などのウィークポインターとして宣言できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="translated">ビュー番号の表現には、DWARF 5 で導入された位置リスト形式との下位互換性がないものが提案されています。</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">はありません。</target>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="translated">Objective-CまたはObjective-C ++の正式な標準規格はありません。従来のObjective-C（1.0）に関する信頼できるマニュアルは「オブジェクト指向プログラミングとObjective-C言語」です&lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;。http&lt;/a&gt;：//www.gnustep.org/resources/documentation/ObjectivCBook.pdfは元のNeXTstepドキュメントです。</target>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="translated">増分が特定の順序で評価されるという保証はありません（CまたはC ++標準言語定義のいずれかで）。いずれかの増分が最初に発生する可能性があります。 &lt;code&gt;func&lt;/code&gt; は引数を取得する可能性があります '</target>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="translated">トランザクションが成功する保証はありませんので、常に有効なフォールバックパスが必要です。</target>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="translated">入れ子になっている方言の代替品のサポートはありません。</target>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="translated">1つのヘッダファイルの内容を複数の実装ファイルに分割する方法はありません。</target>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="translated">テンプレート内で、どの代替案が選択されたかを判断する方法はありません。しかし、あなたはあなたのラップすることができるかもしれ &lt;code&gt;asm&lt;/code&gt; ような組み込みコマンドとステートメントを &lt;code&gt;__builtin_constant_p&lt;/code&gt; 所望の結果を達成するために。</target>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="translated">属性とプラグマの目的にはいくつかの重複があります（&lt;a href=&quot;pragmas#Pragmas&quot;&gt;GCCで受け入れ&lt;/a&gt;られるプラグマを参照）。 &lt;code&gt;__attribute__&lt;/code&gt; を使用して、対応する宣言に属性を自然に付加するのが便利であることがわかっています。一方、 &lt;code&gt;#pragma&lt;/code&gt; は、文法の一部を自然には形成しない他のコンパイラまたは構成との互換性のために使用されます。</target>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="translated">関数プロトタイプなしで関数の引数に &lt;code&gt;long long&lt;/code&gt; 型を使用すると、落とし穴が生じる可能性があります。関数がその引数として &lt;code&gt;int&lt;/code&gt; 型を期待しているときに &lt;code&gt;long long int&lt;/code&gt; 型の値を渡すと、呼び出し元とサブルーチンが引数のバイト数について意見が一致しないため、混乱が生じます。関数が想定している場合同様に、 &lt;code&gt;long long int&lt;/code&gt; 、あなたは合格 &lt;code&gt;int&lt;/code&gt; 型。このような問題を回避する最良の方法は、プロトタイプを使用することです。</target>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="translated">そのため、G++ドライバは自動的に</target>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="translated">そのため、式</target>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="translated">これら '</target>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="translated">これらの追加 '</target>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="translated">これらの追加オプションは、Microsoft Windows ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="translated">これらの追加オプションは、System V Release 4では、これらのシステム上の他のコンパイラとの互換性のために利用可能です。</target>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">これらは、セクション &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; でデータを検索する16ビットのアドレススペースで、 &lt;var&gt;N&lt;/var&gt; はアドレススペース &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 指します。コンパイラーは、 &lt;code&gt;ELPM&lt;/code&gt; 命令によってデータを読み取る前に、 &lt;code&gt;RAMPZ&lt;/code&gt; セグメントレジスタを適切に設定します。</target>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="translated">これらは、対応する</target>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="translated">これらは、&lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000およびPowerPCオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="translated">これらはSee &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S / 390 and zSeries Optionsに&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="translated">これらは '</target>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="translated">これらは、Altera Nios II プロセッサ用に定義されたオプションです。</target>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="translated">これらはサポートされている修飾子です。</target>
        </trans-unit>
        <trans-unit id="3f0f74a8692c7935b66e165ba67cb1a501ff0206" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;).</source>
          <target state="translated">これらの属性は、同じ名前のMSP430関数属性と同じです（&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="translated">これらの属性は、同じ名前のMSP430関数属性と同じです（&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430関数属性を&lt;/a&gt;参照）。これらの属性は、関数と変数の両方に適用できます。</target>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">これらの属性は、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリシーケンスとエグジットシーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">これらの属性は、指定された関数が割り込みハンドラであることを示しています。使用 &lt;code&gt;fast_interrupt&lt;/code&gt; 低レイテンシ割り込みモード、およびで使用されるハンドラを示すために、属性を &lt;code&gt;interrupt_handler&lt;/code&gt; 低レイテンシのハンドラを使用していない割り込みのを。どちらの場合も、GCCは適切なプロローグコードを &lt;code&gt;rtid&lt;/code&gt; し、rtsdの代わりに &lt;code&gt;rtsd&lt;/code&gt; を使用してハンドラーからの戻りを生成します。</target>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="translated">これらの属性は</target>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="translated">これらの属性は、特定の関数がMIPS上でどのように呼び出されるかを指定します。この属性は</target>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="translated">これらの属性は、特定の関数がどのように呼ばれるかを指定します。これらの属性は</target>
        </trans-unit>
        <trans-unit id="3aa2c83f10183032d2c290e0fbfc5503038ef4f2" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for calling kernel helpers, and they are available depending on the kernel version selected as the CPU.</source>
          <target state="translated">これらの組み込み関数はカーネルヘルパーを呼び出すために利用でき、CPUとして選択されているカーネルのバージョンに応じて利用できます。</target>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="translated">これらの組み込み機能は、AArch64 ファミリのプロセッサで利用できます。</target>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="translated">これらの組み込み機能は、ARM ファミリのプロセッサが</target>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="translated">これらの内蔵機能は、浮動小数点ユニットを搭載したARMファミリのプロセッサで利用可能です。</target>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="translated">これらの内蔵機能は、使用するコマンドラインスイッチに応じて、Alpha ファミリのプロセッサで利用可能です。</target>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="translated">これらの内蔵機能は、Altera Nios II ファミリのプロセッサで利用できます。</target>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="translated">これらの内蔵機能はNDS32ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="translated">これらの組み込み機能は、使用するコマンドラインスイッチに応じて、x86-32およびx86-64ファミリーのコンピュータで利用できます。</target>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="translated">これらの組み込み関数は、 &lt;code&gt;__builtin_sub_overflow&lt;/code&gt; &lt;code&gt;__builtin_add_overflow&lt;/code&gt; 、__builtin_sub_overflow、または &lt;code&gt;__builtin_mul_overflow&lt;/code&gt; に似ていますが、算術演算の結果がどこにも格納されず、最後の引数がポインターではなく、列挙型またはブール型以外の整数型の式がある点が異なります。</target>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="translated">これらの組み込み関数は、加算の代わりに乗算を実行することを除いては、上記の加算オーバーフローチェックの組み込み関数と似ています。</target>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="translated">これらの組み込み関数は、加算の代わりに第1引数から第2引数を引く減算を行う点を除いては、上記の加算オーバーフローチェックの組み込み関数と似ています。</target>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="translated">これらの組み込み関数は、それぞれの機械命令、つまり &lt;code&gt;nop&lt;/code&gt; 、 &lt;code&gt;sei&lt;/code&gt; 、 &lt;code&gt;cli&lt;/code&gt; 、 &lt;code&gt;sleep&lt;/code&gt; 、 &lt;code&gt;wdr&lt;/code&gt; 、 &lt;code&gt;swap&lt;/code&gt; 、 &lt;code&gt;fmul&lt;/code&gt; 、 &lt;code&gt;fmuls&lt;/code&gt; resp にマップされます。 &lt;code&gt;fmulsu&lt;/code&gt; 。ハードウェア乗算器が利用できない場合、3つの &lt;code&gt;fmul*&lt;/code&gt; ビルトインはライブラリコールとして実装されます。</target>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの組み込み関数は、アトミックな比較とスワップを実行します。つまり、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の現在の値が &lt;var&gt;oldval&lt;/var&gt; である場合、 &lt;var&gt;newval&lt;/var&gt; を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">これらの組み込み関数は、名前で提案された操作を実行し、新しい値を返します。つまり、整数オペランドの演算には次のセマンティクスがあります。ポインターオペランドの演算は、オペランドの型が &lt;code&gt;uintptr_t&lt;/code&gt; であるかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前で提案された操作を実行し、操作の結果を返します。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインタが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前によって提案された操作を実行し、以前に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; にあった値を返します。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインタが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前によって提案された操作を実行し、以前にメモリにあった値を返します。つまり、整数オペランドの演算には次のセマンティクスがあります。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインタが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="translated">これらの組み込み関数は、最初の2つのオペランドを無限精度の符号付き型にプロモートし、プロモートされたオペランドに対して加算を実行します。結果は、3番目のポインター引数が指す型にキャストされ、そこに格納されます。格納された結果が無限精度の結果と等しい場合、組み込み関数は &lt;code&gt;false&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;true&lt;/code&gt; を返します。加算は無限の符号付き精度で実行されるため、これらの組み込み関数はすべての引数値に対して完全に定義された動作を持っています。</target>
        </trans-unit>
        <trans-unit id="889254cac4522dec29d7418673ff86e35bc69fa4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for PRU target:</source>
          <target state="translated">これらのコマンドラインオプションはPRUターゲットに対して定義されています。</target>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="translated">これらのコマンドラインオプションはRISC-Vターゲット用に定義されています。</target>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="translated">これらのコマンドラインオプションは、RX ターゲットに対して定義されています。</target>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="translated">これらの考慮事項は、C++で動作するように設計されたヘッダファイルでこの形式の文式を使うのは、おそらく悪い考えだということを意味しています(GNU Cライブラリのいくつかのバージョンには、まさにこのバグにつながる文式を使ったヘッダファイルが含まれていたことに注意してください)。(GNU Cライブラリのいくつかのバージョンには、まさにこのバグにつながる文式を使ったヘッダファイルが含まれていたことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="translated">これらの制約は、複数の代替案として表現されます。代替は、各オペランドに対する一連の文字で記述することができる。オペランドに対する全体的な制約は、最初の代替案からのこのオペランドに対する文字、カンマ、2番目の代替案からのこのオペランドに対する文字、カンマ、そして最後の代替案までの間の文字から作られます。1つの命令に対するすべてのオペランドは、同じ数の選択肢を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="translated">これらのダンプは定義されていますが、常に空のファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="translated">これらの環境変数は、GCCがローカリゼーション情報を使用する方法を制御します。これにより、GCCはさまざまな国内の規則で動作できます。GCCは、ロケールカテゴリ &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_MESSAGES&lt;/code&gt; を検査するように構成されているかどうかを検査します。これらのロケールカテゴリは、インストールでサポートされている任意の値に設定できます。典型的な値は '</target>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="translated">これらの拡張&lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;機能は&lt;/a&gt;、組み込み関数としても使用できます。これらのスイッチによって有効または無効になる関数の詳細については、「x86組み込み関数」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="translated">これらの拡張機能は、CおよびObjective-Cで使用できます。それらのほとんどはC ++でも使用できます。&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++に&lt;/a&gt;&lt;em&gt;のみ&lt;/em&gt;適用される拡張機能については、C ++言語の拡張機能を参照してください。</target>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="translated">これらの関数属性は、H8/300ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="translated">これらの関数属性は、AMD GCNバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="translated">これらの関数属性はARCバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="translated">これらの機能属性はAVRバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="translated">これらの関数属性は Blackfin バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="translated">これらの関数属性は、C-SKYバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="translated">これらの関数属性はCR16バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="translated">これらの関数属性は Epiphany バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="translated">これらの関数属性はM32Cバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="translated">これらの関数属性は、M32R/Dバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="translated">これらの関数属性は MCORE バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="translated">これらの関数属性はMIPSバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="translated">これらの機能属性は、MSP430バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="translated">これらの関数属性は、MePバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="translated">これらの関数属性はNDS32バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="translated">これらの関数属性は、Nios II バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">これらの機能属性は、Nvidia PTXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="translated">これらの関数属性は、PowerPCバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="translated">これらの関数属性はRISC-Vバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="translated">これらの関数属性はRL78バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="translated">これらの関数属性は、RXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="translated">これらの関数属性はSPUバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="translated">これらの関数属性はVisiumバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="translated">これらの関数属性は、Xstormy16 のバックエンドでサポートされている。</target>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="translated">これらの関数属性は、m68kバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="translated">これらの関数属性は、x86バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="translated">これらの関数属性はARMターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="translated">これらの関数属性はIA-64ターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="translated">これらの関数属性はMicroBlazeターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="translated">これらの機能属性は、S/390でサポートされています。</target>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="translated">これらの関数属性は、SH ファミリのプロセッサでサポートされています。</target>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="translated">これらの機能は、「</target>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="translated">これらの関数は、レガシーを置き換えることを目的としています '</target>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用して &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; とbを比較します。cond .psを実行し、結果の上半分または下半分を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用して &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; とbを比較します。cond .psまたは &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 。 &lt;code&gt;any&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; いずれかの結果がある場合に &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;all&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; 両方の結果である場合は &lt;code&gt;true&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用してaとbを比較し &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; を実行し、結果の上半分または下半分を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用してaとbを比較し &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; または &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; を実行し、結果をブール値として返します。例えば：</target>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="translated">これらの関数は、関数の呼び出し元に関する情報を取得するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">これらの関数は &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 使用します。cond .psまたは &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 比較すると &lt;var&gt;b&lt;/var&gt; と比較するために &lt;var&gt;c&lt;/var&gt; して &lt;var&gt;d&lt;/var&gt; 。 &lt;code&gt;any&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; 4つの結果のいずれかがある場合に &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;all&lt;/code&gt; フォームが返され &lt;code&gt;true&lt;/code&gt; 4件のすべての結果がある場合に &lt;code&gt;true&lt;/code&gt; 。例えば： &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="translated">x86用のこれらのハードウェア・トランザクション・メモリ・イントリニクスは、RTM (Restricted Transactional Memory)を使用してメモリ・トランザクションを使用できるようにします。このサポートは</target>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="translated">これらの識別子は変数であり、プリプロセッサマクロではなく、 &lt;code&gt;char&lt;/code&gt; 配列の初期化や文字列リテラルとの連結には使用できません。</target>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="translated">これらの問題は</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">これらのマシンに依存しないオプションは、コード生成に使用されるインターフェイスの規約を制御します。</target>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="translated">これらのマングリングの問題は、以下で修正されました。</target>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="translated">これらのメモリモデルは、SPARC-V9アーキテクチャマニュアルの付録Dで正式に定義されており、プロセッサの &lt;code&gt;PSTATE.MM&lt;/code&gt; フィールドに設定されています。</target>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="translated">これらの修飾子は、このアセンブラコードを生成します。</target>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="translated">これらのオプション（ '</target>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="translated">これらのオプションは、AArch64 の実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="translated">これらのオプションはAVR実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="translated">これらのオプションはNDS32の実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="translated">これらのオプションはNvidia PTX用に定義されています。</target>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="translated">これらのオプションはOpenRISC用に定義されています。</target>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="translated">これらのオプションは、Score の実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="translated">これらのオプションは、Xstormy16 で定義されています。</target>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="translated">これらのオプションは、Darwin オペレーティングシステムを実行するすべてのアーキテクチャで定義されています。</target>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="translated">これらのオプションはMMIX用に定義されています。</target>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="translated">これらのオプションはMSP430で定義されています。</target>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="translated">これらのオプションはPDP-11で定義されています。</target>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="translated">これらのオプションは、AMD GCNポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="translated">これらのオプションは、CR16 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="translated">これらのオプションは、CRIS ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="translated">これらのオプションは FR30 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="translated">これらのオプションは、FT32 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="translated">これらのオプションはリンカに渡されます。これらはDiabとの互換性のために定義されています。</target>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="translated">これらのオプションは、Darwin リンカに渡されます。Darwin リンカのマニュアルページで詳細に説明されています。</target>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="translated">これらのオプションは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="translated">これらのオプションはXtensaターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">これらのオプションは、コンパイラがオブジェクト・ファイルを実行可能な出力ファイルにリンクするときに使用されます。コンパイラがリンク・ステップを実行していない場合、これらのオプションは意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="translated">これらのオプションは、実際にコンパイルする前に各Cソースファイルで実行されるCプリプロセッサを制御します。</target>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="translated">これらのオプションは、特殊なNot-a-number (NaN)IEEE 754浮動小数点データのエンコーディングを制御します。</target>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="translated">これらのオプションは、リテラルプールの処理を制御します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="translated">これらのオプションは、 &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 使用した特殊な非数（NaN）IEEE 754浮動小数点データの処理を制御します。&lt;i&gt;fmt&lt;/i&gt;と &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; マシン命令。</target>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="translated">これらのオプションは、さまざまな種類の最適化を制御します。</target>
        </trans-unit>
        <trans-unit id="ca73d9226e349bbe9ceb8794e7b1f792d3ed7055" translate="yes" xml:space="preserve">
          <source>These options control warnings about left shift overflows.</source>
          <target state="translated">これらのオプションは、左シフトオーバーフローに関する警告を制御します。</target>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="translated">これらのオプションは、宣言で &lt;code&gt;signed&lt;/code&gt; または &lt;code&gt;unsigned&lt;/code&gt; のどちらも使用されていない場合に、ビットフィールドが符号付きか符号なしかを制御します。これは一貫性があるため、デフォルトでは、このようなビット・フィールドは、署名されている次のような基本的な整数型 &lt;code&gt;int&lt;/code&gt; は型が署名されています。</target>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="translated">これらのオプションは、どの形式のブランチを生成するかを制御します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="translated">これらのオプションを使用すると、GCC は生成されたコードでこれらの拡張命令を使用することができます。</target>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="translated">これらのオプションは、5ラウンドの命令分割後にダンピングを可能にします。</target>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="translated">これらのオプションは、GCCが位置に依存しないコードを生成している場合を除いては効果がありません。</target>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="translated">これらのオプションは、GCCが位置に依存しないコードを生成している場合を除いては効果がありません。</target>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="translated">これらのオプションは、ヘッダファイル、ライブラリ、およびコンパイラの一部を検索するディレクトリを指定します。</target>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="translated">これらのオプションは、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、または &lt;code&gt;section&lt;/code&gt; 属性の &lt;code&gt;either&lt;/code&gt; 持たない関数とデータを配置する場所をコンパイラーに指示します。可能な値は &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、 &lt;code&gt;either&lt;/code&gt; 、または &lt;code&gt;any&lt;/code&gt; 。最初の3つは、対応する属性のように動作します。第4の可能な値- &lt;code&gt;any&lt;/code&gt; -デフォルトです。配置は完全にリンカースクリプトと、標準セクション（ &lt;code&gt;.text&lt;/code&gt; 、 &lt;code&gt;.data&lt;/code&gt; など）をメモリ領域に割り当てる方法に任されています。</target>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="translated">これらのプラグマは、現在のターゲットと最適化オプションのスタックを維持します。これは、一時的に別の 'の使用に切り替えたいインクルードファイルを対象としています</target>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="translated">これらの問題はおそらく残念なことですが、実際の回避策はわかりません。</target>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="translated">&lt;code&gt;__STDC__&lt;/code&gt; が定義されている場合、これらのプログラムはGNU C ++で正しく動作します。それ以外の場合は機能しません。</target>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="translated">これらの疑似型はGCCで定義されているものではなく、このマニュアルで使用されている表記上の便宜を図ったものです。</target>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="translated">これらの制限が存在するのは,スカラのアドレスやスカラ成分を持つ配列のアドレスを取ると,格納順序属性が失われるため,このアドレスを介して間接的に格納することは一般的には機能しないからです.第二のケースは、それにもかかわらず、配列から、または配列へのブロックコピーを実行することができるように許可されています。</target>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="translated">これらのスイッチは、上記に加えてSolaris 2でもサポートされています。</target>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。64ビットのサイズを作る &lt;code&gt;long double&lt;/code&gt; のタイプは、同等の &lt;code&gt;double&lt;/code&gt; タイプ。これは、32ビットのBionic Cライブラリのデフォルトです。128ビットのサイズは、 &lt;code&gt;long double&lt;/code&gt; 型を &lt;code&gt;__float128&lt;/code&gt; 型と同等にします。これは、64ビットのBionic Cライブラリのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。64ビットのサイズを作る &lt;code&gt;long double&lt;/code&gt; のタイプは、同等の &lt;code&gt;double&lt;/code&gt; タイプ。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。x86-32アプリケーションバイナリインターフェイスは、サイズを96ビットに指定しているため、</target>
        </trans-unit>
        <trans-unit id="10e0a73d40a50d884864ada5af6042c707554338" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16, ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">これらのスイッチは、MMX、SSE、SSE2、SSE3、SSE3、SSE4、SSE4A、SSE4.2、AVX、AVX2、AVX512F、AVX512PF、AVX512ER、AVX512CD、AVX512VL、AVX512BW、AVX512DQ、AVX512IFMA、AVX512VBMI、SHA、AES、PCLMUL、CLFLUSHOPTの命令を使用することができます。CLWB、FSGSBASE、PTWRITE、RDRND、F16C、FMA、PCONFIG、WBNOINVD、FMA4、PREFETCHW、RDPID、PREFETCHWT1、RDSEED、SGX、XOP、LWP、3DNow!,を強化した3DNow! POPCNT、ABM、ADX、BMI、BMI2、LZCNT、FXSR、XSAVE、XSAVEOPT、XSAVEC、XSAVES、RTM、HLE、TBM、MWAITX、CLZERO、PKU、AVX512VBMI2、GFNI、VAES、WAITPKG、VPCLMULQDQ。AVX512BITALG、MOVDIRI、MOVDIR64B、AVX512BF16、ENQCMD、AVX512VPOPCNTDQ、AVX5124FMAPS、AVX512VNNI、AVX5124VNNIW、またはCLDEMOTE拡張命令セット。それぞれに対応する</target>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">これらのスイッチは、MMX、SSE、SSE2、SSE3、SSE3、SSE4、SSE4A、SSE4.2、AVX、AVX2、AVX512F、AVX512PF、AVX512ER、AVX512CD、AVX512VL、AVX512BW、AVX512DQ、AVX512IFMA、AVX512VBMI、SHA、AES、PCLMUL、CLFLUSHOPTの命令を使用することができます。CLWB、FSGSBASE、PTWRITE、RDRND、F16C、FMA、PCONFIG、WBNOINVD、FMA4、PREFETCHW、RDPID、PREFETCHWT1、RDSEED、SGX、XOP、LWP、3DNow!,を強化した3DNow! POPCNT、ABM、ADX、BMI、BMI2、LZCNT、FXSR、XSAVE、XSAVEOPT、XSAVEC、XSAVES、RTM、HLE、TBM、MWAITX、CLZERO、PKU、AVX512VBMI2、GFNI、VAES、WAITPKG。VPCLMULQDQ、AVX512BITALG、MOVDIRI、MOVDIR64B、AVX512VPOPCNTDQ、AVX5124FMAPS、AVX512VNNI、AVX5124VNNIW、またはCLDEMOTE拡張命令セット。それぞれに対応する</target>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="translated">これらの型は、128 ビットの変数を定義するために使用できます。次のセクションにリストアップされている組み込み関数は、これらの変数でベクトル演算を生成するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="translated">これらの用法は、曖昧さがない場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="translated">これらの変数属性は、H8/300ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">これらの変数属性は、Nvidia PTXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="translated">これらの変数属性は V850 バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="e1ed20f7dd8c240bdd89fa6c4be557443a983d56" translate="yes" xml:space="preserve">
          <source>These warnings are enabled by default.</source>
          <target state="translated">これらの警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="translated">これらの警告は無害であり、安全に無視することができます。</target>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="translated">これらの警告はオプションになっていますが、これは、GCC がエラーがあるように見えても、コードが正しいかどうかを判断できない可能性があるためです。これがどのようにして起こるかの一例を示します。</target>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="translated">これらの警告はコンパイルを最適化する際にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="e68200a8afffeb4dc68ba2a9ef927363c09a49e9" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized elements of structure, union or array variables as well as for variables that are uninitialized as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depend on the precise optimization options and version of GCC used.</source>
          <target state="translated">これらの警告は、構造体、ユニオン、または配列変数の初期化されていない個々の要素、および全体として初期化されていない変数に対して発生します。 &lt;code&gt;volatile&lt;/code&gt; と宣言された変数または要素では発生しません。これらの警告は最適化に依存するため、警告が表示される正確な変数または要素は、使用されるGCCの正確な最適化オプションとバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="translated">これらの警告は、構造化変数、共用体変数、配列変数の初期化されていない、または破損している個々の要素、および全体として初期化されていない、または破損している変数に対して発生します。 &lt;code&gt;volatile&lt;/code&gt; と宣言された変数または要素では発生しません。これらの警告は最適化に依存するため、警告が出される正確な変数または要素は、使用されるGCCの正確な最適化オプションとバージョンに依存します。</target>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="translated">自分たちが正しいと思っていることでも、他の人が反対していることもある。</target>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="translated">G++からモノが消える。</target>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="translated">この &lt;code&gt;asm&lt;/code&gt; は、内部的にポップされる1つの入力を取り、2つの出力を生成します。</target>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="translated">この &lt;code&gt;asm&lt;/code&gt; は、 &lt;code&gt;fyl2xp1&lt;/code&gt; オペコードによってポップされる2つの入力を受け取り、それらを1つの出力に置き換えます。 &lt;code&gt;st(1)&lt;/code&gt; コンパイラがいることを知っているためクロバーが必要です &lt;code&gt;fyl2xp1&lt;/code&gt; は、両方の入力をポップ。</target>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="translated">グローバル変数または関数にアタッチされたこのIA-64 HP-UX属性は、バージョン文字列を含むシンボルの名前を変更し、関数レベルのバージョニングを可能にします。HP-UX システム・ヘッダ・ファイルでは、一部のシステム・コールで関数レベルのバージョニングを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="translated">このISAは、最小限のAVRコアによって実装され、アセンブラーでのみサポートされます。 &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt; 、 &lt;code&gt;attiny12&lt;/code&gt; 、 &lt;code&gt;attiny15&lt;/code&gt; 、 &lt;code&gt;attiny28&lt;/code&gt; 、 &lt;code&gt;at90s1200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="translated">このRX属性は、パラメーターを含め、 &lt;code&gt;interrupt&lt;/code&gt; 属性に似ていますが、関数を割り込みハンドラータイプの関数にしません（つまり、ABIを呼び出す通常のC関数を保持します）。引数の説明については、 &lt;code&gt;interrupt&lt;/code&gt; 属性を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="translated">これにより、クラスは最初に呼び出されたときに（ &lt;code&gt;class_addMethod&lt;/code&gt; を使用してクラスにメソッドを追加することにより）メソッドを動的に登録できます。そのためには、クラスは &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (または場合によっては &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ：）を実装し、実行時に動的に登録できるメソッドのセレクターを認識し、それらを登録して、 &lt;code&gt;YES&lt;/code&gt; を返す必要があります。実行時に動的に登録されないメソッドに対しては、 &lt;code&gt;NO&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="translated">これは、次のような場合にも動作します。</target>
        </trans-unit>
        <trans-unit id="ebf24102acffe4ee7e0e4cb4b714de13fd9ab15c" translate="yes" xml:space="preserve">
          <source>This analysis is much more expensive than other GCC warnings.</source>
          <target state="translated">この分析は、他のGCCの警告よりもはるかに高価です。</target>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="translated">これは、 &lt;code&gt;x&lt;/code&gt; が関数へのポインターの配列であることを前提としています。説明されているタイプは、関数の値のタイプです。</target>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="translated">この属性は、フラグが</target>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="translated">この属性は、関連付けられている宣言のリンケージに影響します。関数だけでなく、変数（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）や型（「&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;共通型属性&lt;/a&gt;」を参照）にも適用できます。</target>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">この属性は、関連付けられている宣言のリンケージに影響します。 &lt;code&gt;visibility&lt;/code&gt; 属性はで説明された&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通機能の属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="translated">この属性により、通常モードから呼び出し可能なセキュアコード関数をマークできます。セキュアな呼び出し関数の &lt;code&gt;sjli&lt;/code&gt; テーブルへの場所は、引数として渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="translated">この属性を使用すると、コンパイラーは必要な関数宣言を作成でき、関数の本体をアセンブリコードにすることができます。指定された関数には、コンパイラーによって生成されたプロローグ/エピローグシーケンスがありません。ネイキッド関数に安全に含めることができるのは、基本的な &lt;code&gt;asm&lt;/code&gt; ステートメントのみです（&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;基本的なAsmを&lt;/a&gt;参照）。拡張 &lt;code&gt;asm&lt;/code&gt; または基本的な &lt;code&gt;asm&lt;/code&gt; とCコードの混合を使用すると動作するように見えるかもしれませんが、確実に動作するように依存することはできず、サポートされていません。</target>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="translated">この属性は特定の名前空間本体にのみ適用され、同じ名前空間の他の定義には適用されません。これは「</target>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="translated">この属性を使用すると、コンパイラは呼び出された関数が通常の呼び出し規則を使用するのに十分に近いと仮定して</target>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="translated">この属性は、コンパイラが与えられた関数の間、割り込みを無効にする命令を出すようにします。</target>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="translated">この属性は</target>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">この属性により、1回の呼び出しでSIMD命令を使用して複数の引数を処理できる1つ以上の関数バージョンを作成できます。この属性を指定すると、コンパイラーはそのようなバージョンがリンク時に使用可能であると想定できます（同じまたは別の翻訳単位で提供されます）。生成されたバージョンはターゲットに依存し、対応するベクターABIドキュメントに記載されています。x86_64ターゲットの場合、このドキュメントは&lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;ここにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="translated">この属性は、対応する関数がカーネル関数としてコンパイルされるべきであること、つまり、HSAランタイムライブラリを介してホストから呼び出すことができるエントリーポイントであることを示します。デフォルトでは、関数は他のGCN関数からのみ呼び出し可能です。</target>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="translated">この属性は、対応する関数がカーネル関数としてコンパイルされ、CUDA RT ライブラリを介してホストから呼び出すことができることを示します。デフォルトでは、関数は他のPTX関数からのみ呼び出し可能です。</target>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="translated">この属性はC言語でも受け入れられていますが、C言語にはコンストラクタやデストラクタがないので不要です。</target>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="translated">この属性は、 &lt;code&gt;std::string&lt;/code&gt; など、値を表すだけのタイプに適しています。 &lt;code&gt;std::lock_guard&lt;/code&gt; など、リソースを制御するタイプには適していません。</target>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="translated">この属性はR8Cターゲットでは無視されます。</target>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="translated">この属性は、デフォルトのパラメーターを使用して、 &lt;code&gt;main&lt;/code&gt; という名前の関数に暗黙的に適用されます。</target>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="translated">この属性は、積分型と浮動スカラ型にのみ適用されます。関数宣言では、この属性は関数の戻り値の型に適用されます。</target>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="translated">この属性は積分スカラと浮動スカラにのみ適用されますが、配列、ポインタ、および関数の戻り値はこの構造体と組み合わせて使用することができます。</target>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="translated">この属性は、統一されたデフォルトのスカラの格納順序を使用するターゲット(幸いにも、ほとんどのターゲット)、すなわち、スカラをすべてビッグエンディアンまたはリトルエンディアンのいずれかで格納するターゲットに対してのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="translated">この属性は、すべての関数の終了時にすべての入力レジスタをライブとしてマークすることで、IA-64の呼び出し規約を変更するために使用されます。これにより、入力レジスタを保存/復元することなく、割り込み後にシステムコールを再起動することが可能になります。これはまた、カーネルデータがアプリケーションコードに漏れることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="translated">この属性は、可能であればデバッグ中にユニットとして表示されるべき小さなインラインラッパーに便利です。デバッグ情報のフォーマットに応じて、関数を人工的なものとしてマークするか、インラインボディ内のすべての命令に呼び出し元の場所を使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="translated">この属性はローカルで</target>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="translated">この属性は構造タイプにのみ適用できます。このタイプのオブジェクトの初期化では、位置初期化子ではなく、指定された初期化子を使用する必要があることを示しています。この属性の目的は、構造体のレイアウトが変更される可能性があることをプログラマーが示すことができるようにすることであり、したがって、位置の初期化に依存すると将来的に破損することになります。</target>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="translated">この属性は割り込みハンドラの動作を変更します。割り込みハンドラは分岐命令では到達できない外部メモリにある可能性があるので、制御を転送するためにローカルメモリのトランポリンを生成します。シングルパラメータはトランポリンを配置するセクションを特定します。</target>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="translated">この属性は割り込み関数にのみ適用されます。非割込み関数に適用された場合は静かに無視されます。ウェイクアップ割り込み関数は、その関数が終了したときにプロセッサを低消費電力状態から解放します。</target>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="translated">この属性はアセンブラとオブジェクトファイルのサポートが必要で、すべてのターゲットで利用できるわけではありません。</target>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="translated">この属性は、 &lt;code&gt;inline&lt;/code&gt; キーワードで宣言されている関数でも使用する必要があります。これは、C99またはgnu99モードでコンパイルする場合でも、関数をgnu90モードで定義されたものとして扱うようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="translated">この属性は、L1命令SRAMに配置される関数を指定します。関数は &lt;code&gt;.l1.text&lt;/code&gt; という名前の特定のセクションに配置されます。と</target>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="translated">この属性は、L2 SRAMに配置される機能を指定します。関数は &lt;code&gt;.l2.text&lt;/code&gt; という名前の特定のセクションに配置されます。と</target>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="translated">この属性は、バイト単位で測定される構造体フィールドのしきい値を指定します。構造体フィールドが閾値以下に整列している場合、警告が発行されます。例えば、宣言</target>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="translated">この属性は、宣言のデータ型（モード &lt;var&gt;mode&lt;/var&gt; に対応する型）を指定します。これにより、実際には、幅に応じて整数型または浮動小数点型を要求できます。</target>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="translated">この属性は、宣言された変数のタイプのベクトルサイズをバイト単位で指定します。適用される&lt;em&gt;タイプ&lt;/em&gt;は、&lt;em&gt;基本タイプ&lt;/em&gt;と呼ばれます。 &lt;var&gt;bytes&lt;/var&gt; 引数は、ベース型サイズの正の2のべき乗の倍数でなければなりません。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="translated">この属性は、タイプのベクトルサイズをバイト単位で指定します。適用される&lt;em&gt;タイプ&lt;/em&gt;は、&lt;em&gt;基本タイプ&lt;/em&gt;と呼ばれます。 &lt;var&gt;bytes&lt;/var&gt; 引数は、ベース型サイズの正の2のべき乗の倍数でなければなりません。たとえば、次の宣言：</target>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="translated">この属性は、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、またはC ++ &lt;code&gt;class&lt;/code&gt; 型定義に添付され、そのメンバー（ゼロ幅のビットフィールド以外）のそれぞれが必要なメモリを最小限に抑えるために配置されることを指定します。これは、各メンバーに &lt;code&gt;packed&lt;/code&gt; 属性を指定することと同じです。</target>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="translated">この属性は、 &lt;code&gt;union&lt;/code&gt; 体型定義に付加され、その共用体型を持つ関数パラメーターがあると、その関数の呼び出しが特別な方法で処理されることを示します。</target>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="translated">関数に添付されたこの属性は、関数が参照されていないように見えても、その関数に対してコードを出さなければならないことを意味します。これは、例えば、関数がインライン・アセンブリでしか参照されない場合などに便利です。</target>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="translated">この属性は、関数に付けられたもので、その関数が使用されない可能性があることを意味します。GCCはこの関数に対して警告を発しません。</target>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="translated">グローバル変数や関数にアタッチされたこの属性は</target>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="translated">静的記憶装置を持つ変数に付けられたこの属性は、変数が参照されていないように見えても、その変数を放出しなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="translated">この属性は、変数に添付され、その変数が使用されない可能性があることを意味します。GCCはこの変数に対して警告を発しません。</target>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="translated">この振る舞いはばかげているように見えるかもしれませんが、それはISO標準が指定するものです。 &lt;code&gt;struct mumble&lt;/code&gt; の定義をプロトタイプの上に移動することで、コードを機能させるのは簡単です。上記の例のエラーを回避するためだけにISO Cと互換性がないことは価値がありません。</target>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="translated">この組み込みは、以下のコード例を使用して現在のトランザクションの状態を決定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="translated">この組み込み関数は、同じスレッドに基づくスレッドとシグナルハンドラ間の同期フェンスとして機能します。</target>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="translated">この組み込み関数は、指定されたメモリ順序に基づいてスレッド間の同期フェンスとして機能します。</target>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="translated">この組み込み関数を使用して、安全でない投機的実行を軽減することができます。 &lt;var&gt;type&lt;/var&gt; は、任意の整数型または任意のポインター型です。</target>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="translated">この組み込み関数は、選択された引数がlvalueの場合、lvalueを返すことができます。</target>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、最上位の修飾子（たとえば、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;volatile&lt;/code&gt; ）を無視します。たとえば、 &lt;code&gt;int&lt;/code&gt; は &lt;code&gt;const int&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="translated">この組み込み関数は、アトミックな比較および交換操作を実装します。これにより、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の内容と &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; の内容が比較されます。等しい場合は、操作は&lt;em&gt;リードモディファイライト&lt;/em&gt;書き込み動作の &lt;var&gt;desired&lt;/var&gt; に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; が。それらが等しくない場合、操作は&lt;em&gt;読み取りで&lt;/em&gt;あり、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の現在の内容が &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; に書き込まれます。 &lt;var&gt;weak&lt;/var&gt; は、 &lt;code&gt;false&lt;/code&gt; 失敗する可能性のある弱いcompare_exchangeの &lt;code&gt;true&lt;/code&gt; はtrue、falseの場合誤って失敗することのない強力なバリエーション。多くのターゲットは強い変動のみを提供し、パラメーターを無視します。疑わしい場合は、強力なバリエーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミック交換操作を実装します。これは、書き込み &lt;var&gt;val&lt;/var&gt; に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 、との以前の内容を返す &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミックロード操作を実装します。 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の内容を返します。</target>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミックストア操作を実装します。 &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;__atomic_compare_exchange&lt;/code&gt; の汎用バージョンを実装しています。この関数は、目的の値もポインタであることを除いて、実質的に &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="translated">これは、組み込み関数呼び出し &lt;var&gt;function&lt;/var&gt; によって記述されたパラメータのコピーを &lt;var&gt;arguments&lt;/var&gt; と &lt;var&gt;size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="translated">この組み込み関数は、「</target>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="translated">この組み込み関数は完全なバリアではなく、&lt;em&gt;リリースバリア&lt;/em&gt;です。これは、以前のすべてのメモリストアがグローバルに表示され、以前のすべてのメモリロードが満たされていることを意味しますが、後続のメモリ読み取りは、バリアの前に推測されることを妨げられません。</target>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="translated">この組み込み関数は完全なバリアではなく、&lt;em&gt;取得バリア&lt;/em&gt;です。これは、操作後の参照が操作の前に移動できない（または推測できない）ことを意味しますが、以前のメモリストアはまだグローバルに表示されておらず、以前のメモリロードがまだ満たされていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="translated">この内蔵機能は、フルメモリバリアを発行します。</target>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に対してアトミックなクリア操作を実行します。操作後、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; には0が含まれます。これは、 &lt;code&gt;bool&lt;/code&gt; 型または &lt;code&gt;char&lt;/code&gt; 型のオペランドにのみ使用し、 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; と組み合わせて使用​​する必要があります。他のタイプでは、部分的にしかクリアされない場合があります。タイプが &lt;code&gt;bool&lt;/code&gt; でない場合は、 &lt;code&gt;__atomic_store&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; のバイトに対してアトミックなテストと設定の操作を実行します。バイトは、実装によって定義されたゼロ以外の「セット」値に設定され、戻り値は、前のコンテンツが「セット」された場合にのみ &lt;code&gt;true&lt;/code&gt; になります。タイプ &lt;code&gt;bool&lt;/code&gt; または &lt;code&gt;char&lt;/code&gt; のオペランドにのみ使用する必要があります。他のタイプでは、値の一部のみを設定できます。</target>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt; によって取得されたロックを解放します。通常、これは定数0を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込むことを意味します。</target>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="translated">この組み込み関数は、インライン関数のすべての無名引数を表します。 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; または &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; externインライン関数を使用する関数など、常にインライン化され、個別の関数としてコンパイルされることのないインライン関数でのみ使用できます。可変引数を持つ他の関数の最後の引数としてのみ渡す必要があります。これは、プリプロセッサマクロの使用が望ましくない場合に、可変引数関数の小さなラッパーインラインを記述するのに役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="translated">この組み込み関数は、 &lt;var&gt;type1&lt;/var&gt; と &lt;var&gt;type2&lt;/var&gt; （式ではなく型）の非修飾バージョンに互換性がある場合は1を返し、それ以外の場合は0を返します。この組み込み関数の結果は、整数定数式で使用できます。</target>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="translated">この組み込み関数は、 &lt;var&gt;size&lt;/var&gt; バイトのオブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合に &lt;code&gt;true&lt;/code&gt; を返します。 &lt;var&gt;size&lt;/var&gt; はコンパイル時定数に解決される必要があり、結果もコンパイル時定数に解決されます。</target>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、 &lt;var&gt;size&lt;/var&gt; バイトのオブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合に &lt;code&gt;true&lt;/code&gt; を返します。組み込み関数がロックフリーであることがわからない場合は、 &lt;code&gt;__atomic_is_lock_free&lt;/code&gt; という名前の実行時ルーチンが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="translated">この組み込み関数は、現在の関数に渡されている引数と同じ引数で呼び出しを実行する方法を記述したデータへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="translated">この組み込み関数は、インライン関数の無名引数の数を返します。 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; または &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; externインライン関数を使用する関数など、常にインライン化され、個別の関数としてコンパイルされることのないインライン関数でのみ使用できます。たとえば、次のコードは、最適化されたコードのオープン引数のリンク時または実行時のチェックを行います。</target>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、包含関数の &lt;var&gt;result&lt;/var&gt; によって記述された値を返します。 &lt;var&gt;result&lt;/var&gt; には、__ &lt;code&gt;__builtin_apply&lt;/code&gt; によって返される値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、Intelによって記述されているように、従来のテストと設定の操作ではなく、アトミックな交換操作です。これは、書き込み &lt;var&gt;value&lt;/var&gt; に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 、との以前の内容を返す &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">この組み込みは、C99 fpclassify機能を実装します。最初の5つのint引数は、可能なFPクラスのターゲットライブラリの概念であり、戻り値に使用されます。それらは定数値である必要があり、 &lt;code&gt;FP_NAN&lt;/code&gt; 、 &lt;code&gt;FP_INFINITE&lt;/code&gt; 、 &lt;code&gt;FP_NORMAL&lt;/code&gt; 、 &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; 、および &lt;code&gt;FP_ZERO&lt;/code&gt; の順序で出現する必要があります。省略記号は、1つの浮動小数点値を分類するためのものです。 GCCは最後の引数を型ジェネリックとして扱います。これは、floatからdoubleへのデフォルトの昇格を行わないことを意味します。</target>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">この組み込み &lt;code&gt;__memx&lt;/code&gt; は、バイトアドレスを24ビット&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;アドレス空間&lt;/a&gt;__memxに取り、アドレスが指すフラッシュセグメント（64 KiBチャンク）の番号を返します。カウントは &lt;code&gt;0&lt;/code&gt; から始まります。アドレスがフラッシュメモリを指していない場合は、 &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">この呼び出し規約はUnixで通常使われているものと互換性がないので、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合には使えません。</target>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="translated">これは通常動作するだけなので、Borlandモデル用に作成されたアプリケーションコードに適したオプションです。Cfrontモデル用に作成されたコードは、インスタンス化の1つ以上のポイントでテンプレート定義が使用できるように変更する必要があります。通常、これは各テンプレートヘッダーの末尾に &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="translated">これにより、GCCの出力ファイルに「</target>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="translated">というエラーメッセージが出てしまいます。</target>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">現在スタック上に保存されているステータス・レジスタの保存されたコピーの中の指定されたビットをクリアします。これは割り込みハンドラ内でのみ動作し、ステータスレジスタの変更はハンドラが戻ってきてから有効になります。</target>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">このコードは &lt;code&gt;src&lt;/code&gt; を &lt;code&gt;dst&lt;/code&gt; にコピーし、1を &lt;code&gt;dst&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="translated">このコードは、オプションの &lt;var&gt;asmSymbolicName&lt;/var&gt; を使用しません。したがって、最初の出力オペランドは &lt;code&gt;%0&lt;/code&gt; として参照されます（2番目があった場合、 &lt;code&gt;%1&lt;/code&gt; になります）最初の入力オペランドの数は、最後の出力オペランドの数よりも1つ大きくなっています。このi386の例では、 &lt;code&gt;Mask&lt;/code&gt; が &lt;code&gt;%1&lt;/code&gt; として参照されます。</target>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="translated">プロトタイプ内の &lt;code&gt;struct mumble&lt;/code&gt; のスコープはそれを含む引数リストに限定されているため、このコードは実際には誤りです。すぐ下のファイルスコープで定義された &lt;code&gt;struct mumble&lt;/code&gt; は参照されません。これらは、異なるスコープで類似した名前を持つ2つの無関係なタイプです。</target>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="translated">このコードは、すべての 64 ビットプロセッサ上で無条件に動作します。32ビットプロセッサでは、このコードはマルチバイトNOP命令をサポートしているプロセッサで実行されます。</target>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="translated">このコードは、入力 &lt;code&gt;b&lt;/code&gt; が &lt;code&gt;asm&lt;/code&gt; によってポップされず、 &lt;code&gt;asm&lt;/code&gt; が結果をreg-stackにプッシュすることを示しています。つまり、スタックは &lt;code&gt;asm&lt;/code&gt; の前より1つ深いです。ただし、リロードは、入力と出力の両方に同じレジスターを使用できると考える可能性があります。</target>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; のこの組み合わせは、ほとんどマクロの効果があります。これを使用する方法は、これらのキーワードを使用して関数定義をヘッダーファイルに置き、ライブラリファイルに定義の別のコピー（ &lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; が欠けている）を置くことです。ヘッダーファイル内の定義により、関数のほとんどの呼び出しがインライン化されます。関数の使用が残っている場合、それらはライブラリ内の単一のコピーを参照します。</target>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="translated">この構築出力 &lt;code&gt;dialect0&lt;/code&gt; コード、コンパイルする方言＃0を使用して &lt;code&gt;dialect1&lt;/code&gt; 方言のコンパイラサポートの数、構造出力何よりも、中括弧内の少数の選択肢がある場合など方言＃1、のために。</target>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="translated">これも文式を使って書くことができます。</target>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="translated">この宣言は、クラス &lt;code&gt;Foo&lt;/code&gt; に &lt;code&gt;Foo::bar&lt;/code&gt; という名前の &lt;code&gt;int&lt;/code&gt; と &lt;code&gt;Foo::method&lt;/code&gt; という名前のメンバー関数があることのみを確立します。ただし&lt;em&gt;、&lt;/em&gt; &lt;code&gt;method&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; &lt;em&gt;両方を&lt;/em&gt;別の場所で定義する必要があります。ISO標準によれば、次のような1つの（そして1つだけの）ソースファイルで初期化子を指定する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="translated">これは、 &lt;code&gt;y&lt;/code&gt; を文字へのポインタの配列として宣言します。</target>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="translated">これは &lt;code&gt;y&lt;/code&gt; をそのような値の配列として宣言します。</target>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="translated">これは、 &lt;code&gt;x&lt;/code&gt; が指すものの型で &lt;code&gt;y&lt;/code&gt; を宣言します。</target>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="translated">この推論は、当初提案されていた C++11 標準のセマンティクスを拡張する可能性があるとして実装されましたが、最終的な標準には含まれていなかったため、デフォルトでは無効になっています。このオプションは非推奨であり、G++の将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="translated">これはデフォルトで '</target>
        </trans-unit>
        <trans-unit id="951c7938f85853a27d5c7d2c75acbe672c4155a1" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;free&lt;/code&gt; is called on a non-heap pointer (e.g. an on-stack buffer, or a global).</source>
          <target state="translated">この診断は、ヒープ以外のポインター（スタック上のバ​​ッファー、グローバルなど）で &lt;code&gt;free&lt;/code&gt; が呼び出されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="6a1c5da5f3c1afd18968f173e07657e7302351a3" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;longjmp&lt;/code&gt; is called to rewind to a &lt;code&gt;jmp_buf&lt;/code&gt; relating to a &lt;code&gt;setjmp&lt;/code&gt; call in a function that has returned.</source>
          <target state="translated">この診断は、 &lt;code&gt;longjmp&lt;/code&gt; が呼び出されて、 &lt;code&gt;jmp_buf&lt;/code&gt; れた関数の &lt;code&gt;setjmp&lt;/code&gt; 呼び出しに関連するjmp_bufに巻き戻されるパスを警告します。</target>
        </trans-unit>
        <trans-unit id="ac21f5dcf2d09b0cae014f784d56a15b158edf70" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;code&gt;FILE *&lt;/code&gt; stream object is leaked.</source>
          <target state="translated">この診断は、 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;code&gt;FILE *&lt;/code&gt; ストリームオブジェクトがリークされたコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="0839228138ef335cef6fd42894f9d1b11c2d55f0" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;FILE *&lt;/code&gt; can have &lt;code&gt;fclose&lt;/code&gt; called on it more than once.</source>
          <target state="translated">この診断は、 &lt;code&gt;FILE *&lt;/code&gt; が &lt;code&gt;fclose&lt;/code&gt; を複数回呼び出すことができるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="69065a1147c573eab2950f6087ec4e566a67c9a6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a function known to be async-signal-unsafe (such as &lt;code&gt;fprintf&lt;/code&gt;) is called from a signal handler.</source>
          <target state="translated">この診断は、async-signal-unsafeであることがわかっている関数（ &lt;code&gt;fprintf&lt;/code&gt; など）がシグナルハンドラーから呼び出されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="21154539e36b0472f9191b1b593654ca89275a98" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer allocated via &lt;code&gt;malloc&lt;/code&gt; is leaked.</source>
          <target state="translated">この診断は、 &lt;code&gt;malloc&lt;/code&gt; を介して割り当てられたポインターがリークされたコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="11378cc6703dc8c65838b338e0ff6edde259a680" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer can have &lt;code&gt;free&lt;/code&gt; called on it more than once.</source>
          <target state="translated">この診断は、ポインターが複数回 &lt;code&gt;free&lt;/code&gt; コールされる可能性のあるコード内のパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="8f9dc818bd4f109cde1dcf9e6dc005ab06fd45c6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is dereferenced that points to a variable in a stale stack frame.</source>
          <target state="translated">この診断では、スタック・フレーム内の変数を指しているポインタが参照されていないコードのパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="4ec5073148ee9d8b883f3325ddcb7fb0c4d813dc" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is used after &lt;code&gt;free&lt;/code&gt; is called on it.</source>
          <target state="translated">この診断は、 &lt;code&gt;free&lt;/code&gt; が呼び出された後にポインターが使用されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="fad14ca24b0d656f13db98b7bf5a30df3b6adb8e" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is dereferenced.</source>
          <target state="translated">この診断では、コード中のパスのうち、null の可能性のある値が参照されている場合に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="f2a9ffda1fede774b63029feba567cccbb607842" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">この診断は、NULL以外の値が必要であるとして &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; マークされた関数引数にNULLの可能性のある値が渡されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="e828b08ddbeb8b76319f7c2f75bb782a082fba40" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a security-sensitive value is written to an output file (such as writing a password to a log file).</source>
          <target state="translated">この診断では、セキュリティに敏感な値が出力ファイルに書き込まれているコードのパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="3e36f8c84c0a1d9f61a3991f2dd1bc00f7fd261b" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is dereferenced.</source>
          <target state="translated">この診断は、NULL であることがわかっている値が参照されているコードのパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="409bd5dd675e6fd0250a68f96b1c476f5f6aaaac" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">この診断は、NULLであることがわかっている値が、NULL以外の値を必要とするものとして &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; マークされた関数引数に渡されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="3abf773f1e1f311cc5692173d305b2448d2aae95" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value that could be under an attacker&amp;rsquo;s control is used as the index of an array access without being sanitized.</source>
          <target state="translated">この診断は、攻撃者の制御下にある可能性のある値がサニタイズされずに配列アクセスのインデックスとして使用されるコードを通るパスについて警告します。</target>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="translated">このように従属名と非従属名のルックアップを区別することを、2段階(または従属)名ルックアップと呼びます。G++ではバージョン3.4から実装されています。</target>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="translated">この文書は、GNU Objective-C の機能の一部を説明することを目的としています。Objective-Cを教えることを目的としたものではありません。インターネット上には、この言語を紹介するいくつかのリソースがあります。</target>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="translated">これにより</target>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="translated">これにより、マクロと組み合わせても、一部のユーザーが疑わしく、簡単に回避できる（または警告を回避するように変更できる）構文に関するすべての警告が有効になります。これにより、&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++方言オプション&lt;/a&gt;と&lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-CおよびObjective-C ++方言オプションで&lt;/a&gt;説明されている言語固有の警告も有効になります。</target>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="translated">これにより</target>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="translated">これにより、ロックされたロード/ストア条件拡張を使用してアトミック・メモリ・ビルトイン関数を実装することができます。ARC 6xx または ARC EM コアでは使用できません。</target>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="translated">この例では、デフォルトテーブルの2つのスロットに関数を割り当て（他の場所で定義されたプリプロセッサマクロを使用）、それを &lt;code&gt;dct&lt;/code&gt; テーブルのデフォルトにします。</target>
        </trans-unit>
        <trans-unit id="1f3b599da5422ada6f5dd38b7f237af6695d9dff" translate="yes" xml:space="preserve">
          <source>This example creates an alias of &lt;code&gt;foo_v1&lt;/code&gt; with symbol name &lt;code&gt;symver_foo_v1&lt;/code&gt; which will be version &lt;code&gt;VERS_2&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">この例では、シンボル名 &lt;code&gt;symver_foo_v1&lt;/code&gt; の &lt;code&gt;foo_v1&lt;/code&gt; のエイリアスを作成します。これは、 &lt;code&gt;foo&lt;/code&gt; のバージョン &lt;code&gt;VERS_2&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="translated">この例は</target>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="translated">この例では、「</target>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="translated">この例では、デフォルトテーブル内の1つのベクタに関数を簡単に代入しています(チップ固有のシンボリックベクタ名にはプリプロセッサマクロが使用される場合があることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="translated">この例では、 &lt;code&gt;cold&lt;/code&gt; ラベル属性を使用して、 &lt;code&gt;ErrorHandling&lt;/code&gt; ブランチが実行される可能性が低く、 &lt;code&gt;ErrorHandling&lt;/code&gt; ラベルが使用されていないことを示しています。</target>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="translated">この例では、 &lt;code&gt;deprecated&lt;/code&gt; 列挙子属性を使用して、 &lt;code&gt;oldval&lt;/code&gt; 列挙子が非推奨であることを示しています。</target>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="translated">この例では、 &lt;code&gt;fallthrough&lt;/code&gt; ステートメント属性を使用して、</target>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="translated">この例。</target>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="translated">この拡張機能はGNU C++ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="translated">この拡張子は、次のような十分なものです。</target>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="translated">この拡張機能はあまり役に立ちませんが、 &lt;code&gt;enum&lt;/code&gt; の処理を、 &lt;code&gt;struct&lt;/code&gt; と &lt;code&gt;union&lt;/code&gt; 体の処理方法とより一貫したものにします。</target>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="translated">この余分なアラインメントは余分なスタックスペースを消費し、一般的にコードサイズを大きくします。組込みシステムやオペレーティングシステムのカーネルなど、スタックスペースの使用量に敏感なコードは、優先的なアラインメントを</target>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="translated">この機能は、最初にクラスにメッセージを送信せずに、プログラムから直接アクセスできるグローバル変数を初期化する場合に非常に役立ちます。グローバル変数を初期化する通常の方法は、中に &lt;code&gt;+initialize&lt;/code&gt; ための方法、便利ではないかもしれません &lt;code&gt;+initialize&lt;/code&gt; 最初のメッセージがいくつかのケースでは遅すぎるかもしれないクラスオブジェクトに送信されたときにのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="translated">この機能は、ASCII文字コードの範囲に対して特に有用です。</target>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="translated">この機能は、マクロ定義を「安全」にするために特に役立ちます（各オペランドを1回だけ評価するため）。たとえば、「最大」関数は通常、標準Cでは次のようにマクロとして定義されています。</target>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="translated">この機能は、未使用のラベルを含む可能性のあるプログラム生成コードを対象としています。</target>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="translated">この機能はデフォルトでは有効になっていません。指定する</target>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="translated">この機能はmakefileの自動更新に使用されます。</target>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="translated">このファイルはGNUコンパイラの使用を文書化したものです。</target>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="translated">このフラグは、表示設定を使用して、GCCのC ++リンケージモデルをMicrosoft Visual Studioのモデルと互換性があるようにします。</target>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="translated">このフラグは、三者択一を指定しているので、負の形をしていません。</target>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="translated">このフラグはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="translated">このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="translated">このフラグは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="translated">このフラグは</target>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="translated">この関数属性は、関数の呼び出しの引数が明示的な &lt;code&gt;NULL&lt;/code&gt; であることが期待されることを示します。この属性は、可変個関数でのみ有効です。デフォルトでは、番兵は関数呼び出しの最後の引数であると想定されています。オプションの &lt;var&gt;position&lt;/var&gt; 引数が属性に指定されている場合、センチネルは引数リストの最後から逆方向に数えた位置に &lt;var&gt;position&lt;/var&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="translated">この関数属性は、関数が複製のために考慮されないようにします。これは、関数の特殊なコピーを作成し、（現在）プロシージャ間の定数伝播によって実行されるメカニズムです。</target>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="translated">この関数属性は、関数がインライン化の対象とされないようにします。関数に副作用がない場合、インライン化以外にも、関数呼び出しが生きているにもかかわらず、関数呼び出しが離れて最適化される原因となる最適化があります。このような呼び出しが最適化されないようにするには</target>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="translated">この関数属性は、関数が他の意味的に等価な関数とマージされることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="translated">この関数は、プログラムを異常終了させます。GCCは、ターゲット依存のメカニズム（意図的に不正な命令を実行するなど）を使用するか、 &lt;code&gt;abort&lt;/code&gt; を呼び出すことによって、この関数を実装します。使用されるメカニズムはリリースごとに異なる可能性があるため、特定の実装に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; の逆を行います。</target>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="translated">この関数のセマンティクスは &lt;code&gt;__builtin_expect&lt;/code&gt; と同じですが、呼び出し元は &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; であると予想される確率を提供します。最後の引数 &lt;var&gt;probability&lt;/var&gt; は、0.0〜1.0の範囲の浮動小数点値です。 &lt;var&gt;probability&lt;/var&gt; 引数は、浮動小数点定数式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="translated">この関数はPowerPCプラットフォームの &lt;code&gt;nop&lt;/code&gt; であり、x86ビルトインとのAPI互換性を維持するためにのみ含まれています。</target>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="translated">この関数は &lt;code&gt;__builtin_return_address&lt;/code&gt; に似ていますが、関数の戻りアドレスではなく、関数フレームのアドレスを返します。値 &lt;code&gt;0&lt;/code&gt; を指定して &lt;code&gt;__builtin_frame_address&lt;/code&gt; を呼び出すと、現在の関数のフレームアドレスが生成され、値 &lt;code&gt;1&lt;/code&gt; を指定すると、現在の関数の呼び出し元のフレームアドレスが生成されます。</target>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="translated">この関数は &lt;code&gt;__FUNCTION__&lt;/code&gt; シンボルと同等であり、組み込みが呼び出された関数の名前を指すアドレス定数を返します。呼び出しが関数のスコープにない場合は空の文字列を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++デフォルト引数として使用すると、関数のスコープで呼び出しが行われなかった場合は、 &lt;var&gt;F&lt;/var&gt; の呼び出し元の名前または空の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="translated">この関数は、プリプロセッサーの &lt;code&gt;__FILE__&lt;/code&gt; マクロと同等で、組み込みの呼び出しを含むファイル名を指すアドレス定数を返します。呼び出しが関数のスコープにない場合は空の文字列を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++のデフォルト引数として使用すると、 &lt;var&gt;F&lt;/var&gt; への呼び出しのファイル名、または関数のスコープで呼び出しが行われなかった場合は空の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="translated">この関数は、プリプロセッサーの &lt;code&gt;__LINE__&lt;/code&gt; マクロと同等であり、組み込みの呼び出しの行番号に評価される定数整数式を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++デフォルト引数として使用すると、 &lt;var&gt;F&lt;/var&gt; への呼び出しの行番号が返されます。</target>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="translated">この関数は、包括的 &lt;var&gt;begin&lt;/var&gt; と排他的 &lt;var&gt;end&lt;/var&gt; 間のメモリ領域のプロセッサの命令キャッシュをフラッシュするために使用されます。一部のターゲットでは、確定的な動作を得るために、コードを含むメモリを変更した後、命令キャッシュをフラッシュする必要があります。</target>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="translated">この関数は、データがアクセスされる前にデータをキャッシュに移動することにより、キャッシュミスのレイテンシを最小限に抑えるために使用されます。すぐにアクセスされる可能性が高いメモリ内のデータのアドレスがわかっているコードに、__ &lt;code&gt;__builtin_prefetch&lt;/code&gt; 呼び出しを挿入できます。ターゲットがそれらをサポートしている場合、データのプリフェッチ命令が生成されます。アクセスの前にプリフェッチが十分早く行われた場合、データはアクセスされるまでにキャッシュに存在します。</target>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="translated">この関数は、前の &lt;code&gt;__builtin_setjmp&lt;/code&gt; の呼び出しで保存された &lt;var&gt;buf&lt;/var&gt; のスタックコンテキストを復元します。後 &lt;code&gt;__builtin_longjmp&lt;/code&gt; を終了し、一致するかのように、プログラムが実行を再開 &lt;code&gt;__builtin_setjmp&lt;/code&gt; が値を返し &lt;var&gt;val&lt;/var&gt; 1でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="translated">この関数は、によって返されるどのような値を返す方法を説明したデータへのポインタを返す &lt;var&gt;function&lt;/var&gt; 。データは、スタックに割り当てられたメモリのブロックに保存されます。</target>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="translated">この関数は、ランタイムCPUのタイプが &lt;var&gt;cpuname&lt;/var&gt; の場合は正の整数を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。次のCPU名を検出できます。</target>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="translated">この関数は、ランタイムCPUが &lt;var&gt;feature&lt;/var&gt; をサポートしている場合は正の整数を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。次の機能を検出できます。</target>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="translated">この関数は、ランタイムCPUのタイプが &lt;var&gt;cpuname&lt;/var&gt; の場合は値 &lt;code&gt;1&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">この関数は値を返す &lt;code&gt;1&lt;/code&gt; を実行時のCPUがHWCAP機能のサポートしている場合に &lt;var&gt;feature&lt;/var&gt; し、リターン &lt;code&gt;0&lt;/code&gt; それ以外を。</target>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="translated">この関数は最初の引数を返し、コンパイラーは返されたポインターが少なくとも &lt;var&gt;align&lt;/var&gt; バイトであると想定できるようにします。この組み込みには2つまたは3つの引数を指定できます。3つある場合、3番目の引数は整数型でなければなりません。ゼロ以外の場合、不整合オフセットを意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="translated">この関数は、現在の関数またはその呼び出し元の1つの戻りアドレスを返します。 &lt;var&gt;level&lt;/var&gt; 引数は、コールスタックをスキャンするフレームの数です。値 &lt;code&gt;0&lt;/code&gt; は現在の関数の戻りアドレスを生成し、値 &lt;code&gt;1&lt;/code&gt; は現在の関数の呼び出し元の戻りアドレスを生成し、以下同様に続きます。期待される動作をインライン化するときは、関数は、返される関数のアドレスを返します。この動作を回避するには、 &lt;code&gt;noinline&lt;/code&gt; 関数属性を使用します。</target>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="translated">この関数は、CPU検出コードを実行して、CPUのタイプとサポートされている機能を確認します。この組み込み関数は、コンストラクターが呼び出される前に実行される関数で使用される場合にのみ、CPUのタイプと機能をチェックするための組み込み関数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; および &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; と共に呼び出す必要があります。CPU検出コードは、非常に優先度の高いコンストラクタで自動的に実行されます。</target>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="translated">この関数は、現在のスタックコンテキストを &lt;var&gt;buf&lt;/var&gt; に保存します。 &lt;code&gt;__builtin_setjmp&lt;/code&gt; は、直接戻る場合は0を返し、同じ &lt;var&gt;buf&lt;/var&gt; を使用して &lt;code&gt;__builtin_longjmp&lt;/code&gt; から戻る場合は1を返します。</target>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="translated">この関数は、文字列リテラルが与えられた場合、それらすべてが &lt;code&gt;strtol&lt;/code&gt; によって消費されるはずでしたが、コンパイル時定数と見なされるのに十分早く評価されます。</target>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">これは通常の静的配列と対称性があり、サイズが不明な配列も &lt;code&gt;[]&lt;/code&gt; で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="translated">これは、 &lt;var&gt;low&lt;/var&gt; から &lt;var&gt;high&lt;/var&gt; までの整数値ごとに1つずつ、適切な数の個別の &lt;code&gt;case&lt;/code&gt; ラベルと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="translated">このフックは通常、GNUstep Baseなどの「Foundation」ライブラリ用に予約されており、これを使用して、通常は &lt;code&gt;forwardInvocation:&lt;/code&gt; メソッドに基づいた高レベルのメソッド転送APIを実装します。したがって、独自の「Foundation」ライブラリを実装しているのでない限り、このフックを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="translated">このi386コードは、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用しない（または必要としない）ケースを示しています。アサーションチェックを実行している場合、このコードは &lt;code&gt;asm&lt;/code&gt; を使用して検証を実行します。それ以外の場合、 &lt;code&gt;dwRes&lt;/code&gt; はどのコードからも参照されません。その結果、オプティマイザは &lt;code&gt;asm&lt;/code&gt; ステートメントを破棄できるため、 &lt;code&gt;DoCheck&lt;/code&gt; ルーチン全体が不要になります。 &lt;code&gt;volatile&lt;/code&gt; 修飾子が不要な場合は省略して、オプティマイザが可能な限り最も効率的なコードを生成できるようにします。</target>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="translated">これは、 '内の山括弧または二重引用符の選択が</target>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="translated">これにより、完了するまで正確に &lt;var&gt;cycles&lt;/var&gt; 0から17E9のサイクルが必要な命令シーケンスが挿入されます。挿入されたシーケンスは、ジャンプ、ループ、またはノーオペレーションを使用でき、他の命令に干渉しません。 &lt;var&gt;cycles&lt;/var&gt; はコンパイル時の定数整数でなければならないことに注意してください。つまり、後で定数に最適化される可能性のある変数ではなく、数値を渡す必要があります。このビルトインによって遅延したサイクル数は正確です。</target>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="translated">この計測は、他の関数でインライン展開された関数に対しても行われます。プロファイリング呼び出しは、概念的には、インライン関数の開始と終了の場所を示します。これは、そのような関数のアドレス可能なバージョンが利用可能でなければならないことを意味します。関数のすべての使用がインラインで展開される場合、これはコードサイズの追加の拡張を意味する場合があります。Cコードで &lt;code&gt;extern inline&lt;/code&gt; でexternを使用する場合、そのような関数のアドレス可能なバージョンを提供する必要があります。 （これは通常いずれにしても当てはまりますが、運がよければ、オプティマイザーが常に関数をインラインで展開する場合は、静的コピーを提供せずに回避できた可能性があります。）</target>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="translated">このインターフェイスでは、 &lt;code&gt;int *&lt;/code&gt; 呼び出し規約を使用して、 &lt;code&gt;int *&lt;/code&gt; または &lt;code&gt;union wait *&lt;/code&gt; 引数を渡すことができます。プログラムは、次のいずれかのタイプの引数を使用して &lt;code&gt;wait&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="translated">この割り込みサービスルーチンは、 &lt;code&gt;PSW.GIE&lt;/code&gt; （グローバル割り込み有効化）が設定された後に割り込み可能です。これにより、割り込みサービスルーチンは、割り込みを有効にする前に、いくつかの重要なコードを終了できます。</target>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="translated">この割込みサービスルーチンは割込み可能です。</target>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="translated">この割込みサービスルーチンは割込み可能ではありません。</target>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="translated">これにより、 'の下の &lt;code&gt;gcc&lt;/code&gt; のすべてのサブプログラムが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、フラッシュとRAMを線形化する24ビットのアドレス空間です。アドレスの上位ビットが設定されている場合、データはRAMアドレスとして下位2バイトを使用してRAMから読み取られます。アドレスの上位ビットがクリアされている場合、データは、アドレスの上位バイトに従って &lt;code&gt;RAMPZ&lt;/code&gt; が設定された状態でフラッシュから読み取られます。&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt; &lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="translated">これはデバッグフラグです。と一緒に使用すると</target>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="translated">これは、アセンブラコードのテンプレートであるリテラル文字列です。これは、入力、出力、およびgotoパラメーターを参照する固定テキストとトークンの組み合わせです。&lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplateを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="translated">これはアセンブラのコードを指定するリテラル文字列です。この文字列には、ディレクティブを含め、アセンブラが認識する全ての命令を含めることができます。GCC はアセンブラ命令自体を解析しませんので、それが何を意味するのか、それが有効なアセンブラ入力であるかどうかさえわかりません。</target>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="translated">の方が細かくなっています。</target>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="translated">これはリンカのプロパティです。C99およびC11では、外部リンクを持つ識別子では常に大文字小文字の区別が重要であることが要求されており、このプロパティを持たないシステムはGCCではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="translated">これは、最適化パスを明示的に無効にしたり有効にしたりするために使用するオプションのセットです。これらのオプションは、GCC のデバッグに使用することを意図しています。コンパイラのユーザは、パスの有効化/無効化のための通常のオプションを代わりに使用してください。</target>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="translated">の同義語です。</target>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="translated">これはあっても許容されるイニシャライザで &lt;var&gt;EXPRESSION&lt;/var&gt; 場合を含む定数式でない &lt;code&gt;__builtin_constant_p&lt;/code&gt; ため戻っ1 &lt;var&gt;EXPRESSION&lt;/var&gt; 一定に折り畳むことができるが、 &lt;var&gt;EXPRESSION&lt;/var&gt; そうでない場合（例えば、初期化子静的に許可されていないオペランド含ま &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt; ）。GCCは、最適化を実行する機会がないため、この場合の組み込みの評価についてより保守的でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="translated">これは上級者向けのセクションです。型エンコーディングはコンパイラとランタイムによって広範囲に使用されますが、Objective-Cを使用するためには一般的には知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="translated">これは、 &lt;code&gt;double&lt;/code&gt; メンバーを使用してユニオンを作成する代わりの方法です。これにより、ユニオンはダブルワードで整列されます。</target>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">これは、ISO C99関数 &lt;code&gt;nan&lt;/code&gt; の実装です。</target>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="translated">これは、2147483648が &lt;code&gt;int&lt;/code&gt; 型に収まらないため、（ISO C規則に従って）そのデータ型が &lt;code&gt;unsigned long int&lt;/code&gt; であるためです。この値を否定すると、再び2147483648になります。</target>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="translated">これは、関連性があると考えられる呼び出しに適用されます。</target>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="translated">これは、サイズが最適化されたコールに適用されます。インライン化によって露出する最適化の機会を見越して、小さな成長が望ましいかもしれません。</target>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="translated">これは&lt;em&gt;マッチング制約&lt;/em&gt;と呼ばれ、それが実際に意味することは、アセンブラには &lt;code&gt;asm&lt;/code&gt; が区別する2つの役割を満たす単一のオペランドしかないということです。たとえば、add命令は2つの入力オペランドと1つの出力オペランドを使用しますが、ほとんどのCISCマシンでは実際にadd命令には2つのオペランドしかなく、そのうちの1つは入出力オペランドです。</target>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="translated">これは現在、C ++ 11の &lt;code&gt;memory_order_consume&lt;/code&gt; のセマンティクスが不足しているため、より強力な &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; メモリ順序を使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="translated">これはCライブラリの実装に依存しており、GCC自体では定義されていません。</target>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="translated">これは、アセンブラがサポートされている限り、DWARF 2 のデバッグ情報を通常のレベルで出力する際にデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="translated">これは、以下のように書くことに相当します。</target>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="translated">アセンブラで生成された行番号テーブルは、コンパイラが自分で生成するよりもずっとコンパクトなので、一般的にはこれが望ましいです。</target>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="translated">これは、GCCが従来 &lt;code&gt;inline&lt;/code&gt; 宣言された関数を処理する方法です。ISO C99は &lt;code&gt;inline&lt;/code&gt; に異なるセマンティクスを指定しているため、この関数属性は、遷移測定として、およびそれ自体で有用な機能として提供されます。この属性は、GCC 4.1.3以降で使用できます。プリプロセッサマクロ &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; または &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; のいずれかが定義されている場合に使用できます。「&lt;a href=&quot;inline#Inline&quot;&gt;インライン関数はマクロと同じくらい高速です&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="translated">これは、あらゆる意味で上記のISO Cの例と同等であるが、間違いなく、より読みやすく、記述的である。</target>
        </trans-unit>
        <trans-unit id="1eaa9666a3a5435e04f459b069a65e1a2259a5c1" translate="yes" xml:space="preserve">
          <source>This is intended for use by GCC developers and plugin developers when debugging diagnostics that report interprocedural control flow.</source>
          <target state="translated">これは、GCC開発者やプラグイン開発者が、手続き間の制御フローを報告する診断をデバッグする際に使用することを意図しています。</target>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="translated">これはちょうどのようです</target>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="translated">こんな感じです。</target>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="translated">これは必要とされる動的再配置の数を減らし、結果的にデータを読み取り専用にすることができるので、共有ライブラリに住むコードにはより親切です。ラベルの違いを持つこの代替案はAVRターゲットではサポートされていませんので、AVRプログラムには最初のアプローチを使用してください。</target>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="translated">x86-64では、これは &lt;code&gt;ax&lt;/code&gt; または &lt;code&gt;dx&lt;/code&gt; のいずれかにティックを割り当てるため、正しくありません。代わりに次のバリアントを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="translated">これはFortranの仮定形状配列で特に有用であり,(例えば)連続したアクセスを仮定したより良いベクトル化を可能にします.このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">に似ています。</target>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">これは、入力として &lt;code&gt;asm&lt;/code&gt; ステートメントに渡されるC変数または式です。括弧は構文の必須部分です。</target>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="translated">これはデフォルト(通常)の設定です。有効になっているのは、ソフトウェアで無効にできないトラップ(例:ゼロによる除算トラップ)のみです。</target>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="translated">これは、非Darwin x86-32ターゲットのデフォルトの選択です。</target>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="translated">これは、x86-64 コンパイラ、Darwin x86-32 ターゲットのデフォルトの選択であり、SSE2 命令セットを使用する x86-32 ターゲットのデフォルトの選択です。</target>
        </trans-unit>
        <trans-unit id="b74e8d3240c6f67db12f1d7fa81a7aa2edb28fb1" translate="yes" xml:space="preserve">
          <source>This is the default on some targets.</source>
          <target state="translated">これは一部のターゲットではデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="translated">のデフォルトの警告レベルです。</target>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミック交換の一般的なバージョンです。 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; の内容を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に格納します。 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の元の値は &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミックロードの一般的なバージョンです。それはの内容を返す &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 中で &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミックストアの汎用バージョンです。 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; の値を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に格納します。</target>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="translated">これは、浮動小数点演算を行う際に使用されるモードで、ラウンド・トゥ・ニアレストまたはイーブンの丸めモードを使用します。</target>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="translated">これは、切り捨て(つまりゼロに向かって丸める)丸めモードを持つ浮動小数点演算に使用されるモードです。これには、浮動小数点から整数への変換も含まれます。</target>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="translated">これは、FPUで整数計算を実行するために使用されるモードで、例えば、整数の乗算、または整数の乗算と累積などがあります。</target>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="translated">これは 'と同じです</target>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="translated">これは最もシンプルなオプションですが、柔軟性があり、必要に応じて細かく制御することができます。また、これは最も移植性の高い代替手段であり、この方法を使用したプログラムはほとんどの最新のコンパイラで動作します。</target>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="translated">の警告レベルです。</target>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="translated">これは</target>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="translated">これが典型的な出力です。</target>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="translated">これは、 &lt;code&gt;gcc&lt;/code&gt; がエラーメッセージを出力するときに便利です'</target>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="translated">を使うときに便利です。</target>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="translated">これが、GCCがプレーンなビットフィールドをすべてのタイプのマシン上で同じ方法で扱う理由です(デフォルトでは)。</target>
        </trans-unit>
        <trans-unit id="4b959d24ea2462316c67c3712ca90973257d6c02" translate="yes" xml:space="preserve">
          <source>This level is intended for analyzer developers; it adds various other events intended for debugging the analyzer.</source>
          <target state="translated">このレベルはアナライザの開発者向けで、アナライザのデバッグ用に様々なイベントを追加します。</target>
        </trans-unit>
        <trans-unit id="7c1b93195f2512278e6a6fff2538323d8e57d38c" translate="yes" xml:space="preserve">
          <source>This level is the default.</source>
          <target state="translated">このレベルがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="translated">このマクロは</target>
        </trans-unit>
        <trans-unit id="7d487e0152f8e873aae65c9ae3d1ffd07da68324" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 10.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">このマニュアルでは、GNUコンパイラの使用方法、その機能と非互換性、およびバグの報告方法について説明しています。コンパイラ（GCC）バージョン10.2.0に対応します。GNUコンパイラの内部は、新しいターゲットに移植する方法や、新しい言語のフロントエンドを作成する方法に関する情報など、別のマニュアルに記載されています。GNUコンパイラコレクション（GCC）内部の&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;概要&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">このマニュアルでは、GNUコンパイラの使用方法、その機能と非互換性、およびバグの報告方法について説明します。コンパイラ（GCC）バージョン9.2.0に対応しています。新しいターゲットに移植する方法や新しい言語のフロントエンドを作成する方法に関する情報など、GNUコンパイラの内部については、別のマニュアルに記載されています。GNUコンパイラコレクション（GCC）の内部の&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;概要&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="translated">このメカニズムは、 &lt;code&gt;+initialize&lt;/code&gt; の代わりになるものではありません。 &lt;code&gt;+initialize&lt;/code&gt; の代わりに使用する場合は、その制限に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="translated">これは奇妙に見えるかもしれません。insnがコンパイル時に不明な値を持つ定数オペランドを許可する場合、既知の値を許可する必要があります。だからなぜ使用する '</target>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="translated">この番号は、1桁以上にすることができます。複数の数字が連続して出現する場合、それらは単一の10進整数として解釈されます。今日までそれが望ましくなかったので、あいまいさの可能性はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="translated">これは、GCCが存在しない変数を最適化する場合があるために発生します。このような変数が「持っていたはず」の値を計算する方法をデバッガーに指示する方法はありません。とにかくそれが望ましいことは明らかではありません。そのため、GCCはデバッグ情報を書き込むときに、削除された変数については言及しません。</target>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="translated">これは、レジスタの割り当て後にスケジューリングを行う場合にのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="translated">この最適化は、例外処理やアンワインドテーブル(setjump/longjump またはターゲット固有のスキームを使用するターゲット)、linkonce セクション、ユーザー定義のセクション属性を持つ関数、および名前付きセクションをサポートしないアーキテクチャでは、自動的にオフになります。以下のような場合には、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="96a50b9ceb3aa5aae8cfa612292d0e06f418fdee" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default for PowerPC targets, but disabled by default otherwise.</source>
          <target state="translated">この最適化は、PowerPC ターゲットではデフォルトで有効になっていますが、それ以外の場合はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="translated">この最適化はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="translated">この最適化は、すべての最適化レベルでデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="translated">このオプションは、浮動小数点演算がIEEE標準よりも高い精度または範囲のフォーマットで行われ、浮動小数点型を交換するようなマシンで、過剰な精度をさらに制御することを可能にします。デフォルトでは</target>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="translated">このオプションを使用すると、プリコンパイル済みヘッダー（「&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;プリ&lt;/a&gt;コンパイル済みヘッダー」を参照）と一緒に使用できます。</target>
        </trans-unit>
        <trans-unit id="bc138a12e44acf9ec0d9c17239119bb46de565b8" translate="yes" xml:space="preserve">
          <source>This option also controls warnings when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">このオプションは、ユーザー定義のリテラル演算子がアンダースコアで始まらないリテラルサフィックス識別子で宣言された場合の警告も制御します。アンダースコアで始まらないリテラルサフィックス識別子は、将来の標準化のために予約されています。</target>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="translated">このオプションでは、次のことも可能になります。</target>
        </trans-unit>
        <trans-unit id="f64cb852c815528bec1c35d19339c840b9bc9852" translate="yes" xml:space="preserve">
          <source>This option also enables warnings about psABI-related changes. The known psABI changes at this point include:</source>
          <target state="translated">このオプションでは、psABI関連の変更に関する警告も有効にします。この時点で既知の psABI の変更には以下のものがあります。</target>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="translated">このオプションは、 &lt;code&gt;alloca&lt;/code&gt; がループで使用されているときにも警告します。</target>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="translated">このオプションは、 &lt;code&gt;longjmp&lt;/code&gt; の呼び出しによって不揮発性自動変数が変更される可能性がある場合にも警告します。コンパイラーは、 &lt;code&gt;setjmp&lt;/code&gt; の呼び出しのみを認識します。 &lt;code&gt;longjmp&lt;/code&gt; が呼び出される場所を知ることはできません。実際、シグナルハンドラーは、コードの任意の時点でそれを呼び出すことができます。その結果、問題が発生する場所で &lt;code&gt;longjmp&lt;/code&gt; を実際に呼び出すことができないため、実際には問題がない場合でも警告が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="translated">このオプションとそれに対応するもの。</target>
        </trans-unit>
        <trans-unit id="5138f290e3826f8790e3e713269029e9ccdb5e45" translate="yes" xml:space="preserve">
          <source>This option behaves mostly the same as the MSP430 function attribute of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;), but it has some additional functionality.</source>
          <target state="translated">このオプションは、同じ名前の&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430関数属性&lt;/a&gt;（MSP430関数属性を参照）とほぼ同じように動作しますが、いくつかの追加機能があります。</target>
        </trans-unit>
        <trans-unit id="d7bf60baf10d559ca0b1b6d693e3ba93b5e1f2d3" translate="yes" xml:space="preserve">
          <source>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed</source>
          <target state="translated">このオプションは、従来のカスタムデバイス仕様ファイルを指定する際に必要だった</target>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="translated">このオプションは、 &lt;code&gt;hotpatch&lt;/code&gt; 属性を持つ個々の関数に対してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="b9d6d68f8663846b608b68015e96e5892b5536f8" translate="yes" xml:space="preserve">
          <source>This option can be used in combination with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="translated">このオプションは、printf ライクな関数の呼び出しのように、スタック上で引数を取得する関数への複数の呼び出しを実行する関数のコードサイズを小さくすることができます。</target>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="translated">このオプションは、ターゲットアーキテクチャが分岐可能な命令をサポートしている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="translated">このオプションには、機能修飾子を接尾辞として付けることはできません。</target>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="translated">このオプションを使用すると、GCCはステートメントの先頭で内部表現にマーカーを作成し、それらを使用して、行番号テーブル内の &lt;code&gt;is_stmt&lt;/code&gt; マーカーの出力をガイドするために、コンパイル中おおよその位置に保ちます。これは、最適化を使用してコンパイルするときにデフォルトで有効になります（</target>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="translated">このオプションを使用すると、r2とr5は固定レジスタとして扱われます。</target>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="translated">このオプションを使用すると、コンパイラが生成するコードで r2 と r5 が使用されます。この設定がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="translated">このオプションにより、プログラムの起動時にランタイムデータ構造が構築され、vtableポインターの検証に使用されます。オプション '</target>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="translated">このオプションを使用すると、コンパイルを続行してエラーメッセージを表示するのではなく、最初に発生したエラーでコンパイルを中止します。</target>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="translated">このオプションにより、プリプロセッサマクロ &lt;code&gt;__FAST_MATH__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="translated">このオプションにより、プリプロセッサマクロ &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="c130859b377ff82df01657d63e921773dd0c4fe8" translate="yes" xml:space="preserve">
          <source>This option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">このオプションは、リンク時間オプティマイザのコード生成を制御します。デフォルトでは、リンカの出力はリンカ・プラグインによって自動的に決定されます。コンパイラのデバッグや、非LTOオブジェクト・ファイルとのインクリメンタル・リンクが必要な場合は、手動でタイプを制御すると便利です。</target>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="translated">このオプションは、ユーザーが宣言したローカル/自動変数とコンパイラが生成した一時変数のスタックスペースの再利用を制御します。 &lt;var&gt;reuse_level&lt;/var&gt; 利用レベルは</target>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">このオプションは、リンク時間オプティマイザのコード生成を制御します。デフォルトでは、リンカーの出力はリンカー・プラグインによって自動的に決定されます。コンパイラのデバッグや、非ltoオブジェクトファイルへのインクリメンタルリンクが必要な場合には、手動でタイプを制御すると便利です。</target>
        </trans-unit>
        <trans-unit id="9a86853e0ed7deb868803dd87757662761aedfd9" translate="yes" xml:space="preserve">
          <source>This option controls the complexity of the control flow paths that are emitted for analyzer diagnostics.</source>
          <target state="translated">このオプションは、アナライザ診断用に放射される制御フロー・パスの複雑さを制御します。</target>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="translated">このオプションは、ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; プラグマのデフォルト設定を制御します。それでも、このオプションはすべての言語に適用されます。</target>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="translated">このオプションは、2番目のスケジューリングパス中にディスパッチスロット制限付き命令に割り当てられる優先度を制御します。引数の &lt;var&gt;priority&lt;/var&gt; は値 'を取ります</target>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">このオプションは、コンパイラが実行可能ファイルにリンクするlibgccのバージョンを制御し、特定のキャッシュサイズで &lt;code&gt;__ea&lt;/code&gt; アドレス空間の変数にアクセスするためのソフトウェア管理キャッシュを選択します。 &lt;var&gt;cache-size&lt;/var&gt; の可能なオプションは '</target>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="translated">このオプションは、コンパイラーが実行可能ファイルにリンクするlibgccのバージョンを制御し、PPU側の変数のソフトウェア管理キャッシュに対するアトミック更新を使用するかどうかを選択します。アトミック更新を使用する場合、 &lt;code&gt;__ea&lt;/code&gt; 名前付きアドレス空間修飾子を使用してSPUコードからPPU変数を変更しても、PPUコードから同じキャッシュラインにある他のPPU変数への変更を妨げることはありません。アトミック更新を使用しない場合、そのような干渉が発生する可能性があります。ただし、キャッシュラインを書き戻す方が効率的です。デフォルトの動作では、アトミック更新を使用します。</target>
        </trans-unit>
        <trans-unit id="f61295df1d57ff262d461369dde8c3f32294d711" translate="yes" xml:space="preserve">
          <source>This option controls warnings for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">このオプションの起動のための制御警告&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic組み込み関数&lt;/a&gt;、&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;組み込み関数__sync&lt;/a&gt;動作または値の範囲外のいずれか無効でメモリ一貫性引数を、およびC11原子汎用関数を &lt;code&gt;memory_order&lt;/code&gt; の列挙。たとえば、 &lt;code&gt;__atomic_store&lt;/code&gt; および &lt;code&gt;__atomic_store_n&lt;/code&gt; ビルトインは、リラックス、リリース、および逐次一貫性のあるメモリオーダーに対してのみ定義されているため、次のコードが診断されます。</target>
        </trans-unit>
        <trans-unit id="d64a7975973f5229e105c9130aabc92aaaa20581" translate="yes" xml:space="preserve">
          <source>This option controls warnings if feedback profiles are missing when using the</source>
          <target state="translated">このオプションは、フィードバックプロファイルがない場合の警告を制御します。</target>
        </trans-unit>
        <trans-unit id="db5b3a6e625e42c517fab36eef17aa077a6434f1" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a &lt;code&gt;switch&lt;/code&gt; case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">このオプションは、 &lt;code&gt;switch&lt;/code&gt; ケースの値がそれぞれのタイプの範囲外である場合の警告を制御します。この警告は、CおよびC ++プログラムではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="d647e87ba0a1edc0a3d0d54b53d61b0d1016c986" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a base class is inaccessible in a class derived from it due to ambiguity. The warning is enabled by default. Note that the warning for ambiguous virtual bases is enabled by the</source>
          <target state="translated">このオプションは、基底クラスが曖昧さのためにその基底クラスから派生したクラスにアクセスできない場合の警告を制御します。この警告はデフォルトで有効になっています。あいまいな仮想ベースに対する警告は</target>
        </trans-unit>
        <trans-unit id="6199fdb67a75703bc6938c6426b3cd53c0cf499e" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">このオプションは、宣言が型を指定していない場合の警告を制御します。この警告は、C99 およびそれ以降の C 言語の方言ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="925a6115338780b00aeb738e9eb85ce67e1d1212" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">このオプションは、関数が宣言される前に使用されたときの警告を制御します。この警告は、C99 およびそれ以降の C 言語の方言ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="e630e657c926dcb14e35c4ecbe7b78750ea05b99" translate="yes" xml:space="preserve">
          <source>This option controls warnings when an attribute is ignored. This is different from the</source>
          <target state="translated">このオプションは、属性が無視されたときの警告を制御します。これは</target>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="translated">このオプションは、浮動小数点関連のトラップを有効にするかどうかを制御します。他のAlphaコンパイラはこのオプションを</target>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="translated">このオプションは、 &lt;code&gt;__sync&lt;/code&gt; 関数ファミリーのアウトオブラインインスタンスを使用して、C ++ 11の &lt;code&gt;__atomic&lt;/code&gt; 関数ファミリーを実装できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">このオプションは、2番目のスケジューリングパスで使用されるNOP挿入方式を制御します。引数 &lt;var&gt;scheme&lt;/var&gt; は、次のいずれかの値を取ります。</target>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">このオプションは、命令のスケジューリング時にターゲットがどの依存関係にコストがかかると見なすかを制御します。引数 &lt;var&gt;dependence_type&lt;/var&gt; は、次のいずれかの値を取ります。</target>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="translated">このオプションは、使用できる相互推定命令を制御します。 &lt;var&gt;opt&lt;/var&gt; はコンマで区切られたオプションのリストで、先頭に '</target>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="translated">このオプションは、使用できる相互推定命令を制御します。 &lt;var&gt;opt&lt;/var&gt; はオプションのコンマ区切りのリストで、前に &lt;code&gt;!&lt;/code&gt; オプションを反転するには：</target>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="translated">このオプションは現在のところRTLダンプに対してのみ機能し、RTLは常にスリムな形でダンプされます。</target>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="translated">このオプションのデフォルトは</target>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="translated">このオプションは、以前に有効になっていたサニタイザーをすべて無効にします。</target>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="translated">このオプションは、次のようなプリプロセッサのデバッグ出力を抑制しません。</target>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="translated">このオプションは、指定された初期化子について警告を発しないので、以下の変更は警告を発しません。</target>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="translated">このオプションは、共有ライブラリや入れ子になった関数がある場合には動作しません。</target>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="translated">このオプションを使用すると、コンパイラーは &lt;code&gt;enter&lt;/code&gt; および &lt;code&gt;leave&lt;/code&gt; 命令を発行できます。これらの命令は、コード密度機能を備えたCPUにのみ有効です。</target>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="translated">このオプションを使用すると、GCC が64ビットコードで &lt;code&gt;CMPXCHG16B&lt;/code&gt; 命令を生成して、16バイト境界で整列された128ビットオブジェクトに比較および交換操作を実装できます。これは、サイズが1マシンワードを超えるデータ構造のアトミック更新に役立ちます。コンパイラーは、この命令を使用して&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;を実装します。ただし、128ビット整数で動作する&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtinsの&lt;/a&gt;場合、ライブラリー呼び出しが常に使用されます。</target>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="translated">このオプションは、事前に定義された名前付きのカスタム命令エンコーディングのセットを有効にします (</target>
        </trans-unit>
        <trans-unit id="ba4e36ba668d3f1644121ffdad98a65c14adabae" translate="yes" xml:space="preserve">
          <source>This option enables an static analysis of program flow which looks for &amp;ldquo;interesting&amp;rdquo; interprocedural paths through the code, and issues warnings for problems found on them.</source>
          <target state="translated">このオプションを使用すると、プログラムフローの静的分析が可能になり、コード内の「興味深い」手続き間パスを探し、それらで見つかった問題に対して警告を発行します。</target>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="translated">このオプションは、機能を内蔵可能 &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt; 、 &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt; 、 &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; と &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; 生成する &lt;code&gt;crc32&lt;/code&gt; マシン命令を。</target>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="translated">このオプションは、ポインタが参照解除されたときや、参照が十分にアラインメントされていないターゲットにバインドされたとき、あるいはメソッドやコンストラクタが十分にアラインメントされていないオブジェクト上で呼び出されたときに、ポインタのアラインメントをチェックすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="translated">このオプシ ョ ンは、 シ フ ト 演算の結果が未定義でない こ と を確認で き る よ う に し ます。具体的に何を未定義とみなすかは、C と C++の間、また ISO C90 と C99 の間などで若干異なりますので注意してください。このオプシ ョ ンには 2 つのサブオプシ ョ ンがあ り ます。</target>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="translated">このオプションを使用すると、シフト操作の第2引数が負ではなく、昇格した第1引数の精度よりも小さいことを確認することができます。</target>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="translated">このオプションは、浮動小数点型から整数型への変換チェックを有効にします。変換結果がオーバーフローしないかどうかをチェックします。他の類似のオプションとは異なります。</target>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="translated">このオプションを使用すると、通常の文字列やUTF-8の文字列に対して関数をオーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="translated">このオプションを使用すると、64ビットコードで &lt;code&gt;SAHF&lt;/code&gt; 命令を生成できます。 2005年12月にPentium 4 G1ステップが導入される前の、Intel 64対応の初期のIntel Pentium 4 CPUには、AMD64でサポートされている &lt;code&gt;LAHF&lt;/code&gt; および &lt;code&gt;SAHF&lt;/code&gt; 命令がありませんでした。これらは、特定のステータスフラグのロードおよびストア命令です。 64ビットモードでは、 &lt;code&gt;SAHF&lt;/code&gt; 命令を使用して &lt;code&gt;fmod&lt;/code&gt; 、 &lt;code&gt;drem&lt;/code&gt; 、および &lt;code&gt;remainder&lt;/code&gt; 組み込み関数を最適化します。詳細については、&lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;他のビルトイン&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="translated">このオプションを使用すると、C++のメンバ関数呼び出し、メンバ・アクセス、および基底クラスと派生クラスへのポインタ間の一部の変換を計測して、参照されるオブジェクトが正しい動的型を持っていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="translated">このオプションは、選択された組み込み関数への引数の計測を有効にします。そのような引数に無効な値が渡されると、実行時エラーが発行されます。たとえば、 &lt;code&gt;__builtin_ctz&lt;/code&gt; または &lt;code&gt;__builtin_clz&lt;/code&gt; の引数として0を渡すと、未定義の動作が呼び出され、このオプションによって診断されます。</target>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="translated">このオプションを使用すると、アレイの境界を計測できるようになります。様々なアウトオブバウンズアクセスが検出されます。柔軟な配列メンバ、柔軟な配列メンバライクな配列、静的ストレージを持つ変数の初期化子は計測されません。</target>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">このオプションは、NULL値がNULL以外で値を必要とするものとしてマークされた引数に渡されていないかどうかをチェックし、通話の計測を可能に &lt;code&gt;nonnull&lt;/code&gt; 関数属性。</target>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="translated">このオプションは、列挙型からのロードの計測を可能にします。列挙型の値の範囲外の値がロードされた場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="translated">このオプションは、boolからのロードの計測を可能にします。0/1以外の値がロードされた場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="translated">このオプションは、 &lt;code&gt;__builtin_object_size&lt;/code&gt; 関数を使用してメモリ参照の計測を有効にします。さまざまな範囲外のポインターアクセスが検出されます。</target>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="translated">このオプションは、ポインタ演算の計測を可能にします。ポインタ演算器がオーバーフローした場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="translated">このオプションは、 &lt;code&gt;returns_nonnull&lt;/code&gt; 関数属性でマークされた関数のreturnステートメントの計測を有効にして、そのような関数からのnull値の戻りを検出します。</target>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="translated">このオプションでは、このオプションで指定されたMCU名の競合に関する警告を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="translated">このオプションはポインタチェックを有効にします。特に、このオプションを有効にしてビルドされたアプリケーションは、 NULL ポインタを参照解除しようとした場合や、 参照 (おそらく rvalue 参照)が NULL ポインタにバインドされている場合、あるいは NULL ポインタが指すオブジェクトに対してメソッドが呼び出された場合に、 エラーメッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="translated">このオプションは、戻り文のチェックを有効にします。このオプションを有効にして構築されたプログラムは、実際に値を返さずに非ボイド関数の終了に到達した場合にエラーメッセージを発行します。このオプションは C++のみで動作します。</target>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="translated">このオプションは、符号付き整数オーバーフローチェックを有効にします。私たちは、結果ことを確認してください &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および単項およびバイナリの両方が &lt;code&gt;-&lt;/code&gt; 署名算術演算でオーバーフローしません。整数の昇格ルールを考慮する必要があることに注意してください。つまり、以下はオーバーフローではありません。</target>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="translated">このオプションは、配列の境界を厳密に計測することを可能にします。柔軟性のある配列メンバや柔軟性のある配列メンバのような配列を含む、ほとんどのアウトオブバウンズアクセスを検出します。静的なストレージを持つ変数の初期化子は計測されません。</target>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="translated">このオプションは、ライブラリアーカイブからGIMPLEバイトコードを用いたオブジェクトファイルを抽出することを可能にします。これにより、より多くのコードをリンク時間オプティマイザに公開して最適化の質を向上させます。この情報は、どのようなシンボルが外部から(非LTOオブジェクトや動的リンク中に)アクセスできるかを指定します。バイナリ(および非表示の可視性を使用する共有ライブラリ)でのコード品質の向上の結果は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="aff42a7c223b12e8af263b78f8decfd79d138482" translate="yes" xml:space="preserve">
          <source>This option enables transitivity of constraints within the analyzer.</source>
          <target state="translated">このオプションを使用すると、アナライザ内の制約の変換が可能になります。</target>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="translated">このオプションは、単精度浮動小数点引数の &lt;code&gt;DIVSS&lt;/code&gt; および &lt;code&gt;SQRTSS&lt;/code&gt; （およびそれらのベクトル化されたバリアント）の代わりに、精度を高めるために追加のNewton-Raphsonステップで &lt;code&gt;RCPSS&lt;/code&gt; および &lt;code&gt;RSQRTSS&lt;/code&gt; 命令（およびそれらのベクトル化されたバリアント &lt;code&gt;RCPPS&lt;/code&gt; および &lt;code&gt;RSQRTPS&lt;/code&gt; ）の使用を有効にします。これらの指示は、次の場合にのみ生成されます</target>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="translated">このオプションにより、 &lt;code&gt;movbe&lt;/code&gt; 命令を使用して &lt;code&gt;__builtin_bswap32&lt;/code&gt; および &lt;code&gt;__builtin_bswap64&lt;/code&gt; を実装できます。</target>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="translated">このオプションは、浮動小数点引数で除算や平方根と除算を行う代わりに、精度を向上させるためにニュートン-ラプソンステップを追加した逆推定と平方根の逆推定命令を使用することを可能にします。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="translated">このオプションを使用すると、AddressSanitizer のチェックで GCC がカスタム シャドウ オフセットを使用するように強制されます。これは、カーネル アドレス サニタイザーでさまざまなシャドウ メモリ レイアウトを実験するのに便利です。</target>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="translated">このオプションは、足し算・引き算・乗算演算で符号付きオーバーフローのトラップを生成します。オプション</target>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="translated">このオプションはabicallsのコードには何の影響もありません。デフォルトは</target>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="translated">このオプションは無視されます。ソフトウェアの浮動小数点コードはデフォルトで出力され、このデフォルトはFPXオプションで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="translated">このオプションは、次のことを暗示しています。</target>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="translated">このオプションは、68060 のソフトウェアでエミュレートする必要がある 68020 および 68881/68882 命令の使用を禁止します。68060にこれらの命令をエミュレートするコードがない場合は、このオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="translated">このオプションは、68040 のソフトウェアでエミュレートする必要がある 68881/68882 命令の使用を禁止します。68040にこれらの命令をエミュレートするコードがない場合は、このオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="translated">このオプションは、メインファイル以外の依存関係ごとに偽のターゲットを追加するようにCPPに指示し、それぞれが何にも依存しないようにします。これらのダミールールは、ヘッダーファイルを削除せずにエラー &lt;code&gt;make&lt;/code&gt; 回避し、</target>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="translated">このオプションは、GCC に x86 パフォーマンスチューニング機能とデフォルト設定の名前をダンプするように指示します。この名前は</target>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="translated">このオプションは、文字列命令を使用する関数のプロローグで &lt;code&gt;cld&lt;/code&gt; 命令を発行するようにGCCに指示します。文字列命令はDFフラグに依存して、自動インクリメントモードまたは自動デクリメントモードを選択します。 ABIは関数の開始時にDFフラグをクリアするように指定しますが、一部のオペレーティングシステムは、例外ディスパッチャーのDFフラグをクリアしないことにより、この仕様に違反しています。例外ハンドラーは、DFフラグを設定して呼び出すことができます。これにより、文字列命令が使用されたときに誤った方向モードになります。このオプションは、32ビットx86ターゲットでデフォルトで有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="translated">このオプションは、制御フローを関数から転送する前に &lt;code&gt;vzeroupper&lt;/code&gt; 命令を発行してAVXからSSEへの移行ペナルティを最小限に抑え、不要な &lt;code&gt;zeroupper&lt;/code&gt; 組み込み関数を削除するようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="translated">このオプションは、GCC にチューニング可能な機能をすべてオフにするよう指示します。以下も参照してください。</target>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="translated">このオプションは、オートベクタライザで256ビットのAVX命令の代わりに128ビットのAVX命令を使用するようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="translated">このオプションは、GCCに対して、選択したプラットフォームでのデフォルトではなく、 &lt;var&gt;opt&lt;/var&gt; -bitベクトル幅を命令で使用するように指示します。</target>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="translated">このオプションは、足し算と引き算の際にポインタの算術オーバーフローが二相補表現を使用して回避されると仮定するようにコンパイラに指示します。このフラグは、ポインタのオーバーフローが無効であると仮定したいくつかの最適化を無効にします。</target>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="translated">このオプションは、加算、減算、乗算の符号付き算術のオーバーフローが二相補表現を使用して回避されると仮定するようにコンパイラに指示します。このフラグは、いくつかの最適化を有効にし、その他の最適化を無効にします。オプション</target>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="translated">このオプションは、可変長配列のサイズが正の値であることを確認するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="translated">このオプションは、16エントリのレジスタファイルのコードを生成するようコンパイラーに指示します。このオプションは、 &lt;code&gt;__ARC_RF16__&lt;/code&gt; プリプロセッサマクロを定義します。</target>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="translated">このオプションはアセンブラにも渡されます。</target>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="translated">このオプションは、特定のマシンではデフォルトで常に有効になっています。</target>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="translated">このオプションは、CygwinおよびMinGWターゲットで使用できます。DLL（ダイナミックリンクライブラリ）を生成することを指定し、必要なランタイムスタートアップオブジェクトとエントリポイントを選択できるようにします。</target>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="translated">このオプションはCygwinとMinGWターゲットで利用可能です。リンカにPEヘッダサブシステムタイプを適切に設定するよう指示してGUIアプリケーションを生成することを指定します。</target>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="translated">このオプションは、CygwinおよびMinGWターゲットで使用できます。 &lt;code&gt;dllimport&lt;/code&gt; 属性を無視するように指定しています。</target>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="translated">このオプションは Cygwin と MinGW ターゲットで利用可能です。これは、コードを生成する際に、COMMON変数の正しい位置合わせを可能にするPEファイル形式のGNU拡張子を使用することを指定します。設定中に見つかったターゲットアセンブラがこの機能をサポートしていることを GCC が検出した場合、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="translated">このオプションはCygwinとMinGWターゲットで利用可能です。典型的なMicrosoft Windowsの定義済みマクロをプリプロセッサで設定することを指定しますが、ランタイムライブラリ/スタートアップコードの選択には影響しません。</target>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="translated">このオプションは、MinGWおよびCygwinターゲットで使用できます。読み取り専用セクションのrelocated-dataが &lt;code&gt;.data&lt;/code&gt; セクションに配置されることを指定します。これは、疑似再配置のための &lt;code&gt;.rdata&lt;/code&gt; セクションの変更をサポートしていない古いランタイムに必要です。</target>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="translated">このオプションはMinGWターゲットで使用できます。MinGW固有のスレッドサポートを使用することを指定します。</target>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="translated">このオプションは、MinGWターゲットで使用できます。ネストされた関数で使用されるスタックの実行可能フラグが設定されていないことを指定します。これは、Microsoft Windowsのカーネルモードで実行されているバイナリに必要です。実行可能権限を設定するために使用されるUser32 APIが使用できないためです。</target>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="translated">このオプションは、MinGW-w64ターゲットで使用できます。これは、原因 &lt;code&gt;UNICODE&lt;/code&gt; プリプロセッサマクロが事前定義すること、およびUnicode対応ランタイムスタートアップコードを選択します。</target>
        </trans-unit>
        <trans-unit id="d398f6bbd65088d4b5a66179b5d137a011940d08" translate="yes" xml:space="preserve">
          <source>This option is deprecated and has no effect.</source>
          <target state="translated">このオプションは非推奨であり、何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="translated">このオプションは非推奨です。</target>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="translated">このオプションは非推奨です。これは構造体を4バイトの倍数にパッドするもので、SH ABIとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="translated">このオプションは非推奨です。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="translated">このオプションはレベル</target>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="1157d5cea597fdcb95a42f4efe9767ae5da67d67" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at</source>
          <target state="translated">このオプションはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="translated">このオプションは、最適化レベルでデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="translated">このオプションは、Microsoft Windowsターゲットではデフォルトで有効になっています。この動作は、変数またはタイプ属性を使用してローカルに制御することもできます。詳細については、「&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86変数属性」&lt;/a&gt;および「&lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86タイプ属性&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="translated">このオプションはほとんどのターゲットでデフォルトで有効になっています。Nios II ELFでは、デフォルトはオフになっています。AVR、CR16、MSP430では、このオプションは完全に無効になっています。</target>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="translated">このオプションは、GCC の LTO サポートが有効で、プラグインをサポートするリンカ (GNU ld 2.21 以降または gold)で GCC を使用するように設定されている場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="translated">このオプションは、RH850 ABI を使用しているときにデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="translated">このオプションは実験的なものであり、シグナリングNaNの動作に影響を与えるすべてのGCC最適化を無効にすることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="translated">このオプションは実験的なものであり、現在、丸めモードの影響を受けるすべてのGCC最適化を無効にすることを保証していません。GCCの将来のバージョンでは、C99の &lt;code&gt;FENV_ACCESS&lt;/code&gt; プラグマを使用して、この設定をより細かく制御できるようになる可能性があります。このコマンドラインオプションは、 &lt;code&gt;FENV_ACCESS&lt;/code&gt; のデフォルトの状態を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="translated">このオプションは実験的なものであり、圧縮されたJSONファイル内のデータのフォーマットは変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="translated">このオプションは無視され、互換性のためだけに提供されます。</target>
        </trans-unit>
        <trans-unit id="988bc726815f60352325aa80e3adb73dc59e56eb" translate="yes" xml:space="preserve">
          <source>This option is ignored; it is for compatibility purposes only. This used to select linker and preprocessor options for use with newlib.</source>
          <target state="translated">このオプションは無視されます。これは newlib で使用するリンカとプリプロセッサのオプションを選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="translated">このオプションは、2回目のコンパイルを行う際に</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="d3193c2234bb7da293261732a9d8d77268c8fc1c" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers.</source>
          <target state="translated">このオプションはアナライザ開発者向けです。</target>
        </trans-unit>
        <trans-unit id="a6f2c53d2e68d97cb3dfd3ec9c7aa21718a8745f" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of control flow within diagnostic paths.</source>
          <target state="translated">このオプションは、アナライザの開発者向けです。このオプションを使用すると、診断パス内の制御フローの説明をより冗長で低レベルの詳細なものにすることができます。</target>
        </trans-unit>
        <trans-unit id="d656b9a9c9fb5f6bcdc2b59dc196d049700bd1b2" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of events relating to state machines within diagnostic paths.</source>
          <target state="translated">このオプションは、アナライザの開発者向けです。このオプションを使用すると、診断パス内のステートマシンに関連するイベントの説明をより冗長で低レベルの詳細なものにすることができます。</target>
        </trans-unit>
        <trans-unit id="4f67300ba0c3c74acfb2d8150e18a2987b0d6f05" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers: if multiple diagnostics have been detected as being duplicates of each other, it emits a note when reporting the best diagnostic, giving the number of additional diagnostics that were suppressed by the deduplication logic.</source>
          <target state="translated">複数の診断が重複していることが検出された場合、最良の診断を報告する際にノートが表示され、重複排除ロジックによって抑制された追加の診断の数が表示されます。</target>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="translated">このオプションは互換性のために残されています。</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="translated">このオプションはデフォルトではオフになっています。このオプションは</target>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="translated">このオプションは、符号付きオーバーフローが未定義の場合にのみ有効です。このオプションは、符号付きオーバーフローが発生しないと仮定してコンパイラが最適化する場合について警告します。このオプションは、コードがオーバーフローする可能性のあるすべてのケースについて警告するわけではなく、 コンパイラが何らかの最適化を実装している場合にのみ警告します。このように、この警告は最適化レベルに依存します。</target>
        </trans-unit>
        <trans-unit id="84e9b00e2175bed56ae8768cc7c1a2405f67103d" translate="yes" xml:space="preserve">
          <source>This option is only applicable when compiling for the base ARMv8.0 instruction set. If using a later revision, e.g.</source>
          <target state="translated">このオプションは、ベースのARMv8.0命令セット用にコンパイルする場合にのみ適用されます。後のリビジョンを使用している場合、例えば</target>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="translated">このオプションはARCv2コアでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="bb2b96b2a317107a5bbb2f1d27d819613a30b1f8" translate="yes" xml:space="preserve">
          <source>This option is only available if GCC was configured with analyzer support enabled.</source>
          <target state="translated">このオプションは、GCCがアナライザのサポートを有効にして構成されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="translated">このオプションは、C++コードをコンパイルするときにのみ使用できます。このオプションをオンにします (</target>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="translated">このオプションは、GCCを開発する際にのみ有用であることを意図しています。</target>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="translated">このオプションはGCCのデバッグにのみ有効です。CPPから使用する場合や</target>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="translated">このオプションはアセンブラとリンカに渡され、最終的なリンクまではできない特定の最適化をリンカが実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="translated">このオプションは、MIPS Release 6 以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="translated">アセンブラとリンカがサポートしている場合、このオプションは最適化されたコンパイルを行うためのデフォルトです。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="translated">このオプションは、コンパイラーによって内部的に使用され、アーキテクチャー &lt;code&gt;avr2&lt;/code&gt; および &lt;code&gt;avr25&lt;/code&gt; のマルチライブラリーを選択およびビルドします。これらのアーキテクチャは、 &lt;code&gt;SPH&lt;/code&gt; があるデバイスとないデバイスを混在させます。以外の設定</target>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="translated">このオプションは、マルチライブラリを選択するために内部的に使用されます。これは最適化オプションではないため、手動で設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="translated">このオプションは、カバレッジ解析のためにインスツルメンテーションされたコードをコンパイルしてリンクするために使用されます。このオプションは</target>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="translated">このオプションは、x86コード生成機能を細かく制御するために使用されます。 &lt;var&gt;feature-list&lt;/var&gt; は、 &lt;var&gt;feature&lt;/var&gt; 名のコンマ区切りリストです。こちらもご覧ください</target>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="translated">このオプションは、プロファイルフィードバックを提供しない限り有効ではありません（</target>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="translated">このオプションは、シンボリックデバッグを不可能にします。</target>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="translated">このオプションは、生成されたコードを IEEE 準拠としてマークします。このオプションは</target>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="translated">このオプションは、より良いコードを生成したり、より悪いコードを生成したりする可能性があり、結果はソースコード内のループの構造に大きく依存します。</target>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="translated">このオプションは、VR4130 用に最適化する場合にのみ効果があります。通常はコードを高速化しますが、コードを大きくすることを犠牲にしています。デフォルトでは、最適化レベルで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="translated">このオプションはアセンブラへのリクエストを渡して、指定されたシリコンエラッタの修正を有効にするようにします。</target>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="translated">このオプションは、シリコンエラッタの適用が必要な場合に警告メッセージを有効にするようにアセンブラに要求を渡します。</target>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="translated">このオプションは、（68881の）浮動レジスターが &lt;code&gt;double&lt;/code&gt; の本来の精度よりも高い精度を維持する68000などのマシンでの望ましくない過剰な精度を防ぎます。x86アーキテクチャについても同様です。ほとんどのプログラムでは、過剰な精度は良い結果をもたらすだけですが、一部のプログラムはIEEE浮動小数点の正確な定義に依存しています。使用する</target>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="translated">このオプションは、コンパイルされたファイルごとに異なる必要がある特定のシンボル名を生成する際に乱数の代わりにGCCが使用するシードを提供します。また、カバレッジデータファイルやそれを生成するオブジェクトファイルに一意のスタンプを配置するためにも使用されます。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="5d13842ae6ab4ca478a1a5e72b6a9207042790a6" translate="yes" xml:space="preserve">
          <source>This option provides additional information when printing control-flow paths associated with a diagnostic.</source>
          <target state="translated">このオプションは、診断に関連付けられた制御フローパスを印刷する際の追加情報を提供します。</target>
        </trans-unit>
        <trans-unit id="4fc311cf74252b7ed7aa80360e3b9606e9388cce" translate="yes" xml:space="preserve">
          <source>This option requires Newlib Nano IO, so GCC must be configured with &amp;lsquo;</source>
          <target state="translated">このオプションにはNewlibNano IOが必要なため、GCCは 'で構成する必要があります</target>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="translated">このオプションを使用するとコードの効率が悪くなりますが、アセンブラの出力を変更するような奇妙なハックは、このオプションを使用しない場合に実行される最適化によって混乱する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="translated">このオプションは、標準のリンク時オプティマイザを実行します。ソースコードで呼び出されると、GIMPLE（GCCの内部表現の1つ）を生成し、オブジェクトファイルの特別なELFセクションに書き込みます。オブジェクトファイルがリンクされると、すべての関数本体がこれらのELFセクションから読み取られ、同じ変換単位の一部であるかのようにインスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="translated">このオプションは、揮発性ビットフィールド（または他の構造体フィールドへのアクセス（ただし、コンパイラーは通常、これらのタイプを尊重します））がフィールドのタイプの幅の単一アクセスを使用し、可能な場合は自然な配置に揃えられる場合に使用します。たとえば、メモリマップされたペリフェラルレジスタを備えたターゲットでは、このようなすべてのアクセスを16ビット幅にする必要があります。このフラグを使用すると、すべてのペリフェラルビットフィールドを &lt;code&gt;unsigned short&lt;/code&gt; （これらのターゲットではshortが16ビットであると想定）として宣言して、GCCがおそらくより効率的な32ビットアクセスの代わりに16ビットアクセスを使用するように強制できます。</target>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="translated">このオプションは、デバッガへの型情報の損失の可能性がありますが、デバッグ情報のサイズを大幅に削減します。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">このオプションは、GP相対アドレス指定を介してアクセスできる追加のセクション名を指定します。これは、変数宣言の &lt;code&gt;section&lt;/code&gt; 属性（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）およびカスタムリンカースクリプトと組み合わせて使用​​すると最も役立ちます。 &lt;var&gt;regexp&lt;/var&gt; POSIX拡張正規表現です。</target>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">このオプションは、 &lt;code&gt;r0&lt;/code&gt; からの16ビットのオフセットを介してアクセスできるセクションの名前を指定します。つまり、32ビットアドレス空間の下位32Kまたは上位32Kです。これは、変数宣言の &lt;code&gt;section&lt;/code&gt; 属性（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）およびカスタムリンカースクリプトと組み合わせて使用​​すると最も役立ちます。 &lt;var&gt;regexp&lt;/var&gt; POSIX拡張正規表現です。</target>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="translated">このオプションは、コンソールアプリケーションに必要なPEヘッダサブシステムタイプを設定するようリンカに指示することで、コンソールアプリケーションを生成することを指定します。このオプションは Cygwin と MinGW ターゲットで利用可能で、これらのターゲットではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="translated">このオプションは、リンクされているビルド出力ファイルをロードする &lt;var&gt;executable&lt;/var&gt; を指定します。詳細については、man ld（1）を参照してください。</target>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="translated">このオプションは、LTO オブジェクトファイルに書き込まれる中間言語に使用される圧縮のレベルを指定します。</target>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="translated">このオプションは、GCCがコードのパフォーマンスを調整する必要があるターゲットARMプロセッサーの名前を指定します。一部のARM実装では、このオプションを使用することでパフォーマンスが向上する場合があります。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="translated">このオプションは、コンパイラ自体の実行ファイル、ライブラリ、インクルードファイル、データファイルの場所を指定します。</target>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="translated">このオプションはデバッグ情報のサイズを大幅に縮小しますが、デバッガの型情報の損失が大きくなる可能性があります。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="translated">このオプションは、v850アーキテクチャのv850e、v850e1、v850e2、v850e2v3、およびv850e3v5フレーバーの &lt;code&gt;CALLT&lt;/code&gt; 命令の生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="translated">このオプションは、これらのラベルの印刷を抑制します（上記の例では、垂直バーと「char *」および「long int」テキスト）。</target>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="translated">このオプションは、共通ブロック(Fortranなど)で宣言された変数が、後に長い末尾の配列でオーバーライドされる可能性があることをコンパイラに伝えます。これにより、配列の境界を知ることに依存する最適化を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="translated">このオプションは、ループオプティマイザが言語制約を使用してループの反復回数の境界を導出するように指示します。これは、ループコードが符号付き整数のオーバーフローやアウトオブバウンドの配列アクセスなどの未定義の動作を起こさないことを前提としています。ループの繰り返し回数の境界は、ループの展開や剥離、ループ終了テストの最適化の指針として使用されます。このオプションはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="translated">一部のプログラムはデータセクションに移動する変数に明示的に依存しているため、このオプションはこの動作をオフにします。たとえば、結果の実行可能ファイルがそのセクションの先頭を見つけたり、それに基づいて仮定を行ったりすることができます。</target>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="translated">このオプションは、ソースでの &lt;code&gt;alloca&lt;/code&gt; のすべての使用について警告します。</target>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="translated">このオプションは、値がゼロの整数引数、またはその値を最大 &lt;var&gt;byte-size&lt;/var&gt; 制限する制御述語によって制限されていない整数引数で &lt;code&gt;alloca&lt;/code&gt; を呼び出すときに警告します。また、バインドされた値が不明な &lt;code&gt;alloca&lt;/code&gt; の呼び出しについても警告します。非整数型の引数は、期待される範囲に制約されているように見えても、無制限と見なされます。</target>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="translated">このオプションは、GCC configure時にアセンブラがそのようなディレクティブをサポートしていることが判明した場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="translated">このオプションは、GCC configure時にアセンブラがこれらをサポートしていることが判明した場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="translated">このオプションは、DWARF デバッグ出力でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="translated">cris-axis-elf で認識されるこのオプションは、シミュレータライブラリからの入出力関数とのリンクを手配します。コード、初期化データ、ゼロ初期化データを連続して配置します。</target>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="translated">このパラメータは、互換性があっても複数のアトミックモデルが混在して使用されることを防ぎ、指定されたモデルのアトミックシーケンスのみをコンパイラに生成させます。</target>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="translated">このパラメーターは、スレッド制御ブロック構造内の変数のオフセットをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="translated">このパスは初期化ループを分散し、memset zeroへの呼び出しを生成します。例えば、ループ</target>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="translated">このパスは、レジスタの割り当てが完了する前に比較演算を明示的に表現できない特定のターゲットにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">このプラグマを使用すると、ユーザーは、各可視性属性を指定する必要なく、複数の宣言の可視性を設定できます（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">このプラグマを使用すると、ソースファイルで後で定義される関数のグローバル最適化オプションを設定できます。 1つ以上の文字列を指定できます。この時点以降に定義された各関数は、各 &lt;var&gt;string&lt;/var&gt; 引数に対して1つの &lt;code&gt;optimize(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性で宣言されているかのように扱われます。プラグマの文字列を囲む括弧はオプションです。 &lt;code&gt;optimize&lt;/code&gt; 属性と属性構文の詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">このプラグマを使用すると、ソースファイルで後で定義される関数のターゲット固有のオプションを設定できます。1つ以上の文字列を指定できます。この時点以降に定義された各関数は、各 &lt;var&gt;string&lt;/var&gt; 引数に対して1つの &lt;code&gt;target(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性で宣言されているかのように扱われます。プラグマの文字列を囲む括弧はオプションです。 &lt;code&gt;target&lt;/code&gt; 属性と属性構文の詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="translated">このプラグマと &lt;code&gt;asm&lt;/code&gt; ラベル拡張は、複雑な方法で相互作用します。以下に、注意する必要があるいくつかのケースを示します。</target>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="translated">このプラグマは、 &lt;code&gt;.fini&lt;/code&gt; セクションへの呼び出しを追加することにより、リストされた各 &lt;var&gt;function&lt;/var&gt; がメインの後で、または共有モジュールのアンロード中に呼び出されるようにします。</target>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="translated">このプラグマにより、初期化中（ &lt;code&gt;main&lt;/code&gt; の前）または共有モジュールのロード中に、 &lt;code&gt;.init&lt;/code&gt; セクションに呼び出しを追加することにより、リストされた各 &lt;var&gt;function&lt;/var&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="translated">このプラグマは、現在の &lt;code&gt;#pragma GCC target&lt;/code&gt; と &lt;code&gt;#pragma GCC optimize&lt;/code&gt; をクリアして、コマンドラインで指定されたデフォルトのスイッチを使用します。</target>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="translated">このプラグマは宣言する &lt;var&gt;symbol1&lt;/var&gt; 弱い別名であることを &lt;var&gt;symbol2&lt;/var&gt; 。現在の翻訳単位で &lt;var&gt;symbol2&lt;/var&gt; が定義されていない場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="translated">このプラグマは、宣言が同じ名前の属性を持っているかのように、 &lt;var&gt;symbol&lt;/var&gt; を弱いものとして宣言します。プラグマは、 &lt;var&gt;symbol&lt;/var&gt; の宣言の前または後に表示できます。 &lt;var&gt;symbol&lt;/var&gt; がまったく定義されていないことはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="translated">このプラグマは、変数が未使用になる可能性があることを宣言します。GCCは、リストされた変数に対して警告を生成しません。効果は、このプラグマが変数のスコープ内のどこにでも出現する可能性があることを除いて、 &lt;code&gt;unused&lt;/code&gt; れていない属性の効果と同様です。</target>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="translated">このプラグマは、C関数 &lt;var&gt;oldname&lt;/var&gt; にアセンブリシンボル &lt;var&gt;newname&lt;/var&gt; を与えます。このプラグマが使用可能な場合、プリプロセッサマクロ &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; が定義されています（現在すべてのプラットフォーム上）。</target>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="translated">このプラグマは受け入れられていますが、効果はありません。</target>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="translated">このプラグマは実装されていませんが、以下の場合を除き、デフォルトは「オフ」です。</target>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="translated">このプラグマは実装されていません。式は現在のところ</target>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="translated">このプラグマは、 &lt;var&gt;macro_name&lt;/var&gt; という名前のマクロの値を、このマクロのスタックの最上位に保存します。</target>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">このプラグマは、構造体のフィールドの配置を設定します。 &lt;var&gt;alignment&lt;/var&gt; の値は、m68k整列をエミュレートするための &lt;code&gt;mac68k&lt;/code&gt; 、またはPowerPC整列をエミュレートするための &lt;code&gt;power&lt;/code&gt; です。このプラグマを使用すると、適切にネストされます。以前の設定に &lt;code&gt;reset&lt;/code&gt; は、 &lt;var&gt;alignment&lt;/var&gt; リセットを使用します。</target>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="translated">このプラグマは、 &lt;var&gt;macro_name&lt;/var&gt; という名前のマクロの値を、このマクロのスタックの一番上の値に設定します。 &lt;var&gt;macro_name&lt;/var&gt; のスタックが空の場合、マクロの値は変更されません。</target>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="translated">このプラグマは、外部リンケージのある宣言にのみ暗黙的に適用されます。 &lt;code&gt;asm&lt;/code&gt; ラベル機能は、この制限はありません。</target>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="translated">この接頭辞は、次のようなファイルを見つけるためにも使われます。</target>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="translated">この問題は、例えば、このパターンを再帰的に使用する場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="translated">この問題はカーネルストアにのみ影響し、システムによってはカーネルロードに影響します。例として、投機的に実行されたストアは、ストア自体が後で中止された場合でも、ターゲットメモリをキャッシュにロードし、キャッシュラインをダーティとしてマークします。「ダーティ」ラインがフラッシュされる前にDMA操作がメモリの同じ領域に書き込む場合、キャッシュされたデータがDMAされたデータを上書きします。他の潜在的な問題を含む完全な説明については、R10Kプロセッサのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">この修飾子は、 &lt;code&gt;asm&lt;/code&gt; ステートメントが &lt;var&gt;GotoLabels&lt;/var&gt; にリストされているラベルの1つにジャンプする可能性があることをコンパイラーに通知します。&lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabelsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="translated">ISO Cのこの制限により、プログラマは &lt;code&gt;uid_t&lt;/code&gt; 型が &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、または &lt;code&gt;long&lt;/code&gt; のいずれであるかを知らないため、従来のCコンパイラに移植可能なコードを書くことが難しくなります。したがって、これらのGNU Cのようなケースでは、プロトタイプが後の古いスタイルの定義をオーバーライドできるようにします。より正確には、GNU Cでは、プロトタイプの前の型が昇格前の後者の型と同じである場合、関数のプロトタイプ引数の型は、後の古いスタイルの定義で指定された引数の型をオーバーライドします。したがって、GNU Cでは、上記の例は次と同等です。</target>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="translated">このサンプルでは、データのアセンブラ名を指定する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="translated">これは、名前が「</target>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="translated">これは、サフィックスが既知の &lt;var&gt;language&lt;/var&gt; エイリアスであることを示しています。これは、</target>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="translated">このセクションでは、プロトタイプを宣言したりマクロ定義を提供したりするために特別なヘッダーファイルを含める必要のない PowerPC 組み込み関数について説明します。以下のセクションでは、その他のPowerPC組み込み関数について説明します。</target>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="translated">ここでは、特定のFR-V命令に名前を付けない組み込み関数について説明します。</target>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="translated">このセクションでは、コンパイラーのテストやコンパイラーのバグやコンパイル時のパフォーマンスの問題の調査をサポートするオプションなど、主にGCC開発者が関心を持つコマンドラインオプションについて説明します。これには、コンパイルのさまざまな時点でデバッグダンプを生成するオプションが含まれます。メモリ使用量や実行時間などの統計を出力します。ライブラリを検索する場所など、GCCの構成に関する情報を出力します。通常のコンパイルおよびリンクタスクでは、これらのオプションを使用する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="translated">このセクションでは、GCCのユーザーに影響を与える既知の問題について説明します。これらのほとんどは、それ自体がGCCバグではありません。もしそうであれば、私たちはそれらを修正します。しかし、ユーザーの結果はバグの結果のようになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="translated">この節では、GCC の動作に影響を与えるいくつかの環境変数について説明します。いくつかの環境変数は、様々な種類のファイルを検索する際に使用するディレクトリや接頭辞を指定することで動作します。また、コンパイル環境の他の側面を指定するために使用されるものもあります。</target>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="translated">この節では、C++プログラムにのみ意味のあるコマンドラインオプションについて説明します。また、プログラムの言語に関係なく、GNUコンパイラのオプションのほとんどを使うことができます。例えば、ファイル</target>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="translated">この節では、Objective-C と Objective-C++プログラムでのみ意味を持つコマンドラインオプションについて説明します。また、言語に依存しないGNUコンパイラオプションのほとんどを使うことができます。例えば、以下のようなファイルをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="translated">このセクションでは、C言語で &lt;code&gt;__attribute__&lt;/code&gt; を使用できる構文と、属性指定子がバインドする構成について説明します。C ++とObjective-Cでは一部の詳細が異なる場合があります。属性の文法が不完全であるため、ここで説明する一部の形式は、すべての場合に正常に解析されるとは限りません。</target>
        </trans-unit>
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="translated">このセクションでは、Objective-Cを使用するためにめったに必要とされないメソッドタイプのエンコーディングについて説明します。あなたは最初の読書でそれをスキップする必要があります。ランタイムは、メソッドで機能し、パラメーターのリストをウォークスルーして解釈できる関数を提供します。これらの関数はパブリック「API」の一部であり、ユーザーコードからのメソッドシグネチャと対話するための推奨される方法です。</target>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="translated">このセクションは意図的に空になっています。</target>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="translated">このセクションはGNU Objective-Cランタイムに特化しています。他のランタイムを使用している場合は、省略しても構いません。</target>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="translated">ここでは、よくリクエストされる変更点をリストアップしていますが、GCCはない方がいいと思っているので、作っていません。</target>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="translated">このセクションでは、GCCを他のコンパイラと併用したり、特定のシステム上でアセンブラ、リンカ、ライブラリ、デバッガを使用したりする際に遭遇する様々な問題を列挙しています。</target>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="translated">このセクションでは、メモリにアクセスするための読み取りおよび書き込み命令に関連する組み込み関数について説明します。これらの関数は、上記のFujitsuのマニュアルで説明されているように、I / Oロードをフラッシュするための &lt;code&gt;membar&lt;/code&gt; 命令を生成し、必要に応じて保存します。</target>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="translated">コンパイルマシンのプロセッサの種類を決定して、コンパイル時にコードを生成するCPUを選択します。使用方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">現在スタック上に保存されているステータス・レジスタのコピーに指定されたビットを設定します。これは割り込みハンドラ内でのみ動作し、ステータスレジスタの変更はハンドラが戻ってきてから有効になります。</target>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="translated">この設定は、既知で一定のストライドにのみ有効です。</target>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="translated">この設定は、ハードウェアプリフェッチャがあるプロセッサで、ハードウェアプリフェッチャとソフトウェアプリフェッチャの間に競合がある場合に有用です。ハードウェアプリフェッチャが扱える最大のストライドを持っている場合は、 ソフトウェアプリフェッチャの使用を改善するためにここで使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="translated">このサイズは、決定のインライン化にも使用されます。あなたが使用している場合は &lt;code&gt;asm inline&lt;/code&gt; だけではなく &lt;code&gt;asm&lt;/code&gt; 、その後、インライン化の目的のためにASMの大きさは、GCCは、それがあると考えてどのように多くの命令を無視し、最小サイズとしています。</target>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="translated">これは、アセンブラコードで関数 &lt;code&gt;func&lt;/code&gt; に使用される名前が &lt;code&gt;MYFUNC&lt;/code&gt; であることを指定します。</target>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="translated">これは、アセンブラー・コードの変数 &lt;code&gt;foo&lt;/code&gt; に使用される名前が '</target>
        </trans-unit>
        <trans-unit id="a3c554fdfb8d610626cac613dfe8c644012d6c11" translate="yes" xml:space="preserve">
          <source>This specifies the hard limit for frame sizes, in bytes. Currently, the value that can be specified should be less than or equal to &amp;lsquo;</source>
          <target state="translated">これは、フレームサイズのハード制限をバイト単位で指定します。現在、指定できる値は '以下である必要があります</target>
        </trans-unit>
        <trans-unit id="157c3a5d700741dba8b972ce366b3872db0f98d9" translate="yes" xml:space="preserve">
          <source>This specifies the minimum version of the kernel that will run the compiled program. GCC uses this version to determine which instructions to use, what kernel helpers to allow, etc. Currently, &lt;var&gt;version&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">これは、コンパイルされたプログラムを実行するカーネルの最小バージョンを指定します。GCCはこのバージョンを使用して、使用する命令、許可するカーネルヘルパーなどを決定します。現在、 &lt;var&gt;version&lt;/var&gt; は次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="translated">これはターゲットとなるARMアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードを生成する際にどのような命令を出すことができるかを決定します。このオプションは</target>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="translated">ターゲットARMプロセッサの名前を指定します。GCCはこの名前を使用して、ターゲットARMアーキテクチャの名前を導出します。</target>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">これは、ターゲットNios IIアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">ターゲットアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="translated">これは、ターゲットで使用可能な浮動小数点ハードウェア（またはハードウェアエミュレーション）を指定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="translated">このスイッチは、コンパイラを呼び出すために使用されたコマンド・ラインを作成中のオブジェクト・ファイルに記録します。このスイッチは一部のターゲットにのみ実装されており、記録の正確な形式はターゲットとバイナリファイルの形式に依存しますが、通常はASCIIテキストを含むセクションの形をとります。このスイッチは</target>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="translated">このスイッチにより、コード生成に影響を与える可能性のあるコンパイラの呼び出しに使用されるコマンドライン・オプションが、DWARF デバッグ情報の DW_AT_producer 属性に追加されます。オプションはスペースで連結されており、お互いのオプションとコンパイラのバージョンを区切っています。デフォルトでは有効になっています。これはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="translated">このスイッチは、ユーザーがインライン関数やメソッドへのポインタを比較しようとしないことを宣言します。</target>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="translated">このスイッチは、生成されたコードからの冗長な &lt;code&gt;membar&lt;/code&gt; 命令の自動削除を無効にします。</target>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="translated">このスイッチは、ISEL命令の生成を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="translated">このスイッチは主にコンパイラをデバッグするためのもので、将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="translated">このスイッチは、コンパイラが生成したコードから冗長な &lt;code&gt;membar&lt;/code&gt; 命令を削除します。デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="translated">この構文は C++2011 標準で定義されていますが、2011 年以前から G++や他のコンパイラでサポートされています。</target>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">これは、関数が &lt;code&gt;malloc&lt;/code&gt; に似ていること、つまり、関数から返されたポインター &lt;var&gt;P&lt;/var&gt; が、関数が戻ったときに有効な他のポインターをエイリアスできず、さらに、 &lt;var&gt;P&lt;/var&gt; によってアドレス指定されたストレージで有効なオブジェクトへのポインターが発生しないことをコンパイラーに伝えます。</target>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="translated">これは、名前付き仕様文字列を作成、オーバーライド、または削除するようコンパイラーに指示します。このディレクティブの後の次のディレクティブまたは空白行までのすべての行は、スペック文字列のテキストと見なされます。これが空の文字列になる場合、スペックは削除されます。（または、仕様が存在しない場合は何も起こりません。）それ以外の場合、仕様が現在存在しない場合は、新しい仕様が作成されます。仕様が存在する場合、テキストの最初の文字が 'でない限り、その内容はこのディレクティブのテキストで上書きされます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
