<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="f6ee8357cf66d468fce21ce87f6e1455c61c9d71" translate="yes" xml:space="preserve">
          <source>8.2. +load: Executing Code before main</source>
          <target state="translated">8.2.+ロードします。メインの前にコードを実行する</target>
        </trans-unit>
        <trans-unit id="0e37b3bc6a72bc7a45aefe525b01b3bcbc69dc62" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1 +loadでできること、できないこと</target>
        </trans-unit>
        <trans-unit id="7514eae887431bc2b23c9f91ceeb2b8927f90957" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in &lt;code&gt;+load&lt;/code&gt;</source>
          <target state="translated">8.2.1 &lt;code&gt;+load&lt;/code&gt; でできることとできないこと</target>
        </trans-unit>
        <trans-unit id="8bc74bfbf57cd10928d01b916e6fa71d6d37346e" translate="yes" xml:space="preserve">
          <source>8.2.1. What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1.ロードでできることとできないこと</target>
        </trans-unit>
        <trans-unit id="ac17a28fe0400efdbbf27dc0a3aa19d768882f50" translate="yes" xml:space="preserve">
          <source>8.3 Type Encoding</source>
          <target state="translated">8.3 タイプの符号化</target>
        </trans-unit>
        <trans-unit id="0b5a28a401e5caa1731675ca56a84d444c15fa81" translate="yes" xml:space="preserve">
          <source>8.3. Type Encoding</source>
          <target state="translated">8.3.型の符号化</target>
        </trans-unit>
        <trans-unit id="f6228ff4737811227a708bc22b6ff3a77b75cceb" translate="yes" xml:space="preserve">
          <source>8.3.1 Legacy Type Encoding</source>
          <target state="translated">8.3.1 レガシー型エンコーディング</target>
        </trans-unit>
        <trans-unit id="7bec6b4bee7afdb83a43730a9fe5c4d6d085e864" translate="yes" xml:space="preserve">
          <source>8.3.1. Legacy Type Encoding</source>
          <target state="translated">8.3.1.レガシー型符号化</target>
        </trans-unit>
        <trans-unit id="5527244afdb6dfb3dca3ad889987c2fef987074e" translate="yes" xml:space="preserve">
          <source>8.3.2 &lt;code&gt;@encode&lt;/code&gt;</source>
          <target state="translated">8.3.2 &lt;code&gt;@encode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="978fa94702c6bb2aa016de617938fd819d570db4" translate="yes" xml:space="preserve">
          <source>8.3.2 @encode</source>
          <target state="translated">8.3.2 @encode</target>
        </trans-unit>
        <trans-unit id="4493f310bc1651626e01d4c07ee677385159442c" translate="yes" xml:space="preserve">
          <source>8.3.2. @encode</source>
          <target state="translated">8.3.2.エンコード</target>
        </trans-unit>
        <trans-unit id="e76f8c08ebb07739970dc34b59461ba675ae7b31" translate="yes" xml:space="preserve">
          <source>8.3.3 Method Signatures</source>
          <target state="translated">8.3.3 メソッドシグネチャ</target>
        </trans-unit>
        <trans-unit id="0cd2b9090f85dc474192078b9cdd2977a7b93ce8" translate="yes" xml:space="preserve">
          <source>8.3.3. Method Signatures</source>
          <target state="translated">8.3.3.メソッドのシグネチャ</target>
        </trans-unit>
        <trans-unit id="8dc0bdb621513ef296dfe1ccb8a8e69178e55c00" translate="yes" xml:space="preserve">
          <source>8.4 Garbage Collection</source>
          <target state="translated">8.4 ゴミの収集</target>
        </trans-unit>
        <trans-unit id="f07f1c7fc14cbe1fbcf43d8205938600aba5fb3a" translate="yes" xml:space="preserve">
          <source>8.4. Garbage Collection</source>
          <target state="translated">8.4.ゴミの収集</target>
        </trans-unit>
        <trans-unit id="7a1c9992cbe3a8eb5bac4598d41c0f55497fcfd0" translate="yes" xml:space="preserve">
          <source>8.5 Constant String Objects</source>
          <target state="translated">8.5 定数文字列オブジェクト</target>
        </trans-unit>
        <trans-unit id="4a2eeb0e04646c0d1d5dde7596bb4e3ab441cf85" translate="yes" xml:space="preserve">
          <source>8.5. Constant String Objects</source>
          <target state="translated">8.5.定数文字列オブジェクト</target>
        </trans-unit>
        <trans-unit id="1ad03b99d44944113a02e8b2d43422e1fb50690e" translate="yes" xml:space="preserve">
          <source>8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</source>
          <target state="translated">8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16a6371cd4eb99b88acbb876c48214d1528996b9" translate="yes" xml:space="preserve">
          <source>8.6 compatibility_alias</source>
          <target state="translated">8.6 互換性</target>
        </trans-unit>
        <trans-unit id="68169a32cc1b2c0d8e0fdd12ac28ee8a4f88ccd1" translate="yes" xml:space="preserve">
          <source>8.6. compatibility_alias</source>
          <target state="translated">8.6.互換性</target>
        </trans-unit>
        <trans-unit id="477e0b2d2877013fc309d42abd04b7a7fac95b0e" translate="yes" xml:space="preserve">
          <source>8.7 Exceptions</source>
          <target state="translated">8.7 例外</target>
        </trans-unit>
        <trans-unit id="16af8614813519947458cd70b76429228a166bf8" translate="yes" xml:space="preserve">
          <source>8.7. Exceptions</source>
          <target state="translated">8.7.例外</target>
        </trans-unit>
        <trans-unit id="74543d3119c6680f587a9317c42b3e80f7812525" translate="yes" xml:space="preserve">
          <source>8.8 Synchronization</source>
          <target state="translated">8.8 同期化</target>
        </trans-unit>
        <trans-unit id="083f9b1455cca391952297e65a5f3c8e7fb0c091" translate="yes" xml:space="preserve">
          <source>8.8. Synchronization</source>
          <target state="translated">8.8.同期化</target>
        </trans-unit>
        <trans-unit id="7338c2122f2c6512086917a88263a1ffa319037d" translate="yes" xml:space="preserve">
          <source>8.9 Fast Enumeration</source>
          <target state="translated">8.9 高速列挙</target>
        </trans-unit>
        <trans-unit id="ec7154738dfa0ae117df4872a446a28e2a0711e7" translate="yes" xml:space="preserve">
          <source>8.9. Fast Enumeration</source>
          <target state="translated">8.9.高速な列挙</target>
        </trans-unit>
        <trans-unit id="c5c48c9ddc1c6eec5370a9f3cc1d2da53b4277bc" translate="yes" xml:space="preserve">
          <source>8.9.1 Using Fast Enumeration</source>
          <target state="translated">8.9.1 高速列挙の使用</target>
        </trans-unit>
        <trans-unit id="6ad2c7a48f39c65d867329ec2c7335528dcac484" translate="yes" xml:space="preserve">
          <source>8.9.1. Using Fast Enumeration</source>
          <target state="translated">8.9.1.高速列挙の使用</target>
        </trans-unit>
        <trans-unit id="d4e4b02de8979958bbc292a9013946837f1fa2de" translate="yes" xml:space="preserve">
          <source>8.9.2 C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2 C99-Like 高速列挙構文</target>
        </trans-unit>
        <trans-unit id="c0c8d7e4c548cb334b0077b49fb8d7954fa1bc7a" translate="yes" xml:space="preserve">
          <source>8.9.2. C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2.C99に似た高速列挙構文</target>
        </trans-unit>
        <trans-unit id="fc941982a158e238821dd94fbed3bb5cab331767" translate="yes" xml:space="preserve">
          <source>8.9.3 Fast Enumeration Details</source>
          <target state="translated">8.9.3 高速列挙の詳細</target>
        </trans-unit>
        <trans-unit id="1e69e987b4483c072c99556446bfbd580c89a6c7" translate="yes" xml:space="preserve">
          <source>8.9.3. Fast Enumeration Details</source>
          <target state="translated">8.9.3.高速列挙の詳細</target>
        </trans-unit>
        <trans-unit id="66afcdf52d12c5936c393d8a7d4415ca40641c8c" translate="yes" xml:space="preserve">
          <source>8.9.4 Fast Enumeration Protocol</source>
          <target state="translated">8.9.4 高速列挙プロトコル</target>
        </trans-unit>
        <trans-unit id="af86351ac19c6a92b0fadb75de17d30680748abf" translate="yes" xml:space="preserve">
          <source>8.9.4. Fast Enumeration Protocol</source>
          <target state="translated">8.9.4.高速列挙プロトコル</target>
        </trans-unit>
        <trans-unit id="2a24cd506294a07c6a0446f8badafaf3201f2507" translate="yes" xml:space="preserve">
          <source>9 Binary Compatibility</source>
          <target state="translated">9 バイナリ互換性</target>
        </trans-unit>
        <trans-unit id="aaf34f43b56348453c9670867bbe710bc4cff1f1" translate="yes" xml:space="preserve">
          <source>9-bit signed integer constant for load and store postincrements</source>
          <target state="translated">ロードおよびストアのポストインクリメント用の9ビット符号付き整数定数</target>
        </trans-unit>
        <trans-unit id="f5866ff425b2380665d4757e884a24f7c0c34afd" translate="yes" xml:space="preserve">
          <source>9. Binary Compatibility</source>
          <target state="translated">9.9.バイナリ互換性</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="0e96f6929feaa8c7f7735055f893a7b75a845c22" translate="yes" xml:space="preserve">
          <source>: even though it may help make the global offset table smaller, it trades 1 instruction for 4. With</source>
          <target state="translated">：グローバルオフセットテーブルを小さくするのに役立つ場合がありますが、1命令を4と交換します。</target>
        </trans-unit>
        <trans-unit id="63347315fe8e655bf95e9a504d6fcbb0f9ecd9f0" translate="yes" xml:space="preserve">
          <source>: this header declares a public runtime API threading layer that is only provided by the GNU Objective-C runtime. It declares functions such as &lt;code&gt;objc_mutex_lock()&lt;/code&gt;, which provide a platform-independent set of threading functions.</source>
          <target state="translated">：このヘッダーは、GNU Objective-Cランタイムによってのみ提供されるパブリックランタイムAPIスレッディングレイヤーを宣言します。プラットフォームに依存しない一連のスレッド化関数を提供する &lt;code&gt;objc_mutex_lock()&lt;/code&gt; などの関数を宣言します。</target>
        </trans-unit>
        <trans-unit id="30dd56b7640731d14fa9ecac2bbbbb504e1a5176" translate="yes" xml:space="preserve">
          <source>: this header declares most of the public runtime API functions allowing you to inspect and manipulate the Objective-C runtime data structures. These functions are fairly standardized across Objective-C runtimes and are almost identical to the Apple/NeXT Objective-C runtime ones. It does not declare functions in some specialized areas (constructing and forwarding message invocations, threading) which are in the other headers below. You have to include</source>
          <target state="translated">：このヘッダーは、ほとんどのパブリックランタイムAPI関数を宣言して、Objective-Cランタイムデータ構造を検査および操作できるようにします。これらの関数はObjective-Cランタイム全体でかなり標準化されており、Apple / NeXT Objective-Cランタイムのものとほとんど同じです。以下の他のヘッダーにある一部の特殊な領域（メッセージ呼び出しの作成と転送、スレッド化）で関数を宣言していません。あなたが含める必要があります</target>
        </trans-unit>
        <trans-unit id="26a235338902d41d3db5491024b9576d18742880" translate="yes" xml:space="preserve">
          <source>: this header declares public functions used to construct, deconstruct and forward message invocations. Because messaging is done in quite a different way on different runtimes, functions in this header are specific to the GNU Objective-C runtime implementation.</source>
          <target state="translated">：このヘッダーは、メッセージ呼び出しの作成、分解、転送に使用されるパブリック関数を宣言します。メッセージングは​​ランタイムによってまったく異なる方法で実行されるため、このヘッダーの関数はGNU Objective-Cランタイム実装に固有です。</target>
        </trans-unit>
        <trans-unit id="5a3c29505625144ba68750995731439e9906fdd5" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to Objective-C exceptions. For example functions in this header allow you to throw an Objective-C exception from plain C/C++ code.</source>
          <target state="translated">：このヘッダーは、Objective-Cの例外に関連するいくつかのパブリック関数を宣言します。たとえば、このヘッダーの関数を使用すると、プレーンなC / C ++コードからObjective-C例外をスローできます。</target>
        </trans-unit>
        <trans-unit id="9e5ef08f873716700e594dd3a36d7d64d5272d49" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to the Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; syntax, allowing you to emulate an Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; block in plain C/C++ code.</source>
          <target state="translated">：このヘッダーは、Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; 構文に関連するいくつかのパブリック関数を宣言し、プレーンC / C ++コードでObjective-C &lt;code&gt;@synchronized()&lt;/code&gt; ブロックをエミュレートできるようにします。</target>
        </trans-unit>
        <trans-unit id="7cc9c1a09bf135868f452e4dc5bbf2907bfed13f" translate="yes" xml:space="preserve">
          <source>: this is the basic Objective-C header file, defining the basic Objective-C types such as &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;BOOL&lt;/code&gt;. You have to include this header to do almost anything with Objective-C.</source>
          <target state="translated">：これは基本的なObjective-Cヘッダーファイルで、 &lt;code&gt;id&lt;/code&gt; 、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;BOOL&lt;/code&gt; などの基本的なObjective-Cタイプを定義しています。Objective-Cでほとんどすべてを行うには、このヘッダーを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="e8c89b6d4332bd3369abe0522644501e5013a432" translate="yes" xml:space="preserve">
          <source>; higher levels are not, and must be explicitly requested.</source>
          <target state="translated">; より高いレベルはありません。明示的に要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="a66283a15e09823e79a5c6a663cf680f2ab5e710" translate="yes" xml:space="preserve">
          <source>; however, use of the backchain for debugging purposes usually requires that the whole binary is built with</source>
          <target state="translated">; ただし、デバッグ目的でバックチェーンを使用するには、通常、バイナリ全体が</target>
        </trans-unit>
        <trans-unit id="2e840d8b6d6867941a2eee8b46c7d917829de2b1" translate="yes" xml:space="preserve">
          <source>; it causes the preprocessor to treat comments as tokens in their own right. For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a &amp;lsquo;</source>
          <target state="translated">; これにより、プリプロセッサはコメントをトークンとして扱います。たとえば、指示行となるものの先頭にあるコメントは、その行を通常のソース行に変換する効果があります。これは、行の最初のトークンが 'ではないためです。</target>
        </trans-unit>
        <trans-unit id="fe9de4759d0dc5597c891d37b107703d1930a026" translate="yes" xml:space="preserve">
          <source>; it then defines &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; and does not make assumptions about the meanings of function names from the standard library, with exceptions noted below. To build an OS kernel, you may well still need to make your own arrangements for linking and startup. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">; 次に、 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; を &lt;code&gt;0&lt;/code&gt; に定義し、標準ライブラリの関数名の意味を仮定しません。ただし、以下に示す例外があります。OSカーネルを構築するには、リンクと起動のために独自の準備をする必要があるかもしれません。&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;C方言を制御するオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0bd28d9793fcd7e9f0549371e16a97a1f053629f" translate="yes" xml:space="preserve">
          <source>; see &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">; &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C ++ Dialectを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="50016dac566b707582c4b1fc771e52069b7a937b" translate="yes" xml:space="preserve">
          <source>; the corrections are also applied with</source>
          <target state="translated">; 修正も適用されます</target>
        </trans-unit>
        <trans-unit id="3eb04dcb759dd8c0995915b2a5ccb10d6a327b33" translate="yes" xml:space="preserve">
          <source>; the same rule applies to macros defined this way.</source>
          <target state="translated">; この方法で定義されたマクロにも同じ規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="00b878f7746de72103ac67a35f0e1d78575bcec7" translate="yes" xml:space="preserve">
          <source>; they do not have this problem.</source>
          <target state="translated">; この問題はありません。</target>
        </trans-unit>
        <trans-unit id="39de10441f5a92f5c2ca38349b7c2fdec8841dcf" translate="yes" xml:space="preserve">
          <source>; this option implies</source>
          <target state="translated">; このオプションは、</target>
        </trans-unit>
        <trans-unit id="1989c55c1ff2b01f4215828caa4538ad66beba83" translate="yes" xml:space="preserve">
          <source>; to obtain all the diagnostics required by the standard, you should also specify</source>
          <target state="translated">; 標準で必要なすべての診断を取得するには、次も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a73b42f7298a4e09fb1e0072c5f63bdced6b9b8c" translate="yes" xml:space="preserve">
          <source>; when linking, it links in a special thread helper library</source>
          <target state="translated">; リンクすると、特別なスレッドヘルパーライブラリにリンクします。</target>
        </trans-unit>
        <trans-unit id="06561510744788a1609ec5f60662cc5908d39e15" translate="yes" xml:space="preserve">
          <source>; you should not need to use it for anything else.</source>
          <target state="translated">; 他の目的で使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="431058a2491fcbde34064009eece9653a8f5b829" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Example&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Example&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="01d7c1c3eb993c58806b746668090c8a26bb75db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Limitations and caveats&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;制限と警告&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0424675c89789c8478a359447a9eeb880c777989" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.init]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.init]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3b972f187fc77684d7b4caf8cb567979becf9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.main]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.main]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b883af22766032bc16303da205cb38fbd19479e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.term]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.term]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18fcd33e6f11059c9a572ef77f16711d1475704" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.static]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.static]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fc91ea62596ffaa9b88e5f5653a875441113bac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13e2f1e5179d31ce813b6d9c962af8d8f15a52b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="082e6d5681614613f1cf46008d31795e30341ce2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[class.mem]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[class.mem]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20a71e88049b10a9036fc51e894c28860a33cdaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[dcl.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[dcl.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51818883b235ce777320b575e0bf8025965510ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[intro.execution]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[intro.execution]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a31fbd2e2b9c5c3bb615b7491f612d5a707c3ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[lex.key]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[lex.key]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cc4701ea1dbc7c0ae0a60db0f72537871372ebf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![16,16i]&lt;/code&gt; (alignment depends on the machine)</source>
          <target state="translated">&lt;code&gt;![16,16i]&lt;/code&gt; （配置はマシンによって異なります）</target>
        </trans-unit>
        <trans-unit id="cffc58ac2d212878e6c4d3afeb9026603af158fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma interface&lt;/code&gt; and &lt;code&gt;#pragma implementation&lt;/code&gt; provide the user with a way of explicitly directing the compiler to emit entities with vague linkage (and debugging information) in a particular translation unit.</source>
          <target state="translated">&lt;code&gt;#pragma interface&lt;/code&gt; と &lt;code&gt;#pragma implementation&lt;/code&gt; は、特定の変換単位で曖昧なリンケージ（およびデバッグ情報）を持つエンティティーを出力するようコンパイラーに明示的に指示する方法をユーザーに提供します。</target>
        </trans-unit>
        <trans-unit id="2569b071a9af441d9b6296aa268b56f40df7cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct off&lt;/code&gt; turns off the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct off&lt;/code&gt; は、Microsoftレイアウトをオフにします。</target>
        </trans-unit>
        <trans-unit id="5e363473f488b7983412e972ce0eac0f09b14174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct on&lt;/code&gt; turns on the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct on&lt;/code&gt; は、Microsoftレイアウトをオンにします。</target>
        </trans-unit>
        <trans-unit id="107cfa70f66f6e21716326b44d8c2543bd277a0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; goes back to the default layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; はデフォルトのレイアウトに戻ります。</target>
        </trans-unit>
        <trans-unit id="359f3157fca41c8df8f6c827d78d1920672257ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack()&lt;/code&gt; sets the alignment to the one that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma pack()&lt;/code&gt; は、コンパイルを開始したときに有効だった配置に設定します（コマンドラインオプションも参照）</target>
        </trans-unit>
        <trans-unit id="2da8592b5f1ca4f7c8ec146ce07922d1be68b588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; simply sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; は、単に新しい配置を設定します。</target>
        </trans-unit>
        <trans-unit id="09cd1961f6ec088315967f82b215657a1847a8f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(pop)&lt;/code&gt; restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; does not influence this internal stack; thus it is possible to have &lt;code&gt;#pragma pack(push)&lt;/code&gt; followed by multiple &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; instances and finalized by a single &lt;code&gt;#pragma pack(pop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#pragma pack(pop)&lt;/code&gt; は、配置設定を内部スタックの一番上に保存された設定に戻します（そのスタックエントリを削除します）。 &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; はこの内部スタックに影響を与えないことに注意してください。したがって、 &lt;code&gt;#pragma pack(push)&lt;/code&gt; の後に複数の &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; インスタンスが続き、単一の &lt;code&gt;#pragma pack(pop)&lt;/code&gt; でファイナライズすることが可能です。</target>
        </trans-unit>
        <trans-unit id="c1f4e8456ee450b615ff464f6ff9615991f7f956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; pushes the current alignment setting on an internal stack and then optionally sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; は、現在の配置設定を内部スタックにプッシュし、オプションで新しい配置を設定します。</target>
        </trans-unit>
        <trans-unit id="8d404d78e391f3edc2a1e7fe1018546d3f145abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; sets the storage order of the scalar fields to big-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; は、スカラーフィールドの格納順序をビッグエンディアンに設定します。</target>
        </trans-unit>
        <trans-unit id="791d1af4df580d4926f6784307622e913fe6169f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; goes back to the endianness that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; は、コンパイルの開始時に有効だったエンディアンに戻ります（コマンドラインオプションも参照）</target>
        </trans-unit>
        <trans-unit id="9e92ce5f2b8e8dd2da4f3a23c57c175f27849093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; sets the storage order of the scalar fields to little-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; は、スカラーフィールドの格納順序をリトルエンディアンに設定します。</target>
        </trans-unit>
        <trans-unit id="d7b3947b00665c0273f8ee03de6b46c48b82e923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+load&lt;/code&gt; is to be used only as a last resort. Because it is executed very early, most of the Objective-C runtime machinery will not be ready when &lt;code&gt;+load&lt;/code&gt; is executed; hence &lt;code&gt;+load&lt;/code&gt; works best for executing C code that is independent on the Objective-C runtime.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; は最後の手段としてのみ使用されます。これは非常に早期に実行されるため、 &lt;code&gt;+load&lt;/code&gt; が実行されると、ほとんどのObjective-Cランタイムマシンは準備できません。したがって、 &lt;code&gt;+load&lt;/code&gt; は、Objective-Cランタイムに依存しないCコードの実行に最適です。</target>
        </trans-unit>
        <trans-unit id="2a3b66c50c6331da3456637374283bba0d9341b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-2147483648&lt;/code&gt; is positive.</source>
          <target state="translated">&lt;code&gt;-2147483648&lt;/code&gt; は正です。</target>
        </trans-unit>
        <trans-unit id="ff73f3bc9136cfe683f6e1000d6ea1e5f0b6d324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0xFF&lt;/code&gt; or &lt;code&gt;0xFFFF&lt;/code&gt;, for andsi as a zero-extending move.</source>
          <target state="translated">&lt;code&gt;0xFF&lt;/code&gt; または &lt;code&gt;0xFFFF&lt;/code&gt; は、andsiがゼロ拡張移動として使用されます。</target>
        </trans-unit>
        <trans-unit id="69970b695b65687a239461624104cc1d44b36e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;100&lt;/code&gt;, &lt;code&gt;102&lt;/code&gt;, &lt;code&gt;103&lt;/code&gt;, &lt;code&gt;104&lt;/code&gt;, &lt;code&gt;105&lt;/code&gt;, &lt;code&gt;106&lt;/code&gt;, &lt;code&gt;107&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; 、 &lt;code&gt;102&lt;/code&gt; 、 &lt;code&gt;103&lt;/code&gt; 、 &lt;code&gt;104&lt;/code&gt; 、 &lt;code&gt;105&lt;/code&gt; 、 &lt;code&gt;106&lt;/code&gt; 、 &lt;code&gt;107&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f94cae98ac3d64f04d19f0b2e99e2c0a60564f25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;25&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;31&lt;/code&gt;, &lt;code&gt;35&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;51&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; 、 &lt;code&gt;25&lt;/code&gt; 、 &lt;code&gt;3&lt;/code&gt; 、 &lt;code&gt;31&lt;/code&gt; 、 &lt;code&gt;35&lt;/code&gt; 、 &lt;code&gt;4&lt;/code&gt; 、 &lt;code&gt;5&lt;/code&gt; 、 &lt;code&gt;51&lt;/code&gt; 、 &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bd49a42c06dc5b5614602b595d1eb861097847b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; is evaluated exactly once and the result is used as the collection object to iterate over. This means it is safe to write code such as &lt;code&gt;for (object in [NSDictionary
keyEnumerator]) &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; は1回だけ評価され、結果はコレクションオブジェクトとして使用され、繰り返し処理されます。これは、 &lt;code&gt;for (object in [NSDictionary keyEnumerator]) &amp;hellip;&lt;/code&gt; などのコードを記述しても安全であることを意味します。</target>
        </trans-unit>
        <trans-unit id="3eba358d191709438321ae5dbb3501eb47389e2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; can contain &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; commands, which will abort the iteration or skip to the next loop iteration as expected.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; は、 &lt;code&gt;break&lt;/code&gt; コマンドと &lt;code&gt;continue&lt;/code&gt; コマンドを含めることができます。これにより、反復が中止されるか、次のループ反復にスキップされます。</target>
        </trans-unit>
        <trans-unit id="61531b33eb2db1449ceab15f5f279c4b2f1791b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; must not make any changes to the collection object; if they do, it is a hard error and the fast enumeration terminates by invoking &lt;code&gt;objc_enumerationMutation&lt;/code&gt;, a runtime function that normally aborts the program but which can be customized by Foundation libraries via &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; to do something different, such as raising an exception.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; はコレクションオブジェクトに変更を加えてはなりません。もしそうなら、それはハードエラーであり、高速列挙は &lt;code&gt;objc_enumerationMutation&lt;/code&gt; を呼び出すことで終了します。objc_enumerationMutationは通常プログラムを &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; しますが、例外を発生させるなど、何か別のことをするために objc_set_mutation_handlerを介してFoundationライブラリによってカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="9d58742173ee42448629f6db4422e3203e474e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@encode&lt;/code&gt; does not support type qualifiers other than &lt;code&gt;const&lt;/code&gt;. For example, &lt;code&gt;@encode(const char*)&lt;/code&gt; is valid and is compiled into &lt;code&gt;&quot;r*&quot;&lt;/code&gt;, while &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; is invalid and will cause a compilation error.</source>
          <target state="translated">&lt;code&gt;@encode&lt;/code&gt; は &lt;code&gt;const&lt;/code&gt; 以外の型修飾子をサポートしません。例えば、 &lt;code&gt;@encode(const char*)&lt;/code&gt; 有効であるとにコンパイルされた &lt;code&gt;&quot;r*&quot;&lt;/code&gt; ながら、 &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; 無効であり、コンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="06f7d071955d8af36c31b170590dbc2a8f025b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A&lt;/code&gt; through &lt;code&gt;L&lt;/code&gt; registers.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; から &lt;code&gt;L&lt;/code&gt; レジスタ。</target>
        </trans-unit>
        <trans-unit id="80d0c9344feef2e94b4f1747dfadf5bbe5585ef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CPATH&lt;/code&gt; specifies a list of directories to be searched as if specified with</source>
          <target state="translated">&lt;code&gt;CPATH&lt;/code&gt; は、次のように指定した場合と同様に検索するディレクトリのリストを指定します</target>
        </trans-unit>
        <trans-unit id="789e53d1b037b549885585694fb4b6c06a41dc94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GSWApplication&lt;/code&gt; (the real class) must be an existing class.</source>
          <target state="translated">&lt;code&gt;GSWApplication&lt;/code&gt; （実際のクラス）は既存のクラスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="372485e67dabbb2f6f7563c915c0d05a5bb7796c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NXConstantString&lt;/code&gt; inherits from &lt;code&gt;Object&lt;/code&gt;; user class libraries may choose to inherit the customized constant string class from a different class than &lt;code&gt;Object&lt;/code&gt;. There is no requirement in the methods the constant string class has to implement, but the final ivar layout of the class must be the compatible with the given structure.</source>
          <target state="translated">&lt;code&gt;NXConstantString&lt;/code&gt; は &lt;code&gt;Object&lt;/code&gt; を継承しています。ユーザークラスライブラリは、 &lt;code&gt;Object&lt;/code&gt; とは異なるクラスからカスタマイズされた定数文字列クラスを継承することを選択できます。定数文字列クラスが実装する必要のあるメソッドには要件はありませんが、クラスの最終的なivarレイアウトは、指定された構造と互換性がある必要があります。</target>
        </trans-unit>
        <trans-unit id="b73742c69a964b14887fe5c58b748cbc6ead8dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;V&lt;/code&gt; is a special modifier which prints the name of the full integer register without &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; は、 &lt;code&gt;%&lt;/code&gt; なしで完全な整数レジスタの名前を出力する特別な修飾子です。</target>
        </trans-unit>
        <trans-unit id="e9680743302272f4d21a0ca0fcf6f7d2fc4b4f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WOApplication&lt;/code&gt; (the alias) must not be an existing class;</source>
          <target state="translated">&lt;code&gt;WOApplication&lt;/code&gt; （エイリアス）は既存のクラスであってはなりません。</target>
        </trans-unit>
        <trans-unit id="ee6195175737171e4b0021bc7dc79c772162ab99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; is another name for &lt;code&gt;__func__&lt;/code&gt;, provided for backward compatibility with old versions of GCC.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; は、古いバージョンのGCCとの下位互換性のために提供される &lt;code&gt;__func__&lt;/code&gt; の別名です。</target>
        </trans-unit>
        <trans-unit id="f2c1ea03a8f41c269c203f97859a30953067ac6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__attribute ((const))&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; were mangled as type qualifiers, and &lt;code&gt;decltype&lt;/code&gt; of a plain declaration was folded away.</source>
          <target state="translated">&lt;code&gt;__attribute ((const))&lt;/code&gt; と &lt;code&gt;noreturn&lt;/code&gt; が型修飾子として &lt;code&gt;decltype&lt;/code&gt; され、プレーン宣言のdecltypeが折りたたまれました。</target>
        </trans-unit>
        <trans-unit id="31d52aa69bfef9deeeff9d7920e4c48f0f233481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; can be used to change any bit of the register except the condition codes, which GCC assumes are preserved.</source>
          <target state="translated">&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; を使用して、GCCが保持されていると想定する条件コードを除く、レジスタの任意のビットを変更できます。</target>
        </trans-unit>
        <trans-unit id="dd0179ef987e379ce17d15225812657b396c054c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__const__&lt;/code&gt;, &lt;code&gt;__asm__&lt;/code&gt;, etc., for header files.</source>
          <target state="translated">&lt;code&gt;__const__&lt;/code&gt; 、 &lt;code&gt;__asm__&lt;/code&gt; など、ヘッダファイルのため。</target>
        </trans-unit>
        <trans-unit id="7473df93d6fe52ceeeb6718adea22f662c95bc6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float128&lt;/code&gt; is available on i386, x86_64, IA-64, and hppa HP-UX, as well as on PowerPC GNU/Linux targets that enable the vector scalar (VSX) instruction set. &lt;code&gt;__float128&lt;/code&gt; supports the 128-bit floating type. On i386, x86_64, PowerPC, and IA-64 other than HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;_Float128&lt;/code&gt;. On hppa and IA-64 HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;long
double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__float128&lt;/code&gt; は、i386、x86_64、IA-64、およびhppa HP-UX、ならびにベクタースカラー（VSX）命令セットを有効にするPowerPC GNU / Linuxターゲットで使用できます。 &lt;code&gt;__float128&lt;/code&gt; は、128ビット浮動型をサポートします。i386では、x86_64版は、HP-UX以外のPowerPC、およびIA-64は、 &lt;code&gt;__float128&lt;/code&gt; の別名です &lt;code&gt;_Float128&lt;/code&gt; 。hppaおよびIA-64 HP-UXでは、 &lt;code&gt;__float128&lt;/code&gt; は &lt;code&gt;long double&lt;/code&gt; エイリアスです。</target>
        </trans-unit>
        <trans-unit id="ffb2bf9a670bef293cfa77a116c8f843376e5401" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float80&lt;/code&gt; is available on the i386, x86_64, and IA-64 targets, and supports the 80-bit (&lt;code&gt;XFmode&lt;/code&gt;) floating type. It is an alias for the type name &lt;code&gt;_Float64x&lt;/code&gt; on these targets.</source>
          <target state="translated">&lt;code&gt;__float80&lt;/code&gt; は、i386、x86_64、およびIA-64ターゲットで使用でき、80ビット（ &lt;code&gt;XFmode&lt;/code&gt; ）浮動型をサポートします。これは、これらのターゲットのタイプ名 &lt;code&gt;_Float64x&lt;/code&gt; のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="7ec6ed15db3de1e0e785dbadf3953c59dadef3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ibm128&lt;/code&gt; is available on PowerPC targets, and provides access to the IBM extended double format which is the current format used for &lt;code&gt;long double&lt;/code&gt;. When &lt;code&gt;long double&lt;/code&gt; transitions to &lt;code&gt;__float128&lt;/code&gt; on PowerPC in the future, &lt;code&gt;__ibm128&lt;/code&gt; will remain for use in conversions between the two types.</source>
          <target state="translated">&lt;code&gt;__ibm128&lt;/code&gt; はPowerPCターゲットで使用可能であり、 &lt;code&gt;long double&lt;/code&gt; に現在使用されているIBM拡張double形式へのアクセスを提供します。ときに &lt;code&gt;long double&lt;/code&gt; に遷移 &lt;code&gt;__float128&lt;/code&gt; 将来的にはPowerPCで、 &lt;code&gt;__ibm128&lt;/code&gt; は二つのタイプの間の変換で使用するために残ります。</target>
        </trans-unit>
        <trans-unit id="9e3a9ed7baa3bf65df3ff05f513613983a9587ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acc&lt;/code&gt; arguments are evaluated at compile time and specify the number of an accumulator register. For example, an &lt;code&gt;acc&lt;/code&gt; argument of 2 selects the ACC2 register.</source>
          <target state="translated">&lt;code&gt;acc&lt;/code&gt; 引数はコンパイル時に評価され、アキュムレータレジスタの数を指定します。たとえば、 &lt;code&gt;acc&lt;/code&gt; 引数2はACC2レジスタを選択します。</target>
        </trans-unit>
        <trans-unit id="15fdbd93cf947c8849cb1d5a35f4090a626ff637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array&lt;/code&gt; needs to be an Objective-C object (usually a collection object, for example an array, a dictionary or a set) which implements the &amp;ldquo;Fast Enumeration Protocol&amp;rdquo; (see below). If you are using a Foundation library such as GNUstep Base or Apple Cocoa Foundation, all collection objects in the library implement this protocol and can be used in this way.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; は、「高速列挙プロトコル」を実装するObjective-Cオブジェクト（通常は、配列、辞書、セットなどのコレクションオブジェクト）である必要があります（以下を参照）。 GNUstep BaseやApple Cocoa FoundationなどのFoundationライブラリを使用している場合、ライブラリ内のすべてのコレクションオブジェクトはこのプロトコルを実装しており、この方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="426e3d34f5d2b8cc641dc2d655c2412b3ba31507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm goto&lt;/code&gt; allows assembly code to jump to one or more C labels. The &lt;var&gt;GotoLabels&lt;/var&gt; section in an &lt;code&gt;asm goto&lt;/code&gt; statement contains a comma-separated list of all C labels to which the assembler code may jump. GCC assumes that &lt;code&gt;asm&lt;/code&gt; execution falls through to the next statement (if this is not the case, consider using the &lt;code&gt;__builtin_unreachable&lt;/code&gt; intrinsic after the &lt;code&gt;asm&lt;/code&gt; statement). Optimization of &lt;code&gt;asm goto&lt;/code&gt; may be improved by using the &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; label attributes (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; を使用すると、アセンブリコードで1つ以上のCラベルにジャンプできます。 &lt;code&gt;asm goto&lt;/code&gt; ステートメントの &lt;var&gt;GotoLabels&lt;/var&gt; セクションには、アセンブラーコードがジャンプするすべてのCラベルのコンマ区切りのリストが含まれています。 GCCは、 &lt;code&gt;asm&lt;/code&gt; の実行が次のステートメントまで進むと想定します（そうでない場合は、 &lt;code&gt;asm&lt;/code&gt; ステートメントの後に &lt;code&gt;__builtin_unreachable&lt;/code&gt; コンパイラ組み込み関数を使用することを検討してください）。最適化 &lt;code&gt;asm goto&lt;/code&gt; 使用することによって改善することができる &lt;code&gt;hot&lt;/code&gt; と &lt;code&gt;cold&lt;/code&gt; （参照ラベル属性&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c9823fe22f97e1ec190b250dc2a2fdf94a1ee857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements, only to the listed &lt;var&gt;GotoLabels&lt;/var&gt;. GCC&amp;rsquo;s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; ステートメントは、他の &lt;code&gt;asm&lt;/code&gt; ステートメントへのジャンプを実行できません。リストされている &lt;var&gt;GotoLabels&lt;/var&gt; へのジャンプのみを実行できます。GCCのオプティマイザは他のジャンプについて知りません。したがって、最適化の方法を決定する際にそれらを考慮することはできません。</target>
        </trans-unit>
        <trans-unit id="62977bb50d3c5a19ea5904a3a299ffd7ea5dbd29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements. GCC does not know about these jumps, and therefore cannot take account of them when deciding how to optimize. Jumps from &lt;code&gt;asm&lt;/code&gt; to C labels are only supported in extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; ステートメントは、他の &lt;code&gt;asm&lt;/code&gt; ステートメントへのジャンプを実行できません。GCCはこれらのジャンプを認識していないため、最適化の方法を決定するときにそれらを考慮することができません。 &lt;code&gt;asm&lt;/code&gt; からCラベルへのジャンプは、拡張 &lt;code&gt;asm&lt;/code&gt; でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="c9448d646265094e46fad56b4a1ad54b2c75f890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; supports operand modifiers on operands (for example &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; は、オペランドのオペランド修飾子をサポートします（たとえば、 '</target>
        </trans-unit>
        <trans-unit id="47c475345b4b6683f86ef0bd1304fa403571227e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; followed by the starting position of the bit-field, the type of the bit-field and the size of the bit-field (the bit-fields encoding was changed from the NeXT&amp;rsquo;s compiler encoding, see below)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; に続いて、ビットフィールドの開始位置、ビットフィールドのタイプ、およびビットフィールドのサイズ（ビットフィールドエンコーディングは、NeXTのコンパイラエンコーディングから変更されました。以下を参照してください）</target>
        </trans-unit>
        <trans-unit id="fd931d3282f78cf10b6e109fc3d87523a40b1c70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int*&lt;/code&gt; is a pointer to a &lt;code&gt;const int&lt;/code&gt;, and so is encoded as &lt;code&gt;^ri&lt;/code&gt;. &lt;code&gt;int* const&lt;/code&gt;, instead, is a &lt;code&gt;const&lt;/code&gt; pointer to an &lt;code&gt;int&lt;/code&gt;, and so is encoded as &lt;code&gt;r^i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const int*&lt;/code&gt; へのポインタで &lt;code&gt;const int&lt;/code&gt; 、およびように符号化されている &lt;code&gt;^ri&lt;/code&gt; 。代わりに、 &lt;code&gt;int* const&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; への &lt;code&gt;const&lt;/code&gt; ポインターであるため、 &lt;code&gt;r^i&lt;/code&gt; としてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="8cc303077f2d42536c4b3baafc5729fd35626b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; arguments represent immediate operands in the underlying FR-V instructions. They must be compile-time constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 引数は、基になるFR-V命令の即値オペランドを表します。それらはコンパイル時の定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="deb6088d1e3cb9956bb32715c4b9b0433c0fb80e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(nullptr)&lt;/code&gt; incorrectly had an alignment of 1, leading to unaligned accesses. Note that this did not affect the ABI of a function with a &lt;code&gt;nullptr_t&lt;/code&gt; parameter, as parameters have a minimum alignment.</source>
          <target state="translated">&lt;code&gt;decltype(nullptr)&lt;/code&gt; のアライメントが誤って1になり、アライメントされていないアクセスが発生しました。パラメータが最小の整列を持っているため、これは &lt;code&gt;nullptr_t&lt;/code&gt; パラメータを持つ関数のABIに影響を与えなかったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="13371da4b8a0998cda9c846517eca9aac42602d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum foo;&lt;/code&gt;, with details to follow.</source>
          <target state="translated">&lt;code&gt;enum foo;&lt;/code&gt; 、詳細が続きます。</target>
        </trans-unit>
        <trans-unit id="9e91e48e9653d7d4d932a05bfbd83b09588c7939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are always encoded as &amp;rsquo;i&amp;rsquo; (int) even if they are actually unsigned or long.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; は、実際に符号なしまたは長い場合でも、常に「i」（int）としてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="9a12395e61d19efb5c294812d6196468603d44b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; declarations are not affected by</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 宣言は影響を受けません</target>
        </trans-unit>
        <trans-unit id="4b6de559d80875c4a2043040ec9b3a928c196dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 戻り値の型とパラメーターの型の浮動小数点数</target>
        </trans-unit>
        <trans-unit id="43f52ce2765906e82519d10c80ebb890c471c9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc&lt;/code&gt; is a driver program. It performs its job by invoking a sequence of other programs to do the work of compiling, assembling and linking. GCC interprets its command-line parameters and uses these to deduce which programs it should invoke, and which command-line options it ought to place on their command lines. This behavior is controlled by &lt;em&gt;spec strings&lt;/em&gt;. In most cases there is one spec string for each program that GCC can invoke, but a few programs have multiple spec strings to control their behavior. The spec strings built into GCC can be overridden by using the</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; はドライバープログラムです。他の一連のプログラムを呼び出して、コンパイル、アセンブル、およびリンクの作業を行うことにより、その役割を果たします。GCCはそのコマンドラインパラメータを解釈し、これらを使用して、呼び出すプログラムと、コマンドラインに配置する必要があるコマンドラインオプションを推定します。この動作は、&lt;em&gt;スペック文字列&lt;/em&gt;によって制御され&lt;em&gt;ます&lt;/em&gt;。ほとんどの場合、GCCが呼び出すことができるプログラムごとに1つの仕様文字列がありますが、いくつかのプログラムは、その動作を制御する複数の仕様文字列を持っています。GCCに組み込まれた仕様文字列は、</target>
        </trans-unit>
        <trans-unit id="78e0e9f2c419ee9f240f0845bc755717d55d3a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; は次のオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="57d6fe4b10a5a2126cbfcec6595777a79798d69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump content of gcda and gcno profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; は、GCCと組み合わせて使用​​して、gcdaおよびgcnoプロファイルファイルのコンテンツをオフラインでダンプできるツールです。</target>
        </trans-unit>
        <trans-unit id="2878b99530b4f0ab8508c0886d2f8099475e075b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt;&amp;mdash;an offline gcda and gcno profile dump tool.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; dump-オフラインのgcdaおよびgcnoプロファイルダンプツール。</target>
        </trans-unit>
        <trans-unit id="8557e16ee11b3bb8a6161e3b196a98d4d9ef3676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; は次のオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="834e3a72a863342de668198a9b180e31689bb9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is a tool you can use in conjunction with GCC to manipulate or process gcda profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; は、GCCと組み合わせて使用​​して、gcdaプロファイルファイルをオフラインで操作または処理できるツールです。</target>
        </trans-unit>
        <trans-unit id="8966e78c51b409536bc0ea171add9c067eaae6cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is an offline tool to process gcc&amp;rsquo;s gcda profile files.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; は、gccのgcdaプロファイルファイルを処理するオフラインツールです。</target>
        </trans-unit>
        <trans-unit id="70183d08ebe3785a624a3a0d2f54f5da4fcf92c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt;&amp;mdash;an offline gcda profile processing program.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; &amp;mdash;オフラインのgcdaプロファイル処理プログラム。</target>
        </trans-unit>
        <trans-unit id="432fd55f9f3348b69e564e9e68b9ac68338b2330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は次のオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="ef7fa5c92c81ba37950cfb7081e034b38df44ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; creates a logfile called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="fa86b3b9c4851aca0143ed5eebf12b37ac982caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a test coverage program. Use it in concert with GCC to analyze your programs to help create more efficient, faster running code and to discover untested parts of your program. You can use &lt;code&gt;gcov&lt;/code&gt; as a profiling tool to help discover where your optimization efforts will best affect your code. You can also use &lt;code&gt;gcov&lt;/code&gt; along with the other profiling tool, &lt;code&gt;gprof&lt;/code&gt;, to assess which parts of your code use the greatest amount of computing time.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; はテストカバレッジプログラムです。これをGCCと組み合わせて使用​​してプログラムを分析し、より効率的で高速に実行されるコードを作成し、プログラムのテストされていない部分を発見します。 &lt;code&gt;gcov&lt;/code&gt; をプロファイリングツールとして使用して、最適化の取り組みがコードに最も影響する場所を見つけることができます。 &lt;code&gt;gcov&lt;/code&gt; を他のプロファイリングツール &lt;code&gt;gprof&lt;/code&gt; と一緒に使用して、コードのどの部分が計算時間を最も多く使用しているかを評価することもできます。</target>
        </trans-unit>
        <trans-unit id="ec4c7d87db361b8b7217252e79155f330d87180c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a tool you can use in conjunction with GCC to test code coverage in your programs.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は、GCCと組み合わせて使用​​して、プログラムのコードカバレッジをテストできるツールです。</target>
        </trans-unit>
        <trans-unit id="74c1eaafeae6a0c3622569a9b97608b21c035122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; should be run with the current directory the same as that when you invoked the compiler. Otherwise it will not be able to locate the source files. &lt;code&gt;gcov&lt;/code&gt; produces files called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は、コンパイラーを起動したときと同じ現在のディレクトリで実行する必要があります。そうしないと、ソースファイルを見つけることができません。 &lt;code&gt;gcov&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="54f992c071dcdc4cf317b5dc2c2e8150dab3baed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; uses two files for profiling. The names of these files are derived from the original &lt;em&gt;object&lt;/em&gt; file by substituting the file suffix with either</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は、プロファイリングに2つのファイルを使用します。これらのファイルの名前は、ファイルサフィックスを次のいずれかに置き換えることにより、元の&lt;em&gt;オブジェクト&lt;/em&gt;ファイルから派生します。</target>
        </trans-unit>
        <trans-unit id="e0e281a8c455e080b9c9615f521b0af9f3afc81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; works only on code compiled with GCC. It is not compatible with any other profiling or test coverage mechanism.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; は、GCCでコンパイルされたコードでのみ機能します。他のプロファイリングやテストカバレッジメカニズムとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="e18b2104276bf04773cc9483f7f381c6d995630f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a test coverage program.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; :テストカバレッジプログラム。</target>
        </trans-unit>
        <trans-unit id="0adbd472f7e4a6a8700ee625ca50b5065e7189f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt;, defined as follows:</source>
          <target state="translated">&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt; 、次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="c651bda5c1e10d455f6b6c7f62a6f71255f9e521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iacc&lt;/code&gt; arguments are similar to &lt;code&gt;acc&lt;/code&gt; arguments but specify the number of an IACC register. See see &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;Other Built-in Functions&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;iacc&lt;/code&gt; 引数は &lt;code&gt;acc&lt;/code&gt; 引数に似ていますが、IACCレジスタの数を指定します。詳細については、&lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;その他の組み込み関数&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bf79502e7b46209589262e2429120814cbb13c52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_15&lt;/code&gt;, an integer literal in range 0 to 15;</source>
          <target state="translated">&lt;code&gt;imm0_15&lt;/code&gt; 、範囲0〜15の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="ccc2033cd80d019d5fd83cb192150729b7904cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_1&lt;/code&gt;, an integer literal in range 0 to 1;</source>
          <target state="translated">&lt;code&gt;imm0_1&lt;/code&gt; 、範囲0〜1の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="f624a59ec5d313a1c0a203fc5cdfd4a3666bdad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_255&lt;/code&gt;, an integer literal in range 0 to 255;</source>
          <target state="translated">&lt;code&gt;imm0_255&lt;/code&gt; 、0〜255の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="45c72131be83eef97ea9ee3eff2a0bdba7519f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_31&lt;/code&gt;, an integer literal in range 0 to 31;</source>
          <target state="translated">&lt;code&gt;imm0_31&lt;/code&gt; 、0〜31の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="cde4836239d0583916a4b3f7436c408e99e7f181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_3&lt;/code&gt;, an integer literal in range 0 to 3;</source>
          <target state="translated">&lt;code&gt;imm0_3&lt;/code&gt; 、範囲0〜3の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="51e823a1bbc6ba2a324f7474f9da47e3b2690272" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_63&lt;/code&gt;, an integer literal in range 0 to 63;</source>
          <target state="translated">&lt;code&gt;imm0_63&lt;/code&gt; 、0〜63の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="62f6834f1b1628360d13102cd8355d1bff98dfb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_7&lt;/code&gt;, an integer literal in range 0 to 7;</source>
          <target state="translated">&lt;code&gt;imm0_7&lt;/code&gt; 、0〜7の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="06869e0d4af1794473183f20d27a91d5c322515b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm1_4&lt;/code&gt;, an integer literal in range 1 to 4;</source>
          <target state="translated">&lt;code&gt;imm1_4&lt;/code&gt; 、1〜4の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="26b8f3ccab339df690ac564365568e69734e0e95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n1024_1022&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 1 bit, i.e., -1024, -1022, &amp;hellip;, 1020, 1022;</source>
          <target state="translated">&lt;code&gt;imm_n1024_1022&lt;/code&gt; 、-512から511の範囲の整数リテラル、1ビット左シフト、つまり-1024、-1022、&amp;hellip;、1020、1022。</target>
        </trans-unit>
        <trans-unit id="53f347dd23c9ce86f4bf63425a73319aeca2e71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n16_15&lt;/code&gt;, an integer literal in range -16 to 15;</source>
          <target state="translated">&lt;code&gt;imm_n16_15&lt;/code&gt; 、-16〜15の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="c764a9f154679364bdd3af401c15760d950c39d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n2048_2044&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 2 bits, i.e., -2048, -2044, &amp;hellip;, 2040, 2044;</source>
          <target state="translated">&lt;code&gt;imm_n2048_2044&lt;/code&gt; 、-512から511の範囲の整数リテラル、2ビット左シフト、つまり-2048、-2044、&amp;hellip;、2040、2044;</target>
        </trans-unit>
        <trans-unit id="d8621ae125b08b357812594db312fcdb8bd2e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n4096_4088&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 3 bits, i.e., -4096, -4088, &amp;hellip;, 4080, 4088;</source>
          <target state="translated">&lt;code&gt;imm_n4096_4088&lt;/code&gt; 、-512から511の範囲の整数リテラル、つまり-4096、-4088、&amp;hellip;、4080、4088。</target>
        </trans-unit>
        <trans-unit id="43bcd7d1a4a29ac9e7f1c73f1912ac48e5ce1624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n512_511&lt;/code&gt;, an integer literal in range -512 to 511;</source>
          <target state="translated">&lt;code&gt;imm_n512_511&lt;/code&gt; 、-512〜511の範囲の整数リテラル。</target>
        </trans-unit>
        <trans-unit id="f04c7ff5dca47e97ec5511198b36d3aa9615e32d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int16x4_t&lt;/code&gt;, a vector of four signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;int16x4_t&lt;/code&gt; 、4つの符号付き16ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="d63e9df03ecc48a8a23928c599b1004cd533f6d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32x2_t&lt;/code&gt;, a vector of two signed 32-bit integers.</source>
          <target state="translated">&lt;code&gt;int32x2_t&lt;/code&gt; 、2つの符号付き32ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="91184ef12147d2f6b1bdaa56fe5d9583a6f4e83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8x8_t&lt;/code&gt;, a vector of eight signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;int8x8_t&lt;/code&gt; 、8つの符号付き8ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="9a7265111af471ce530480c106de4c972fb277fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 戻り値の型とパラメーターの型のint</target>
        </trans-unit>
        <trans-unit id="3e0d50378937884eeb028aecd3fcc684e4a49b74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt; followed by the inner type. For example &lt;code&gt;_Complex double&lt;/code&gt; is encoded as &quot;jd&quot;.</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; の後に内部型が続きます。たとえば、 &lt;code&gt;_Complex double&lt;/code&gt; は「jd」としてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="0871af21d28c83f64c804091ade1492e9664c30b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; は次のオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="ea8422e33957287d90215f0f4f8087a0305f1d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump link time optimization object files.</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; は、リンク時間最適化オブジェクトファイルをダンプするためにGCCと組み合わせて使用​​できるツールです。</target>
        </trans-unit>
        <trans-unit id="a51997ac3a8fdd69732aefc35a59335c494052e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt;&amp;mdash;Tool for dumping LTO object files.</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; ：LTOオブジェクトファイルをダンプするためのツール。</target>
        </trans-unit>
        <trans-unit id="2f711a37cb98098d461731b92b78a9d7c2b5ec6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb1626a9beed4fd0495f07220bec199cc6d6bd0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not have a return instruction whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; functions have a &lt;code&gt;RET&lt;/code&gt; or &lt;code&gt;RETI&lt;/code&gt; return instruction.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 一方の機能が復帰命令を持っていない &lt;code&gt;OS_main&lt;/code&gt; と &lt;code&gt;OS_task&lt;/code&gt; 機能を持っている &lt;code&gt;RET&lt;/code&gt; または &lt;code&gt;RETI&lt;/code&gt; の復帰命令を。</target>
        </trans-unit>
        <trans-unit id="f91f91e06fe6fe3ed6698c6a7170097cb9c11482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not set up a frame for local variables or a frame pointer whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; do this as needed.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 関数はローカル変数のフレームやフレームポインターを設定しませんが、 &lt;code&gt;OS_main&lt;/code&gt; と &lt;code&gt;OS_task&lt;/code&gt; は必要に応じてこれを行います。</target>
        </trans-unit>
        <trans-unit id="e1ec8966dbb2d024c34ce202400922786b20bf42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q31&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are actually the same as &lt;code&gt;int&lt;/code&gt;, but we use &lt;code&gt;q31&lt;/code&gt; to indicate a Q31 fractional value and &lt;code&gt;i32&lt;/code&gt; to indicate a 32-bit integer value. Similarly, &lt;code&gt;a64&lt;/code&gt; is the same as &lt;code&gt;long long&lt;/code&gt;, but we use &lt;code&gt;a64&lt;/code&gt; to indicate values that are placed in one of the four DSP accumulators (&lt;code&gt;$ac0&lt;/code&gt;, &lt;code&gt;$ac1&lt;/code&gt;, &lt;code&gt;$ac2&lt;/code&gt; or &lt;code&gt;$ac3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;q31&lt;/code&gt; および &lt;code&gt;i32&lt;/code&gt; は実際には &lt;code&gt;int&lt;/code&gt; と同じですが、 &lt;code&gt;q31&lt;/code&gt; を使用してQ31の小数値を示し、 &lt;code&gt;i32&lt;/code&gt; を使用して32ビットの整数値を示します。同様に、 &lt;code&gt;a64&lt;/code&gt; 同じである &lt;code&gt;long long&lt;/code&gt; 、我々は使用 &lt;code&gt;a64&lt;/code&gt; 4つのDSPアキュムレータのいずれかに配置されている値を示すために（ &lt;code&gt;$ac0&lt;/code&gt; 、 &lt;code&gt;$ac1&lt;/code&gt; 、 &lt;code&gt;$ac2&lt;/code&gt; または &lt;code&gt;$ac3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ea0054c5fec474c155dbd98ae3adc8592ccc0ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict-align&lt;/code&gt; indicates that the compiler should not assume that unaligned memory references are handled by the system. To allow the compiler to assume that aligned memory references are handled by the system, the inverse attribute &lt;code&gt;no-strict-align&lt;/code&gt; can be specified. The behavior is same as for the command-line option</source>
          <target state="translated">&lt;code&gt;strict-align&lt;/code&gt; は、アライメントされていないメモリ参照がシステムによって処理されるとコンパイラが想定してはならないことを示します。コンパイラーが整列されたメモリー参照がシステムによって処理されると想定できるようにするには、逆属性 &lt;code&gt;no-strict-align&lt;/code&gt; を指定できます。動作はコマンドラインオプションの場合と同じです</target>
        </trans-unit>
        <trans-unit id="0ce41d50092061190708b7c5fd578471925d484e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tbegin&lt;/code&gt; has been executed as part of normal processing. The transaction body is supposed to be executed.</source>
          <target state="translated">&lt;code&gt;tbegin&lt;/code&gt; は通常の処理の一部として実行されました。トランザクション本体が実行されることになっています。</target>
        </trans-unit>
        <trans-unit id="90a2359fdefeabe506da21e5ceeb1ec6dfb149dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type_info&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; オブジェクト</target>
        </trans-unit>
        <trans-unit id="972569711d57266ec65a8196096540c87f973793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; is often useful in conjunction with statement expressions (see &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprs&lt;/a&gt;). Here is how the two together can be used to define a safe &amp;ldquo;maximum&amp;rdquo; macro which operates on any arithmetic type and evaluates each of its arguments exactly once:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; は多くの場合、ステートメント式と組み合わせて使用​​すると便利です（&lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprsを&lt;/a&gt;参照）。以下は、2つを一緒に使用して、任意の算術型で動作し、その引数のそれぞれを1回だけ評価する安全な「最大」マクロを定義する方法です。</target>
        </trans-unit>
        <trans-unit id="01dc66305ee017274a8f90b9afb7de83e8f46c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt;: referring to the type of an expression.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; ：式のタイプを参照します。</target>
        </trans-unit>
        <trans-unit id="8c7b90f2794ef9994bb660999c0f322a942bf8f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint16x4_t&lt;/code&gt;, a vector of four unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;uint16x4_t&lt;/code&gt; 、4つの符号なし16ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="b0558ac59824429cd7d9d4b1f36c21a2ee0fe3e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint32x2_t&lt;/code&gt;, a vector of two unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;uint32x2_t&lt;/code&gt; 、2つの符号なし32ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="2d69c68962c47d62e79bf31389c4415c2f200ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8x8_t&lt;/code&gt;, a vector of eight unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;uint8x8_t&lt;/code&gt; 、8つの符号なし8ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="dbb644e8ba42f8f623407a24fa989ae31fed8572" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; は常にメモリに渡されます。</target>
        </trans-unit>
        <trans-unit id="1db4672f93c338ff587750e17356ae256986573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is now always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; は常にメモリに渡されるようになりました。</target>
        </trans-unit>
        <trans-unit id="fadc8e6d5e8d31b3a291f79221d6f051c12b8821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16i8&lt;/code&gt;, a vector of sixteen signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16i8&lt;/code&gt; 、16個の符号付き8ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="131a161af4f7e0b4ea5ae1747e0ea7514b0c83b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16u8&lt;/code&gt;, a vector of sixteen unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16u8&lt;/code&gt; 、16個の符号なし8ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="1b29406a43f217bd305e13cb54ba71e651d5bba2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2f64&lt;/code&gt;, a vector of two 64-bit doubles.</source>
          <target state="translated">&lt;code&gt;v2f64&lt;/code&gt; 、2つの64ビットdoubleのベクトル。</target>
        </trans-unit>
        <trans-unit id="7512973093e5491713fd6ebd5358156e9bc4a1dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2i64&lt;/code&gt;, a vector of two signed 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2i64&lt;/code&gt; 、2つの符号付き64ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="9db6b88b33ec3aa8ad125c2d46beb5f476bec0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2sf&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v2sf&lt;/code&gt; 値は、集計と同じ方法で初期化されます。例えば：</target>
        </trans-unit>
        <trans-unit id="c3855d3df800b3ae2c45c123aa6cb8ce5e785ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2u64&lt;/code&gt;, a vector of two unsigned 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2u64&lt;/code&gt; 、2つの符号なし64ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="6ad31881d9c216547f22d1f2a2db29238b4dc646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4f32&lt;/code&gt;, a vector of four 32-bit floats;</source>
          <target state="translated">&lt;code&gt;v4f32&lt;/code&gt; 、4つの32ビット浮動小数点のベクトル。</target>
        </trans-unit>
        <trans-unit id="31c7877922fb039b6c0292daf271e4981078508f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i32&lt;/code&gt;, a vector of four signed 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4i32&lt;/code&gt; 、4つの符号付き32ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="17a0ec2f60a3d3e13fba7b775b40060a5c47ab58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i8&lt;/code&gt;, &lt;code&gt;v4q7&lt;/code&gt;, &lt;code&gt;v2i16&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v4i8&lt;/code&gt; 、 &lt;code&gt;v4q7&lt;/code&gt; 、 &lt;code&gt;v2i16&lt;/code&gt; 、および &lt;code&gt;v2q15&lt;/code&gt; の値は、集計と同じ方法で初期化されます。例えば：</target>
        </trans-unit>
        <trans-unit id="6b9f0632a60f7e2199e33eae5df860d977b737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4u32&lt;/code&gt;, a vector of four unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4u32&lt;/code&gt; 、4つの符号なし32ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="15eeca02c95cac6ccf4d38d5e71572806fbe59c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8i16&lt;/code&gt;, a vector of eight signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8i16&lt;/code&gt; 、8つの符号付き16ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="18c14a5e3dac281031739c8daafc626ba35c9efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8u16&lt;/code&gt;, a vector of eight unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8u16&lt;/code&gt; 、8つの符号なし16ビット整数のベクトル。</target>
        </trans-unit>
        <trans-unit id="d6a4e5bb9ed4a03346a1e5335ca402c064f0fe3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 戻り値の型とパラメーターの型</target>
        </trans-unit>
        <trans-unit id="931138ba5a2507ee2e7e0fc42f85c661aad3ee17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; for return type and no parameter for parameter types.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 戻り値の型の場合はvoid、パラメーター型の場合はパラメーターなし。</target>
        </trans-unit>
        <trans-unit id="5a5d5c4a2842d52363078341ffbf5ff1c71da9e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AArch64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AArch64オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ea9b56847cb67e896fe9ed92e829c46db4c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AMD GCN Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AMD GCNオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="867c24fe4dbfd5ccbf6133610e3056cd4490ebb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ARCオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a804dffc1734b11346a4329fb8b712484dc062a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARM Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ARMオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42007853e2d2e5ee57f43b159004f83209e6c120" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AVR Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AVRオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aab5cdb90e0e7068aace684de244f8deb97788a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Adapteva Epiphany Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Adaptevaエピファニーオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae87c6342c250828b19327bd7929eed321e39d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blackfin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Blackfinオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77196484bdd6bd4585004c0d69f5afd921d39aeb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C-SKY Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C-SKYオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be9ad0c2e9c89a60e3ec15f581550300b8820f0d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C6X Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C6Xオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd379f819a2900908cff60cb928d58f868b9db54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CR16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CR16オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfc7c2eba72f3e5ff0469155a3c3406b2e006fe3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CRIS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CRISオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bcedc624ee2d8bc0dc1dde9e3ffd94d702c3815" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DEC Alpha Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DEC Alphaオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c720ccb25061b11c148efb66e96f845b91fa6ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Darwin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ダーウィンのオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95f44dfbf82d62481da460c42b5fb7c35274dcea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Errors&lt;/em&gt; report problems that make it impossible to compile your program. GCC reports errors with the source file name and line number where the problem is apparent.</source>
          <target state="translated">&lt;em&gt;エラーは&lt;/em&gt;、プログラムのコンパイルを不可能にする問題を報告します。GCCは、問題が明らかなソースファイル名と行番号のエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="089e6e509d8caabf29e30ec3bbbe964fc2afe250" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FR30 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FR30オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091553d3f3e8974e90f05c57755746679c1fdd3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FRV Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FRVオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70b7d6e356f2d0708ee860d4fc3fd1c61ab2eed5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FT32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FT32オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ffc4ee3ad54f42a4735dcc174d96d9c6c59ac5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;GNU/Linux Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;GNU / Linuxオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0822ea35a43e7bcfdcf9fd3e546d607438735455" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;H8/300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;H8 / 300オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdf83e6772f30030bb2fc1476c4b6aba2fad8a80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HPPA Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HPPAオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5c413dcc96c0d8d85ccbfd5c8edb509e5cdc1c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IA-64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IA-64オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b634d41b068d05c153c5acbd927a150eda46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LM32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;LM32オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e939059a018e2d2ed5fcec7a81d238219702f1a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32C Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32Cオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41423d489b98fe3519ae5cbb7b050e878b6bd6b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32R/D Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32R / Dオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d6bc2eaf8866182e321b20849ed96413e122e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M680x0 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M680x0オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7869c6ee0bb9ef2d45291f35d9736bbbaaacc30a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MCore Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MCoreオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f92ee1798eb5d8b5d7a11c3903d764ec6e437af6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MIPS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MIPSオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6811edeb78aee90d2929700d84423144700748a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MMIX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MMIXオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c6c421dea99cc933fb54d01b9291e1f3cc15403" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MN10300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MN10300オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ae829c80944d42f892c7e2fcafa7795e50814c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSP430 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSP430オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="995202556b55cd172ec8bc628d585bb4f9d60357" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MeP Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MePオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8110270e3200546987d8ee1384e2734ad7589" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MicroBlaze Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MicroBlazeオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56c00142a2adf77adfc3b717573e363224b9028" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moxie Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Moxieオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56ac1cd6a6c4ddc7383020e1168c9487d3c77648" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NDS32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NDS32オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0489603a8178bb1a03c11b5a827e58b0d976d54d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nios II Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nios IIオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a71b3dbe832df819e003067a1cc89679cd5065c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Although the equivalent hardware instructions do not take an SIMD register as an operand, these builtins overwrite the relevant bits of the &lt;code&gt;__v8hi&lt;/code&gt; register provided as the first argument with the value loaded from the &lt;code&gt;[Ib, u8]&lt;/code&gt; location in the SDM.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;同等のハードウェア命令はSIMDレジスタをオペランドとして取りませんが、これらの組み込み関数は、最初の引数として提供された &lt;code&gt;__v8hi&lt;/code&gt; レジスタの関連ビットを、SDMの &lt;code&gt;[Ib, u8]&lt;/code&gt; ロケーションからロードされた値で上書きします。</target>
        </trans-unit>
        <trans-unit id="906695ffc11fbd6c29f6a7c5fffdd87c61dd0062" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; as &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; GCC 4.4以降では、 &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; を &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; 〜tmp ＆valueではなく* ptr =〜（tmp＆value）として実装してい &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32481d3d57648f7ac3b59915a8b343ab8f94362a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; as &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; GCC 4.4以降では、 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; を &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; なく* ptr =〜（* ptr＆value）として実装してい &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa1f3ae46628635e862095cde321a13674e15cd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If GCOV_PREFIX_STRIP is set without GCOV_PREFIX is undefined, then a relative path is made out of the hardwired absolute paths.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; GCOV_PREFIX_STRIPが設定されていて、GCOV_PREFIXが定義されていない場合、相対パスはハードワイヤード絶対パスから作成されます。</target>
        </trans-unit>
        <trans-unit id="ea491177a79dc64abd09c78a1e151400a239c1ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If a macro is actually used, but only used in skipped conditional blocks, then the preprocessor reports it as unused. To avoid the warning in such a case, you might improve the scope of the macro&amp;rsquo;s definition by, for example, moving it into the first skipped block. Alternatively, you could provide a dummy use with something like:</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;マクロが実際に使用されているが、スキップされた条件付きブロックでのみ使用されている場合、プリプロセッサーはそれを未使用として報告します。このような場合の警告を回避するには、マクロを最初のスキップされたブロックに移動するなどして、マクロの定義のスコープを改善することができます。または、次のようなダミーの使用法を提供できます。</target>
        </trans-unit>
        <trans-unit id="513ca629c61e9f50ec1060bb038d882eda72087c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If the chosen key method is later defined as inline, the vtable is still emitted in every translation unit that defines it. Make sure that any inline virtuals are declared inline in the class body, even if they are not defined there.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;選択したキーメソッドが後でインラインとして定義されている場合でも、vtableはそれを定義するすべての変換単位で出力されます。インライン仮想は、クラス本体で定義されていない場合でも、クラス本体でインラインで宣言されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="5909e9b7c2f203286387e1708a17c1db3ad3cfd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; interface is supported. Internally, GCC uses built-in functions to achieve the functionality in the aforementioned header file, but they are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; インターフェースのみがサポートされています。内部的には、GCCは組み込み関数を使用して前述のヘッダーファイルの機能を実現していますが、これらはサポートされておらず、予告なく変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="2e7d99f36188d0a0ae9bd36f15a8de72013df3fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the interface described in the aforementioned specification is supported. Internally, GCC uses built-in functions to implement the required functionality, but these are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;上記の仕様で説明されているインターフェースのみがサポートされています。内部的には、GCCは組み込み関数を使用して必要な機能を実装していますが、これらはサポートされておらず、予告なく変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="60f5a5be3206ed7a5edc1d0306252ee653ebb15f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Q7, Q15 and Q31 values must be initialized with their integer representation. As shown in this example, the integer representation of a Q7 value can be obtained by multiplying the fractional value by &lt;code&gt;0x1.0p7&lt;/code&gt;. The equivalent for Q15 values is to multiply by &lt;code&gt;0x1.0p15&lt;/code&gt;. The equivalent for Q31 values is to multiply by &lt;code&gt;0x1.0p31&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; Q7、Q15、およびQ31の値は、整数表現で初期化する必要があります。この例に示すように、Q7値の整数表現は、小数値に &lt;code&gt;0x1.0p7&lt;/code&gt; を乗算することで取得できます。Q15値に相当するのは、 &lt;code&gt;0x1.0p15&lt;/code&gt; を掛けることです。Q31値に相当するのは、 &lt;code&gt;0x1.0p31&lt;/code&gt; を掛けることです。</target>
        </trans-unit>
        <trans-unit id="ecefd38e47b465f12582422275b6c1c7fc5ba3d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. See the documentation of</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; 4.1、4.2、および4.3シリーズのGCCは、 &lt;code&gt;char&lt;/code&gt; 型のビットフィールドの &lt;code&gt;packed&lt;/code&gt; 属性を無視します。これはGCC 4.4で修正されましたが、変更により構造レイアウトに違いが生じる可能性があります。のドキュメントを参照してください</target>
        </trans-unit>
        <trans-unit id="83a8626dc0b2f71c9d50349e2149ee36fab186fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines the order in which values are packed. On little-endian targets, the first value is the least significant and the last value is the most significant. The opposite order applies to big-endian targets. For example, the code above sets the lowest byte of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; on little-endian targets and &lt;code&gt;4&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; CPUのエンディアンによって、値がパックされる順序が決まります。リトルエンディアンターゲットでは、最初の値が最も重要でなく、最後の値が最も重要です。ビッグエンディアンターゲットには、逆の順序が適用されます。たとえば、上記のコードは、リトルエンディアンターゲットでは &lt;code&gt;a&lt;/code&gt; の最下位バイトを &lt;code&gt;1&lt;/code&gt; に設定し、ビッグエンディアンターゲットでは &lt;code&gt;4&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="5b93697e5f9fd5103a0a7f14fc065355825c4168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines which value is stored in the upper half of a register and which value is stored in the lower half. On little-endian targets, the first value is the lower one and the second value is the upper one. The opposite order applies to big-endian targets. For example, the code above sets the lower half of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1.5&lt;/code&gt; on little-endian targets and &lt;code&gt;9.1&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; CPUのエンディアンによって、レジスタの上半分に格納される値と下半分に格納される値が決まります。リトルエンディアンターゲットでは、最初の値は低い方の値で、2番目の値は上の方の値です。ビッグエンディアンターゲットには、逆の順序が適用されます。例えば、セット上記のコードの下半分への &lt;code&gt;1.5&lt;/code&gt; リトルエンディアンターゲットにして &lt;code&gt;9.1&lt;/code&gt; ビッグエンディアンターゲットに。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f29631325fd85cd0fed1160021c6ec9cde3b5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The generic GCC command-line option</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;一般的なGCCコマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="ed06dff3e4ef6bf04ce2ce52a8b9fd81cb4cb441" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The value of the third parameter must be 0 or 4 modulo 8, otherwise the result is unpredictable. Please read the instruction description for details.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt; 3番目のパラメーターの値は0または4モジュロ8でなければなりません。そうでない場合、結果は予測できません。詳細は取扱説明書をご覧ください。</target>
        </trans-unit>
        <trans-unit id="72153d9d5813664a3177200e0649d766dc189c8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; These &lt;code&gt;#pragma&lt;/code&gt;s have been superceded as of GCC 2.7.2 by COMDAT support and the &amp;ldquo;key method&amp;rdquo; heuristic mentioned in &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage&lt;/a&gt;. Using them can actually cause your program to grow due to unnecessary out-of-line copies of inline functions.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;これらの &lt;code&gt;#pragma&lt;/code&gt; は、GCC 2.7.2以降、COMDATサポートおよび&lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkageで&lt;/a&gt;言及されている「キーメソッド」ヒューリスティックに取って代わられました。それらを使用すると、インライン関数の不要な行外コピーが原因で、プログラムが実際に大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a7b139d88803f100cdd95a55602837bc153be904" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This builtin is only available for C. This builtin can be used to call Go closures from C.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;この組み込みはCでのみ使用できます。この組み込みは、CからGoクロージャーを呼び出すために使用できます。</target>
        </trans-unit>
        <trans-unit id="2d97839275dd23b736dcd3d659869aced8cae5cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;この構成はCでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="eacbc4a00a6df067f8f96e363a35fd76d48bed27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C. Furthermore, the unused expression (&lt;var&gt;exp1&lt;/var&gt; or &lt;var&gt;exp2&lt;/var&gt; depending on the value of &lt;var&gt;const_exp&lt;/var&gt;) may still generate syntax errors. This may change in future revisions.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;この構築物は、さらにC.に対してのみ利用可能である未使用の式（ &lt;var&gt;exp1&lt;/var&gt; 又は &lt;var&gt;exp2&lt;/var&gt; の値に応じ &lt;var&gt;const_exp&lt;/var&gt; 依然として構文エラーを生成することができます）。これは将来の改訂で変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e7e557ba1661093fe7151e1bdc289cf424df86b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Using a built-in to generate an instruction not supported by a target may cause problems. At present the compiler is not guaranteed to detect such misuse, and as a result an internal compiler error may be generated.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;組み込みを使用してターゲットでサポートされていない命令を生成すると、問題が発生する可能性があります。現在のところ、コンパイラはそのような誤用を検出することを保証されておらず、その結果、内部コンパイラエラーが生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1a1eec5083716264a52a5668d0e808764085fd67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;計算されたgotos（GCC拡張）を使用してプログラムをコンパイルする場合、グローバルな共通部分式除去パスを無効にすると、実行時のパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="c3ceb34dafdbbccb7b3f4a9bc3198076a8bb038d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; pseudo instruction represents, in this particular context, an abstract measurement of function&amp;rsquo;s size. In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;疑似命令は、この特定のコンテキストでは、関数のサイズの抽象的な測定値を表します。アセンブリ命令の数を表すものでは決してなく、その正確な意味はリリースごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="64cd29898900abd284b24ce0046a12f2a889805e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; there may be no value to</source>
          <target state="translated">&lt;em&gt;注：&lt;/em&gt;値がない場合があります</target>
        </trans-unit>
        <trans-unit id="34f20bbbcdb20cd93bc0b28a39e05bcb36620def" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If the</source>
          <target state="translated">&lt;em&gt;注&lt;/em&gt;場合は</target>
        </trans-unit>
        <trans-unit id="cc501835fd0037936c2300c5863d1305c99d13dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nvidia PTX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nvidia PTXオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7857f3cff032f30c80ecfb8270b8c04e4e9d6efc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OpenRISC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OpenRISCオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022f17d65bf2f852a9bf52143c3cab7582dddc12" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PDP-11 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PDP-11オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc7124a8b758cba8598057dd8d025c193f4f022a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PRU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PRUオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc36ba8a70957c05f0128aeed8b3ffa01e74a202" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PowerPC Options&lt;/em&gt; See RS/6000 and PowerPC Options.</source>
          <target state="translated">&lt;em&gt;PowerPCオプション&lt;/em&gt; RS / 6000および&lt;em&gt;PowerPCオプションを&lt;/em&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7d12212e9493501d271a126a834619cd825cc637" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RISC-V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RISC-Vオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51deeb74b7040696523eac8e9b50aaa9f0c160b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RL78 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RL78オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0525fb0f4921d4b454f0867178cc3f2e709dd05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RS/6000 and PowerPC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RS / 6000およびPowerPCオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cbc4dfd74b5b6e0fa9efd8a12d1162bb681080" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RXオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="736a44f00f2782082aa29882ffc21518d1f4a4e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;S/390 and zSeries Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;S / 390およびzSeriesオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41e4a234f5bb49cd0264fa22972792fc9da3bcbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SH Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56bc7167620d3c71b9cb584d08f274377f44bf2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPARCオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc670533970668fe64148e47e0fafdaea94cb03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPUオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56413d87d2da9557912d35dbc2cfbca82836384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Score Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;スコアオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62b914fb373470c0b2ac9d74fa9f6fe2b909d5de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Solaris 2 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Solaris 2オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d42fb76fd4341ca34cfd6fb2f6c0a0d677895a40" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec files&lt;/em&gt; are plain-text files that are used to construct spec strings. They consist of a sequence of directives separated by blank lines. The type of directive is determined by the first non-whitespace character on the line, which can be one of the following:</source>
          <target state="translated">&lt;em&gt;スペックファイル&lt;/em&gt;は、スペック文字列の作成に使用されるプレーンテキストファイルです。これらは、空白行で区切られた一連のディレクティブで構成されています。ディレクティブのタイプは、行の最初の非空白文字によって決定されます。これは次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="db99a02bf9325a0446b3d3660f54ae1be166577f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec strings&lt;/em&gt; are a list of command-line options to be passed to their corresponding program. In addition, the spec strings can contain &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;スペック文字列&lt;/em&gt;は、対応するプログラムに渡されるコマンドラインオプションのリストです。さらに、スペック文字列には「</target>
        </trans-unit>
        <trans-unit id="5a15016eaf2ae61e798c9e92b569358a39e86710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;System V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;System Vオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb127030e9fe13464eefbb656da5c5e59f1ec48" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILE-Gx Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILE-Gxオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6e6e9084306dd7d17aba875acb7fea1ed46ce39" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILEPro Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILEProオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e262e710aa664259e0fd18b86e9454a54d4a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;V850 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;V850オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc271d88c785f840f6cf51c476df618f74b1cbef" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VAX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VAXオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e143e075ae3bdac97703feadb897d0df26906759" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VMS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VMSオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28ef093233a29030bf54382ba024a105f45890e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Visium Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Visiumのオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe1a73e1bcb98976a3dfe16f3ba0939cee97b5b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VxWorks Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VxWorksオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aee4d537121bb2f423daebb8bdece70ad36a69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; In the above example, be aware that a register (for example &lt;code&gt;r0&lt;/code&gt;) can be call-clobbered by subsequent code, including function calls and library calls for arithmetic operators on other variables (for example the initialization of &lt;code&gt;p2&lt;/code&gt;). In this case, use temporary variables for expressions between the register assignments:</source>
          <target state="translated">&lt;em&gt;警告：&lt;/em&gt;上記の例では、レジスター（例えば &lt;code&gt;r0&lt;/code&gt; ）が他の変数の算術演算子の関数呼び出しやライブラリー呼び出し（例えば &lt;code&gt;p2&lt;/code&gt; の初期化）を含む後続のコードによって呼び出し破棄される可能性があることに注意してください。この場合、レジスタ割り当て間の式に一時変数を使用します。</target>
        </trans-unit>
        <trans-unit id="816a932da8e0bd79bd86e31e2bb7d68625f97793" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; report other unusual conditions in your code that &lt;em&gt;may&lt;/em&gt; indicate a problem, although compilation can (and does) proceed. Warning messages also report the source file name and line number, but include the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;警告&lt;/em&gt;は、コンパイルを続行することはできますが、続行する&lt;em&gt;こと&lt;/em&gt;は&lt;em&gt;でき&lt;/em&gt;ますが、問題を示す&lt;em&gt;可能性&lt;/em&gt;があるコード内のその他の異常な状態を報告します。警告メッセージもソースファイル名と行番号を報告しますが、テキスト '</target>
        </trans-unit>
        <trans-unit id="4b143c44f6aab624c938e93ad2f6b4f657e59153" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xstormy16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xstormy16オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ac74c0cb677176c306ff128a293af591f367d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xtensa Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xtensaオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135f91287a5ce57a17a4eafa0bb5f1e2e6a72df9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;eBPF Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;eBPFオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95e5f6791684d95443cdbb8fd6680f023a74362e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;picoChip Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;picoChipオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2dbd6047aac87327270d92252817d5d79e582ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2372ad60b474adcacc8813df7ea55f14799cf6b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Windows Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86 Windowsオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="636b6c51fd4e87f012cdd524f840607ddf80c3c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;zSeries Options&lt;/em&gt; See S/390 and zSeries Options.</source>
          <target state="translated">&lt;em&gt;zSeriesオプション&lt;/em&gt; S / 390および&lt;em&gt;zSeriesオプションを&lt;/em&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="05b073d8b145e3b7b4fe9382c836fb5ca8365004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lsquo;&lt;samp&gt;-mcpu&lt;/samp&gt;&amp;rsquo; arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;」&lt;samp&gt;-mcpu&lt;/samp&gt;'引数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ca73c3cb15b2a6924f0a26af33432a71a16d184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful:&lt;/strong&gt; Write spaces around the &lt;code&gt;...&lt;/code&gt;, for otherwise it may be parsed wrong when you use it with integer values. For example, write this:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;...&lt;/code&gt; の周りにスペースを入れてください。そうしないと、整数値で使用すると正しく解析されない可能性があります。たとえば、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="5b296bb4d7e000ba38a77aa5d36e6fe239ea357d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Family&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Family&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ce6e314b705bb119112642204e6ae779116bafe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do &lt;em&gt;not&lt;/em&gt; modify the contents of input-only operands (except for inputs tied to outputs). The compiler assumes that on exit from the &lt;code&gt;asm&lt;/code&gt; statement these operands contain the same values as they had before executing the statement. It is &lt;em&gt;not&lt;/em&gt; possible to use clobbers to inform the compiler that the values in these inputs are changing. One common work-around is to tie the changing input variable to an output variable that never gets used. Note, however, that if the code that follows the &lt;code&gt;asm&lt;/code&gt; statement makes no use of any of the output operands, the GCC optimizers may discard the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;入力のみのオペランドの内容は変更し&lt;em&gt;ないで&lt;/em&gt;ください（出力に関連付けられた入力を除く）。コンパイラーは、 &lt;code&gt;asm&lt;/code&gt; ステートメントの終了時に、これらのオペランドにはステートメントを実行する前と同じ値が含まれていると想定します。これらの入力の値が変化していることをコンパイラに通知するために、クロバーを使用することは&lt;em&gt;できません&lt;/em&gt;。一般的な回避策の1つは、変化する入力変数を、決して使用されない出力変数に関連付けることです。ただし、 &lt;code&gt;asm&lt;/code&gt; ステートメントに続くコードが出力オペランドをまったく使用しない場合、GCCオプティマイザは &lt;code&gt;asm&lt;/code&gt; ステートメントを不要なものとして破棄する場合があることに注意してください（&lt;a href=&quot;#Volatile&quot;&gt;Volatileを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a41c6abd653a33317410ef0db731418bdf245365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use this switch, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;このスイッチを使用する場合は、ライブラリを含め、すべてのモジュールを同じ値でビルドする必要があります。これには、システムライブラリとスタートアップモジュールが含まれます。</target>
        </trans-unit>
        <trans-unit id="9f8a7fec506fe7c2f6084ea58dbd6ac51571b5ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since RAX register is used to avoid unnecessarily saving vector registers on stack when passing variable arguments, the impacts of this option are callees may waste some stack space, misbehave or jump to a random location. GCC 4.4 or newer don&amp;rsquo;t have those issues, regardless the RAX register value.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; RAXレジスタは、変数引数を渡すときにスタックにベクターレジスタを不必要に保存しないようにするために使用されるため、このオプションの影響は、呼び出し先がスタックスペースを浪費したり、誤動作したり、ランダムな場所にジャンプしたりする可能性があることです。RCCレジスタの値に関係なく、GCC 4.4以降ではこれらの問題は発生しません。</target>
        </trans-unit>
        <trans-unit id="715534c76b05f27a336cac5eca1f15bb1ba0531b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;ザ・</target>
        </trans-unit>
        <trans-unit id="e163e3f64318185967d993e343b277921267102a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The C standards do not specify semantics for &lt;code&gt;asm&lt;/code&gt;, making it a potential source of incompatibilities between compilers. These incompatibilities may not produce compiler warnings/errors.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; C標準では &lt;code&gt;asm&lt;/code&gt; のセマンティクスを指定していないため、コンパイラ間の非互換性の原因となる可能性があります。これらの非互換性は、コンパイラの警告/エラーを生成しない場合があります。</target>
        </trans-unit>
        <trans-unit id="e86cc1401a696068f7f847fa2efe8d1c2b4f1d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When an application does not properly join all threads (or creates an detached thread), a profile file can be still corrupted.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;アプリケーションがすべてのスレッドに適切に参加しない（または切り離されたスレッドを作成する）場合でも、プロファイルファイルが破損している可能性があります。</target>
        </trans-unit>
        <trans-unit id="edb6152c62df55204f513a2bd268c824cd742794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; SSE拡張機能を無効にしてx86-64アーキテクチャーのコードを生成すると、</target>
        </trans-unit>
        <trans-unit id="6d3e02f67e0426840cf2eab0fa386a7a0d8f3f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; code compiled with the</source>
          <target state="translated">&lt;strong&gt;警告：で&lt;/strong&gt;コンパイルされたコード</target>
        </trans-unit>
        <trans-unit id="81d77d1a721cb0e9d979c46fa00adb7925430d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you override the default value for your target ABI, this changes the size of structures and arrays containing &lt;code&gt;long double&lt;/code&gt; variables, as well as modifying the function calling convention for functions taking &lt;code&gt;long double&lt;/code&gt;. Hence they are not binary-compatible with code compiled without that switch.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;ターゲットABIのデフォルト値をオーバーライドすると、 &lt;code&gt;long double&lt;/code&gt; 変数を含む構造体と配列のサイズが変更され、 &lt;code&gt;long double&lt;/code&gt; を取る関数の関数呼び出し規則が変更されます。したがって、それらはそのスイッチなしでコンパイルされたコードとバイナリ互換ではありません。</target>
        </trans-unit>
        <trans-unit id="6aef184d39f03952d172b7102530bc7a9cb2fa3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;を使用する場合</target>
        </trans-unit>
        <trans-unit id="b85ec1ce84c8439a9545fb2c1d7bf94b735aa0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;このスイッチを使用する場合は、ライブラリを含むすべてのモジュールを同じ値でビルドする必要があります。これには、システムライブラリとスタートアップモジュールが含まれます。</target>
        </trans-unit>
        <trans-unit id="6580347fe9571154d0b4891b1664cd9202c2acd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch, and &lt;var&gt;num&lt;/var&gt; is nonzero, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;このスイッチを使用し、 &lt;var&gt;num&lt;/var&gt; がゼロ以外の場合は、ライブラリを含むすべてのモジュールを同じ値でビルドする必要があります。これには、システムライブラリとスタートアップモジュールが含まれます。</target>
        </trans-unit>
        <trans-unit id="f2fa2d1c77dc6f956448ba7d671e1de6cedbcd38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88c4d51d8f615f3993e3c0cef840662cb24bb857" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not part of GCC. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;必要なライブラリはGCCの一部ではありません。通常、マシンの通常のCコンパイラの機能が使用されますが、これはクロスコンパイルで直接行うことはできません。クロスコンパイルに適したライブラリ関数を提供するには、独自の配置を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="776b38edee53ccd0d1e652426154a9a588a26326" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; this calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;この呼び出し規約は、Unixで通常使用されるものと互換性がないため、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合は使用できません。</target>
        </trans-unit>
        <trans-unit id="8633eef0a9b0178977134e42efd5a0068c9de00b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;KIND&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;KIND&lt;/var&gt; は '</target>
        </trans-unit>
        <trans-unit id="136834bf622d717ffa74c10318ba5a8ccd251af2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;WHEN&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="14be2a02710f49b8ea2b62d8e69b1cad01176b7f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arch&lt;/var&gt; value</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; 値</target>
        </trans-unit>
        <trans-unit id="3c92b0834b3f6e0b0e166db87ccbdb672bb82648" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="9e19d8b5ca485e7de26e8b332e442d8fc54664ea" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcno</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcno</target>
        </trans-unit>
        <trans-unit id="85165da2ca5194c5347e3eeeb486f7fe2449eb31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;b&lt;/var&gt;fx</source>
          <target state="translated">&lt;var&gt;b&lt;/var&gt;fx</target>
        </trans-unit>
        <trans-unit id="e61d261ac414ee0ceb16d824496fad9b5acddd85" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks&lt;/var&gt;: number of blocks that are in the function</source>
          <target state="translated">&lt;var&gt;blocks&lt;/var&gt; ：関数内にあるブロックの数</target>
        </trans-unit>
        <trans-unit id="8ae8f4fb9cf1118a0551f86c7142bd0ff6bc1464" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks_executed&lt;/var&gt;: number of executed blocks of the function</source>
          <target state="translated">&lt;var&gt;blocks_executed&lt;/var&gt; ：関数の実行済みブロックの数</target>
        </trans-unit>
        <trans-unit id="b33636a0ba563901664b6c5f838dee23ec7b7447" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;byte-size&lt;/var&gt; works, but with variable-length arrays.</source>
          <target state="translated">&lt;var&gt;byte-size&lt;/var&gt; 機能しますが、可変長配列を使用します。</target>
        </trans-unit>
        <trans-unit id="3908fe32fbee17ab1091dcbbbcc9d95e8c868d21" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the branch</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; ：ブランチの実行数</target>
        </trans-unit>
        <trans-unit id="a5a5b0ddbf193f53659eab4ecc8e6518b23dc55a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the line</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; ：行の実行数</target>
        </trans-unit>
        <trans-unit id="6dc66d5a71e8f3349f4206d52eb3738739a10355" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;current_working_directory&lt;/var&gt;: working directory where a compilation unit was compiled</source>
          <target state="translated">&lt;var&gt;current_working_directory&lt;/var&gt; ：コンパイルユニットがコンパイルされた作業ディレクトリ</target>
        </trans-unit>
        <trans-unit id="f2f093923378c09906b260d4e4fef642e8bd4c9b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;data_file&lt;/var&gt;: name of the data file (GCDA)</source>
          <target state="translated">&lt;var&gt;data_file&lt;/var&gt; ：データファイルの名前（GCDA）</target>
        </trans-unit>
        <trans-unit id="82a3c99596c0803b3cd5b5dc5b7d4f7edcb29691" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;demangled_name&lt;/var&gt;: demangled name of the function</source>
          <target state="translated">&lt;var&gt;demangled_name&lt;/var&gt; ：関数の復号化された名前</target>
        </trans-unit>
        <trans-unit id="96756339f8a07464a095163d86ae17ba49c6f2b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="457fd18521fb5ee2775888f964e4ddd50de83968" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="a2f5c6f857a964db0e9209dc3bc8af9204a69687" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/lib</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/lib</target>
        </trans-unit>
        <trans-unit id="710f2aaaa57ae08947b2914f307083f5ba6ecc46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_column&lt;/var&gt;: column in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_column&lt;/var&gt; ：関数が終了するソースファイルの列</target>
        </trans-unit>
        <trans-unit id="77d6abb0099a7849ef1e3e17b19f0755409a5b5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_line&lt;/var&gt;: line in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_line&lt;/var&gt; ：関数が終了するソースファイルの行</target>
        </trans-unit>
        <trans-unit id="bcfb310dcf9e58743c432d6bf3a973817fa1a1e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;execution_count&lt;/var&gt;: number of executions of the function</source>
          <target state="translated">&lt;var&gt;execution_count&lt;/var&gt; ：関数の実行回数</target>
        </trans-unit>
        <trans-unit id="07ced02e11442bdc9f19c2804e52ff736e36f64b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fallthrough&lt;/var&gt;: true when the branch is a fall through branch</source>
          <target state="translated">&lt;var&gt;fallthrough&lt;/var&gt; ：ブランチがフォールスルーブランチである場合はtrue</target>
        </trans-unit>
        <trans-unit id="cb068146736527c3f97548042cc209e45a84344b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fieldname&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;fieldname&lt;/var&gt;:</target>
        </trans-unit>
        <trans-unit id="bc0ca9277beb7ce53874c5a6ea975087cabd0480" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</target>
        </trans-unit>
        <trans-unit id="185fc61cbdabdd77db10b2b0b60581412f88344f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.analyzer.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.analyzer.txt</target>
        </trans-unit>
        <trans-unit id="355dc9a2a93abc7e552de9fc5978fd259683b69a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.callgraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.callgraph.dot</target>
        </trans-unit>
        <trans-unit id="aa2d0b0a626af00705d11416adb8472a02b85335" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</target>
        </trans-unit>
        <trans-unit id="d51037b1808ab0ab68cf2854624577a0a2363a83" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.dot</target>
        </trans-unit>
        <trans-unit id="e8c4ee87a95529e92014956c101d08d19626272a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.txt</target>
        </trans-unit>
        <trans-unit id="434eff9a292fff30f74330fc896652b1272e4265" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.state-purge.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.state-purge.dot</target>
        </trans-unit>
        <trans-unit id="e948a9213200b3530a25cdb5e96fc8a614d0ac69" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</target>
        </trans-unit>
        <trans-unit id="36dd403968851ab1e3b90f91ed5b921efca47df1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph.dot</target>
        </trans-unit>
        <trans-unit id="e36ec986d0d68718176ac505f37684283543d3d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8ec94309621d2424e899ea1b78e55daad7870d18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file_name&lt;/var&gt;: name of the source file</source>
          <target state="translated">&lt;var&gt;file_name&lt;/var&gt; ：ソースファイルの名前</target>
        </trans-unit>
        <trans-unit id="cd6f65bdf191a64aaefc5c263459a6f075adc163" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; automatically implies</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; は自動的に意味します</target>
        </trans-unit>
        <trans-unit id="70afe026807a5e12e476985ab37efbc5dc26d077" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; does not imply anything.</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; は何も意味しません。</target>
        </trans-unit>
        <trans-unit id="46fba837f5408f9512a6c400d555a520081bdffd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;. However,</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 。しかしながら、</target>
        </trans-unit>
        <trans-unit id="705042d186415d378755a17325dbc0219d4372f1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;format_version&lt;/var&gt;: semantic version of the format</source>
          <target state="translated">&lt;var&gt;format_version&lt;/var&gt; ：形式のセマンティックバージョン</target>
        </trans-unit>
        <trans-unit id="58bfbaccb373a1af2e15a00fe6b5acf8e46f5efd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function_name&lt;/var&gt;: a name of a function this &lt;var&gt;line&lt;/var&gt; belongs to (for a line with an inlined statements can be not set)</source>
          <target state="translated">&lt;var&gt;function_name&lt;/var&gt; ：この &lt;var&gt;line&lt;/var&gt; 属する関数の名前（インライン化されたステートメントを持つ行は設定できません）</target>
        </trans-unit>
        <trans-unit id="7150cb8c780083943181393bffe3746be197596d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;gcc_version&lt;/var&gt;: version of the GCC compiler</source>
          <target state="translated">&lt;var&gt;gcc_version&lt;/var&gt; ：GCCコンパイラのバージョン</target>
        </trans-unit>
        <trans-unit id="ae44b540bd27d10c4dc7e21db41478a671658ee6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;kind&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;kind&lt;/var&gt; は '</target>
        </trans-unit>
        <trans-unit id="8b8203cf510dcd89888a7c10446ebe87c2f89369" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</source>
          <target state="translated">&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</target>
        </trans-unit>
        <trans-unit id="7e28a7ea5e6f3cd24974425a7e272dd6dab22c97" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;line_number&lt;/var&gt;: line number</source>
          <target state="translated">&lt;var&gt;line_number&lt;/var&gt; ：行番号</target>
        </trans-unit>
        <trans-unit id="ea29079cba4e83858223a5ec28bdc6d50bd316b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</source>
          <target state="translated">&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="fb87e55fd40c286be395999f14a4dc6d95b10b8e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mangledname&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;mangledname&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="f0ce3ea44130cbe877829294966ed36eef7f62f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mode&lt;/var&gt; can be set to one the following values:</source>
          <target state="translated">&lt;var&gt;mode&lt;/var&gt; は次のいずれかの値に設定できます。</target>
        </trans-unit>
        <trans-unit id="0b1b3ce355abf1bec528e4e29cb69b648d32b2c3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f</target>
        </trans-unit>
        <trans-unit id="2956846802a0f3763419f1cd6721396729e2240a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f1_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f1_1</target>
        </trans-unit>
        <trans-unit id="d0f528c5f50a3a9ca8a7f4d4becb651762709fc6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f2_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f2_1</target>
        </trans-unit>
        <trans-unit id="a64a9113e49c525ccc4593f4075479691d2d779c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f3_2</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f3_2</target>
        </trans-unit>
        <trans-unit id="0f1c1c81fa999d2f5ca3d601e651ccc54a89eb03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;x</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;x</target>
        </trans-unit>
        <trans-unit id="8e4ffce74a745b869371f4d5e4b25a511464db80" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;: name of the function</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; ：関数の名前</target>
        </trans-unit>
        <trans-unit id="97651fa5ce5e8856932bddb384b35a32ca248309" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt; can only be 1 or 2. If it is 1 then branches are preferred over conditional code, if it is 2, then the opposite applies.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; は1または2のみです。1の場合、条件付きコードよりもブランチが優先されます。2の場合、逆が適用されます。</target>
        </trans-unit>
        <trans-unit id="50273f37f0b45fd83f80ed0fdeed8ef68524af4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0ce734a96f9558ae28efb50ac75200764dc9df5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; is the name of a file containing AutoFDO profile information. If omitted, it defaults to</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; は、AutoFDOプロファイル情報を含むファイルの名前です。省略した場合のデフォルトは</target>
        </trans-unit>
        <trans-unit id="5fc499cb4d5dfe67bd81e09d65c41f73e48f4073" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; with &lt;var&gt;path&lt;/var&gt; pointing to the base directory of the build can be used to strip the irrelevant part of the path and keep all file names relative to the main build directory.</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; ビルドのベースディレクトリを指すパスを持つ &lt;var&gt;path&lt;/var&gt; 使用して、パスの無関係な部分を取り除き、すべてのファイル名をメインビルドディレクトリに相対的に保つことができます。</target>
        </trans-unit>
        <trans-unit id="4a043823197d8a0d9d4a3dae48ce610f7a8479fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</target>
        </trans-unit>
        <trans-unit id="75da58a5824259553dc7e89b6ec73fadaabdf8c6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; and</source>
          <target state="translated">&lt;var&gt;profile_dir&lt;/var&gt; および</target>
        </trans-unit>
        <trans-unit id="26ed21f74315a592f7dd2bab8ba025f5ae695175" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; to inform GCC where is the base directory of built source tree. By default &lt;var&gt;profile_dir&lt;/var&gt; will contain files with mangled absolute paths of all object files in the built project. This is not desirable when directory used to build the instrumented binary differs from the directory used to build the binary optimized with profile feedback because the profile data will not be found during the optimized build. In such setups</source>
          <target state="translated">&lt;var&gt;profile_dir&lt;/var&gt; は、構築されたソースツリーのベースディレクトリがどこにあるかをGCCに通知します。デフォルトでは、 &lt;var&gt;profile_dir&lt;/var&gt; には、ビルドされたプロジェクト内のすべてのオブジェクトファイルの絶対パスが壊れたファイルが含まれます。インストルメント化されたバイナリのビルドに使用されるディレクトリが、プロファイルフィードバックで最適化されたバイナリのビルドに使用されるディレクトリと異なる場合、最適化されたビルド中にプロファイルデータが見つからないため、これは望ましくありません。そのような設定では</target>
        </trans-unit>
        <trans-unit id="575dfa2a337b4bc21315c8f8022717c452a4ae62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;ptr&lt;/var&gt; is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</source>
          <target state="translated">&lt;var&gt;ptr&lt;/var&gt; は、配置の決定に使用できるオブジェクトへのオプションのポインターです。値0は、通常の配置を使用する必要があることを示します。コンパイラーもこのパラメーターを無視する場合があります。</target>
        </trans-unit>
        <trans-unit id="8b3c5b36be47a0fa932bdb61b7a90e0c4902fd51" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="444cf69e0e22b51ba0c19cf554accc4728339634" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reg&lt;/var&gt; must be the name of a register. The register names accepted are machine-specific and are defined in the &lt;code&gt;REGISTER_NAMES&lt;/code&gt; macro in the machine description macro file.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; はレジスタの名前でなければなりません。受け入れられるレジスタ名はマシン固有であり、マシン記述マクロファイルの &lt;code&gt;REGISTER_NAMES&lt;/code&gt; マクロで定義されます。</target>
        </trans-unit>
        <trans-unit id="9fe1c0acef9a1d0caebcd87a22d3dc35ad3b0448" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="b880a9e002b5a8cc6ab8e5b60ed026a3bd7b4c0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="c61509b5e229f01a21d510673ed3415523a72145" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</target>
        </trans-unit>
        <trans-unit id="70db49065f5eba9055c8c455ae0994a97a7b0ff7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.o</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.o</target>
        </trans-unit>
        <trans-unit id="4b7c7cc9bc07a7bc8b59a106fc41bf34e5bc1bce" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.s</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.s</target>
        </trans-unit>
        <trans-unit id="a72234cee5f73a88a10f2c471d34f2876066e0e2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.c</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.c</target>
        </trans-unit>
        <trans-unit id="fca90e9a21f6a50975b13af845d218e0a2f371d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="d01d6365317d600e2664fe58c60f8e16adc09101" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.decl</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.decl</target>
        </trans-unit>
        <trans-unit id="273491f96586620c37b4be341e04ca0866ba515f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="b7a20df9ca0090865388e1ede1a8c313cfa2ec03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_column&lt;/var&gt;: column in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_column&lt;/var&gt; ：関数が開始するソースファイルの列</target>
        </trans-unit>
        <trans-unit id="3305d67073def22b0281ddc5b0ab6b21190df394" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_line&lt;/var&gt;: line in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_line&lt;/var&gt; ：関数が始まるソースファイルの行</target>
        </trans-unit>
        <trans-unit id="cb4cfaac038ae456ad73674888cd5dee273bede8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startfile&lt;/var&gt; is the file name of the startfile (crt0) to use when linking. This option is only useful in conjunction with</source>
          <target state="translated">&lt;var&gt;startfile&lt;/var&gt; は、リンク時に使用するstartfile（crt0）のファイル名です。このオプションは、</target>
        </trans-unit>
        <trans-unit id="92e2c1df29e70248323ce9841f5738d40e347e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;state&lt;/var&gt; configure option.</source>
          <target state="translated">&lt;var&gt;state&lt;/var&gt; 設定オプション。</target>
        </trans-unit>
        <trans-unit id="956c0d57ed11241cf2af6705b81cf132c79d5cf4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;string&lt;/var&gt; may be parenthesized, and is printed with location information. For example,</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; は括弧で囲むことができ、位置情報とともに印刷されます。例えば、</target>
        </trans-unit>
        <trans-unit id="9eedc4fd2f60aed10814958a1668c96d1c3d2760" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is either &lt;code&gt;c11&lt;/code&gt; or &lt;code&gt;ts-18661-3&lt;/code&gt; as appropriate.</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; は、必要に応じて &lt;code&gt;c11&lt;/code&gt; または &lt;code&gt;ts-18661-3&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="756b0ec3e68649366cd0150c58c2eabc74fb8d54" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;systemlib&lt;/var&gt; is the library name of the library that provides low-level system calls required by the C library, e.g. &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;. This option is typically used to link with a library provided by a HAL BSP.</source>
          <target state="translated">&lt;var&gt;systemlib&lt;/var&gt; は、Cライブラリに必要な低レベルのシステムコールを提供するライブラリのライブラリ名です（例： &lt;code&gt;read&lt;/code&gt; および &lt;code&gt;write&lt;/code&gt; )。このオプションは通常、HAL BSPによって提供されるライブラリとリンクするために使用されます。</target>
        </trans-unit>
        <trans-unit id="f3b5c58dcaf93cade01b7328b68fe8d4178ba8da" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;throw&lt;/var&gt;: true when the branch is an exceptional branch</source>
          <target state="translated">&lt;var&gt;throw&lt;/var&gt; ：ブランチが例外的なブランチである場合はtrue</target>
        </trans-unit>
        <trans-unit id="745e86448be042dc8edebfc034c56ccccf38a979" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; is an integer constant from 0 to 3. If the least significant bit is clear, objects are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to. The second bit determines if maximum or minimum of remaining bytes is computed.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; は0〜3の整数定数です。最下位ビットがクリアされている場合、オブジェクトは変数全体です。設定されている場合、最も近い周囲のサブオブジェクトは、ポインターが指すオブジェクトと見なされます。2番目のビットは、残りのバイトの最大値または最小値を計算するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="342fc24f28a056e632a0b35fb86b8d4dd73bc946" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;unexecuted_block&lt;/var&gt;: flag whether the line contains an unexecuted block (not all statements on the line are executed)</source>
          <target state="translated">&lt;var&gt;unexecuted_block&lt;/var&gt; ：行に未実行ブロックが含まれているかどうかを示すフラグ（行のすべてのステートメントが実行されるわけではありません）</target>
        </trans-unit>
        <trans-unit id="6049c35e012365c54216cf4865563ff7b5c3b373" translate="yes" xml:space="preserve">
          <source>=&lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">=&lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="46f10d3b2f96391f996a860a29e922307def05f4" translate="yes" xml:space="preserve">
          <source>=@cc&lt;var&gt;cond&lt;/var&gt;</source>
          <target state="translated">=@cc&lt;var&gt;cond&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2481fc6ffc2fbe4f98d31256e625358325756148" translate="yes" xml:space="preserve">
          <source>=f</source>
          <target state="translated">=f</target>
        </trans-unit>
        <trans-unit id="900f8b38b05989605df65663e5e3869aab5eb789" translate="yes" xml:space="preserve">
          <source>? :</source>
          <target state="translated">？：</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7025e1843ee6104f357de4a85f21b2b545cac788" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable&amp;rdquo; memory operand; that is, one which does not include any automodification of the base register. This used to be useful when &amp;lsquo;</source>
          <target state="translated">「安定した」メモリオペランド。つまり、ベースレジスタの自動変更を含まないものです。これは以前 '</target>
        </trans-unit>
        <trans-unit id="b2a6e604c21235a8a2cf39c25b6821bfb403a2f9" translate="yes" xml:space="preserve">
          <source>A 10-bit signed constant (-512 &amp;hellip; 511)</source>
          <target state="translated">10ビットの符号付き定数（-512&amp;hellip;511）</target>
        </trans-unit>
        <trans-unit id="576737d0097b50a261308a427b2851f9873b4e96" translate="yes" xml:space="preserve">
          <source>A 16 bit value with exactly one bit set.</source>
          <target state="translated">16ビットの値で、正確には1ビットが設定されています。</target>
        </trans-unit>
        <trans-unit id="91a340944b7c5084f9cb17cdbbc4b3cfd1b6b8d2" translate="yes" xml:space="preserve">
          <source>A 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">got、tls、または pc-相対参照の16ビットフラグメント。</target>
        </trans-unit>
        <trans-unit id="9d079cc97fa73a6ab6e8c28d5a00eebc59ab7c45" translate="yes" xml:space="preserve">
          <source>A 16-bit signed constant (-32768 &amp;hellip; 32767)</source>
          <target state="translated">16ビットの符号付き定数（-32768&amp;hellip;32767）</target>
        </trans-unit>
        <trans-unit id="600f9da68b2b8b3eca45f28f2690b3c739522b91" translate="yes" xml:space="preserve">
          <source>A 16-bit unsigned constant, multiple of 4 (0 &amp;hellip; 65532)</source>
          <target state="translated">4の倍数の16ビット符号なし定数（0&amp;hellip;65532）</target>
        </trans-unit>
        <trans-unit id="626d08e653ff5fead00da4b2ae1ffdf55de25ac2" translate="yes" xml:space="preserve">
          <source>A 2-element vector constant with identical elements.</source>
          <target state="translated">同一要素を持つ2要素のベクトル定数。</target>
        </trans-unit>
        <trans-unit id="199076609694aaa8dd531a498d6bd24d81a6cc20" translate="yes" xml:space="preserve">
          <source>A 20-bit signed constant (-524288 &amp;hellip; 524287)</source>
          <target state="translated">20ビットの符号付き定数（-524288&amp;hellip;524287）</target>
        </trans-unit>
        <trans-unit id="739e9c986b6796272b083980b6406cba9cf05af2" translate="yes" xml:space="preserve">
          <source>A 3-bit unsigned integer constant.</source>
          <target state="translated">3ビットの符号なし整数定数。</target>
        </trans-unit>
        <trans-unit id="8d9d9ff6786b090797685cfe7290aeace549fb2c" translate="yes" xml:space="preserve">
          <source>A 4-element vector constant with identical elements.</source>
          <target state="translated">同一要素を持つ4要素のベクトル定数。</target>
        </trans-unit>
        <trans-unit id="809cfd342c5778cebf932a5fb2090f41ac0b8050" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned immediate for CSR access instructions.</source>
          <target state="translated">CSRアクセス命令用の5ビット符号なしイミディエイト。</target>
        </trans-unit>
        <trans-unit id="7a0f592094ae133e28a83db08acb3ad80aaa8c6b" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned integer constant.</source>
          <target state="translated">5ビットの符号なし整数定数。</target>
        </trans-unit>
        <trans-unit id="2a19359a80d0f6de7d964e539759745df3e07113" translate="yes" xml:space="preserve">
          <source>A 6-bit unsigned integer constant.</source>
          <target state="translated">6ビットの符号なし整数定数。</target>
        </trans-unit>
        <trans-unit id="4a1d6a6dcc128bafb39f6e3e6579f2614ede9096" translate="yes" xml:space="preserve">
          <source>A 7-bit unsigned integer constant.</source>
          <target state="translated">7ビットの符号なし整数定数。</target>
        </trans-unit>
        <trans-unit id="4e392016af47c374eef4f8aaf14822a0c557c367" translate="yes" xml:space="preserve">
          <source>A 8-bit unsigned integer constant.</source>
          <target state="translated">8ビットの符号なし整数定数。</target>
        </trans-unit>
        <trans-unit id="083fa44b7c5e44320ff4ed2ae01244ea90801a78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;lo_sum&lt;/code&gt; data-linkage-table memory operand</source>
          <target state="translated">&lt;code&gt;lo_sum&lt;/code&gt; データリンクテーブルメモリ・オペランド</target>
        </trans-unit>
        <trans-unit id="f9cd2e27d673f56cc94424aa5ac780102659b79a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;switch&lt;/code&gt; statement has an operand of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントは、タイプのオペランドを持って &lt;code&gt;long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0eff00ac09b6d2be5766ddb9515db21e223caed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typeof&lt;/code&gt; construct can be used anywhere a typedef name can be used. For example, you can use it in a declaration, in a cast, or inside of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算の構築物は、どこでも使用することができtypedefの名前を使用することができます。たとえば、宣言、キャスト、または &lt;code&gt;sizeof&lt;/code&gt; や &lt;code&gt;typeof&lt;/code&gt; の内部で使用できます。</target>
        </trans-unit>
        <trans-unit id="0fcc11ba29659026ef90972ee49fd236e8ca7461" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nested function&lt;/em&gt; is a function defined inside another function. Nested functions are supported as an extension in GNU C, but are not supported by GNU C++.</source>
          <target state="translated">&lt;em&gt;ネストされた関数は、&lt;/em&gt;別の関数の内部に定義された関数です。入れ子関数はGNU Cの拡張機能としてサポートされていますが、GNU C ++ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c55a5d7e9e734b9cfd6d5b793b74655af96e5ff3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;preprocessing token&lt;/em&gt; is a &lt;em&gt;preprocessing number&lt;/em&gt; if it begins with a digit and is followed by letters, underscores, digits, periods and &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;前処理トークンが&lt;/em&gt;ある&lt;em&gt;前処理数&lt;/em&gt;が数字で始まり、文字が続く場合、下線、数字、期間および'</target>
        </trans-unit>
        <trans-unit id="226cffe8593eab9de1b46a1badbfea96e62ee6f4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; is a flow of control within the abstract machine. It is implementation defined whether or not there may be more than one thread.</source>
          <target state="translated">&lt;em&gt;スレッドは、&lt;/em&gt;抽象マシン内の制御の流れです。複数のスレッドが存在するかどうかは、実装で定義されます。</target>
        </trans-unit>
        <trans-unit id="d63439749e9d375a44c13be44c44d3b25a8cbdd3" translate="yes" xml:space="preserve">
          <source>A C++ namespace declaration can also have the visibility attribute.</source>
          <target state="translated">C++名前空間宣言は visibility 属性を持つこともできます。</target>
        </trans-unit>
        <trans-unit id="f6e3cb01289f372ad5685f7b48da04f4e60a84ec" translate="yes" xml:space="preserve">
          <source>A GNU Manual</source>
          <target state="translated">GNUマニュアル</target>
        </trans-unit>
        <trans-unit id="e5ae31d72b84a280dea45cc026a21e380e65748b" translate="yes" xml:space="preserve">
          <source>A VSX register (VSR), &lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt;. This is either an FPR (&lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs31&lt;/code&gt; are &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;) or a VR (&lt;code&gt;vs32&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt; are &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;).</source>
          <target state="translated">VSXレジスタ（VSR）、 &lt;code&gt;vs0&lt;/code&gt; &amp;hellip; &lt;code&gt;vs63&lt;/code&gt; 。これは、FPR（ &lt;code&gt;vs0&lt;/code&gt; &amp;hellip; &lt;code&gt;vs31&lt;/code&gt; は &lt;code&gt;f0&lt;/code&gt; &amp;hellip; &lt;code&gt;f31&lt;/code&gt; ）またはVR（ &lt;code&gt;vs32&lt;/code&gt; &amp;hellip; &lt;code&gt;vs63&lt;/code&gt; は &lt;code&gt;v0&lt;/code&gt; &amp;hellip; &lt;code&gt;v31&lt;/code&gt; ）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="d5003442624da7a5396a336fd4ef339c3db6eb07" translate="yes" xml:space="preserve">
          <source>A base register. Like &lt;code&gt;r&lt;/code&gt;, but &lt;code&gt;r0&lt;/code&gt; is not allowed, so &lt;code&gt;r1&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="translated">ベースレジスタ。 &lt;code&gt;r&lt;/code&gt; と同様ですが、 &lt;code&gt;r0&lt;/code&gt; は許可されていないため、 &lt;code&gt;r1&lt;/code&gt; &amp;hellip; &lt;code&gt;r31&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd8fd98a94ad304e430ad561d03982387ab58fa2" translate="yes" xml:space="preserve">
          <source>A basic &lt;code&gt;asm&lt;/code&gt; statement has the following syntax:</source>
          <target state="translated">基本的な &lt;code&gt;asm&lt;/code&gt; ステートメントの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6145aa4e1e7149a673e61fa6c454fd8a42cee7a8" translate="yes" xml:space="preserve">
          <source>A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.</source>
          <target state="translated">基本的なブロックプロファイルのカウントは、プロファイル化された実行全体の所定のパーミラージュ(すなわち、0~1000)に貢献している場合、ホットとみなされます。</target>
        </trans-unit>
        <trans-unit id="2df3f34d53b76011b7a6bb1711d67e1df403856d" translate="yes" xml:space="preserve">
          <source>A binary type trait: &lt;code&gt;true&lt;/code&gt; whenever the type arguments are the same.</source>
          <target state="translated">バイナリ型の特性：型の引数が同じ場合は常に &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a474d3c8a798ad9f41fbc155178fa260c3cbfd" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the BFINS instruction.</source>
          <target state="translated">BFINS命令に適したビットマスクです。</target>
        </trans-unit>
        <trans-unit id="1c197853a26bb6b9e64cfe3c20fc4b78dab065a2" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the MM instruction.</source>
          <target state="translated">MM命令に適したビットマスクです。</target>
        </trans-unit>
        <trans-unit id="fb82d601263ede6336b3a6d38f27a2db288988de" translate="yes" xml:space="preserve">
          <source>A bitfield mask suitable for bext or bins</source>
          <target state="translated">bext またはビンに適したビットフィールドマスク</target>
        </trans-unit>
        <trans-unit id="95088444b66d4c9478cf588a65f1dca5aa3b6e35" translate="yes" xml:space="preserve">
          <source>A c99-like declaration syntax is also allowed:</source>
          <target state="translated">c99のような宣言構文も許可されています。</target>
        </trans-unit>
        <trans-unit id="242045c1091165567c1e2bc6642eff026733baf4" translate="yes" xml:space="preserve">
          <source>A call clobbered P register.</source>
          <target state="translated">呼び出しでPのレジスターがやられた。</target>
        </trans-unit>
        <trans-unit id="6501e67efab2f7c858c0e0f7b446cd704c13a388" translate="yes" xml:space="preserve">
          <source>A call-used register in register file B (B0&amp;ndash;B9, B16&amp;ndash;B31).</source>
          <target state="translated">レジスター・ファイルB（B0&amp;ndash;B9、B16&amp;ndash;B31）の呼び出し使用レジスター。</target>
        </trans-unit>
        <trans-unit id="5a85a53751233b51746da27b56a87b1a58dd44bc" translate="yes" xml:space="preserve">
          <source>A cast from integer to pointer discards most-significant bits if the pointer representation is smaller than the integer type, extends according to the signedness of the integer type if the pointer representation is larger than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">整数からポインタへのキャストは、ポインタ表現が整数型よりも小さければ最も重要なビットを破棄し、ポインタ表現が整数型よりも大きければ整数型の符号化に従って拡張し、そうでなければビットは変更されません。</target>
        </trans-unit>
        <trans-unit id="9579e92267fbbcb00a411d24c34a20ac82cffc52" translate="yes" xml:space="preserve">
          <source>A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">ポインタから整数へのキャストは、ポインタ表現が整数型より大きい場合は最上位ビットを破棄し、ポインタ表現が整数型より小さい場合は符号拡張&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;します。それ以外の場合、ビットは変更されません。</target>
        </trans-unit>
        <trans-unit id="8d607e1d6022f86c3f2fb0150398c8747d6a9a20" translate="yes" xml:space="preserve">
          <source>A cast to a union type is a C extension not available in C++. It looks just like ordinary casts with the constraint that the type specified is a union type. You can specify the type either with the &lt;code&gt;union&lt;/code&gt; keyword or with a &lt;code&gt;typedef&lt;/code&gt; name that refers to a union. The result of a cast to a union is a temporary rvalue of the union type with a member whose type matches that of the operand initialized to the value of the operand. The effect of a cast to a union is similar to a compound literal except that it yields an rvalue like standard casts do. See &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;.</source>
          <target state="translated">共用体型へのキャストは、C ++では使用できないC拡張です。指定された型が共用体型であるという制約がある通常のキャストと同じように見えます。タイプは、 &lt;code&gt;union&lt;/code&gt; キーワードまたはユニオンを参照する &lt;code&gt;typedef&lt;/code&gt; 名のいずれかで指定できます。共用体へのキャストの結果は、型がオペランドの値に初期化されたオペランドの型と一致するメンバーを持つ共用体型の一時的な右辺値です。共用体へのキャストの効果は、標準のキャストが行うように右辺値を生成することを除いて、複合リテラルに似ています。&lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;複合リテラルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="75e1479f2ae72adba50e5d40e09a4fb8d576ce4d" translate="yes" xml:space="preserve">
          <source>A combination of</source>
          <target state="translated">の組み合わせ</target>
        </trans-unit>
        <trans-unit id="de7ce58153dc3aa9a8a53f607567323d0809bd31" translate="yes" xml:space="preserve">
          <source>A comma-separated list of C expressions read by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;AssemblerTemplate&lt;/var&gt; の指示によって読み取られるC式のコンマ区切りリスト。空のリストが許可されます。&lt;a href=&quot;#InputOperands&quot;&gt;InputOperandsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5b5d944665cc53cab2f2ad1f645c434c5620d068" translate="yes" xml:space="preserve">
          <source>A comma-separated list of registers or other values changed by the &lt;var&gt;AssemblerTemplate&lt;/var&gt;, beyond those listed as outputs. An empty list is permitted. See &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;.</source>
          <target state="translated">出力としてリストされているもの以外に、 &lt;var&gt;AssemblerTemplate&lt;/var&gt; によって変更されたレジスターまたはその他の値のコンマ区切りリスト。空のリストが許可されます。&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registersを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="65d21196a0c3e5a9f693ae19ae22931182555110" translate="yes" xml:space="preserve">
          <source>A comma-separated list of the C variables modified by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;AssemblerTemplate&lt;/var&gt; の命令によって変更されたC変数のカンマ区切りリスト。空のリストが許可されます。&lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperandsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="57ff1562fe61f1f887425ce2cee86f1d3d93e844" translate="yes" xml:space="preserve">
          <source>A compiler conforms to an ABI if it generates code that follows all of the specifications enumerated by that ABI. A library conforms to an ABI if it is implemented according to that ABI. An application conforms to an ABI if it is built using tools that conform to that ABI and does not contain source code that specifically changes behavior specified by the ABI.</source>
          <target state="translated">コンパイラは、そのABIで列挙されたすべての仕様に従ったコードを生成する場合、ABIに準拠します。ライブラリは、そのABIに従って実装されていればABIに準拠します。アプリケーションは、そのABIに準拠したツールを使用して構築され、ABIで指定された動作を特に変更するソースコードを含まない場合、ABIに準拠します。</target>
        </trans-unit>
        <trans-unit id="41c80a94e954da6243e86405854638e4aa3a6477" translate="yes" xml:space="preserve">
          <source>A compound literal looks like a cast of a brace-enclosed aggregate initializer list. Its value is an object of the type specified in the cast, containing the elements specified in the initializer. Unlike the result of a cast, a compound literal is an lvalue. ISO C99 and later support compound literals. As an extension, GCC supports compound literals also in C90 mode and in C++, although as explained below, the C++ semantics are somewhat different.</source>
          <target state="translated">複合リテラルは、中括弧で囲まれた集約型初期化子リストのキャストのように見えます。その値は、初期化子で指定された要素を含む、キャストで指定された型のオブジェクトです。キャストの結果とは異なり、複合リテラルはlvalueです。ISO C99 以降では、複合リテラルがサポートされています。拡張機能として、GCC は C90 モードと C++で複合リテラルをサポートしていますが、後述するように C++のセマンティクスは多少異なります。</target>
        </trans-unit>
        <trans-unit id="f6dd9a1a8f56216b2f65e6b7a8c29b8ee8f55106" translate="yes" xml:space="preserve">
          <source>A compound statement enclosed in parentheses may appear as an expression in GNU C. This allows you to use loops, switches, and local variables within an expression.</source>
          <target state="translated">括弧で囲まれた複合文は、GNU Cの式として現れることがあります。これにより、式の中でループ、スイッチ、ローカル変数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="8a72443d4592827fe4ca85bea82301121049b91e" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 9899:1990, ISO/IEC 9899:1999 and ISO/IEC 9899:2011 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">ISO Cの適合実装は、「実装定義」と指定されている各領域での動作の選択を文書化する必要があります。以下は、ISO / IEC 9899：1990、ISO / IEC 9899：1999、およびISO / IEC 9899：2011規格のセクション番号とともに、そのような領域をすべてリストしています。一部の領域は、標準の1つのバージョンで実装定義のみです。</target>
        </trans-unit>
        <trans-unit id="d4cb4e2bf524da1d62affddb40dfb630800239af" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C++ is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 14882:1998 and ISO/IEC 14882:2003 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">ISO C ++の適合実装は、「実装定義」と指定されている各領域での動作の選択を文書化する必要があります。以下は、ISO / IEC 14882：1998およびISO / IEC 14882：2003規格のセクション番号とともに、そのような領域すべてをリストしています。一部の領域は、標準の1つのバージョンで実装定義のみです。</target>
        </trans-unit>
        <trans-unit id="7b29cb3b319ec95ede4a30707c842823bf94b7db" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;code&gt;sizeof&lt;/code&gt; is also allowed on &lt;code&gt;void&lt;/code&gt; and on function types, and returns 1.</source>
          <target state="translated">この結果、 &lt;code&gt;sizeof&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; と関数型でも許可され、1を返します。</target>
        </trans-unit>
        <trans-unit id="7cad9a0baf039ead351d859d05c0365e63661fb9" translate="yes" xml:space="preserve">
          <source>A constant between -255 and 0 inclusive.</source>
          <target state="translated">255から0までの間の定数です。</target>
        </trans-unit>
        <trans-unit id="4f8cd8bf499f2d6d54a71ffc2d3e21cf7ef45e36" translate="yes" xml:space="preserve">
          <source>A constant between -3 and 0 inclusive.</source>
          <target state="translated">3から0までの間の定数です。</target>
        </trans-unit>
        <trans-unit id="19428213d0a5f62ee0574191f3ae2f2ddd996015" translate="yes" xml:space="preserve">
          <source>A constant between -4 and -1 inclusive.</source>
          <target state="translated">4から-1までの間の定数。</target>
        </trans-unit>
        <trans-unit id="d2fbc8414f61903ae333dcf7ac7a844a0c7b23fe" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 255 inclusive.</source>
          <target state="translated">0から255までの間の定数。</target>
        </trans-unit>
        <trans-unit id="12f6b4cb352959b8bca5dac3da05fd53e64fa274" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 3 inclusive.</source>
          <target state="translated">0から3の間の定数。</target>
        </trans-unit>
        <trans-unit id="da945b1c391dff3ac6bc6d5fbd2be9149c62266c" translate="yes" xml:space="preserve">
          <source>A constant between 1 and 4 inclusive.</source>
          <target state="translated">1から4までの間の定数。</target>
        </trans-unit>
        <trans-unit id="c0aca6087bfc1e63cba0551e38002443555e0fac" translate="yes" xml:space="preserve">
          <source>A constant for a bitfield width (1 &amp;hellip; 16)</source>
          <target state="translated">ビットフィールド幅の定数（1&amp;hellip;16）</target>
        </trans-unit>
        <trans-unit id="6d56856d82b6a91412eed6d7df5c640079002d4d" translate="yes" xml:space="preserve">
          <source>A constant in the range -128 to 127, inclusive.</source>
          <target state="translated">128~127の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="17b05b4c60ac27d1e72d8030837136d5fa0be31c" translate="yes" xml:space="preserve">
          <source>A constant in the range -256 to 255, inclusive.</source>
          <target state="translated">256~255の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="695a694abf391bc605e989d6eb5dbacf14f628c2" translate="yes" xml:space="preserve">
          <source>A constant in the range -32768 to 32767, inclusive.</source>
          <target state="translated">32768~32767の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="2e51455a9b3294a37777151389f3c055d9628f83" translate="yes" xml:space="preserve">
          <source>A constant in the range -65535 to -1 (inclusive).</source>
          <target state="translated">65535から-1(含む)の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="a2eafd56ff7c3244c125e89f98b5047314116000" translate="yes" xml:space="preserve">
          <source>A constant in the range -8388608 to 8388607, inclusive.</source>
          <target state="translated">8388608~8388607の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="097b361ff7733f96fe3db5433e37aba686b852b1" translate="yes" xml:space="preserve">
          <source>A constant in the range 0 to 15, inclusive.</source>
          <target state="translated">0~15の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="a36455a425b9727ae75ec8f878c7951252ab00ab" translate="yes" xml:space="preserve">
          <source>A constant in the range 1 to 65535 (inclusive).</source>
          <target state="translated">1~65535(含む)の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="2a58c4a3cc79eb84153470348476e3f269dac278" translate="yes" xml:space="preserve">
          <source>A constant in the range [-64, 63] for shift/rotate instructions.</source>
          <target state="translated">シフト/回転命令用の[-64,63]の範囲の定数です。</target>
        </trans-unit>
        <trans-unit id="10785db1e9d20c3cdec60f076d95570e2881e446" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to -255.</source>
          <target state="translated">0~-255の範囲の定数です。</target>
        </trans-unit>
        <trans-unit id="5b0495335754f2b58bcc5c273f50a0ad47fb4980" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to 255.</source>
          <target state="translated">0~255の範囲の定数。</target>
        </trans-unit>
        <trans-unit id="3df560572af8da9f608ecbfa457628a58591cc1d" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movcc&lt;/code&gt; instructions (11-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movcc&lt;/code&gt; 命令でサポートされる範囲の定数（11ビット符号付き即値）</target>
        </trans-unit>
        <trans-unit id="e6b217cb7e92669add738eef6823abf207c1faff" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movrcc&lt;/code&gt; instructions (10-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movrcc&lt;/code&gt; 命令でサポートされている範囲の定数（10ビット符号付き即値）</target>
        </trans-unit>
        <trans-unit id="f72ba093b9d9c51600024c95028a46b05718f280" translate="yes" xml:space="preserve">
          <source>A constant that cannot be loaded using &lt;code&gt;lui&lt;/code&gt;, &lt;code&gt;addiu&lt;/code&gt; or &lt;code&gt;ori&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lui&lt;/code&gt; 、 &lt;code&gt;addiu&lt;/code&gt; 、 &lt;code&gt;ori&lt;/code&gt; を使用してロードできない定数。</target>
        </trans-unit>
        <trans-unit id="7c2d44283a3acc9bdc683ea83a3f874e52a46752" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit clear.</source>
          <target state="translated">きっちり1ビットクリアしている定数。</target>
        </trans-unit>
        <trans-unit id="cfb3a0520f6d9864d7a1976144208cbbd9174378" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit set.</source>
          <target state="translated">正確に1ビットが設定されている定数。</target>
        </trans-unit>
        <trans-unit id="f067235028290b700b44d1ece783ed553e206e2b" translate="yes" xml:space="preserve">
          <source>A constant that is not between 2 and 15 inclusive.</source>
          <target state="translated">2と15の間に含まれていない定数。</target>
        </trans-unit>
        <trans-unit id="dc8b34473e04adc25852b0eed10f1d174b004494" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bclr instruction.</source>
          <target state="translated">imm15uの範囲外の定数ですが、bclr命令では問題ありません。</target>
        </trans-unit>
        <trans-unit id="c6a1b8bc59cee8c8f6571d6cc94e881414d8fd98" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bset instruction.</source>
          <target state="translated">imm15uの範囲内ではありませんが、bset命令ではOKな定数です。</target>
        </trans-unit>
        <trans-unit id="5a081f0e675d939eda6d41b659eb1a4796698f55" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for btgl instruction.</source>
          <target state="translated">imm15uの範囲外の定数ですが、BTGL命令では問題ありません。</target>
        </trans-unit>
        <trans-unit id="739639d0dba642847055adad6d408a8462cefd56" translate="yes" xml:space="preserve">
          <source>A constant whose compliment value is in the range of imm15u and ok for bitci instruction.</source>
          <target state="translated">ビットシー命令の補完値が imm15u と ok の範囲内にある定数です。</target>
        </trans-unit>
        <trans-unit id="772d4006b3b3b9f5dbb1eb8305ae0da40df09812" translate="yes" xml:space="preserve">
          <source>A decimal number representing clock cycles.</source>
          <target state="translated">クロックサイクルを表す10進数。</target>
        </trans-unit>
        <trans-unit id="0e4012d6617bb64507db563d81889013cebe2316" translate="yes" xml:space="preserve">
          <source>A declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached and that is associated with a named &lt;code&gt;target&lt;/code&gt; must be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weakref&lt;/code&gt; がアタッチされ、名前付き &lt;code&gt;target&lt;/code&gt; 関連付けられている宣言は &lt;code&gt;static&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="871d38c63e186ae7cd0f311fcbbf75d49f235704" translate="yes" xml:space="preserve">
          <source>A deprecated synonym for</source>
          <target state="translated">非推奨の同義語</target>
        </trans-unit>
        <trans-unit id="35b2c49fceb685c2e6ddfd9b7ccde26327c395da" translate="yes" xml:space="preserve">
          <source>A diagnostic can contain zero or more locations. Each location has up to three positions within it: a &lt;code&gt;caret&lt;/code&gt; position and optional &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;finish&lt;/code&gt; positions. A location can also have an optional &lt;code&gt;label&lt;/code&gt; string. For example, this error:</source>
          <target state="translated">診断には0個以上の場所を含めることができます。各場所には、 &lt;code&gt;caret&lt;/code&gt; ポジションとオプションの &lt;code&gt;start&lt;/code&gt; および &lt;code&gt;finish&lt;/code&gt; ポジションの3つのポジションがあります。場所には、オプションの &lt;code&gt;label&lt;/code&gt; 文字列を含めることもできます。たとえば、次のエラー：</target>
        </trans-unit>
        <trans-unit id="1d3956dd1850c8ee01dd888bb0a0a3023c553d32" translate="yes" xml:space="preserve">
          <source>A diagnostic has a &lt;code&gt;kind&lt;/code&gt;. If this is &lt;code&gt;warning&lt;/code&gt;, then there is an &lt;code&gt;option&lt;/code&gt; key describing the command-line option controlling the warning.</source>
          <target state="translated">診断には &lt;code&gt;kind&lt;/code&gt; ます。これが &lt;code&gt;warning&lt;/code&gt; 場合、警告を制御するコマンドラインオプションを説明する &lt;code&gt;option&lt;/code&gt; キーがあります。</target>
        </trans-unit>
        <trans-unit id="64d7123704bf7fa0f1e73d01535513a0dc7c2748" translate="yes" xml:space="preserve">
          <source>A different sort of disaster results from the use of this flag for a register in which function values may be returned.</source>
          <target state="translated">関数値が返される可能性のあるレジスタにこのフラグを使用すると、別の種類の災害が発生します。</target>
        </trans-unit>
        <trans-unit id="c32446d7ea192a83db5ac54835cfe4c3d265fe83" translate="yes" xml:space="preserve">
          <source>A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop.</source>
          <target state="translated">swing modulo スケジューラがループをスケジューリングする際に使用する上限値を調整するための因子。</target>
        </trans-unit>
        <trans-unit id="a7b34a84c6690fd83c05d2fa16fc0c287bb3da1b" translate="yes" xml:space="preserve">
          <source>A feature to report any failure to conform to ISO C might be useful in some instances, but would require considerable additional work and would be quite different from</source>
          <target state="translated">ISO C に適合していないことを報告する機能は、いくつかのインスタンスでは有用かもしれませんが、かなりの追加作業が必要になります。</target>
        </trans-unit>
        <trans-unit id="b2a29cc3baea0c08d4a825d0752f1c7c91b7a29c" translate="yes" xml:space="preserve">
          <source>A few standard library functions, such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt;, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them &lt;code&gt;noreturn&lt;/code&gt; to tell the compiler this fact. For example,</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; や &lt;code&gt;exit&lt;/code&gt; などのいくつかの標準ライブラリ関数は戻ることができません。GCCはこれを自動的に認識します。一部のプログラムは、決して戻らない独自の関数を定義しています。それらを &lt;code&gt;noreturn&lt;/code&gt; と宣言して、コンパイラにこの事実を伝えることができます。例えば、</target>
        </trans-unit>
        <trans-unit id="cb463f377ea974dd6c90f4d5e14fe7753fa59c05" translate="yes" xml:space="preserve">
          <source>A file name that does not end in a special recognized suffix is considered to name an object file or library. (Object files are distinguished from libraries by the linker according to the file contents.) If linking is done, these object files are used as input to the linker.</source>
          <target state="translated">特別に認識された接尾辞で終わらないファイル名は、オブジェクトファイルまたはライブラリの名前とみなされます。(オブジェクト・ファイルはファイルの内容によってリンカがライブラリと区別します)。リンクされた場合は、これらのオブジェクトファイルがリンカへの入力として使用されます。</target>
        </trans-unit>
        <trans-unit id="31a3ef8a1f914c346a656751b3762e1f23b6d753" translate="yes" xml:space="preserve">
          <source>A file&amp;rsquo;s &lt;em&gt;basename&lt;/em&gt; is the name stripped of all leading path information and of trailing suffixes, such as &amp;lsquo;</source>
          <target state="translated">ファイルの&lt;em&gt;ベース名&lt;/em&gt;は、 'などのすべての先行パス情報と後続サフィックスを取り除いた名前です。</target>
        </trans-unit>
        <trans-unit id="3cb6c35b9f770d58e9e6ae1be71711d84191b278" translate="yes" xml:space="preserve">
          <source>A floating point constant 0.0</source>
          <target state="translated">浮動小数点定数 0.0</target>
        </trans-unit>
        <trans-unit id="ac7c31fdc5f9ddf8dfae82582cc34a55de257130" translate="yes" xml:space="preserve">
          <source>A floating point register (FPR), &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;.</source>
          <target state="translated">浮動小数点レジスタ（FPR）、 &lt;code&gt;f0&lt;/code&gt; &amp;hellip; &lt;code&gt;f31&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="637820768e2434914c48d73ef03a77823d03c37c" translate="yes" xml:space="preserve">
          <source>A floating point register. This is the same as &lt;code&gt;f&lt;/code&gt; nowadays; historically &lt;code&gt;f&lt;/code&gt; was for single-precision and &lt;code&gt;d&lt;/code&gt; was for double-precision floating point.</source>
          <target state="translated">浮動小数点レジスタ。これは最近の &lt;code&gt;f&lt;/code&gt; と同じです。歴史的に、 &lt;code&gt;f&lt;/code&gt; は単精度を表し、 &lt;code&gt;d&lt;/code&gt; は倍精度浮動小数点を表していました。</target>
        </trans-unit>
        <trans-unit id="35a05594f7fa158ed7e1a662576eede9b7714efc" translate="yes" xml:space="preserve">
          <source>A floating-point condition code register.</source>
          <target state="translated">浮動小数点の条件コードレジスタです。</target>
        </trans-unit>
        <trans-unit id="6a5e282398dc91c4802485c8333b0a476c54fe7d" translate="yes" xml:space="preserve">
          <source>A floating-point register (if available).</source>
          <target state="translated">浮動小数点レジスタ(利用可能な場合)。</target>
        </trans-unit>
        <trans-unit id="f68f63f0de9f100e3091753e0a87b4bdcab324f8" translate="yes" xml:space="preserve">
          <source>A floating-point register (if availiable).</source>
          <target state="translated">浮動小数点レジスタ(利用可能な場合)。</target>
        </trans-unit>
        <trans-unit id="1d93f84bcb43d9808ea6d43552092e130f8e5d2b" translate="yes" xml:space="preserve">
          <source>A fourth version of the C standard, known as &lt;em&gt;C11&lt;/em&gt;, was published in 2011 as ISO/IEC 9899:2011. (While in development, drafts of this standard version were referred to as &lt;em&gt;C1X&lt;/em&gt;.) GCC has substantially complete support for this standard, enabled with</source>
          <target state="translated">&lt;em&gt;C11&lt;/em&gt;として知られるC規格の4番目のバージョンは、ISO / IEC 9899：2011として2011年に公開されました。（開発中、この標準バージョンのドラフトは&lt;em&gt;C1X&lt;/em&gt;と呼ばれてい&lt;em&gt;ました&lt;/em&gt;。）GCCはこの標準を実質的に完全にサポートしており、</target>
        </trans-unit>
        <trans-unit id="55257df904754ff4c13989bc1d064dbb261da350" translate="yes" xml:space="preserve">
          <source>A framework directory is a directory with frameworks in it. A framework is a directory with a</source>
          <target state="translated">フレームワークディレクトリとは、フレームワークが入っているディレクトリのことです。フレームワークのディレクトリは</target>
        </trans-unit>
        <trans-unit id="5ba28f66c2dca176d361d13d2cfcd58e64de11b1" translate="yes" xml:space="preserve">
          <source>A function declared external in one block and then used after the end of the block.</source>
          <target state="translated">1つのブロックで外部に宣言された関数で、ブロックの終了後に使用されます。</target>
        </trans-unit>
        <trans-unit id="31442efa0c2c801bce0a5591e6aced95492894fb" translate="yes" xml:space="preserve">
          <source>A function may be given the attribute &lt;code&gt;no_instrument_function&lt;/code&gt;, in which case this instrumentation is not done. This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory). See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">関数には属性 &lt;code&gt;no_instrument_function&lt;/code&gt; を指定できます。その場合、この計測は行われません。これは、たとえば、上記のプロファイリング関数、高優先度の割り込みルーチン、およびプロファイリング関数を安全に呼び出すことができない関数（おそらく、プロファイリングルーチンが出力を生成するか、メモリを割り当てる場合はシグナルハンドラー）に使用できます。&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a3b5c7a586587400ee92ec622d45d7b4bfd1b3e3" translate="yes" xml:space="preserve">
          <source>A function parameter is declared without a type specifier in K&amp;amp;R-style functions:</source>
          <target state="translated">関数パラメーターは、K＆Rスタイルの関数で型指定子なしで宣言されます。</target>
        </trans-unit>
        <trans-unit id="4a55e26416d74770259268d8b952c442c03d140f" translate="yes" xml:space="preserve">
          <source>A function-like macro that appears without arguments.</source>
          <target state="translated">引数なしで現れる関数のようなマクロ。</target>
        </trans-unit>
        <trans-unit id="debf2118f99ae7d5fcef4420f2e62948ac9db34c" translate="yes" xml:space="preserve">
          <source>A further version of the C standard, known as &lt;em&gt;C2X&lt;/em&gt;, is under development; experimental and incomplete support for this is enabled with</source>
          <target state="translated">&lt;em&gt;C2X&lt;/em&gt;として知られるC標準の別のバージョンが開発中です。これに対する実験的で不完全なサポートは、</target>
        </trans-unit>
        <trans-unit id="dd4d39a738de423b3a8f7321b1548155edc7437d" translate="yes" xml:space="preserve">
          <source>A general purpose register (GPR), &lt;code&gt;r0&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="translated">汎用レジスタ（GPR）、 &lt;code&gt;r0&lt;/code&gt; &amp;hellip; &lt;code&gt;r31&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a8db3cc1b660b8c40d207078f962c2f15753e61" translate="yes" xml:space="preserve">
          <source>A general register (&lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r31&lt;/code&gt;).</source>
          <target state="translated">汎用レジスター（ &lt;code&gt;r0&lt;/code&gt; から &lt;code&gt;r31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4c9d8cf8321530b1a940502b30ac5acf72522d1e" translate="yes" xml:space="preserve">
          <source>A general-purpose register. This is equivalent to &lt;code&gt;r&lt;/code&gt; unless generating MIPS16 code, in which case the MIPS16 register set is used.</source>
          <target state="translated">汎用レジスター。これは、MIPS16コードを生成しない限り &lt;code&gt;r&lt;/code&gt; と同等です。その場合、MIPS16レジスタセットが使用されます。</target>
        </trans-unit>
        <trans-unit id="d2030f94473ff72afe09286a5000f598b54444ee" translate="yes" xml:space="preserve">
          <source>A generic CPU with 64-bit extensions.</source>
          <target state="translated">64ビット拡張した汎用CPU。</target>
        </trans-unit>
        <trans-unit id="1e6fe121c0bf0b0f224a8bd42e66a0a587219c64" translate="yes" xml:space="preserve">
          <source>A given program is written in one or the other of these two dialects. The program stands a chance to work on most any machine if it is compiled with the proper dialect. It is unlikely to work at all if compiled with the wrong dialect.</source>
          <target state="translated">与えられたプログラムは、これら2つの方言のうちの1つまたはもう1つで書かれています。適切な方言でコンパイルされていれば、そのプログラムはほとんどのマシンで動作する可能性があります。間違った方言でコンパイルされた場合は、全く動作しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c5058629f496fbd3a9b20ab2118be652c13eb69" translate="yes" xml:space="preserve">
          <source>A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by &amp;ldquo;How To Write Shared Libraries&amp;rdquo; by Ulrich Drepper (which can be found at &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt;)&amp;mdash;however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public. This is the norm with DLLs on Windows and with</source>
          <target state="translated">ELFシンボルが正しい可視性を持っていることを保証することによって提供される利点の適切な説明は、Ulrich Drepper（&lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/にあります&lt;/a&gt;）による「共有ライブラリの書き方」によって提供されます。ただし、デフォルトがpublicのときに非表示にマークを付けるこのオプションによって可能になった優れたソリューションは、デフォルトを非表示にしてパブリックにマークすることです。これは、WindowsのDLLと</target>
        </trans-unit>
        <trans-unit id="4b92b6d35d4ef9edd4bc988a5b041656a4bfb9c4" translate="yes" xml:space="preserve">
          <source>A local label declaration looks like this:</source>
          <target state="translated">ローカルラベル宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4eae759733edfeb41cf185aaf992eb0590b9b2a1" translate="yes" xml:space="preserve">
          <source>A local variable or class data member declared both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;__thread&lt;/code&gt; gives the variable or member thread storage duration.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; と &lt;code&gt;__thread&lt;/code&gt; の両方で宣言されたローカル変数またはクラスデータメンバーは、変数またはメンバーのスレッドストレージ期間を提供します。</target>
        </trans-unit>
        <trans-unit id="cbc079ebb13b05a28fc7e6b5c8e9b7e32b012d41" translate="yes" xml:space="preserve">
          <source>A loop expected to iterate at least the selected number of iterations is aligned.</source>
          <target state="translated">少なくとも選択した回数以上の反復処理を行うことが期待されるループを整列させます。</target>
        </trans-unit>
        <trans-unit id="e6e2fdd4a6e2c1dbe43d588ddf3a77eab778b7d1" translate="yes" xml:space="preserve">
          <source>A member of a union object is accessed using a member of a different type (C90 6.3.2.3).</source>
          <target state="translated">ユニオンオブジェクトのメンバは、異なる型のメンバを用いてアクセスする(C90 6.3.2.3)。</target>
        </trans-unit>
        <trans-unit id="d48a8ba2b56e035d8312e0298f36fac9054a9681" translate="yes" xml:space="preserve">
          <source>A memory address based on Y or Z pointer with displacement.</source>
          <target state="translated">変位を伴うYまたはZポインタに基づくメモリアドレス。</target>
        </trans-unit>
        <trans-unit id="3b84dcc8ac9137874012ebfd9eadab8bb949fee4" translate="yes" xml:space="preserve">
          <source>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes</source>
          <target state="translated">SI,DI,SF,DFモードでのロード/ストアペア命令に適したメモリアドレス</target>
        </trans-unit>
        <trans-unit id="0bb3634ff6bc0ca41e70f28fef8acf81311e449f" translate="yes" xml:space="preserve">
          <source>A memory address that will work with the &lt;code&gt;lq&lt;/code&gt; and &lt;code&gt;stq&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;lq&lt;/code&gt; および &lt;code&gt;stq&lt;/code&gt; 命令で機能するメモリアドレス。</target>
        </trans-unit>
        <trans-unit id="e82efce1d813a82c9a30ae4a9287debad5d5c479" translate="yes" xml:space="preserve">
          <source>A memory address which uses a single base register with no offset</source>
          <target state="translated">オフセットのない単一のベースレジスタを使用するメモリアドレス。</target>
        </trans-unit>
        <trans-unit id="f6aff7695c779a2c12c72d4158e0a44c684b7687" translate="yes" xml:space="preserve">
          <source>A memory operand accessed with indexed or indirect addressing.</source>
          <target state="translated">インデックス付きまたは間接アドレッシングでアクセスされるメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="9aa32937bb87c45112562669984946bc4a880e43" translate="yes" xml:space="preserve">
          <source>A memory operand addressed by just a base register.</source>
          <target state="translated">ベースレジスタだけでアドレスを指定するメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="d889b3934276ee507afa50f38217acb1e8a60ca1" translate="yes" xml:space="preserve">
          <source>A memory operand for floating-point loads and stores</source>
          <target state="translated">浮動小数点のロードおよびストアのためのメモリオペランド</target>
        </trans-unit>
        <trans-unit id="76dff8679e9a8f7ce2eb5bb8fad71047c6747dbc" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, but only if the address is &lt;em&gt;offsettable&lt;/em&gt;. This means that adding a small integer (actually, the width in bytes of the operand, as determined by its machine mode) may be added to the address and the result is also a valid memory address.</source>
          <target state="translated">メモリオペランドは使用できますが、アドレスが&lt;em&gt;offsettableの&lt;/em&gt;場合のみです。これは、小さな整数（実際には、マシンモードによって決定されるオペランドのバイト単位の幅）をアドレスに追加でき、その結果も有効なメモリアドレスになることを意味します。</target>
        </trans-unit>
        <trans-unit id="388671fe2c36d60a932779a67c16d85d78ac2d17" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used for the general memory constraint can be re-defined by a back end using the &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; macro.</source>
          <target state="translated">マシンが一般的にサポートするあらゆる種類のアドレスで、メモリオペランドが許可されます。一般的なメモリ制約に使用される文字は、 &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; マクロを使用してバックエンドで再定義できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e12c184fcd9f0721bc91e2359dd6f356789155c7" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for Nios II R2 load/store exclusive instructions.</source>
          <target state="translated">Nios II R2 のロード/ストア専用命令に適したメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="7146411d4e212e3eace6ea02064bc67368c7d22e" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for load/store IO and cache instructions.</source>
          <target state="translated">ロード/ストアIOやキャッシュ命令に適したメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="40ed4ba7f90bf88673d73789aca447219b51285c" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for the ISA 3.0 vector d-form instructions.</source>
          <target state="translated">ISA 3.0のベクトルdフォーム命令に適したメモリオペランドです。</target>
        </trans-unit>
        <trans-unit id="84bfbe27f0967bbd8165fcff340f78cb41e95ca2" translate="yes" xml:space="preserve">
          <source>A memory operand that can be used as the destination operand of an integer store instruction</source>
          <target state="translated">整数ストア命令のデスティネーション・オペランドとして使用できるメモリ・オペランド。</target>
        </trans-unit>
        <trans-unit id="96695f63007ab0923706713901f4b85b969e2a0a" translate="yes" xml:space="preserve">
          <source>A memory operand that is not offsettable. In other words, anything that would fit the &amp;lsquo;</source>
          <target state="translated">オフセットできないメモリオペランド。言い換えれば、「</target>
        </trans-unit>
        <trans-unit id="1a801a13c9b53ba2ca78c13cc2cdf8d621afb8bd" translate="yes" xml:space="preserve">
          <source>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as &lt;code&gt;ll&lt;/code&gt; and &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ll&lt;/code&gt; および &lt;code&gt;sc&lt;/code&gt; と同じアドレッシングモードの命令での使用に適した、ベースレジスタとオフセットによってアドレスが形成されるメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="0cf579681538dd24f4c522430fbc1d9db816f237" translate="yes" xml:space="preserve">
          <source>A memory operand with autodecrement addressing (either predecrement or postdecrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; this constraint is only allowed if the operand is used exactly once in an instruction that can handle the side effects. Not using an operand with &amp;lsquo;</source>
          <target state="translated">自動減分アドレッシング（前減分または後減分）を備えたメモリオペランドが許可されます。インライン &lt;code&gt;asm&lt;/code&gt; では、この制約は、副作用を処理できる命令でオペランドが1回だけ使用される場合にのみ許可されます。'でオペランドを使用していません</target>
        </trans-unit>
        <trans-unit id="cdc334ade8276d0cf5a4c832b12ab9caa48613bc" translate="yes" xml:space="preserve">
          <source>A memory operand with autoincrement addressing (either preincrement or postincrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; the same restrictions as for &amp;lsquo;</source>
          <target state="translated">自動インクリメントアドレッシング（プリインクリメントまたはポストインクリメント）を備えたメモリオペランドが許可されます。インライン &lt;code&gt;asm&lt;/code&gt; では 'と同じ制限</target>
        </trans-unit>
        <trans-unit id="5ac646a0970be5dfa33196ede31cf6694433d2fe" translate="yes" xml:space="preserve">
          <source>A memory operand. Normally, &lt;code&gt;m&lt;/code&gt; does not allow addresses that update the base register. If the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; in an &lt;code&gt;asm&lt;/code&gt; statement if that &lt;code&gt;asm&lt;/code&gt; statement accesses the operand exactly once. The &lt;code&gt;asm&lt;/code&gt; statement must also use &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; as a placeholder for the &amp;ldquo;update&amp;rdquo; flag in the corresponding load or store instruction. For example:</source>
          <target state="translated">メモリオペランド。通常、 &lt;code&gt;m&lt;/code&gt; はベースレジスタを更新するアドレスを許可しません。もし &lt;code&gt;&amp;lt;&lt;/code&gt; または &lt;code&gt;&amp;gt;&lt;/code&gt; 制約がまた、使用されている彼らが許可されているので、その場合のPowerPCの目標にそれが使用するだけで安全である &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; で &lt;code&gt;asm&lt;/code&gt; その場合のステートメント &lt;code&gt;asm&lt;/code&gt; 文は正確に一度のオペランドにアクセスします。 &lt;code&gt;asm&lt;/code&gt; ステートメントも使用する必要があり &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; 対応するロードまたはストア命令で「更新」フラグのためのプレースホルダとして。例えば：</target>
        </trans-unit>
        <trans-unit id="a4c1412da74dea8e31160c68dd4c58d9ddd39d1e" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for VFP load/store insns (reg+constant offset)</source>
          <target state="translated">VFPのロード/ストア・インスタンスに適したメモリ・リファレンス(reg+定数オフセット)</target>
        </trans-unit>
        <trans-unit id="3a8bf2f192d44bf25c5dafeee0b8eaa22bcc9154" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for iWMMXt load/store instructions.</source>
          <target state="translated">iWMMXtのロード/ストア命令に適したメモリリファレンスです。</target>
        </trans-unit>
        <trans-unit id="4b919c81ffb39ef6f8f9eb3d7ccc854afd2048d5" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for the ARMv4 ldrsb instruction.</source>
          <target state="translated">ARMv4のldrsb命令に適したメモリ参照。</target>
        </trans-unit>
        <trans-unit id="0281e56b013121500cc01f595e9459e28872a62b" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack pop.</source>
          <target state="translated">スタックポップであるメモリ参照。</target>
        </trans-unit>
        <trans-unit id="19169aa6dfaeac0eed19cdca087e18730184a143" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack push.</source>
          <target state="translated">スタックプッシュであるメモリ参照。</target>
        </trans-unit>
        <trans-unit id="9f8594bf5c6cb542733511c9002f352d41b3d7e8" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode, but not auto-increment or auto-decrement.</source>
          <target state="translated">オプコード内でエンコードされているが、オートインクリメントやオートデクリメントではないメモリ参照。</target>
        </trans-unit>
        <trans-unit id="261f1d2ca930e0206ac633c0e47452ba885dfea6" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode.</source>
          <target state="translated">オプトコード内でエンコードされたメモリ参照。</target>
        </trans-unit>
        <trans-unit id="9cafdb6d926c7b33945a0f45773363bd841f1c97" translate="yes" xml:space="preserve">
          <source>A memory reference that refers to a constant address of known value.</source>
          <target state="translated">既知の値の定数アドレスを参照するメモリ参照。</target>
        </trans-unit>
        <trans-unit id="4d28cbf28c6da1c555a93c693a0088131b65d6af" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;BC&lt;/code&gt;, &lt;code&gt;DE&lt;/code&gt;, or &lt;code&gt;HL&lt;/code&gt; for the address, for calls.</source>
          <target state="translated">呼び出しの場合、アドレスに &lt;code&gt;AX&lt;/code&gt; 、 &lt;code&gt;BC&lt;/code&gt; 、 &lt;code&gt;DE&lt;/code&gt; 、または &lt;code&gt;HL&lt;/code&gt; を使用するメモリ参照。</target>
        </trans-unit>
        <trans-unit id="ccd702a76b4ec6cf431d1b3b13c087fda1a005cc" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;BC&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">&lt;code&gt;BC&lt;/code&gt; をベースレジスタとして使用し、オプションのオフセットを使用したメモリ参照。</target>
        </trans-unit>
        <trans-unit id="1b8a2311d7274d21eb0ecc9fab5c05d859421673" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">&lt;code&gt;DE&lt;/code&gt; をベースレジスタとして使用し、オプションのオフセットを使用したメモリ参照。</target>
        </trans-unit>
        <trans-unit id="70d9c96a11dbdafd4cd2e7e236553a508e4c91e1" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">&lt;code&gt;DE&lt;/code&gt; をベースレジスタとして使用し、オフセットなしのメモリ参照。</target>
        </trans-unit>
        <trans-unit id="e072e18db9eb6bf209deec68cb4227fc0ad73751" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; as the index register.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; をベースレジスタとして使用し、 &lt;code&gt;B&lt;/code&gt; または &lt;code&gt;C&lt;/code&gt; をインデックスレジスタとして使用するメモリ参照。</target>
        </trans-unit>
        <trans-unit id="df6dc5b742ae15cb0c4a64ea30738791b4c31ce2" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; をベースレジスタとして使用し、オプションの1バイトオフセットのメモリ参照。</target>
        </trans-unit>
        <trans-unit id="ddc26c1495756f4b844ddb7cea2453b5108af343" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">オフセットなしの &lt;code&gt;HL&lt;/code&gt; をベースレジスタとして使用するメモリ参照。</target>
        </trans-unit>
        <trans-unit id="dd84b756a68010a9ef8c97c933ab58752c08401e" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;SP&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; をベースレジスタとして使用するメモリ参照。オプションで1バイトのオフセットがあります。</target>
        </trans-unit>
        <trans-unit id="8838226960a63f5221b0e15609b574e60c61f473" translate="yes" xml:space="preserve">
          <source>A memory reference using any 16-bit register pair for the address, for calls.</source>
          <target state="translated">任意の16ビットのレジスタペアをアドレスに使用したメモリ参照。</target>
        </trans-unit>
        <trans-unit id="4b51e9b71c2545b5652560bf7f6a9647e0035d8a" translate="yes" xml:space="preserve">
          <source>A memory reference where the exact address is in a single register (&amp;lsquo;&amp;lsquo;</source>
          <target state="translated">正確なアドレスが単一のレジスタにあるメモリ参照（ ''</target>
        </trans-unit>
        <trans-unit id="0139bd65b0b5d2fe4673870edd7d6641449c58e8" translate="yes" xml:space="preserve">
          <source>A memory reference which requires an additional word (address or offset) after the opcode.</source>
          <target state="translated">オプコードの後に追加ワード(アドレスまたはオフセット)を必要とするメモリ参照。</target>
        </trans-unit>
        <trans-unit id="9a543e86cece309b6602d80f4120038bbc4ab307" translate="yes" xml:space="preserve">
          <source>A memory reference with an absolute address.</source>
          <target state="translated">絶対アドレスを持つメモリ参照。</target>
        </trans-unit>
        <trans-unit id="287d82bed5f1580615ce42d8bee2ee48ebecfb48" translate="yes" xml:space="preserve">
          <source>A memory transaction commits all changes to memory in an atomic way, as visible to other threads. If the transaction fails it is rolled back and all side effects discarded.</source>
          <target state="translated">メモリトランザクションは、他のスレッドから見えるように、すべての変更をアトミックな方法でメモリにコミットします。トランザクションが失敗した場合はロールバックされ、すべての副作用が破棄されます。</target>
        </trans-unit>
        <trans-unit id="d7f155128a2791cfe10b2a9e15921858bd575c02" translate="yes" xml:space="preserve">
          <source>A nested function always has no linkage. Declaring one with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; is erroneous. If you need to declare the nested function before its definition, use &lt;code&gt;auto&lt;/code&gt; (which is otherwise meaningless for function declarations).</source>
          <target state="translated">ネストされた関数は常にリンケージを持ちません。 &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; で宣言するとエラーになります。ネストされた関数をその定義の前に宣言する必要がある場合は、 &lt;code&gt;auto&lt;/code&gt; を使用してください（それ以外の場合は関数宣言では意味がありません）。</target>
        </trans-unit>
        <trans-unit id="d26414fbc961f98329967917d426b4cbc2efe330" translate="yes" xml:space="preserve">
          <source>A nested function can jump to a label inherited from a containing function, provided the label is explicitly declared in the containing function (see &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Local Labels&lt;/a&gt;). Such a jump returns instantly to the containing function, exiting the nested function that did the &lt;code&gt;goto&lt;/code&gt; and any intermediate functions as well. Here is an example:</source>
          <target state="translated">ネストされた関数は、ラベルが包含関数で明示的に宣言されていれば、包含関数から継承されたラベルにジャンプできます（&lt;a href=&quot;local-labels#Local-Labels&quot;&gt;ローカルラベルを&lt;/a&gt;参照）。このようなジャンプは即座に包含関数に戻り、 &lt;code&gt;goto&lt;/code&gt; を実行した入れ子関数と中間関数も終了します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="0712d7fc676044f053a72419ea0e38ad815c6a04" translate="yes" xml:space="preserve">
          <source>A new edition of the ISO C standard was published in 1999 as ISO/IEC 9899:1999, and is commonly known as &lt;em&gt;C99&lt;/em&gt;. (While in development, drafts of this standard version were referred to as &lt;em&gt;C9X&lt;/em&gt;.) GCC has substantially complete support for this standard version; see &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for details. To select this standard, use</source>
          <target state="translated">ISO C規格の新版はISO / IEC 9899：1999として1999年に公開され、一般に&lt;em&gt;C99&lt;/em&gt;として知られ&lt;em&gt;てい&lt;/em&gt;ます。（開発中、この標準バージョンのドラフトは&lt;em&gt;C9X&lt;/em&gt;と呼ばれてい&lt;em&gt;ました&lt;/em&gt;。）GCCはこの標準バージョンを実質的に完全にサポートしています。詳細については、&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http：//gcc.gnu.org/c99status.html&lt;/a&gt;を参照してください。この規格を選択するには、</target>
        </trans-unit>
        <trans-unit id="c1d3e8da2b16b837e350778965a42d38a1727ecd" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; function declaration follows a &lt;code&gt;static&lt;/code&gt; one. This construct is not accepted by some traditional C compilers.</source>
          <target state="translated">非 &lt;code&gt;static&lt;/code&gt; 関数の宣言は、 &lt;code&gt;static&lt;/code&gt; 宣言の後に続きます。この構造は、一部の従来のCコンパイラでは受け入れられません。</target>
        </trans-unit>
        <trans-unit id="a1561d49e6959fd563ec43b519d5c367906c49ac" translate="yes" xml:space="preserve">
          <source>A number of bytes.</source>
          <target state="translated">バイト数です。</target>
        </trans-unit>
        <trans-unit id="c6e4f37a3cc64090cf8998b7f43d11b497869792" translate="yes" xml:space="preserve">
          <source>A operand which is read by the instruction can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. Adding alternatives of this form often allows GCC to produce better code when only some of the read operands can be affected by the earlyclobber. See, for example, the &amp;lsquo;</source>
          <target state="translated">命令によって読み取られるオペランドは、初期結果が書き込まれる前に入力としてのみ使用される場合は、初期クローバーオペランドに関連付けることができます。この形式の代替を追加することで、GCCは、一部の読み取りオペランドのみが初期クローバーの影響を受ける可能性がある場合に、より良いコードを生成できるようになります。たとえば、「</target>
        </trans-unit>
        <trans-unit id="33c89233be593b8efaeda5d8e73bec02c063a6ed" translate="yes" xml:space="preserve">
          <source>A parameter to control whether to use function internal id in profile database lookup. If the value is 0, the compiler uses an id that is based on function assembler name and filename, which makes old profile data more tolerant to source changes such as function reordering etc.</source>
          <target state="translated">プロファイル・データベースの検索で関数の内部 ID を使用するかどうかを制御するためのパラメータです。値が0の場合、コンパイラは関数アセンブラ名とファイル名に基づいたIDを使用します。これにより、古いプロファイル・データは、関数の並び替えなどのソースの変更に対してより寛容になります。</target>
        </trans-unit>
        <trans-unit id="ac02409b28e4665594149c1f072d2a778a5e74f5" translate="yes" xml:space="preserve">
          <source>A pointer is compared against integer zero with &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">ポインタは、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、または &lt;code&gt;&amp;gt;=&lt;/code&gt; で整数ゼロと比較されます。</target>
        </trans-unit>
        <trans-unit id="5e654ce5ba59b63225116cee29f29b754f51ae4a" translate="yes" xml:space="preserve">
          <source>A possibly empty comma-separated list of expressions. For example, &lt;code&gt;format_arg&lt;/code&gt; attributes use this form with the list being a single integer constant expression, and &lt;code&gt;alias&lt;/code&gt; attributes use this form with the list being a single string constant.</source>
          <target state="translated">おそらく空の式のコンマ区切りリスト。たとえば、 &lt;code&gt;format_arg&lt;/code&gt; 属性はこの形式を使用し、リストは単一の整数定数式であり、 &lt;code&gt;alias&lt;/code&gt; 属性はこの形式を使用し、リストは単一の文字列定数です。</target>
        </trans-unit>
        <trans-unit id="6f94ad7a128da59e35cfef4198c05f92370ba7a7" translate="yes" xml:space="preserve">
          <source>A precompiled header cannot be used once the first C token is seen. You can have preprocessor directives before a precompiled header; you cannot include a precompiled header from inside another header.</source>
          <target state="translated">プリコンパイルされたヘッダは、最初のCトークンが表示されると使用できません。プリコンパイルされたヘッダの前にプリプロセッサディレクティブを置くことができます。</target>
        </trans-unit>
        <trans-unit id="967ed292b7da3d9c381bae6f412c1eb711012203" translate="yes" xml:space="preserve">
          <source>A precompiled header file can be used only when these conditions apply:</source>
          <target state="translated">プリコンパイルされたヘッダファイルは、これらの条件が適用される場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="05035041744377e6b9210288a1d05f98595669e6" translate="yes" xml:space="preserve">
          <source>A precompiled header file is searched for when &lt;code&gt;#include&lt;/code&gt; is seen in the compilation. As it searches for the included file (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Search Path&lt;/a&gt; in The C Preprocessor) the compiler looks for a precompiled header in each directory just before it looks for the include file in that directory. The name searched for is the name specified in the &lt;code&gt;#include&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">コンパイルで &lt;code&gt;#include&lt;/code&gt; が見つかると、プリコンパイル済みヘッダーファイルが検索されます。インクルードファイルを&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;検索&lt;/a&gt;するとき（Cプリプロセッサの検索パスを参照）、コンパイラーは各ディレクトリでプリコンパイル済みヘッダーを探し、そのディレクトリでインクルードファイルを探します。検索される名前は、 &lt;code&gt;#include&lt;/code&gt; で指定された名前と '</target>
        </trans-unit>
        <trans-unit id="65201eadf5d675527c7f1ac85fd378b5ccbc08ee" translate="yes" xml:space="preserve">
          <source>A prefix for source file names to remove when generating the output coverage files. This option is useful when building in a separate directory, and the pathname to the source directory is not wanted when determining the output file names. Note that this prefix detection is applied before determining whether the source file is absolute.</source>
          <target state="translated">出力カバレッジファイルを生成する際に除去したいソースファイル名の接頭辞。このオプションは、別のディレクトリに構築する場合に便利で、出力ファイル名を決定する際にソースディレクトリへのパス名を必要としない場合に使用します。この接頭辞の検出は、ソースファイルがアブソリュートかどうかを判断する前に適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2f9dfd11eaa793c8913662662201289a00fcaafa" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on an MCM target should be linked with this option. It causes the libraries libc.a and libdebug.a to be linked. The program should be run on the target under the control of the GDB remote debugging stub.</source>
          <target state="translated">ファイル I/O を実行し、MCM ターゲット上で実行されることを前提としたプログラムは、このオプションを使用してリンクする必要があります。これにより、ライブラリ libc.a と libdebug.a がリンクされます。プログラムは、GDB リモートデバッグスタブの制御下でターゲット上で実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="06091d7b0985c9e8feba549f19d66a548c218908" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on the simulator should be linked with option. This causes libraries libc.a and libsim.a to be linked.</source>
          <target state="translated">ファイルの入出力を行い、シミュレータ上で動作することを前提としたプログラムは、オプションでリンクされている必要があります。これにより、ライブラリ libc.a と libsim.a がリンクされます。</target>
        </trans-unit>
        <trans-unit id="03bc1b8f8194ecc4bd7cc22529202219ccc55928" translate="yes" xml:space="preserve">
          <source>A redeclaration of an entity must not add new ABI tags, since doing so would change the mangled name.</source>
          <target state="translated">エンティティの再宣言は、新しいABIタグを追加してはならない。</target>
        </trans-unit>
        <trans-unit id="72babc8ed783b6f80b238e203c04bb32ab9b7ee7" translate="yes" xml:space="preserve">
          <source>A register indirect memory operand</source>
          <target state="translated">レジスタ間接メモリオペランド</target>
        </trans-unit>
        <trans-unit id="822740a74e2ad86073347ee3e0a96d4ea21793b7" translate="yes" xml:space="preserve">
          <source>A register operand is allowed provided that it is in a general register.</source>
          <target state="translated">レジスタオペランドは、一般的なレジスタ内であれば許可されます。</target>
        </trans-unit>
        <trans-unit id="c6b4e516f4445d7fd0eb4545cb8bd87379ffb2be" translate="yes" xml:space="preserve">
          <source>A register suitable for use in an indirect jump. This will always be &lt;code&gt;$25&lt;/code&gt; for</source>
          <target state="translated">間接ジャンプでの使用に適したレジスター。これは常に &lt;code&gt;$25&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="bf74def1fd328fca34b37ccd32d0585450fe7d70" translate="yes" xml:space="preserve">
          <source>A register that can hold a 64 bit value.</source>
          <target state="translated">64ビットの値を保持できるレジスタ。</target>
        </trans-unit>
        <trans-unit id="40b15fdd982b6acc2dbd0ac15c94e31ec3b3ecb8" translate="yes" xml:space="preserve">
          <source>A revised ISO C++ standard was published in 2011 as ISO/IEC 14882:2011, and is referred to as C++11; before its publication it was commonly referred to as C++0x. C++11 contains several changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">改訂されたISO C ++標準は、2011年にISO / IEC 14882：2011として公開され、C ++ 11と呼ばれています。公開前は、一般にC ++ 0xと呼ばれていました。C ++ 11には、C ++言語に対するいくつかの変更が含まれており、それらはすべてGCCに実装されています。詳細については、&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https：//gcc.gnu.org/projects/cxx-status.html#cxx11を&lt;/a&gt;参照してください。GCCでこの標準を選択するには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="fa1cdaecb062b94545ea6452cf8e926ff17ef618" translate="yes" xml:space="preserve">
          <source>A scalar volatile object is read when it is accessed in a void context:</source>
          <target state="translated">voidコンテキストでアクセスされたときにスカラー揮発性オブジェクトが読み込まれます。</target>
        </trans-unit>
        <trans-unit id="1be35e4d0dcffaec4e53c70345395a20bb71df65" translate="yes" xml:space="preserve">
          <source>A scaled or unscaled indexed memory operand</source>
          <target state="translated">スケーリングされた、またはスケーリングされていないインデックス化されたメモリオペランド。</target>
        </trans-unit>
        <trans-unit id="7561d823e8220cc1324112197c014a5470da6511" translate="yes" xml:space="preserve">
          <source>A signed 10-bit constant for most arithmetic instructions.</source>
          <target state="translated">ほとんどの算術命令のための符号付き10ビット定数。</target>
        </trans-unit>
        <trans-unit id="d4172f55ed8446ca35d32bcd89906fb5748ddaf8" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant added to -1. Can only match when the</source>
          <target state="translated">符号付き 11 ビット定数に -1 を加えたもの。の場合にのみマッチします。</target>
        </trans-unit>
        <trans-unit id="4dbec6f25e372e0d0975d4d90b4ec971a46651e9" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant.</source>
          <target state="translated">符号付き11ビットの定数。</target>
        </trans-unit>
        <trans-unit id="c5fd23196153b5c02da9d3addd039cf5332baffd" translate="yes" xml:space="preserve">
          <source>A signed 12-bit integer constant.</source>
          <target state="translated">符号付き12ビット整数定数。</target>
        </trans-unit>
        <trans-unit id="5d45116f20daaebe383530883ac080de0bcc23a5" translate="yes" xml:space="preserve">
          <source>A signed 15-bit constant.</source>
          <target state="translated">符号付き15ビットの定数。</target>
        </trans-unit>
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; ための即時の符号付き16ビット。</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">符号付き16ビット定数(算術命令用)。</target>
        </trans-unit>
        <trans-unit id="1040a418b2933ba39c0db5d1c19b995428a5db61" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant shifted left 16 bits.</source>
          <target state="translated">符号付き16ビット定数を左16ビットシフトしたもの。</target>
        </trans-unit>
        <trans-unit id="426c500fe95b660ec71d2075e660305546d46c08" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant.</source>
          <target state="translated">符号付き16ビット定数。</target>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">下位16ビットがゼロである符号付き32ビット定数。そのような定数は、 &lt;code&gt;lui&lt;/code&gt; を使用してロードできます。</target>
        </trans-unit>
        <trans-unit id="536e9bf9352073c69bfd1331260c3d50c75e4c4c" translate="yes" xml:space="preserve">
          <source>A signed 34-bit integer constant if prefixed instructions are supported.</source>
          <target state="translated">プリフィックス命令がサポートされている場合の符号付き34ビット整数定数。</target>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">単一のレジスタ。 &lt;var&gt;n&lt;/var&gt; が0〜7の範囲にある場合、対応するDレジスタ。 &lt;code&gt;A&lt;/code&gt; の場合、レジスタP0。</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">仕様の構文は['</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">ステータスレジスタ（ &lt;code&gt;rmsr&lt;/code&gt; 、 &lt;code&gt;$fcc1&lt;/code&gt; から &lt;code&gt;$fcc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">オペランドの配置に関する制約を指定する文字列定数。詳細については、&lt;a href=&quot;constraints#Constraints&quot;&gt;制約&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">柔軟性のある配列のメンバを含む構造体や、そのような構造体を(おそらく再帰的に)含む連合は、構造体のメンバや配列の要素にはならないかもしれません(ただし、これらの用途は拡張子としてGCCで許可されています)。(ただし、これらの用途はGCCでは拡張子として許可されています)。</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">現在のファイルのテキストセグメント内のシンボル</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">シンボルリファレンスです。</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">シンボリックオペランド、または got、tls、または pc-相対参照の16ビットフラグメント。</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">参照型の非型テンプレートパラメータを持つテンプレートが誤ってマングされていました。</target>
        </trans-unit>
        <trans-unit id="3af936ccb51639cb634f6ac0a1e094ce5a6bd006" translate="yes" xml:space="preserve">
          <source>A text segment (program memory) constant label.</source>
          <target state="translated">テキストセグメント(プログラムメモリ)の定数ラベル。</target>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">スイングモジュラスケジューラによって考慮される平均ループ数のしきい値。</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">トランポリンは、入れ子になった関数のアドレスを取ったときに実行時にスタック上に作成され、入れ子になった関数を間接的に呼び出すために使用される小さなコードです。したがって、プログラムが正常に動作するためには、スタックを実行可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">店舗から負荷への真の依存はコストがかかる。</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">このオプションの典型的な使用法は、浮動小数点レジスタを使用しないカーネルを構築し、そのために浮動小数点レジスタを保存したり復元したりする必要がないことです。</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">このコンテキストでの有効な &lt;code&gt;NULL&lt;/code&gt; は、任意のオブジェクトポインタータイプでゼロとして定義されます。システムが整数型の &lt;code&gt;NULL&lt;/code&gt; マクロを定義している場合は、明示的なキャストを追加する必要があります。インストール中に、GCCはシステムの &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ヘッダーを、NULLを適切に再定義するコピーに置き換えます。</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">このオプションの値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">値が-1の場合は、しきい値がないため、一定のストライドに対してプリフェッチヒントを発行できます。</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">ベクトル定数</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">ベクトル定数は中括弧内の定数表現のリストです。</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">ベクトル定数が初期化する変数と同じ型であれば、ベクトル初期化器はキャストを必要としません。</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">弱参照は、それ自体ではターゲットシンボルに定義を与える必要がないエイリアスです。ターゲットシンボルが弱い参照でのみ参照されている場合、 &lt;code&gt;weak&lt;/code&gt; 未定義のシンボルになります。ただし、直接参照される場合は、そのような強い参照が優先され、必ずしも同じ変換単位ではなく、シンボルの定義が必要です。</target>
        </trans-unit>
        <trans-unit id="74b379dc012a6dcd931f8c8cdffa0c221d2777a0" translate="yes" xml:space="preserve">
          <source>AArch64</source>
          <target state="translated">AArch64</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">AArch64ファミリー&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">エービーアイ適合性</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">追加事項:このライセンスのドキュメントへの使用方法</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">AESの指示。</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">エーアイエックスTOCエントリ</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">RS / 6000上のAIXは、米国外の環境にサポート（NLS）を提供します。コンパイラーとアセンブラーはNLSを使用して、浮動小数点数を含むさまざまなオブジェクトのロケール固有の表現をサポートします（ '</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">AMD Athlon CPUにMMX、3dNOW!、強化された3DNow!、SSEプリフェッチ命令サポートを搭載。</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMDのCPU。</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMDファミリー10hバルセロナCPU。</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMDファミリー10hのCPU。</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMDファミリー10hイスタンブールCPU。</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMDファミリー10h上海CPU。</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">AMDファミリー14hのCPU。</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">AMDファミリー15hブルドーザーバージョン1。</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">AMDファミリー15hブルドーザーバージョン2。</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">AMDファミリー15hブルドーザーバージョン3。</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">AMDファミリー15hブルドーザーバージョン4。</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMDファミリー15hのCPU。</target>
        </trans-unit>
        <trans-unit id="6adbeef26c0c63ee2016d0b2ac6031e70f73f984" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMDファミリー15hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張をスーパーセットします)。</target>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">AMDファミリー15hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張をスーパーセットします。</target>
        </trans-unit>
        <trans-unit id="afaafd936d606f23e0204241163cd5538d5327ed" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMDファミリー15hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、TBM、F16C、FMA、FMA4、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張をスーパーセット)</target>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMDファミリー15hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、TBM、F16C、FMA、FMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張をスーパーセットします)</target>
        </trans-unit>
        <trans-unit id="62e14a811063bd0f1e3f0931b760b915b408af1e" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64命令セットをサポートするAMDファミリー15hコアベースCPU。(BMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、および64ビット命令セット拡張をスーパーセットします)</target>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">AMDファミリー15hコアベースCPUでx86-64命令セットをサポートしています。(BMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張をスーパーセットします。</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">AMDファミリー16hのCPU。</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">AMDファミリー17hのCPU。</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMDファミリー17h Zenバージョン1。</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMDファミリー17h Zenバージョン2。</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64命令セットをサポートするAMDファミリー17hコアベースCPU。(BMI、BMI2、 ,CLWB、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、64ビット命令セットをスーパーセットしています。 1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、および64ビット命令セット拡張)</target>
        </trans-unit>
        <trans-unit id="26b9464c770316c8957e5f0dd9332edc81fe410d" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, RDPID, WBNOINVD, and 64-bit instruction set extensions.)</source>
          <target state="translated">AMDファミリー17hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、BMI2、CLWB、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、RDPID WBをスーパーセットしています。 1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、RDPID、WBNOINVD、および64ビット命令セット拡張機能)</target>
        </trans-unit>
        <trans-unit id="37e7bb5b5f5ab7650fa5577e6308f180e065ef83" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">AMDファミリー17hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、および64ビット命令セット拡張機能)</target>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">AMDファミリー17hコアベースのCPUで、x86-64命令セットをサポートしています。(BMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、64ビットの命令セットをスーパーセットしています。 1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、および64ビット命令セット拡張。</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">MMXと3DNow!命令セットをサポートするAMD Geode組み込みプロセッサ。</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">MMX命令セット対応のAMD K6 CPU。</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">ARC &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX（dpfp）64ビットレジスタ。 &lt;code&gt;D0&lt;/code&gt; 、 &lt;code&gt;D1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">ARC HS SIMD対応。</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="29d8dec43e88b47582179de53ef2720d981e8ab1" translate="yes" xml:space="preserve">
          <source>ARM</source>
          <target state="translated">ARM</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">ARMファミリ&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">ARM ターゲットは、半精度浮動小数点値の 2 つの互換性のない表現をサポートしています。どちらかの表現を選択し、プログラムで一貫して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">AVRファミリー&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVXの説明書。</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">AVX2の指示。</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPSの指示。</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIWの指示。</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG命令。</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW説明書。</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">AVX512CD説明書。</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">AVX512DQの説明書。</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">AVX512ERの説明書。</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">AVX512Fの取扱説明書。</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMAの説明書。</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">AVX512PFの説明書。</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI説明書。</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2命令。</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">AVX512VLの説明書。</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNIの指示。</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ命令。</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">現在のトランザクションを中止します。アクティブなトランザクションがない場合、これは何もしません。 &lt;var&gt;status&lt;/var&gt; 8ビットの定数です。その値は &lt;code&gt;_xbegin&lt;/code&gt; からの戻り値にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">2ペア、単一の値（の絶対比較 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 、 &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">2つのスカラー値（の絶対比較 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; 、 &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">絶対値（ &lt;code&gt;abs.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">同意する</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">虚数、固定小数点、または機械定義のリテラル数値サフィックスを GNU 拡張機能として受け入れます。このオプションをオフにすると、これらのサフィックスは C++11 ユーザ定義のリテラル数値サフィックスとして扱われます。このオプションは、C++11 以前のすべての方言とすべての GNU 方言でデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">マイクロソフトのヘッダファイルで使用されているいくつかの非標準的な構文を受け入れます。</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">Plan 9 コードで使用されているいくつかの非標準的な構文を受け入れます。</target>
        </trans-unit>
        <trans-unit id="d6ca16d1d2f90084c15b7909650d30bcccb6d876" translate="yes" xml:space="preserve">
          <source>Accept universal character names and extended characters in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">識別子で普遍的な文字名と拡張文字を受け入れます。このオプションは、C99(およびそれ以降のC標準バージョン)とC++ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">識別子で普遍的な文字名を受け入れます。このオプションは、C99(およびそれ以降のC標準バージョン)とC++ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">名前付きパラメータなしで可変関数を受け入れます。</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">この属性を持つ型へのポインタを介したアクセスは,型ベースのエイリアス解析の対象とはならず,その代わりに,他の型のオブジェクトをエイリアスすることができると仮定される。C99標準の6.5項7の文脈では、このようなポインタを参照するlvalue式は、文字型を持つのと同じように扱われます。以下を参照のこと。</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">揮発性のオブジェクトであってもビットフィールドへのアクセスは、バイトやワードなどのより大きなオブジェクトにアクセスすることで動作します。ビットフィールドを読み書きするためにアクセスされるオブジェクトのサイズに依存することはできません。</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">不揮発性オブジェクトへのアクセスは、揮発性アクセスに対して順序付けられません。揮発性オブジェクトをメモリバリアとして使用して、不揮発性メモリへの書き込みの順序を決めることはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">変数へのアクセスは通常通り最適化され、レジスタは変数の観測可能な値が影響を受けないことを条件に、どのような計算でも割り当てと使用が可能なままになります。</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">入出力オペランドを使用せずに(アセンブラテンプレートから直接グローバルシンボルを使用するなどして)Cプログラムからデータにアクセスすると、期待通りに動作しない場合があります。同様に、アセンブラテンプレートから直接関数を呼び出すには、ターゲットのアセンブラとABIの詳細な理解が必要です。</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">C標準によれば、このような式は右辺値であり、その型は元の型の非修飾バージョン、つまり &lt;code&gt;int&lt;/code&gt; です。GCCがこれをポイントされている揮発性オブジェクトの読み取りとして解釈するのか、それとも副作用の式を評価する要求としてのみ解釈するのかは、このタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">「のオプションを蓄積する</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">関数プロローグ/エピローグで一度だけ、発信関数引数を蓄積し、発信関数引数のために必要なスタックスペースを取得/解放します。このオプションを指定しないと、関数を呼び出す前に発信引数がプッシュされ、その後にポップされます。</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">アキュムレータレジスタ。</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">ライブラリユニット本体（サブプログラムまたはパッケージ本体）を含むAdaソースコードファイル。このようなファイルは、&lt;em&gt;本文&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">ライブラリユニット宣言（パッケージ、サブプログラム、ジェネリック、またはジェネリックインスタンス化の宣言）、またはライブラリユニット名変更宣言（パッケージ、ジェネリック、またはサブプログラム名変更宣言）を含むAdaソースコードファイル。このようなファイルは&lt;em&gt;specs&lt;/em&gt;とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">段落1のリストに「スレッドストレージ期間」を追加します。</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">オフセット可能なメモリ参照に8バイトを追加します。SSE 値の上位 8 バイトにアクセスするときに便利です。(%rax)の memref に対して、以下を生成します。</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">段落1のリストに &lt;code&gt;__thread&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">段落3の指定子のリストに &lt;code&gt;__thread&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">段落1のストレージクラス指定子のリストに &lt;code&gt;__thread&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">第3段落の後に追加</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">第4段落の後に追加</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">第5段落の後に追加</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">第6項の後に追加</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">プログラムフロー&lt;em&gt;アーク&lt;/em&gt;が計測されるようにコードを追加します。実行中、プログラムは各分岐と呼び出しが実行された回数と、分岐または呼び出しが実行または返された回数を記録します。優先度サポート付きのコンストラクタをサポートするターゲットでは、プロファイリングは、グローバル変数の型として使用されるクラスのコンストラクタ、デストラクタ、およびC ++コンストラクタ（およびデストラクタ）を適切に処理します。</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">人工変数、外部参照、コールサイトパラメータのDIEなど、名前属性を持たないいくつかのDWARF DIEに記述属性を追加しました。</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">検索するディレクトリのリストにディレクトリ &lt;var&gt;dir&lt;/var&gt; を追加します</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">第1段落の後に新しいテキストを追加</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">第6段落の後に新しいテキストを追加</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">第3段落の前に新しいテキストを追加</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">HP-UX での&lt;em&gt;dceスレッド&lt;/em&gt;ライブラリを使用したマルチスレッドのサポートを追加します。このオプションは、プリプロセッサーとリンカーの両方にフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">前処理中にヘッダーファイルを検索するディレクトリのリストにディレクトリ &lt;var&gt;dir&lt;/var&gt; を追加します。 &lt;var&gt;dir&lt;/var&gt; が 'で始まる場合</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">ヘッダーファイルを検索するディレクトリのリストの先頭にフレームワークディレクトリ &lt;var&gt;dir&lt;/var&gt; を追加します。これらのディレクトリは、</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">フローティングタイプを追加しました。</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">コマンドラインオプションで要求された場合、追加のブロック情報が各行に続く場合があります。 &lt;var&gt;execution_count&lt;/var&gt; は 'です</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">128ビット浮動小数点（ &lt;code&gt;__float128&lt;/code&gt; ）値を効率的に使用するために、64ビットPowerPCファミリーのプロセッサーで追加の組み込み関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">追加の浮動小数点例外、丸めモード、環境、分類、およびそれらのマクロ名(C99とC11 7.6、C99とC11 7.12)。</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">戻り値の追加の後処理が必要になる場合があります &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">プロローグとエピローグでのみ使用される追加のレジスタ。RETS、RETN、RETI、RETX、RETE、ASTAT、SEQSTAT、USP。</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">ターゲットのスカラー記憶次数に関して、逆スカラー記憶次数を持つ型には追加の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">でコンパイルされた関数をインライン化することもできます。</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">さらに、ネイティブAArch64 GNU / Linuxシステムでは、値 '</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">さらに '</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">さらに、 &lt;code&gt;CFStringRefs&lt;/code&gt; （ &lt;code&gt;CoreFoundation&lt;/code&gt; ヘッダーで定義）もフォーマット引数として使用できます。関連するヘッダーはDarwin（OSX）のインストールでのみ利用可能であることに注意してください。このようなインストールでは、XCodeとシステムのドキュメントに &lt;code&gt;CFString&lt;/code&gt; 、 &lt;code&gt;CFStringRefs&lt;/code&gt; 、および関連する関数の説明が記載されています。</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">さらに、いくつかのメッセージは、最適化パスの実装の詳細を反映して、他のメッセージの中に論理的に入れ子になっています。</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">さらに、アーキテクチャ拡張文字列を独自に指定することもできます。これは、特定のアーキテクチャのバージョンやコアを指定しなくても、特定のアーキテクチャ拡張をオンオフするために使用することができます。例を示します。</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">さらに、Thumb実行状態のサポートが不足している以下のアーキテクチャは認識されますが、サポートは非​​推奨です。</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">さらに、オプション</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">さらに、このオプションは、GCCがbig.LITTLEシステムのコードのパフォーマンスを調整する必要があることを指定できます。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">さらに、ユーザー定義のリテラル演算子がアンダースコアで始まらないリテラルサフィックス識別子で宣言されている場合は警告します。アンダースコアで始まらないリテラルサフィックス識別子は、将来の標準化のために予約されています。</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">アドレスベースレジスタ</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64ビット命令が有効な場合、またはNO_REGSの場合はアドレスベースレジスタ。</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">インデックス付きまたはレジスタから間接的なアドレスオペランド（ '</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">セグメントレジスタのないアドレスオペランド。</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">アドレスレジスタ</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">アドレスレジスタ(r0以外の汎用レジスタ</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">アドレスレジスタ間接アドレッシングモード</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">アドレスレジスタ</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">16ビット幅のアドレスレジスタ。</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">24ビット幅のアドレスレジスタ。</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">アドレス空間識別子は、他のCタイプ修飾子（たとえば、 &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;volatile&lt;/code&gt; ）とまったく同じように使用できます。詳細については、N1275ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="b5e65d5c203f07ad3d2623301ca2022f82e6bcd0" translate="yes" xml:space="preserve">
          <source>Address space layout randomization (ASLR) can lead to not binary identical PCH files. If you rely on stable PCH file contents disable ASLR when generating PCH files.</source>
          <target state="translated">アドレス空間レイアウトのランダム化(ASLR)により、バイナリで同一のPCHファイルが生成されないことがあります。安定した PCH ファイルの内容に依存している場合は、PCH ファイルを生成する際に ASLR を無効にしてください。</target>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">隣接するビットフィールドは、積分型が同じサイズであり、次のビットフィールドがビットフィールドの共通のアラインメント要件によって課される境界を越えることなく現在のアロケーションユニットに収まる場合、同じ1バイト、2バイト、または4バイトのアロケーションユニットに詰め込まれます。</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">グローバルレジスタ変数を定義した後、現在のコンパイルユニットのために。</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">レジスタ割り当て後のレジスタ割り当て命令分割後、その演算に基づく比較演算と同様のプロセッサフラグを計算する演算命令を特定します。可能であれば、明示的な比較演算を排除する。</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">レジスタ割り当てとレジスタ割り当て後の命令分割の後、コピープロパゲーションパスを実行してスケジューリング依存性を減らし、時にはコピーを排除しようとします。</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">でコンパイルされたプログラムを実行した後</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">接頭辞の後には、値が存在する場所を説明する1つ以上の追加の制約（&lt;a href=&quot;constraints#Constraints&quot;&gt;制約を&lt;/a&gt;参照）が必要です。一般的な制約には、</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">この場合も、 &lt;code&gt;f()&lt;/code&gt; への呼び出しはテンプレート引数に依存していません（ &lt;code&gt;T&lt;/code&gt; 型に依存する引数はなく、呼び出しが依存コンテキスト内にあることも指定されていません）。したがって、基本クラスの関数はインスタンス化時まで表示されないため、このような関数のグローバル宣言を使用できる必要があります。その結果、コンパイラは次のエラーメッセージを生成します。</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">この属性を持つ集約は、対応するスカラと同じサイズであっても無効です。例えば、宣言</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">のエイリアス</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">すべてのブランチターゲットをパワーオブツーの境界に配置します。</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">すべてのループを32バイトの境界に整列させます。</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">ジャンプでしか到達できない分岐ターゲットのために、分岐ターゲットをパワーオブツーの境界に合わせる。この場合、ダミー操作は必要ありません。</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">ダブルスを64ビット境界で整列させます。これにより呼び出し規則が変更されるので、標準Cライブラリの関数の中には、最初に</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">ループを2乗境界に整列させる。ループが何度も実行される場合、これはダミーのパディング命令の実行を補います。</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">関数の開始を &lt;var&gt;n&lt;/var&gt; より大きい次の2のべき乗に揃え、最大 &lt;var&gt;m&lt;/var&gt; -1バイトまでスキップします。これにより、少なくとも関数の最初の &lt;var&gt;m&lt;/var&gt; バイトが、 &lt;var&gt;n&lt;/var&gt; バイトの境界整列を越えることなくCPUによってフェッチされることが保証されます。</target>
        </trans-unit>
        <trans-unit id="c4d41afbffbc15906243cd5ff7feb6499dec3822" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than or equal to &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">関数の開始を &lt;var&gt;n&lt;/var&gt; 以上の次の2の累乗に揃え、 &lt;var&gt;m&lt;/var&gt; -1バイトまでスキップします。これにより、 &lt;var&gt;n&lt;/var&gt; バイトのアライメント境界を越えることなく、関数の少なくとも最初の &lt;var&gt;m&lt;/var&gt; バイトをCPUがフェッチできるようになります。</target>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">変数を整列します（ &lt;code&gt;alnv.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">すべての条件レジスタ。SCC、VCCZ、EXECZ</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">依存関係はすべてコストがかかります。</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">で指定されたすべてのファイル</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">すべての暗黙的にポップされた入力レジスタは、暗黙的にポップされていない入力よりもREGスタックの先頭に近づかなければなりません。</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">すべてのメモリオーダーが有効です。</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">すべてのモジュールは、同じ</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">スレッドの保存期間も動的な保存期間も持たず、ローカルでもないすべてのオブジェクト[&amp;hellip;]。</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">すべてのルーチンは、「メモリバリアによって保護された変数のオプションリスト」を取得するために、Intelのドキュメントで説明されています。それが何を意味するのかは明らかではありません。それがいることを意味するかもしれません&lt;em&gt;のみ&lt;/em&gt;記載されている変数が保護されている、またはそれが保護されるべき追加の変数のリストを意味するかもしれません。リストは空として扱うGCCによって無視されます。GCCは空のリストを、グローバルにアクセス可能なすべての変数を保護する必要があると解釈します。</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">他のすべての属性</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">上記のすべて</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">すべての基本的な整数型は、符号付きと符号なしの両方の基本型として使用できます： &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 。さらに、 &lt;code&gt;float&lt;/code&gt; と &lt;code&gt;double&lt;/code&gt; を使用して、浮動小数点ベクトル型を構築できます。</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">すべてのデータセグメントと読み取り専用のデータセグメントは、512KBのアドレス空間内になければなりません。テキストセグメントは16MBのアドレス空間内になければなりません。</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">すべてのテキストとデータセグメントは、4GBのアドレス空間内にすることができます。</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">すべての可視性がすべてではなく多くのELFターゲットでサポートされています（アセンブラが '</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 型には、宣言可能な値の範囲に必要なバイト数だけを割り当てます。具体的には、 &lt;code&gt;enum&lt;/code&gt; 型は、十分なスペースがある最小の整数型と同等です。</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">変数は、可能であれば最初に読み取り専用のデータセクションに割り当て、次に可能であれば小さなデータセクションに割り当て、それ以外の場合はデータに割り当てます。これにより、デフォルトよりも若干コードが遅くなりますが、実行時に必要なRAMの量を減らすことができるので、組み込みシステムによっては好ましいかもしれません。</target>
        </trans-unit>
        <trans-unit id="482b6f74ff2eb85ead91bf4d63cb82360d5be63f" translate="yes" xml:space="preserve">
          <source>Allow (or do not allow) GCC to use the LOOP instruction.</source>
          <target state="translated">GCCがLOOP命令を使用することを許可する(または許可しない)。</target>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">ビット演算で任意のサイズのイミディエイトを許可します。</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">第2引数と第3引数の型が不一致の条件式を許可します。このような式の値は void です。このオプションは C++ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">メッセージディスパッチャへの高速ジャンプを許可します。Darwin では、これは comm ページを使って実現します。</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">要素数の異なるベクトル間の暗黙の変換や、互換性のない要素型の変換を許可します。このオプションは、新しいコードには使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">(a)引数と結果が有効であることを前提とし、(b)IEEEまたはANSI規格に違反する可能性がある浮動小数点演算の最適化を許可します。リンク時に使用する場合は、デフォルトのFPU制御ワードを変更するライブラリやスタートアップファイル、または他の類似の最適化を含むことがあります。</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">引数と結果がNaNや+-Infではないことを前提とした浮動小数点演算の最適化を可能にしました。</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">ゼロの符号化を無視した浮動小数点演算の最適化を許可します。IEEE 算術では、明確な +0.0 と -0.0 の値の振る舞いを指定していますが、これは x+0.0 や 0.0*x のような式の単純化を禁止しています。</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">オプティマイザがストアに新しいデータ競合を導入することを許可します。許可する場合は1に設定し、許可しない場合は0に設定します。</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">コンパイラがサインおよびコサイン近似のために &lt;code&gt;fsca&lt;/code&gt; 命令を発行することを許可または禁止します。オプション</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">逆平方根近似のコンパイラが &lt;code&gt;fsrra&lt;/code&gt; 命令を発行することを許可または禁止します。オプション</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">一連の浮動小数点演算でオペランドの再関連付けを許可します。これは、計算結果を変更する可能性があるため、ISO CおよびC ++言語標準に違反しています。注：並べ替えは、ゼロの符号を変更するだけでなく、NaNを無視して、アンダーフローまたはオーバーフローを抑制または作成する可能性があります（したがって、 &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; ような丸め動作に依存するコードでは使用できません。また、浮動小数点比較を並べ替えることができるため、順序付けされた比較が必要な場合は使用できません。このオプションでは、</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">より多くの負荷命令の投機的な動作を許可します。これは、レジスタ割り当ての前にスケジューリングする場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">いくつかのロード命令の投機的な動きを許可します。これは、レジスタ割り当ての前にスケジューリングする場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">ストップビットのトリガーとなった命令の直前よりも前にストップビットを配置できるようにします。これは命令スケジューリングを改善することができますが、常にそうなるとは限りません。</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">コンパイラーが、コンパイルされる言語に適用可能な最も厳しいエイリアシング規則を想定できるようにします。C（およびC ++）の場合、これは式のタイプに基づいて最適化をアクティブにします。特に、あるタイプのオブジェクトは、タイプがほとんど同じでない限り、別のタイプのオブジェクトと同じアドレスに存在しないと想定されています。例えば、 &lt;code&gt;unsigned int&lt;/code&gt; 型は別名設定できる &lt;code&gt;int&lt;/code&gt; 型ではなく、 &lt;code&gt;void*&lt;/code&gt; や &lt;code&gt;double&lt;/code&gt; を。文字型は他の型の別名になる場合があります。</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">ターゲットが 'の場合、コンパイラが&lt;em&gt;Long Instruction Word&lt;/em&gt;命令を生成できるようにし&lt;em&gt;ます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">コンパイラが生成することを許可し&lt;em&gt;SETLB&lt;/em&gt;と&lt;em&gt;のLCC&lt;/em&gt;ターゲット'の場合の手順を</target>
        </trans-unit>
        <trans-unit id="57b9d18f30c753317a363448d4ac2396bae27e7d" translate="yes" xml:space="preserve">
          <source>Allow the compiler to introduce new data races on stores.</source>
          <target state="translated">コンパイラがストアに新しいデータレースを導入できるようにします。</target>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">コンパイラが、列挙型の値は列挙の値のうちの 1 つにしかなりえないという仮定を使用して最適化できるようにします(C++標準で定義されているとおり、基本的にはすべての列挙子を表現するのに必要な最小ビット数で表現できる値です)。プログラムがキャストを使用して任意の整数値を列挙型に変換する場合には、この仮定は有効ではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">コンパイラーが使用可能なレジスターをすべて使用できるようにします。デフォルトでは、レジスタ &lt;code&gt;r24..r31&lt;/code&gt; は、割り込みハンドラで使用するために予約されています。このオプションを有効にすると、これらのレジスタは通常の機能でも使用できます。</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">最適化が有効な場合、値で除算する代わりに、値の逆数を使用できるようにします。たとえば、 &lt;code&gt;x / y&lt;/code&gt; を &lt;code&gt;x * (1/y)&lt;/code&gt; に置き換えることができます。これは、 &lt;code&gt;(1/y)&lt;/code&gt; が共通の部分式の削除の対象となる場合に役立ちます。これは精度を失い、値で動作するフロップの数が増えることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">合法であれば、店舗合流パスで未合流店舗を導入できるようにする。</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">小数点固定小数点型の場合、ゼロへの丸めの代わりに切り捨てを使用できるようにしました。</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">で選択されたバージョンよりも後の DWARF 標準バージョンの拡張機能の使用を許可します。</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">&lt;code&gt;__ea&lt;/code&gt; アドレス空間を汎用アドレス空間のスーパーセットとして扱うことを許可/禁止します。これにより、 &lt;code&gt;__ea&lt;/code&gt; とジェネリックポインター間の明示的な型キャスト、およびジェネリックポインターから &lt;code&gt;__ea&lt;/code&gt; ポインターへの暗黙的な変換が可能になります。デフォルトでは、アドレス空間のポインター変換が許可されます。</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; 、 &lt;code&gt;signed int&lt;/code&gt; 、および &lt;code&gt;unsigned int&lt;/code&gt; 以外の許容されるビットフィールドタイプ（C99およびC11 6.7.2.1）。</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">ターゲットコードがインターワーキング用にコンパイルされているかどうかに関わらず、関数ポインタ(仮想関数を含む)を介した呼び出しが正しく実行されるようにします。このオプションを有効にすると、関数ポインタの実行コストにわずかなオーバーヘッドが発生します。このオプションは、インターワーキングがデフォルトで有効になっているため、AAPCS 構成では有効ではありません。</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">また、GCCは、ベクトル化された単一の浮動小数点除算およびベクトル化された &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; の追加のNewton-Raphsonステップを使用して上記のシーケンスを出力し、</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">また、 &lt;code&gt;asm goto&lt;/code&gt; ステートメントは常に暗黙的に揮発性と見なされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">また、コンパイラが比較に含まれる定数の大きさを減少させる場合についても警告します。たとえば、 &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; は &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; 簡略化されます。この単純化は多くの比較に適用されるため、これは最も高い警告レベルでのみ報告され、この警告レベルは非常に多くの誤検知を引き起こします。</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">また、比較が定数に簡略化される他のケースについても警告します。例： &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; 。これは、 &lt;code&gt;abs (INT_MIN)&lt;/code&gt; がゼロ未満の &lt;code&gt;INT_MIN&lt;/code&gt; にオーバーフローするため、符号付き整数オーバーフローが定義されていない場合にのみ簡略化できます。</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">比較が単純化されている他のケースについても警告します。たとえば、 &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; は &lt;code&gt;x &amp;gt; 0&lt;/code&gt; 簡略化されます。</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">上記のケースでカバーされていない他の簡略化についても警告します。例： &lt;code&gt;(x * 10) / 5&lt;/code&gt; は &lt;code&gt;x * 2&lt;/code&gt; 簡略化されます。</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">中間オペランドが省略されている &lt;code&gt;?:&lt;/code&gt; へのGNU拡張機能の危険な使用についても警告します。時の状態 &lt;code&gt;?&lt;/code&gt; ：演算子はブール式であり、省略された値は常に1です。多くの場合、プログラマーは、条件式の内部で計算される値であると期待します。</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">&lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; ような比較が表示された場合も警告します。これは &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; と同等であり、通常の数学的表記とは解釈が異なります。</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">安全ではない方法で型修飾子を導入するキャストを作成するときにも警告します。たとえば、次の例のように、 &lt;code&gt;char **&lt;/code&gt; を &lt;code&gt;const char **&lt;/code&gt; にキャストすることは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">また、組み込み関数の中には、対応するDSP命令が即値とレジスタオペランドの両方を受け付ける場合と、即値のみを受け付ける場合があるため、パラメータとして即値を好む、または必要とするものがあります。即値パラメータは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">また、ABIは、テンプレート引数パック、 &lt;code&gt;const_cast&lt;/code&gt; 、 &lt;code&gt;static_cast&lt;/code&gt; 、プレフィックスの増分/減分、およびテンプレート引数として使用されるクラススコープ関数の変換を変更しました。</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">また、特殊なクローバーの引数が2つあります。</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">また、可変数の引数を取るすべての関数（ &lt;code&gt;printf&lt;/code&gt; を含む）の関数プロトタイプを提供する必要があります。そうしないと、これらの関数の呼び出しに対して誤ったコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">OpenMP simdディレクティブでマークされたループのベクトル化に使用されるコストモデルを変更します。 &lt;var&gt;model&lt;/var&gt; 引数は、 'は1でなければなりません</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">ベクトル化に使用されるコストモデルを変更します。 &lt;var&gt;model&lt;/var&gt; 引数は、 'は1でなければなりません</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">使用するスレッドローカルストレージモデルを変更します（&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;スレッドローカルを&lt;/a&gt;参照）。 &lt;var&gt;model&lt;/var&gt; 引数は、 'は1でなければなりません</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">プロファイルフィードバックに基づく最適化のためにインスツルメントされたアプリケーションの更新方法を変更します。 &lt;var&gt;method&lt;/var&gt; 引数には、 &quot;のいずれかでなければなりません</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">または、括弧で囲まれた実際のCラベル名を使用してラベルを参照できます。たとえば、 &lt;code&gt;carry&lt;/code&gt; というラベルを参照するには、'</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">また、どのバイナリ最適化が有効になっているかを調べるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">または、関数属性 &lt;code&gt;noplt&lt;/code&gt; を使用して、特定の外部関数のPLTを介した呼び出しを回避できます。</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">あるいは、コンパイル済みのヘッダファイルをディレクトリに置いて</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">IRA は高度なアルゴリズムを使用して競合テーブルを圧縮していますが、巨大な関数の場合はテーブルに過度のメモリが必要になることがあります。ある関数の競合テーブルがこのパラメータで指定されたMBのサイズを超える場合、レジスタアロケータは代わりに、擬似レジスタ競合テーブルを構築する必要のない、より高速でシンプルな低品質のアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">このようなケースをすべて警告するように努力していますが、G++が互換性のないコードを生成しているにもかかわらず、警告が出ないケースもあるでしょう。また、生成されるコードが互換性のあるコードであるにもかかわらず、警告が出るケースもあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">このような関数を定義することは可能ですが、引数を読み取ることができないため、あまり有用ではありません。C++ではこのような構成が許されているため、Cでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">動作はゴールドリンカーのICF最適化と似ていますが、GCC ICFはさまざまなレベルで機能するため、最適化は同じではありません。</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">この属性の主な用途は POD 型ですが、コンストラクタによって初期化されるグローバル C++オブジェクトにも適用できます。この場合、オブジェクトの静的な初期化および破壊コードは、オブジェクトを定義する各変換で発行されますが、コンストラクタとデストラクタの呼び出しはリンクワンスのガード変数で保護されます。</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">ゼロ長の配列のサイズはゼロであるが、この種の配列部材は、テールパディングの結果として、囲い込み型のサイズを増加させてもよい。囲む構造体の先頭からのゼロ長の配列メンバのオフセットは、同じ型の1つ以上の要素を持つ配列のオフセットと同じである。ゼロ長配列の整列は,その要素の整列と同じである。</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">アルティベック登録</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">Altivec レジスタをダブルロード/ストアまたは NO_REGS に使用します。</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">Altivec レジスタを float/32 ビット int ロード/ストアまたは NO_REGS に使用します。</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">アルティベックベクトルレジスタ</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">ビットフィールドは常に &lt;code&gt;int&lt;/code&gt; サイズとして扱います。</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">常にライブラリコールを使用します。</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">これらの変更の結果として、同じ名前の同じ型の静的データメンバであっても、異なる共有オブジェクトで定義されている静的データメンバは異なるため、一方を変更しても他方は変更されないこと、および、異なる共有オブジェクトで定義されている関数メンバへのポインタが等しく比較されないことがあります。このフラグが与えられた場合、同じ名前の型を異なる形で定義することはODRの違反となります。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">正確には1ビットが設定された8ビットの値。</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">同一要素を持つ8要素のベクトル定数。</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; 文は出力することはできません。これはコンパイラの内部制限によるものです。コントロール転送命令は出力を持つことができません。アセンブラコードが何かを変更する場合は、 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; クロバーを使用して、オプティマイザにすべてのレジスタ値をメモリにフラッシュさせ、必要に応じて &lt;code&gt;asm&lt;/code&gt; ステートメントの後で再ロードします。</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 文は、アセンブラコードによって修飾C変数の名前を示す、ゼロ以上の出力オペランドを有しています。</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 型は、相互に互換性が考慮されていない &lt;code&gt;enum&lt;/code&gt; の両方が同じ整数型と互換性がある場合でも、タイプ、これは、C標準で指定されています。たとえば、 &lt;code&gt;enum {foo, bar}&lt;/code&gt; は &lt;code&gt;enum {hot, dog}&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">&lt;em&gt;属性指定子リストは&lt;/em&gt;、他のトークンで区切られていない1つ以上の属性指定子のシーケンスです。</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">&lt;em&gt;属性指定子は&lt;/em&gt;フォームである &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; 。&lt;em&gt;属性リストは&lt;/em&gt;の空の可能性カンマで区切ったシーケンスである&lt;em&gt;属性&lt;/em&gt;各属性は、次のいずれかです：</target>
        </trans-unit>
        <trans-unit id="7298880ccde6d5d2f135cff890ce9dd813a48a5a" translate="yes" xml:space="preserve">
          <source>An Altivec vector register (VR), &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;.</source>
          <target state="translated">Altivecベクトルレジスタ（VR）、 &lt;code&gt;v0&lt;/code&gt; &amp;hellip; &lt;code&gt;v31&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">I型12ビットの符号付きイミディエイト。</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">絶対アドレス</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">絶対シンボリックアドレスまたはラベル参照</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">適しアドレス &lt;code&gt;prefetch&lt;/code&gt; 命令、または同じアドレッシングモードを有する任意の他の命令の &lt;code&gt;prefetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">非マクロロードまたはストアで使用できるアドレス。</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">汎用レジスタに保持されているアドレス。</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">レジスタの間接アドレスや前後のインクリメント/デクリメントアドレスを伴わないアドレス。</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">上記の例の別の書き方は</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">GCC 2.5から廃止されたが、GCCがまだ受け入れる、このための代替構文は、「</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">宛先バッファのサイズを増やす代わりに、フォーマットされた値の範囲を制限することもできます。文字列引数の最大長は、formatディレクティブで精度を指定することによって制限できます。フォーマットディレクティブの数値引数は、その型の精度よりも小さいと制限されていると想定できる場合、フォーマット指定子に適切な長さ修飾子を選択すると、必要なバッファーサイズが小さくなります。たとえば、および &lt;var&gt;b&lt;/var&gt; と仮定することができる上記の例では、精度の範囲内であると &lt;code&gt;short int&lt;/code&gt; 次にいずれかを使用して型 &lt;code&gt;%hi&lt;/code&gt; フォーマット指示するか、引数キャスト &lt;code&gt;short&lt;/code&gt; 24バイトのバッファの最大必要なサイズを減少させます。 &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">1990規格の改訂版は1995年に公開されました。この改訂 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; は、ダイグラフと__STDC_VERSION__が言語に追加されましたが、それ以外の点ではライブラリに関係しています。この修正は一般に&lt;em&gt;AMD1&lt;/em&gt;として知られています。修正された規格は、&lt;em&gt;C94&lt;/em&gt;または&lt;em&gt;C95&lt;/em&gt;と呼ばれることもあります。 GCCでこの標準を選択するには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">アプリケーションは、以下のようにして呼び出された関数に対して、独自の関数定義を挿入することができます。</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">違いが最も明白な領域は名前のマングリングです。異なる名前のマングリングの使用は、より微妙な問題からユーザーを保護するために意図的です。コンパイラーは、クラスインスタンスのレイアウト、多重継承の実装方法、仮想関数呼び出しの処理方法など、C ++実装の多くの内部の詳細が異なります。名前のエンコーディングを同じにした場合、プログラムは他のコンパイラーから提供されたライブラリーにリンクしますが、プログラムは実行時にクラッシュします。互換性のないライブラリは、実行時ではなくリンク時に検出されます。</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">アセンブラテンプレートは、アセンブラ命令を含むリテラル文字列です。コンパイラーは、入力、出力、およびgotoラベルを参照するテンプレート内のトークンを置き換え、結果のストリングをアセンブラーに出力します。文字列には、ディレクティブを含め、アセンブラによって認識される任意の命令を含めることができます。GCCはアセンブラー命令自体を解析せず、それらが何を意味するのか、またはそれらが有効なアセンブラー入力であるかどうかさえも知りません。ただし、ステートメントはカウントされます（&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asmのサイズを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">アトミック操作は、コードの動きを制約すると同時に、スレッド間の同期のためにハードウェア命令にマッピングすることができます(例:フェンス)。これをどの程度まで実現するかは、メモリオーダーによって制御されます。各メモリ順序の説明は、効果を大まかに説明するためのものであり、仕様ではありません。</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">属性名（ &lt;code&gt;unused&lt;/code&gt; などの識別子、または &lt;code&gt;const&lt;/code&gt; などの予約語である場合があります）。</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">属性名の後に、その属性のパラメータの括弧付きリストが続きます。これらのパラメータは以下の形式のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">属性指定子リストは、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、または &lt;code&gt;enum&lt;/code&gt; 指定子の一部として表示される場合があります。 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; キーワードの直後、または右中括弧の後に置くことができます。前者の構文が推奨されます。属性指定子が閉じ中かっこに続く場合、それらは定義された構造体、共用体、または列挙型に関連していると見なされ、型指定子が含まれる宣言に関連していないと見なされ、定義された型は属性指定子の後まで完全ではありません。</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">属性指定子リストは、ネストされた宣言子の先頭に表示される場合があります。現在、この使用法にはいくつかの制限があります。属性は宣言子に正しく適用されますが、ほとんどの個々の属性では、これが意味するセマンティクスは実装されていません。属性指定子がポインタ宣言子の &lt;code&gt;*&lt;/code&gt; の後に続く場合、それらは存在する任意の型修飾子と混合される場合があります。以下に、この構文の正式なセマンティクスについて説明します。 ISO C標準の宣言子の正式な仕様に精通している場合、これは最も理にかなっています。</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">属性指定子リストは、単一の指定子と修飾子のリストを用いた複数の識別子の宣言において、カンマで区切られた宣言子のリストの中の宣言子の直前に(最初の宣言子以外の)現れることがある。そのような属性指定子は、それらが現れる宣言子の前の識別子にのみ適用される。例えば</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">属性指定子リストは、関数定義以外の識別子の宣言を終了するカンマ、 &lt;code&gt;=&lt;/code&gt; 、またはセミコロンの直前に表示される場合があります。このような属性指定子は、宣言されたオブジェクトまたは関数に適用されます。オブジェクトまたは関数のアセンブラ名が指定されている場合（&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asmラベルを&lt;/a&gt;参照）、属性は &lt;code&gt;asm&lt;/code&gt; 仕様に従う必要があります。</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">属性指定子リストは、将来的には、関数定義の宣言子の後に(旧式のパラメータ宣言や関数本体の前に)現れることが許されるようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">空の置換文字列は、指定された範囲が削除されることを示します。空の範囲（「45：3-45：3」など）は、文字列が指定された位置に挿入されることを示します。</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">コンマと空ではないコンマ区切りの式のリストが後に続く識別子。たとえば、 &lt;code&gt;format&lt;/code&gt; 属性はこのフォームを使用します。</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">識別子。たとえば、 &lt;code&gt;mode&lt;/code&gt; 属性はこの形式を使用します。</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">即時浮動オペランド（式コード &lt;code&gt;const_double&lt;/code&gt; または &lt;code&gt;const_vector&lt;/code&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">即時浮動小数点オペランド（式コード &lt;code&gt;const_double&lt;/code&gt; ）は許可されますが、ターゲットの浮動小数点形式が（コンパイラーが実行されている）ホストマシンのそれと同じである場合に限られます。</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">const_intは符号を128ビットに拡張したものです。</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_intは32ビットの値として扱われます。</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">const_intは64ビットの値として扱われます。</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">ほとんどの算術命令のための即時型。</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">シフト命令と回転命令のためのイミディエイト。</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 命令の即値。const_intは、128ビットに符号拡張されます。</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 命令の即値。const_intは32ビット値として扱われます。</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 命令の即値。const_intは64ビット値として扱われます。</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">即時整数オペランド(定数値を持つもの)が許されています。これには、アセンブル時以降にしか値がわからないシンボリック定数も含まれます。</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">値が明示的な整数ではない即時整数オペランドが許されています。</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">既知の数値を持つ即値整数オペランドを使用できます。多くのシステムは、ワード幅未満のオペランドのアセンブリ時定数をサポートできません。これらのオペランドの制約には、「</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">R2とchi/andci命令のための即時オペランド。</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fsmbi&lt;/code&gt; でロードできる即値。</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">il/ila/ilh/ilhu 命令でロード可能なイミディエイト。</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">il/ila/ilh/ilhu 命令でロードできるイミディエイト。</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">il/ila/ilh/ilhu 命令でロードできるイミディエイト。</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">重要な注意点は、GCCは、コンパイル対象の特定のアーキテクチャバリアントで既知のレジスタのみを保存および復元するように調整していることです。これにより、場合によっては、 &lt;code&gt;__builtin_setjmp&lt;/code&gt; および &lt;code&gt;__builtin_longjmp&lt;/code&gt; が対応するライブラリよりも効率的になりますが、完全なレジスタセットを使用するコードと混合すると、不正確で不可解な動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bb50275db5ef990a5c71386c85806595b867df5" translate="yes" xml:space="preserve">
          <source>An indexed or indirect address.</source>
          <target state="translated">インデックス化された、または間接的なアドレス。</target>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; によって暗黙的にポップされる入力レジスターは、出力オペランドと一致するように制約されていない限り、明示的に破棄する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">-255〜0の範囲の整数定数</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">0〜255の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">1〜15の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">1〜7の範囲の整数定数。</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">コードの制約を満たさない整定数 '</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">16ビットに収まる整数定数。</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">低次16ビットが0である整数定数。</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">正確に1を除くすべてのビットがセットされた整数定数。</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">正確に1ビットがセットされた整数定数。</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">アキュムレータ A1 でのみ使用するのに適した MACFLAG_XXX 定数の 1 つに等しい整数。</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">いずれかのアキュムレータでの使用に適したMACFLAG_XXX定数の1つに等しい整数。</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">割り込みハンドラは必須のポインタ引数で宣言しなければなりません。</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">bext またはビンに適した反転ビットフィールドマスク</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">定数プールの項目</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">リンクに直接供給されるオブジェクトファイル。認識できるサフィックスを持たないファイル名は、このように扱われます。</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">ストレージクラス指定子 &lt;code&gt;__thread&lt;/code&gt; で識別子が宣言されているオブジェクトには、&lt;em&gt;スレッドストレージ期間があり&lt;/em&gt;ます。その存続期間はスレッドの実行全体であり、格納された値は、スレッドの起動前に一度だけ初期化されます。</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">オフセットアドレス</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">オフセットアドレス。</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">有効なメモリアドレスであるオペランドを使用できます。これは、「ロードアドレス」および「プッシュアドレス」命令用です。</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">指定されたオペランド番号に一致するオペランドが許可されます。桁が同じ代替案内で文字と一緒に使用される場合は、その桁が最後に来るようにします。</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">符号付きオーバーフローが発生しないと仮定した最適化は、関係する変数の値が実際にはオーバーフローが発生しないような値であれば、完全に安全です。そのため、この警告は、実際には問題のないコードについての警告という偽のポジティブな警告を容易に与えることができます。重要な問題に焦点を当てるために、いくつかの警告レベルが定義されています。ループが必要とする反復回数を推定する際、特にループが全く実行されないかどうかを判断する際に、未定義の符号付きオーバーフローを使用しても警告は出ません。</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">これらのテクニックの概要、その利点、およびそれらの使用方法は、&lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibilityにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">符号なし16ビット定数(論理命令用)。</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; および &lt;code&gt;fsmbi&lt;/code&gt; の符号なし16ビット定数。</target>
        </trans-unit>
        <trans-unit id="c10f415d71c7e7066c4b909d3f1393b2cce4e125" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant shifted left 16 bits (use &lt;code&gt;L&lt;/code&gt; instead for &lt;code&gt;SImode&lt;/code&gt; constants).</source>
          <target state="translated">符号なし16ビット定数は左に16ビットシフトしました（ &lt;code&gt;SImode&lt;/code&gt; 定数の代わりに &lt;code&gt;L&lt;/code&gt; を使用してください）。</target>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">符号なし16ビットの定数。</target>
        </trans-unit>
        <trans-unit id="bb28e9e819d64e02267cdf40ed8e86dabcf29201" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit integer constant.</source>
          <target state="translated">符号なし16ビット整数定数。</target>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">16 バイトのローテートおよびシフト用の符号なし 3 ビット定数</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">符号なし5ビットの定数。</target>
        </trans-unit>
        <trans-unit id="7983abc6cf90ba7d41ddff4f3b8b3d5f6d999d50" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit integer constant (for shift counts).</source>
          <target state="translated">符号なし5ビットの整数定数(シフトカウント用)。</target>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">変換/nop/チャンネル命令用の符号なし7ビット定数。</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">最下位3ビットが0の符号なし7ビット定数。</target>
        </trans-unit>
        <trans-unit id="d8264da1da251da38e16c7abcf0200adc7f6c27d" translate="yes" xml:space="preserve">
          <source>An unsigned 8-bit integer constant.</source>
          <target state="translated">符号なし8ビット整数定数。</target>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">文字列メモリの引数の長さが不明な x86 の例。</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">そして関数名は</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">アセンブラ命令に推定アドレスをアノテーションします。</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">コンパイルの早い段階でユーザ変数への代入をアノテーションし、最適化しながらデバッグ情報を改善するために、コンパイルの最後までアノテーションを引き継ぐようにしてください。の使用</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">アセンブラの出力に、どのパターンと代替案が使用されているかを示すコメントをアノテーションします。各命令の長さとコストも表示されます。</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">アセンブラの出力に雑多なデバッグ情報をアノテーションします。</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">リンク時間の最適化を有効にするもう一つの(より簡単な)方法があります。</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">もう1つの結果は、 &lt;code&gt;sscanf&lt;/code&gt; が非常に古いシステムでは、文字列定数をフォーマット制御文字列または入力として渡したときに機能しないことです。これは、 &lt;code&gt;sscanf&lt;/code&gt; が誤って文字列定数に書き込もうとするためです。同様に &lt;code&gt;fscanf&lt;/code&gt; と &lt;code&gt;scanf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">別の例です。</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">LTOのもう一つの特徴は、異なる言語で書かれたファイルに対して、手順間の最適化を適用できることです。</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">もう1つの制限は、クロバーリストにスタックポインターレジスタを含めないことです。これは、コンパイラがスタックポインタの値を &lt;code&gt;asm&lt;/code&gt; ステートメントの後も、ステートメントの開始時と同じにする必要があるためです。ただし、GCCの以前のバージョンではこのルールは適用されず、セマンティクスが不明確なスタックポインターをリストに表示することができました。この動作は非推奨であり、スタックポインタのリストはGCCの将来のバージョンでエラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">別の改訂ISO C ++標準は2014年にISO / IEC 14882：2014として公開され、C ++ 14と呼ばれています。公開前は、C ++ 1yと呼ばれることもありました。C ++ 14には、C ++言語に対するいくつかのさらなる変更が含まれており、それらはすべてGCCに実装されています。詳細については、&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https：//gcc.gnu.org/projects/cxx-status.html#cxx14を&lt;/a&gt;参照してください。GCCでこの標準を選択するには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">GCC 2.5で廃止された、同じ意味を持つ別の構文は '</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">&lt;code&gt;__builtin_unreachable&lt;/code&gt; のもう1つの用途は、次の例のように、決して戻らないが &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; と宣言されていない関数の呼び出しに従うことです。</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">ラベル値のもう一つの用途は、スレッドコード用のインタプリタにあります。インタープリタ関数内のラベルは、超高速ディスパッチのためにスレッドコード内に格納することができます。</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">式のタイプを参照する別の方法は、 &lt;code&gt;typeof&lt;/code&gt; を使用することです。このキーワードを使用する構文は &lt;code&gt;sizeof&lt;/code&gt; のように見えますが、構文は &lt;code&gt;typedef&lt;/code&gt; で定義された型名のように機能します。</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">のようなプレフィックスを指定する方法もあります。</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">別の同様の例では、基底クラスのメンバ関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">任意の 80387 浮動小数点(スタック)レジスタ。</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">どれ &lt;code&gt;symbol_ref&lt;/code&gt; または &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">どれ &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">D、P、B、M、I、Lのいずれかのレジスタ。</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">EVEXでエンコード可能なSSEレジスタ（ &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">任意のMMXレジスタ。</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">任意のSSEレジスタ。</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">任意のSYMBOL_REF。</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">の場合は、任意のVSXレジスタ</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">lvalueでなくても、任意の配列を添え字にすることができます。</target>
        </trans-unit>
        <trans-unit id="b906590ae8882826b85c1f14c38d4cf1bfbb5d1f" translate="yes" xml:space="preserve">
          <source>Any condition register field, &lt;code&gt;cr0&lt;/code&gt;&amp;hellip;&lt;code&gt;cr7&lt;/code&gt;.</source>
          <target state="translated">任意の条件レジスタフィールド、 &lt;code&gt;cr0&lt;/code&gt; &amp;hellip; &lt;code&gt;cr7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">任意のconst_double値。</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">16ビット幅の場合の制御レジスター（制御レジスターが24ビット幅の場合は何もない）</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">24ビット幅の場合の任意の制御レジスタ。</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">非ジェネリックアドレス空間へのデータまたはポインタは、 &lt;code&gt;const&lt;/code&gt; として、つまり読み取り専用データとして修飾する必要があります。これは、ソフトウェアバージョン番号やキャリブレーションルックアップテーブルなどのこれらのアドレススペースのいずれかのデータが、ロード後に、ブートローダーなどによって変更される予定の場合にも適用されます。この場合、正しい修飾は &lt;code&gt;const&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; であるため、コンパイラは既知の値を最適化したり、命令のオペランドに即値として挿入したりしてはなりません。</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">&lt;code&gt;noinit&lt;/code&gt; 属性を持つデータは、Cランタイムスタートアップコードまたはプログラムローダーによって初期化されません。この方法でデータを初期化しないことで、プログラムの起動時間を短縮できます。</target>
        </trans-unit>
        <trans-unit id="b31ade70b5b6adb7eda689c140579a407cbd5f8e" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialized by the C runtime startup code, or the program loader. Not initializing data in this way can reduce program startup times. This attribute is specific to ELF targets and relies on the linker to place such data in the right location</source>
          <target state="translated">&lt;code&gt;noinit&lt;/code&gt; 属性を持つデータは、Cランタイムスタートアップコードまたはプログラムローダーによって初期化されません。この方法でデータを初期化しないと、プログラムの起動時間を短縮できます。この属性はELFターゲットに固有であり、リンカーに依存してそのようなデータを適切な場所に配置します</target>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">レイテンシが &lt;var&gt;number&lt;/var&gt; 以上の依存関係はコストがかかります。</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">店舗から負荷への依存はコストがかかります。</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">で指定されたすべてのディレクトリ</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 型の式はすべて許可されます。</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">実装に存在する任意の拡張整数型(C99及びC11 6.2.5)。</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">スタックスイッチなしの割込み可能なコードはすべて</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">宣言の先頭にある指定子と修飾子のリストには、そのようなリストにストレージクラス指定子が含まれているかどうかに関係なく、属性指定子を含めることができます。（一部の属性は、しかし、ストレージ・クラス指定の性質に本質的であり、記憶クラス指定子を使用することができる場合にのみ意味をなす、例えば、 &lt;code&gt;section&lt;/code&gt; 。）この構文には必要な制限が1つあります。関数定義の最初の古いスタイルのパラメータ宣言は、属性指定子で始めることはできません。この場合に実装されます）。他のいくつかのケースでは、属性指定子はこの文法では許可されていますが、コンパイラではまだサポートされていません。この場所のすべての属性指定子は、全体としての宣言に関連しています。 &lt;code&gt;int&lt;/code&gt; の型が型指定子がないことによって暗示される陳腐化した使用法では、そのような指定子と修飾子のリストは、他の指定子または修飾子のない属性指定子リストになる場合があります。</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">プリコンパイル済みヘッダーが含まれる前に定義されたマクロは、プリコンパイル済みヘッダーの生成時と同じ方法で定義するか、プリコンパイル済みヘッダーに影響を与えないようにする必要があります。つまり、通常はプリコンパイル済みヘッダーにまったく表示されません。</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">遠方アドレス空間のアドレスへのメモリ参照。</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">近いアドレス空間のアドレスへの任意のメモリ参照。</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">関数のエントリ時のどのモードも有効であり、関数が戻ってきた時や他の関数を呼び出した時に保持または復元されます。このモードは、ライブラリやその他のコンパイルユニットを、異なる一般的なFPUモードで異なるプログラムに組み込みたい場合に便利です。また、単一のオブジェクトファイルを使用できるという利便性は、一般的なFPUモードをより具体的に選択する場合に必要とされるものと比較して、必要とされるかもしれない余分なモード切り替えのためのサイズと速度のオーバーヘッドを上回ります。</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">SVE述語レジスタのいずれか（ &lt;code&gt;P0&lt;/code&gt; へ &lt;code&gt;P15&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">浮動小数点レジスタ(AC0~AC5)のいずれか。</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">どんなオペランドでも許されています。</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">任意のレジスタ</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; としてアクセス可能な任意のレジスタ： &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、および &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; としてアクセス可能な任意のレジスタ。32ビットモードで &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、b、 &lt;code&gt;c&lt;/code&gt; 、および &lt;code&gt;d&lt;/code&gt; 。64ビットモードでは、任意の整数レジスタ。</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">アキュムレータまたはCC以外のすべてのレジスタ。</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">一般的なレジスタではないレジスタを除いて、任意のレジスタ、メモリ、または即時整数オペランドが許可されます。</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;based&lt;/code&gt; 属性を持つ変数は &lt;code&gt;.based&lt;/code&gt; セクションに割り当てられ、 &lt;code&gt;$tp&lt;/code&gt; レジスターを基準にしてアクセスされます。</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">&lt;code&gt;persistent&lt;/code&gt; 属性を持つ変数は、Cランタイムスタートアップコードによって初期化されません。代わりに、アプリケーションが読み込まれたときにその値が一度設定され、プロセッサがリセットされたりプログラムが再起動したりしても、再度初期化されることはありません。永続データは、フラッシュRAMに配置することを目的としており、その値はリセット後も保持されます。アプリケーションの作成に使用されるリンカースクリプトは、永続データが正しく配置されていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">追加の &lt;var&gt;dir&lt;/var&gt; 接頭辞には、と以前に指定しました</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">I-unitに常駐しているアプリケーションレジスター</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">Mユニットに常駐しているアプリケーションレジスター</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">パーティショニングされた実行最適化を適用します。これは、任意のレベルの最適化が選択されている場合のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">後続のすべての関数宣言に &lt;code&gt;longcall&lt;/code&gt; 属性を適用します。</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">実行可能なループにアンロール変換とジャム変換を適用します。ループネストでは、これは外側のループを何らかの要因で展開し、結果として生じる複数の内側のループを融合させます。このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">タイプ &lt;code&gt;uh&lt;/code&gt; 、 &lt;code&gt;uw1&lt;/code&gt; 、 &lt;code&gt;sw1&lt;/code&gt; 、 &lt;code&gt;uw2&lt;/code&gt; 、および &lt;code&gt;sw2&lt;/code&gt; の引数は、実行時に評価されます。これらは、基になるFR-V命令のレジスタオペランドに対応します。</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">&lt;code&gt;const int&lt;/code&gt; として文書化されている引数には、その操作に必要な範囲内のリテラル整数値が必要です。</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; ポインターと関数ポインターの演算。</target>
        </trans-unit>
        <trans-unit id="69bbb6fc13a2914af3927b07e93cd7741bc9feb7" translate="yes" xml:space="preserve">
          <source>Armv8-A</source>
          <target state="translated">Armv8-A</target>
        </trans-unit>
        <trans-unit id="660e1e41a2fb561d4417587f9d3cb0a826807dab" translate="yes" xml:space="preserve">
          <source>Armv8.1-A</source>
          <target state="translated">Armv8.1-A</target>
        </trans-unit>
        <trans-unit id="068702f6b509e3ebf3a7362a3b6109bad1bc317c" translate="yes" xml:space="preserve">
          <source>Armv8.2-A</source>
          <target state="translated">Armv8.2-A</target>
        </trans-unit>
        <trans-unit id="9fe2d2038a9bf766f6b65dbcea4a2090d8403b7b" translate="yes" xml:space="preserve">
          <source>Armv8.3-A</source>
          <target state="translated">Armv8.3-A</target>
        </trans-unit>
        <trans-unit id="0c3f33729a39f559eae20d5545e995ad551dd902" translate="yes" xml:space="preserve">
          <source>Armv8.4-A</source>
          <target state="translated">Armv8.4-A</target>
        </trans-unit>
        <trans-unit id="255ee3b7801398dad2fbbd56f35d7d60c8e0a39d" translate="yes" xml:space="preserve">
          <source>Armv8.5-A</source>
          <target state="translated">Armv8.5-A</target>
        </trans-unit>
        <trans-unit id="4b5d9fa165aea4d969d0093fec00424d91bb68a1" translate="yes" xml:space="preserve">
          <source>Armv8.6-A</source>
          <target state="translated">Armv8.6-A</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">実行時に長さが計算される配列。</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">GNUの拡張機能として、GCCでは複合リテラルによる静的記憶期間を持つオブジェクトの初期化を可能にしています(ISO C99では初期化子が定数ではないためできません)。複合リテラルとオブジェクトの型が一致する場合には、中括弧付きリストのみでオブジェクトを初期化したかのように扱われます。複合リテラルの要素は定数でなければなりません。初期化対象のオブジェクトがサイズ不明の配列型を持つ場合は、複合リテラルのサイズで決定されます。</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">ACLCの一部として、GCCはARM C言語拡張仕様で説明されているようにAdvanced SIMDの拡張機能を実装します。Advanced SIMD組み込みの完全なリストは、&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http：//infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdfにあり&lt;/a&gt;ます。Advanced SIMD拡張の組み込み組み込み関数は、NEONが有効になっている場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">その結果、Sun CCでコンパイルされた関数が &lt;code&gt;double&lt;/code&gt; 型の引数のアドレスを受け取り、この &lt;code&gt;double *&lt;/code&gt; 型のポインタをGCCでコンパイルされた関数に渡す場合、ポインタを逆参照すると致命的なシグナルが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">その結果、ファイルが</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">特別な kludge として、もし</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">仕様文字列を提供する代わりに、サフィックスディレクティブの後に続くテキストは以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">拡張として、整数スカラー型 &lt;code&gt;__int128&lt;/code&gt; は、128ビットを保持するのに十分な幅の整数モードを持つターゲットでサポートされます。単に書き込み &lt;code&gt;__int128&lt;/code&gt; 符号付き128ビット整数のために、または &lt;code&gt;unsigned __int128&lt;/code&gt; 符号なしの128ビット整数のために。128ビット幅よりも &lt;code&gt;long long&lt;/code&gt; 整数のターゲットに対して &lt;code&gt;__int128&lt;/code&gt; 型の整数定数を表現するためのGCCのサポートはありません。</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">C言語の拡張機能として、GCCはC99およびC11で指定された緯度を使用せず、署名された特定の側面のみを扱います '</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">拡張機能として、GCCは構造体やユニオンのメンバとして可変長の配列を受け入れます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">拡張として、GNU C と GNU C++は、すべてのターゲットでサポートされているわけではない追加の浮動型をサポートしています。</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">拡張として、GNU CはISO/IEC WDTR24732のN1312ドラフトで定義されている10進数の浮動小数点型をサポートしています。GCCでの10進数浮動小数点型のサポートは、技術報告書の草案の変更に合わせて進化していくでしょう。ターゲットの呼び出し規則も変わるかもしれません。すべてのターゲットが10進数の浮動小数点型をサポートしているわけではありません。</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">拡張として、GNU CはISO/IEC DTR 18037のN1169ドラフトで定義されている固定小数点型をサポートしています。GCCにおける固定小数点型のサポートは、技術報告書の草案の変更に合わせて進化していくでしょう。ターゲットの呼び出し規則も変わるかもしれません。すべてのターゲットが固定小数点型をサポートしているわけではありません。</target>
        </trans-unit>
        <trans-unit id="6505eef47254e959e5dceda5b17ed5092c6fdad3" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">その拡張として、GNU CはISO/IEC DTR 18037のN1275ドラフトで定義されている名前付きアドレス空間をサポートしています。GCCにおける名前付きアドレス空間のサポートは、技術報告書の草案の変更に合わせて進化していくでしょう。任意のターゲットに対する呼び出し規則も変わるかもしれません。現在、AVR、M32C、RL78、x86ターゲットだけが汎用アドレス空間以外のアドレス空間をサポートしています。</target>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">その拡張として、GNU CはISO/IEC DTR 18037のN1275ドラフトで定義されている名前付きアドレス空間をサポートしています。GCCにおける名前付きアドレス空間のサポートは、技術報告書の草案の変更に合わせて進化していくでしょう。任意のターゲットに対する呼び出し規則も変わるかもしれません。現在、AVR、SPU、M32C、RL78、x86ターゲットだけが汎用アドレス空間以外のアドレス空間をサポートしています。</target>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">最適化として、G ++は時々配列複合リテラルの寿命を延ばします：配列が関数の外に現れるか、または &lt;code&gt;const&lt;/code&gt; 修飾型を持つ場合。場合は &lt;code&gt;foo&lt;/code&gt; とその初期化子が型の要素を持っていた &lt;code&gt;char *const&lt;/code&gt; ではなく &lt;code&gt;char *&lt;/code&gt; 場合、または &lt;code&gt;foo&lt;/code&gt; がグローバル変数だった、配列は、静的記憶域期間を持つことになります。ただし、C ++コードで配列複合リテラルを使用しないようにするのがおそらく最も安全です。</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">別の例として</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">別の例として、次の &lt;code&gt;strncpy&lt;/code&gt; の呼び出しは、NULを末尾に追加せずに、終了NULの前の文字だけを &lt;code&gt;d&lt;/code&gt; にコピーします。 &lt;code&gt;strncpy&lt;/code&gt; の結果が必然的にNULで終了する文字列であると仮定することは一般的な誤りであり、そのため呼び出しが診断されます。結果がNULで終了すると予期されない場合の警告を回避するには、代わりに &lt;code&gt;memcpy&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">ビットフィールドは個別にアドレス指定可能ではないので、揮発性ビットフィールドは、書き込まれたとき、または隣接するビットフィールドがアクセスされたときに暗黙のうちに読み出されてもよい。ビットフィールド操作は、隣接するビットフィールドがストレージユニットの境界にまたがっている場合、部分的にしかアクセスされないように最適化されてもよい。これらの理由から、ハードウェアにアクセスするために揮発性ビットフィールドを使用することは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;一般的な関数属性&lt;/a&gt;で説明したように、この属性を使用すると、ターゲット固有のコンパイルオプションを指定できます。</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">はどうかと言うと '</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">標準C++やISO C99のように、自動変数のための集約型初期化器の要素は、GNU Cでは定数式である必要はありません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
