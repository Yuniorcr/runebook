<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">インラインされた文字列操作の宛先を揃えるかどうかを指定します。</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">識別子にはドル記号を使用することができます。</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">DWARF行番号デバッグ情報のアセンブラコードを生成しません（またはしません）。これは、GNUアセンブラを使用していない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="c37914471f4a30f8d34225039b83103b924890c2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add</source>
          <target state="translated">追加しないでください</target>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">&lt;code&gt;r32&lt;/code&gt; &amp;hellip; &lt;code&gt;r63&lt;/code&gt; の範囲のレジスタを割り当てないでください。これにより、これらのレジスタがないハードウェアバリアントでコードを実行できます。</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">コンパイラが特権モードコードを生成することを許可（許可）しないでください。指定</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">インラインテンプレートの暗黙的なインスタンス化のコードも発行しません。デフォルトでは、インラインを異なる方法で処理するため、最適化ありとなしのコンパイルでは、明示的なインスタンス化の同じセットが必要です。</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">実行時に例外指定の違反をチェックするコードを生成しないでください。このオプションはC ++標準に違反していますが、 &lt;code&gt;NDEBUG&lt;/code&gt; を定義するのと同じように、製品ビルドでコードサイズを削減するのに役立ちます。これは、ユーザーコードに、例外仕様に違反して例外をスローする許可を与えません。コンパイラは依然として仕様に基づいて最適化するため、予期しない例外をスローすると、実行時に未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">条件付き分岐の直後にCSYNCまたはSSYNC命令が発生するのを防ぐために、追加のコードを生成しないでください。</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">投機的なロードの発生を防ぐために追加のコードを生成しないでください。</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">ターゲットレジスタの優先順位を指定しないでください。</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">NOPを挿入しないでください。</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">リーフ関数のフレームポインターをレジスターに保持しないでください。これにより、フレームポインターの保存、セットアップ、復元の指示が回避され、追加のレジスターをリーフ関数で使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">リーフ関数のフレームポインターをレジスターに保持しないでください。これにより、フレームポインターを保存、セットアップ、および復元する命令が回避され、追加のレジスターがリーフ関数で使用可能になります。オプション</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">AVR-LibCのデバイス固有のライブラリ &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; mcu &amp;gt; .aに対してリンクしないでください。</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">&lt;code&gt;.size&lt;/code&gt; アセンブラディレクティブ、または関数が中央で分割され、2つの半分がメモリ内の離れた場所に配置されている場合に問題を引き起こす可能性のあるその他のものを出力しないでください。このオプションはコンパイル時に使用されます</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">動的にリンクされた位置に依存しない実行可能ファイルを作成しないでください。</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">'で始まらない組み込み関数を認識しない</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">オブジェクトを返す必要があるときに参照を返そうとしないでください。</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">呼び出しに25ビット未満のアドレッシング範囲を使用しないでください。これは、無条件分岐リンク命令で使用可能なオフセットです。関数呼び出しの条件付き実行が抑制され、条件付きブランチとリンクで21ビット範囲ではなく、25ビット範囲を使用できるようになります。これは、 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; および &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; ターゲット用にビルドされたツールチェーンのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">&lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; ランタイムルーチンを使用しないでください。これにより &lt;code&gt;std::uncaught_exception&lt;/code&gt; が正しくなくなりますが、ランタイムルーチンが利用できない場合に必要です。</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">倍精度浮動小数点。</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">倍精度の最小値と最大値。これらの命令は、以下の場合にのみ生成されます。</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">倍精度三角関数と指数関数。これらの命令は、以下の場合にのみ生成されます。</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">ダブルワード整数&amp;mdash; &lt;code&gt;long long int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">不適合コードに関するいくつかの診断をエラーから警告にダウングレードします。このように</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">制限のため、 &lt;var&gt;type-or-expression&lt;/var&gt; 引数によって参照される型または変数が宣言されている場合でも、 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 関数は &lt;code&gt;mode&lt;/code&gt; 属性に対して &lt;code&gt;false&lt;/code&gt; を返します。この関数は、ラベルやCでは列挙子でもサポートされていません。</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">遅延スロットスケジューリングとオペランド番号、リテラルサイズ、命令長、条件付き実行のサポート間の相互作用のため、条件付き実行を生成するためのターゲットに依存しないパスはしばしば不足しているため、ARCポートではレジスタ割り当て、ブランチ短縮、遅延スロットスケジューリングが行われた後に、より多くの条件付き実行生成の機会を見つけようとする特別なパスを保持しています。このパスは一般的に、常にではありませんがパフォーマンスとコードサイズを向上させますが、コンパイル時間を余分に犠牲にしています。呼び出し命令が条件付きであるために許容オフセット範囲を超えてしまう問題がある場合は</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">64 ビット ABI の違いにより、System V の ABI 関数を呼び出す Microsoft ABI 関数は、RSI、RDI、XMM6-15 をクローバされたと見なさなければなりません。デフォルトでは、これらのレジスタの保存と復元のコードはインラインで出力されるため、かなり長いプロローグとエピローグになります。以下のような使い方をします。</target>
        </trans-unit>
        <trans-unit id="408f58f18488b8883676547177ce8b939c3a83db" translate="yes" xml:space="preserve">
          <source>Dump a representation of the &amp;ldquo;exploded graph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">GraphVizでの表示に適した「展開されたグラフ」の表現をダンプします</target>
        </trans-unit>
        <trans-unit id="169bc667798b22c68aedd5d55d686c15e2808baf" translate="yes" xml:space="preserve">
          <source>Dump a representation of the call graph suitable for viewing with GraphViz to</source>
          <target state="translated">GraphVizで表示するのに適したコールグラフの表現をGraphVizにダンプします。</target>
        </trans-unit>
        <trans-unit id="57d46471a4ce7f3b77f03f78421a9baa93db393b" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to</source>
          <target state="translated">「展開されたグラフ」のテキスト表現をにダンプします</target>
        </trans-unit>
        <trans-unit id="ca50a32f407b97e3b5dbaa8c49a491f9e0224426" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to one dump file per node, to</source>
          <target state="translated">「展開されたグラフ」のテキスト表現をノードごとに1つのダンプファイルにダンプします。</target>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">RTL生成後にダンプ。</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">全てのrtlが共有されていない状態になってからダンプします。</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">auto-inc-dec の検出後にダンプします。このパスは auto inc または auto dec 命令を持つアーキテクチャでのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">ブロックの並び替え後にダンプします。</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">分岐配置が計算された後にダンプします。</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">バリアの説明書を片付けた後にダンプします。</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">スタック調整を組み合わせた後にダンプします。</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">共通シーケンスの発見後にダンプします。</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">GCCの「フラットレジスタファイル」レジスタからx87のスタックのようなレジスタに変換した後にダンプします。このパスは、x86バリアントでのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">EH処理範囲領域の変換後のダンプ。</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">cfglayoutモードからの変換後のダンプ。</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">cfglayoutモードに変換した後のダンプ。</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">仮想レジスタをハードレジスタに変換した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">遅延ブランチスケジューリング後のダンプ</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">計算されたgetosを複製した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">EHハンドリングコードの確定後にダンプする。</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">in/out制約が満たされていないrtl文を修正した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">関数のインライン化後にダンプします。</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">関数プロローグとエピローグを生成した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">ハードレジスタコピー伝播後のダンプ。</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">反復されたレジスタ割り当ての後にダンプします。</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">ジャンプバイパスと制御フローの最適化後のダンプ。</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">ライブレンジ分割後のダンプ</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">モデューロスケジューリングの後にダンプします。このパスはいくつかのアーキテクチャでのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">ホットとコールドの基本ブロックを分割した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">マシン依存の再編成パスが存在する場合は、マシン依存の再編成パスを実行した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">リロード後の最適化後のダンプ。</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">レジスタのリナンバリング後にダンプします。</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">冗長モードスイッチを削除した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">枝を短くしてからダンプ。</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">兄弟通話の最適化後にダンプします。</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">サイン/ゼロ延長消去後のダンプ</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">RTL命令の組み合わせパス後にダンプします。</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">初期値セットの計算後にダンプします。</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">レジスタの初期化後にダンプします。</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">覗き穴パスの後にダンプ。</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">2回目のジャンプ最適化後のダンプ</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">スタンドアローンのデッドコード除去が通過した後にダンプします。</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">変数追跡後のダンプ。</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">通常の出力に加えて、前処理の最後にすべてのマクロ定義をダンプします。</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">クラス階層情報をダンプします。仮想テーブル情報は '</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">レコードの内容をダンプします。</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">デバッグ生成フェーズで生成されたデバッグ情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">初期のデバッグ生成フェーズで生成されたデバッグ情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="1abef1a2a1cc464ec73ba64187b2cddb0b1c7d96" translate="yes" xml:space="preserve">
          <source>Dump initial values of the variables.</source>
          <target state="translated">変数の初期値をダンプします。</target>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">アセンブリコード内のダンプ命令のサイズと位置。</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">ソースファイルで見られるすべてのクラスのインターフェイス宣言をファイル名にダンプします。</target>
        </trans-unit>
        <trans-unit id="71af018e18b101632a18de688096b3fe9f9a731e" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to</source>
          <target state="translated">アナライザが何をしているかについての内部の詳細をダンプします。</target>
        </trans-unit>
        <trans-unit id="e377d6eb44f5fb68248439a06aca414e07626287" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to stderr. This option overrides</source>
          <target state="translated">アナライザが何をしているかの内部詳細を標準エラーにダンプします。このオプションは</target>
        </trans-unit>
        <trans-unit id="657cfbab09055c61a05bd93612f91cf2d2f1bab3" translate="yes" xml:space="preserve">
          <source>Dump only the defined symbols.</source>
          <target state="translated">定義されたシンボルのみをダンプします。</target>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">をダンプアウトします。</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">レコードの位置をダンプします。</target>
        </trans-unit>
        <trans-unit id="62f71366775032a269dc239f7ef38d5ece6fef12" translate="yes" xml:space="preserve">
          <source>Dump representations of the &amp;ldquo;supergraph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">GraphVizでの表示に適した「スーパーグラフ」の表現をダンプして</target>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">各命令の前にコメントとしてアセンブラ出力にRTLをダンプします。また</target>
        </trans-unit>
        <trans-unit id="0be5cff07653f79d7c01424690f5d095b8fcbb7d" translate="yes" xml:space="preserve">
          <source>Dump the demangled output.</source>
          <target state="translated">デマングされた出力をダンプします。</target>
        </trans-unit>
        <trans-unit id="1726ca951812ad3322375de05b128457cc9a8ced" translate="yes" xml:space="preserve">
          <source>Dump the details of LTO objects.</source>
          <target state="translated">LTOオブジェクトの詳細をダンプします。</target>
        </trans-unit>
        <trans-unit id="171aa9511579073802041f0a2e60b1934e57be91" translate="yes" xml:space="preserve">
          <source>Dump the details of specific symbol.</source>
          <target state="translated">特定のシンボルの詳細をダンプします。</target>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">最終的な内部表現（RTL）を &lt;var&gt;file&lt;/var&gt; にダンプします。オプションの引数が省略された場合（または &lt;var&gt;file&lt;/var&gt; が &lt;code&gt;.&lt;/code&gt; 場合）、ダンプファイルの名前は、コンパイル出力ファイル名に &lt;code&gt;.gkd&lt;/code&gt; を追加することによって決定されます。</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">生の内部ツリーデータをダンプします。このオプションは C++のみに適用されます。</target>
        </trans-unit>
        <trans-unit id="1afb37f8221633019abbbb6e4139e775923345d4" translate="yes" xml:space="preserve">
          <source>Dump the specific gimple body.</source>
          <target state="translated">特定のキモオタボディを捨てる。</target>
        </trans-unit>
        <trans-unit id="be1097bb2eea2f70c64d4c1cb70ed1c5ba583376" translate="yes" xml:space="preserve">
          <source>Dump the statistics of gimple statements.</source>
          <target state="translated">ギムプル文の統計をダンプします。</target>
        </trans-unit>
        <trans-unit id="3a4757ccb92c3f2e13c8881d180d079b3623ccf0" translate="yes" xml:space="preserve">
          <source>Dump the statistics of tree types.</source>
          <target state="translated">ツリータイプの統計情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="1f4cd598ed5041028b59e01e68f001fefceb7ea6" translate="yes" xml:space="preserve">
          <source>Dump the statistics of trees.</source>
          <target state="translated">木の統計をダンプします。</target>
        </trans-unit>
        <trans-unit id="3b93daf63f806cdb033463ad6f03043c2e411af3" translate="yes" xml:space="preserve">
          <source>Dump the symbols in order of occurrence.</source>
          <target state="translated">記号を出現順にダンプします。</target>
        </trans-unit>
        <trans-unit id="389f264332906b0c1d732e39c64a371de3b149c7" translate="yes" xml:space="preserve">
          <source>Dump the symbols in reverse order.</source>
          <target state="translated">シンボルを逆順にダンプします。</target>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">コールグラフの最適化、未使用関数の削除、インライン化の決定に関する情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="3288dac3087a7accf2fa127698249b8034a173fa" translate="yes" xml:space="preserve">
          <source>Dumps list of details of functions and variables.</source>
          <target state="translated">関数や変数の詳細をダンプしたリストです。</target>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">1つのオブジェクトファイルで明示的なインスタンス化を定義し、 &lt;code&gt;extern template&lt;/code&gt; 構文を使用して明示的なインスタンス化宣言を使用することにより、コンパイラが他のオブジェクトファイルで暗黙的なインスタンス化を行わないようにすることで、テンプレートの重複インスタンスを回避できます。</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">IPA-CPは、関数本体の解析において、関数パラメータが指す値を追跡するために、エイリアス解析を採用しています。巨大な関数の解析に時間をかけすぎないようにするために、関数本体の解析を行った後は、すべてのメモリを諦めて</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">インクリメンタルリンク中(</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">リンク時間の最適化の際に、異なるコンパイルユニットからのグローバル宣言の型の不一致を警告します。必要なのは</target>
        </trans-unit>
        <trans-unit id="3941436ae2dc30b7d71f0708c7f73c50626caec3" translate="yes" xml:space="preserve">
          <source>During the link-time optimization, do not warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">リンク時間の最適化の際に、異なるコンパイルユニットからのグローバル宣言の型の不一致を警告しないようにします。必要なもの</target>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">動的丸めモード。浮動小数点制御レジスター（ &lt;var&gt;fpcr&lt;/var&gt; 、Alphaアーキテクチャーのリファレンス・マニュアルを参照）のフィールドは、有効な丸めモードを制御します。Cライブラリは、このレジスタを初期化してプラス無限大に丸めます。したがって、プログラムが &lt;var&gt;fpcr&lt;/var&gt; を変更しない限り、 '</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">条件コードレジスタを動的に割り当てます。</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">EAMレジスター &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">EAMレジスター &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="db3a4c6dcbc964f457aa623cff604baca1fe6abf" translate="yes" xml:space="preserve">
          <source>ESC \</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">EXECレジスタ(EXEC_LO、EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">それぞれ '</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">各 &lt;var&gt;branch&lt;/var&gt; 形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">各 &lt;var&gt;file&lt;/var&gt; 形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">各 &lt;var&gt;function&lt;/var&gt; 形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">それぞれの &lt;var&gt;line&lt;/var&gt; 次の形式があります。</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">各アーキテクチャは追加の制約を定義します。これらの制約は、コンパイラー自体が命令の生成や &lt;code&gt;asm&lt;/code&gt; ステートメントに使用します。したがって、一部の制約は &lt;code&gt;asm&lt;/code&gt; には特に役立ちません。以下は、特定のマシンで利用可能なマシン依存の制約の要約です。これには、 &lt;code&gt;asm&lt;/code&gt; に役立つ制約と役に立たない制約の両方が含まれます。各アーキテクチャの表の見出しに記載されているコンパイラのソースファイルは、そのアーキテクチャの制約の意味の最も信頼できるリファレンスです。</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">マクロへの各引数は、マクロの展開の中で一度しか現れません。これは、そのようなマクロへの呼び出しがそのようなマクロの引数の中に入れ子になっている場合に、マクロの展開のサイズが指数関数的に大きくなるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">それぞれの引数には、型のエンコーディングと、パラメータのリストの中の引数のオフセット(バイト数)が続きます。</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">各識別子は、それが宣言された場所から、それを囲むブロックの最後まで見えるようになっています。</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">各実装には、条件付きでサポートされているがサポートされていないすべての構成体を識別する文書を含めるものとする(C++0x 1.4)。</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">マシンの種類ごとに、 &lt;code&gt;char&lt;/code&gt; のデフォルトが設定されています。デフォルトでは &lt;code&gt;unsigned char&lt;/code&gt; のように、またはデフォルトでは &lt;code&gt;signed char&lt;/code&gt; のようになっています。</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">プリコンパイルされたヘッダをビルドして使用する際には、以下の各オプションが同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">これらはそれぞれ、r0 から r10 までの個々のレジスタのレジスタ制約を表しています。</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">GCCでサポートされている各ターゲットマシンには独自のオプションがあります。たとえば、特定のプロセッサバリアントまたはABI用にコンパイルしたり、そのマシンに固有の最適化を制御したりできます。慣例により、マシン固有のオプションの名前は「</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">各変数の値は、 &lt;code&gt;PATH&lt;/code&gt; のような特殊文字で区切られたディレクトリのリストで、ヘッダーファイルを検索します。特殊文字 &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; はターゲットに依存し、GCCビルド時に決定されます。Microsoft Windowsベースのターゲットの場合はセミコロンであり、他のほとんどすべてのターゲットの場合はコロンです。</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">埋め込み文は、列挙定数の値、ビットフィールドの幅、静的変数の初期値などの定数表現では使用できません。</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">ELF オブジェクトに余分な情報を記録するために RISC-V 属性を放出します (放出しません)。この機能には最低でも binutils 2.32 が必要です。</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">&lt;code&gt;_mcount&lt;/code&gt; が呼び出し元の関数の戻りアドレスを変更できるようにするコードを放出します（放出しません）。このオプションを有効にすると、通常の &lt;code&gt;_mcount&lt;/code&gt; インターフェースが新しい &lt;var&gt;ra-address&lt;/var&gt; パラメーターで拡張されます。これは、タイプが &lt;code&gt;intptr_t *&lt;/code&gt; で、レジスター &lt;code&gt;$12&lt;/code&gt; 渡されます。 &lt;code&gt;_mcount&lt;/code&gt; は、次の両方を実行することにより、戻りアドレスを変更できます。</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">.gnu.attribute アセンブリディレクティブを発行して、関数パラメータや戻り値の ABI バリエーションを指定する .gnu.attributes セクションのタグと値のペアを設定します。</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">EMITは &lt;code&gt;.stack_size&lt;/code&gt; アセンブリ出力の各機能のためのディレクティブ。このオプションのデフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">EMIT &lt;code&gt;static&lt;/code&gt; 関数が使用されることはありません場合でも、オブジェクトファイルに機能し、。</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">EMITの &lt;var&gt;num&lt;/var&gt; 個の他のすべての生成された命令の前にNOP。</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">GASの &lt;code&gt;.cfi_*&lt;/code&gt; ディレクティブを使用する代わりに、コンパイラが生成した &lt;code&gt;.eh_frame&lt;/code&gt; セクションとしてDWARF unwind infoを発行します。</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">結果のオブジェクトファイルに静的にリンクしないように &lt;code&gt;ld(1)&lt;/code&gt; に指示する特別なマーカーを &lt;code&gt;dyld(1)&lt;/code&gt; し、代わりにdyld（1）が実行時にそれをロードできるようにします。これは、Fix-and-Continueデバッグモードと組み合わせて使用​​されます。このモードでは、プログラム自体を再起動する必要なしに、問題のオブジェクトファイルがプログラムの実行中に再コンパイルおよび動的に再ロードされます。現在、Fix-and-Continue機能は、Mac OS X 10.3以降のNeXTランタイムでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">現在の関数が指定されたフレームサイズを超えた場合に警告を発します。これはコンパイル時のチェックなので、プログラムの実行時に実際の問題である必要はありません。スタックオーバーフローを引き起こす可能性が最も高い関数を特定することを目的としています。スタックサイズが制限されている環境（Linuxカーネルなど）で使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">関数が &lt;code&gt;alloca&lt;/code&gt; を呼び出すか、動的サイズの配列を使用する場合は、警告を出します。スタックサイズが限られている場合、これは一般的に悪い考えです。</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">コールグラフ情報を送信します。</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">コンパイル・ソース・ファイルのベース・ネームが構造体が定義されているファイルのベース・ネームと一致した場合にのみ、構造体のようなタイプのデバッグ情報を表示します。</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">構造体がテンプレートであるか、システム・ヘッダで定義されている場合を除き、コンパイル・ソース・ファイルのベース・ネームがそのタイプが定義されているファイルのベース・ネームと一致した場合にのみ、構造体のようなタイプのデバッグ情報を出力するようにしました。</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">すべてのシンボルとタイプのデバッグ情報を送信します。</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">使用しているシンボルのデバッグ情報を出力します。スタブのデバッグフォーマットでは</target>
        </trans-unit>
        <trans-unit id="c7be7022731d1d4e89f739d3f084947002265870" translate="yes" xml:space="preserve">
          <source>Emit diagnostics showing where nodes in the &amp;ldquo;exploded graph&amp;rdquo; are in relation to the program source.</source>
          <target state="translated">「展開されたグラフ」のノードがプログラムソースとの関係でどこにあるかを示す診断を発行します。</target>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">スタックスマッシング攻撃などのバッファオーバーフローをチェックする追加のコードを発行します。これは、脆弱なオブジェクトを持つ関数にガード変数を追加することによって行われます。これには、 &lt;code&gt;alloca&lt;/code&gt; を呼び出す関数、および8バイトより大きいバッファーを持つ関数が含まれます。ガードは、関数に入るときに初期化され、関数が終了するときにチェックされます。ガードチェックが失敗した場合、エラーメッセージが出力され、プログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="0b4704d417754dd3e2fa8536b703ca97736ecd33" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits. Only variables that are actually allocated on the stack are considered, optimized away variables or variables allocated in registers don&amp;rsquo;t count.</source>
          <target state="translated">スタックスマッシング攻撃などのバッファオーバーフローをチェックするために追加のコードを発行します。これは、脆弱なオブジェクトを持つ関数にガード変数を追加することによって行われます。これには、 &lt;code&gt;alloca&lt;/code&gt; を呼び出す関数、および8バイト以上のバッファーを持つ関数が含まれます。ガードは、関数が開始されると初期化され、関数が終了するとチェックされます。ガードチェックが失敗すると、エラーメッセージが出力され、プログラムが終了します。スタックに実際に割り当てられている変数のみが考慮され、最適化された変数またはレジスタに割り当てられている変数はカウントされません。</target>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">IDEでの使用に適した、マシンで解析可能な形式で修正ヒントを出力します。各fix-itについて、関連する診断の後に「fix-it：」という文字列で始まる行が出力されます。例えば：</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">関数のプロローグを、関数の先頭ではなく、関数の必要な部分の前にのみ表示します。このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">ファイルと行だけではなく、DWARFのデバッグ情報に位置情報のカラム情報を出力します。このオプションはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">ホットライン用にパーフのような色で出力します。出力ファイルの先頭に色目盛の凡例を表示します。</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">コンパイルの最後にフロントエンドの処理に関する統計情報を出力します。このオプションは C++フロントエンドでのみサポートされており、情報は一般的に G++開発チームにのみ有用です。</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">変数が参照されていなくても、最適化がオンになっていない場合、 &lt;code&gt;static const&lt;/code&gt; 宣言された変数を出力します。</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">空。空の属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">有効にする</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">ロード/ストアのボンディングを有効にするために、連続したロード命令またはストア命令をペアリングする最適化を有効(無効)にします。このオプションはデフォルトで有効になっていますが、選択したアーキテクチャがボンディングをサポートしていることがわかっている場合にのみ有効になります。</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">o32 ABIでフレームヘッダ最適化を有効(無効)にします。o32 ABI を使用する場合、呼び出された関数は、レジスタ引数を書き出すためにスタック上に 16 バイトを割り当てます。この最適化を有効にすると、フレームヘッダが使用されていないと判断できる場合、フレームヘッダの割り当てが抑制されます。</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">サポートするアーキテクチャーでの &lt;code&gt;synci&lt;/code&gt; 命令の生成を有効（無効）にします。 &lt;code&gt;synci&lt;/code&gt; ときの命令は（有効な場合）が生成され &lt;code&gt;__builtin___clear_cache&lt;/code&gt; がコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA のバージョン 2.07 で追加されたハードウェア・トランザクション・メモリ(HTM)命令への直接アクセスを可能にする組み込み機能の使用を有効(無効)にします。</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">&lt;code&gt;%hi()&lt;/code&gt; および &lt;code&gt;%lo()&lt;/code&gt; アセンブラ再配置演算子の使用を有効（無効）にします。このオプションは、</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">R4650 ISAによって提供される &lt;code&gt;mad&lt;/code&gt; 、 &lt;code&gt;madu&lt;/code&gt; 、 &lt;code&gt;mul&lt;/code&gt; 命令の使用を有効（無効）にします。</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">（無効）の使用を有効に &lt;code&gt;madd&lt;/code&gt; 及び &lt;code&gt;msub&lt;/code&gt; インストラクション整数。デフォルトは</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">浮動小数点積和命令が使用可能な場合に、その使用を有効にします(無効にします)。デフォルトは</target>
        </trans-unit>
        <trans-unit id="b555e3f0b555bfa87127103aa19a5b771c06eb1e" translate="yes" xml:space="preserve">
          <source>Enable 32-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">32 ビット浮動小数点行列乗算命令を有効にします。これにより、SVE 命令も有効になります。Armv8.2-A より前のアーキテクチャでのこのオプションの使用はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">64ビットAIX ABIと呼び出し規約を有効にします。64ビットポインター、64ビット &lt;code&gt;long&lt;/code&gt; 型、およびそれらをサポートするために必要なインフラストラクチャ。指定</target>
        </trans-unit>
        <trans-unit id="7b3c726da78dba7ee2a5726b767895d7cdc32731" translate="yes" xml:space="preserve">
          <source>Enable 64-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">64 ビット浮動小数点行列乗算命令を有効にします。これにより、SVE 命令も有効になります。Armv8.2-A より前のアーキテクチャでのこのオプションの使用はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6ded79f10cf70cf5831bdeffd10c676f4e368113" translate="yes" xml:space="preserve">
          <source>Enable 8-bit Integer Matrix Multiply instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">8 ビット整数行列乗算命令を有効にします。これにより、高度なSIMD命令と浮動小数点命令も有効になります。このオプシ ョ ンは、 デフ ォ ル ト では</target>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">ARCv2コアの &lt;code&gt;div&lt;/code&gt; および &lt;code&gt;rem&lt;/code&gt; 命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">LinuxカーネルでAddressSanitizerを有効にします。詳細については、&lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https：//github.com/google/kasan/wiki&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">高速なメモリエラー検出器である AddressSanitizer を有効にします。メモリアクセス命令は、範囲外バグや使用後フリーバグを検出するようにインスツルメンテーションされています。このオプションを使用すると</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">Advanced SIMD 命令を有効にします。これは浮動小数点命令も有効にします。オプションのすべての可能な値に対して、デフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">C-SKY DSP、Enhanced DSP、またはVector DSP命令をそれぞれ有効にします。これらのオプシ ョ ンはすべて、 デフォルトではoff に設定されています。</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">C-SKYセキュリティ指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">C-SKY信託指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">LRAでCFGに敏感な再マテリアル化を有効にします。LRA は、こぼれたプソイドの値をロードする代わりに、利益がある場合には値の再物質化(再計算)を試みます。</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">CRC 拡張を有効にします。これは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">アセンブリコードでCRIS固有の詳細なデバッグ関連情報を有効にします。このオプションには、「</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Crypto 拡張を有効にします。これにより、Advanced SIMDと浮動小数点命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">FP16拡張を有効にします。また、浮動小数点命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">FP16 fmla 拡張を有効にします。これは、FP16 拡張と浮動小数点命令も有効にします。このオプションは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">IPAパスを有効 &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; はパス名です。同じパスがコンパイラーで複数回静的に呼び出される場合は、パス名に1から始まる連番を付加する必要があります。</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">大規模システム拡張命令を有効にします。のデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">メモリリークディテクタであるLeakSanitizerを有効にします。このオプションは、実行可能ファイルのリンクでのみ重要であり、実行可能ファイルは、 &lt;code&gt;malloc&lt;/code&gt; およびその他のアロケーター関数をオーバーライドするライブラリーに対してリンクされます。詳細については、&lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https：//github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt;をご覧ください。 &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; 環境変数を使用して、ランタイムの動作に影響を与えることができます。このオプションと組み合わせることはできません</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">ローカルレジスタの割り当てを有効にします。これはARCではまだ実験的なものなので、デフォルトではコンパイラは標準的なリロード(すなわち</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">ローカルレジスタの割り当てを有効にします。これはFT32ではまだ実験的なものなので、デフォルトではコンパイラは標準のリロードを使用します。</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">ローカルレジスタの割り当てを有効にします。これは GCC 7 以降の SPARC のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">RTLパスを有効 &lt;var&gt;pass&lt;/var&gt; 。見る</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">ラウンド二重乗算アキュムレート命令を有効にします。これは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="d370af9affe58a56b9b5454d4d92570e141e8b8f" translate="yes" xml:space="preserve">
          <source>Enable SVE2 aes instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 aes 命令を有効にします。これにより、SVE2 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="c3f75e37c4e4e45b9963ff233f2e2820dcfb4fb8" translate="yes" xml:space="preserve">
          <source>Enable SVE2 bitperm instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 ビットパーマ命令を有効にします。これにより、SVE2 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="2bbf22cee4e50726f4cae0a5e266998649407231" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sha3 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 sha3 命令を有効にします。これにより、SVE2 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="2c7cde27311588c6804e4c9ac9068d7a4af84b22" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sm4 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 sm4 命令を有効にします。SVE2 命令も有効にします。</target>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Scalable Vector Extension 命令を有効にします。これにより、Advanced SIMDおよび浮動小数点命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">高速データ競合検出器であるThreadSanitizerを有効にします。メモリアクセス命令は、データレースのバグを検出するために装備されています。詳細については、&lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https：//github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt;を参照してください。 &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; 環境変数を使用して、ランタイムの動作に影響を与えることができます。サポートされているオプションのリストについては、&lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https：//github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt;を参照してください。このオプションと組み合わせることはできません</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">高速な未定義ビヘイビア検出器であるUndefinedBehaviorSanitizerを有効にします。実行時に未定義の動作を検出するために、さまざまな計算がインスツルメンテーションされています。現在のサブオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">すべての見積もり指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">すべての言語固有のダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">関数の呼び出しによって妨害されたレジスタへの値の割り当てを有効にし、そのような呼び出しの周りのレジスタを保存したり復元したりするための余分な命令を出すことで、そのような呼び出しの周りのレジスタを保存したり復元したりします。このような割り当ては、より良いコードになると思われる場合にのみ行われます。</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">別のファイルでパス統計のダンプを有効にして制御します。ファイル名は、 'で終わるサフィックスを追加して生成されます。</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">asan allocas/VLAの保護を有効にします。</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">リンク時のテンプレートの自動インスタンス化を有効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">バレルシフトの指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">bbit peephole2を有効にします。</target>
        </trans-unit>
        <trans-unit id="180b32141a3f8a46f27f030b1d9db7ce44e7c46b" translate="yes" xml:space="preserve">
          <source>Enable brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">脳の半精度浮動小数点命令を有効にします。これにより、Advanced SIMD および浮動小数点命令も有効になります。このオプションは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">グローバルオブジェクトのバッファオーバーフロー検出を有効にします。この種の保護機能は、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">メモリリードのバッファオーバーフロー検出を有効にします。この種の保護は</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">メモリ書き込みのバッファオーバーフロー検出を有効にします。この種の保護機能は</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">スタックオブジェクトのバッファオーバーフロー検出を有効にします。この種の保護は</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">揮発性参照のキャッシュバイパスを有効にします。</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">ARC EM のコード密度命令を有効にします。このオプションはARC HSのデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">制御フロー転送のコード計測を有効にして、制御フロー転送命令(間接関数呼び出し、関数リターン、間接ジャンプなど)のターゲットアドレスが有効であるかどうかをチェックすることで、プログラムのセキュリティを向上させます。これにより、予期しないターゲットへの制御フローの流用を防止します。これは、リターン指向プログラミング(ROP)や同様のコール/ジャンプ指向プログラミング(COP/JOP)のような脅威から保護することを目的としています。</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">コンパクトな &lt;code&gt;casesi&lt;/code&gt; パターンを有効にします。これはのデフォルトです</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">コンストラクタ/デストラクタ機能を有効にします。</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">コプロセッサ命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">カバレッジに基づくファジングコードのインストルメンテーションを有効にします。 &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; の呼び出しをすべての基本ブロックに挿入します。</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">データフローに基づくファジングコードのインスツルメンテーションを有効にします。挿入の呼び出し &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; 、 &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; 、 &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; または &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; オペランド変数または両方と一体と比較するための &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; 、 &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; 、 &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; または &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; 1つのオペランド定数と一体の比較のために、 &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; または &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; floatまたはdoubleの比較とのため &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; switchステートメントの場合。</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">ブレースで囲まれたイニシャライザリストから &lt;code&gt;std::initializer_list&lt;/code&gt; としてテンプレートタイプパラメータの推定を有効にします。</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">内蔵機能の検出を有効にします。この種の保護は、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">Use-after-after-return の検出を有効にします。この種の保護は</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">除算命令とモジュラス命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">ARC HSコアのダブルロード/ストア動作を有効にします。</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">パスに関する様々な統計情報をダンプすることを有効にします (すべてのダンプオプションで有効になるわけではありません)。</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">すべてのOMP(オフロードおよびマルチプロセッシング)最適化からのダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">すべてのインライン最適化からのダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">すべての手順間最適化からのダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">すべてのループ最適化からのダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">すべての最適化からのダンプを有効にします。これは上記の最適化グループのスーパーセットです。</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">すべてのベクトル化最適化からのダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">HSA カーネル内に特別なデバッグストアを生成し、それを libgomp プラグインが読み込んで報告することを有効にします。これらのストアの生成はデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">例外処理を有効にします。例外の伝播に必要な追加のコードを生成します。一部のターゲットでは、これはGCCがすべての関数のフレームアンワインド情報を生成することを意味します。これは、実行に影響を与えませんが、かなりのデータサイズのオーバーヘッドを生成します。このオプションを指定しない場合、GCCは通常、例外処理を必要とするC ++などの言語に対してデフォルトで有効にし、通常は必要としないCなどの言語に対して無効にします。ただし、C ++で記述された例外ハンドラと適切に相互運用する必要があるCコードをコンパイルする場合は、このオプションを有効にする必要がある場合があります。例外処理を使用しない古いC ++プログラムをコンパイルする場合は、このオプションを無効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">浮動小数点命令を有効にします。これは、オプション</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">Objective-C および Objective-C++プログラムでガベージ・コレクション (GC)を有効にします。GNU ランタイムには、特別なコンパイラフラグを必要としない別のガベージコレクション実装があります。</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">ターゲット固有のビルドインによるARC SIMD命令の生成を可能にします。以下の場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="3476de902c479834e38b15661f3b7c3cc2032cce" translate="yes" xml:space="preserve">
          <source>Enable generation of compare and set flag with immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">即時（ &lt;code&gt;l.sf*i&lt;/code&gt; ）命令を使用して、比較および設定フラグの生成を有効にします。デフォルトでは、イミディエートを最初にレジスタに格納するための追加の命令が生成されます。</target>
        </trans-unit>
        <trans-unit id="d50921b35a0d76feb95a28aea9efb5fcae7e1038" translate="yes" xml:space="preserve">
          <source>Enable generation of conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instructions. By default the equivalent will be generated using set and branch.</source>
          <target state="translated">条件付き移動（ &lt;code&gt;l.cmov&lt;/code&gt; ）命令の生成を有効にします。デフォルトでは、同等のものはsetとbranchを使用して生成されます。</target>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">プリプロセッサの出力で、前処理時に現在の作業ディレクトリをコンパイラに知らせるラインマーカーの生成を有効にします。このオプションを有効にすると、プリプロセッサは、最初のラインマーカーの後に、現在の作業ディレクトリと2つのスラッシュが続く2番目のラインマーカーを出力します。GCCは、いくつかのデバッグ情報形式で現在の作業ディレクトリとして出力されるディレクトリとして、前処理された入力に存在する場合、このディレクトリを使用します。デバッグ情報が有効になっている場合、このオプションは暗黙的に有効になりますが、これは否定形式で禁止できます。</target>
        </trans-unit>
        <trans-unit id="588970c3346f8b21ca330055ce039842b7c95dc3" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right (&lt;code&gt;l.ror&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">右回転（ &lt;code&gt;l.ror&lt;/code&gt; ）命令の生成を有効にします。デフォルトでは、</target>
        </trans-unit>
        <trans-unit id="4410c960b2144b2a5392d7e9052119e5a2916ace" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right with immediate (&lt;code&gt;l.rori&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">即時（ &lt;code&gt;l.rori&lt;/code&gt; ）命令で右回転の生成を有効にします。デフォルトでは、</target>
        </trans-unit>
        <trans-unit id="1d2f560a395cf8229af315865d428228064bb2c4" translate="yes" xml:space="preserve">
          <source>Enable generation of shift with immediate (&lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">即時（ &lt;code&gt;l.srai&lt;/code&gt; 、 &lt;code&gt;l.srli&lt;/code&gt; 、 &lt;code&gt;l.slli&lt;/code&gt; ）命令でシフトの生成を有効にします。デフォルトでは、イミディエートを最初にレジスタに格納するための追加の命令が生成されます。</target>
        </trans-unit>
        <trans-unit id="c64d914c46ba456fccc83d7a0d7c17c411a4e40e" translate="yes" xml:space="preserve">
          <source>Enable generation of sign extension (&lt;code&gt;l.ext*&lt;/code&gt;) instructions. By default memory loads are used to perform sign extension.</source>
          <target state="translated">符号拡張（ &lt;code&gt;l.ext*&lt;/code&gt; ）命令の生成を有効にします。デフォルトでは、メモリロードは符号拡張を実行するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">アラインメントされていないロードおよびストア命令の生成を有効にします。</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">グローバル割り込みを有効にします。</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++ではOpenACCディレクティブ &lt;code&gt;#pragma acc&lt;/code&gt; &lt;code&gt;!$acc&lt;/code&gt; 、Fortran では！$ accの処理を有効にします。いつ</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++ではOpenMP指令 &lt;code&gt;#pragma omp&lt;/code&gt; &lt;code&gt;!$omp&lt;/code&gt; 、Fortran では！$ ompの処理を有効にします。いつ</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">C / C ++では &lt;code&gt;#pragma omp&lt;/code&gt; &lt;code&gt;!$omp&lt;/code&gt; 、Fortran では！$ ompを使用してOpenMPのSIMDディレクティブの処理を有効にします。他のOpenMPディレクティブは無視されます。</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">ローカルにバインドすることが知られていない関数への関数呼び出しで、PLT エントリのインライン化を有効にします。これは</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">内部一貫性チェックを有効にします。デフォルトはコンパイラの設定に依存します。</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">割り込みスタック命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">カーネル開発モードを有効にします。のように、カーネル開発モードを有効にします。</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">関数呼び出しの遅延バインドを有効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">リンカ緩和を有効にします。リンカ緩和とは、リンカがさまざまな命令の短いバージョンを見つけることでプログラムのサイズを縮小しようとするプロセスです。既定では無効になっています。</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">より小さいベクトルサイズを使用してループエピローグのベクトル化を有効にします。</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">より詳細なダンプを有効にします(すべてのダンプオプションには対応していません)。また、最適化パスからの情報も含めます。</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">乗算命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">マルチプロセッサ命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">入れ子になった条件付き実行の最適化を有効にします(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と &lt;code&gt;||&lt;/code&gt; の最適化を有効にする 条件付き実行（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">通常、インストゥルメント・アプリケーションのインストゥルメントに使用されるオプションを有効にして、プロファイル・フィードバック・ベースの最適化を使用して、後で再コンパイルする際に役立つプロファイルを作成します。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">PC 関連のリテラル ロードを有効または無効にします。このオプションを使用すると、1 つの命令を使用してリテラルプールにアクセスし、各関数の後にエミッ トされます。これにより、関数の最大サイズは1MBに制限されます。こ れは、 デフ ォル ト では有効です。</target>
        </trans-unit>
        <trans-unit id="37cd8da3fdbfa9f8188d860129119fec2bfd100c" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. These helpers will, at runtime, determine if the LSE instructions from ARMv8.1-A can be used; if not, they will use the load/store-exclusive instructions that are present in the base ARMv8.0 ISA.</source>
          <target state="translated">アトミック演算を実装するための行外ヘルパーの呼び出しを有効または無効にします。これらのヘルパーは、実行時にARMv8.1-AのLSE命令が使用できるかどうかを判断し、使用できない場合は、ベースのARMv8.0 ISAに存在するロード/ストア排他命令を使用します。</target>
        </trans-unit>
        <trans-unit id="1a34d5bdfa8a40aec1348063e5f43f0a38a44e4b" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. This corresponds to the behavior of the command line options</source>
          <target state="translated">アトミック操作を実装するための行外ヘルパーへの呼び出しを有効または無効にします。これはコマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">コンパイラーによる &lt;code&gt;mul&lt;/code&gt; 、 &lt;code&gt;mulx&lt;/code&gt; および &lt;code&gt;div&lt;/code&gt; ファミリーの命令の発行を有効または無効にします。デフォルトでは、 &lt;code&gt;mul&lt;/code&gt; を出力し、 &lt;code&gt;div&lt;/code&gt; および &lt;code&gt;mulx&lt;/code&gt; を出力しません。</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">Nios II R2 BMX(ビット操作)およびCDX(コード密度)命令の生成を有効または無効にします。これらの命令を有効にするには</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">条件付きブランチを通じて投機的な実行を追跡するための追加コードの生成を有効または無効にします。その後、コンパイラは、 &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; の呼び出しを展開するときに追跡状態を使用して、より効率的なコードシーケンスを生成できます。</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">除算近似を有効にするか無効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">逆数平方根近似を有効にするか無効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">平方根近似を有効にするか無効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">ARM Cortex-A53 のエラー番号 835769 の回避策を有効または無効にします。これには、メモリ命令と 64 ビット整数乗算積和命令の間に NOP 命令を挿入することが含まれます。</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">ARM Cortex-A53 のエラー番号 843419 のワークアラウンドを有効または無効にします。このエラトゥームの回避策はリンク時に行われ、これは対応するフラグをリンカに渡すだけです。</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">定数値をロードするための &lt;code&gt;CONST16&lt;/code&gt; 命令の使用を有効または無効にします。 &lt;code&gt;CONST16&lt;/code&gt; の命令は、現在、テンシリカの標準オプションではありません。有効にすると、標準の &lt;code&gt;L32R&lt;/code&gt; 命令の代わりに &lt;code&gt;CONST16&lt;/code&gt; 命令が常に使用されます。使用 &lt;code&gt;CONST16&lt;/code&gt; は、場合にのみ、デフォルトで有効になって &lt;code&gt;L32R&lt;/code&gt; の命令は使用できません。</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">選択したアーキテクチャのデフォルトにかかわらず、分岐可能性の高い命令の使用を有効または無効にします。デフォルトでは、選択したアーキテクチャでサポートされている場合は、Branch Likely 命令が生成される可能性があります。例外は、MIPS32 および MIPS64 アーキテクチャーおよびそれらのアーキテクチャーを実装するプロセッサの場合です。</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">浮動小数点オプションでの融合乗算/加算および乗算/減算命令の使用を有効または無効にします。浮動小数点オプションも有効になっていない場合、これは効果がありません。融合された乗算/加算および乗算/減算命令を無効にすると、コンパイラーは乗算および加算/減算演算に別々の命令を使用するようになります。これは、厳密なIEEE 754準拠の結果が必要な場合に望ましいことがあります。融合乗算加算/減算命令は中間結果を丸めないため、IEEE規格で指定されているよりも&lt;em&gt;多くの&lt;/em&gt;ビット精度で結果が生成されます。融合型乗算/加算/減算命令を無効にすると、プログラム出力がコンパイラーの乗算および加算/減算演算を組み合わせる機能に影響されなくなります。</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">その他の詳細な最適化情報を有効にします(特定のパスでのみ利用可能)。</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">&lt;code&gt;__GIMPLE&lt;/code&gt; でマークされた関数定義の解析を有効にします。これは、GIMPLEパスの単体テストを可能にする実験的な機能です。</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;code&gt;cbranchsi&lt;/code&gt; パターンのリロード前の使用を有効にします。</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">プロファイルフィードバック指示型の最適化、および以下の最適化を有効にします。</target>
        </trans-unit>
        <trans-unit id="dd16226a248d7401935b2178b12d750c5c2d817f" translate="yes" xml:space="preserve">
          <source>Enable reduced code size &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;puts&lt;/code&gt; library functions. The &amp;lsquo;</source>
          <target state="translated">縮小されたコードサイズの &lt;code&gt;printf&lt;/code&gt; を有効にし、ライブラリ関数を &lt;code&gt;puts&lt;/code&gt; ます。'</target>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">レジスタ割り当ての前にレジスタの圧力に敏感な insn スケジューリングを有効にします。これは、レジスタ割り当て前のスケジューリングが有効な場合にのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">サンプリングベースのフィードバック指向の最適化、および以下の最適化を有効にします。</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">ローカル変数のサニタイズを有効にして、使用後のバグを検出します。このオプションは</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">基本的なブロック境界の表示を有効にします(生のダンプでは無効)。</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">ステートメントの行番号の表示を有効にします。</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">見逃した最適化情報の表示を有効にします(特定のパスでのみ利用可能)。</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">最適化情報の表示を有効にします(特定のパスでのみ利用可能)。</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">スカラー進化解析の詳細を表示可能にします。</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">各ステートメントを保持するEH領域番号を表示することを有効にします。</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">各ステートメントのツリーダンプの表示を有効にします。</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">各変数の一意のID（ &lt;code&gt;DECL_UID&lt;/code&gt; ）の表示を有効にします。</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">ステートメントごとに仮想オペランドを表示することを有効にします。</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">サインの拡張指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">選択的スケジューリング中の最内周ループのソフトウェアパイプライン化を有効にします。このオプションは</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">MS-DOS のような非常に短いファイル名しか許可されていないファイルシステムを回避するための特別なコードを有効にします。</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">リンク時に、C++型のマングルされた型名とその統一のストリーミングを有効にします。これにより、LTO オブジェクト ファイルのサイズは大きくなりますが、One Definition Rule 違反についての診断が可能になります。</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">C ++ 2aで採用されている &lt;code&gt;char8_t&lt;/code&gt; のサポートを有効にします。これには、新しい &lt;code&gt;char8_t&lt;/code&gt; 基本タイプの追加、UTF-8文字列および文字リテラルのタイプの変更、ユーザー定義リテラルの新しいシグネチャ、関連する標準ライブラリの更新、新しい &lt;code&gt;__cpp_char8_t&lt;/code&gt; および &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; 機能テストマクロが含まれます。</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; 提供するよりも多くのアラインメントが必要 &lt;code&gt;new&lt;/code&gt; C ++ 17 newのサポートを有効にします。 &lt;code&gt;-faligned-new=32&lt;/code&gt; などの数値引数を使用して、その関数によって提供されるアライメント（バイト単位）の量を指定できますが、 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; デフォルトをオーバーライドする必要があるユーザーはほとんどいません。</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">概念のための C++拡張機能の技術仕様、ISO 19217(2015)のサポートを有効にすると、次のようなコードが可能になります。</target>
        </trans-unit>
        <trans-unit id="14e7ef08a35724e34d06ae98a57c52f37db35541" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ coroutines extension (experimental).</source>
          <target state="translated">C++コアーチン拡張のサポートを有効にします(実験的)。</target>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">C ++で提供されるものと同様に、Objective-Cでの構造化例外処理の構文サポートを有効にします。このオプションは、Objective-Cのキーワードを使用する必要があり &lt;code&gt;@try&lt;/code&gt; 、 &lt;code&gt;@throw&lt;/code&gt; 、 &lt;code&gt;@catch&lt;/code&gt; 、 &lt;code&gt;@finally&lt;/code&gt; と &lt;code&gt;@synchronized&lt;/code&gt; を。このオプションは、GNUランタイムとNeXTランタイムの両方で使用できます（ただし、Mac OS X 10.2以前のNeXTランタイムと組み合わせて使用​​することはできません）。</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a実行およびデータ予測制限命令を有効にします。このオプションはアセンブラレベルで拡張機能を有効にするためだけのもので、コード生成には影響しません。このオプションは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="9fdfa6853fe490f741b25fcc657be1e589731130" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Scalable Vector Extension 2. This also enables SVE instructions.</source>
          <target state="translated">Armv8-a Scalable Vector Extension 2 を有効にします。これにより、SVE 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a Speculation Barrier 命令を有効にします。このオプションはアセンブラレベルで拡張機能を有効にするためだけのもので、コード生成には影響しません。このオプションは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a Speculative Store Bypass Safe 命令を有効にします。このオプションはアセンブラレベルで拡張機能を有効にするためだけのもので、コード生成には影響しません。このオプションは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Armv8-a aes と pmull crypto extension を有効にします。これにより、Advanced SIMD 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Armv8-a sha2 crypto extension を有効にします。これにより、Advanced SIMD 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a メモリタギング拡張機能を有効にします。このオプションはアセンブラレベルで拡張機能を有効にするだけで、コード生成には影響しません。</target>
        </trans-unit>
        <trans-unit id="9079a098e5a352f9d4734819ee7434e8414e46a7" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. Use of this option with architectures prior to Armv8.5-A is not supported.</source>
          <target state="translated">Armv8.5-a Memory Tagging Extensions を有効にします。Armv8.5-A以前のアーキテクチャでのこのオプションの使用はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a乱数命令を有効にします。このオプションはアセンブラレベルで拡張機能を有効にするためだけのもので、コード生成には影響しません。</target>
        </trans-unit>
        <trans-unit id="180be0b78efe4d6cb3cafec86af33875c8613d90" translate="yes" xml:space="preserve">
          <source>Enable the Custom Datapath Extension (CDE) on selected coprocessors according to the numbers given in the options in the range 0 to 7.</source>
          <target state="translated">0 ~ 7 の範囲のオプションで指定された数値に従って、選択したコプロセッサでカスタム データパス拡張(CDE)を有効にします。</target>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">ドット製品拡張機能を有効にします。これにより、Advanced SIMD 命令も有効になります。</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">C++11 のコンストラクタ継承のセマンティクスに対する P0136 の調整を有効にします。これは C++17 の一部ですが、C++11 および C++14 に対する欠陥報告とも考えられています。このフラグは、以下の場合を除き、デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">コア課題150、テンプレート・テンプレート・パラメータおよびデフォルト引数に対するP0522解決を有効にする:これにより、テンプレート・パラメータの数が少ないテンプレート・パラメータの引数として、デフォルト・テンプレート引数を持つテンプレートを使用できるようになります。このフラグは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">RcPc 拡張を有効にします。これはGCCからのコード生成を変更するものではありませんが、アセンブラに渡され、インラインのasm文でRcPc拡張からの命令を使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">統計プロファイリング拡張機能を有効にします。このオプションは、アセンブラレベルで拡張機能を有効にするためだけのもので、コード生成には影響しません。</target>
        </trans-unit>
        <trans-unit id="1fe6b0760edee391f1d108920f04662238f04b99" translate="yes" xml:space="preserve">
          <source>Enable the Transactional Memory Extension.</source>
          <target state="translated">トランザクションメモリ拡張を有効にします。</target>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">スカラー除算の近似を有効にします。</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">スカラー平方根の近似を有効にします。</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">ベクトル化された除算の近似を有効にします。</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">ベクトル化された平方根の近似を有効にします。</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">組み込みのグローバル宣言を有効にする</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">最初にレジスタにロードせずに、コンパイラがシンボル名をロード/ストア命令のアドレスとして直接使用できるようにします。通常、このオプションを使用すると、より大きなプログラムが生成され、オプションを使用しない場合よりも高速に実行されます。ただし、結果はプログラムによって異なるため、永続的に有効にするのではなく、ユーザーオプションとして残します。</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラのクリティカルパスヒューリスティックを有効にします。このヒューリスティックは、クリティカルパス上の命令を優先します。これは、スケジューリングが有効になっているときにデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">デフォルトの命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラの依存数ヒューリスティックを有効にします。このヒューリスティックは、より多くの命令が依存している命令を優先します。これは、スケジューリングが有効になっているときにデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">GR712RCプロセッサのバックツーバックストアのエラッタに対する文書化された回避策を有効にします。</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">UT699E/UT700 プロセッサのバックツーバックストアエラッタの文書化された回避策を有効にします。</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">Atmel AT697F プロセッサの単一のエラー(AT697E プロセッサのエラー #13 に対応)の文書化された回避策を有効にします。</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">UT699プロセッサの浮動小数点のエラッタとデータキャッシュのエラッタを無効にするための文書化された回避策を有効にします。</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">倍精度の逆数近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">倍精度の逆数平方根近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">拡張 &lt;code&gt;lrw&lt;/code&gt; 命令を有効にします。このオプションのデフォルトは、CK801の場合はオン、それ以外の場合はオフです。</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">条件付きの手の生成を有効にします。</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラのグループヒューリスティックを有効にします。このヒューリスティックは、スケジュールグループに属する命令を優先します。スケジューリングが有効な場合、デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">グラファイトの同一性変換を有効にします。SCoPごとに多面体表現を生成してギムプルに変換します。このような場合には</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">islベースのループネストオプティマイザを有効にします。これはPluto最適化アルゴリズムに基づいた汎用ループネストオプティマイザです。データの局所性と並列性に最適化されたループ構造を計算します。このオプションは実験的なものです。</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラの最後の命令ヒューリスティックを有効にします。このヒューリスティックは、最後にスケジューリングされた命令への依存度が低い命令を優先します。これは、スケジューリングが有効になっているときにデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">HP-UX リンカの最適化パスを有効にします。これにより、シンボリック・デバッグが不可能になることに注意してください。また、HP-UX 8 および HP-UX 9 リンカでは、一部のプログラムをリンクすると偽のエラーメッセージが表示されるというバグが発生します。</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラのランクヒューリスティックを有効にします。このヒューリスティックは、サイズや頻度が大きい基本ブロックに属する命令を優先します。これは、スケジューリングが有効になっているときにデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">単精度と倍精度の両方の逆数近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">単精度と倍精度の両方で、逆数平方根近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sha512 と sha3 の暗号化拡張を有効にします。これにより、Advanced SIMD 命令も有効になります。Armv8.2-A より前のアーキテクチャでこのオプションを使用することはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">単精度の逆数近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">単精度の逆数平方根近似命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sm3とsm4の暗号化拡張を有効にします。これにより、Advanced SIMD 命令も有効になります。Armv8.2-A以前のアーキテクチャでのこのオプションの使用はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">スケジューラの投機的命令ヒューリスティックを有効にします。このヒューリスティックは、依存性の弱い投機的な命令を優先します。これは、スケジューリングが有効になっているときにデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA のバージョン 2.07 で追加された暗号命令への直接アクセスを可能にする内蔵機能の使用(無効化)を有効にします。</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">読み取り専用セクションにあることがわかっているデータに対して、FDPIC ABI で &lt;code&gt;GPREL&lt;/code&gt; 再配置の使用を有効にします。デフォルトでは有効になっていますが、</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">最小限のランタイム環境の使用を有効にする-スタティックなイニシャライザやコンストラクタを使用しない。これはメモリ制約のあるデバイス向けです。コンパイラは、リンカとランタイムにどのコード・フラグメントが必要かを伝える特別なシンボルをいくつかのオブジェクトに含みます。</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">GASのみが理解するアセンブラディレクティブの使用を有効にします。</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">SH2Aでのビット操作命令の使用を有効にします。</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">条件付き実行の使用を有効にします(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">条件付きセット命令の使用を有効にします(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">条件付き移動命令の使用を有効にします(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">インデックス付きロードの使用を有効にします。これは、オプティマイザによってはインデックス付きのストアが存在すると仮定してしまうため、問題となることがあります。</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">逓倍積算命令の使用を有効にします。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">o32 ABI で奇数番目の単精度浮動小数点レジスタの使用を有効にします。これは、これらのレジスタをサポートしていることが知られているプロセッサのデフォルトです。o32 FPXX ABI を使用する場合。</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">見当ずれのあるプリ/ポストモディファイの使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">命令 &lt;code&gt;fmovd&lt;/code&gt; の使用を有効にします。小切手</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">ツリーのパスを有効 &lt;var&gt;pass&lt;/var&gt; 。見る</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">ジャンプテーブルを実装するには、 &lt;code&gt;bi&lt;/code&gt; または &lt;code&gt;bih&lt;/code&gt; 命令の使用を有効にします。</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">FT32B プロセッサの拡張命令の使用を有効にします。</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">ユーザー定義の指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">デバッグ・ダンプ・ファイルの詳細なコスト・モデル・ダンプを有効にします。このオプションは、コンパイラのデバッグで使用するために提供されます。</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">Microsoft Windowsネイティブコンパイラと互換性のあるビットフィールドレイアウトを有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">文字列操作のインライン化を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">IEEE 128ビット浮動小数点の &lt;var&gt;__float128&lt;/var&gt; キーワードを有効/無効にし、IEEE 128ビット浮動小数点のソフトウェアエミュレーションまたはハードウェア命令を使用します。</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">RCPSS、RCPPS、RSQRTSS、RSQRTPS命令の生成を、浮動小数点除算を行う代わりに、ニュートンラプソンステップを追加して行うことを有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">IEEE算術に依存する浮動小数点の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">3DNow!命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">387浮動小数点ユニットでの &lt;code&gt;sin&lt;/code&gt; 、 &lt;code&gt;cos&lt;/code&gt; 、および &lt;code&gt;sqrt&lt;/code&gt; 命令の生成を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">ADX 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">AES 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">AVX 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">AVX2 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">AVX512BW 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">AVX512CD 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">AVX512ER 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">AVX512F 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">AVX512PF 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">AVX512VL 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">BMI 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">BMI2 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">文字列が移動する前のCLDの生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">CLDEMOTE 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">CLFLUSHOPT 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">CLWB 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">CLZERO 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">CMPXCHG16B命令の生成を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">CRC32命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">F16C命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">FMA命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">FMA4命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">FSGSBASE命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">FXSR命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">GFNI命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">HLE命令の接頭辞の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">LWP 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">LZCNT命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">MMX命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">MOVBE 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">MOVDIR64B命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">MOVDIRI命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">MWAITX命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">PCLMUL 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">PCONFIG 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">PKU 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">POPCNT 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">PREFETCHW 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">PREFETCHWT1命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">PTWRITE命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">RDPID命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">RDRND 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">RDSEED命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">RTM 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">SAHF 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">SGX 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">SHA 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">SSE命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">SSE2 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">SSE3 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">SSE4 命令(SSE4.1 と SSE4.2 の両方)の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">SSE4A 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">SSSE3 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">TBM 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">VAES 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">WAITPKG命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">WBNOINVD命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">XOP命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">XSAVE命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">XSAVEC 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">XSAVEOPT命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">XSAVES 命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">アドバンスビット命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">強化された3DNow!命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">小さな文字列演算を行うためのインラインコードの生成と、大きな演算のためのライブラリルーチンの呼び出しを有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">sse4.1命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">sse4.2命令の生成を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">CETからのシャドウスタック内蔵機能を有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">&lt;var&gt;__float128&lt;/var&gt; データ型をサポートするISA 3.0ハードウェア命令を使用して有効/無効にします。</target>
        </trans-unit>
        <trans-unit id="41e598e82b094b60e50ff17f84b1a81de5e43516" translate="yes" xml:space="preserve">
          <source>Enabled at level</source>
          <target state="translated">レベルで有効</target>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">レベルで有効</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">以下の方法で有効になります。</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">デフォルトでは</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">デフォルトでは</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">Alpha、AArch64、x86 レベルで有効</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">レベルでx86で有効</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">で有効になります。</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">イネーブル(</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">16 ビッ トまたは32 ビッ ト アラインメントされていないアドレスからの16 ビッ トおよび32 ビッ ト値の読み書きを有効(または無効)にします。デフォルトでは、すべてのARMv6以前、すべてのARMv6-M、ARMv8-Mベースライン アーキテクチャではアンアラインド アクセスは無効になっており、その他のすべてのアーキテクチャでは有効になっています。unaligned アクセスが有効になっていない場合、パックされたデータ構造内のワードは一度に1 バイトずつアクセスされます。</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">IVC2スケジューリングを有効にします。IVC2 は 64 ビット VLIW コプロセッサです。</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">すべての手順間解析ダンプを有効にします。</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">すべてのオプションの命令（平均、乗算、除算、ビット演算、先行ゼロ、絶対差、最小/最大、クリップ、および飽和）を有効にします。</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">最初の反復の値を使用して、アンロールループの後の反復で誘導変数の値を表現できるようにします。これにより、長い依存関係の連鎖を断ち切ることができ、スケジューリングパスの効率を向上させることができます。</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">文字列操作命令 &lt;code&gt;SMOVF&lt;/code&gt; 、 &lt;code&gt;SCMPU&lt;/code&gt; 、 &lt;code&gt;SMOVB&lt;/code&gt; 、 &lt;code&gt;SMOVU&lt;/code&gt; 、 &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; 、および &lt;code&gt;RMPA&lt;/code&gt; 命令の使用を有効または無効にします。これらの命令はデータをプリフェッチする可能性があり、I / Oレジスタにアクセスする場合は安全ではありません。（詳細については、RX62Nグループのユーザーマニュアルのセクション12.2.7を参照してください）。</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; および &lt;code&gt;long long&lt;/code&gt; 型のサポートを有効にして、8バイト境界で整列させます。デフォルトでは、すべてのオブジェクトの配置を最大4バイトに制限します。いつ</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">すべての単精度および倍精度浮動小数点ハードウェア拡張をサポートします。ARC EMでは使用できません。</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">すべての単精度浮動小数点ハードウェア拡張のサポートを有効にします。</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">倍精度浮動小数点と融合乗算のサポートを有効にし、ハードウェア拡張を追加します。このオプションにはオプションが含まれています '</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">倍精度アシスト命令を使用した倍精度浮動小数点ハードウェア拡張のサポートを有効にします。すべての単精度浮動小数点ハードウェア拡張も有効になります。このオプションはARC EMでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">倍精度アシスト命令を使用した倍精度浮動小数点ハードウェア拡張のサポートを有効にします。単精度浮動小数点および融合乗算・加算ハードウェア拡張も有効になります。このオプションはARC EMでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">倍精度アシスト命令を使用した倍精度浮動小数点ハードウェア拡張のサポートを有効にします。単精度浮動小数点拡張も有効になります。このオプションはARC EMでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">倍精度アシスト命令を使用した倍精度浮動小数点ハードウェア拡張のサポートを有効にします。単精度浮動小数点拡張、平方根拡張、除算拡張も有効になります。このオプションはARC EMでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">倍精度浮動小数点ハードウェア拡張のサポートを有効にします。単精度浮動小数点拡張も有効になります。ARC EM では使用できません。</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">倍精度浮動小数点、平方根、除算のハードウェア拡張のサポートを有効にします。このオプションにはオプションが含まれています '</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">単精度浮動小数点および融合乗算のサポートを有効にし、ハードウェア拡張を追加します。</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">単精度浮動小数点ハードウェア拡張のサポートを有効にします。</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">単精度浮動小数点、平方根、除算のハードウェア拡張をサポートします。</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">ARCv2コアの特定の浮動小数点ハードウェア拡張のサポートを有効にします。 &lt;var&gt;fpu&lt;/var&gt; でサポートされる値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI の RH850 バージョンのサポートを有効にします。これがデフォルトです。このバージョンの ABI では、以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI の古い GCC バージョンのサポートを有効にします。このバージョンの ABI では、以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">32ビットコプロセッサの命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">64ビットコプロセッサの命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">2つのレジスタ間の絶対差である &lt;code&gt;abs&lt;/code&gt; 命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">2つのレジスタの平均を計算する &lt;code&gt;ave&lt;/code&gt; 命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">&lt;code&gt;clip&lt;/code&gt; 命令を有効にします。ご了承ください</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; および &lt;code&gt;divu&lt;/code&gt; 命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">&lt;code&gt;leadz&lt;/code&gt; （先行ゼロ）命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; および &lt;code&gt;max&lt;/code&gt; 命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">低オーバーヘッドのループに使用される、 &lt;code&gt;repeat&lt;/code&gt; と &lt;code&gt;erepeat&lt;/code&gt; 指示を有効にします。</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">ビット操作命令を有効にします。ビットテスト（ &lt;code&gt;btstm&lt;/code&gt; ）、セット（ &lt;code&gt;bsetm&lt;/code&gt; ）、クリア（ &lt;code&gt;bclrm&lt;/code&gt; ）、反転（ &lt;code&gt;bnotm&lt;/code&gt; ）、およびテストと設定（ &lt;code&gt;tas&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">コプロセッサ命令を有効にします。デフォルトでは、32 ビットのコプロセッサです。通常、コプロセッサは</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">の暗号化手順を有効にします '</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">位置に依存しないデータの生成を有効にします。この機能を有効にすると、定数データへのアクセスは、レジスタに保持されているベースアドレスからのオフセットを介して行われます。これにより、実行ファイルの再配置を必要とせずに、実行時に定数データの位置を決定することができます。変更可能なデータは、このオプションの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">RTLループオプティマイザのループ不変モーションパスを有効にします。レベル</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">乗算・積算命令を有効にします。</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">飽和命令を有効にします。現在、コンパイラ自体はこれらを生成しませんが、このオプションは、などの他のツールとの互換性のために含まれて &lt;code&gt;as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">リンク時間の最適化中にリンカープラグインの使用を有効にします。このオプションはリンカのプラグインサポートに依存します。</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">e3v5 LOOP 命令の使用を有効にします。この命令の使用は、e3v5 アーキテクチャが選択されている場合、その使用はまだ実験的なものであるため、デフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">スカラー64ビット演算の処理にNeonを使用することを有効にします。コアレジスタからNeonにデータを移動するコストが高いため、デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">プロファイリングと追加のランタイムエラーチェックを有効にします。</target>
        </trans-unit>
        <trans-unit id="e90d4bd4a0cd6ad11d1267ee1ab362b6754a6129" translate="yes" xml:space="preserve">
          <source>Enabling this option effectively enables the following warnings:</source>
          <target state="translated">このオプションを有効にすると、以下の警告が効果的に有効になります。</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">ロック変数のロック省略を終了します。メモリの順序は &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 以上にする必要があります。</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">他のすべての &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 操作と一緒に全体の順序付けを適用します。</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">列挙子属性</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">GCC に影響を与える Env vars。</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">に相当する。</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; と同じです。下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">1990年のISO C規格の誤りは、1994年と1996年に発行された2つの技術コリゲンダで修正されました。GCCは修正されていないバージョンをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">1999年のISO C規格の誤りは、2001年、2004年、2007年に発行された3つの技術コリゲンダで修正された。GCCは修正されていないバージョンをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">プリフェッチが終了する前に実行される命令の平均数を推定します。先にプリフェッチされる距離は、この定数に比例します。この数を増やすと、プリフェッチされるストリームの数が少なくなることもあります (</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">C++17 で採用されているように、メンバ・アクセス、配列の添え字、およびシフト式を左から右の順序で評価し、代入を右から左の順序で評価します。デフォルトでは</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">たとえ</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">コンパイラー側でリカバリー・モードがオンになっている場合でも、ランタイム・ライブラリー側でもリカバリー・モードを有効にする必要があります。そうしないと、失敗は依然として致命的です。ランタイムライブラリのデフォルトは、ThreadSanitizerおよびUndefinedBehaviorSanitizerの &lt;code&gt;halt_on_error=0&lt;/code&gt; ですが、AddressSanitizerのデフォルト値は &lt;code&gt;halt_on_error=1&lt;/code&gt; です。これは、対応する環境変数で &lt;code&gt;halt_on_error&lt;/code&gt; フラグを設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">長さゼロのビットフィールドの後に通常のビットフィールドが続いていなくても、構造体の整列に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">このスイッチが有効になっていても、すべての関数呼び出しが長い呼び出しに変わるわけではありません。ヒューリスティックは、静的関数、 &lt;code&gt;short_call&lt;/code&gt; 属性を持つ関数、 &lt;code&gt;#pragma no_long_calls&lt;/code&gt; ディレクティブのスコープ内にある関数、および定義が現在のコンパイル単位内で既にコンパイルされている関数は、長い呼び出しに変換されないことです。この規則の例外は、弱い関数定義、 &lt;code&gt;long_call&lt;/code&gt; 属性または &lt;code&gt;section&lt;/code&gt; 属性を持つ関数、および &lt;code&gt;#pragma long_calls&lt;/code&gt; ディレクティブのスコープ内にある関数は常に長い呼び出しに変換されることです。</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">を指定しても</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">登録も</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">ループで &lt;code&gt;sum&lt;/code&gt; が累積されても、その合計は使用されないため、累積を削除できます。</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">偶数Dレジスタ</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">偶数のアキュムレータレジスタ。</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">すべてのデータオブジェクトには配置要件があります。構造体、共用体、配列を除くすべてのデータの配置要件は、オブジェクトのサイズまたは現在のパッキングサイズ（ &lt;code&gt;aligned&lt;/code&gt; 属性または &lt;code&gt;pack&lt;/code&gt; プラグマで指定）のいずれか小さい方です。構造体、共用体、配列の場合、整列要件はそのメンバーの最大の整列要件です。すべてのオブジェクトにオフセットが割り当てられるため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">2の正確な力</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">まさにその通り</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">使用例</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">これらの低レベルの組み込み関数の使用例は、次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">未定義の動作を伴うコードの例は &lt;code&gt;a = a++;&lt;/code&gt; 、 &lt;code&gt;a[n] = b[n++]&lt;/code&gt; および &lt;code&gt;a[i++] = i;&lt;/code&gt; 。より複雑ないくつかのケースはこのオプションでは診断されず、時々偽陽性の結果をもたらす可能性がありますが、一般に、プログラムでこの種の問題を検出するのにかなり効果的であることがわかっています。</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">このツールのユースケースの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">例外ハンドラーは、システムがスタックにエラーコードをプッシュするため、割り込みハンドラーとは異なります。例外ハンドラー宣言は、割り込みハンドラーの宣言に似ていますが、必須の関数シグニチャーが異なります。コンパイラーは、 &lt;code&gt;IRET&lt;/code&gt; 命令の前にスタックからエラーコードをポップするように調整します。</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">例外ハンドラは、エラーコードをプッシュする例外にのみ使用してください。間違った種類のハンドラを使うとシステムがクラッシュします。</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">実行およびデータ予測制限命令。</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">展開 &lt;code&gt;adddi3&lt;/code&gt; と &lt;code&gt;subdi3&lt;/code&gt; をへRTL生成時に &lt;code&gt;add.f&lt;/code&gt; 、 &lt;code&gt;adc&lt;/code&gt; など、このオプションが推奨されていません。</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">インラインループに展開します。</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">指定されたサイズのi386 &lt;code&gt;rep&lt;/code&gt; プレフィックスを使用して展開します。</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">インストラクションを短くするか長くするかを決める際に、どのような点を考慮するかを説明してください。</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">明示的なインスタンスは、プログラムの残りの部分でどの他のインスタンスが使用されているかを正確に知る必要がなく、最大または最も頻繁に複製されるインスタンスに使用することができます。明示的なインスタンスをプログラム全体に分散させることができ、インスタンスが使用される翻訳ユニットやテンプレート自体を定義する翻訳ユニットに配置することができます。</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">明示的にインスタンス化されたインラインメソッドは、リンケージが共有ライブラリの境界を越える場合があるため、このオプションの影響を受けません。&lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;テンプレートのインスタンス化を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">式は現在、以下の場合にのみ契約されます。</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">ユニオン型にキャストされる可能性のある式は、その型がユニオンのメンバーの少なくとも1つと一致するものです。したがって、次のようなユニオンと変数が与えられているとします。</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">を拡張する(拡張しない)。</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">現在のABIを特定の拡張子で拡張するか、そのような拡張子を削除します。有効な値は '</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">拡張 &lt;code&gt;asm&lt;/code&gt; ステートメントはC関数内にある必要があるため、ファイルスコープ（「トップレベル」）でインラインアセンブリ言語を記述するには、C関数の外で基本的な &lt;code&gt;asm&lt;/code&gt; を使用する必要があります。この手法を使用して、アセンブラディレクティブを発行したり、ファイルの他の場所で呼び出すことができるアセンブリ言語マクロを定義したり、関数全体をアセンブリ言語で書き込んだりできます。関数以外の基本的な &lt;code&gt;asm&lt;/code&gt; ステートメントでは、修飾子を使用できません。</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">自動ストレージ期間のオブジェクトでは、最大&lt;em&gt;2 ^ {28}&lt;/em&gt;（バイト）までの拡張配置がサポートされています。静的およびスレッドストレージ期間のオブジェクトでサポートされるアライメントは、ABIによって決定されます。</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">拡張レジスタは、モニタ属性を持つ関数の実行前にスタックに保存されません。デフォルトのオプションは</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">拡張レジスタは、モニタ属性を持つ関数の実行前にスタックに格納されます。デフォルトのオプションは</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">関数のプロローグやエピローグの実行に必要な時間など、関数のオーバーヘッドのためにinlinerが計上した余分な時間</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">FMAの指示。</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">FMA4の指示。</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">直接手のための64ビットの倍数を保持するためのFPまたはVSXレジスタまたはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">VSX insnsまたはNO_REGSのための64ビット整数を保持するためのFPまたはVSXレジスタ。</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">直接手を動かすための64ビット整数を保持するためのFPまたはVSXレジスタ、またはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">ISA 2.07 の float ops または NO_REGS を実行するための FP または VSX レジスタ。</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">FP または VSX レジスタの下で float 演算を実行するための</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">FPレジスタ</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">DarwinのFSF GCCは「ファット」オブジェクトファイルを作成しません。GCCがターゲットとして構築した単一のアーキテクチャのオブジェクトファイルを作成します。ダーウィン上のAppleのGCCは、複数の場合に「ファット」ファイルを作成します</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">Fat LTOオブジェクトは、中間言語とオブジェクトコードの両方を含むオブジェクトファイルです。これにより、LTOリンクでも通常のリンクでも使用可能になります。このオプションは</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">フィーチャーモディファイア</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">で使用される機能修飾子</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;branch&lt;/var&gt; 要素のフィールドには、次のセマンティクスがあります。</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 要素のフィールドには、次のセマンティクスがあります。</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 要素のフィールドには、次のセマンティクスがあります。</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">ルート要素のフィールドは以下のセマンティクスを持っています。</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">最後に '</target>
        </trans-unit>
        <trans-unit id="24e09f2eaae1d9afb97c63e8aa6a65a24f91f73b" translate="yes" xml:space="preserve">
          <source>Finally if the parameter is &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; then in addition to creating a symbol version (as if &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; was used) the version will be also used to resolve &lt;var&gt;name2&lt;/var&gt; by the linker.</source>
          <target state="translated">最後に、パラメーターが &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; 場合、シンボルバージョンの作成に加えて（ &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; が使用されたかのように）、バージョンはリンカーによる &lt;var&gt;name2&lt;/var&gt; の解決にも使用されます。</target>
        </trans-unit>
        <trans-unit id="889bce84d14bf80370f700a385229e627febe04d" translate="yes" xml:space="preserve">
          <source>Finally, GCC will examine &amp;lsquo;</source>
          <target state="translated">最後に、GCCは 'を調べます</target>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">最後に、検討してみてください。</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">最後に、 &lt;code&gt;len&lt;/code&gt; 引数と戻り値が &lt;code&gt;unsigned long&lt;/code&gt; 型であると宣言した方法に注意してください。それらは &lt;code&gt;unsigned int&lt;/code&gt; 型であると宣言することもでき、すべてが機能します。</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">最後に、 &lt;code&gt;const char *&lt;/code&gt; と &lt;code&gt;char * const&lt;/code&gt; エンコードする場合は複雑になります。 &lt;code&gt;char *&lt;/code&gt; は &lt;code&gt;^c&lt;/code&gt; ではなく &lt;code&gt;*&lt;/code&gt; としてエンコードされるため、 &lt;code&gt;r&lt;/code&gt; がポインターまたは指示先に適用されるという事実を表現する方法はありません。</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">ピリオドで区切られた3つのコンポーネントで構成される名前のファイルでパスダンプを見つけます。コンパイルするためにGCCが呼び出されたソースファイルの名前、パス番号を示す数値のサフィックス、その後に文字 '</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">命令の長さと配置に関してサイズ最適化を微調整します。 &lt;var&gt;level&lt;/var&gt; の認識される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">最初のSSEレジスタ（ &lt;code&gt;%xmm0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">まず、透過的な共用体型に対応する引数は、共用体の任意の型にすることができます。キャストは必要ありません。また、共用体にポインター型が含まれている場合、対応する引数はnullポインター定数またはvoidポインター式にすることができます。共用体にvoidポインター型が含まれている場合、対応する引数は任意のポインター式にすることができます。共用体メンバー型がポインターである場合、参照される型の &lt;code&gt;const&lt;/code&gt; などの修飾子は、通常のポインター変換と同様に尊重されなければなりません。</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">(従来のプリプロセッサを使用した)前処理が必要なFortranソースコードを修正しました。</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">Fortranのソースコードが前処理されないように修正されました。</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">関数のスタティックフレームのサイズの制限を修正しました:特定の関数でトップになるとスタックチェックが信頼できなくなり、コンパイラから警告が出ます。</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">定点タイプ。</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">固定小数点データ値には、分数部分と任意の積分部分が含まれます。固定小数点データのフォーマットは、ターゲットマシンによって異なります。</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">固定小数点型は、DWARF のデバッグ情報フォーマットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">名前が &lt;var&gt;prefix&lt;/var&gt; で始まる最初のルーチンに、デバッガーのメインルーチンとしてフラグを立てます。</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">柔軟な配列メンバーは、 &lt;code&gt;0&lt;/code&gt; なしで &lt;code&gt;contents[]&lt;/code&gt; として書き込まれます。</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">フレキシブルアレイメンバーの型が不完全であるため、 &lt;code&gt;sizeof&lt;/code&gt; 演算子が適用されない場合があります。長さゼロの配列の元の実装の癖として、 &lt;code&gt;sizeof&lt;/code&gt; はゼロに評価されます。</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">フレキシブル配列メンバーは、空でない &lt;code&gt;struct&lt;/code&gt; 最後のメンバーとしてのみ表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">浮動小数点定数0。</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">1ワードあたり1命令でレジスタにロードできる浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">店頭即決でご法度な浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">68881定数ではない浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">浮動小数点定数ゼロ</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">浮動小数点レジスタ</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">浮動小数点レジスタ(32ビット値を含む</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">浮動小数点レジスタ(64ビット値を含む</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">浮動小数点レジスタ(非推奨</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">浮動小数点レジスタ</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">ダイレクトムーブが可能な場合は浮動小数点レジスタ、またはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWAX命令が有効かNO_REGSであれば浮動小数点レジスタ。</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWZX命令が有効な場合、またはNO_REGSの場合は浮動小数点レジスタ。</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">STFIWX命令が有効かNO_REGSであれば浮動小数点レジスタ。</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">浮動小数点レジスタ、高度なSIMDベクターレジスタまたはSVEベクターレジスタ</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮動小数点レジスタ AC0~AC3。これらは1つの命令でメモリから/メモリにロードすることができます。</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮動小数点レジスタAC4とAC5。これらは1回の命令でメモリから/メモリにロードすることはできません。</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">浮動小数点条件コードレジスタ。</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">浮動小数点定数 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">浮動小数点定数 0.0 または 1.0</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">high/lo_sum命令シーケンスを使用して整数レジスタに移動することができる積分表現を持つ浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">浮動小数点定数で、その積分表現が1つのmov命令で整数レジスタに移動できるもの</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">1回のセッチ命令で積分表現を整数レジスタに移すことができる浮動小数点定数</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">ただし、浮動小数点命令は32ビットの浮動小数点値に対してのみ生成されるため、FPUハードウェアが</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">浮動小数点の最小値と最大値。これらの命令は</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">浮動小数点レジスタ</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">SPARC-V8アーキテクチャでは浮動小数点レジスタ、SPARC-V9アーキテクチャでは下位浮動小数点レジスタ。</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">浮動小数点レジスタ。と同等です</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">浮動小数点レジスタ。Visual 命令セットが利用可能な場合にのみ SPARC-V9 アーキテクチャで有効です。</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">浮動小数点三角関数と指数関数。これらの命令は</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">浮動小数点ゼロ</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">浮動小数点ゼロ。</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">レジスタをメモリにフラッシュするとパフォーマンスに影響があり、時間依存のコードでは問題になる可能性があります。次の例に示すように、GCCにより良い情報を提供してこれを回避できます。少なくとも、エイリアスルールにより、GCC &lt;em&gt;は&lt;/em&gt;フラッシュする必要の&lt;em&gt;ない&lt;/em&gt;メモリを知ること&lt;em&gt;ができ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">スタックフレームが割り当てられたときは常にフレームポインタを作成するという EABI の要件に従います。このオプションはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">以下のために &lt;code&gt;t2&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; オフセット2に配置され、なく、サイズにより1オフセット &lt;code&gt;t2&lt;/code&gt; は 4.ある &lt;code&gt;t3&lt;/code&gt; 、長さゼロのビットフィールドは、位置合わせに影響しない &lt;code&gt;bar&lt;/code&gt; 、または、結果としての大きさを構造。</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">以下のための &lt;var&gt;n&lt;/var&gt; 、ゼロより大きい</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">ARCの場合、 &lt;code&gt;long_call&lt;/code&gt; 属性でマークされた関数は常にレジスター間接ジャンプおよびリンク命令を使用して呼び出されるため、呼び出された関数を32ビットアドレス空間内の任意の場所に配置できます。 &lt;code&gt;medium_call&lt;/code&gt; 属性でマークされた関数は常に、呼び出しサイトからの25ビットのオフセットを持つ無条件分岐リンク命令で呼び出されるのに十分近くなります。 &lt;code&gt;short_call&lt;/code&gt; 属性でマークされた関数は常に、呼び出しサイトから21ビットのオフセットを持つ条件付き分岐リンク命令で呼び出されるのに十分近くなります。</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">CおよびC ++のソースファイルとインクルードファイルの場合、対応するAda仕様を生成します。この機能の詳細なドキュメントを提供するGNATユーザーガイドの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;CおよびC ++ヘッダーのAdaバインディングの生成を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">Cの場合のみ、式のタイプが &lt;code&gt;void&lt;/code&gt; でない限り、戻り値のタイプがvoidである関数に式を含む &lt;code&gt;return&lt;/code&gt; ステートメントについて警告し &lt;code&gt;void&lt;/code&gt; 。GNUの拡張機能として、後者のケースは警告なしに受け入れられます。</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">C++では、宣言の中に不要な括弧がある場合があることを警告しています。</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">自明ではないコンストラクタやデストラクタを持つ C++型の場合、この型の変数が参照されていない場合、コンパイラは本当に未使用であるかどうかを判断することができません。この型属性は、基本型の変数と同様に、この型の変数が使用されていないように見える場合には、コンパイラに警告するように通知します。</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">C ++の場合、ユーザー定義の変換で混乱するオーバーロード解決についても警告します。型変換演算子を決して使用しない変換： &lt;code&gt;void&lt;/code&gt; への変換、同じ型、基本クラス、またはそれらへの参照。符号付き整数と符号なし整数間の変換に関する警告は、C ++ではデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">C++11 以降の標準では、標準で要求されているように、狭窄変換はデフォルトで診断されます。定数からのナローイング変換はエラーを生成し,定数以外からのナローイング変換は警告を生成する.</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">C言語の場合、オーバーロードされた関数はマクロで実装されているため、以下のようには動作しません。</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">Microsoft Windowsターゲットの場合、関数で &lt;code&gt;dllimport&lt;/code&gt; 属性を使用する必要はありませんが、DLL内のサンクを排除することにより、パフォーマンスが少し向上します。インポートされた変数での &lt;code&gt;dllimport&lt;/code&gt; 属性の使用は、</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">Microsoft Windowsターゲットの場合、DLLのエクスポートテーブルにシンボルを含めるための代替方法があります。</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">Objective-C方言の場合、 &lt;code&gt;NSString&lt;/code&gt; （または &lt;code&gt;__NSString__&lt;/code&gt; ）は同じコンテキストで認識されます。これらのフォーマット属性を含む宣言は正しい構文で解析されますが、このようなフォーマット文字列のチェック結果はまだ定義されておらず、このバージョンのコンパイラでは実行されません。</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">Objective-C方言の場合、 &lt;code&gt;format-arg&lt;/code&gt; 属性は、上記の &lt;code&gt;format&lt;/code&gt; 属性との互換性のために &lt;code&gt;NSString&lt;/code&gt; リファレンスを参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">PMF定数（つまり、「</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">SysV / x86-64の場合、 &lt;code&gt;long double&lt;/code&gt; メンバーを持つ共用体は、psABIで指定されているとおりにメモリに渡されます。例えば：</target>
        </trans-unit>
        <trans-unit id="1f5fce8a743c71e90680bcbdd5fc42205fc0e24c" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. Prior to GCC 4.4, this was not the case. For example:</source>
          <target state="translated">SysV / x86-64の場合、 &lt;code&gt;long double&lt;/code&gt; メンバーを持つ共用体は、psABIで指定されているようにメモリに渡されます。GCC 4.4より前は、これは当てはまりませんでした。例えば：</target>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">ブランチの場合、少なくとも1回実行された場合は、ブランチが実行された回数をブランチが実行された回数で割ったパーセンテージが出力されます。そうでない場合は、「実行されなかった」というメッセージが出力されます。</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">通話の場合、少なくとも1回は実行された場合、通話が戻った回数を通話が実行された回数で割った割合が出力されます。これは通常100％になりますが、 &lt;code&gt;exit&lt;/code&gt; または &lt;code&gt;longjmp&lt;/code&gt; を呼び出す関数の場合は少なくなる可能性があるため、呼び出されるたびに戻るとは限りません。</target>
        </trans-unit>
        <trans-unit id="0b932ff19c99d589baf49f81de1fc444d2d6fe68" translate="yes" xml:space="preserve">
          <source>For a full description of what the helpers do, the arguments they take, and the returned value, see the</source>
          <target state="translated">ヘルパーが何をするのか、引数を取るのか、返される値は</target>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">すべての組み込みコマンドについては、 &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; 、ヘッダファイル</target>
        </trans-unit>
        <trans-unit id="faea18cdbc9f914fc830faf9ab42ccd57286882b" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">最後のものを除くこれらすべてについて、条件が満たされない場合、コンパイラはプリコンパイル済みヘッダーを自動的に無視します。あなたが仕事をせず、プリコンパイル済みヘッダーが無視されることはありませんオプションの組み合わせを見つけた場合は、参照して、バグレポートを提出ご検討ください&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;バグを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">最後のものを除くこれらすべてについて、条件が満たされない場合、コンパイラーはプリコンパイル済みヘッダーを自動的に無視します。あなたが仕事をせず、プリコンパイル済みヘッダーが無視されることはありませんオプションの組み合わせを見つけた場合は、参照して、バグレポートを提出ご検討ください&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;バグを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">自動(つまりローカル)変数の場合、関数エントリから初期化された変数を使用するまでのパスが存在するが、変数が初期化されていない他のパスが存在する場合、初期化されていないパスが実行時に実行されていないことを証明できないと、コンパイラは警告を発します。</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; に一致する宣言されたシンボルの場合、これはそのシンボルに対して3つのことを実行します。つまり、指定されたアドレス（数値）にシンボルを強制的に配置し、シンボルを揮発性にし、シンボルのスコープを静的に変更します。このプラグマは他のコンパイラとの互換性のために存在しますが、一般的な &lt;code&gt;1234H&lt;/code&gt; 数値構文はサポートされていません（代わりに &lt;code&gt;0x1234&lt;/code&gt; を使用してください）。例：</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">与えられた入力ファイルに対して、ファイル名の接尾辞はどのようなコンパイルを行うかを決定します。</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; によって暗黙的にポップされる入力レジスターの場合、ポップを補償するためにスタックを調整する方法を知る必要があります。ポップされていない入力が暗黙的にポップされたレジスターよりもreg-stackの最上部に近い場合、スタックがどのように見えるかを知ることはできません。スタックの残りの部分がどのように「スライド」するかは明確ではありません。</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">空でないアセンブラー文字列を使用した基本的な &lt;code&gt;asm&lt;/code&gt; の場合、GCCはアセンブラーブロックが汎用レジスターを変更しないと想定しますが、グローバルにアクセス可能な変数の読み取りまたは書き込みは可能です。</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">Microsoft Windowsコンパイラとの互換性のために、GCCは '</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">Microsoft Windowsコンパイラとの互換性のため、GCCは一連の &lt;code&gt;#pragma&lt;/code&gt; ディレクティブをサポートしており、構造体（幅がゼロのビットフィールド以外）、ユニオン、および後で定義されるクラスのメンバーの最大配置を変更します。以下の &lt;var&gt;n&lt;/var&gt; 値は常に2のべき乗である必要があり、新しいアライメントをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">SVR4との互換性のために、GCCはシンボルが弱いことを宣言し、弱いエイリアスを定義するための一連の &lt;code&gt;#pragma&lt;/code&gt; ディレクティブをサポートしています。</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">ネストされた宣言子に属性を実装していないコンパイラ・バージョン用に書かれた既存のコードとの互換性のために、属性を配置する際に多少の甘さが許されています。型にのみ適用される属性が宣言に適用された場合、その宣言の型に適用されたものとして扱われます。また、宣言された識別子の直前に属性を配置するコードとの互換性のため、関数の戻り値の型に適用される属性は関数の型に適用され、配列の要素の型に適用される属性は配列の型に適用されるものとして扱われます。関数型にのみ適用される属性がポインタ先関数型に適用された場合は、ポインタ先関数型に適用されたものとして扱われ、ポインタ先関数型ではない関数戻り型に適用された場合は、関数型に適用されたものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">互換性のために、現在は常にelfのnewlibです。</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">便宜上、1つのオペランドがスカラであるバイナリ・ベクトル演算を使用することができます。その場合、コンパイラはスカラのオペランドを、各要素が演算のスカラであるベクトルに変換します。変換は、スカラが安全にベクトル-要素型に変換できる場合にのみ行われます。次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">幅&lt;em&gt;Nの&lt;/em&gt;型に変換する場合、値は&lt;em&gt;2 ^ N&lt;/em&gt;を法として縮小され、型の範囲内になります。シグナルは発生しません。</target>
        </trans-unit>
        <trans-unit id="c0bc316f0ef750b2316cb1b5e8278752dde4a8ca" translate="yes" xml:space="preserve">
          <source>For deciding the optimization level of body.</source>
          <target state="translated">体の最適化レベルを決めるために</target>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">&lt;code&gt;avrtiny&lt;/code&gt; または &lt;code&gt;avrxmega3&lt;/code&gt; に含まれないデバイスの場合、フラッシュメモリはRAMアドレス空間に表示されないため、読み取り専用データを含むすべてのデータはRAM（汎用アドレス空間）に配置されます。フラッシュメモリに読み取り専用のデータを見つけるために&lt;em&gt;と&lt;/em&gt;（インライン）アセンブラコードを使用せずに、このデータにアクセスするには、右命令を生成するために、特別なアドレス空間が必要とされています。</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">ドキュメントについて &lt;code&gt;altivec&lt;/code&gt; 属性のドキュメントを参照してください&lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPCのタイプの属性を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">Objective-Cクラスごとに、そのインスタンス変数のいずれかが重要なデフォルトコンストラクターを持つC ++オブジェクトであるかどうかを確認します。その場合、特別な &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; インスタンスメソッドを合成します。このメソッドは、このようなインスタンス変数に対して重要なデフォルトコンストラクターを順番に実行し、次に &lt;code&gt;self&lt;/code&gt; を返します。同様に、インスタンス変数が重要なデストラクタを持つC ++オブジェクトであるかどうかを確認し、そうでない場合は、そのようなすべてのデフォルトのデストラクタを逆の順序で実行する特別な &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; メソッドを合成します。</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">各基本ブロックについて、基本ブロックの最後の行の後に、その基本ブロックを終了する分岐または呼び出しを記述した行が表示されます。その行で終了する基本ブロックが複数ある場合、1つのソース行に対して複数の分岐や呼び出しがリストされることがあります。この場合、ブランチとコールにはそれぞれ番号が与えられます。これらの分岐と呼び出しをソース構成要素にマッピングする簡単な方法はありません。しかし、一般的には、最も番号の低い分岐や呼び出しは、ソース行の左端の構造体に対応します。</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">AVRの各組み込み関数には、同じ名前の大文字の組み込みマクロが定義されています。これにより、特定の組み込みが実装されているかどうかにかかわらず、ユーザーは簡単にクエリを実行できます。たとえば、 &lt;code&gt;__builtin_avr_nop&lt;/code&gt; が利用可能であるマクロ &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; はに定義されている &lt;code&gt;1&lt;/code&gt; 、そうでなければ不定。</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">関数ごとに、関数が呼び出された回数、関数が返された回数、関数のブロックの何パーセントが実行されたかを示す線が出力されます。</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">GCCによってコンパイルされた標準がある各言語について、GCCはその標準の1つ以上のバージョンに従おうとします。</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">avr-gcc でサポートされている名前付きのアドレス空間には、同じように名前が付いていますが大文字の組み込みマクロが定義されています。これは、それぞれのアドレス空間がサポートされているかどうかのテストを容易にするためです。</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">他の指定されたダンプファイル(</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">実行される各サブプログラムに対して、コンパイラドライバは最初に</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">さらにAVR固有の組み込みマクロについては、&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR名前付きアドレススペース&lt;/a&gt;と&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR組み込み関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">たとえば、以下の構造では、メンバー配列 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; パディングなしでaの直後に来るようにパックされています。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">例えば、 '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">たとえば、 &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">たとえば、GCC は次のスニペットで &lt;code&gt;i&lt;/code&gt; が初期化されていないことを警告するのは、</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">たとえば、 &lt;code&gt;alloca&lt;/code&gt; の有界ケースは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">たとえば、引数がなく、 &lt;code&gt;int&lt;/code&gt; を返すメソッドは、ポインタのサイズが &lt;code&gt;i8@0:4&lt;/code&gt; 場合、署名はi8 @ 0：4になります。署名は次のように解釈されます &lt;code&gt;i&lt;/code&gt; は戻り値の型（ &lt;code&gt;int&lt;/code&gt; ）で、 &lt;code&gt;8&lt;/code&gt; はバイト単位のパラメーターの合計サイズ（各サイズ4の2つのポインター）、 &lt;code&gt;@0&lt;/code&gt; は最初のパラメーター（バイトオフセット &lt;code&gt;0&lt;/code&gt; のオブジェクト） &lt;code&gt;SEL&lt;/code&gt; &lt;code&gt;:4&lt;/code&gt; は2番目のパラメーター（バイトオフセット &lt;code&gt;4&lt;/code&gt; のSEL）</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">例えば、プログラムが関数を使用することができる &lt;code&gt;strfunc&lt;/code&gt; 返すこと &lt;code&gt;string&lt;/code&gt; オブジェクト、および他の機能 &lt;code&gt;charfunc&lt;/code&gt; へのポインタで動作 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">例えば、以下のような仕様文字列。</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">例えば、定数であるアドレスはオフセット可能ですが、レジスタと定数の和であるアドレスはオフセット可能です(少し大きめの定数もマシンがサポートするアドレスオフセットの範囲内にある限り)。より複雑な間接/インデックス付きアドレスは、マシンがサポートしている他のアドレッシングモードによっては、オフセット可能な場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">たとえば、デフォルトでは、長さが1の8つの &lt;code&gt;unsigned&lt;/code&gt; ビットフィールドのみを含む構造体は、4バイトの境界に揃えられ、サイズは4バイトです。を使用して</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">たとえば、標準の ISA エンコーディングを使用するコードは、MIPS16 または microMIPS コードに直接ジャンプできません。</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">例えば、このC言語のソースファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">たとえば、x86コンパイラが2つの方言（ '</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">例えば、オブジェクトファイル</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">たとえば、ターゲットマシンで8バイト境界に配置するために &lt;code&gt;double&lt;/code&gt; 値が必要な場合、 &lt;code&gt;__alignof__ (double)&lt;/code&gt; は8です。これは、多くのRISCマシンで当てはまります。従来のマシン設計では、 &lt;code&gt;__alignof__ (double)&lt;/code&gt; は4または2です。</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">たとえば、次の関数での呼び出し &lt;code&gt;g&lt;/code&gt; ときので安全ではない &lt;code&gt;overalign&lt;/code&gt; はゼロで、によって割り当てられたスペース &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; はの終了時に解放された可能性が &lt;code&gt;if&lt;/code&gt; 、それが呼び出された声明。</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">たとえば、次の例では、関数 &lt;code&gt;foo&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; のような行がファイル名と &lt;code&gt;printf&lt;/code&gt; 呼び出しの行番号、関数 &lt;code&gt;foo&lt;/code&gt; の名前とともに出力されます。、その後に &lt;code&gt;message&lt;/code&gt; という単語が続きます。</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">たとえば、フルワード命令の68000では、即値オペランドを使用できます。しかし、即値が-128から127の間の場合、値をレジスターにロードしてレジスターを使用すると、より良いコードが得られます。これは、レジスタへのロードが '</target>
        </trans-unit>
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">たとえば、以下のプライマリ関数テンプレートの宣言は属性 &lt;code&gt;malloc&lt;/code&gt; と &lt;code&gt;alloc_size&lt;/code&gt; の両方を使用するため、テンプレートの明示的な特殊化の宣言は、属性の1つが欠落しているために診断されます。</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">たとえば、以下の &lt;code&gt;struct A&lt;/code&gt; が、サードパーティのライブラリヘッダーで整列要件 &lt;code&gt;N&lt;/code&gt; を持ち、タイプの変数が属性が &lt;code&gt;packed&lt;/code&gt; いるために整列されない場合は常に警告を出すように定義されているとします。無関係な &lt;code&gt;struct B&lt;/code&gt; 定義に &lt;code&gt;copy&lt;/code&gt; 属性を指定すると、ポインター式によって参照される型から &lt;code&gt;struct B&lt;/code&gt; すべての関連属性がコピーされます。</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">たとえば、SunOS 4.1.3の &lt;code&gt;sprintf&lt;/code&gt; 関数は &lt;code&gt;char *&lt;/code&gt; を返しますが、C標準では &lt;code&gt;sprintf&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; を返すとしています。 &lt;code&gt;fixincludes&lt;/code&gt; のプログラムでは、この関数のプロトタイプは、標準に一致させることができますが、機能はまだ返されますので、それは、間違っているだろう &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">例えば、 &lt;var&gt;StrongAlias&lt;/var&gt; なります以下のマクロは、の使用 &lt;code&gt;alias&lt;/code&gt; と &lt;code&gt;copy&lt;/code&gt; という別名を定義する属性を &lt;var&gt;alloc&lt;/var&gt; 機能については、 &lt;var&gt;allocate&lt;/var&gt; 属性で宣言を &lt;var&gt;alloc_size&lt;/var&gt; 、 &lt;var&gt;malloc&lt;/var&gt; 関数、および &lt;var&gt;nothrow&lt;/var&gt; 。 &lt;code&gt;__typeof__&lt;/code&gt; 演算子のおかげで、エイリアスはターゲット関数と同じ型になります。 &lt;code&gt;copy&lt;/code&gt; 属性の結果として、エイリアスはターゲットと同じ属性も共有します。</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">たとえば、以下の &lt;code&gt;memset&lt;/code&gt; への呼び出しは、関数が &lt;code&gt;size_t&lt;/code&gt; 型の値を引数として想定しているが、 &lt;code&gt;32&lt;/code&gt; 型は &lt;code&gt;int&lt;/code&gt; であるため、警告によって診断されます。と</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">例えば、コンパイラは次のループを無条件にベクトル化することができるのは、プラグマを使用した場合のみです。</target>
        </trans-unit>
        <trans-unit id="46fb01ed368f209c80511e7fc1fb91adc3f606e1" translate="yes" xml:space="preserve">
          <source>For example, the declaration of &lt;code&gt;struct Object&lt;/code&gt; in the argument list of &lt;code&gt;draw&lt;/code&gt; triggers the warning. To avoid it, either remove the redundant class-key &lt;code&gt;struct&lt;/code&gt; or replace it with &lt;code&gt;class&lt;/code&gt; to match its definition.</source>
          <target state="translated">たとえば、 &lt;code&gt;draw&lt;/code&gt; の引数リストで &lt;code&gt;struct Object&lt;/code&gt; を宣言すると、警告がトリガーされます。これを回避するには、冗長なクラスキー &lt;code&gt;struct&lt;/code&gt; 削除するか、定義に一致するように &lt;code&gt;class&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">例えば、宣言。</target>
        </trans-unit>
        <trans-unit id="40a677ec7a2740cf56a10d8e5968835578281034" translate="yes" xml:space="preserve">
          <source>For example, the first two stores in function &lt;code&gt;bad&lt;/code&gt; are diagnosed because the array elements overlap the subsequent members &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. The third store is diagnosed by</source>
          <target state="translated">たとえば、配列要素が後続のメンバー &lt;code&gt;b&lt;/code&gt; および &lt;code&gt;c&lt;/code&gt; とオーバーラップしているため、関数 &lt;code&gt;bad&lt;/code&gt; の最初の2つのストアが診断されます。3番目の店舗はによって診断されます</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">たとえば、次の関数は、それぞれ &lt;code&gt;n&lt;/code&gt; バイトの8つのオブジェクトをスタックに割り当て、それぞれへのポインターを配列 &lt;code&gt;a&lt;/code&gt; の連続する要素に格納します。次に、配列を関数 &lt;code&gt;g&lt;/code&gt; に渡します。関数gは、各配列要素が指すストレージを安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">例えば、以下のマクロを使用すると、コンパイル時に 2 つの定数整数の加算がオーバーフローするかどうかを可搬的にチェックし、安全であり</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">例えば、以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">たとえば、次の関数 &lt;code&gt;foo&lt;/code&gt; の実装です。</target>
        </trans-unit>
        <trans-unit id="0e188aff9d720764d35dd90d13b53f0b69cd5a6e" translate="yes" xml:space="preserve">
          <source>For example, the intraprocedural example shown for</source>
          <target state="translated">のために示された術中の例としては、例えば</target>
        </trans-unit>
        <trans-unit id="da4fa7f73b59dbaab5c10c7cbf8d1067ea1077b7" translate="yes" xml:space="preserve">
          <source>For example, the same events as above might be printed as:</source>
          <target state="translated">例えば、上記と同じイベントが印刷されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">たとえば、この関数は、組み込み関数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; および &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; を使用してCPUタイプをチェックする &lt;code&gt;ifunc&lt;/code&gt; リゾルバー、またはコンストラクターの優先度をサポートしないターゲットのコンストラクターで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">たとえば、コンパイラは &lt;code&gt;[object init]&lt;/code&gt; などのメソッド呼び出しを &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; すると、それをobjc_msg_lookup（object、@selector（init））への呼び出しにコンパイルし、その後に戻り値を適切な関数ポインタ型にキャストします。次にそれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">struct属性の完全なドキュメントについては、&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86変数属性の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">関数と計算されたgotoへの間接呼び出しの場合、リンカは&lt;em&gt;スタブを&lt;/em&gt;生成します。スタブは、&lt;em&gt;トランポリン&lt;/em&gt;とも呼ばれるジャンプパッドです。したがって、間接呼び出し/ジャンプはそのようなスタブにジャンプします。スタブには、目的のアドレスへの直接ジャンプが含まれています。</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">O64 ABIについては、http://gcc.gnu.org/projects/mipso64-abi.htmlを参照して&lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">任意の言語の入力ファイルの場合、対応するGo宣言を &lt;var&gt;file&lt;/var&gt; に生成します。これにより、Go &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;var&lt;/code&gt; 、および &lt;code&gt;func&lt;/code&gt; 宣言が生成されます。これらの宣言は、他の言語で記述されたコードへのGoインターフェースの記述を開始するのに役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">たとえば、スタックが絶対アドレスで始まる場合 '</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">たとえば、 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; があり、</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">たとえば、x86では、 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; を使用して関数をコンパイルできます。GCCは2つの関数クローンを作成し、1つは</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">例えば、x86の上で、あなたが一つの関数を宣言することができ &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 属性として、別の &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 。これは、最初の関数を</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">例えば、SB-1でFP例外が無効になっていて、64ビットのコードを出力している場合、両方のFPパイプを使うことができます。そうでない場合は、1本のFPパイプしか使えません。</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">例えば、次のような宣言があります。</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">内部名の場合は、すべての文字が有効です。外部の名前の場合、有効な文字の数はリンカによって定義されます。</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">ライブラリコードの場合、ライブラリに必要なテンプレートのインスタンスをすべて提供したい場合は、そのライブラリのすべてのオブジェクトファイルをリンクしてみてください。リンクは失敗しますが、副作用としてインスタンションが生成されます。しかし、複数のライブラリが同じインスタンションを提供しようとした場合、これは競合を引き起こす可能性があることに注意してください。より大きな制御のためには、次のオプションで説明するように明示的なインスタンス化を使用してください。</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">関数呼び出し後に引数をポップする必要があるマシンでは、各関数が戻ってきたらすぐに引数をポップするようにします。レベル</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">オンラインで入手可能なObjective-Cの履歴に関する詳細については、&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http：//gcc.gnu.org/readings.htmlを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="af9da95259f3bd0345f2ca30bdb8d3f07bd5caf4" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">トランザクションメモリに対するGCCのサポートの詳細については&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;、GNUトランザクションメモリライブラリのGNUトランザクションメモリライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">トランザクションメモリに対するGCCのサポートの詳細については&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;、GNUトランザクションメモリライブラリのGNUトランザクションメモリライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">プロファイル指定の最適化については、同じ最適化とコード生成オプションに加えて、ソースファイルを再度コンパイルします。</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Technical Corrigenda、Rationaleドキュメント、およびオンラインで入手可能なCの歴史に関する情報については、http：//gcc.gnu.org/readings.htmlを参照して&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">実行時の識別のために、それぞれの関数エントリから &lt;var&gt;M&lt;/var&gt; を引いたものに対応するこれらの領域の開始アドレスが、結果のバイナリの &lt;code&gt;__patchable_function_entries&lt;/code&gt; セクションに追加で収集されます。</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">単精度浮動小数点比較の場合、 &lt;code&gt;fsub&lt;/code&gt; 命令を発行してフラグをテストします。これはソフトウェアの比較より高速ですが、NaNが存在する場合、または2つの異なる小さな数値が比較され、それらの差がゼロとして計算される場合に、誤った結果が得られる可能性があります。デフォルトは</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">一部のターゲットマシンでは、GCCがformat属性の追加オプションをサポートしています（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性の宣言を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">ターゲットによっては、サフィックスが</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">サイズが不明な文字列操作に対しては、小さなブロックに対してはインラインコードによるランタイムチェックを使用し、大きなブロックに対してはライブラリコールを使用します。</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">GNU C ライブラリを使用するシステムでは、デフォルトはオンになっています。</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">COMDATや弱いシンボルをサポートしていないターゲットの場合、リンカからの重複定義エラーを避けるために、曖昧なリンケージを持つほとんどのエンティティはローカルシンボルとして出力されます。しかし、複数のコピーを持つことはほとんど確実に物事を壊すので、これはインラインのローカル・スタティックには起こりません。</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">通常、入れ子になった関数にトランポリンを必要とするターゲットに対しては、記述子を使用する代わりに常に生成してください。そうでなければ、HP-PAやIA-64のようにトランポリンを必要としないターゲットに対しては、何もしません。</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">GNU/Linuxのように、ユーザモードのXtensaコードがすべて位置に依存しないコード(PIC)でなければならないターゲットの場合、このオプションはカーネルコードをコンパイルするためのPICを無効にします。</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">テストカバレッジ分析では、 &lt;code&gt;gcov&lt;/code&gt; を使用して、人間が読める情報を</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">ABI のバージョン 2 を持つ NeXT ランタイムでは、実際のメソッド呼び出しを実行する前に、メソッド呼び出しで nil レシーバをチェックします。これは既定であり、以下を使用して無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">指定された関数に対して、コンパイラはそれらの関数の間、割り込みを無効にするコードを追加します。名前が付けられた関数がソース内で見つからない場合は、プラグマが使用されていないことを示す警告が表示されます。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">名前付き関数の場合、コンパイラは名前付き関数を呼び出すときには常にレジスタ・ダイレクト・コール・モデルを使用します。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b9c34f2bc66483d538061a0df9fde1756b31b97d" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%.</source>
          <target state="translated">分岐予測の最適化の目的で、 &lt;code&gt;__builtin_expect&lt;/code&gt; 式が &lt;code&gt;true&lt;/code&gt; である確率は、GCCの &lt;code&gt;builtin-expect-probability&lt;/code&gt; パラメーター（デフォルトは90％）によって制御されます。</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">分岐予測の最適化のために、 &lt;code&gt;__builtin_expect&lt;/code&gt; 式が &lt;code&gt;true&lt;/code&gt; である確率は、GCCの &lt;code&gt;builtin-expect-probability&lt;/code&gt; パラメーター（デフォルトは90％）によって制御されます。 &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; を使用して、確率値を個々の式に明示的に割り当てることもできます。</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">include ディレクティブの引用形では</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">include ディレクティブの引用形では、カレントファイルのディレクトリが最初に検索されます。</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">x86-32 コンパイラの場合は</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">既存のコードに可視性のサポートを追加する場合は、 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; を使用できます。これは、（たとえば） &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; および &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; を使用して、可視性を設定する宣言を囲むことで機能します。シンボルの可視性は&lt;strong&gt;APIインターフェースコントラクトの一部として&lt;/strong&gt;表示する必要があるため、デフォルトではない場合、すべての新しいコードは常に可視性を指定する必要があります。つまり、ローカルDSO内でのみ使用する宣言は、PLT間接オーバーヘッドを回避するために&lt;strong&gt;常に&lt;/strong&gt;明示的に非表示としてマークする必要&lt;strong&gt;があり&lt;/strong&gt;ます。これを十分に明確にすると、コードの可読性と自己文書化にも役立ちます。 ISO C ++仕様の要件により、 &lt;code&gt;operator new&lt;/code&gt; および &lt;code&gt;operator delete&lt;/code&gt; は常にデフォルトの可視性である必要があります。</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">生成されたコードが各関数で単一の終了点を持つように強制する(強制しない)。</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">重要でないブロック移動に &lt;code&gt;memcpy&lt;/code&gt; の使用を強制します（強制しません）。デフォルトは</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">フォース &lt;code&gt;long&lt;/code&gt; タイプは、64ビット幅であることを。見る</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、およびポインタ型を32ビット幅に強制します。</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">の場合、GCC がビュー番号を内部的に割り当てるように強制します。</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">DWARF2+の行番号テーブルを生成する場合、GCCが内部的にDWARF2+の行番号テーブルを生成するように強制する。</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">関数へのすべての呼び出しを強制的に間接的にします。これは、関数呼び出しのタイミング情報をより正確に生成する Intel Processor Trace を使用する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">すべての関数を強制的に 4 バイトの境界に合わせます。</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">すべてのロードおよびストア命令は、命令のI/Oバリアントを使用して常にキャッシュをバイパスするように強制します。デフォルトではキャッシュをバイパスしないようになっています。</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">アセンブリ出力で常に16進数の定数を使用するように強制します。通常、このような定数は符号付き小数ですが、このオプションはテストスイートや美的目的のために利用可能です。</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">ARM(A32)ISAでの強制コード生成。</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">アーキテクチャレベルに応じて、Thumb (T16/T32)ISAで強制的にコードを生成します。</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">レジスタ経由で強制的に間接呼び出しとジャンプを行う。</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">条件付きブランチの遅延スロットの使用を強制します。適切な命令が見つからない場合は、遅延スロットに &lt;code&gt;nop&lt;/code&gt; が詰め込まれます。デフォルトでは、このオプションは無効になっています。元のSH7055にあるハードウェアのバグを回避するために有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">jli_s 命令を使用して関数を強制的に呼び出します。このオプションはARCv2アーキテクチャでのみ有効です。</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; 命令を使用して特定の関数を強制的に呼び出します。 &lt;code&gt;jli&lt;/code&gt; 命令に記憶されたテーブルの使用なり &lt;code&gt;.jlitab&lt;/code&gt; この命令を使用してアドレス指定される機能の位置を保持するセクションを、。</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">属性の正式な構文。</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">特定のターゲットに固有のフォーマットチェックを行います。</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">以前は &lt;code&gt;hi&lt;/code&gt; レジスターでした。この制約はサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">(従来のプリプロセッサを使用した)前処理が必要なフリーフォームのFortranソースコード。</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">前処理してはいけない自由形のFortranソースコード。</target>
        </trans-unit>
        <trans-unit id="79c3d4c459214fa53411ede2a681be19e9178e25" translate="yes" xml:space="preserve">
          <source>Fully split wide types early, instead of very late. This option has no effect unless</source>
          <target state="translated">ワイドタイプを完全に分割し、 非常に遅くするのではなく早めに分割します。このオプションは</target>
        </trans-unit>
        <trans-unit id="4b3ade0ff4647a9f20d6dba70ea3a9f2cb1aec15" translate="yes" xml:space="preserve">
          <source>Function Pointer Size</source>
          <target state="translated">関数ポインタサイズ</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">関数属性は、関数の宣言の &lt;code&gt;__attribute__&lt;/code&gt; キーワードによって導入され、その後に二重括弧で囲まれた属性指定が続きます。宣言で複数の属性を指定するには、属性を二重括弧内のコンマで区切るか、属性指定の直後に別の属性を続けます。属性の構文と配置に関する正確な規則については、「&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性の構文&lt;/a&gt;」を参照してください。同じ関数の異なる宣言の互換性のある属性仕様がマージされます。同じ関数の宣言にすでに適用されている属性と互換性のない属性指定は、警告とともに無視されます。</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">関数の精度。トラップハンドラは、浮動小数点例外の原因となった関数を判定することができます。</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">関数プロトタイプ</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">プロファイルインストルメンテーションに基づく関数の並び替えでは、関数の初回実行時間を収集し、昇順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="84a74152b608e42b8dbf493e4c08ff7789383e02" translate="yes" xml:space="preserve">
          <source>Function return values larger than 64 bits are passed by using a hidden pointer as the first argument of the function. TI ABI, though, mandates that the pointer can be NULL in case the caller is not using the returned value. GNU always passes and expects a valid return value pointer.</source>
          <target state="translated">64 ビットよりも大きい関数の戻り値は、関数の第 1 引数に hidden ポインタを使用して渡されます。しかし、TI ABIでは、呼び出し元が戻り値を使用していない場合には、ポインタをNULLにすることが義務付けられています。GNUは常に有効な戻り値ポインタを渡し、期待しています。</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">関数は16ビットの境界にアラインメントされています。</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">サイズを最適化しない限り、関数は32ビット境界に整列されます。</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 属性で宣言された関数には、基本的な &lt;code&gt;asm&lt;/code&gt; も必要です（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">異なるモードの関数は、呼び出し元のモードにインライン化できます。</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">関数のプロログ/エピログは、適切なサブルーチンの呼び出しとして展開されます。コードサイズが小さくなります。</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">通常は組み込まれているが、ISO Cで定義されているセマンティクスを持たない関数（ &lt;code&gt;alloca&lt;/code&gt; や &lt;code&gt;ffs&lt;/code&gt; など）は、次の場合には組み込み関数ではありません。</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">自由ソフトウェアの資金調達</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">さらに、&lt;em&gt;earlyclobber&lt;/em&gt;オペランドが読み取り/書き込みオペランドでもある場合、そのオペランドは使用後にのみ書き込まれます。</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">GCCの将来のバージョンでは、ゼロ拡張するか、ターゲット定義の &lt;code&gt;ptr_extend&lt;/code&gt; パターンを使用する可能性があります。符号拡張に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++は、仮想関数が 'を返すことを許可します</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++では、匿名構造体と組合が、パブリックではない非静的データのメンバ(つまりフィールド)を持つことができます。これらの拡張機能は非推奨です。</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++では、属性を括弧で囲まれた直接初期化子に続けることができます。</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++では、浮動小数点リテラルを整数定数式に含めることができます。例： '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++では、const 浮動小数点型の静的データ・メンバをクラス定義でイニシャライザを使用して宣言することができます。標準では、const 積分型と const 列挙型の静的メンバに対してのみイニシャライザを許可しているため、この拡張機能は非推奨となり、将来のバージョンから削除される予定です。</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++は、コピー割り当てのための「直感的な」アルゴリズムを実装します。すべての直接ベースを割り当ててから、すべてのメンバーを割り当てます。そのアルゴリズムでは、仮想ベースサブオブジェクトが複数回発生する可能性があります。この例では、コピーは次の順序で行われます。</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++は、リンカがサポートしているターゲット(GNU/LinuxなどのELFターゲット、Mac OS X、Microsoft Windowsなど)でボーランドモデルを実装します。それ以外の場合は、G++は自動モデルを実装していません。</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++は、揮発性オブジェクトに割り当てるときのGCCと同じ動作を実装します。割り当て先オブジェクトの再読み取りがなく、割り当てられた右辺値が再利用されます。C ++の割り当て式は左辺値であり、左辺値として使用された場合、揮発性オブジェクトが参照されることに注意してください。たとえば、次の例では、 &lt;var&gt;vref&lt;/var&gt; が予想どおり &lt;var&gt;vobj&lt;/var&gt; を参照しています。</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCCは、適合した独立した実装として、または適合したホストされた実装のコンパイラとして使用できることを目指しています。デフォルトでは、ホストされた実装のコンパイラーとして機能し、 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; として定義し、ISO C関数の名前が使用される場合、それらは標準で定義されているセマンティクスを持っていると想定します。自立型環境の適合自立型実装として機能させるには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、Cラベルに属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、および型（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、列挙子に属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、およびタイプ（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、nullステートメントに属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、および型（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;型属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCCでは、柔軟な配列メンバーの静的な初期化が可能です。これは、元の構造を含む新しい構造を定義し、その後にデータを格納するのに十分なサイズの配列を定義することと同じです。たとえば、以下では、 &lt;code&gt;f1&lt;/code&gt; は &lt;code&gt;f2&lt;/code&gt; のように宣言されたかのように構築されます。</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCCを使用すると、ユーザーは特定の種類の診断を選択的に有効または無効にしたり、診断の種類を変更したりできます。たとえば、プロジェクトのポリシーでは、すべてのソースをコンパイルして</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCCでは、 &lt;code&gt;typedef&lt;/code&gt; 名をベクトル型の型指定子として使用できますが、これは次の状況でのみ可能です。</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCCでは、ベクター型の型指定子として &lt;code&gt;typedef&lt;/code&gt; 名を使用できます。</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCCでは、ネストされたブロックスコープで&lt;em&gt;ローカルラベル&lt;/em&gt;を宣言できます。ローカルラベルは通常のラベルと同じですが、それを宣言できるブロック内でのみ（ &lt;code&gt;goto&lt;/code&gt; ステートメントを使用するか、アドレスを取得することによって）参照できます。</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCCでは</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC にはすでに広範なサフィックスのリストが組み込まれています。このディレクティブはサフィックスのリストの最後にエントリを追加しますが、 リストは最後から順に検索されるので、この手法を使って以前のエントリを上書きすることが 事実上可能です。</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">GCCはまた、ColdFireマイクロアーキテクチャー &lt;var&gt;uarch&lt;/var&gt; のチューニング時にマクロ &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; 定義します。ここで、 &lt;var&gt;uarch&lt;/var&gt; は上記の引数の1つです。</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCCはまた、暗黙のうちに</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCCには、コンパイル中にメッセージを印刷するためのシンプルな仕組みもあります。</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCCは、ターゲット固有のマクロ &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; も提供します。これは、コンパイル対象のターゲットマシン上の任意のデータ型でこれまでに使用された最大のアライメントです。たとえば、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCCは、ネットワークレジスタに直接アクセスするための内部構造も提供しています。イントリニクスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCは、変数宣言（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、およびタイプ（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）の属性もサポートしています。</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCCは、 &lt;code&gt;format&lt;/code&gt; 属性の候補となる可能性がある関数定義についても警告します。繰り返しますが、これらは可能な候補にすぎません。 GCCは、 &lt;code&gt;format&lt;/code&gt; 属性が &lt;code&gt;vprintf&lt;/code&gt; や &lt;code&gt;vscanf&lt;/code&gt; などの関数を呼び出すすべての関数に適していると推測していますが、常にそうであるとは限らず、 &lt;code&gt;format&lt;/code&gt; 属性が適切である一部の関数が検出されない場合があります。</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCCは、除算の結果がゼロに向かって切り捨てられるというC99とC11の要件に常に従います。</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCCは、可能であれば常にプログラムをコンパイルしようとします。（たとえば）標準に準拠していないという理由だけで意味が明確なプログラムを不当に拒否することはありません。ただし、場合によっては、CおよびC ++標準では、特定の拡張を禁止し、適合コンパイラーによって診断を発行する&lt;em&gt;必要&lt;/em&gt;があると規定しています。の</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC は、デフォルトでは GNU Objective-C ランタイムライブラリを使用しますが、これは GCC の一部であり、Apple システムで使用されている Apple/NeXT Objective-C ランタイムライブラリとは同じではありません。このマニュアルには、いくつかの違いが記載されています。オプション</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC自体は、適合した独立した実装になることを試みます。これの意味の詳細については、&lt;a href=&quot;standards#Standards&quot;&gt;GCC&lt;/a&gt;でサポートされている言語標準を参照してください。このような実装に必要なライブラリ機能の他に、Cライブラリの残りはオペレーティングシステムのベンダーによって提供されます。そのCライブラリがC標準に準拠していない場合、プログラムは警告を受け取る可能性があります（特に、</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCCは、不連続な方法で複雑な自動変数を割り当てることができます。虚数部がスタック上にあるときに実数部がレジスタに存在することも可能です（またはその逆）。これを表すことができるのはDWARFデバッグ情報形式だけなので、DWARFの使用をお勧めします。 stabsデバッグ情報形式を使用している場合、GCCは、非連続タイプの2つの別個の変数であるかのように、不連続の複素変数を記述します。変数の実際の名前が &lt;code&gt;foo&lt;/code&gt; の場合、2つの架空の変数の名前は &lt;code&gt;foo$real&lt;/code&gt; および &lt;code&gt;foo$imag&lt;/code&gt; です。これら2つの架空の変数をデバッガーで調べて設定できます。</target>
        </trans-unit>
        <trans-unit id="8c74211307275623a7dfd79983ff1fca91bf2ce8" translate="yes" xml:space="preserve">
          <source>GCC can also be configured (via the</source>
          <target state="translated">GCC の設定も可能です (</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCCは、HSA Programmer's Reference Manualバージョン1.0.1で説明されているように、HSAILテキスト形式のバイナリ表現（BRIG）をコンパイルできます。この機能は通常、gccがサポートされているプロセッサーにHSAランタイムAPIのHSAILファイナライズ拡張機能を実装するために使用されます。HSA標準は、&lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http：&lt;/a&gt; //www.hsafoundation.com/standards/から無料で入手できます。</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCCは、VxWorksカーネルとリアルタイムプロセス（RTP）の両方のコードを生成できます。このオプションは、前者から後者に切り替えます。また、プリプロセッサマクロ &lt;code&gt;__RTP__&lt;/code&gt; も定義します。</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC は asm の中で 1 つの可換的なペアしか扱えません。2つの選択肢が厳密に同一である場合は修飾子を使用する必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC には、システムヘッダファイルの既知の問題を修正するためのシェルスクリプトが付属しています。それらは、様々なヘッダファイルの修正されたコピーを、通常はGCCだけが探すことができる特別なディレクトリにインストールします。スクリプトは、我々が知っている問題のケースのためにすべてのシステムヘッダファイルを検索することによって、様々なシステムに適応します。</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC でコンパイルされたコードが HP-UX アセンブラから警告を発することがあります。</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCCは、「</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC は、失敗する前処理の条件式の中にある終端のない文字定数に不満を感じています。プログラムの中には、条件式の中に英語のコメントが含まれているものがありますが、これらのコメントにアポストロフィが含まれている場合、GCC はおそらくエラーを報告します。例えば、以下のコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCCは、&lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http:&lt;/a&gt; //openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.htmlにあるOpenPOWER 64ビットELF V2 ABI仕様に準拠しています。このドキュメントの付録Aは、準拠するコンパイラが提供する必要があるベクターAPIインターフェースの一覧です。プログラマーは、そこに記述されているインターフェースを優先的に使用する必要があります。ただし、歴史的にGCCは、ベクトル命令にアクセスするための追加のインターフェースを提供してきました。これらについて以下に簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c80707819ec65b1cb82541da2d3b9e30cf2076e3" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCCは、&lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https：&lt;/a&gt; //openpowerfoundation.org/？resource_lib = 64-bit-elf-v2-abi-specification-power-architectureにあるOpenPOWER64ビットELFV2ABI仕様に準拠しています。このドキュメントの付録Aには、準拠コンパイラが提供する必要のあるベクターAPIインターフェイスがリストされています。プログラマーは、そこに記載されているインターフェースを優先的に使用する必要があります。ただし、歴史的にGCCは、ベクトル命令にアクセスするための追加のインターフェースを提供してきました。これらについて以下に簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCCは、現在の呼び出し発する &lt;code&gt;vmldExp2&lt;/code&gt; 、 &lt;code&gt;vmldLn2&lt;/code&gt; 、 &lt;code&gt;vmldLog102&lt;/code&gt; 、 &lt;code&gt;vmldPow2&lt;/code&gt; 、 &lt;code&gt;vmldTanh2&lt;/code&gt; 、 &lt;code&gt;vmldTan2&lt;/code&gt; 、 &lt;code&gt;vmldAtan2&lt;/code&gt; 、 &lt;code&gt;vmldAtanh2&lt;/code&gt; 、 &lt;code&gt;vmldCbrt2&lt;/code&gt; 、 &lt;code&gt;vmldSinh2&lt;/code&gt; 、 &lt;code&gt;vmldSin2&lt;/code&gt; 、 &lt;code&gt;vmldAsinh2&lt;/code&gt; 、 &lt;code&gt;vmldAsin2&lt;/code&gt; 、 &lt;code&gt;vmldCosh2&lt;/code&gt; 、 &lt;code&gt;vmldCos2&lt;/code&gt; 、 &lt;code&gt;vmldAcosh2&lt;/code&gt; 、 &lt;code&gt;vmldAcos2&lt;/code&gt; 、 &lt;code&gt;vmlsExp4&lt;/code&gt; 、 &lt;code&gt;vmlsLn4&lt;/code&gt; 、 &lt;code&gt;vmlsLog104&lt;/code&gt; 、 &lt;code&gt;vmlsPow4&lt;/code&gt; 、 &lt;code&gt;vmlsTanh4&lt;/code&gt; を、 &lt;code&gt;vmlsTan4&lt;/code&gt; 、 &lt;code&gt;vmlsAtan4&lt;/code&gt; 、 &lt;code&gt;vmlsAtanh4&lt;/code&gt; 、 &lt;code&gt;vmlsCbrt4&lt;/code&gt; 、 &lt;code&gt;vmlsSinh4&lt;/code&gt; 、 &lt;code&gt;vmlsSin4&lt;/code&gt; 、 &lt;code&gt;vmlsAsinh4&lt;/code&gt; 、 &lt;code&gt;vmlsAsin4&lt;/code&gt; 、 &lt;code&gt;vmlsCosh4&lt;/code&gt; 、 &lt;code&gt;vmlsCos4&lt;/code&gt; 、 &lt;code&gt;vmlsAcosh4&lt;/code&gt; および &lt;code&gt;vmlsAcos4&lt;/code&gt; およびvmlsAcos4の場合</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCCは、ColdFireターゲットのコードを生成するときはいつでも、マクロ &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 定義します。このマクロの &lt;var&gt;arch&lt;/var&gt; は、</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCCは、指定された &lt;var&gt;cpu&lt;/var&gt; のプリプロセッサマクロを定義します。のために '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC は、ユーザーコードが機能の有無をテストできるように、いくつかの組み込みマクロを定義しています。以下の組み込みマクロのほとんどは、デバイスの機能から推論され、したがって</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">ColdFireターゲット &lt;var&gt;cpu&lt;/var&gt; が選択されている場合、GCCはマクロ &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; を定義します。また、 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; も定義しています。この場合、 &lt;var&gt;family&lt;/var&gt; の値は上記の表で与えられます。</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">このオプションが有効な場合、GCCはマクロ &lt;code&gt;__mcfhwdiv__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCCは、680x0アーキテクチャの &lt;var&gt;arch&lt;/var&gt; チューニングするときに、マクロ &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 定義します。どちらかでない限り、 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; &lt;var&gt;arch&lt;/var&gt; も定義します</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCCは、この組み込みをサポートするように更新されたターゲットに対して、プリプロセッサマクロ &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCCは、このオプションの値に基づいて2つのマクロを定義します。1つ目は &lt;code&gt;_MIPS_ARCH&lt;/code&gt; で、ターゲットアーキテクチャの名前を文字列として提供します。2番目の形式は &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; で、 &lt;var&gt;foo&lt;/var&gt; は &lt;code&gt;_MIPS_ARCH&lt;/code&gt; の大文字の値です。例えば、</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCCがSSEx命令を抑制する場合</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">GCCは、 'を指定しない限り、最適化しない場合は関数をインライン化しません。</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCCは基本的な &lt;code&gt;asm&lt;/code&gt; の &lt;var&gt;AssemblerInstructions&lt;/var&gt; を解析しません。つまり、それらの内部で何が起こっているかをコンパイラーに伝える方法はありません。 GCCは &lt;code&gt;asm&lt;/code&gt; 内のシンボルを可視化せず、参照されていないものとして破棄する場合があります。また、メモリやレジスタの変更など、アセンブラコードの副作用についても認識しません。一部のコンパイラーとは異なり、GCCは汎用レジスターへの変更は発生しないと想定しています。この仮定は、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCCでは、次のようなCライブラリ機能は提供されていません。</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCCは、ホストされた実装のみに必要なライブラリ機能を提供していません。また、すべてのプラットフォームでのC99の自立型実装に必要なすべての機能も提供していません。ホスト環境の機能を使用するには、それらを他の場所（たとえば、GNU Cライブラリー）で見つける必要があります。&lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;標準ライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCCは、マクロの引数が文字列定数の中に現れた場合、マクロの引数を代用しません。例えば、GCC の次のマクロは</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCCは拡張整数型をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCCは、非静的ローカル変数でのこの機能の使用をサポートしていません。そのような変数にはアセンブラ名がないためです。変数を特定のレジスターに配置する場合は、&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;明示的なレジスター変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCCではそのような値は使用していません。</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCCはデフォルトでこの属性に基づいて警告を発します。</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC では、デフォルトでこのオプションが有効になっています。最適化がオンになっているかどうかに関わらず、変数が参照されているかどうかをコンパイラに強制的にチェックさせたい場合は</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCCは現在のところ、非脆弱性インスタンス変数をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCCは長い間バリアディックマクロをサポートしており、他の引数と同じように変数引数に名前を付けることができる別の構文を使用していました。ここに例を示します。</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCCには、以下の仕様文字列が組み込まれています。Spec ファイルは、これらの文字列をオーバーライドしたり、独自の文字列を作成したりすることができます。個々のターゲットは、独自の仕様文字列をこのリストに追加することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCCは、データが書き込もうとするオブジェクトのサイズを決定し、サイズが十分でない場合に書き込みを防ぐことにより、一部のバッファーオーバーフロー攻撃を防ぐことができる制限付きバッファーオーバーフロー保護メカニズムを実装しています。以下で説明する組み込み関数は、一緒に使用した場合、および最適化が有効になっている場合に最良の結果をもたらします。たとえば、関数の境界を越えてオブジェクトのサイズを検出したり、重要な制御フローを通じてポインタの割り当てを追跡したりするには、次のようにして有効化されたさまざまな最適化パスに依存します。</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCCはCの拡張機能を実装してい&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;ます&lt;/a&gt;。これは、http： //infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdfにあるARM C言語拡張機能（ACLE）仕様で説明されています。</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCCは、CとC ++の両方に対して、 &lt;code&gt;offsetof&lt;/code&gt; マクロを実装する構文拡張を実装します。</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCCは、&lt;em&gt;trampolines&lt;/em&gt;と呼ばれる手法を使用して、ネストされた関数のアドレスを取ることを実装します。この手法は、C ++の字句閉包で説明されています（Thomas M. Breuel、USENIX C ++ Conference Proceedings、1988年10月17〜21日）。</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCCは、&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http&lt;/a&gt;：//infocenter.arm.com/help/topic/com.arm.docにある「ARMv8-M Security Extensions：Requirements on Development Tools Engineering Specification」で説明されているように、ARMv8-M Security Extensionsを実装しています。 ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf。</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCCは、関数をインラインで宣言する際に、3つの異なるセマンティクスを実装しています。一つは</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCCには、標準Cライブラリの多くの関数の組み込みバージョンが含まれています。これらの関数には2つの形式があります。1つは &lt;code&gt;__builtin_&lt;/code&gt; 接頭辞で始まる名前、もう1つは名前のない名前です。両方の形式は同じタイプ（プロトタイプを含む）、同じアドレス（アドレスが取得された場合）、およびCライブラリ関数と同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCCは従来のCとは相性が悪い。</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCCは利用可能なメモリが限られています。</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCCは、一部のシステムヘッダーファイルの修正バージョンをインストールする必要があります。これは、ほとんどのターゲットシステムに、変更しないとGCCで動作しないヘッダーファイルがあるためです。バグのあるもの、ISO Cと互換性のないもの、他のコンパイラの特別な機能に依存しているものがあります。</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCCは、バージョン2以降とは実質的に異なるDWARFバージョン1をサポートしなくなりました。歴史的な理由から、他のいくつかのDWARF関連のオプションでは</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCCは通常、 &lt;code&gt;__STDC__&lt;/code&gt; &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 1と定義し、さらに__STRICT_ANSI__を定義します。</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCCは通常、特定の組み込み関数をより効率的に処理するための特別なコードを生成します。たとえば、 &lt;code&gt;alloca&lt;/code&gt; の呼び出しは、スタックを直接調整する単一の命令になり、 &lt;code&gt;memcpy&lt;/code&gt; の呼び出しは、インラインコピーループになる場合があります。多くの場合、結果のコードは小さくて高速ですが、関数呼び出しはそのように表示されないため、それらの呼び出しにブレークポイントを設定したり、別のライブラリとリンクして関数の動作を変更したりすることはできません。さらに、関数が組み込み関数として認識されると、GCCはその関数に関する情報を使用して、その関数への呼び出しに関する問題について警告したり、結果のコードにその関数への呼び出しが含まれていても、より効率的なコードを生成したりできます。たとえば、警告は</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCCは通常、文字列定数を読み取り専用にします。複数の同一の文字列定数が使用されている場合、GCCはその文字列のコピーを1つだけ保存します。</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCCは通常、GOTから値をロードするために1つの命令を使用します。これは比較的効率的ですが、GOT が約 64k よりも小さい場合にのみ動作します。これ以上小さくなると、リンカは以下のようなエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">GCCオプション。</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCCは、C構造体にメンバーがいないことを認めています。</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCCはC言語の割り込みハンドラの記述を支援するために、いくつかの特別な組み込み関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC には、上記以外にも多くの組み込み関数があります。これらの中には例外や可変長の引数リストの処理で内部的に使用するためのものもありますが、これらは随時変更される可能性があるため、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCCは、MotorolaのAltiVecプログラミングインターフェイスマニュアルで説明されているAltiVec操作にアクセスするためのPowerPCファミリーのプロセッサ用のインターフェイスを提供します。インターフェイスは、 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; をインクルードして使用することで利用可能になります</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCCは、picoChip命令セットから選択されたマシン命令へのインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCCは、ISO C99浮動小数点比較マクロの組み込みバージョンを提供し、順序付けられていないオペランドの例外の発生を回避します。彼らは、標準マクロ（と同じ名前を持つ &lt;code&gt;isgreater&lt;/code&gt; 、 &lt;code&gt;isgreaterequal&lt;/code&gt; 、 &lt;code&gt;isless&lt;/code&gt; 、 &lt;code&gt;islessequal&lt;/code&gt; 、 &lt;code&gt;islessgreater&lt;/code&gt; 、および &lt;code&gt;isunordered&lt;/code&gt; で、） &lt;code&gt;__builtin_&lt;/code&gt; は接頭辞。ライブラリの実装者が、各標準マクロを組み込みの同等のマクロに &lt;code&gt;#define&lt;/code&gt; できるようにするつもりです。同じ方法では、GCCは提供 &lt;code&gt;fpclassify&lt;/code&gt; 、 &lt;code&gt;isfinite&lt;/code&gt; の、 &lt;code&gt;isinf_sign&lt;/code&gt; 、 &lt;code&gt;isnormal&lt;/code&gt; かつ &lt;code&gt;signbit&lt;/code&gt; を &lt;code&gt;__builtin_&lt;/code&gt; を前に付けて使用するビルトイン。 &lt;code&gt;isinf&lt;/code&gt; と &lt;code&gt;isnan&lt;/code&gt; 組み込み関数は、ととなしの両方に表示され &lt;code&gt;__builtin_&lt;/code&gt; 接頭辞。</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCCは、Sony / Toshiba / IBM SPU言語拡張仕様で説明されているように、SPUプロセッサーの拡張機能を提供します。GCCの実装はいくつかの点で異なります。</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCCは、TI C6Xプロセッサの特定の命令にアクセスするための組み込み関数を提供します。以下にリストされているこれらの組み込み関数は、 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; ヘッダーファイルをインクルードした後に使用できます。それらはC6X命令に直接マップされます。</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC は、TILE-Gx プロセッサのすべての命令にアクセスするための組込み関数を提供します。内部構造は次のような形をしています。</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCCは、TILEProプロセッサのすべての命令にアクセスするための組込み関数を提供します。内部構造は、次のような形をしています。</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCCは、MSA MIPS SIMDアーキテクチャによって提供されるSIMD命令にアクセスするための組み込み関数を提供します。インターフェイスは &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; をインクルードして使用することで利用可能になります</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCCは、ST Microelectronics Loongson-2Eおよび-2Fプロセッサーが提供するSIMD命令にアクセスするための組み込み関数を提供します。 &lt;code&gt;loongson.h&lt;/code&gt; ヘッダーファイルのインクルード後に利用可能なこれらの組み込み関数は、次の64ビットベクトルタイプで動作します。</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCCは多くのFR-V固有の組み込み関数を提供します。一般に、これらの関数は、FR-Vファミリ、Softune C / C ++コンパイラマニュアル（V6）、富士通セミコンダクターで説明されているものとの互換性を目的としています。2つの例外は &lt;code&gt;__MDUNPACKH&lt;/code&gt; と &lt;code&gt;__MBTOHE&lt;/code&gt; です。これらのGCC形式では、128ビット値を値ではなくポインタで渡します。</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCCは、他のMIPS固有の組み込み関数を提供します。</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCCは、Cライブラリ関数 &lt;code&gt;setjmp&lt;/code&gt; および &lt;code&gt;longjmp&lt;/code&gt; に類似しているが互換性がない &lt;code&gt;__builtin_longjmp&lt;/code&gt; 関数 &lt;code&gt;__builtin_setjmp&lt;/code&gt; および__builtin_longjmpを提供しています。組み込みバージョンは、一部のターゲットで例外処理を実装するためにGCCのライブラリによって内部的に使用されます。組み込み関数ではなく、ユーザーコードの &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; で宣言されている標準Cライブラリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCCは、現在の関数の名前を文字列として保持する3つの魔法の定数を提供します。C ++ 11以降のモードでは、3つすべてが定数式として扱われ、 &lt;code&gt;constexpr&lt;/code&gt; コンテキストで使用できます。これらの定数の最初は、C99標準の一部である &lt;code&gt;__func__&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC は、PowerPC ファミリのいくつかのプロセッサ(例えば POWER8)で利用可能なハードウェア・トランザクション・メモリ(HTM)命令にアクセスするための 2 つのインタフェースを提供します。この2つのインタフェースには、PowerPC固有の組み込み関数からなる低レベルのインタフェースと、PowerPCとS/390の間で共通のインライン関数からなる高レベルのインタフェースがあります。</target>
        </trans-unit>
        <trans-unit id="0504373821c4265dbbe47258f3675e81d3bda382" translate="yes" xml:space="preserve">
          <source>GCC searches for the &amp;lsquo;</source>
          <target state="translated">GCCは 'を検索します</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCCは「GNU Compiler Collection」の略です。GCCは、いくつかの主要なプログラミング言語用のコンパイラの統合ディストリビューションです。これらの言語には現在、C、C ++、Objective-C、Objective-C ++、Fortran、Ada、D、Go、およびBRIG（HSAIL）が含まれます。</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">技術報告書草案で規定されている10進数の浮動小数点のGCCサポートは不完全である。</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">技術報告書草案で規定されている定点型のGCCサポートは不完全である。</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCCは「従来の」Objective-C（「Objective-C 1.0」とも呼ばれる）をサポートし、Objective-C例外および同期構文のサポートを含みます。また、プロパティ、高速列挙（Objective-Cのみ）、メソッド属性、プロトコルの@optionalキーワードおよび@requiredキーワードなど、多数の「Objective-C 2.0」言語拡張もサポートしています。GCCはObjective-C ++をサポートしており、Objective-Cで利用可能な機能はObjective-C ++でも利用できます。</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCCは両方の一般的なベクトルの拡張機能を使用してMIPS DSP演算をサポートしています（参照&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンションを&lt;/a&gt;）および組み込み関数MIPS固有のコレクション。どちらの種類のサポートも、</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCCは、一般的なベクトルの拡張機能の両方を使用して（参照SPARC上のSIMD演算をサポートしている&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンションを&lt;/a&gt; SPARCビジュアル命令セット（VIS）のため）だけでなく、組み込み関数。あなたが使うとき</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCCは、指定された宣言のアセンブリで使用される名前を変更する &lt;code&gt;#pragma&lt;/code&gt; ディレクティブをサポートしています。このプラグマはすべてのプラットフォームでサポートされていますが、主にSolarisシステムヘッダーとの互換性を提供することを目的としています。この効果は、asmラベル拡張を使用して実現することもできます（&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asmラベルを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC は、通常生成するコードにランタイム計測器を追加する制御を行うコマンドラインオプションを多数サポートしています。例えば、インストルメンテーションの目的の1つは、プログラムのホットスポットの発見、コードカバレッジ分析、プロファイルガイド付き最適化に使用するためのプロファイリング統計情報を収集することです。プログラムのインストルメンテーションの別のクラスには、無効なポインタのディファレンスや範囲外の配列アクセスなどのプログラミング・エラーや、スタック・スマッシングや C++vtable ハイジャックなどの意図的な敵対的な攻撃を検出するためのランタイム・チェックを追加する機能があります。また、デバッグやプログラム解析を目的とした他の形式のトレースや関数レベルのインストルメンテーションを実装するために使用できる一般的なフックもあります。</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCCは、浮動小数点レジスタが32ビット幅ではなく64ビット幅のo32 ABIの変形をサポートしています。この組み合わせは</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCCは2の補数の整数型のみをサポートし、すべてのビットパターンは通常の値です。</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCCの支持体は、ペア、単一の汎用ベクトル拡張（参照両方使用した操作&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンション&lt;/a&gt;）と組み込み関数MIPS固有のコレクションを。どちらの種類のサポートも、</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCCは、主に他のコンパイラー用に最初に作成されたコードをコンパイルするために、いくつかのタイプのプラグマをサポートしています。通常、プラグマの使用はお勧めしません。詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCCは、C言語では表現できないいくつかのRX命令を組み込み関数を使ってサポートしています。サポートされている関数は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCCはD 2.0プログラミング言語をサポートしています。D言語自体は現在、&lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https：//dlang.org/spec/spec.html&lt;/a&gt;で説明されているリファレンス実装とサポート言語仕様によって定義されています。</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCCは以下のAVRデバイスとISAをサポートしています。</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCCは、1998年に発行されたオリジナルのISO C++規格と、2011年と2014年の改訂版をサポートしています。</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCCは、C-SKY V2プロセッサのコンパイル時にこれらのオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCCは、SVEコード生成の2つの形式をサポートしています。任意のサイズのベクトルレジスターで機能する「ベクトル長に依存しない」出力と、最適化の理由で役立つ場合にGCCがベクトル長について仮定できる「ベクトル長固有」出力です。'の可能な値</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCCは、識別子のすべての文字を重要なものとして扱います。K＆R-1（2.2）によると、「重要なのは最初の8文字のみですが、それ以上使用してもかまいません。」また、K＆R-1（2.2）によれば、「識別子は文字と数字のシーケンスです。最初の文字は文字でなければなりません。アンダースコア_は文字としてカウントされます。」ですが、GCCでは識別子にドル記号も使用できます。</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCCは &lt;var&gt;name&lt;/var&gt; を使用して、アセンブリコードを生成するときに、どのような命令を発行できるかを決定します</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCCは &lt;var&gt;name&lt;/var&gt; を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。もし</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCCはガベージコレクターを使用して、独自のメモリ割り当てを管理します。このパラメーターは、ガベージコレクターのヒープがコレクション間で拡張できる最小の割合を指定します。これを調整すると、コンパイル速度が向上する場合があります。コード生成には影響しません。</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCCは修正されたバージョンのシステムヘッダーファイルを使用します。これは必要ですが、常にスムーズに機能するとは限りません。</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCCは、プロファイリングフィードバックが提供されていない場合に、分岐確率を推測するためにヒューリスティックを使用します (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCCはシステムCライブラリを使用しているため、ISO C規格に準拠していない可能性があります。</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">の場合、GCC は関数をインライン化しません。</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCCのデフォルトの動作は、 &lt;code&gt;dllexport&lt;/code&gt; 属性を持つすべてのインライン関数を発行することです。これはオブジェクトのファイルサイズの膨張を引き起こす可能性があるため、使用できます</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">CおよびC ++コードから利用可能なGCCの高水準言語インターフェースの実装は、いくつかの点でモトローラのドキュメントと異なります。</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCCのオプティマイザは、このコードを以前の例の不揮発性コードのように扱いません。前の呼び出しからの結果がまだ有効であるという前提で、ループの外に移動したり、省略したりしません。</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">GCCのオプティマイザは、出力変数が必要ないと判断した場合、 &lt;code&gt;asm&lt;/code&gt; ステートメントを破棄することがあります。また、オプティマイザは、コードが常に同じ結果を返す（つまり、呼び出し間で入力値が変化しない）と考える場合、ループからコードを移動する場合があります。 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用すると、これらの最適化が無効になります。 &lt;code&gt;asm&lt;/code&gt; &lt;code&gt;asm goto&lt;/code&gt; ステートメントを含む、出力オペランドを持たないasmステートメントは、暗黙的に揮発性です。</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX には、オブジェクトファイルの絶対パスに追加する接頭辞が含まれています。プレフィックスは絶対パスでも、相対パスでも構いません。デフォルトはプレフィックスなしです。</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP は、ハードワイヤード絶対パスから削除する初期ディレクトリ名の数を指定します。デフォルト値は 0 です。</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNIの指示。</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU Cでは、特定のハードウェアレジスタをC変数に関連付けることができます。ほとんどの場合、コンパイラがレジスタを割り当てることで最良のコードが得られます。しかし、特定の異常な状況下では、変数の保存をより正確に制御する必要があります。</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU CはISO Cを拡張して、関数プロトタイプが後の古いスタイルの非プロトタイプ定義を上書きできるようにしました。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C は ISO 標準 C にはないいくつかの言語機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++は旧式の関数定義をサポートしていないので、この拡張は無関係です。</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPPには、さらに2つの可変マクロ拡張があり、マクロ定義の上記の形式のいずれかと一緒に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP では、この方法で変数引数を完全に省略することができます。上記の例では、マクロの展開はまだフォーマット文字列の後に余分なカンマがあるので、コンパイラは文句を言うでしょう。</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU自由文書ライセンス</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU一般公衆利用許諾書</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU General Public Licenseには、GCCをコピーして共有する方法が記載されています。</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-Cは、コンパイラーによって直接生成される定数文字列オブジェクトを提供します。定数文字列オブジェクトを宣言するには、C定数文字列の前に文字 'を付けます。</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-Cは、以下の例のように、言語に組み込まれた例外のサポートを提供しています。</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-Cは同期化されたブロックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-Cは高速な列挙構文をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-Cのランタイム機能。</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-Cは、C / Objective-C型から型エンコードを作成できる &lt;code&gt;@encode&lt;/code&gt; 構文をサポートしています。たとえば、 &lt;code&gt;@encode(int)&lt;/code&gt; はコンパイラによって &lt;code&gt;&quot;i&quot;&lt;/code&gt; にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">のGNU方言</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11のGNU方言。名前 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17 の GNU 方言。これはCコードのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90 の GNU 方言 (C99 の機能を含む)。</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99のGNU方言。名前 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">C言語ファミリのGNU拡張。</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">C++言語のGNU拡張。</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64ビット命令が有効な場合、またはNO_REGSの場合は汎用レジスタ。</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">一般レジスタ1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;addl&lt;/code&gt; 命令用の汎用レジスター &lt;code&gt;r0&lt;/code&gt; から &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">汎用レジスター、ただし &lt;code&gt;r29&lt;/code&gt; 、 &lt;code&gt;r30&lt;/code&gt; および &lt;code&gt;r31&lt;/code&gt; は不可</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">汎用32ビットレジスタ</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">一般的に、メモリトランザクションが成功する保証はなく、常に適切なフォールバックコードを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">一般的に、最適化が指定されない限り、関数はインライン化されません。インラインで宣言された関数の場合、この属性は、インライン化に適用される制限とは無関係に関数をインライン化します。このような関数がインライン化されていない場合は、エラーと診断されます。このような関数が間接的に呼び出された場合、コンパイラは最適化レベルに応じてその関数をインライン化するかどうかを決定し、間接的な呼び出しがインライン化されなかった場合は診断されない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">一般に、関数へのインライン展開は制限されています。この属性でマークされた関数の場合、可能であれば、この関数内のすべての呼び出しがインライン化されます。属性 &lt;code&gt;noinline&lt;/code&gt; などで宣言された関数はインライン化されません。関数自体がインライン化の対象となるかどうかは、そのサイズと現在のインライン化パラメーターによって異なります。</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">一般的に、リンク時に指定されたオプションはコンパイル時に指定されたものを上書きしますが、GCCは入力ファイルのコンパイルに使用された設定からリンク時のオプションを推測しようとする場合もあります。</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">ColdFire ハードウェアの除算および剰余命令を生成します (生成しない)。もし</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">GP相対アクセスを生成します（生成しません）。次の &lt;var&gt;option&lt;/var&gt; 名が認識されます。</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">MIPS16 コードを生成する(生成しない)。GCC が MIPS32 または MIPS64 アーキテクチャをターゲットにしている場合、MIPS16e ASE を使用します。</target>
        </trans-unit>
        <trans-unit id="7322f1cb41e6457edd178c659eebf99bfcbafd3c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) addressing modes using prefixed load and store instructions when the option</source>
          <target state="translated">オプションを指定した場合、プレフィックス付きのロード/ストア命令を使用してアドレッシングモードを生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">完全に位置に依存せず、共有ライブラリにリンクできるコードを生成します(生成しない)。このオプションは</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">SVR4スタイルのダイナミックオブジェクトに適したコードを生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">&lt;em&gt;ベースアドレス&lt;/em&gt;を使用するコードを生成します（生成しません）。ベースアドレスを使用すると、グローバルレジスタに設定する定数の要求（アセンブラーとリンカーによって処理される）が自動的に生成されます。レジスターは、レジスターに保持されている値から0から255の範囲内の1つ以上のベース・アドレス要求に使用されます。一般に、コードは短くて高速になりますが、アドレス指定できるさまざまなデータ項目の数は限られています。つまり、多くの静的データを使用するプログラムでは、</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">関数ポインターが関数アドレス、TOC値を与える3ワード記述子を指すAIXおよび64ビットLinuxシステムでポインターを介して呼び出すときに、静的チェーンレジスタ（ &lt;code&gt;r11&lt;/code&gt; ）をロードするコードを生成（生成しない）します。レジスタ &lt;code&gt;r2&lt;/code&gt; にロードされる静的チェーン値とレジスタ &lt;code&gt;r11&lt;/code&gt; にロードされる静的チェーン値。の</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">古いバージョンのGCCとの互換性のために、最大64ビットのアラインメントで構造体パラメータを渡すためのコードを生成します(生成しない)。</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">AIXおよび64ビットLinuxシステム上で関数がポインタを介して呼び出す場合、関数プロローグ内の予約スタック位置にTOC値を保存するためのコードを生成します(生成しません)。TOC値がプロローグに保存されていない場合は、ポインタを介して呼び出す直前に保存されます。このような場合には</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">microMIPS コードを生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="3996f10552777a166b0e49d921b421c578c5e2f7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) pc-relative addressing when the option</source>
          <target state="translated">オプションが指定されている場合は、pc-relative addressingを生成します(生成しません)。</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">ときに &lt;code&gt;friz&lt;/code&gt; 命令を生成します（生成しません）。</target>
        </trans-unit>
        <trans-unit id="59dec4f42737e1a4ee2b102faf59b8bbec911145" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the MMA instructions when the option</source>
          <target state="translated">オプションを指定した場合は、MMA命令を生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">サブルーチン呼び出しを行うために &lt;code&gt;bras&lt;/code&gt; 命令を使用してコードを生成します（または生成しません）。これは、実行可能ファイルの合計サイズが64kを超えない場合にのみ確実に機能します。デフォルトでは、代わりに &lt;code&gt;basr&lt;/code&gt; 命令を使用しますが、この制限はありません。</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">&lt;code&gt;mvcle&lt;/code&gt; 命令を使用してブロック移動を実行するコードを生成します（または生成しません）。いつ</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">生成する（しない） '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">揮発性asmステートメントの直前と直後にストップビットを生成します（または生成しません）。</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">GNUアセンブラー用のコードを生成します（または生成しません）。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">GNUリンカーのコードを生成します（または生成しません）。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">16ビット命令を生成します。</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">HP-UX 10リンカーで必要になる場合がある3命令ロードおよびストアシーケンスを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">32x16ビットの乗算・積算命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">GDBインデックスへの変換に適した形式で &lt;code&gt;.debug_pubnames&lt;/code&gt; および &lt;code&gt;.debug_pubtypes&lt;/code&gt; セクションを生成します。このオプションは、GDBインデックスバージョン7を生成できるリンカーでのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">&lt;code&gt;mul64&lt;/code&gt; および &lt;code&gt;mulu64&lt;/code&gt; 命令を生成します。のみ有効</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 命令を生成します。これはデフォルトです</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">各関数の最初に &lt;var&gt;N&lt;/var&gt; 個の NOP を生成し、関数のエントリポイントを &lt;var&gt;M&lt;/var&gt; 番目のNOPの前に配置します。場合は &lt;var&gt;M&lt;/var&gt; がに省略されている、それはデフォルトで &lt;code&gt;0&lt;/code&gt; ちょうど最初のNOPのアドレスへの関数エントリポイントそう。 NOP命令は、コードセグメントが書き込み可能であれば、実行時に任意のインストルメンテーションにパッチを適用するために使用できる余分なスペースを予約します。スペースの量は、NOPの数を介して間接的に制御できます。使用されるNOP命令は、内部GCCバックエンドインターフェイス &lt;code&gt;gen_nop&lt;/code&gt; によって発行される命令に対応しています。この動作はターゲット固有であり、アーキテクチャバリアントや他のコンパイルオプションに依存する場合もあります。</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">値で渡される最大の構造体があれば、それを記述したCヘッダを生成します。</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; および &lt;code&gt;.debug_pubtypes&lt;/code&gt; セクションを生成します。</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">アトミック組み込み関数のGNU / Linux互換gUSAソフトウェアアトミックシーケンスを生成します。生成されたアトミックシーケンスは、システムの割り込み/例外処理コードからの追加サポートを必要とし、SH3 *およびSH4 *シングルコアシステムにのみ適しています。ターゲットが &lt;code&gt;sh*-*-linux*&lt;/code&gt; およびSH3 *またはSH4 *の場合、このオプションはデフォルトで有効になります。ターゲットがSH4Aの場合、このオプションは、ハードウェアアトミック命令 &lt;code&gt;movli.l&lt;/code&gt; および &lt;code&gt;movco.l&lt;/code&gt; を部分的に利用して、より効率的なコードを作成します。</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">プログラム内のすべてのデータ・オブジェクトに対して GP 相対アクセスを生成します。このオプションを使用する場合、プログラムのデータセグメントとBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカースクリプトを使用してグローバルポインタのアドレス指定可能な範囲内に割り当てる必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
