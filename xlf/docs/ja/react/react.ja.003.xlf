<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="42274756b2dc2c17eaeb7f294f21deef9e594667" translate="yes" xml:space="preserve">
          <source>Race Conditions with useEffect</source>
          <target state="translated">useEffectを使用したレース条件</target>
        </trans-unit>
        <trans-unit id="7a22b192ac2fa53d431f80c3ed1ab58049c5282b" translate="yes" xml:space="preserve">
          <source>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the &lt;code&gt;useEffect&lt;/code&gt; Hook or in class lifecycle methods like &lt;code&gt;componentDidUpdate&lt;/code&gt; often leads to them. Suspense can help here, too &amp;mdash; let&amp;rsquo;s see how.</source>
          <target state="translated">競合状態は、コードが実行される順序についての誤った仮定が原因で発生するバグです。 &lt;code&gt;useEffect&lt;/code&gt; フック、または &lt;code&gt;componentDidUpdate&lt;/code&gt; などのクラスライフサイクルメソッドでデータをフェッチすると、多くの場合、それらが発生します。ここでもサスペンスが役立ちます&amp;mdash;方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="14755c296af9379808222382bdd6b5de345159dc" translate="yes" xml:space="preserve">
          <source>Rarely Used Lifecycle Methods</source>
          <target state="translated">稀に使用されるライフサイクル手法</target>
        </trans-unit>
        <trans-unit id="26dd7fe02a64876676c6cbd9aa8708f0a20b47f9" translate="yes" xml:space="preserve">
          <source>Re-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.</source>
          <target state="translated">新しいルート要素でインメモリツリーを再レンダーします。これは、ルートでのReact更新をシミュレートします。新しい要素が前の要素と同じ型とキーを持っている場合は、ツリーが更新されますが、そうでない場合は新しいツリーを再マウントします。</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="cec80c2bc8202e23af151e7f74a7ef7ace217cd9" translate="yes" xml:space="preserve">
          <source>React 15 included a very limited support for error boundaries under a different method name: &lt;code&gt;unstable_handleError&lt;/code&gt;. This method no longer works, and you will need to change it to &lt;code&gt;componentDidCatch&lt;/code&gt; in your code starting from the first 16 beta release.</source>
          <target state="translated">React 15には、異なるメソッド名の下でのエラー境界の非常に限られたサポートが含まれていました： &lt;code&gt;unstable_handleError&lt;/code&gt; 。このメソッドは機能しなくなったため、最初の16ベータリリース以降、コード内で &lt;code&gt;componentDidCatch&lt;/code&gt; に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d738f325e7c19b6858708f27583b05cb0428fc2" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">React 16は、コレクションタイプ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Setに&lt;/a&gt;依存します。これらをネイティブで提供していない可能性のある古いブラウザーやデバイス（IE &amp;lt;11など）や、準拠していない実装（IE 11など）をサポートしている場合は、&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel&lt;/a&gt;などのバンドルアプリケーションにグローバルポリフィルを含めることを検討してください。-ポリフィル。</target>
        </trans-unit>
        <trans-unit id="74986fa4e985ed82adb453f97ce762c40df9fea1" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;.</source>
          <target state="translated">React 16は、コレクションタイプ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;によって異なります。これらをネイティブに提供していない可能性のある古いブラウザーやデバイス（IE &amp;lt;11など）または非準拠の実装（IE 11など）をサポートしている場合は、&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;などのバンドルアプリケーションにグローバルポリフィルを含めることを検討してください。</target>
        </trans-unit>
        <trans-unit id="1051bec19cd5874a397897a7f06cc6437c451c36" translate="yes" xml:space="preserve">
          <source>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</source>
          <target state="translated">React 16 は、アプリケーションが誤ってエラーを飲み込んでしまった場合でも、レンダリング中に発生したすべてのエラーを開発中のコンソールに表示します。エラーメッセージと JavaScript スタックに加えて、コンポーネントスタックのトレースも提供します。これで、コンポーネントツリーのどこで障害が発生したかを正確に知ることができます。</target>
        </trans-unit>
        <trans-unit id="30e0407bcbcc67abd7c79d5c3bd2fcd47ad42dd9" translate="yes" xml:space="preserve">
          <source>React 16.3 added a third option that offers the convenience of a string ref without any of the downsides:</source>
          <target state="translated">React 16.3では、デメリットのない文字列参照の利便性を提供する3つ目のオプションが追加されました。</target>
        </trans-unit>
        <trans-unit id="3c32dfc45304c45a68c84f0c0ee4c4f05460c24f" translate="yes" xml:space="preserve">
          <source>React 16.6 added a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; component that lets you &amp;ldquo;wait&amp;rdquo; for some code to load and declaratively specify a loading state (like a spinner) while we&amp;rsquo;re waiting:</source>
          <target state="translated">React 16.6に &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; コンポーネントが追加されました。これにより、コードが読み込まれるのを「待ち」、待機中に読み込み状態（スピナーなど）を宣言的に指定できます。</target>
        </trans-unit>
        <trans-unit id="b645cea94d9f5a02a027aeb84445527c67977cf7" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0はフックをサポートする最初のリリースです。アップグレードするときは、React DOMを含むすべてのパッケージを忘れずに更新してください。React Nativeは&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;、React Nativeの0.59リリース&lt;/a&gt;以降、フックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="e30a4592694f3d8efb2c8c6a713f826f50e4e4ee" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0は、フックをサポートする最初のリリースです。アップグレードするときは、ReactDOMを含むすべてのパッケージを更新することを忘れないでください。React Nativeは&lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;、React Nativeの0.59リリース&lt;/a&gt;以降、フックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a2fa57c98aa2ff66a34e3804ba4afdbf43f949c" translate="yes" xml:space="preserve">
          <source>React &lt;a href=&quot;react-without-jsx&quot;&gt;doesn&amp;rsquo;t require&lt;/a&gt; using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</source>
          <target state="translated">React &lt;a href=&quot;react-without-jsx&quot;&gt;は&lt;/a&gt; JSXを使用する必要はありませんが、JavaScriptコード内でUIを操作する際の視覚的な補助として、JSXが役立つと感じています。また、Reactがより有用なエラーおよび警告メッセージを表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="e56b4ec7d4044adf40d8ea846a837d5e5d0e2ec1" translate="yes" xml:space="preserve">
          <source>React DOM</source>
          <target state="translated">リアクトDOM</target>
        </trans-unit>
        <trans-unit id="0e17312bf427154aa9521cc18565e992f954d046" translate="yes" xml:space="preserve">
          <source>React DOM Server</source>
          <target state="translated">React DOM サーバー</target>
        </trans-unit>
        <trans-unit id="6783695eda495767c874d2c12b708f12b9eb5c68" translate="yes" xml:space="preserve">
          <source>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</source>
          <target state="translated">React DOMは、要素とその子を前のものと比較し、DOMを目的の状態にするために必要なDOMの更新のみを適用します。</target>
        </trans-unit>
        <trans-unit id="c0f543b7e06f16286089bf4be437499e1b43b727" translate="yes" xml:space="preserve">
          <source>React DOM efficiently updates the DOM to match &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">React DOMは、 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; に一致するようにDOMを効率的に更新します。</target>
        </trans-unit>
        <trans-unit id="9fdeb7ff15e5768ee7e11ab66cd7913eac488847" translate="yes" xml:space="preserve">
          <source>React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</source>
          <target state="translated">React DOMでは、沸騰した評定値と希望する入力値を一致させるようにDOMを更新しています。先ほど編集した入力は現在の値を受け取り、他の入力は変換後の温度に更新されます。</target>
        </trans-unit>
        <trans-unit id="1b3e9e3b704e86ac0ae2261ed5ae0110bb475463" translate="yes" xml:space="preserve">
          <source>React DOM uses camelCase property naming convention instead of HTML attribute names. For example, &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;code&gt;tabIndex&lt;/code&gt; in JSX. The attribute &lt;code&gt;class&lt;/code&gt; is also written as &lt;code&gt;className&lt;/code&gt; since &lt;code&gt;class&lt;/code&gt; is a reserved word in JavaScript:</source>
          <target state="translated">React DOMは、HTML属性名の代わりにcamelCaseプロパティの命名規則を使用します。たとえば、JSX では &lt;code&gt;tabindex&lt;/code&gt; は &lt;code&gt;tabIndex&lt;/code&gt; になります。属性 &lt;code&gt;class&lt;/code&gt; とも書かれている &lt;code&gt;className&lt;/code&gt; のため、 &lt;code&gt;class&lt;/code&gt; JavaScriptで予約語です。</target>
        </trans-unit>
        <trans-unit id="64f7152b69ea8b7e6f11fc24d5c27c7549c6acd1" translate="yes" xml:space="preserve">
          <source>React Documentation</source>
          <target state="translated">React ドキュメント</target>
        </trans-unit>
        <trans-unit id="3a01dc41ed1fa68614175afe8e165764d9609ab0" translate="yes" xml:space="preserve">
          <source>React Must Be in Scope</source>
          <target state="translated">Reactはスコープ内になければならない</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">リアクトネイティブ</target>
        </trans-unit>
        <trans-unit id="a2c6dfc0e1dfdf3f794b802a1ba06278b93a1b13" translate="yes" xml:space="preserve">
          <source>React Only Updates What&amp;rsquo;s Necessary</source>
          <target state="translated">必要なものだけを更新して反応する</target>
        </trans-unit>
        <trans-unit id="3633a811906ebb40f86bdd77c315e1e2bde36321" translate="yes" xml:space="preserve">
          <source>React Redux since v7.1.0 &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;supports Hooks API&lt;/a&gt; and exposes hooks like &lt;code&gt;useDispatch&lt;/code&gt; or &lt;code&gt;useSelector&lt;/code&gt;.</source>
          <target state="translated">v7.1.0以降のReact Redux &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;はフックAPI&lt;/a&gt;をサポートし、 &lt;code&gt;useDispatch&lt;/code&gt; や &lt;code&gt;useSelector&lt;/code&gt; などのフックを公開しています。</target>
        </trans-unit>
        <trans-unit id="3bb3fe34bf0fbac0db48c2c52246f7bf4643b58d" translate="yes" xml:space="preserve">
          <source>React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;supports hooks&lt;/a&gt; since v5.1.</source>
          <target state="translated">React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;は&lt;/a&gt; v5.1以降のフックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="db30dab9afce5ee17ad60f6815d45c7d2775403c" translate="yes" xml:space="preserve">
          <source>React Shallow Renderer</source>
          <target state="translated">Reactシャローレンダラー</target>
        </trans-unit>
        <trans-unit id="59f752bd2488cbb706a191bae6c25ec360c9ae78" translate="yes" xml:space="preserve">
          <source>React Test Renderer</source>
          <target state="translated">Reactテストレンダラ</target>
        </trans-unit>
        <trans-unit id="493a1a450ae702c6d46a164382378d365c88d431" translate="yes" xml:space="preserve">
          <source>React Testing Library offers a &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;more concise helper&lt;/a&gt; for firing events.</source>
          <target state="translated">React Testing Libraryは、イベントを&lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;起動する&lt;/a&gt;ためのより簡潔なヘルパーを提供します。</target>
        </trans-unit>
        <trans-unit id="a3a37522e503e9a2cee5bb38180398e2a23e1f1f" translate="yes" xml:space="preserve">
          <source>React Top-Level API</source>
          <target state="translated">ReactトップレベルAPI</target>
        </trans-unit>
        <trans-unit id="8e60d7618dece37120d3987205a0d2168962460f" translate="yes" xml:space="preserve">
          <source>React Without ES6</source>
          <target state="translated">ES6なしでリアクト</target>
        </trans-unit>
        <trans-unit id="cd5884fb1f8e40d0ef6cbe86d6584a46690762e1" translate="yes" xml:space="preserve">
          <source>React Without JSX</source>
          <target state="translated">JSXなしでReactする</target>
        </trans-unit>
        <trans-unit id="9fe2f9ba8b44464b4bfefd199f9bc13307ee3332" translate="yes" xml:space="preserve">
          <source>React also depends on &lt;code&gt;requestAnimationFrame&lt;/code&gt; (even in test environments).</source>
          <target state="translated">Reactは &lt;code&gt;requestAnimationFrame&lt;/code&gt; にも依存します（テスト環境でも）。</target>
        </trans-unit>
        <trans-unit id="7d8f2b9666834dcad7e288b25fd8480664eaad61" translate="yes" xml:space="preserve">
          <source>React also supports another way to set refs called &amp;ldquo;callback refs&amp;rdquo;, which gives more fine-grain control over when refs are set and unset.</source>
          <target state="translated">Reactは、「コールバック参照」と呼ばれる参照を設定する別の方法もサポートしています。これにより、参照の設定と設定解除をより細かく制御できます。</target>
        </trans-unit>
        <trans-unit id="10225c998465dfe979466a99502e0be87e759457" translate="yes" xml:space="preserve">
          <source>React and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</source>
          <target state="translated">Reactおよび&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Webコンポーネント&lt;/a&gt;は、さまざまな問題を解決するために構築されています。Webコンポーネントは再利用可能なコンポーネントの強力なカプセル化を提供し、ReactはDOMとデータの同期を維持する宣言型ライブラリを提供します。2つの目標は相補的です。開発者は、WebコンポーネントでReactを使用するか、ReactでWebコンポーネントを使用するか、またはその両方を自由に行えます。</target>
        </trans-unit>
        <trans-unit id="27082daf4244e21a91a723f26657721dc905d29e" translate="yes" xml:space="preserve">
          <source>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a &amp;ldquo;virtual DOM&amp;rdquo;, but it works the same way on React Native.</source>
          <target state="translated">Reactは、レンダリングされたUIの内部表現を構築および維持します。これには、コンポーネントから返すReact要素が含まれています。この表現により、JavaScriptオブジェクトの操作よりも遅くなる可能性があるため、ReactはDOMノードの作成や、必要以上に既存のノードへのアクセスを回避できます。「仮想DOM」と呼ばれることもありますが、React Nativeでも同じように機能します。</target>
        </trans-unit>
        <trans-unit id="610b64665a6a2f5e728c19e6eca03a8b39cdcf07" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Calculator&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</source>
          <target state="translated">Reactは &lt;code&gt;Calculator&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出して、UIの外観を学習します。両方の入力の値は、現在の温度とアクティブなスケールに基づいて再計算されます。ここで温度変換を行います。</target>
        </trans-unit>
        <trans-unit id="ba853d2a17e24f0bd22d89450b9557d4a2c11971" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Welcome&lt;/code&gt; component with &lt;code&gt;{name: 'Sara'}&lt;/code&gt; as the props.</source>
          <target state="translated">Reactは &lt;code&gt;{name: 'Sara'}&lt;/code&gt; を小道具として &lt;code&gt;Welcome&lt;/code&gt; コンポーネントを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d6f2ebfc937521d2470061f7e3d9cde73833393e" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; method of the &lt;code&gt;BoilingVerdict&lt;/code&gt; component, passing the temperature in Celsius as its props.</source>
          <target state="translated">Reactは &lt;code&gt;BoilingVerdict&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出し、摂氏の温度を小道具として渡します。</target>
        </trans-unit>
        <trans-unit id="f3922365ae8f20c0cd2b94600d6dd96e8199f37c" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; methods of the individual &lt;code&gt;TemperatureInput&lt;/code&gt; components with their new props specified by the &lt;code&gt;Calculator&lt;/code&gt;. It learns what their UI should look like.</source>
          <target state="translated">Reactは、 &lt;code&gt;Calculator&lt;/code&gt; で指定された新しいプロパティを使用して、個々の &lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出します。UIの外観を学習します。</target>
        </trans-unit>
        <trans-unit id="36fdfacce7eedd6661f907c10f0f4ea9af876fce" translate="yes" xml:space="preserve">
          <source>React calls the function specified as &lt;code&gt;onChange&lt;/code&gt; on the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In our case, this is the &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component.</source>
          <target state="translated">Reactは、DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; で &lt;code&gt;onChange&lt;/code&gt; として指定された関数を呼び出します。私たちの場合、これは &lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの &lt;code&gt;handleChange&lt;/code&gt; メソッドです。</target>
        </trans-unit>
        <trans-unit id="bd8b2d2111896cb2314cfe1f0bde6a55efe40119" translate="yes" xml:space="preserve">
          <source>React can be embedded into other applications thanks to the flexibility of &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; の&lt;/a&gt;柔軟性により、Reactを他のアプリケーションに埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="e1330ed30fca80f90b213d9b6f69f3e0df6ecab7" translate="yes" xml:space="preserve">
          <source>React can be used in any web application. It can be embedded in other applications and, with a little care, other applications can be embedded in React. This guide will examine some of the more common use cases, focusing on integration with &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;, but the same ideas can be applied to integrating components with any existing code.</source>
          <target state="translated">ReactはどのWebアプリケーションでも使用できます。他のアプリケーションに組み込むことができ、少し注意して、他のアプリケーションをReactに組み込むことができます。このガイドでは、&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;と&lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;との統合に焦点を当てて、より一般的な使用例をいくつか調べますが、コンポーネントを既存のコードと統合する場合にも同じ考え方を適用できます。</target>
        </trans-unit>
        <trans-unit id="d37e463c6f9b2a55b2880cfa9eafdf5e114306ed" translate="yes" xml:space="preserve">
          <source>React can be used to power animations. See &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; and &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; or &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt;, for example.</source>
          <target state="translated">Reactを使用してアニメーションを強化できます。たとえば、&lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt;および&lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt;または&lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Springを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c793e68bb1fac249aba0ce5f3bec7e5d7023c434" translate="yes" xml:space="preserve">
          <source>React community&amp;rsquo;s experiments with render prop APIs, including &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;の&lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;を含むレンダープロップAPIを使用したReactコミュニティの実験。</target>
        </trans-unit>
        <trans-unit id="27be082454b7d8bc7b1e13ab663caeb1f2c60981" translate="yes" xml:space="preserve">
          <source>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</source>
          <target state="translated">React コンポーネントは、ページにレンダリングされる React 要素を返す、再利用可能な小さなコードです。Reactコンポーネントの最も単純なバージョンは、React要素を返すプレーンなJavaScript関数です。</target>
        </trans-unit>
        <trans-unit id="48861e38df56656ab830494ad258a4d6191d07f5" translate="yes" xml:space="preserve">
          <source>React components can also be defined as functions which can be wrapped:</source>
          <target state="translated">Reactコンポーネントは、ラップできる関数として定義することもできます。</target>
        </trans-unit>
        <trans-unit id="e4cc5817b2558aba649764feaed76c372dd8b626" translate="yes" xml:space="preserve">
          <source>React components have their own &amp;ldquo;lifecycle&amp;rdquo;. They may receive props or update state at any point in time. However, each asynchronous request &lt;em&gt;also&lt;/em&gt; has its own &amp;ldquo;lifecycle&amp;rdquo;. It starts when we kick it off, and finishes when we get a response. The difficulty we&amp;rsquo;re experiencing is &amp;ldquo;synchronizing&amp;rdquo; several processes in time that affect each other. This is hard to think about.</source>
          <target state="translated">Reactコンポーネントには独自の「ライフサイクル」があります。彼らはいつでも小道具を受け取ったり状態を更新したりできます。ただし、各非同期リクエストに&lt;em&gt;も&lt;/em&gt;独自の「ライフサイクル」があります。それは私たちがそれを開始したときに始まり、私たちが応答を得たときに終了します。私たちが直面している問題は、互いに影響を与えるいくつかのプロセスを時間内に「同期化」することです。これは考えるのが難しいです。</target>
        </trans-unit>
        <trans-unit id="4222b5a8657725e4a00728011e55a70511e28796" translate="yes" xml:space="preserve">
          <source>React components hide their implementation details, including their rendered output. Other components using &lt;code&gt;FancyButton&lt;/code&gt;&lt;strong&gt;usually will not need to&lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;obtain a ref&lt;/a&gt; to the inner &lt;code&gt;button&lt;/code&gt; DOM element. This is good because it prevents components from relying on each other&amp;rsquo;s DOM structure too much.</source>
          <target state="translated">Reactコンポーネントは、レンダリングされた出力を含め、実装の詳細を隠します。 &lt;code&gt;FancyButton&lt;/code&gt; を使用する他のコンポーネント&lt;strong&gt;は通常&lt;/strong&gt;、内部 &lt;code&gt;button&lt;/code&gt; DOM要素への&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;を取得する&lt;strong&gt;必要はありません&lt;/strong&gt;。これは、コンポーネントが互いのDOM構造に過度に依存するのを防ぐため、優れています。</target>
        </trans-unit>
        <trans-unit id="5817ef7548b0234e3521fa7650bb8ea6c27ada2e" translate="yes" xml:space="preserve">
          <source>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing &lt;code&gt;React.Component&lt;/code&gt; or &lt;code&gt;React.PureComponent&lt;/code&gt;.</source>
          <target state="translated">Reactコンポーネントを使用すると、UIを独立した再利用可能な部分に分割し、各部分を分離して考えることができます。Reactコンポーネントは、 &lt;code&gt;React.Component&lt;/code&gt; または &lt;code&gt;React.PureComponent&lt;/code&gt; をサブクラス化することによって定義できます。</target>
        </trans-unit>
        <trans-unit id="ca8d82c06b82b483efb7cfed08df669ddf86929f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t call &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; with initial props during &lt;a href=&quot;#mounting&quot;&gt;mounting&lt;/a&gt;. It only calls this method if some of component&amp;rsquo;s props may update. Calling &lt;code&gt;this.setState()&lt;/code&gt; generally doesn&amp;rsquo;t trigger &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;.</source>
          <target state="translated">Reactは、&lt;a href=&quot;#mounting&quot;&gt;マウント&lt;/a&gt;中に初期プロップで &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; を呼び出しません。コンポーネントの小道具の一部が更新される場合にのみ、このメソッドを呼び出します。呼び出し &lt;code&gt;this.setState()&lt;/code&gt; 、一般的にトリガされません &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca31c5026bd08138666663526caeedbe15b5ea02" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t force you to use the ES6 class syntax. If you prefer to avoid it, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module or a similar custom abstraction instead. Take a look at &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; to learn more.</source>
          <target state="translated">Reactは、ES6クラス構文を使用することを強制しません。回避したい場合は、代わりに &lt;code&gt;create-react-class&lt;/code&gt; モジュールまたは同様のカスタム抽象化を使用できます。詳細については、&lt;a href=&quot;react-without-es6&quot;&gt;ES6&lt;/a&gt;を使用せずにReactを使用するをご覧ください。</target>
        </trans-unit>
        <trans-unit id="74b56919404ce18c573bf25676a77e3c0c3ec215" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.</source>
          <target state="translated">Reactは、ファイルをフォルダーに配置する方法について意見を持っていません。とはいえ、エコシステムで人気のあるいくつかの一般的なアプローチについて検討する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="65aea3f2a5c31b29c9426cd1a03d900e3079061c" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don&amp;rsquo;t happen during rendering. So if they throw, React still knows what to display on the screen.</source>
          <target state="translated">Reactは、イベントハンドラーのエラーから回復するためにエラー境界を必要としません。renderメソッドやライフサイクルメソッドとは異なり、イベントハンドラーはレンダリング中には発生しません。したがって、それらがスローされた場合でも、Reactは画面に何を表示するかを認識しています。</target>
        </trans-unit>
        <trans-unit id="8fd4db2f190bce0d1cd19887d508e28c6fb7d62f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t offer a way to &amp;ldquo;attach&amp;rdquo; reusable behavior to a component (for example, connecting it to a store). If you&amp;rsquo;ve worked with React for a while, you may be familiar with patterns like &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a &amp;ldquo;wrapper hell&amp;rdquo; of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;filter them out in DevTools&lt;/a&gt;, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.</source>
          <target state="translated">Reactは、再利用可能な動作をコンポーネントに「アタッチ」する方法（たとえば、コンポーネントをストアに接続するなど）を提供していません。 Reactをしばらく使用していた場合は、これを解決しようとする&lt;a href=&quot;render-props&quot;&gt;レンダープロップ&lt;/a&gt;や&lt;a href=&quot;higher-order-components&quot;&gt;高次コンポーネント&lt;/a&gt;などのパターンに精通している可能性があります。ただし、これらのパターンでは、コンポーネントを使用するときにコンポーネントを再構築する必要があります。これにより、コードが扱いにくくなり、コードの追跡が難しくなる場合があります。 React DevToolsで典型的なReactアプリケーションを見ると、プロバイダー、コンシューマー、高次コンポーネント、レンダープロップ、およびその他の抽象化のレイヤーに囲まれたコンポーネントの「ラッパー地獄」が見つかるでしょう。&lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;DevTools&lt;/a&gt;でそれらを除外することもできますが、これは根本的な問題を示しています。Reactはステートフルロジックを共有するためのより優れたプリミティブを必要としています。</target>
        </trans-unit>
        <trans-unit id="f78ca1328cbe2529b63f5cb261c75fa5b40138a1" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t use the &lt;code&gt;state = initialState&lt;/code&gt; argument convention popularized by Redux. The initial value sometimes needs to depend on props and so is specified from the Hook call instead. If you feel strongly about this, you can call &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; to emulate the Redux behavior, but it&amp;rsquo;s not encouraged.</source>
          <target state="translated">Reactは、Reduxによって普及した &lt;code&gt;state = initialState&lt;/code&gt; 引数規則を使用しません。初期値は小道具に依存する必要がある場合があるため、代わりにフック呼び出しから指定されます。これについて強く感じる場合は、 &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; を呼び出してReduxの動作をエミュレートできますが、お勧めしません。</target>
        </trans-unit>
        <trans-unit id="d83294fcb3556b3e4c12f42b28d13fbaa61565e3" translate="yes" xml:space="preserve">
          <source>React elements are &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;immutable&lt;/a&gt;. Once you create an element, you can&amp;rsquo;t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</source>
          <target state="translated">React要素は&lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;不変&lt;/a&gt;です。要素を作成すると、その子や属性を変更することはできません。要素は、映画の1つのフレームのようなものです。特定の時点でのUIを表します。</target>
        </trans-unit>
        <trans-unit id="72d7e53a8e0f9d5ea79b7f65c786e10e05c2fc30" translate="yes" xml:space="preserve">
          <source>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. An element describes what you want to see on the screen. React elements are immutable.</source>
          <target state="translated">React要素は、Reactアプリケーションのビルディングブロックです。要素を、より広く知られている「コンポーネント」の概念と混同するかもしれません。要素は、画面に表示したいものを記述します。React要素は不変です。</target>
        </trans-unit>
        <trans-unit id="6524f58f9d8f8ab1fca2ad781736505d87a9d6ca" translate="yes" xml:space="preserve">
          <source>React elements like &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; are just objects, so you can pass them as props like any other data. This approach may remind you of &amp;ldquo;slots&amp;rdquo; in other libraries but there are no limitations on what you can pass as props in React.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; などのReact要素は単なるオブジェクトなので、他のデータと同様に小道具として渡すことができます。このアプローチは他のライブラリの「スロット」を思い出させるかもしれませんが、Reactで小道具として渡すことができるものに制限はありません。</target>
        </trans-unit>
        <trans-unit id="d783a77ced1d87ae35cd28616b7b8dde4c0feec8" translate="yes" xml:space="preserve">
          <source>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</source>
          <target state="translated">React は、レンダリングロジックが他の UI ロジックと本質的に結合しているという事実を受け入れています:イベントがどのように処理されるか、時間の経過とともに状態がどのように変化するか、表示のためにデータがどのように準備されるか。</target>
        </trans-unit>
        <trans-unit id="71aa7bf3c2141f944fb5d607ee0a640c055cd5e3" translate="yes" xml:space="preserve">
          <source>React event handlers are named using camelCase, rather than lowercase.</source>
          <target state="translated">Reactのイベントハンドラの名前は小文字ではなく、キャメルケースを使用しています。</target>
        </trans-unit>
        <trans-unit id="aaaede23e33f54df8554d19c52716021dc6d0ad7" translate="yes" xml:space="preserve">
          <source>React events are named using camelCase, rather than lowercase.</source>
          <target state="translated">Reactイベントの名前は小文字ではなく、キャメルケースを使用します。</target>
        </trans-unit>
        <trans-unit id="d81cbd9c023137339681f3ecb86a4870cf58d1f3" translate="yes" xml:space="preserve">
          <source>React events will be grouped under the &lt;strong&gt;User Timing&lt;/strong&gt; label.</source>
          <target state="translated">Reactイベントは&lt;strong&gt;User Timing&lt;/strong&gt;ラベルの下にグループ化され&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9a9f448560435e23fa1b8b20e5ca27d1ae3d080b" translate="yes" xml:space="preserve">
          <source>React expects that the rendered content is identical between the server and the client. It can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.</source>
          <target state="translated">React は、レンダリングされたコンテンツがサーバーとクライアントの間で同一であることを期待しています。テキストコンテンツの違いをパッチで修正することはできますが、ミスマッチはバグとして扱い、修正する必要があります。開発モードでは、Reactはハイドレーション時にミスマッチを警告します。属性の違いがミスマッチの場合にパッチアップされる保証はありません。ほとんどのアプリではミスマッチは稀であり、そのためすべてのマークアップを検証するのは法外なコストがかかるため、これはパフォーマンス上の理由から重要です。</target>
        </trans-unit>
        <trans-unit id="688c4519446fdd44f425e4ac67a8e7c31b228818" translate="yes" xml:space="preserve">
          <source>React follows &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning (semver)&lt;/a&gt; principles.</source>
          <target state="translated">Reactは&lt;a href=&quot;https://semver.org/&quot;&gt;セマンティックバージョニング（サーバー）の&lt;/a&gt;原則に従います。</target>
        </trans-unit>
        <trans-unit id="2ace8a8f59843973f666f085ceaf962fea60d36e" translate="yes" xml:space="preserve">
          <source>React for Beginners</source>
          <target state="translated">初心者のためのReact</target>
        </trans-unit>
        <trans-unit id="0c447ed07bb40a48e19866c8e49bff0aaf61e27b" translate="yes" xml:space="preserve">
          <source>React for Designers</source>
          <target state="translated">デザイナーのためのReact</target>
        </trans-unit>
        <trans-unit id="a3064a3146d7f8947ad21494bc1745e87bfe69d8" translate="yes" xml:space="preserve">
          <source>React fully supports building accessible websites, often by using standard HTML techniques.</source>
          <target state="translated">React は、標準的な HTML テクニックを使用して、アクセシブルなウェブサイトを構築することを完全にサポートしています。</target>
        </trans-unit>
        <trans-unit id="0931dcf2a1d7800c25ee9a956b9c2839a169eadd" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;dispatch&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">Reactは、 &lt;code&gt;dispatch&lt;/code&gt; 関数のIDが安定していて、再レンダリングしても変更されないことを保証します。これが、 &lt;code&gt;useEffect&lt;/code&gt; または &lt;code&gt;useCallback&lt;/code&gt; 依存関係リストから省略しても安全な理由です。</target>
        </trans-unit>
        <trans-unit id="760079d64e4b1bb1d3f5af076b4f911126e07d29" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;setState&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">Reactは、 &lt;code&gt;setState&lt;/code&gt; 関数のIDが安定していて、再レンダリングしても変更されないことを保証します。これが、 &lt;code&gt;useEffect&lt;/code&gt; または &lt;code&gt;useCallback&lt;/code&gt; 依存関係リストから省略しても安全な理由です。</target>
        </trans-unit>
        <trans-unit id="52c2ef58675954a462a2178998aa8077eb12b98d" translate="yes" xml:space="preserve">
          <source>React guarantees that whenever we look at these components on the screen, they will reflect data from the same &lt;code&gt;user&lt;/code&gt;. If a different &lt;code&gt;user&lt;/code&gt; is passed down because of a state update, you would see them changing together. You can&amp;rsquo;t ever record a screen and find a frame where they would show values from different &lt;code&gt;user&lt;/code&gt;s. (If you ever run into a case like this, file a bug!)</source>
          <target state="translated">Reactは、これらのコンポーネントを画面で見るたびに、同じ &lt;code&gt;user&lt;/code&gt; からのデータを反映することを保証します。状態が更新されたために別の &lt;code&gt;user&lt;/code&gt; が渡された場合、それらが一緒に変化するのがわかります。画面を記録して、さまざまな &lt;code&gt;user&lt;/code&gt; の値を表示するフレームを見つけることはできません。（このようなケースに遭遇した場合は、バグを報告してください！）</target>
        </trans-unit>
        <trans-unit id="cdc83e6519b0f0d8e4abbcdc04e6a6bc27050c9d" translate="yes" xml:space="preserve">
          <source>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</source>
          <target state="translated">Reactには強力なコンポジションモデルがあり、コンポーネント間でコードを再利用するために継承ではなくコンポジションを使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="df3b73a4c521d8e8577e5382082dcb38c98839b5" translate="yes" xml:space="preserve">
          <source>React has always provided a JavaScript-centric API to the DOM. Since React components often take both custom and DOM-related props, React uses the &lt;code&gt;camelCase&lt;/code&gt; convention just like the DOM APIs:</source>
          <target state="translated">Reactは常にJavaScript中心のAPIをDOMに提供してきました。ReactコンポーネントはカスタムとDOM関連の両方のプロップを受け取ることが多いので、ReactはDOM APIと同じように &lt;code&gt;camelCase&lt;/code&gt; 規則を使用します。</target>
        </trans-unit>
        <trans-unit id="6034f047f205ffc8dc240f7e19af8c137e1310ea" translate="yes" xml:space="preserve">
          <source>React has an API to update context, but it is fundamentally broken and you should not use it.</source>
          <target state="translated">Reactにはコンテキストを更新するAPIがありますが、根本的に壊れているので使ってはいけません。</target>
        </trans-unit>
        <trans-unit id="01b02eb95334a25e55e537194d6a183abb3dc8f6" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need.&lt;/strong&gt; Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app, the links in this section will help you get started.</source>
          <target state="translated">Reactは最初から段階的に採用するように設計されており、&lt;strong&gt;必要に応じてReactをほとんどまたはまったく使用できません。&lt;/strong&gt;Reactを試してみたい、単純なHTMLページにインタラクティブ機能を追加したい、複雑なReactを利用したアプリを起動したいなど、このセクションのリンクは、始めるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c050def493e7cae09b97f99b2e48a3bc9ad5f3d3" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need&lt;/strong&gt;. Perhaps you only want to add some &amp;ldquo;sprinkles of interactivity&amp;rdquo; to an existing page. React components are a great way to do that.</source>
          <target state="translated">Reactは最初から段階的に採用するように設計されており、&lt;strong&gt;必要に応じてReactをほとんどまたはまったく使用できません&lt;/strong&gt;。おそらく、既存のページにいくつかの「インタラクティブな機能」を追加するだけです。Reactコンポーネントは、そのための優れた方法です。</target>
        </trans-unit>
        <trans-unit id="7e2cc4782b2fb108291fcfae89e4501e3f4d58b8" translate="yes" xml:space="preserve">
          <source>React has two different approaches to dealing with form inputs.</source>
          <target state="translated">Reactには、フォーム入力を扱うための2つの異なるアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="6556acb734c30d6b0e81652863896aeac19e12df" translate="yes" xml:space="preserve">
          <source>React implements a browser-independent DOM system for performance and cross-browser compatibility. We took the opportunity to clean up a few rough edges in browser DOM implementations.</source>
          <target state="translated">React は、パフォーマンスとクロスブラウザ互換性のために、ブラウザに依存しない DOM システムを実装しています。この機会に、ブラウザの DOM 実装におけるいくつかの粗いエッジをきれいにしました。</target>
        </trans-unit>
        <trans-unit id="6e11539e493eeb1713363587c427ffbbd6d68e65" translate="yes" xml:space="preserve">
          <source>React is a JavaScript library, and so we&amp;rsquo;ll assume you have a basic understanding of the JavaScript language. &lt;strong&gt;If you don&amp;rsquo;t feel very confident, we recommend &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;going through a JavaScript tutorial&lt;/a&gt; to check your knowledge level&lt;/strong&gt; and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour, but as a result you won&amp;rsquo;t have to feel like you&amp;rsquo;re learning both React and JavaScript at the same time.</source>
          <target state="translated">ReactはJavaScriptライブラリーであるため、JavaScript言語の基本を理解していることを前提としています。&lt;strong&gt;自信がない場合は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;、JavaScriptチュートリアル&lt;/a&gt;を実行して知識レベルを確認し、&lt;/strong&gt;迷うことなくこのガイドに沿って進むことができるようにすることをお勧めします。30分から1時間かかる場合がありますが、結果として、ReactとJavaScriptの両方を同時に学習しているように感じる必要はありません。</target>
        </trans-unit>
        <trans-unit id="61c3cb0936f8fb199aa04b34b04ecfe3125551c1" translate="yes" xml:space="preserve">
          <source>React is pretty flexible but it has a single strict rule:</source>
          <target state="translated">Reactはかなり柔軟性がありますが、一つだけ厳しいルールがあります。</target>
        </trans-unit>
        <trans-unit id="dd576a79e84680cddef9aa2ab5587fa94134d1fe" translate="yes" xml:space="preserve">
          <source>React is unaware of changes made to the DOM outside of React. It determines updates based on its own internal representation, and if the same DOM nodes are manipulated by another library, React gets confused and has no way to recover.</source>
          <target state="translated">Reactは、Reactの外部でDOMに加えられた変更を認識していません。それは独自の内部表現に基づいて更新を決定し、同じ DOM ノードが他のライブラリによって操作された場合、React は混乱し、回復する方法がありません。</target>
        </trans-unit>
        <trans-unit id="6cb3494e2a27c4434fdf174bb108a83ae2a686d9" translate="yes" xml:space="preserve">
          <source>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</source>
          <target state="translated">Reactは、JavaScriptを使って大規模で高速なWebアプリケーションを構築するための最高の方法だと私たちは考えています。FacebookやInstagramでは非常によく使われています。</target>
        </trans-unit>
        <trans-unit id="56d6afe7c746ff7047ca63f1d78e3dc5b9dcfae0" translate="yes" xml:space="preserve">
          <source>React keeps track of the currently rendering component. Thanks to the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;, we know that Hooks are only called from React components (or custom Hooks &amp;mdash; which are also only called from React components).</source>
          <target state="translated">Reactは現在レンダリングしているコンポーネントを追跡します。&lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooksの&lt;/a&gt;おかげで、フックはReactコンポーネント（またはカスタムフック&amp;mdash; Reactコンポーネントからのみ呼び出される）からのみ呼び出されることがわかります。</target>
        </trans-unit>
        <trans-unit id="4e89f6b54b1e83e2f41d243abe76734deb9a4d0b" translate="yes" xml:space="preserve">
          <source>React lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend &lt;code&gt;React.Component&lt;/code&gt;:</source>
          <target state="translated">Reactでは、コンポーネントをクラスまたは関数として定義できます。クラスとして定義されたコンポーネントは現在、このページで詳細に説明されているより多くの機能を提供しています。Reactコンポーネントクラスを定義するには、 &lt;code&gt;React.Component&lt;/code&gt; を拡張する必要があります。</target>
        </trans-unit>
        <trans-unit id="97a984b046ffb2272bbcd3ebf68f1025fff620f2" translate="yes" xml:space="preserve">
          <source>React makes this data flow explicit to help you understand how your program works, but it does require a little more typing than traditional two-way data binding.</source>
          <target state="translated">React はこのデータフローを明示的にしてプログラムの動作を理解しやすくしていますが、従来の双方向のデータバインディングよりも少し型付けが必要になります。</target>
        </trans-unit>
        <trans-unit id="51fd1862df14bb5b3bd3097a75315aaec37c0d5c" translate="yes" xml:space="preserve">
          <source>React may batch multiple &lt;code&gt;setState()&lt;/code&gt; calls into a single update for performance.</source>
          <target state="translated">Reactは、パフォーマンスのために、複数の &lt;code&gt;setState()&lt;/code&gt; 呼び出しを単一の更新にバッチ処理する場合があります。</target>
        </trans-unit>
        <trans-unit id="e7723873e421d86b75d6e18af64ca7963f769b3b" translate="yes" xml:space="preserve">
          <source>React normalizes events so that they have consistent properties across different browsers.</source>
          <target state="translated">React はイベントを正規化し、異なるブラウザ間で一貫したプロパティを持つようにします。</target>
        </trans-unit>
        <trans-unit id="2d906a56aa31f7c4795766f5e6511a32ef9c51c2" translate="yes" xml:space="preserve">
          <source>React offers a new built-in &lt;code&gt;useTransition()&lt;/code&gt; Hook to help with this.</source>
          <target state="translated">Reactは、これに役立つ新しい組み込みの &lt;code&gt;useTransition()&lt;/code&gt; フックを提供します。</target>
        </trans-unit>
        <trans-unit id="8a6c999a7613998525cad958f1f5a4415aeb6c88" translate="yes" xml:space="preserve">
          <source>React passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; function inside &lt;code&gt;forwardRef&lt;/code&gt; as a second argument.</source>
          <target state="translated">Reactは &lt;code&gt;ref&lt;/code&gt; を &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; &lt;code&gt;forwardRef&lt;/code&gt; 内の関数に2番目の引数として渡します。</target>
        </trans-unit>
        <trans-unit id="6b8a0c49fcebb56ee095e5a48d9f54395dede3d8" translate="yes" xml:space="preserve">
          <source>React previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the &lt;a href=&quot;legacy-context&quot;&gt;legacy context docs here&lt;/a&gt;.</source>
          <target state="translated">以前に実験的なコンテキストAPIとともに出荷されたReact。古いAPIはすべての16.xリリースでサポートされますが、それを使用するアプリケーションは新しいバージョンに移行する必要があります。レガシーAPIは、将来のメジャーReactバージョンで削除される予定です。&lt;a href=&quot;legacy-context&quot;&gt;こちら&lt;/a&gt;のレガシーコンテキストドキュメントをお読みください。</target>
        </trans-unit>
        <trans-unit id="2765ccc9886a57c1e31be3cce27fa7d9e6c6390f" translate="yes" xml:space="preserve">
          <source>React provides a declarative API so that you don&amp;rsquo;t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React&amp;rsquo;s &amp;ldquo;diffing&amp;rdquo; algorithm so that component updates are predictable while being fast enough for high-performance apps.</source>
          <target state="translated">Reactは宣言型APIを提供するため、更新ごとにどのような変更が行われるかを正確に心配する必要はありません。これにより、アプリケーションの作成がはるかに簡単になりますが、これがReact内でどのように実装されているかは明らかではない場合があります。この記事では、Reactの「差分」アルゴリズムで行った選択について説明します。これにより、コンポーネントの更新が予測可能でありながら、高性能アプリに十分高速であることがわかります。</target>
        </trans-unit>
        <trans-unit id="d6cb4b93a472ab33ec73a24af7d41c47515e59e1" translate="yes" xml:space="preserve">
          <source>React provides a few built-in Hooks like &lt;code&gt;useState&lt;/code&gt;. You can also create your own Hooks to reuse stateful behavior between different components. We&amp;rsquo;ll look at the built-in Hooks first.</source>
          <target state="translated">Reactは、 &lt;code&gt;useState&lt;/code&gt; のようないくつかの組み込みフックを提供します。独自のフックを作成して、異なるコンポーネント間でステートフルな動作を再利用することもできます。最初に組み込みのフックを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="01011cf1aceb6ea9b5b96f5c62df1bcc3dd1a485" translate="yes" xml:space="preserve">
          <source>React relies on a thriving open source community to file bug reports, open pull requests, and &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;submit RFCs&lt;/a&gt;. To encourage feedback we sometimes share special builds of React that include unreleased features.</source>
          <target state="translated">Reactは、繁栄しているオープンソースコミュニティに依存して、バグレポートの&lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;提出&lt;/a&gt;、プルリクエストのオープン、RFCの送信を行っています。フィードバックを促すために、リリースされていない機能を含むReactの特別なビルドを共有することがあります。</target>
        </trans-unit>
        <trans-unit id="f40d6ae813b74cf5f01219aa31530ea03f76cff9" translate="yes" xml:space="preserve">
          <source>React supports a special attribute that you can attach to any component. The &lt;code&gt;ref&lt;/code&gt; attribute can be an object created by &lt;a href=&quot;react-api#reactcreateref&quot;&gt;&lt;code&gt;React.createRef()&lt;/code&gt; function&lt;/a&gt; or a callback function, or a string (in legacy API). When the &lt;code&gt;ref&lt;/code&gt; attribute is a callback function, the function receives the underlying DOM element or class instance (depending on the type of element) as its argument. This allows you to have direct access to the DOM element or component instance.</source>
          <target state="translated">Reactは、任意のコンポーネントにアタッチできる特別な属性をサポートしています。 &lt;code&gt;ref&lt;/code&gt; 属性により作成されたオブジェクトにすることができ&lt;a href=&quot;react-api#reactcreateref&quot;&gt; &lt;code&gt;React.createRef()&lt;/code&gt; 関数&lt;/a&gt;またはコールバック関数、または（レガシーAPIで）文字列。場合 &lt;code&gt;ref&lt;/code&gt; 属性は、コールバック関数であり、関数は、引数として（要素のタイプに応じて）基礎となるDOM要素またはクラスのインスタンスを受け取ります。これにより、DOM要素またはコンポーネントインスタンスに直接アクセスできます。</target>
        </trans-unit>
        <trans-unit id="238af60aedac40fa19ce64bb9c937963b487a350" translate="yes" xml:space="preserve">
          <source>React supports all popular browsers, including Internet Explorer 9 and above, although &lt;a href=&quot;javascript-environment-requirements&quot;&gt;some polyfills are required&lt;/a&gt; for older browsers such as IE 9 and IE 10.</source>
          <target state="translated">ReactはInternet Explorer 9以降を含むすべての一般的なブラウザーをサポートしますが、IE 9やIE 10などの古いブラウザーで&lt;a href=&quot;javascript-environment-requirements&quot;&gt;は一部のポリフィルが必要です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1108fbc718d743d28b30340d206d3e26c0f8796" translate="yes" xml:space="preserve">
          <source>React then calls the &lt;code&gt;Clock&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s render output.</source>
          <target state="translated">次に、Reactは &lt;code&gt;Clock&lt;/code&gt; コンポーネントの &lt;code&gt;render()&lt;/code&gt; メソッドを呼び出します。これは、Reactが画面に何を表示すべきかを学習する方法です。その後、ReactはDOMを更新して &lt;code&gt;Clock&lt;/code&gt; のレンダー出力に一致させます。</target>
        </trans-unit>
        <trans-unit id="8ec1afc5c4c338193066f6b054d7fabc1ccd93cf" translate="yes" xml:space="preserve">
          <source>React treats components starting with lowercase letters as DOM tags. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; represents an HTML div tag, but &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; represents a component and requires &lt;code&gt;Welcome&lt;/code&gt; to be in scope.</source>
          <target state="translated">Reactは小文字で始まるコンポーネントをDOMタグとして扱います。たとえば、 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; はHTML divタグを表しますが、 &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; はコンポーネントを表し、 &lt;code&gt;Welcome&lt;/code&gt; がスコープ内にある必要があります。</target>
        </trans-unit>
        <trans-unit id="960c9be08d5e97c9a662b93134873e0dbeec6765" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.user.read()&lt;/code&gt;. None of the data is fetched yet, so this component &amp;ldquo;suspends&amp;rdquo;. React skips over it, and tries rendering other components in the tree.</source>
          <target state="translated">Reactは &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; をレンダリングしようとします。 &lt;code&gt;resource.user.read()&lt;/code&gt; を呼び出します。データはまだフェッチされていないため、このコンポーネントは「一時停止」します。Reactはそれをスキップして、ツリー内の他のコンポーネントのレンダリングを試みます。</target>
        </trans-unit>
        <trans-unit id="058b3578eec02c6fb7e50af3a2a4e4de20aaa646" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt;. It returns &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; as children.</source>
          <target state="translated">Reactは &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; をレンダリングしようとします。 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; を子として返します。</target>
        </trans-unit>
        <trans-unit id="e8754ec34540679dad16654502b2c038a71a9b14" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.posts.read()&lt;/code&gt;. Again, there&amp;rsquo;s no data yet, so this component also &amp;ldquo;suspends&amp;rdquo;. React skips over it too, and tries rendering other components in the tree.</source>
          <target state="translated">Reactは &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; をレンダリングしようとします。 &lt;code&gt;resource.posts.read()&lt;/code&gt; を呼び出します。繰り返しますが、データはまだないため、このコンポーネントも「一時停止」します。Reactもそれをスキップし、ツリー内の他のコンポーネントのレンダリングを試みます。</target>
        </trans-unit>
        <trans-unit id="2bdef9269be61bc9f880c393261771ba76dbc66f" translate="yes" xml:space="preserve">
          <source>React used to support &lt;code&gt;findDOMNode&lt;/code&gt; to search the tree for a DOM node given a class instance. Normally you don&amp;rsquo;t need this because you can &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;attach a ref directly to a DOM node&lt;/a&gt;.</source>
          <target state="translated">クラスインスタンスが指定されたDOMノードのツリーを検索する &lt;code&gt;findDOMNode&lt;/code&gt; をサポートするために使用されたReact 。&lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;DOMノードに直接ref&lt;/a&gt;をアタッチできるため、通常これは必要ありません。</target>
        </trans-unit>
        <trans-unit id="c79ec4f41b9bc945a753ba6040b79d5949594109" translate="yes" xml:space="preserve">
          <source>React uses a heuristic to decide how &amp;ldquo;urgent&amp;rdquo; an update is, and lets you adjust it with a few lines of code so that you can achieve the desired user experience for every interaction.</source>
          <target state="translated">Reactはヒューリスティックを使用して更新の「緊急」度を決定し、数行のコードで調整して、すべてのやり取りに必要なユーザーエクスペリエンスを実現できます。</target>
        </trans-unit>
        <trans-unit id="22e5b4566adcb56a590eb14809c46d916e2a5e62" translate="yes" xml:space="preserve">
          <source>React will always try to use a shorter lag when network and device allows it.</source>
          <target state="translated">ネットワークやデバイスが許可している場合、Reactは常により短いラグを使用しようとします。</target>
        </trans-unit>
        <trans-unit id="8dd1f1c89423b4d41ec8e1d8fe3ab9451ec3bb8a" translate="yes" xml:space="preserve">
          <source>React will assign the &lt;code&gt;current&lt;/code&gt; property with the DOM element when the component mounts, and assign it back to &lt;code&gt;null&lt;/code&gt; when it unmounts. &lt;code&gt;ref&lt;/code&gt; updates happen before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; lifecycle methods.</source>
          <target state="translated">Reactは、コンポーネントのマウント時に &lt;code&gt;current&lt;/code&gt; プロパティにDOM要素を割り当て、マウント解除すると &lt;code&gt;null&lt;/code&gt; に戻します。 &lt;code&gt;ref&lt;/code&gt; の更新は、 &lt;code&gt;componentDidMount&lt;/code&gt; または &lt;code&gt;componentDidUpdate&lt;/code&gt; ライフサイクルメソッドの前に行われます。</target>
        </trans-unit>
        <trans-unit id="1522b7fcb611ab5619ba5c29f57c6f91086ebb4a" translate="yes" xml:space="preserve">
          <source>React will automatically append a &amp;ldquo;px&amp;rdquo; suffix to certain numeric inline style properties. If you want to use units other than &amp;ldquo;px&amp;rdquo;, specify the value as a string with the desired unit. For example:</source>
          <target state="translated">Reactは、特定の数値インラインスタイルプロパティに「px」サフィックスを自動的に追加します。「px」以外の単位を使用する場合は、目的の単位の文字列として値を指定します。例えば：</target>
        </trans-unit>
        <trans-unit id="e48c661adaa0691f91d81c42dd5ad79faa9d5b40" translate="yes" xml:space="preserve">
          <source>React will call the &lt;code&gt;ref&lt;/code&gt; callback with the DOM element when the component mounts, and call it with &lt;code&gt;null&lt;/code&gt; when it unmounts. Refs are guaranteed to be up-to-date before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; fires.</source>
          <target state="translated">Reactは、コンポーネントのマウント時にDOM要素を使用して &lt;code&gt;ref&lt;/code&gt; コールバックを呼び出し、マウント解除時に &lt;code&gt;null&lt;/code&gt; を使用して呼び出します。refは、 &lt;code&gt;componentDidMount&lt;/code&gt; または &lt;code&gt;componentDidUpdate&lt;/code&gt; が発生する前に最新であることが保証されています。</target>
        </trans-unit>
        <trans-unit id="bec961fa87460a8199bc91207f5602b57da775e4" translate="yes" xml:space="preserve">
          <source>React will match the two &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; trees, match the two &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; trees, and then insert the &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">Reactは2つの &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; ツリーに一致し、2つの &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; ツリーに一致してから、 &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; ツリーを挿入します。</target>
        </trans-unit>
        <trans-unit id="84c8d3d2c6b4ee18e7f6c58c4d0878cfba840ef7" translate="yes" xml:space="preserve">
          <source>React will mutate every child instead of realizing it can keep the &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; subtrees intact. This inefficiency can be a problem.</source>
          <target state="translated">Reactは、 &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; サブツリーをそのまま維持できることに気付かずに、すべての子を突然変異させます。この非効率性が問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="037827f04da7e99d82ca6ffa924d84f2be8f32ef" translate="yes" xml:space="preserve">
          <source>React will only call this function during the first render. See the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt; API reference&lt;/a&gt;.</source>
          <target state="translated">Reactは、最初のレンダリング中にのみこの関数を呼び出します。&lt;a href=&quot;hooks-reference#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d35f599dec735a7f7b9332bdccd38457cff29aae" translate="yes" xml:space="preserve">
          <source>React wouldn&amp;rsquo;t know what to return for the second &lt;code&gt;useState&lt;/code&gt; Hook call. React expected that the second Hook call in this component corresponds to the &lt;code&gt;persistForm&lt;/code&gt; effect, just like during the previous render, but it doesn&amp;rsquo;t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.</source>
          <target state="translated">Reactは、2番目の &lt;code&gt;useState&lt;/code&gt; Hook呼び出しで何を返すかを知りません。Reactは、このコンポーネントの2番目のHook呼び出しが、前回のレンダリング時と同様に、 &lt;code&gt;persistForm&lt;/code&gt; 効果に対応することを期待していましたが、それはもうありません。その時点から、スキップしたコールの後のすべてのフックコールも1つシフトし、バグが発生します。</target>
        </trans-unit>
        <trans-unit id="42280d34287efbc44d3bf22242efdd37d8595402" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called &lt;a href=&quot;reconciliation&quot;&gt;Reconciliation&lt;/a&gt;) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="translated">Reactの差分アルゴリズム（&lt;a href=&quot;reconciliation&quot;&gt;調整&lt;/a&gt;と呼ばれる）は、コンポーネントIDを使用して、既存のサブツリーを更新するか、破棄して新しいサブツリーをマウントするかを決定します。 &lt;code&gt;render&lt;/code&gt; から返されたコンポーネントが前のレンダーのコンポーネントと同一である場合（ &lt;code&gt;===&lt;/code&gt; ）、Reactはサブツリーを新しいものと比較することにより、サブツリーを再帰的に更新します。それらが等しくない場合、前のサブツリーは完全にアンマウントされます。</target>
        </trans-unit>
        <trans-unit id="c1eb9dd2c424ef3fafa626c2c77948281802077e" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="translated">Reactの差分アルゴリズム（調整と呼ばれます）は、コンポーネントIDを使用して、既存のサブツリーを更新するか、破棄して新しいサブツリーをマウントするかを決定します。 &lt;code&gt;render&lt;/code&gt; から返されたコンポーネントが前のrenderのコンポーネントと同一（ &lt;code&gt;===&lt;/code&gt; ）の場合、Reactはサブツリーを新しいサブツリーと比較して再帰的に更新します。それらが等しくない場合、前のサブツリーは完全にマウント解除されます。</target>
        </trans-unit>
        <trans-unit id="4b48776bb22bae427abe8b46cd79f8f736c2050d" translate="yes" xml:space="preserve">
          <source>React.Children</source>
          <target state="translated">React.Children</target>
        </trans-unit>
        <trans-unit id="cc1be87ed14efcaf593075d9ede44a45138aadc0" translate="yes" xml:space="preserve">
          <source>React.Children.count</source>
          <target state="translated">React.Children.count</target>
        </trans-unit>
        <trans-unit id="5af3ed601dd15ebbdaac8d067d95b65af5198725" translate="yes" xml:space="preserve">
          <source>React.Children.forEach</source>
          <target state="translated">React.Children.forEach</target>
        </trans-unit>
        <trans-unit id="b0b9f26dfc87ce7a1fabe603e845da6e1df1ce2e" translate="yes" xml:space="preserve">
          <source>React.Children.map</source>
          <target state="translated">React.Children.map</target>
        </trans-unit>
        <trans-unit id="4a803a2f5a435fe023facedc929712933c00bafa" translate="yes" xml:space="preserve">
          <source>React.Children.only</source>
          <target state="translated">React.Children.only</target>
        </trans-unit>
        <trans-unit id="b1c41bf42fafc87b8d58972c97a42005a457379c" translate="yes" xml:space="preserve">
          <source>React.Children.toArray</source>
          <target state="translated">React.Children.toArray</target>
        </trans-unit>
        <trans-unit id="5cfad44c38cc0f45d4217d64395ad2d18bc09eac" translate="yes" xml:space="preserve">
          <source>React.Component</source>
          <target state="translated">React.Component</target>
        </trans-unit>
        <trans-unit id="8767054cca9f51c04adc1d990df49bae21bd19e8" translate="yes" xml:space="preserve">
          <source>React.Fragment</source>
          <target state="translated">React.Fragment</target>
        </trans-unit>
        <trans-unit id="ec2b194c043c081abd8e1fa7d7077fc02478f79a" translate="yes" xml:space="preserve">
          <source>React.PureComponent</source>
          <target state="translated">React.PureComponent</target>
        </trans-unit>
        <trans-unit id="6f447c27948b73409db445d85ed438ff52b2fed4" translate="yes" xml:space="preserve">
          <source>React.Suspense</source>
          <target state="translated">React.Suspense</target>
        </trans-unit>
        <trans-unit id="da177d61b90dfb2b87eaf6b6fa8fe737abb149c1" translate="yes" xml:space="preserve">
          <source>React.createContext</source>
          <target state="translated">React.createContext</target>
        </trans-unit>
        <trans-unit id="9a1b7db7ce8d37e9b8f0ff95428c282a544b51fe" translate="yes" xml:space="preserve">
          <source>React.createRef</source>
          <target state="translated">React.createRef</target>
        </trans-unit>
        <trans-unit id="470198c910691938bdf95d3f55a8eea2de68e228" translate="yes" xml:space="preserve">
          <source>React.forwardRef</source>
          <target state="translated">React.forwardRef</target>
        </trans-unit>
        <trans-unit id="4d68edc4675fcac6e43f56a62dd19ef2ec4f971c" translate="yes" xml:space="preserve">
          <source>React.lazy</source>
          <target state="translated">React.lazy</target>
        </trans-unit>
        <trans-unit id="b168874df4ce448e7d39cbd474dab62d2a63a48c" translate="yes" xml:space="preserve">
          <source>React.memo</source>
          <target state="translated">React.memo</target>
        </trans-unit>
        <trans-unit id="d1dd4b799fd5b42020755757fd1ad8e4de9166c0" translate="yes" xml:space="preserve">
          <source>ReactDOM</source>
          <target state="translated">ReactDOM</target>
        </trans-unit>
        <trans-unit id="575e6ab87dc7232bd5aee91c11fb19e0ec0429d1" translate="yes" xml:space="preserve">
          <source>ReactDOMServer</source>
          <target state="translated">ReactDOMServer</target>
        </trans-unit>
        <trans-unit id="1c6e2478a4ec4479a4090a890821692248b05319" translate="yes" xml:space="preserve">
          <source>ReactJS: Props vs. State</source>
          <target state="translated">ReactJS:Props vs.State</target>
        </trans-unit>
        <trans-unit id="6bba779745f1dc5e89a8dc6f34f971f62a0cbbcf" translate="yes" xml:space="preserve">
          <source>Read more about the use of these elements to enhance accessibility here:</source>
          <target state="translated">アクセシビリティを高めるためのこれらの要素の使用については、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="074b86f971ede72779f80c5984d463c0b08f7ddd" translate="yes" xml:space="preserve">
          <source>Read our &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;blog post on avoiding derived state&lt;/a&gt; to learn about what to do if you think you need some state to depend on the props.</source>
          <target state="translated">当社読む&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;派生状態を避けるにブログの記事を&lt;/a&gt;、あなたが小道具に依存するように、いくつかの状態が必要だと思う場合の対処について学ぶために。</target>
        </trans-unit>
        <trans-unit id="81948a47f0cece8eebf3d00111f8c4906a80131d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;context&quot;&gt;new context API documentation&lt;/a&gt; to help migrate to the new version.</source>
          <target state="translated">&lt;a href=&quot;context&quot;&gt;新しいコンテキストAPIドキュメント&lt;/a&gt;を読んで、新しいバージョンへの移行に役立ててください。</target>
        </trans-unit>
        <trans-unit id="9d13f2fc7ceb07a1e30213b5dad32a3a5179b292" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt; to learn why we&amp;rsquo;re introducing Hooks to React.</source>
          <target state="translated">Hooks to Reactを導入する理由を学ぶには、&lt;a href=&quot;hooks-intro#motivation&quot;&gt;モチベーション&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="3bbadf53c7263d165aad6e988afe2df6a73f4a1f" translate="yes" xml:space="preserve">
          <source>Reading State</source>
          <target state="translated">よみとりこっか</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="bbff96495da2dd73f63babc3c8bf1ad05fa7f5d9" translate="yes" xml:space="preserve">
          <source>Reason is developed at Facebook, and is used in some of its products like Messenger. It is still somewhat experimental but it has &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;dedicated React bindings&lt;/a&gt; maintained by Facebook and a &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;vibrant community&lt;/a&gt;.</source>
          <target state="translated">ReasonはFacebookで開発され、Messengerなどの一部の製品で使用されています。まだ実験的なものですが、Facebookと&lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;活気のあるコミュニティ&lt;/a&gt;によって維持されている&lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;専用のReactバインディングがあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="3a2b9fcfa6cb6b47fdf570bba482c7f6bd5778c1" translate="yes" xml:space="preserve">
          <source>Recommended Courses</source>
          <target state="translated">おすすめコース</target>
        </trans-unit>
        <trans-unit id="10837ad0c0a51856150f656df265fcd25ac01ed3" translate="yes" xml:space="preserve">
          <source>Recommended Toolchains</source>
          <target state="translated">おすすめのツールチェーン</target>
        </trans-unit>
        <trans-unit id="244546a122b5c31cc9d410496feb2d652e2bbdc1" translate="yes" xml:space="preserve">
          <source>Recommended Tools</source>
          <target state="translated">おすすめツール</target>
        </trans-unit>
        <trans-unit id="b29da9dd20f256ca2ca1f8f9694721825196ea4d" translate="yes" xml:space="preserve">
          <source>Reconciliation</source>
          <target state="translated">Reconciliation</target>
        </trans-unit>
        <trans-unit id="332ed81ec8ca439bef285d75f52c06cbc08b32a4" translate="yes" xml:space="preserve">
          <source>Recursing On Children</source>
          <target state="translated">子どもたちへの再帰</target>
        </trans-unit>
        <trans-unit id="ccfd566b538210ffef62a3cbbf17af444ab5c269" translate="yes" xml:space="preserve">
          <source>Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.</source>
          <target state="translated">レデューサーは、分離してテストするのに非常に便利で、複雑な更新ロジックを表現するためにスケールします。必要に応じて、さらに小さなレデューサーに分解することができます。しかし、Reactローカルステートを使うメリットを享受したり、別のライブラリをインストールしたくない場合もあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0997f5332014e1341252581fa75655f6f29042ff" translate="yes" xml:space="preserve">
          <source>Ref forwarding is a technique for automatically passing a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; through a component to one of its children. This is typically not necessary for most components in the application. However, it can be useful for some kinds of components, especially in reusable component libraries. The most common scenarios are described below.</source>
          <target state="translated">参照転送は、コンポーネントを介して&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;をその子の1つに自動的に渡す手法です。これは通常、アプリケーションのほとんどのコンポーネントでは必要ありません。ただし、一部の種類のコンポーネント、特に再利用可能なコンポーネントライブラリでは役立ちます。最も一般的なシナリオを以下に示します。</target>
        </trans-unit>
        <trans-unit id="88e9c6ab30810deb881b406399ad25815aa00430" translate="yes" xml:space="preserve">
          <source>Ref forwarding is not limited to DOM components. You can forward refs to class component instances, too.</source>
          <target state="translated">参照の転送は DOM コンポーネントに限定されません。クラスコンポーネントのインスタンスにも参照を転送することができます。</target>
        </trans-unit>
        <trans-unit id="f94f7a816faa7ffd5cf23158233fea5b06cec8af" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;React docs&lt;/a&gt; if you need help executing this step.</source>
          <target state="translated">このステップの実行についてヘルプが必要な場合は、&lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;Reactのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c29e646865b903a7f9176acc308f47b762dfedc4" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how best to use ChromeVox:</source>
          <target state="translated">ChromeVoxの最適な使い方については、以下のガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="d97130a2c24d6da30b1f2bcc6a91ee349588c307" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to activate and use VoiceOver:</source>
          <target state="translated">VoiceOverの有効化と使用方法については、次のガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="387cf309f2faa4474cac2537147bc4a9fb447c54" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use JAWS:</source>
          <target state="translated">JAWSの最適な使い方については、以下のガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="c1af4dc4226ba5d7f48cd9164c32b42e6e3bf5ff" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use NVDA:</source>
          <target state="translated">NVDAの最適な使用方法については、以下のガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="e01e6c1194053e77088bcfb2d27b92af6a763645" translate="yes" xml:space="preserve">
          <source>Reference: Component</source>
          <target state="translated">参照してください。コンポーネント</target>
        </trans-unit>
        <trans-unit id="07e5e98584609eccb9f77b23943878ea7e66663b" translate="yes" xml:space="preserve">
          <source>Reference: React</source>
          <target state="translated">参考にしてみてください。リアクト</target>
        </trans-unit>
        <trans-unit id="6c5d1b546101e34b2fef5dfa40c4a0c35d04ef65" translate="yes" xml:space="preserve">
          <source>Reference: Test Utilities</source>
          <target state="translated">参考にしてください。テスト ユーティリティ</target>
        </trans-unit>
        <trans-unit id="9b4ff94e05defc26bbc7cd77d4ca3c6ebd0b6024" translate="yes" xml:space="preserve">
          <source>Referencing Context in Function Components</source>
          <target state="translated">関数コンポーネントでのコンテキストの参照</target>
        </trans-unit>
        <trans-unit id="9b14990da33d9df39d9d550b2e7f8b6fcd2b42ba" translate="yes" xml:space="preserve">
          <source>Referencing Context in Lifecycle Methods</source>
          <target state="translated">ライフサイクル・メソッドにおけるコンテキストの参照</target>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="a3d901aa78a934ff41addcb0fd717d3f919ed007" translate="yes" xml:space="preserve">
          <source>Refs Aren&amp;rsquo;t Passed Through</source>
          <target state="translated">参照は通過しません</target>
        </trans-unit>
        <trans-unit id="f52edcfa76c4c361d68ab116986e39ab247fed52" translate="yes" xml:space="preserve">
          <source>Refs and Function Components</source>
          <target state="translated">リファレンスと機能コンポーネント</target>
        </trans-unit>
        <trans-unit id="fb466d16b8687b6a8370254e6e32e29e3d0859c3" translate="yes" xml:space="preserve">
          <source>Refs and the DOM</source>
          <target state="translated">Refs と DOM</target>
        </trans-unit>
        <trans-unit id="d02e5e18486fdb7d98bc4b06d983eb76fb1c3d9f" translate="yes" xml:space="preserve">
          <source>Refs are created using &lt;code&gt;React.createRef()&lt;/code&gt; and attached to React elements via the &lt;code&gt;ref&lt;/code&gt; attribute. Refs are commonly assigned to an instance property when a component is constructed so they can be referenced throughout the component.</source>
          <target state="translated">&lt;code&gt;React.createRef()&lt;/code&gt; を使用して作成され、 &lt;code&gt;ref&lt;/code&gt; 属性を介してReact要素にアタッチされます。refは通常、コンポーネントの構築時にインスタンスプロパティに割り当てられるため、コンポーネント全体で参照できます。</target>
        </trans-unit>
        <trans-unit id="7d161866c6b9501cf0d2efb1f50f2016be3d6821" translate="yes" xml:space="preserve">
          <source>Refs provide a way to access DOM nodes or React elements created in the render method.</source>
          <target state="translated">Refsは、レンダーメソッドで作成されたDOMノードやReact要素にアクセスする方法を提供します。</target>
        </trans-unit>
        <trans-unit id="899dfdc1d167e0237757bc336e63500e23158098" translate="yes" xml:space="preserve">
          <source>Relay has its own answers to some of these questions. There is certainly more than a single way to do it, and we&amp;rsquo;re excited to see what new ideas the React community comes up with.</source>
          <target state="translated">リレーには、これらの質問のいくつかに対する独自の回答があります。確かにそれを行う方法は1つだけではありません。Reactコミュニティがどのような新しいアイデアを生み出すかを見て興奮します。</target>
        </trans-unit>
        <trans-unit id="f9896fabfbfb541e50cf8fbc89e1dedd902b28da" translate="yes" xml:space="preserve">
          <source>Release Channels</source>
          <target state="translated">リリースチャンネル</target>
        </trans-unit>
        <trans-unit id="37042d2abc9098ffc1431b21485e7d0a1a7e4bba" translate="yes" xml:space="preserve">
          <source>Releases in Experimental are published with the &lt;code&gt;experimental&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">試験運用版のリリースは、npmの &lt;code&gt;experimental&lt;/code&gt; 運用タグで公開されます。バージョンは、ビルドのコンテンツのハッシュから生成されます（例： &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="1437218113e95e798836c2813420f7b58e53793d" translate="yes" xml:space="preserve">
          <source>Releases in Next are published with the &lt;code&gt;next&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">Nextのリリースは、npmの &lt;code&gt;next&lt;/code&gt; タグで公開されます。バージョンは、ビルドのコンテンツのハッシュから生成されます（例： &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="506ceb7ad9bf42c314daf190028b0b49649a9a76" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;props&lt;/code&gt; are readonly. They should not be modified in any way:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; は読み取り専用であることを忘れないでください。これらは決して変更しないでください。</target>
        </trans-unit>
        <trans-unit id="00ec254bb146176823654d1ba7e18ca2d439ac55" translate="yes" xml:space="preserve">
          <source>Remember that only React files ending with &lt;code&gt;.production.min.js&lt;/code&gt; are suitable for production.</source>
          <target state="translated">&lt;code&gt;.production.min.js&lt;/code&gt; で終わるReactファイルのみが本番環境に適していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="55c0498b17e0f7958c5f1cfe9a4af9cc2fac5b70" translate="yes" xml:space="preserve">
          <source>Remember that the function passed to &lt;code&gt;useMemo&lt;/code&gt; runs during rendering. Don&amp;rsquo;t do anything there that you wouldn&amp;rsquo;t normally do while rendering. For example, side effects belong in &lt;code&gt;useEffect&lt;/code&gt;, not &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useMemo&lt;/code&gt; に渡された関数はレンダリング中に実行されることに注意してください。レンダリング中に通常は行わないことは何もしないでください。たとえば、副作用は &lt;code&gt;useEffect&lt;/code&gt; ではなく &lt;code&gt;useMemo&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9a6275d186fd90e50c31acd8ea5dda666aacddf8" translate="yes" xml:space="preserve">
          <source>Remember that this is only necessary before deploying to production. For normal development, use &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="translated">これは、本番環境にデプロイする前にのみ必要であることを覚えておいてください。通常の開発では、 &lt;code&gt;npm start&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3a9b6c75a01a157a01b48b838460f641ef9518a1" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply &lt;code&gt;TerserPlugin&lt;/code&gt; in development because it will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">これを行う必要があるのは、本番ビルドのみです。 &lt;code&gt;TerserPlugin&lt;/code&gt; を開発に適用しないでください。TerserPluginを使用すると、有用なReact警告が非表示になり、ビルドが大幅に遅くなります。</target>
        </trans-unit>
        <trans-unit id="1aa3b578bcc142e681e33d9082e9b12920727051" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply the &lt;code&gt;terser&lt;/code&gt; plugin or the &lt;code&gt;replace&lt;/code&gt; plugin with &lt;code&gt;'production'&lt;/code&gt; value in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">これを行う必要があるのは、本番ビルドのみです。 &lt;code&gt;terser&lt;/code&gt; プラグインまたは &lt;code&gt;replace&lt;/code&gt; プラグインを開発時に &lt;code&gt;'production'&lt;/code&gt; 値で適用しないでください。有用なReact警告が非表示になり、ビルドが非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="0564aab96aa66b680690a02b7eaf83e614ce4779" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply these plugins in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">これを行う必要があるのは、本番ビルドのみです。これらのプラグインは、有用なReact警告を隠し、ビルドを大幅に遅くするため、開発に適用しないでください。</target>
        </trans-unit>
        <trans-unit id="cee5bbc977133f79e172d6c135cbc3a08da22a4c" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t pass the &lt;code&gt;-p&lt;/code&gt; flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.</source>
          <target state="translated">これを行う必要があるのは、本番ビルドのみです。 &lt;code&gt;-p&lt;/code&gt; フラグを渡したり、このプラグインを開発に適用したりしないでください。有用なReact警告が非表示になり、ビルドが大幅に遅くなります。</target>
        </trans-unit>
        <trans-unit id="02638cc549bbccd3a59e4d9f2b3447b3799a9799" translate="yes" xml:space="preserve">
          <source>Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a &amp;ldquo;shell&amp;rdquo; of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph.</source>
          <target state="translated">低速接続でのユーザーエクスペリエンスに注意してください。JavaScriptコードは、最初のHTMLレンダリングよりも大幅に遅れてロードされる可能性があるため、クライアントのみのパスで別のものをレンダリングすると、遷移が不快になる可能性があります。ただし、適切に実行する場合は、サーバー上でアプリケーションの「シェル」をレンダリングし、クライアント上に追加のウィジェットの一部のみを表示することが有益な場合があります。マークアップの不一致の問題を発生させずにこれを行う方法については、前の段落の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="0cf6b3967ff86476349c6cba924e1f4df9063ba0" translate="yes" xml:space="preserve">
          <source>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. &lt;strong&gt;This is often the most challenging part for newcomers to understand,&lt;/strong&gt; so follow these steps to figure it out:</source>
          <target state="translated">覚えておいてください：Reactはすべて、コンポーネント階層の下方向の一方向のデータフローです。どのコンポーネントがどの状態を所有する必要があるかは、すぐには明確でない場合があります。&lt;strong&gt;これは多くの場合、初心者が理解するのが最も難しい部分な&lt;/strong&gt;ので、次の手順に従って&lt;strong&gt;理解&lt;/strong&gt;してください。</target>
        </trans-unit>
        <trans-unit id="4bddbe70e7cebef78898e35292cc2468b12a94b5" translate="yes" xml:space="preserve">
          <source>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns &lt;code&gt;true&lt;/code&gt; if a component was unmounted and &lt;code&gt;false&lt;/code&gt; if there was no component to unmount.</source>
          <target state="translated">マウントされたReactコンポーネントをDOMから削除し、そのイベントハンドラーと状態をクリーンアップします。コンテナにコンポーネントがマウントされていない場合、この関数を呼び出しても何も起こりません。コンポーネントがマウント解除された場合は &lt;code&gt;true&lt;/code&gt; を返し、マウント解除するコンポーネントがなかった場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="86694784f4769bf45b391e840ebd17a5027533ee" translate="yes" xml:space="preserve">
          <source>Remove the &lt;code&gt;date&lt;/code&gt; prop from the &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 要素から &lt;code&gt;date&lt;/code&gt; プロップを削除します。</target>
        </trans-unit>
        <trans-unit id="7f97a2511af3b23436102ab6d44ee45e78c76ee6" translate="yes" xml:space="preserve">
          <source>Render Props</source>
          <target state="translated">小道具を作る</target>
        </trans-unit>
        <trans-unit id="e1ac8a2e8fd4c4d9b2e888fc8ab5aa1c5641c010" translate="yes" xml:space="preserve">
          <source>Render a React element into a detached DOM node in the document. &lt;strong&gt;This function requires a DOM.&lt;/strong&gt; It is effectively equivalent to:</source>
          <target state="translated">React要素をドキュメントの切り離されたDOMノードにレンダリングします。&lt;strong&gt;この関数にはDOMが必要です。&lt;/strong&gt;これは実質的に以下と同等です。</target>
        </trans-unit>
        <trans-unit id="6f4c267baa0ea37da44d3295841c41f7517ef016" translate="yes" xml:space="preserve">
          <source>Render a React element into the DOM in the supplied &lt;code&gt;container&lt;/code&gt; and return a &lt;a href=&quot;refs-and-the-dom&quot;&gt;reference&lt;/a&gt; to the component (or returns &lt;code&gt;null&lt;/code&gt; for &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;stateless components&lt;/a&gt;).</source>
          <target state="translated">React要素を提供された &lt;code&gt;container&lt;/code&gt; DOMにレンダリングし、コンポーネントへの&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;を返し &lt;code&gt;null&lt;/code&gt; （または&lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;ステートレスコンポーネントの&lt;/a&gt;場合はnullを返します）。</target>
        </trans-unit>
        <trans-unit id="dc5294dc207a073f91e4e23440d40dc7c1fe8ec8" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">React要素を初期のHTMLにレンダリングします。ReactはHTMLの文字列を返します。この方法を使用して、サーバー上で HTML を生成し、最初のリクエストでマークアップを下に送ることで、ページの読み込みを高速化したり、検索エンジンが SEO 目的でページをクロールできるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="c0113dc822fbf0c0333e792a37212eab08364f58" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. Returns a &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;Readable stream&lt;/a&gt; that outputs an HTML string. The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; would return. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">React要素を初期HTMLにレンダリングします。HTML文字列を出力する&lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;Readableストリーム&lt;/a&gt;を返します。このストリームによるHTML出力は、&lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt; &lt;/a&gt;が返すものとまったく同じです。このメソッドを使用すると、サーバーでHTMLを生成し、最初のリクエストでマークアップを送信してページの読み込みを高速化し、検索エンジンがSEOの目的でページをクロールできるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="cfd90297d318440c1f2f1e20386ac52433816dbc" translate="yes" xml:space="preserve">
          <source>Render phase lifecycles include the following class component methods:</source>
          <target state="translated">レンダーフェーズのライフサイクルには、以下のクラスのコンポーネントメソッドが含まれます。</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="1c25bcd6bd276eac5fcaea0f95ff3ce958900765" translate="yes" xml:space="preserve">
          <source>Rendering Elements</source>
          <target state="translated">レンダリング要素</target>
        </trans-unit>
        <trans-unit id="6e673765026d08ba19736d6743a5af8bbfbf2280" translate="yes" xml:space="preserve">
          <source>Rendering Multiple Components</source>
          <target state="translated">複数のコンポーネントのレンダリング</target>
        </trans-unit>
        <trans-unit id="5de451ee11969db712ecfa41261cd69923ac3c5e" translate="yes" xml:space="preserve">
          <source>Rendering a Component</source>
          <target state="translated">コンポーネントのレンダリング</target>
        </trans-unit>
        <trans-unit id="5a1b1f26449aa10c5465e1866d5b17350d60dba1" translate="yes" xml:space="preserve">
          <source>Rendering an Element into the DOM</source>
          <target state="translated">DOM への要素のレンダリング</target>
        </trans-unit>
        <trans-unit id="2deeb1304f9fe594167184d5df3f289bd150a128" translate="yes" xml:space="preserve">
          <source>Reorders can also cause issues with component state when indexes are used as keys. Component instances are updated and reused based on their key. If the key is an index, moving an item changes it. As a result, component state for things like uncontrolled inputs can get mixed up and updated in unexpected ways.</source>
          <target state="translated">また、インデックスがキーとして使用されている場合、再順序付けはコンポーネントの状態に問題を引き起こす可能性があります。コンポーネント インスタンスは、そのキーに基づいて更新され、再利用されます。キーがインデックスの場合、アイテムを移動するとそれが変更されます。その結果、制御されていない入力などのコンポーネントの状態が混ざったり、予期せぬ方法で更新されたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="fbe7d9e0840a5d5cc2233edcc4df112b60c50775" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;props&lt;/code&gt; with &lt;code&gt;this.props&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; body.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; ボディの &lt;code&gt;props&lt;/code&gt; を &lt;code&gt;this.props&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="cb57ef5effd1f60e8626d7c988da95a24b5ec275" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;this.props.date&lt;/code&gt; with &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; メソッドで &lt;code&gt;this.props.date&lt;/code&gt; を &lt;code&gt;this.state.date&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="f9ea2adea65e9fb0a33960f20df2ec187396b408" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;Blocking Mode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; を置き換え、&lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;ブロックモード&lt;/a&gt;を有効にします。</target>
        </trans-unit>
        <trans-unit id="317adb3c3ea2c25ffb027f680071c7621ebb38a5" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables Concurrent Mode.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; を置き換え、並行モードを有効にします。</target>
        </trans-unit>
        <trans-unit id="28a19901d94163b49c0b9a0ab562c759e0d3c83b" translate="yes" xml:space="preserve">
          <source>Replacing String-Based Rendering with React</source>
          <target state="translated">文字列ベースのレンダリングをReactに置き換える</target>
        </trans-unit>
        <trans-unit id="326977983d9f5ffff2fba0920254350c35e6b262" translate="yes" xml:space="preserve">
          <source>Requires a &lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;function as a child&lt;/a&gt;. The function receives the current context value and returns a React node. The &lt;code&gt;value&lt;/code&gt; argument passed to the function will be equal to the &lt;code&gt;value&lt;/code&gt; prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the &lt;code&gt;value&lt;/code&gt; argument will be equal to the &lt;code&gt;defaultValue&lt;/code&gt; that was passed to &lt;code&gt;createContext()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;子として&lt;/a&gt;の機能が必要です。関数は現在のコンテキスト値を受け取り、Reactノードを返します。 &lt;code&gt;value&lt;/code&gt; 関数に渡される引数はと同じになります &lt;code&gt;value&lt;/code&gt; ツリーで上記のこのような状況のために最も近いプロバイダの小道具。上記のこのコンテキストのプロバイダーがない場合、 &lt;code&gt;value&lt;/code&gt; 引数は &lt;code&gt;createContext()&lt;/code&gt; に渡された &lt;code&gt;defaultValue&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="e8319d57e9244f07c04fc5e8602151a6c0fa2d6f" translate="yes" xml:space="preserve">
          <source>Requiring Single Child</source>
          <target state="translated">一人っ子を必要とする</target>
        </trans-unit>
        <trans-unit id="7111cdd0dc257beff8eea7a806b1ab1fd962ca5c" translate="yes" xml:space="preserve">
          <source>Resist the temptation to modify a component&amp;rsquo;s prototype (or otherwise mutate it) inside a HOC.</source>
          <target state="translated">HOC内でコンポーネントのプロトタイプを変更する（または変更する）誘惑に抵抗します。</target>
        </trans-unit>
        <trans-unit id="d9204284eada33e6b4a89c93c4c4d56bd1b58bad" translate="yes" xml:space="preserve">
          <source>Return a function that produces React elements of a given type. Like &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;, the type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="translated">指定されたタイプのReact要素を生成する関数を返します。&lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; &lt;/a&gt;と同様に、type引数は、タグ名文字列（ &lt;code&gt;'div'&lt;/code&gt; や &lt;code&gt;'span'&lt;/code&gt; など）、&lt;a href=&quot;components-and-props&quot;&gt;Reactコンポーネント&lt;/a&gt;タイプ（クラスまたは関数）、または&lt;a href=&quot;#reactfragment&quot;&gt;Reactフラグメント&lt;/a&gt;タイプのいずれかです。</target>
        </trans-unit>
        <trans-unit id="9d9490a5975f4c1aeeb1fba945378a6267587086" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. The representation is more detailed than the one provided by &lt;code&gt;toJSON()&lt;/code&gt;, and includes the user-written components. You probably don&amp;rsquo;t need this method unless you&amp;rsquo;re writing your own assertion library on top of the test renderer.</source>
          <target state="translated">レンダリングされたツリーを表すオブジェクトを返します。この表現は、 &lt;code&gt;toJSON()&lt;/code&gt; で提供されるものよりも詳細であり、ユーザー作成コンポーネントが含まれています。テストレンダラーの上に独自のアサーションライブラリを作成しているのでない限り、おそらくこのメソッドは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f7c1bb71db1342d91c5ef36e51eb4eaefb116d31" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. This tree only contains the platform-specific nodes like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and their props, but doesn&amp;rsquo;t contain any user-written components. This is handy for &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;snapshot testing&lt;/a&gt;.</source>
          <target state="translated">レンダリングされたツリーを表すオブジェクトを返します。このツリーには、 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; などのプラットフォーム固有のノードとその小道具のみが含まれ、ユーザーが作成したコンポーネントは含まれていません。これは&lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;スナップショットテストに&lt;/a&gt;便利です。</target>
        </trans-unit>
        <trans-unit id="74fc039e9565bf16b53a3b89e5b81f2b44db53f3" translate="yes" xml:space="preserve">
          <source>Return the instance corresponding to the root element, if available. This will not work if the root element is a function component because they don&amp;rsquo;t have instances.</source>
          <target state="translated">可能な場合、ルート要素に対応するインスタンスを返します。ルート要素が関数コンポーネントの場合、インスタンスがないため、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="1bf63f8c82c0848fec82740dea18e1228a6949a1" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;null&lt;/code&gt; from a component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method does not affect the firing of the component&amp;rsquo;s lifecycle methods. For instance &lt;code&gt;componentDidUpdate&lt;/code&gt; will still be called.</source>
          <target state="translated">コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドから &lt;code&gt;null&lt;/code&gt; を返しても、コンポーネントのライフサイクルメソッドの起動には影響しません。たとえば、 &lt;code&gt;componentDidUpdate&lt;/code&gt; は引き続き呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7bc6aecb5d9aba689da1df93e2754ec3bbba006b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is a React element whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;true&lt;/code&gt; 場合 &lt;code&gt;element&lt;/code&gt; タイプリアクトであるリアクト要素である &lt;code&gt;componentClass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a190fbdb0884ae9441f701da292b119b62675501" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is any React element.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; がReact要素の場合は &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4c122a79f21fb165125e2d7f4bf95f4c5c45a74e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a DOM component (such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">戻り値 &lt;code&gt;true&lt;/code&gt; 場合 &lt;code&gt;instance&lt;/code&gt; （例えば、DOM要素である &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e33afd14605447b5271912282d921b04b0bd5370" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a component whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; がタイプがReact &lt;code&gt;componentClass&lt;/code&gt; のコンポーネントである場合、 &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="499d37d763d22c84b2d39e5c1954470c821ac070" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a user-defined component, such as a class or a function.</source>
          <target state="translated">返し &lt;code&gt;true&lt;/code&gt; ならば &lt;code&gt;instance&lt;/code&gt; 、そのようなクラスまたは関数として、ユーザ定義の構成要素です。</target>
        </trans-unit>
        <trans-unit id="ebac6d7da5644ee246df2cbcbead0e219e53e73f" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; callback.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;メモ化された&lt;/a&gt;コールバックを返します。</target>
        </trans-unit>
        <trans-unit id="d3db2224691dc0b90f31765016663484bb5df51c" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; value.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;メモ化された&lt;/a&gt;値を返します。</target>
        </trans-unit>
        <trans-unit id="ebd4eccf8c2df94f154d585fd787ad0e2ae4f7f8" translate="yes" xml:space="preserve">
          <source>Returns a deferred version of the value that may &amp;ldquo;lag behind&amp;rdquo; it for at most &lt;code&gt;timeoutMs&lt;/code&gt;.</source>
          <target state="translated">最大で &lt;code&gt;timeoutMs&lt;/code&gt; の間「遅れる」可能性がある値の遅延バージョンを返します。</target>
        </trans-unit>
        <trans-unit id="e3aaff9eb4ac50df91dd22852b4c13a60bac4270" translate="yes" xml:space="preserve">
          <source>Returns a stateful value, and a function to update it.</source>
          <target state="translated">ステートフルな値と、それを更新する関数を返します。</target>
        </trans-unit>
        <trans-unit id="62e25a4ff0b51f4bd36d6a71ad97da75dd2e0c57" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;children&lt;/code&gt; opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice &lt;code&gt;this.props.children&lt;/code&gt; before passing it down.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; 不透明データ構造を、各子に割り当てられたキーを持つフラット配列として返します。レンダーメソッドで子のコレクションを操作する場合、特に &lt;code&gt;this.props.children&lt;/code&gt; を渡す前に並べ替えまたはスライスする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4fdadee436b13fdfda743f94c2cfe940b695fe60" translate="yes" xml:space="preserve">
          <source>Returns the root &amp;ldquo;test instance&amp;rdquo; object that is useful for making assertions about specific nodes in the tree. You can use it to find other &amp;ldquo;test instances&amp;rdquo; deeper below.</source>
          <target state="translated">ツリー内の特定のノードに関するアサーションを作成するのに役立つルートの「テストインスタンス」オブジェクトを返します。これを使用して、以下の「テストインスタンス」をより深く見つけることができます。</target>
        </trans-unit>
        <trans-unit id="5a38b55153cd2060423a41d78bde79f2b8e20191" translate="yes" xml:space="preserve">
          <source>Returns the total number of components in &lt;code&gt;children&lt;/code&gt;, equal to the number of times that a callback passed to &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; would be invoked.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; のコンポーネントの総数を返します。これは、 &lt;code&gt;map&lt;/code&gt; または &lt;code&gt;forEach&lt;/code&gt; に渡されたコールバックが呼び出される回数と同じです。</target>
        </trans-unit>
        <trans-unit id="4aeaf8edb1adb3ef0d49248b4bb93fa627e27381" translate="yes" xml:space="preserve">
          <source>Reviewing the Changes</source>
          <target state="translated">変更点の見直し</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="74d0a40665676a538ac8d7c46b8e150fe7235473" translate="yes" xml:space="preserve">
          <source>Route-based code splitting</source>
          <target state="translated">ルートベースのコード分割</target>
        </trans-unit>
        <trans-unit id="60d643b40f21ca2b9a8a2512b3ba9f597aab6291" translate="yes" xml:space="preserve">
          <source>Rules of Hooks</source>
          <target state="translated">フックのルール</target>
        </trans-unit>
        <trans-unit id="9020d3797b111846dfc58e088bf239a503f003ec" translate="yes" xml:space="preserve">
          <source>Run JSX Preprocessor</source>
          <target state="translated">JSXプリプロセッサの実行</target>
        </trans-unit>
        <trans-unit id="e0f8daf0577d98a996bfa8ec0c41df7d50af891c" translate="yes" xml:space="preserve">
          <source>Run your test suite against the updated packages.</source>
          <target state="translated">更新されたパッケージに対してテストスイートを実行します。</target>
        </trans-unit>
        <trans-unit id="0827761783f753ff9b40994c31529959784a8de2" translate="yes" xml:space="preserve">
          <source>Running Flow</source>
          <target state="translated">ランニングフロー</target>
        </trans-unit>
        <trans-unit id="fc77263186fd8066db7ad56b10769297381f425f" translate="yes" xml:space="preserve">
          <source>Running TypeScript</source>
          <target state="translated">TypeScriptの実行</target>
        </trans-unit>
        <trans-unit id="98df08dc14cf2fe8409704906e8ba7f061915ee5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, but is used to hydrate a container whose HTML contents were rendered by &lt;a href=&quot;react-dom-server&quot;&gt;&lt;code&gt;ReactDOMServer&lt;/code&gt;&lt;/a&gt;. React will attempt to attach event listeners to the existing markup.</source>
          <target state="translated">&lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt;と同じですが、HTMLコンテンツが&lt;a href=&quot;react-dom-server&quot;&gt; &lt;code&gt;ReactDOMServer&lt;/code&gt; &lt;/a&gt;によってレンダリングされたコンテナをハイドレートするために使用されます。Reactは既存のマークアップにイベントリスナーをアタッチしようとします。</target>
        </trans-unit>
        <trans-unit id="f129cfc1e70fca4be604a579a5f801302cd6ac8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt;&lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt;&lt;/a&gt; but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt; &lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt; と&lt;/a&gt;同じですが、1つの結果があることを期待してその1つの結果を返すか、1つ以外に一致する数が他にある場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="a4ebff257960955bf717b48cfa34669ee1fa3976" translate="yes" xml:space="preserve">
          <source>Scaling to many files and components.</source>
          <target state="translated">多くのファイルやコンポーネントへのスケーリング。</target>
        </trans-unit>
        <trans-unit id="9a78372a71733c0c9188bac3d792afa287fb2eda" translate="yes" xml:space="preserve">
          <source>Screen readers</source>
          <target state="translated">スクリーンリーダー</target>
        </trans-unit>
        <trans-unit id="b61bfcb18d2395a6da3e919d474b496e6bf967ac" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;this visualization&lt;/a&gt; for a comparison of &lt;code&gt;throttle&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;throttle&lt;/code&gt; 機能と &lt;code&gt;debounce&lt;/code&gt; 機能の比較については、&lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;この視覚化&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7cb44d447dbdc4f2ebff6dfd7717cd653ac4777" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;react-without-jsx&quot;&gt;Using React without JSX&lt;/a&gt; for more information.</source>
          <target state="translated">詳しくは、&lt;a href=&quot;react-without-jsx&quot;&gt;JSX&lt;/a&gt;を使用しないReactの使用を参照してください。</target>
        </trans-unit>
        <trans-unit id="d32e26b0425e2167e0dcb6fdf91a985d64bf28a6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt; for more information about the state.</source>
          <target state="translated">状態の詳細については、状態&lt;a href=&quot;state-and-lifecycle&quot;&gt;とライフサイクル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="85a5ceb78c2280eeda3b846f0acb9cd42d788db2" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;the recommended pattern for derived state&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;派生状態の推奨パターン&lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="a01530646c79b2f55199eeb7b47f0556cdd706ac" translate="yes" xml:space="preserve">
          <source>See below for how to fix this problem.</source>
          <target state="translated">この問題を解決する方法は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="1693e8fef7af337e4a3ee1564391e1db17535c9f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;react-component&quot;&gt;React.Component API Reference&lt;/a&gt; for a list of methods and properties related to the base &lt;code&gt;React.Component&lt;/code&gt; class.</source>
          <target state="translated">基本の &lt;code&gt;React.Component&lt;/code&gt; クラスに関連するメソッドとプロパティのリストについては、&lt;a href=&quot;react-component&quot;&gt;React.Component APIリファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9b57f0fefc1bf09d35ad975ad4ca5e7a0022756a" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;Thinking In React: Step 2&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;のペン&lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;思考の反応：ステップ2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="889e869dc48285461d9781e138af203334338e0d" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;Thinking In React: Step 5&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;のペン&lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;思考の反応：ステップ5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b9f4e6141331c9cdb4f88c27dd7d6b936edcd8e" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;Thinking In React: Step 4&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;のペン&lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;思考の反応：ステップ4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e91150ff591242b615b363e43cadf66bc003b974" translate="yes" xml:space="preserve">
          <source>Selection Events</source>
          <target state="translated">セレクションイベント</target>
        </trans-unit>
        <trans-unit id="337b6de00774331dfea10bf7602f57a929bd0481" translate="yes" xml:space="preserve">
          <source>Selective Hydration</source>
          <target state="translated">選択的水分補給</target>
        </trans-unit>
        <trans-unit id="7c55bcc8e6eca62fa53850720b0e3bfdb3df096a" translate="yes" xml:space="preserve">
          <source>Semantic HTML</source>
          <target state="translated">セマンティックHTML</target>
        </trans-unit>
        <trans-unit id="b2058039eabd80a65369d8f9cda9fc120b4c0fed" translate="yes" xml:space="preserve">
          <source>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</source>
          <target state="translated">セマンティックHTMLは、Webアプリケーションにおけるアクセシビリティの基礎となるものです。Webサイトの情報の意味を補強するために様々なHTML要素を使用することで、多くの場合、無料でアクセシビリティが得られます。</target>
        </trans-unit>
        <trans-unit id="551eb6c2699adf574c58f34b218b75ea8a444ba2" translate="yes" xml:space="preserve">
          <source>Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:</source>
          <target state="translated">独立した状態変数を分離することには、もう一つの利点があります。これにより、例えばカスタムフックに関連するロジックを後で簡単に抽出することができます。</target>
        </trans-unit>
        <trans-unit id="ab5ab1acf5db0758245097e8fa3ad6f910f353a0" translate="yes" xml:space="preserve">
          <source>Server side rendering</source>
          <target state="translated">サーバーサイドレンダリング</target>
        </trans-unit>
        <trans-unit id="aa8d26b865d79b0e63b8bfd0b9391b4237522018" translate="yes" xml:space="preserve">
          <source>Server-only. This API is not available in the browser.</source>
          <target state="translated">サーバー専用です。このAPIはブラウザでは利用できません。</target>
        </trans-unit>
        <trans-unit id="21878b65dc5eb634bcd11071915a81b9ce37484e" translate="yes" xml:space="preserve">
          <source>Set the document &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; to correctly describe the current page content as this ensures that the user remains aware of the current page context:</source>
          <target state="translated">ドキュメント &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; を設定して、現在のページのコンテンツを正しく説明します。これにより、ユーザーは現在のページのコンテキストを常に把握できます。</target>
        </trans-unit>
        <trans-unit id="32b0183325e39fb8a7bae93ef8b271742e8892b1" translate="yes" xml:space="preserve">
          <source>Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt; and &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt;.</source>
          <target state="translated">任意の継続的インテグレーションプラットフォームを使用してcronジョブをセットアップします。Cronジョブは&lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt;と&lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CIの&lt;/a&gt;両方でサポートされています。</target>
        </trans-unit>
        <trans-unit id="ca49bc3bc95dc20864ef73e70622bcc8d41e81bb" translate="yes" xml:space="preserve">
          <source>Setting the Initial State</source>
          <target state="translated">初期状態の設定</target>
        </trans-unit>
        <trans-unit id="418beebb985e8d40774763fdd4f9e8a6047b5b90" translate="yes" xml:space="preserve">
          <source>Setting the document title</source>
          <target state="translated">ドキュメントのタイトルを設定する</target>
        </trans-unit>
        <trans-unit id="fac5905f3c39f20c6f85ca274a70117415678188" translate="yes" xml:space="preserve">
          <source>Setting the language</source>
          <target state="translated">言語の設定</target>
        </trans-unit>
        <trans-unit id="c08c4a1087611b4f8dc1ce3b9d6eab6afb735be4" translate="yes" xml:space="preserve">
          <source>Setup/Teardown</source>
          <target state="translated">Setup/Teardown</target>
        </trans-unit>
        <trans-unit id="1a12bbc273b9d327eac0e2f46ee90996baa545d4" translate="yes" xml:space="preserve">
          <source>Shallow Renderer</source>
          <target state="translated">シャローレンダラ</target>
        </trans-unit>
        <trans-unit id="157334ad7585fe71fa4ab72dc1138a4016d37634" translate="yes" xml:space="preserve">
          <source>Shallow testing currently has some limitations, namely not supporting refs.</source>
          <target state="translated">浅いテストには現在、いくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="61717f0f4104f3c6b59d2620027283eb267d0f6f" translate="yes" xml:space="preserve">
          <source>Short Syntax</source>
          <target state="translated">ショートシンタックス</target>
        </trans-unit>
        <trans-unit id="d78971d67c66eff9e3aca079ae91a776c3dbebcf" translate="yes" xml:space="preserve">
          <source>Should I use Hooks, classes, or a mix of both?</source>
          <target state="translated">フック、クラス、それとも両方を混ぜて使うべきでしょうか?</target>
        </trans-unit>
        <trans-unit id="65ba853a7020f20726c91f50244f39620f835b31" translate="yes" xml:space="preserve">
          <source>Should I use a state management library like Redux or MobX?</source>
          <target state="translated">ReduxやMobXのような状態管理ライブラリを使うべきか?</target>
        </trans-unit>
        <trans-unit id="2eea49ef9ef41333d4d180d43ca9ea2c23559f87" translate="yes" xml:space="preserve">
          <source>Should I use one or many state variables?</source>
          <target state="translated">1つの状態変数を使うべきか、それとも多くの状態変数を使うべきか?</target>
        </trans-unit>
        <trans-unit id="9e6a9215ce35f846b17b522ab097d2abb82a7869" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">&lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt;に似ていますが、 &lt;code&gt;data-reactroot&lt;/code&gt; など、Reactが内部で使用する追加のDOM属性を作成しない点が異なります。Reactを単純な静的ページジェネレーターとして使用する場合、これは便利です。余分な属性を削除すると、バイトを節約できるためです。</target>
        </trans-unit>
        <trans-unit id="3608f05da13ebf98cb83134331188e8ec9e99c3e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">&lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt;と同様ですが、 &lt;code&gt;data-reactroot&lt;/code&gt; など、Reactが内部で使用する追加のDOM属性は作成されません。Reactを単純な静的ページジェネレーターとして使用する場合、これは便利です。余分な属性を削除すると、バイトを節約できるためです。</target>
        </trans-unit>
        <trans-unit id="90d668391f22451830d3dcf0d685e789289cf850" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt; helper from &lt;code&gt;react-dom/test-utils&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TestRenderer.act&lt;/code&gt; prepares a component for assertions. Use this version of &lt;code&gt;act()&lt;/code&gt; to wrap calls to &lt;code&gt;TestRenderer.create&lt;/code&gt; and &lt;code&gt;testRenderer.update&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;react-dom/test-utils&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;act()&lt;/code&gt; ヘルパーと同様に、 &lt;code&gt;TestRenderer.act&lt;/code&gt; はアサーション用のコンポーネントを準備します。このバージョンの &lt;code&gt;act()&lt;/code&gt; を使用して、 &lt;code&gt;TestRenderer.create&lt;/code&gt; および &lt;code&gt;testRenderer.update&lt;/code&gt; への呼び出しをラップします。</target>
        </trans-unit>
        <trans-unit id="f95b4050bee5ae0b356d207e738904d2352b8c01" translate="yes" xml:space="preserve">
          <source>Similarly, all SVG attributes are fully supported:</source>
          <target state="translated">同様に、すべてのSVG属性が完全にサポートされています。</target>
        </trans-unit>
        <trans-unit id="ac994655a077627f0a00237edd40be91d12515d2" translate="yes" xml:space="preserve">
          <source>Similarly, we know from research that interactions like hover and text input need to be handled within a very short period of time, while clicks and page transitions can wait a little longer without feeling laggy. The different &amp;ldquo;priorities&amp;rdquo; that Concurrent Mode uses internally roughly correspond to the interaction categories in the human perception research.</source>
          <target state="translated">同様に、ホバーやテキスト入力などのインタラクションは非常に短い時間内で処理する必要がある一方、クリックやページ遷移は遅延を感じることなく少し長く待機できることが調査からわかっています。並行モードが内部で使用するさまざまな「優先順位」は、人間の知覚研究の相互作用カテゴリにほぼ対応しています。</target>
        </trans-unit>
        <trans-unit id="95c6045668485e434001bbb400904f65d6473b52" translate="yes" xml:space="preserve">
          <source>Simulate</source>
          <target state="translated">Simulate</target>
        </trans-unit>
        <trans-unit id="cdbbf7631367f8cecedfefc8e66eb086c7762a50" translate="yes" xml:space="preserve">
          <source>Simulate an event dispatch on a DOM node with optional &lt;code&gt;eventData&lt;/code&gt; event data.</source>
          <target state="translated">オプションの &lt;code&gt;eventData&lt;/code&gt; イベントデータを使用して、DOMノードでのイベントディスパッチをシミュレートします。</target>
        </trans-unit>
        <trans-unit id="7a90574fe221159516cab518b7b70d81b6f6d291" translate="yes" xml:space="preserve">
          <source>Since &amp;ldquo;virtual DOM&amp;rdquo; is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term &amp;ldquo;virtual DOM&amp;rdquo; is usually associated with &lt;a href=&quot;rendering-elements&quot;&gt;React elements&lt;/a&gt; since they are the objects representing the user interface. React, however, also uses internal objects called &amp;ldquo;fibers&amp;rdquo; to hold additional information about the component tree. They may also be considered a part of &amp;ldquo;virtual DOM&amp;rdquo; implementation in React.</source>
          <target state="translated">「仮想DOM」は特定のテクノロジーというよりパターンになっているため、人々はそれを別の意味で使用すると言います。Reactの世界では、「仮想DOM」という用語は、ユーザーインターフェースを表すオブジェクトであるため、通常&lt;a href=&quot;rendering-elements&quot;&gt;React要素に&lt;/a&gt;関連付けられています。ただし、Reactは「ファイバー」と呼ばれる内部オブジェクトを使用して、コンポーネントツリーに関する追加情報を保持します。また、Reactでの「仮想DOM」実装の一部と見なされる場合もあります。</target>
        </trans-unit>
        <trans-unit id="4830b2d00e988292620868e08773981b63e3a3f0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;for&lt;/code&gt; is a reserved word in JavaScript, React elements use &lt;code&gt;htmlFor&lt;/code&gt; instead.</source>
          <target state="translated">以来 &lt;code&gt;for&lt;/code&gt; のJavaScriptの予約語である、要素が使用リアクト &lt;code&gt;htmlFor&lt;/code&gt; を代わりに。</target>
        </trans-unit>
        <trans-unit id="c096576bbc5548a29f7624ed231f5f3700e9858e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;false&lt;/code&gt; for the subtree rooted at C2, React did not attempt to render C2, and thus didn&amp;rsquo;t even have to invoke &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on C4 and C5.</source>
          <target state="translated">以来 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; が返さ &lt;code&gt;false&lt;/code&gt; C2をルートとするサブツリーのために、C2をレンダリングしようとしなかった反応し、これでも起動する必要はありませんでした &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を C4とC5に。</target>
        </trans-unit>
        <trans-unit id="fa0676e6e4f1be773446c673e249d40dd484a093" translate="yes" xml:space="preserve">
          <source>Since Hooks are functions, we can pass information between them.</source>
          <target state="translated">フックは関数なので、その間に情報を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="ce78c3b89392f8fd00349533b1a860c5b146a75c" translate="yes" xml:space="preserve">
          <source>Since JSX compiles into calls to &lt;code&gt;React.createElement&lt;/code&gt;, the &lt;code&gt;React&lt;/code&gt; library must also always be in scope from your JSX code.</source>
          <target state="translated">JSXは &lt;code&gt;React.createElement&lt;/code&gt; の呼び出しにコンパイルされるため、 &lt;code&gt;React&lt;/code&gt; ライブラリも常にJSXコードのスコープ内になければなりません。</target>
        </trans-unit>
        <trans-unit id="582c0c532f56fb3bc564df7ce904fded5bbd449f" translate="yes" xml:space="preserve">
          <source>Since JSX is closer to JavaScript than to HTML, React DOM uses &lt;code&gt;camelCase&lt;/code&gt; property naming convention instead of HTML attribute names.</source>
          <target state="translated">JSXはHTMLよりもJavaScriptに近いため、React DOMはHTML属性名の代わりに &lt;code&gt;camelCase&lt;/code&gt; プロパティの命名規則を使用します。</target>
        </trans-unit>
        <trans-unit id="a5465180db9678022404188e56a14dedb56e8c77" translate="yes" xml:space="preserve">
          <source>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</source>
          <target state="translated">制御されていないコンポーネントは真実のソースをDOMに保持するので、制御されていないコンポーネントを使用する場合、Reactと非Reactのコードを統合するのが簡単になることがあります。また、素早くダーティにしたい場合には、コードを少し減らすことができます。それ以外の場合は、通常は制御されたコンポーネントを使うべきです。</target>
        </trans-unit>
        <trans-unit id="12802519d13596acb64db3728385146466f1c0c6" translate="yes" xml:space="preserve">
          <source>Since components are the basic unit of code reuse in React, let&amp;rsquo;s try refactoring the code a bit to use a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component that encapsulates the behavior we need to reuse elsewhere.</source>
          <target state="translated">コンポーネントはReactでのコード再利用の基本単位であるため、他の場所で再利用する必要がある動作をカプセル化する &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; コンポーネントを使用して、コードを少しリファクタリングしてみましょう。</target>
        </trans-unit>
        <trans-unit id="7d149476874665e632f5d09368dfec9b329e5fb0" translate="yes" xml:space="preserve">
          <source>Since object refs were largely added as a replacement for string refs, strict mode now warns about usage of string refs.</source>
          <target state="translated">文字列参照の代わりにオブジェクト参照が主に追加されたので、strict モードでは文字列参照の使用について警告するようになりました。</target>
        </trans-unit>
        <trans-unit id="945a3eb7a113afe7fb345d5867e2f0417b7c4d31" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;value&lt;/code&gt; attribute is set on our form element, the displayed value will always be &lt;code&gt;this.state.value&lt;/code&gt;, making the React state the source of truth. Since &lt;code&gt;handleChange&lt;/code&gt; runs on every keystroke to update the React state, the displayed value will update as the user types.</source>
          <target state="translated">以来 &lt;code&gt;value&lt;/code&gt; 属性は、当社のフォーム要素に設定され、表示される値は常になります &lt;code&gt;this.state.value&lt;/code&gt; 真のソース状態を反応させること、。以来 &lt;code&gt;handleChange&lt;/code&gt; はリアクト状態を更新するためにすべてのキーストロークで実行されます、表示される値は、ユーザーの種類として更新します。</target>
        </trans-unit>
        <trans-unit id="65dca83b0699ba95c122c68674390a7799fe42a9" translate="yes" xml:space="preserve">
          <source>Since this technique is a little unusual, you&amp;rsquo;ll probably want to explicitly state that &lt;code&gt;children&lt;/code&gt; should be a function in your &lt;code&gt;propTypes&lt;/code&gt; when designing an API like this.</source>
          <target state="translated">この技術は少し珍しいですので、おそらくことを明示的状態したいと思う &lt;code&gt;children&lt;/code&gt; 自分の中の関数でなければなりません &lt;code&gt;propTypes&lt;/code&gt; このようなAPIを設計するとき。</target>
        </trans-unit>
        <trans-unit id="b258100f25369e4ae0ce97a3b2cb85cb2dfc0fe6" translate="yes" xml:space="preserve">
          <source>Since you&amp;rsquo;re often displaying a JSON data model to a user, you&amp;rsquo;ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That&amp;rsquo;s because UI and data models tend to adhere to the same &lt;em&gt;information architecture&lt;/em&gt;. Separate your UI into components, where each component matches one piece of your data model.</source>
          <target state="translated">多くの場合、JSONデータモデルをユーザーに表示しているため、モデルが正しく構築されていれば、UI（およびコンポーネントの構造）は適切にマッピングされます。UIとデータモデルは同じ&lt;em&gt;情報アーキテクチャ&lt;/em&gt;に準拠する傾向があるためです。UIをコンポーネントに分離します。各コンポーネントはデータモデルの1つの部分と一致します。</target>
        </trans-unit>
        <trans-unit id="625d8d80af7bbcdfa81222888dc91ae1c67047a5" translate="yes" xml:space="preserve">
          <source>Single-File Builds</source>
          <target state="translated">シングルファイルビルド</target>
        </trans-unit>
        <trans-unit id="b79ccec4e08c14b21b7dbe1bf30a724c5d594935" translate="yes" xml:space="preserve">
          <source>Single-page Application</source>
          <target state="translated">シングルページアプリケーション</target>
        </trans-unit>
        <trans-unit id="5e268b8fb13c4275436f6fec47445b6c6a370b4f" translate="yes" xml:space="preserve">
          <source>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</source>
          <target state="translated">スキップリンクまたはスキップナビゲーションリンクは、キーボードユーザーがページを操作したときにのみ表示される隠しナビゲーションリンクです。これらのリンクは、内部のページアンカーといくつかのスタイリングで非常に簡単に実装することができます。</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">スナップショットテスト</target>
        </trans-unit>
        <trans-unit id="540d1ef8fe38fe16e9bd6ac54276ab966b7a4f51" translate="yes" xml:space="preserve">
          <source>So What About Inheritance?</source>
          <target state="translated">では、相続についてはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="be184e3655c9a842843034adac922d2b6b3bcf62" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it&amp;rsquo;s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">これまでに、小道具と階層の下方に流れる状態の関数として正しくレンダリングされるアプリを構築しました。次に、データフローを別の方法でサポートします。階層の深いフォームコンポーネントは &lt;code&gt;FilterableProductTable&lt;/code&gt; の状態を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d36706ca32133596b9127ed5d816900d1e29cf2" translate="yes" xml:space="preserve">
          <source>So finally, our state is:</source>
          <target state="translated">それで、最後に、私たちの州は</target>
        </trans-unit>
        <trans-unit id="41a2c2d31192f2035b56a37240597cc8d1ce2f0e" translate="yes" xml:space="preserve">
          <source>So how does React know which state corresponds to which &lt;code&gt;useState&lt;/code&gt; call? The answer is that &lt;strong&gt;React relies on the order in which Hooks are called&lt;/strong&gt;. Our example works because the order of the Hook calls is the same on every render:</source>
          <target state="translated">では、Reactはどの状態がどの &lt;code&gt;useState&lt;/code&gt; 呼び出しに対応するかをどのようにして知るのでしょうか。その答えは、&lt;strong&gt;Reactはフックが呼び出される順序に依存しているということ&lt;/strong&gt;です。フック呼び出しの順序はすべてのレンダリングで同じであるため、この例は機能します。</target>
        </trans-unit>
        <trans-unit id="91956b86d2b226dc60b40a10c6064c0879b25281" translate="yes" xml:space="preserve">
          <source>So the correct fix is to put &lt;code&gt;setQuery&lt;/code&gt; (which doesn&amp;rsquo;t suspend) &lt;em&gt;outside&lt;/em&gt; the transition, but &lt;code&gt;setResource&lt;/code&gt; (which will suspend) &lt;em&gt;inside&lt;/em&gt; of it.</source>
          <target state="translated">正しい修正が入れてあるので &lt;code&gt;setQuery&lt;/code&gt; （中断しない）&lt;em&gt;外&lt;/em&gt;の移行が、 &lt;code&gt;setResource&lt;/code&gt; （一時停止されます）&lt;em&gt;内の&lt;/em&gt;それのを。</target>
        </trans-unit>
        <trans-unit id="11bcfd3ea24e7b454ce05dfb87c9d0158ac74b60" translate="yes" xml:space="preserve">
          <source>So the following jQuery implementation&amp;hellip;</source>
          <target state="translated">したがって、次のjQuery実装&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bf1cb757dd15a9b82f28af071a783eda7ce755d2" translate="yes" xml:space="preserve">
          <source>So using a render prop makes it possible to use either pattern.</source>
          <target state="translated">そのため、レンダープロップを使用することで、どちらのパターンでも使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b8bee9b25a62fc9052ff4b48a5eeea612a72ba58" translate="yes" xml:space="preserve">
          <source>So what if we could write a &lt;code&gt;useReducer&lt;/code&gt; Hook that lets us manage the &lt;em&gt;local&lt;/em&gt; state of our component with a reducer? A simplified version of it might look like this:</source>
          <target state="translated">では、コンポーネントの&lt;em&gt;ローカル&lt;/em&gt;状態をレデューサーで管理できるようにする &lt;code&gt;useReducer&lt;/code&gt; フックを作成できるとしたらどうでしょう。簡略化したバージョンは次のようになります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4363bcb8572f01d639e93f80d7731d5945c5a5b1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There are a few ways we can answer this:</source>
          <target state="translated">では、サスペンスのポイントは何ですか？これに答える方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="d06b3c258f542a990c77a5fae1fe50270e36d2d1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There&amp;rsquo;s a few ways we can answer this:</source>
          <target state="translated">それでは、サスペンスのポイントは何ですか？これに答える方法はいくつかあります：</target>
        </trans-unit>
        <trans-unit id="c7658e82394e9389e52b89bd4d2384e335440e9a" translate="yes" xml:space="preserve">
          <source>So, how can Hooks solve this problem? Just like &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;you can use the &lt;em&gt;State&lt;/em&gt; Hook more than once&lt;/a&gt;, you can also use several effects. This lets us separate unrelated logic into different effects:</source>
          <target state="translated">では、フックはどのようにしてこの問題を解決できるでしょうか？同じように&lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;使用できる&lt;em&gt;状態の&lt;/em&gt;複数回のフックを&lt;/a&gt;、あなたはまた、いくつかの効果を使用することができます。これにより、無関係なロジックを異なる効果に分離できます。</target>
        </trans-unit>
        <trans-unit id="8d02b7e415d9e8d63052f83b346ef42769efa71e" translate="yes" xml:space="preserve">
          <source>Solving Race Conditions with Suspense</source>
          <target state="translated">サスペンスでレースの条件を解決</target>
        </trans-unit>
        <trans-unit id="5dcc864f338464da25786ad58214ee40c24cb4fd" translate="yes" xml:space="preserve">
          <source>Some components don&amp;rsquo;t know their children ahead of time. This is especially common for components like &lt;code&gt;Sidebar&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; that represent generic &amp;ldquo;boxes&amp;rdquo;.</source>
          <target state="translated">一部のコンポーネントは、事前に子を認識していません。これは、一般的な「ボックス」を表す &lt;code&gt;Sidebar&lt;/code&gt; や &lt;code&gt;Dialog&lt;/code&gt; などのコンポーネントで特に一般的です。</target>
        </trans-unit>
        <trans-unit id="96871b8dd7b23918e375f655cee67524e2b12086" translate="yes" xml:space="preserve">
          <source>Some components have dependencies for modules that may not work well in test environments, or aren&amp;rsquo;t essential to our tests. It can be useful to selectively mock these modules out with suitable replacements &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">一部のコンポーネントには、テスト環境で適切に機能しない可能性のある、またはテストに必須ではないモジュールの依存関係があります。これらのモジュールを適切な代替品&lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;（例）で&lt;/small&gt;&lt;/a&gt;選択的にモックアウトすると便利です。</target>
        </trans-unit>
        <trans-unit id="614c13a8b04ce94e3f4ed5ff071c3bd90dde1618" translate="yes" xml:space="preserve">
          <source>Some examples in the documentation use &lt;code&gt;style&lt;/code&gt; for convenience, but &lt;strong&gt;using the &lt;code&gt;style&lt;/code&gt; attribute as the primary means of styling elements is generally not recommended.&lt;/strong&gt; In most cases, &lt;a href=&quot;#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; should be used to reference classes defined in an external CSS stylesheet. &lt;code&gt;style&lt;/code&gt; is most often used in React applications to add dynamically-computed styles at render time. See also &lt;a href=&quot;faq-styling&quot;&gt;FAQ: Styling and CSS&lt;/a&gt;.</source>
          <target state="translated">ドキュメントの一部の例では、便宜上 &lt;code&gt;style&lt;/code&gt; を&lt;strong&gt;使用して &lt;code&gt;style&lt;/code&gt; ますが、要素のスタイル設定の主要な手段としてスタイル属性を使用することは、一般的に推奨されていません。&lt;/strong&gt;ほとんどの場合、&lt;a href=&quot;#classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt;を使用して、外部CSSスタイルシートで定義されたクラスを参照する必要があります。 &lt;code&gt;style&lt;/code&gt; は、Reactアプリケーションで最もよく使用され、レンダリング時に動的に計算されるスタイルを追加します。&lt;a href=&quot;faq-styling&quot;&gt;FAQ：Styling and CSS&lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="ef4f7933de9dfc7491281fed4ffdc03bbfcf3853" translate="yes" xml:space="preserve">
          <source>Some modules might not work well inside a testing environment, or may not be as essential to the test itself. Mocking out these modules with dummy replacements can make it easier to write tests for your own code.</source>
          <target state="translated">いくつかのモジュールは、テスト環境の中ではうまく動作しないかもしれませんし、テスト自体に必要不可欠なものではないかもしれません。これらのモジュールをダミーの置き換えでモックアウトすることで、独自のコードのテストを書きやすくなります。</target>
        </trans-unit>
        <trans-unit id="c4cfa33208dbe4639a0d378dff52c7435fff87fc" translate="yes" xml:space="preserve">
          <source>Some of the DOM attributes supported by React include:</source>
          <target state="translated">ReactでサポートされているDOM属性には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="96e5cbe3009d23e8b32e7d37fe1acce8dabd1560" translate="yes" xml:space="preserve">
          <source>Some people also prefer to go further, and separate components into different folders depending on their role in the application. For example, &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; is a design methodology built on this principle. Remember that it&amp;rsquo;s often more productive to treat such methodologies as helpful examples rather than strict rules to follow.</source>
          <target state="translated">一部の人々はさらに進んで、アプリケーションでの役割に応じてコンポーネントを異なるフォルダーに分離することを好みます。たとえば、&lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt;は、この原則に基づいて構築された設計方法論です。従うべき厳密な規則ではなく、そのような方法論を有用な例として扱う方が生産的である場合が多いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d096867d249bc9020052a71ba018f7a10b3ca19c" translate="yes" xml:space="preserve">
          <source>Something Missing?</source>
          <target state="translated">何か欠けていますか?</target>
        </trans-unit>
        <trans-unit id="80413ba692b4736af61c7baf6819b5bb8236d925" translate="yes" xml:space="preserve">
          <source>Sometimes a parent component needs to set focus to an element in a child component. We can do this by &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;exposing DOM refs to parent components&lt;/a&gt; through a special prop on the child component that forwards the parent&amp;rsquo;s ref to the child&amp;rsquo;s DOM node.</source>
          <target state="translated">親コンポーネントは、子コンポーネントの要素にフォーカスを設定する必要がある場合があります。これを行うには、親の参照を子のDOMノードに転送する子コンポーネントの特別なプロップを介して、&lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;DOMの参照を親コンポーネントに公開し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b43c302a7eeb97d1c3b75a79a6531baafe26b30a" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to define a static method on a React component. For example, Relay containers expose a static method &lt;code&gt;getFragment&lt;/code&gt; to facilitate the composition of GraphQL fragments.</source>
          <target state="translated">Reactコンポーネントで静的メソッドを定義すると便利な場合があります。たとえば、Relayコンテナは静的メソッド &lt;code&gt;getFragment&lt;/code&gt; を公開して、GraphQLフラグメントの構成を容易にします。</target>
        </trans-unit>
        <trans-unit id="5d35c9c3f98eb464527bcc5a72fa4944c7139e41" translate="yes" xml:space="preserve">
          <source>Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;a list of commonly recommended resources&lt;/a&gt;, some of which are free.</source>
          <target state="translated">公式ドキュメントよりもサードパーティの書籍やビデオコースの方が役立つ場合があります。&lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;一般的に推奨されるリソースのリスト&lt;/a&gt;を維持しています。その一部は無料です。</target>
        </trans-unit>
        <trans-unit id="892625bcde39b047433f6f0e4c2a6c85238cae55" translate="yes" xml:space="preserve">
          <source>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the &lt;code&gt;map()&lt;/code&gt; body is too nested, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">これにより、より明確なコードが得られる場合がありますが、このスタイルも悪用される可能性があります。JavaScriptの場合と同様に、読みやすくするために変数を抽出する価値があるかどうかを判断するのはユーザーです。場合ことを覚えておいてください &lt;code&gt;map()&lt;/code&gt; 体があまりにもネストされている、良い機会かもしれない&lt;a href=&quot;components-and-props#extracting-components&quot;&gt;成分を抽出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0183ce117e89d5333990aad33e9f21dbd3c8ad5" translate="yes" xml:space="preserve">
          <source>Sometimes very different components may share some common functionality. These are sometimes called &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;cross-cutting concerns&lt;/a&gt;. &lt;code&gt;createReactClass&lt;/code&gt; lets you use a legacy &lt;code&gt;mixins&lt;/code&gt; system for that.</source>
          <target state="translated">非常に異なるコンポーネントがいくつかの共通機能を共有する場合があります。これらは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;横断的関心事&lt;/a&gt;と呼ばれることもあります。 &lt;code&gt;createReactClass&lt;/code&gt; を使用すると、従来の &lt;code&gt;mixins&lt;/code&gt; システムを使用できます。</target>
        </trans-unit>
        <trans-unit id="0df05a3843bbcf9ee66e7ee68ac3c0653e4fec68" translate="yes" xml:space="preserve">
          <source>Sometimes we break HTML semantics when we add &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements to our JSX to make our React code work, especially when working with lists (&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt;) and the HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;. In these cases we should rather use &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; to group together multiple elements.</source>
          <target state="translated">JSXに &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 要素を追加してReactコードを機能させると、特にリスト（ &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt; ）とHTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; を処理するときに、HTMLセマンティクスが壊れることがあります。このような場合は、&lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt;を使用して複数の要素をグループ化する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e2e5311eb15d9d862c73dbfbe53759a23f39f84" translate="yes" xml:space="preserve">
          <source>Sometimes we think about components as being &amp;ldquo;special cases&amp;rdquo; of other components. For example, we might say that a &lt;code&gt;WelcomeDialog&lt;/code&gt; is a special case of &lt;code&gt;Dialog&lt;/code&gt;.</source>
          <target state="translated">コンポーネントを他のコンポーネントの「特殊なケース」と考えることがあります。たとえば、 &lt;code&gt;WelcomeDialog&lt;/code&gt; は &lt;code&gt;Dialog&lt;/code&gt; の特殊なケースであると言えます。</target>
        </trans-unit>
        <trans-unit id="2113ccfe3cef67ecda3109bea67055bdcc179fac" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to &lt;strong&gt;run some additional code after React has updated the DOM.&lt;/strong&gt; Network requests, manual DOM mutations, and logging are common examples of effects that don&amp;rsquo;t require a cleanup. We say that because we can run them and immediately forget about them. Let&amp;rsquo;s compare how classes and Hooks let us express such side effects.</source>
          <target state="translated">&lt;strong&gt;ReactがDOMを更新した後で、追加のコード&lt;/strong&gt;を&lt;strong&gt;実行し&lt;/strong&gt;たい場合があり&lt;strong&gt;ます。&lt;/strong&gt;ネットワークリクエスト、手動DOMミューテーション、ロギングは、クリーンアップを必要としない効果の一般的な例です。私たちはそれらを実行し、すぐにそれらを忘れることができるからです。クラスとフックでこのような副作用を表現する方法を比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="657bcb464d6a199b5a3987ac0c1ea4a5d73c44d1" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; and &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;. Custom Hooks let you do this, but without adding more components to your tree.</source>
          <target state="translated">コンポーネント間でステートフルロジックを再利用したい場合があります。従来、この問題に対する一般的な解決策は2つありました。&lt;a href=&quot;higher-order-components&quot;&gt;高次コンポーネント&lt;/a&gt;と&lt;a href=&quot;render-props&quot;&gt;レンダリングプロップ&lt;/a&gt;です。カスタムフックを使用すると、これを行うことができますが、ツリーにコンポーネントを追加する必要はありません。</target>
        </trans-unit>
        <trans-unit id="351447063fd3690ce16863aa7ac3c07a6ab525f3" translate="yes" xml:space="preserve">
          <source>Sometimes, you may not want to mock timers. For example, maybe you&amp;rsquo;re testing an animation, or interacting with an endpoint that&amp;rsquo;s sensitive to timing (like an API rate limiter). Libraries with timer mocks let you enable and disable them on a per test/suite basis, so you can explicitly choose how these tests would run.</source>
          <target state="translated">タイマーをモックしたくない場合があります。たとえば、アニメーションをテストしている場合や、タイミングに敏感なエンドポイント（APIレートリミッターなど）と対話している場合があります。タイマーモックを備えたライブラリでは、テスト/スイートごとにそれらを有効または無効にできるため、これらのテストの実行方法を明示的に選択できます。</target>
        </trans-unit>
        <trans-unit id="091ab55337927adfcab6d0cbf58d4ada7ebe5d05" translate="yes" xml:space="preserve">
          <source>Sometimes, your effect may be using state that changes too often. You might be tempted to omit that state from a list of dependencies, but that usually leads to bugs:</source>
          <target state="translated">時には、あまりにも頻繁に変化するステートを使用している場合があります。依存関係のリストからその状態を省略したくなるかもしれませんが、通常はバグが発生します。</target>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="1fa161cc62a9e4ea6aa020d607d68a8963cee67c" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;[count]&lt;/code&gt; as a list of dependencies would fix the bug, but would cause the interval to be reset on every change. Effectively, each &lt;code&gt;setInterval&lt;/code&gt; would get one chance to execute before being cleared (similar to a &lt;code&gt;setTimeout&lt;/code&gt;.) That may not be desirable. To fix this, we can use the &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;functional update form of &lt;code&gt;setState&lt;/code&gt;&lt;/a&gt;. It lets us specify &lt;em&gt;how&lt;/em&gt; the state needs to change without referencing the &lt;em&gt;current&lt;/em&gt; state:</source>
          <target state="translated">&lt;code&gt;[count]&lt;/code&gt; を依存関係のリストとして指定すると、バグは修正されますが、変更のたびに間隔がリセットされます。事実上、各 &lt;code&gt;setInterval&lt;/code&gt; は、クリアされる前に1回実行される可能性があります（ &lt;code&gt;setTimeout&lt;/code&gt; と同様）。これは望ましくない場合があります。これを修正するには&lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;、 &lt;code&gt;setState&lt;/code&gt; の&lt;/a&gt;機能更新フォームを使用できます。&lt;em&gt;現在の&lt;/em&gt;状態を参照せずに状態を変更する&lt;em&gt;方法を&lt;/em&gt;指定できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f9a50e2fbfe07712e5925cf722f8b4a41d2e0df" translate="yes" xml:space="preserve">
          <source>Specifying Attributes with JSX</source>
          <target state="translated">JSXで属性を指定する</target>
        </trans-unit>
        <trans-unit id="5a158241151d38add28063d1a39efc6a532ed860" translate="yes" xml:space="preserve">
          <source>Specifying Children with JSX</source>
          <target state="translated">JSXで子を指定する</target>
        </trans-unit>
        <trans-unit id="e4fa66e9ea342e16491d74d178d20dc425ce360e" translate="yes" xml:space="preserve">
          <source>Specifying The React Element Type</source>
          <target state="translated">React 要素の型を指定する</target>
        </trans-unit>
        <trans-unit id="248e5212cad1782449c4a8e8fdc79f7d18ea7441" translate="yes" xml:space="preserve">
          <source>Specifying the initial state</source>
          <target state="translated">初期状態の指定</target>
        </trans-unit>
        <trans-unit id="484b72292d9dd5e8ed98a1228281ec72fe6aaebe" translate="yes" xml:space="preserve">
          <source>Specifying the value prop on a &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled component&lt;/a&gt; prevents the user from changing the input unless you desire so. If you&amp;rsquo;ve specified a &lt;code&gt;value&lt;/code&gt; but the input is still editable, you may have accidentally set &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;forms#controlled-components&quot;&gt;制御されたコンポーネントで&lt;/a&gt;値propを指定すると、ユーザーが希望しない限り、ユーザーが入力を変更することを防止できます。 &lt;code&gt;value&lt;/code&gt; を指定したが入力がまだ編集可能な場合は、誤って &lt;code&gt;value&lt;/code&gt; を &lt;code&gt;undefined&lt;/code&gt; または &lt;code&gt;null&lt;/code&gt; に設定した可能性があります。</target>
        </trans-unit>
        <trans-unit id="04a3524370f46bd76ff0ae35ee1a6d4dc7ad661e" translate="yes" xml:space="preserve">
          <source>Splitting High and Low Priority State</source>
          <target state="translated">優先度の高い状態と低い状態を分ける</target>
        </trans-unit>
        <trans-unit id="7250062690f9f9d303c56e302576ed47dd44bdaf" translate="yes" xml:space="preserve">
          <source>Spread Attributes</source>
          <target state="translated">スプレッド属性</target>
        </trans-unit>
        <trans-unit id="efd4ca2d204c1e4616c4e8cf039d050140fdb3ee" translate="yes" xml:space="preserve">
          <source>Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don&amp;rsquo;t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly.</source>
          <target state="translated">スプレッド属性は便利な場合がありますが、不要な小道具を気にしないコンポーネントに渡したり、無効なHTML属性をDOMに渡したりするのも簡単にします。この構文は慎重に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="064bfcfabe6af4f3be4dbea953ea4d27d586523d" translate="yes" xml:space="preserve">
          <source>Standalone Node Package</source>
          <target state="translated">スタンドアロンノードパッケージ</target>
        </trans-unit>
        <trans-unit id="5def4534ce22a871405cdf372bebde72db101bdc" translate="yes" xml:space="preserve">
          <source>Standards and Guidelines</source>
          <target state="translated">基準とガイドライン</target>
        </trans-unit>
        <trans-unit id="cd1bd3ab3b9ae3d1a43994956517d5ee88941549" translate="yes" xml:space="preserve">
          <source>Start Fetching Early</source>
          <target state="translated">早めに取りに行く</target>
        </trans-unit>
        <trans-unit id="711a21abde2479b997c6cb2cae4595727f2a64c8" translate="yes" xml:space="preserve">
          <source>Start With A Mock</source>
          <target state="translated">モックから始める</target>
        </trans-unit>
        <trans-unit id="91177ccaba80c331e7a4c30fc35a6c5a3d541e03" translate="yes" xml:space="preserve">
          <source>Start fetching</source>
          <target state="translated">フェッチ開始</target>
        </trans-unit>
        <trans-unit id="8f669e598b328d921b668756a5d615493ee0168c" translate="yes" xml:space="preserve">
          <source>Start rendering</source>
          <target state="translated">レンダリング開始</target>
        </trans-unit>
        <trans-unit id="a86d8f44e22238201b173b962f6886510a0da088" translate="yes" xml:space="preserve">
          <source>Starting with 16.8.0, React includes a stable implementation of React Hooks for:</source>
          <target state="translated">16.8.0から、ReactにはReact Hooks forの安定した実装が含まれています。</target>
        </trans-unit>
        <trans-unit id="92f810f23bdc85140b73e30ea49450509c5bd85c" translate="yes" xml:space="preserve">
          <source>Starting with React 17, the &lt;code&gt;onScroll&lt;/code&gt; event &lt;strong&gt;does not bubble&lt;/strong&gt; in React. This matches the browser behavior and prevents the confusion when a nested scrollable element fires events on a distant parent.</source>
          <target state="translated">React 17以降、 &lt;code&gt;onScroll&lt;/code&gt; イベント&lt;strong&gt;は&lt;/strong&gt;Reactで&lt;strong&gt;バブル&lt;/strong&gt;し&lt;strong&gt;ません&lt;/strong&gt;。これはブラウザの動作と一致し、ネストされたスクロール可能な要素が離れた親でイベントを発生させたときの混乱を防ぎます。</target>
        </trans-unit>
        <trans-unit id="18c688a4bc8cbf6a9e644ceeea91e61be20a88de" translate="yes" xml:space="preserve">
          <source>State Updates May Be Asynchronous</source>
          <target state="translated">状態の更新は非同期である可能性があります</target>
        </trans-unit>
        <trans-unit id="88237580e68309e5a5a6557ed798f9117f825c21" translate="yes" xml:space="preserve">
          <source>State Updates are Merged</source>
          <target state="translated">州の更新情報が統合される</target>
        </trans-unit>
        <trans-unit id="a8d6e1e76b0e2efabcf40d1b7270dae7fadac365" translate="yes" xml:space="preserve">
          <source>State and Lifecycle</source>
          <target state="translated">状態とライフサイクル</target>
        </trans-unit>
        <trans-unit id="67d1df931840b49786d4500f55b14d3015fe3f48" translate="yes" xml:space="preserve">
          <source>State and Lifecycle guide</source>
          <target state="translated">状態とライフサイクルガイド</target>
        </trans-unit>
        <trans-unit id="4df972d16c5d19e8d5ddb903b62a89007862e156" translate="yes" xml:space="preserve">
          <source>State is similar to props, but it is private and fully controlled by the component.</source>
          <target state="translated">ステートはプロップスと似ていますが、プライベートであり、コンポーネントによって完全に制御されています。</target>
        </trans-unit>
        <trans-unit id="1d1c74f2d06c5f4368c9bc7a2cf5d263cebf3d96" translate="yes" xml:space="preserve">
          <source>State updater functions (the first argument to &lt;code&gt;setState&lt;/code&gt;)</source>
          <target state="translated">状態アップデーター関数（ &lt;code&gt;setState&lt;/code&gt; の最初の引数）</target>
        </trans-unit>
        <trans-unit id="7d421eaa763efe61aa522fbfca14b10e27b8dcc0" translate="yes" xml:space="preserve">
          <source>State variables and state cells in &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScriptの&lt;/a&gt;状態変数と状態セル。</target>
        </trans-unit>
        <trans-unit id="3878c33013f598bc32c82cf1ead566633a3f208e" translate="yes" xml:space="preserve">
          <source>Static Methods Must Be Copied Over</source>
          <target state="translated">静的なメソッドはコピーする必要があります</target>
        </trans-unit>
        <trans-unit id="bd88cfef69c4e37c1ba575ea9f53e708a1a1232c" translate="yes" xml:space="preserve">
          <source>Static Type Checking</source>
          <target state="translated">静的型チェック</target>
        </trans-unit>
        <trans-unit id="924e72d946f8bfadb7a3147de738b256272c4bf4" translate="yes" xml:space="preserve">
          <source>Static type checkers like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; identify certain types of problems before you even run your code. They can also improve developer workflow by adding features like auto-completion. For this reason, we recommend using Flow or TypeScript instead of &lt;code&gt;PropTypes&lt;/code&gt; for larger code bases.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;や&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;などの静的型チェッカーは、コードを実行する前に特定の種類の問題を識別します。また、オートコンプリートなどの機能を追加して、開発者のワークフローを改善することもできます。このため、より大きなコードベースには、 &lt;code&gt;PropTypes&lt;/code&gt; ではなくFlowまたはTypeScriptを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a0bd05cb8a239da7ed3487a46c276e0484a9dd10" translate="yes" xml:space="preserve">
          <source>Staying Informed</source>
          <target state="translated">情報提供</target>
        </trans-unit>
        <trans-unit id="9feb5d73b7d630e1fa9f796479ee1477109b8dba" translate="yes" xml:space="preserve">
          <source>Step 1: Add a DOM Container to the HTML</source>
          <target state="translated">ステップ 1:HTML に DOM コンテナを追加する</target>
        </trans-unit>
        <trans-unit id="14221e6881613f0cccb7ed29f77307bf69df44a9" translate="yes" xml:space="preserve">
          <source>Step 1: Break The UI Into A Component Hierarchy</source>
          <target state="translated">ステップ1:UIをコンポーネント階層に分割する</target>
        </trans-unit>
        <trans-unit id="f86ff7cc0b24afa445be129e259c884fd0af8b9b" translate="yes" xml:space="preserve">
          <source>Step 2: Add the Script Tags</source>
          <target state="translated">ステップ2:スクリプトタグの追加</target>
        </trans-unit>
        <trans-unit id="123ca7868e30446f688a7f747df83b53290cef75" translate="yes" xml:space="preserve">
          <source>Step 2: Build A Static Version in React</source>
          <target state="translated">ステップ2:Reactで静的バージョンをビルドする</target>
        </trans-unit>
        <trans-unit id="39ec5061574d18b5de0be9ab6b2b1a042b9c2339" translate="yes" xml:space="preserve">
          <source>Step 3: Create a React Component</source>
          <target state="translated">ステップ3:Reactコンポーネントを作成する</target>
        </trans-unit>
        <trans-unit id="33a5f37d369f03644215598531ec2c023674c11b" translate="yes" xml:space="preserve">
          <source>Step 3: Identify The Minimal (but complete) Representation Of UI State</source>
          <target state="translated">ステップ 3:UI 状態の最小(しかし完全な)表現を特定する</target>
        </trans-unit>
        <trans-unit id="62f65581c960b7670694036d15605d1e79ee3f22" translate="yes" xml:space="preserve">
          <source>Step 4: Identify Where Your State Should Live</source>
          <target state="translated">ステップ4:あなたの州がどこに住むべきかを特定する</target>
        </trans-unit>
        <trans-unit id="d63ae2a1550f68c81fc498e7a755f439ca787317" translate="yes" xml:space="preserve">
          <source>Step 5: Add Inverse Data Flow</source>
          <target state="translated">ステップ5:逆データフローの追加</target>
        </trans-unit>
        <trans-unit id="0395deb615c42389e7f7f63e97f88c21bad5e8cb" translate="yes" xml:space="preserve">
          <source>Step-by-Step Guide</source>
          <target state="translated">ステップバイステップガイド</target>
        </trans-unit>
        <trans-unit id="ded55f9c4ea8f5cf7b52f527f0d476e47f977212" translate="yes" xml:space="preserve">
          <source>Stop recording.</source>
          <target state="translated">録画を停止します。</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">厳格なモード</target>
        </trans-unit>
        <trans-unit id="ffd57d06c3bfecbc437452b09e192830e0690661" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:</source>
          <target state="translated">厳密モードでは副作用を自動的に検出することはできませんが、副作用をもう少し決定論的にすることで、副作用を見つけるのに役立ちます。これは、次の関数を意図的に二重に呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="1433029b40a7c8096820012bb4fd0012e00acc4b" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following methods:</source>
          <target state="translated">厳格モードでは副作用を自動的に検出できませんが、副作用をもう少し確定的にすることで、それらを見つけるのに役立ちます。これは、以下のメソッドを意図的に二重に呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="0f8563c9f25fde889f1c031be9d1996fb84fdad0" translate="yes" xml:space="preserve">
          <source>Strict mode checks are run in development mode only; &lt;em&gt;they do not impact the production build&lt;/em&gt;.</source>
          <target state="translated">厳格モードのチェックは開発モードでのみ実行されます。&lt;em&gt;プロダクションビルドには影響しません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="translated">文字列リテラル</target>
        </trans-unit>
        <trans-unit id="504651e88e0554e0480e5760d113aa05357364b8" translate="yes" xml:space="preserve">
          <source>String Refs</source>
          <target state="translated">文字列参照</target>
        </trans-unit>
        <trans-unit id="9491d60784f7659ed917ac4823f4059dd50ab9e6" translate="yes" xml:space="preserve">
          <source>Stripping Flow Syntax from the Compiled Code</source>
          <target state="translated">コンパイルされたコードからフロー構文を取り除く</target>
        </trans-unit>
        <trans-unit id="89d196a4aa8b803a1ebf5056e05caebbbc2bd828" translate="yes" xml:space="preserve">
          <source>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. &lt;code&gt;node.style.backgroundImage&lt;/code&gt;). Vendor prefixes &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt;other than &lt;code&gt;ms&lt;/code&gt;&lt;/a&gt; should begin with a capital letter. This is why &lt;code&gt;WebkitTransition&lt;/code&gt; has an uppercase &amp;ldquo;W&amp;rdquo;.</source>
          <target state="translated">JSからDOMノードのプロパティへのアクセスと一貫性を &lt;code&gt;node.style.backgroundImage&lt;/code&gt; ために、スタイルキーはcamelCasedです（例：node.style.backgroundImage）。&lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt; &lt;code&gt;ms&lt;/code&gt; &lt;/a&gt;以外のベンダープレフィックスは、大文字で始める必要があります。これが、 &lt;code&gt;WebkitTransition&lt;/code&gt; に大文字の「W」がある理由です。</target>
        </trans-unit>
        <trans-unit id="dd76e22706bae25144071aa88dd7860b26352adb" translate="yes" xml:space="preserve">
          <source>Styling and CSS</source>
          <target state="translated">スタイリングとCSS</target>
        </trans-unit>
        <trans-unit id="414b5ca82eb42c71f0f2d39c844f482fd42ea9da" translate="yes" xml:space="preserve">
          <source>Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:</source>
          <target state="translated">後続の呼び出しは、同じサイクル内の前の呼び出しの値を上書きするので、量は一度だけ増加します。次の状態が現在の状態に依存する場合は、代わりにアップデータ関数の形式を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="333ad9c79db454c75a821468e0cf82cb446eefbc" translate="yes" xml:space="preserve">
          <source>Such functions are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&amp;ldquo;pure&amp;rdquo;&lt;/a&gt; because they do not attempt to change their inputs, and always return the same result for the same inputs.</source>
          <target state="translated">このような関数は、入力を変更しようとせず、常に同じ入力に対して同じ結果を返すため、&lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;「純粋」&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2358d63b1ed4396759930456a478ea2a3ecb09ca" translate="yes" xml:space="preserve">
          <source>Supported Events</source>
          <target state="translated">対応イベント</target>
        </trans-unit>
        <trans-unit id="e9d85411dc54581517da69d2b9ea66c39e1aebb2" translate="yes" xml:space="preserve">
          <source>Suppose you have a structure like:</source>
          <target state="translated">のような構造になっているとします。</target>
        </trans-unit>
        <trans-unit id="abd40b2a3a10e13029651065e57e2382da64bf8f" translate="yes" xml:space="preserve">
          <source>Suspense</source>
          <target state="translated">Suspense</target>
        </trans-unit>
        <trans-unit id="a18d9f771ec11baec15e54073d783f488add33bd" translate="yes" xml:space="preserve">
          <source>Suspense API</source>
          <target state="translated">サスペンスAPI</target>
        </trans-unit>
        <trans-unit id="ac2887f41b70a20e517e2b034cd704e52c8fb68b" translate="yes" xml:space="preserve">
          <source>Suspense Reveal &amp;ldquo;Train&amp;rdquo;</source>
          <target state="translated">サスペンスは「電車」を明らかにする</target>
        </trans-unit>
        <trans-unit id="321f28f3a1ac7332ad69a67dae8b9247d8a85a04" translate="yes" xml:space="preserve">
          <source>Suspense SSR + Hydration</source>
          <target state="translated">サスペンスSSR+ハイドレーション</target>
        </trans-unit>
        <trans-unit id="81114a1c8b3333230f42d8c8600b93746352c08a" translate="yes" xml:space="preserve">
          <source>Suspense and Race Conditions</source>
          <target state="translated">サスペンスとレースの条件</target>
        </trans-unit>
        <trans-unit id="b82aa4510b7ffae21c24013d7b39f194e5aaa84e" translate="yes" xml:space="preserve">
          <source>Suspense answers some questions, but it also poses new questions of its own:</source>
          <target state="translated">サスペンスはいくつかの疑問に答えているが、それはまた、それ自体の新しい疑問を投げかけている。</target>
        </trans-unit>
        <trans-unit id="0668777af59a2bb3b94fb7bd2790a6a69182a367" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching</source>
          <target state="translated">データ取得のためのサスペンス</target>
        </trans-unit>
        <trans-unit id="17e3380602b04a7d645ea7631524d14d2b831868" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching (Experimental)</source>
          <target state="translated">データ取得のためのサスペンス(実験)</target>
        </trans-unit>
        <trans-unit id="693b7a99ad484ef032cfb982205ce455d09996b7" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching is a new feature that lets you also use &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; to &lt;strong&gt;declaratively &amp;ldquo;wait&amp;rdquo; for anything else, including data.&lt;/strong&gt; This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</source>
          <target state="translated">Suspense for Data Fetchingは、 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; を使用して&lt;strong&gt;、データを含む他のもの&lt;/strong&gt;を&lt;strong&gt;宣言的に「待機」&lt;/strong&gt;することができる新機能です&lt;strong&gt;。&lt;/strong&gt;このページでは、データ取得の使用例に焦点を当てていますが、画像、スクリプト、またはその他の非同期作業を待つこともできます。</target>
        </trans-unit>
        <trans-unit id="9b0d4cdaa1a76384c088f402a4f96d85a28531e2" translate="yes" xml:space="preserve">
          <source>Suspense is not a data fetching library. It&amp;rsquo;s a &lt;strong&gt;mechanism for data fetching libraries&lt;/strong&gt; to communicate to React that &lt;em&gt;the data a component is reading is not ready yet&lt;/em&gt;. React can then wait for it to be ready and update the UI. At Facebook, we use Relay and its &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;new Suspense integration&lt;/a&gt;. We expect that other libraries like Apollo can provide similar integrations.</source>
          <target state="translated">サスペンスはデータフェッチライブラリではありません。これは&lt;strong&gt;、データフェッチライブラリ&lt;/strong&gt;が&lt;em&gt;コンポーネントが読み取っ&lt;/em&gt;て&lt;em&gt;いるデータの準備ができていない&lt;/em&gt;ことをReactに通知する&lt;strong&gt;ため&lt;/strong&gt;の&lt;strong&gt;メカニズムです&lt;/strong&gt;。その後、Reactは準備が整うのを待ってUIを更新できます。Facebookでは、Relayとその&lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;新しいSuspense統合&lt;/a&gt;を使用しています。アポロのような他のライブラリが同様の統合を提供できることを期待しています。</target>
        </trans-unit>
        <trans-unit id="ae0fdcad1737c52adbeb2031aa8e91aa234309f3" translate="yes" xml:space="preserve">
          <source>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions. Let&amp;rsquo;s clarify the most common ones:</source>
          <target state="translated">サスペンスは、これらの問題に対する既存のアプローチとは大きく異なるため、初めてそれについて読むことはしばしば誤解につながります。最も一般的なものを明らかにしましょう：</target>
        </trans-unit>
        <trans-unit id="2300fe3099f2f4c3d641d1d53b84cabdafe3a65d" translate="yes" xml:space="preserve">
          <source>Suspense itself as a mechanism is flexible and doesn&amp;rsquo;t have many constraints. Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees. Some questions that we&amp;rsquo;re currently exploring include:</source>
          <target state="translated">メカニズムとしてのサスペンス自体は柔軟であり、多くの制約はありません。ウォーターフォールが発生しないようにするには、製品コードをさらに制約する必要がありますが、これらの保証を提供する方法はいくつかあります。現在調査中のいくつかの質問は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e0d14a0b49b6d0f702b2ffbbecd59f387529f76b" translate="yes" xml:space="preserve">
          <source>Suspense lets components &amp;ldquo;wait&amp;rdquo; for something before rendering. Today, Suspense only supports one use case: &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;loading components dynamically with &lt;code&gt;React.lazy&lt;/code&gt;&lt;/a&gt;. In the future, it will support other use cases like data fetching.</source>
          <target state="translated">サスペンスにより、コンポーネントはレンダリングの前に何かを「待つ」ことができます。現在、Suspenseは1つのユースケースのみをサポート&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;しています &lt;code&gt;React.lazy&lt;/code&gt; &lt;/a&gt;使用してコンポーネントを動的にロードすることです。将来的には、データのフェッチなどの他のユースケースもサポートする予定です。</target>
        </trans-unit>
        <trans-unit id="5cc08b841d3b9a32f5104a0898d01491b08aa477" translate="yes" xml:space="preserve">
          <source>Suspense lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render. In &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;this example&lt;/a&gt;, two components wait for an asynchronous API call to fetch some data:</source>
          <target state="translated">サスペンスは、コンポーネントがレンダリングする前に何かを「待つ」ことを可能にします。で&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;、この例で&lt;/a&gt;は、2つのコンポーネントは、いくつかのデータをフェッチするために、非同期API呼び出しを待ちます：</target>
        </trans-unit>
        <trans-unit id="597e77ccf0147ff1e0e95dbbfc0c166549395d98" translate="yes" xml:space="preserve">
          <source>SuspenseList</source>
          <target state="translated">SuspenseList</target>
        </trans-unit>
        <trans-unit id="f0933b54a50ee57a6c427ef3484a69b2e12b94de" translate="yes" xml:space="preserve">
          <source>SyntheticEvent</source>
          <target state="translated">SyntheticEvent</target>
        </trans-unit>
        <trans-unit id="eb94a49137dc3e1d46de143e47c86b9942e468c2" translate="yes" xml:space="preserve">
          <source>Teams with a strong focus on user experience sometimes solve similar problems with one-off solutions. However, those solutions rarely survive for a long time, as they&amp;rsquo;re hard to maintain. With Concurrent Mode, our goal is to bake the UI research findings into the abstraction itself, and provide idiomatic ways to use them. As a UI library, React is well-positioned to do that.</source>
          <target state="translated">ユーザーエクスペリエンスを重視するチームは、1回限りのソリューションで同様の問題を解決することがあります。ただし、これらのソリューションは、維持が困難であるため、長期間存続することはほとんどありません。コンカレントモードでは、UIの調査結果を抽象化自体に焼き付け、慣用的な方法でそれらを使用することを目的としています。UIライブラリとして、Reactはそのための適切な位置にあります。</target>
        </trans-unit>
        <trans-unit id="63c65f0a5afe770a42c1f536806bc2ba23c61729" translate="yes" xml:space="preserve">
          <source>Temporarily &lt;strong&gt;disable all Chrome extensions, especially React DevTools&lt;/strong&gt;. They can significantly skew the results!</source>
          <target state="translated">&lt;strong&gt;すべてのChrome拡張機能、特にReact DevToolsを&lt;/strong&gt;一時的に&lt;strong&gt;無効にします&lt;/strong&gt;。結果を大幅に歪める可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d9f45c513924550decb83eed63be6f6d9fd3fb5" translate="yes" xml:space="preserve">
          <source>Test Renderer</source>
          <target state="translated">テストレンダラ</target>
        </trans-unit>
        <trans-unit id="f9f882a7cfbac9fa3cff0ad94e26ffd24816fce8" translate="yes" xml:space="preserve">
          <source>Test Utilities</source>
          <target state="translated">ユーティリティのテスト</target>
        </trans-unit>
        <trans-unit id="ba890ac7eaae740a1397d738f471733e2031742f" translate="yes" xml:space="preserve">
          <source>Test runners</source>
          <target state="translated">テストランナー</target>
        </trans-unit>
        <trans-unit id="124162fb455da17f3c10873c994eb7025be9ae73" translate="yes" xml:space="preserve">
          <source>Test runners like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt; let you write test suites as regular JavaScript, and run them as part of your development process. Additionally, test suites are run as part of continuous integration.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;、&lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt;、&lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt;などのテストランナーを使用すると、テストスイートを通常のJavaScriptとして記述し、開発プロセスの一部として実行できます。さらに、テストスイートは継続的インテグレーションの一部として実行されます。</target>
        </trans-unit>
        <trans-unit id="df1ad36dfe1da6bac30d4a2122b6bbb6bcdc9305" translate="yes" xml:space="preserve">
          <source>TestInstance</source>
          <target state="translated">TestInstance</target>
        </trans-unit>
        <trans-unit id="0e69f126cac48a7e0d8d39281bf25ed113ce94ed" translate="yes" xml:space="preserve">
          <source>TestRenderer</source>
          <target state="translated">TestRenderer</target>
        </trans-unit>
        <trans-unit id="6cfd3bb51c904996890bb1730778d2a7efc233b6" translate="yes" xml:space="preserve">
          <source>TestRenderer instance</source>
          <target state="translated">TestRenderer インスタンス</target>
        </trans-unit>
        <trans-unit id="b4da10691865addeea2f1c653b85a8f1e0286f02" translate="yes" xml:space="preserve">
          <source>TestRenderer.act()</source>
          <target state="translated">TestRenderer.act()</target>
        </trans-unit>
        <trans-unit id="2e71b6a628eaf51262cd4d225cbcddbb76bb40a1" translate="yes" xml:space="preserve">
          <source>TestRenderer.create()</source>
          <target state="translated">TestRenderer.create()</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="12812e81c11031211b6dbe3caf13286f4d099fbc" translate="yes" xml:space="preserve">
          <source>Testing Environments</source>
          <target state="translated">テスト環境</target>
        </trans-unit>
        <trans-unit id="89b062a062bb5077e146efeebbb24fba0a676163" translate="yes" xml:space="preserve">
          <source>Testing Overview</source>
          <target state="translated">テストの概要</target>
        </trans-unit>
        <trans-unit id="d4f180c77cb6606396db8f6554504a4d8a6d0019" translate="yes" xml:space="preserve">
          <source>Testing Recipes</source>
          <target state="translated">レシピのテスト</target>
        </trans-unit>
        <trans-unit id="6cd6d80805fdc664e169392908689e2225952cde" translate="yes" xml:space="preserve">
          <source>Testing accessibility in the browser</source>
          <target state="translated">ブラウザでのアクセシビリティのテスト</target>
        </trans-unit>
        <trans-unit id="e77bc776e14ce1b3f92953a1505b14b5e8807a09" translate="yes" xml:space="preserve">
          <source>Testing with a screen reader should form part of your accessibility tests.</source>
          <target state="translated">スクリーン・リーダーを使用したテストは、アクセシビリティ・テストの一部として実施する必要があります。</target>
        </trans-unit>
        <trans-unit id="a38b0e5bfa5bb2618320d9e5309a34ceaea5d8a2" translate="yes" xml:space="preserve">
          <source>Testing your rate limiting</source>
          <target state="translated">レートを制限するテスト</target>
        </trans-unit>
        <trans-unit id="0ee7b58ebfe6f538de913f611a981507c709cfc5" translate="yes" xml:space="preserve">
          <source>Tests often run in an environment without access to a real rendering surface like a browser. For these environments, we recommend simulating a browser with &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;, a lightweight browser implementation that runs inside Node.js.</source>
          <target state="translated">テストは、ブラウザのような実際のレンダリングサーフェイスにアクセスしない環境で実行されることがよくあります。これらの環境では、Node.js内で実行される軽量のブラウザー実装である&lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; を&lt;/a&gt;使用してブラウザーをシミュレートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5360faacc2fd3e662f0f2d953eff4fe5f229a4dc" translate="yes" xml:space="preserve">
          <source>That means that with a version number &lt;strong&gt;x.y.z&lt;/strong&gt;:</source>
          <target state="translated">つまり、バージョン番号が&lt;strong&gt;xyzの場合&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="2572cbe643325f3e4047c805feaf04cce5e624d2" translate="yes" xml:space="preserve">
          <source>That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.</source>
          <target state="translated">とはいえ、このリストの変更がコミュニティに広範な問題を引き起こすことが予想される場合は、段階的な移行の道筋を提供できるように最善を尽くしていきたいと考えています。</target>
        </trans-unit>
        <trans-unit id="133f42dd430ef5bbc99318df87da28082b76ff20" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s It!</source>
          <target state="translated">それでおしまい！</target>
        </trans-unit>
        <trans-unit id="47cf34ef6f2d037d4305bba6dc055a53cc17f54f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;logProps&amp;rdquo; HOC passes all &lt;code&gt;props&lt;/code&gt; through to the component it wraps, so the rendered output will be the same. For example, we can use this HOC to log all props that get passed to our &amp;ldquo;fancy button&amp;rdquo; component:</source>
          <target state="translated">「logProps」HOCはすべての &lt;code&gt;props&lt;/code&gt; をラップするコンポーネントに渡すため、レンダリングされた出力は同じになります。たとえば、このHOCを使用して、「ファンシーボタン」コンポーネントに渡されるすべての小道具をログに記録できます。</target>
        </trans-unit>
        <trans-unit id="e338a1de1df09480e7fd8879427799044a4cefcc" translate="yes" xml:space="preserve">
          <source>The &amp;rdquo;+&amp;rdquo; and &amp;rdquo;-&amp;rdquo; buttons use the functional form, because the updated value is based on the previous value. But the &amp;ldquo;Reset&amp;rdquo; button uses the normal form, because it always sets the count back to the initial value.</source>
          <target state="translated">更新された値は前の値に基づいているため、「+」および「-」ボタンは関数形式を使用します。ただし、「リセット」ボタンは通常の形式を使用します。これは、常にカウントを初期値に戻すためです。</target>
        </trans-unit>
        <trans-unit id="2384cbfbef2aaecf2b1b1cef6cc143a819625453" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary&quot;&gt;glossary&lt;/a&gt; contains an overview of the most common terms you&amp;rsquo;ll see in the React documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including &lt;a href=&quot;faq-ajax&quot;&gt;making AJAX requests&lt;/a&gt;, &lt;a href=&quot;faq-state&quot;&gt;component state&lt;/a&gt;, and &lt;a href=&quot;faq-structure&quot;&gt;file structure&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary&quot;&gt;用語集は&lt;/a&gt;あなたがドキュメントを反応させるのに表示されます最も一般的な用語の概要が含まれています。また&lt;a href=&quot;faq-ajax&quot;&gt;、AJAXリクエストの作成&lt;/a&gt;、&lt;a href=&quot;faq-state&quot;&gt;コンポーネントの状態&lt;/a&gt;、&lt;a href=&quot;faq-structure&quot;&gt;ファイル構造&lt;/a&gt;など、一般的なトピックに関する短い質問と回答に特化したFAQセクションもあります。</target>
        </trans-unit>
        <trans-unit id="748db1aa2803f2dfcb93b31b6cbd612e4302e368" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook makes it easier to control when individual children update, reducing the need for pure components.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; の&lt;/a&gt;フックは、純粋な成分の必要性を減らす際に、個々の子どもの更新、それが簡単に制御することができます。</target>
        </trans-unit>
        <trans-unit id="d194b55aa0e5c4407ec3ef22a2a2374e9ad14f78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; used this example to get familiar with Hooks:</source>
          <target state="translated">&lt;a href=&quot;hooks-intro&quot;&gt;紹介ページには、&lt;/a&gt;フックに慣れるために、この例を使用しました：</target>
        </trans-unit>
        <trans-unit id="2346342023beadde66b62f9c79644b07c2e16dd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook lets you keep the same callback reference between re-renders so that &lt;code&gt;shouldComponentUpdate&lt;/code&gt; continues to work:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; の&lt;/a&gt;フックを使用すると、間で同じコールバック参照ように再レンダリングしておくことができます &lt;code&gt;shouldComponentUpdate&lt;/code&gt; が仕事に続けます。</target>
        </trans-unit>
        <trans-unit id="120d49be1a12891d545be48cefeee776b16e23c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook lets you cache calculations between multiple renders by &amp;ldquo;remembering&amp;rdquo; the previous computation:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usememo&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; の&lt;/a&gt;フックは、複数の「覚える」前回の演算によってレンダリングの間、あなたが計算をキャッシュすることができます：</target>
        </trans-unit>
        <trans-unit id="098a2975ef1c374c6d16cb1384320a5fa0b0dcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;array destructuring&lt;/a&gt; syntax lets us give different names to the state variables we declared by calling &lt;code&gt;useState&lt;/code&gt;. These names aren&amp;rsquo;t a part of the &lt;code&gt;useState&lt;/code&gt; API. Instead, React assumes that if you call &lt;code&gt;useState&lt;/code&gt; many times, you do it in the same order during every render. We&amp;rsquo;ll come back to why this works and when this is useful later.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;配列の非構造の&lt;/a&gt;構文は、私たちが呼び出すことで宣言した状態変数に異なる名前を付けることができます &lt;code&gt;useState&lt;/code&gt; を。これらの名前は、 &lt;code&gt;useState&lt;/code&gt; APIの一部ではありません。代わりに、Reactは、 &lt;code&gt;useState&lt;/code&gt; を何度も呼び出す場合、すべてのレンダリング中に同じ順序で行うと想定しています。なぜこれが機能するのか、いつ役立つのかは後で説明します。</target>
        </trans-unit>
        <trans-unit id="c1157f3e19fdd019adc6c8af16bcb7d469610ebc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; plugin compresses and mangles the final bundle.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt; &lt;code&gt;terser&lt;/code&gt; &lt;/a&gt;圧縮してマングル最終バンドルプラグイン。</target>
        </trans-unit>
        <trans-unit id="edcb883b6855822aeaaaf923c3ccb9c7db6aacae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint-plugin-jsx-a11y&lt;/a&gt; plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE&amp;rsquo;s allow you to integrate these findings directly into code analysis and source code windows.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint-プラグインJSX-a11yの&lt;/a&gt; ESLintためのプラグインは、あなたのJSXにおけるアクセシビリティの問題について、AST毛羽立ちのフィードバックを提供します。多くのIDEでは、これらの調査結果をコード分析やソースコードウィンドウに直接統合できます。</target>
        </trans-unit>
        <trans-unit id="466c527e21770fbc02c5b0d781265c63d3f2df55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;&lt;code&gt;envify&lt;/code&gt;&lt;/a&gt; transform ensures the right build environment is set. Make it global (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt; &lt;code&gt;envify&lt;/code&gt; &lt;/a&gt;変換性を保証は、右のビルド環境が設定されています。グローバルにします（ &lt;code&gt;-g&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="682e1228ae05401a65c58b0a5a7c5947327f9fa8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt;&lt;code&gt;uglifyify&lt;/code&gt;&lt;/a&gt; transform removes development imports. Make it global too (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt; &lt;code&gt;uglifyify&lt;/code&gt; &lt;/a&gt;削除し開発輸入を変換します。それもグローバルにします（ &lt;code&gt;-g&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d8ad55d9dccafa63caad67ca7c1eeabc211f835" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt;&lt;code&gt;commonjs&lt;/code&gt;&lt;/a&gt; plugin provides support for CommonJS in Rollup.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt; &lt;code&gt;commonjs&lt;/code&gt; &lt;/a&gt;プラグインはロールアップでCommonJSのサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="fec342ad3128435e51009a9f76d45133f8620021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt; plugin ensures the right build environment is set.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;プラグインは、右のビルド環境がセットであることを保証します。</target>
        </trans-unit>
        <trans-unit id="de89beb93569715dce635201036fc64e63c3ab03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/&quot;&gt;React homepage&lt;/a&gt; contains a few small React examples with a live editor. Even if you don&amp;rsquo;t know anything about React yet, try changing their code and see how it affects the result.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/&quot;&gt;ホームページが反応&lt;/a&gt;いくつかの小さなライブエディタでの例を反応させるのが含まれています。Reactについてまだ何も知らない場合でも、コードを変更して、それが結果にどのように影響するかを確認してください。</target>
        </trans-unit>
        <trans-unit id="974ac1c4a0c9da760228a943bce37428cd6a0e23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;React blog&lt;/a&gt; is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted there first.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;ブログが反応&lt;/a&gt;リアクトチームからのアップデートのための公式なソースです。リリースノートや非推奨の通知など、重要なものが最初に投稿されます。</target>
        </trans-unit>
        <trans-unit id="2ad57eeeea994127067368039363f4ff4d6702fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;Web Accessibility Evaluation Tool&lt;/a&gt; is another accessibility browser extension.</source>
          <target state="translated">&lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;ウェブアクセシビリティ評価ツールは&lt;/a&gt;、他のアクセシビリティのブラウザ拡張機能です。</target>
        </trans-unit>
        <trans-unit id="f83d6081d60ff040de57036c3c2ca925f0d22729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;Web Accessibility Initiative - Accessible Rich Internet Applications&lt;/a&gt; document contains techniques for building fully accessible JavaScript widgets.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;ウェブアクセシビリティイニシアティブ-アクセシブル・リッチ・インターネット・アプリケーションの&lt;/a&gt;文書は、完全にアクセスJavaScriptのウィジェットを構築するための技術が含まれています。</target>
        </trans-unit>
        <trans-unit id="54c94cd5415c60ee0381a2c958378a40eaeaf801" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Web Content Accessibility Guidelines&lt;/a&gt; provides guidelines for creating accessible web sites.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Webコンテンツアクセシビリティガイドラインは、&lt;/a&gt;アクセス可能なWebサイトを作成するためのガイドラインを提供します。</target>
        </trans-unit>
        <trans-unit id="71e5eefc03760deefaf5de6d0e50a96ab32f93bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing-recipes&quot;&gt;&lt;code&gt;recipes&lt;/code&gt;&lt;/a&gt; document contains more details on how &lt;code&gt;act()&lt;/code&gt; behaves, with examples and usage.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt; &lt;code&gt;recipes&lt;/code&gt; &lt;/a&gt;文書は方法の詳細が含まれ &lt;code&gt;act()&lt;/code&gt; の例と使用して、振舞います。</target>
        </trans-unit>
        <trans-unit id="93cd169de202dab7b3a7bc88a7d0ccacf3c3279a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Avatar&lt;/code&gt; doesn&amp;rsquo;t need to know that it is being rendered inside a &lt;code&gt;Comment&lt;/code&gt;. This is why we have given its prop a more generic name: &lt;code&gt;user&lt;/code&gt; rather than &lt;code&gt;author&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Avatar&lt;/code&gt; それが内部でレンダリングされていることを知っている必要はありません &lt;code&gt;Comment&lt;/code&gt; 。：これは、我々はその小道具より一般的な名前を与えている理由である &lt;code&gt;user&lt;/code&gt; ではなく、 &lt;code&gt;author&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a76f53d7593b26bd487b5056b04b9938d981554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FormattedDate&lt;/code&gt; component would receive the &lt;code&gt;date&lt;/code&gt; in its props and wouldn&amp;rsquo;t know whether it came from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s state, from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s props, or was typed by hand:</source>
          <target state="translated">&lt;code&gt;FormattedDate&lt;/code&gt; コンポーネントが受け取ることになる &lt;code&gt;date&lt;/code&gt; その小道具で、それがどこから来たかを知ることはできません &lt;code&gt;Clock&lt;/code&gt; の状態を、から &lt;code&gt;Clock&lt;/code&gt; の小道具、または手動で入力しました。</target>
        </trans-unit>
        <trans-unit id="ef0d77ae8586dfacccde29ab8965e058f9cd57a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; measures how often a React application renders and what the &amp;ldquo;cost&amp;rdquo; of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimizations such as memoization&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 対策はどのように多くの場合、アプリケーションは、レンダリングとどのようなレンダリングの「コスト」が反応します。その目的は、低速で、&lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;メモ化などの最適化の&lt;/a&gt;恩恵を受ける可能性のあるアプリケーションの部分を識別するのを助けることです。</target>
        </trans-unit>
        <trans-unit id="ada4ac9d87ac916586daecc13fbb29890339bfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; requires an &lt;code&gt;onRender&lt;/code&gt; function as a prop. React calls this function any time a component within the profiled tree &amp;ldquo;commits&amp;rdquo; an update. It receives parameters describing what was rendered and how long it took.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 必要と &lt;code&gt;onRender&lt;/code&gt; 小道具としての機能を。プロファイルされたツリー内のコンポーネントが更新を「コミット」するたびに、Reactはこの関数を呼び出します。何がレンダリングされ、どのくらい時間がかかったかを表すパラメーターを受け取ります。</target>
        </trans-unit>
        <trans-unit id="135fecf5352f306a8ec799e1818c365ff3112c82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.Fragment&lt;/code&gt; component lets you return multiple elements in a &lt;code&gt;render()&lt;/code&gt; method without creating an additional DOM element:</source>
          <target state="translated">&lt;code&gt;React.Fragment&lt;/code&gt; のコンポーネントを使用すると、中に複数の要素を返すことができます &lt;code&gt;render()&lt;/code&gt; 追加のDOM要素を作成せずにメソッドを：</target>
        </trans-unit>
        <trans-unit id="bb92ce250ac6de4e11572565bd150102f2d8a162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.lazy&lt;/code&gt; function lets you render a dynamic import as a regular component.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; の機能を使用すると、通常のコンポーネントとして動的なインポートをレンダリングすることができます。</target>
        </trans-unit>
        <trans-unit id="edb6a31b8dfd687a65274464ad8c41bf13e449eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReactDOMServer&lt;/code&gt; object enables you to render components to static markup. Typically, it&amp;rsquo;s used on a Node server:</source>
          <target state="translated">&lt;code&gt;ReactDOMServer&lt;/code&gt; のオブジェクトは、静的なマークアップにコンポーネントをレンダリングすることができます。通常、Nodeサーバーで使用されます。</target>
        </trans-unit>
        <trans-unit id="9450751b918d37e1e6d5d17ecb9ef92dc4e90c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&lt;/code&gt; is pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&lt;/code&gt; がプールされています。つまり、イベントコールバックが呼び出された後、 &lt;code&gt;SyntheticEvent&lt;/code&gt; オブジェクトが再利用され、すべてのプロパティが無効になります。これはパフォーマンス上の理由によるものです。そのため、非同期の方法でイベントにアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="199347fbd83520bd3e789e3686528fa06113abd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; components of type &lt;code&gt;checkbox&lt;/code&gt; or &lt;code&gt;radio&lt;/code&gt;. You can use it to set whether the component is checked. This is useful for building controlled components. &lt;code&gt;defaultChecked&lt;/code&gt; is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.</source>
          <target state="translated">&lt;code&gt;checked&lt;/code&gt; 属性はによってサポートされている &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 型のコンポーネント &lt;code&gt;checkbox&lt;/code&gt; や &lt;code&gt;radio&lt;/code&gt; 。これを使用して、コンポーネントをチェックするかどうかを設定できます。これは、制御されたコンポーネントの構築に役立ちます。 &lt;code&gt;defaultChecked&lt;/code&gt; は、コンポーネントが最初にマウントされるときにコンポーネントがチェックされるかどうかを設定する、制御されない同等のものです。</target>
        </trans-unit>
        <trans-unit id="b6728729851a5746fae29188678d79fa67af247b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentDidMount()&lt;/code&gt; method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</source>
          <target state="translated">&lt;code&gt;componentDidMount()&lt;/code&gt; 成分出力DOMにレンダリングされた後、方法は実行されます。これは、タイマーを設定するのに適した場所です。</target>
        </trans-unit>
        <trans-unit id="ed96963c77fb1890112f95b4829564475778ec4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compose&lt;/code&gt; utility function is provided by many third-party libraries including lodash (as &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt;&lt;code&gt;lodash.flowRight&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Redux&lt;/a&gt;, and &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 効用関数は、（AS lodash含む多くのサードパーティライブラリによって提供される&lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt; &lt;code&gt;lodash.flowRight&lt;/code&gt; &lt;/a&gt;）&lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Reduxの&lt;/a&gt;、及び&lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;RAMDA&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e04791f8bce0f48514a481f8e96c984420b6e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contextType&lt;/code&gt; property on a class can be assigned a Context object created by &lt;a href=&quot;#reactcreatecontext&quot;&gt;&lt;code&gt;React.createContext()&lt;/code&gt;&lt;/a&gt;. This lets you consume the nearest current value of that Context type using &lt;code&gt;this.context&lt;/code&gt;. You can reference this in any of the lifecycle methods including the render function.</source>
          <target state="translated">クラスの &lt;code&gt;contextType&lt;/code&gt; プロパティには、&lt;a href=&quot;#reactcreatecontext&quot;&gt; &lt;code&gt;React.createContext()&lt;/code&gt; &lt;/a&gt;によって作成されたContextオブジェクトを割り当てることができます。これにより、 &lt;code&gt;this.context&lt;/code&gt; を使用して、そのContextタイプの最も近い現在の値を使用できます。これは、render関数を含む任意のライフサイクルメソッドで参照できます。</target>
        </trans-unit>
        <trans-unit id="cccbfd6e53da65ebc9b175cdb8162582789149dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultProps&lt;/code&gt; will be used to ensure that &lt;code&gt;this.props.name&lt;/code&gt; will have a value if it was not specified by the parent component. The &lt;code&gt;propTypes&lt;/code&gt; typechecking happens after &lt;code&gt;defaultProps&lt;/code&gt; are resolved, so typechecking will also apply to the &lt;code&gt;defaultProps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; はことを保証するために使用されます &lt;code&gt;this.props.name&lt;/code&gt; はそれが親コンポーネントで指定されていない場合は、値を持つことになります。 &lt;code&gt;propTypes&lt;/code&gt; の後に型チェックが起こる &lt;code&gt;defaultProps&lt;/code&gt; が解決される型チェックもに適用されますので、 &lt;code&gt;defaultProps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ee13fb806f9e8f23f14548fbcf1c0937a20a5c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultValue&lt;/code&gt; argument is &lt;strong&gt;only&lt;/strong&gt; used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing &lt;code&gt;undefined&lt;/code&gt; as a Provider value does not cause consuming components to use &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;defaultValue&lt;/code&gt; の引数はされ&lt;strong&gt;のみ&lt;/strong&gt;コンポーネントは、ツリー内でそれ以上のマッチングプロバイダを持っていないときに使用されます。これは、コンポーネントをラップせずに分離してテストするのに役立ちます。注：プロバイダーの値として &lt;code&gt;undefined&lt;/code&gt; を渡しても、消費コンポーネントは &lt;code&gt;defaultValue&lt;/code&gt; を使用しません。</target>
        </trans-unit>
        <trans-unit id="6a777fc98bbd33659d037fd7c927c40043be8933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;displayName&lt;/code&gt; string is used in debugging messages. Usually, you don&amp;rsquo;t need to set it explicitly because it&amp;rsquo;s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;Wrap the Display Name for Easy Debugging&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;displayName&lt;/code&gt; 文字列は、メッセージのデバッグに使用されています。コンポーネントを定義する関数またはクラスの名前から推測されるため、通常は明示的に設定する必要はありません。デバッグのために別の名前を表示する場合、または高次コンポーネントを作成する場合は、明示的に設定することをお勧めします。詳細については&lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;、「簡単なデバッグの&lt;/a&gt;ために表示名をラップする」を参照してください。</target>
        </trans-unit>
        <trans-unit id="5f3264d4c6693710d81212483cd77491f03734f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallback&lt;/code&gt; prop accepts any React elements that you want to render while waiting for the component to load. You can place the &lt;code&gt;Suspense&lt;/code&gt; component anywhere above the lazy component. You can even wrap multiple lazy components with a single &lt;code&gt;Suspense&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; プロップはあなたが負荷にコンポーネントを待っている間にレンダリングしたいという要素に反応受け入れます。 &lt;code&gt;Suspense&lt;/code&gt; コンポーネントは、レイジーコンポーネントの上のどこにでも配置できます。複数の遅延コンポーネントを単一の &lt;code&gt;Suspense&lt;/code&gt; コンポーネントでラップすることもできます。</target>
        </trans-unit>
        <trans-unit id="3a87cab9efee0ca186ad1f9234f7af7e9b2e6f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getChildContext&lt;/code&gt; function will be called when the state or props changes. In order to update data in the context, trigger a local state update with &lt;code&gt;this.setState&lt;/code&gt;. This will trigger a new context and changes will be received by the children.</source>
          <target state="translated">&lt;code&gt;getChildContext&lt;/code&gt; の機能は、ときの状態や小道具の変更と呼ばれます。コンテキストでデータを更新するには、 &lt;code&gt;this.setState&lt;/code&gt; を使用してローカル状態更新をトリガーします。これにより、新しいコンテキストがトリガーされ、変更が子によって受け取られます。</target>
        </trans-unit>
        <trans-unit id="aec1e744f364f63f5ad699d9c279366bd3b643fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component calls &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; with the new desired value. Its props, including &lt;code&gt;onTemperatureChange&lt;/code&gt;, were provided by its parent component, the &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの &lt;code&gt;handleChange&lt;/code&gt; メソッドは、 &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; を新しい目的の値で呼び出します。 &lt;code&gt;onTemperatureChange&lt;/code&gt; を含むその小道具は、その親コン​​ポーネントである &lt;code&gt;Calculator&lt;/code&gt; によって提供されました。</target>
        </trans-unit>
        <trans-unit id="210f25cbff1c57d320cf40f4827a05dd0f21c6f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialState&lt;/code&gt; argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:</source>
          <target state="translated">&lt;code&gt;initialState&lt;/code&gt; 引数は、最初のレンダリング時に使用される状態です。以降のレンダリングでは、無視されます。初期状態が負荷の高い計算の結果である場合は、代わりに関数を提供できます。これは、初期レンダリングでのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="a4b380ee4d5e3b1bd645f3f0bfab036ddd24f72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isPending&lt;/code&gt; boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; のブール値は、前のプロフィールページにいくつかのロードテキストを示すことによって、ユーザはこのことを知っているようすることができますので、私たちのコンポーネントが移行していることを知っていると反応することができます。</target>
        </trans-unit>
        <trans-unit id="cd1395ba5aab1721b29879ffafc1520cf2ef8732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; property can take any of the values documented in the &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOM Level 3 Events spec&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; プロパティはで文書の任意の値とることができ&lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOMレベル3イベント仕様を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50b803bb4c9f45c5004b2f4b0708f76ae97a29fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name !== ''&lt;/code&gt; condition is &lt;code&gt;true&lt;/code&gt; on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition &lt;code&gt;false&lt;/code&gt;. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:</source>
          <target state="translated">&lt;code&gt;name !== ''&lt;/code&gt; 条件がある &lt;code&gt;true&lt;/code&gt; 私たちは、このフックを実行するので、最初のレンダリングに。ただし、次のレンダリングでは、ユーザーがフォームをクリアして、条件を &lt;code&gt;false&lt;/code&gt; にする場合があります。レンダリング中にこのフックをスキップしたので、フック呼び出しの順序は異なります。</target>
        </trans-unit>
        <trans-unit id="f85476d3988e9bdfdd3e540a4ed2f05b110634e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onBlur&lt;/code&gt; event handler is called when focus has left the element (or left some element inside of it). For example, it&amp;rsquo;s called when the user clicks outside of a focused text input.</source>
          <target state="translated">&lt;code&gt;onBlur&lt;/code&gt; イベントのフォーカスが要素を左（またはその一部の要素の内側を左）したときに、イベントハンドラが呼び出されます。たとえば、ユーザーがフォーカスされたテキスト入力の外側をクリックしたときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a2f669e76a5881578195b4cedc603f344983fd17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onChange&lt;/code&gt; event behaves as you would expect it to: whenever a form field is changed, this event is fired. We intentionally do not use the existing browser behavior because &lt;code&gt;onChange&lt;/code&gt; is a misnomer for its behavior and React relies on this event to handle user input in real time.</source>
          <target state="translated">&lt;code&gt;onChange&lt;/code&gt; イベント振る舞うあなたはそれを期待通り：フォームフィールドが変更されるたびに、このイベントが発生しています。 &lt;code&gt;onChange&lt;/code&gt; はその動作の誤称であり、Reactはこのイベントに依存してリアルタイムでユーザー入力を処理するため、既存のブラウザー動作を意図的に使用しません。</target>
        </trans-unit>
        <trans-unit id="d9df1c231344463418878f550484397733c07805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onFocus&lt;/code&gt; event is called when the element (or some element inside of it) receives focus. For example, it&amp;rsquo;s called when the user clicks on a text input.</source>
          <target state="translated">&lt;code&gt;onFocus&lt;/code&gt; 要素（またはその内部いくつかの要素）がフォーカスを受け取ると、イベントが呼び出されます。たとえば、ユーザーがテキスト入力をクリックしたときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="94e4f5de13553781365d91a92540227537125ed7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onMouseEnter&lt;/code&gt; and &lt;code&gt;onMouseLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">&lt;code&gt;onMouseEnter&lt;/code&gt; と &lt;code&gt;onMouseLeave&lt;/code&gt; イベントではなく、通常のバブリングで入力されると、キャプチャフェーズを持っていないものに残される要素から伝播します。</target>
        </trans-unit>
        <trans-unit id="cf02d54b18eb7e4b7f6b5f2f59bf6af62f2393be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onPointerEnter&lt;/code&gt; and &lt;code&gt;onPointerLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">&lt;code&gt;onPointerEnter&lt;/code&gt; と &lt;code&gt;onPointerLeave&lt;/code&gt; イベントではなく、通常のバブリングで入力されると、キャプチャフェーズを持っていないものに残される要素から伝播します。</target>
        </trans-unit>
        <trans-unit id="674e5d12b6df14f94e34397b4ed6ffef33e647e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onTemperatureChange&lt;/code&gt; prop will be provided together with the &lt;code&gt;temperature&lt;/code&gt; prop by the parent &lt;code&gt;Calculator&lt;/code&gt; component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new &lt;code&gt;Calculator&lt;/code&gt; implementation very soon.</source>
          <target state="translated">&lt;code&gt;onTemperatureChange&lt;/code&gt; の小道具は、一緒に提供される &lt;code&gt;temperature&lt;/code&gt; 親によってプロップ &lt;code&gt;Calculator&lt;/code&gt; コンポーネント。自身のローカル状態を変更することで変更を処理し、両方の入力を新しい値で再レンダリングします。新しい &lt;code&gt;Calculator&lt;/code&gt; 実装については、間もなく見ていきます。</target>
        </trans-unit>
        <trans-unit id="d719b7a2d158d7590b77512a3cf13bd01ac52e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-dom&lt;/code&gt; package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</source>
          <target state="translated">&lt;code&gt;react-dom&lt;/code&gt; パッケージには、あなたがする必要がある場合はリアクトモデルの外を得るためにあなたのアプリのトップレベルでエスケープハッチとして使用することができますDOM固有のメソッドを提供します。ほとんどのコンポーネントでは、このモジュールを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="bed13105d59f319bf16f5451f3a730147d671056" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; function should be pure, meaning that it does not modify component state, it returns the same result each time it&amp;rsquo;s invoked, and it does not directly interact with the browser.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 関数は、コンポーネントの状態を変更しないことを意味し、純粋である必要があり、それは同じ結果にそれが呼び出されるたびに返され、それがブラウザで直接相互作用しません。</target>
        </trans-unit>
        <trans-unit id="0a3390f73827da0e30d1b704469d47775415fc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; method is the only required method in a class component.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; メソッドは、クラスコンポーネントにのみ必要な方法です。</target>
        </trans-unit>
        <trans-unit id="481c653efaf41fafb96ad006f60184c54f2b1c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="54fcb9f91c38f310283c2df0f37ef88cd13c8c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method will be called each time an update happens, but as long as we render &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; into the same DOM node, only a single instance of the &lt;code&gt;Clock&lt;/code&gt; class will be used. This lets us use additional features such as local state and lifecycle methods.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 方法は、更新が起こるたびに呼び出されますが、長い我々はレンダリングのように &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 同じDOMノードへの単一インスタンスのみ &lt;code&gt;Clock&lt;/code&gt; クラスが使用されます。これにより、ローカル状態やライフサイクルメソッドなどの追加機能を使用できます。</target>
        </trans-unit>
        <trans-unit id="71aa8e04c24836138e98c85afaa8c4097328724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; option means that the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes inside this list &lt;strong&gt;will only &amp;ldquo;reveal&amp;rdquo; their content in the order they appear in the tree &amp;mdash; even if the data for them arrives in a different order&lt;/strong&gt;. &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; has other interesting modes: try changing &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; to &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; or &lt;code&gt;&quot;together&quot;&lt;/code&gt; and see what happens.</source>
          <target state="translated">&lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; オプション手段最も近いことを &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; このリスト内のノードは&lt;strong&gt;彼らだけがツリーに表示される順序で、その内容を「明らかに」なります-それらのデータは異なる順序で到着した場合でも&lt;/strong&gt;。 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; には他にも興味深いモードがあります。 &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; を &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; または &lt;code&gt;&quot;together&quot;&lt;/code&gt; 、何が起こるかを確認してください。</target>
        </trans-unit>
        <trans-unit id="107dbf68568c2380480dc053ea5bfc5ee8072aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selected&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; components. You can use it to set whether the component is selected. This is useful for building controlled components.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 属性がによってサポートされている &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; コンポーネント。これを使用して、コンポーネントを選択するかどうかを設定できます。これは、制御されたコンポーネントの構築に役立ちます。</target>
        </trans-unit>
        <trans-unit id="203b22e021419cba17f499d4cb5572448638f462" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setState&lt;/code&gt; function is used to update the state. It accepts a new state value and enqueues a re-render of the component.</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 関数は状態を更新するために使用されます。新しい状態値を受け入れ、コンポーネントの再レンダリングをキューに入れます。</target>
        </trans-unit>
        <trans-unit id="357dff3065dc86ea9f744a876b9ab8c50c2ae184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;style&lt;/code&gt; attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM &lt;code&gt;style&lt;/code&gt; JavaScript property, is more efficient, and prevents XSS security holes. For example:</source>
          <target state="translated">&lt;code&gt;style&lt;/code&gt; 属性はcamelCase形式のプロパティを持つJavaScriptオブジェクトではなく、CSSの文字列を受け付けます。これは、DOM &lt;code&gt;style&lt;/code&gt; JavaScriptプロパティと一貫性があり、より効率的で、XSSセキュリティホールを防ぎます。例えば：</target>
        </trans-unit>
        <trans-unit id="8bc5e56642dd04f2aba447e6f924682226c0df90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useTransition&lt;/code&gt; hook returns two values in an array.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; のフックは、アレイ内の2つの値を返します。</target>
        </trans-unit>
        <trans-unit id="7e1f703ed3eb58b4b8f113ebc5568614f8d4fd8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 属性はによってサポートされている &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; コンポーネント。これを使用して、コンポーネントの値を設定できます。これは、制御されたコンポーネントの構築に役立ちます。 &lt;code&gt;defaultValue&lt;/code&gt; は、コンポーネントが最初にマウントされるときにコンポーネントの値を設定する、制御されない同等のものです。</target>
        </trans-unit>
        <trans-unit id="3b3a8f7885d22f578c1eb0f567738d06ed793b6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 属性によってサポートされている &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; コンポーネントを。これを使用して、コンポーネントの値を設定できます。これは、制御されたコンポーネントを構築するのに役立ちます。 &lt;code&gt;defaultValue&lt;/code&gt; は制御されていない同等物であり、最初にマウントされたときのコンポーネントの値を設定します。</target>
        </trans-unit>
        <trans-unit id="3f3679e38fe474c4819ac2803806e3be80472bfc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Effect Hook&lt;/em&gt; lets you perform side effects in function components:</source>
          <target state="translated">&lt;em&gt;エフェクトフックを&lt;/em&gt;使用すると、機能部品に副作用を実行することができます：</target>
        </trans-unit>
        <trans-unit id="a9385e3f6becba3f891272f25765e8d4da17eddd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commit&lt;/strong&gt; phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) React also calls lifecycles like &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt; during this phase.</source>
          <target state="translated">&lt;strong&gt;コミット&lt;/strong&gt;変更を適用し反応するとフェーズがあります。（React DOMの場合、これは、ReactがDOMノードを挿入、更新、および削除するときです。）Reactは、このフェーズ中に、 &lt;code&gt;componentDidMount&lt;/code&gt; や &lt;code&gt;componentDidUpdate&lt;/code&gt; などのライフサイクルも呼び出します。</target>
        </trans-unit>
        <trans-unit id="c328cac95d0c017f1f700cb3a749d7591b80a4e4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;render&lt;/strong&gt; phase determines what changes need to be made to e.g. the DOM. During this phase, React calls &lt;code&gt;render&lt;/code&gt; and then compares the result to the previous render.</source>
          <target state="translated">&lt;strong&gt;レンダリング&lt;/strong&gt;フェーズは、DOMを例えばようにすることの必要性を変更するかを決定します。このフェーズでは、Reactが &lt;code&gt;render&lt;/code&gt; を呼び出し、その結果を前のレンダーと比較します。</target>
        </trans-unit>
        <trans-unit id="874a87db1393bc286872f5465f37d25df7ac77ad" translate="yes" xml:space="preserve">
          <source>The API call duration in this example is randomized. If you keep refreshing it, you will notice that sometimes the posts arrive first, and sometimes the &amp;ldquo;fun facts&amp;rdquo; arrive first.</source>
          <target state="translated">この例のAPI呼び出し時間はランダム化されています。更新し続けると、投稿が先に届く場合と、「面白い事実」が先に届く場合があります。</target>
        </trans-unit>
        <trans-unit id="1f489e901fd1aa4d117bab0e4b0d39576560ff5b" translate="yes" xml:space="preserve">
          <source>The API of ES6 classes is similar to &lt;code&gt;createReactClass()&lt;/code&gt; with a few exceptions.</source>
          <target state="translated">ES6クラスのAPIは、いくつかの例外を除いて &lt;code&gt;createReactClass()&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">コンポーネントのライフサイクル</target>
        </trans-unit>
        <trans-unit id="21bf04493983dc2ff15309868ae4a25193bad67d" translate="yes" xml:space="preserve">
          <source>The Data Flows Down</source>
          <target state="translated">データは下に流れる</target>
        </trans-unit>
        <trans-unit id="616776b2c6e2444aea1e5faa27917853b1c7f97e" translate="yes" xml:space="preserve">
          <source>The Diffing Algorithm</source>
          <target state="translated">ディフィングアルゴリズム</target>
        </trans-unit>
        <trans-unit id="c5491cfca6b82c27502e045c3ec98fc3838da8d2" translate="yes" xml:space="preserve">
          <source>The Effect Hook unifies both use cases with a single API.</source>
          <target state="translated">Effect Hookは、両方のユースケースを単一のAPIで統一します。</target>
        </trans-unit>
        <trans-unit id="1612e741e93d1c692496ad71dfcff5baab42464f" translate="yes" xml:space="preserve">
          <source>The Effect Hook, &lt;code&gt;useEffect&lt;/code&gt;, adds the ability to perform side effects from a function component. It serves the same purpose as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; in React classes, but unified into a single API. (We&amp;rsquo;ll show examples comparing &lt;code&gt;useEffect&lt;/code&gt; to these methods in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">エフェクトフック &lt;code&gt;useEffect&lt;/code&gt; は、関数コンポーネントから副作用を実行する機能を追加します。Reactクラスの &lt;code&gt;componentDidMount&lt;/code&gt; 、 &lt;code&gt;componentDidUpdate&lt;/code&gt; 、および &lt;code&gt;componentWillUnmount&lt;/code&gt; と同じ目的を果たしますが、単一のAPIに統合されます。（ &lt;code&gt;useEffect&lt;/code&gt; をこれらのメソッドと比較する例&lt;a href=&quot;hooks-effect&quot;&gt;は、エフェクトフックの使用で&lt;/a&gt;示します。）</target>
        </trans-unit>
        <trans-unit id="124aae01ad58b7e1a4ee8c92047de4631d765919" translate="yes" xml:space="preserve">
          <source>The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostaticmarkup&quot;&gt;&lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt;&lt;/a&gt; would return.</source>
          <target state="translated">このストリームによるHTML出力は、&lt;a href=&quot;#rendertostaticmarkup&quot;&gt; &lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt; &lt;/a&gt;が返すものとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="3b58a9fba5b1ef8c2e9715e61380a0bbdc5a87e1" translate="yes" xml:space="preserve">
          <source>The Next channel is a prerelease channel that tracks the master branch of the React repository. We use prereleases in the Next channel as release candidates for the Latest channel. You can think of Next as a superset of Latest that is updated more frequently.</source>
          <target state="translated">Next チャンネルは、React リポジトリのマスターブランチを追跡するプレリリースチャンネルです。Next チャンネルのプレリリースは、Latest チャンネルのリリース候補として使用します。Next は、より頻繁に更新される Latest のスーパーセットと考えることができます。</target>
        </trans-unit>
        <trans-unit id="737fdcd14ec762266f15547050e6808527354f7e" translate="yes" xml:space="preserve">
          <source>The Next channel is designed to support integration testing between React and other projects.</source>
          <target state="translated">Nextチャンネルは、Reactと他のプロジェクト間の統合テストをサポートするために設計されています。</target>
        </trans-unit>
        <trans-unit id="b3ed94c8d360c8d9c494a2ca722d37e49ce3e6ed" translate="yes" xml:space="preserve">
          <source>The Paciello Group - Color Contrast Analyzer</source>
          <target state="translated">Pacielloグループ-カラーコントラストアナライザ</target>
        </trans-unit>
        <trans-unit id="089acaacdb35dc83d6617b2cd65a862a39e1490f" translate="yes" xml:space="preserve">
          <source>The Paciello Group explains accessible names</source>
          <target state="translated">Pacielloグループは、アクセス可能な名前を説明しています。</target>
        </trans-unit>
        <trans-unit id="b6ecb4067f5d6149e2462ed2c6f4975edca53137" translate="yes" xml:space="preserve">
          <source>The Power Of Not Mutating Data</source>
          <target state="translated">データを変異させない力</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">問題点</target>
        </trans-unit>
        <trans-unit id="892213a47fde12815f3b55308a07c21a28514331" translate="yes" xml:space="preserve">
          <source>The Provider component accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="translated">プロバイダーコンポーネントは、このプロバイダーの子孫である消費コンポーネントに渡される &lt;code&gt;value&lt;/code&gt; プロップを受け入れます。1つのプロバイダーを多くのコンシューマーに接続できます。プロバイダーをネストして、ツリー内のより深い値をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="26e24b6b93e7419bc0e50a40347349c779318865" translate="yes" xml:space="preserve">
          <source>The React documentation assumes some familiarity with programming in the JavaScript language. You don&amp;rsquo;t have to be an expert, but it&amp;rsquo;s harder to learn both React and JavaScript at the same time.</source>
          <target state="translated">Reactのドキュメントは、JavaScript言語でのプログラミングにある程度の知識があることを前提としています。エキスパートである必要はありませんが、ReactとJavaScriptの両方を同時に学ぶことは困難です。</target>
        </trans-unit>
        <trans-unit id="0fd3ac585dc50ef7294c9de3e83e35480b26454b" translate="yes" xml:space="preserve">
          <source>The React team primarily recommends these solutions:</source>
          <target state="translated">Reactチームは主にこれらのソリューションを推奨しています。</target>
        </trans-unit>
        <trans-unit id="ba2f4b1bedd474c3014f164a2122303c060ccb81" translate="yes" xml:space="preserve">
          <source>The Receded state doesn&amp;rsquo;t feel very nice because it hides existing content.</source>
          <target state="translated">後退状態は、既存のコンテンツを非表示にするため、あまり気分が良くありません。</target>
        </trans-unit>
        <trans-unit id="1f929f091bc2ce827e8bf4c5ed48e578b25c2e1c" translate="yes" xml:space="preserve">
          <source>The Three Steps</source>
          <target state="translated">三つのステップ</target>
        </trans-unit>
        <trans-unit id="e6a086f204eb46311763e005551391b5b863e8b8" translate="yes" xml:space="preserve">
          <source>The W3C demonstrates user notifications</source>
          <target state="translated">W3Cは、ユーザー通知を実証しています。</target>
        </trans-unit>
        <trans-unit id="a94514ea6fcc374a0e4ec5a9365c3dabf4e39fbb" translate="yes" xml:space="preserve">
          <source>The W3C shows us how to label elements</source>
          <target state="translated">W3Cは、要素にラベルを付ける方法を示しています。</target>
        </trans-unit>
        <trans-unit id="94dcda409aa812a420ab1cfa14badcf0b13d6d3b" translate="yes" xml:space="preserve">
          <source>The above two components are equivalent from React&amp;rsquo;s point of view.</source>
          <target state="translated">上記の2つのコンポーネントは、Reactの観点からは同等です。</target>
        </trans-unit>
        <trans-unit id="37cd269b859b44611e84ee5db5c7b9f522b36e09" translate="yes" xml:space="preserve">
          <source>The above two lines are equivalent, and use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">上記の2行は同等であり、それぞれ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;矢印関数&lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="215acedeed5a2bd97d915656e07e386e37862aa8" translate="yes" xml:space="preserve">
          <source>The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven&amp;rsquo;t found this to be an issue.</source>
          <target state="translated">アルゴリズムは、異なるコンポーネントタイプのサブツリーを照合しようとしません。出力が非常に似ている2つのコンポーネントタイプが交互に表示される場合は、同じタイプにすることができます。実際には、これが問題になることはありません。</target>
        </trans-unit>
        <trans-unit id="d4d34ce90ceca5ceb82456075b266e3c7316fc14" translate="yes" xml:space="preserve">
          <source>The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It&amp;rsquo;s especially regrettable if the original fix is for a bug that is rarely encountered in practice.</source>
          <target state="translated">答えは、React（または他のソフトウェア）に変更を加えると、予期しない方法で壊れるリスクがあることです。あるバグを修正するパッチリリースが誤って別のバグを導入するシナリオを想像してみてください。これは、開発者に混乱をもたらすだけでなく、将来のパッチリリースに対する開発者の信頼を損なうことにもなります。元の修正が実際にはほとんど発生しないバグに対するものである場合は、特に残念です。</target>
        </trans-unit>
        <trans-unit id="e635eec21597077475b644c681e965353535e3c4" translate="yes" xml:space="preserve">
          <source>The answer to this problem &lt;strong&gt;is to split the state in two parts:&lt;/strong&gt; a &amp;ldquo;high priority&amp;rdquo; part that updates immediately, and a &amp;ldquo;low priority&amp;rdquo; part that may wait for a transition.</source>
          <target state="translated">この問題に対する答え&lt;strong&gt;は、状態を2つの部分に分割する&lt;/strong&gt;こと&lt;strong&gt;です。&lt;/strong&gt;「優先度が高い」部分はすぐに更新され、「優先度が低い」部分は遷移を待つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="a7a38c075e6a3910c420e7a01266e74d7df6ccf8" translate="yes" xml:space="preserve">
          <source>The approach above requires your React components to be aware of the Backbone models and collections. If you later plan to migrate to another data management solution, you might want to concentrate the knowledge about Backbone in as few parts of the code as possible.</source>
          <target state="translated">上記のアプローチでは、ReactコンポーネントがBackboneのモデルとコレクションを認識している必要があります。後で別のデータ管理ソリューションへの移行を計画している場合は、コードのできるだけ少ない部分にBackboneに関する知識を集中させた方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="c20f69e03e2db102e3ca9bf7104bb1da944732c2" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the callback. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">依存関係の配列は、引数としてコールバックに渡されません。ただし、概念的には、それがそれらを表します。コールバック内で参照されるすべての値は、依存関係配列にも表示される必要があります。将来的には、十分に高度なコンパイラがこの配列を自動的に作成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e2478d3374b94309b968843a77f28e2fb9c9b3b9" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the effect function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">依存関係の配列は、引数としてエフェクト関数に渡されません。ただし、概念的には、それが表現するものです。エフェクト関数内で参照されるすべての値は、依存関係配列にも表示される必要があります。将来的には、十分に高度なコンパイラがこの配列を自動的に作成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="029b5464ab1167d56107b8168f06ebc2ea8d2817" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">依存関係の配列は、引数として関数に渡されません。ただし、概念的には、それが表現するものです。関数内で参照されるすべての値は、依存関係配列にも表示される必要があります。将来的には、十分に高度なコンパイラがこの配列を自動的に作成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="7f143982715c022eb1b0b1e351548f58f45f5da7" translate="yes" xml:space="preserve">
          <source>The best way to introduce code-splitting into your app is through the dynamic &lt;code&gt;import()&lt;/code&gt; syntax.</source>
          <target state="translated">アプリにコード分割を導入する最良の方法は、動的 &lt;code&gt;import()&lt;/code&gt; 構文を使用することです。</target>
        </trans-unit>
        <trans-unit id="71f1b3c82a840e802e29fee64e41fc0cc4d94466" translate="yes" xml:space="preserve">
          <source>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</source>
          <target state="translated">キーを選択する最良の方法は、兄弟リストの中でリスト項目を一意に識別する文字列を使用することです。多くの場合、データのIDをキーとして使用します。</target>
        </trans-unit>
        <trans-unit id="ef94bfdedef023164021f6b1e4be76fc19c50903" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;act()&lt;/code&gt; will also flush the effects inside of them.</source>
          <target state="translated">&lt;code&gt;act()&lt;/code&gt; を呼び出すと、内部のエフェクトもフラッシュされます。</target>
        </trans-unit>
        <trans-unit id="556c1bcef07eebbaa4e004179e9cfd3eeb9f0fd9" translate="yes" xml:space="preserve">
          <source>The children test instances of this test instance.</source>
          <target state="translated">このテストインスタンスの子テストインスタンス。</target>
        </trans-unit>
        <trans-unit id="c6ef3d6c1361f3d575ce5bfd7aa23746e033615f" translate="yes" xml:space="preserve">
          <source>The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the &lt;strong&gt;previous effect is cleaned up before executing the next effect&lt;/strong&gt;. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.</source>
          <target state="translated">クリーンアップ機能は、コンポーネントがUIから削除される前に実行され、メモリリークを防止します。さらに、コンポーネントが複数回レンダリングされる場合（通常のように）、&lt;strong&gt;前の効果は次の効果を実行する前にクリーンアップされます&lt;/strong&gt;。この例では、更新ごとに新しいサブスクリプションが作成されます。すべての更新で効果が発生しないようにするには、次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a0d7a14266fbc4abca5b3a288ac51756a81b9c9a" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming async mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="translated">コミットフェーズは通常非常に高速ですが、レンダリングは遅くなることがあります。このため、来るべき非同期モード(デフォルトではまだ有効になっていません)では、ブラウザをブロックしないようにレンダリング作業を分割して一時停止したり再開したりします。これは、React がコミット前に複数回レンダリングフェーズのライフサイクルを呼び出すか、またはコミットせずに(エラーや優先度の高い中断のために)全く呼び出される可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="4da89e96ab9a876de60be2bee912c245e63ac6d3" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming concurrent mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="translated">コミットフェーズは通常非常に高速ですが、レンダリングは遅くなることがあります。このため、今後のコンカレントモード(デフォルトではまだ有効になっていません)では、レンダリング作業を分割し、ブラウザをブロックしないように作業を一時停止したり再開したりしています。これは、Reactがコミット前に複数回レンダリングフェーズのライフサイクルを呼び出すこともあれば、全くコミットせずに呼び出すこともあるということを意味します(エラーや優先度の高い中断が発生したため)。</target>
        </trans-unit>
        <trans-unit id="35d925f6ec4f8cdb5a9258d473e99341d40e0c29" translate="yes" xml:space="preserve">
          <source>The common owner component is &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">共通の所有者コンポーネントは &lt;code&gt;FilterableProductTable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a63c154dead70a08be6cc8e31aeac4618b4d14ed" translate="yes" xml:space="preserve">
          <source>The compiler is of no help to us until we tell it what to do. In TypeScript, these rules are defined in a special file called &lt;code&gt;tsconfig.json&lt;/code&gt;. To generate this file:</source>
          <target state="translated">コンパイラーは、何をすべきかを指示するまで役に立ちません。TypeScriptでは、これらのルールは &lt;code&gt;tsconfig.json&lt;/code&gt; と呼ばれる特別なファイルで定義されます。このファイルを生成するには：</target>
        </trans-unit>
        <trans-unit id="121cd37d21dcf9844e0b109d86b1a674e3ab8297" translate="yes" xml:space="preserve">
          <source>The complete implementation of the &lt;code&gt;Chosen&lt;/code&gt; component looks like this:</source>
          <target state="translated">&lt;code&gt;Chosen&lt;/code&gt; コンポーネントの完全な実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="b7fdbd63cb007ae3a70e4c0ab3cbfed9aceb771a" translate="yes" xml:space="preserve">
          <source>The component below demonstrates how to make an AJAX call in &lt;code&gt;componentDidMount&lt;/code&gt; to populate local component state.</source>
          <target state="translated">以下のコンポーネントは、 &lt;code&gt;componentDidMount&lt;/code&gt; で AJAX呼び出しを行ってローカルコンポーネントの状態を設定する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="1198438307a24068ab1bba755a37a1b96d2a22fd" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function.</source>
          <target state="translated">コンポーネントは、文字列、 &lt;code&gt;React.Component&lt;/code&gt; のサブクラス、またはプレーン関数のいずれかとして提供できます。</target>
        </trans-unit>
        <trans-unit id="da6ce7faf44f37b3dd8abfc2e0722acdb78a9da3" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, or as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function for stateless components.</source>
          <target state="translated">コンポーネントは、文字列として、または &lt;code&gt;React.Component&lt;/code&gt; のサブクラスとして、またはステートレスコンポーネントのプレーンな関数として提供できます。</target>
        </trans-unit>
        <trans-unit id="7be5cec66fa7af4738a87fd4dc3bac4a3b9e7f65" translate="yes" xml:space="preserve">
          <source>The component instance corresponding to this test instance. It is only available for class components, as function components don&amp;rsquo;t have instances. It matches the &lt;code&gt;this&lt;/code&gt; value inside the given component.</source>
          <target state="translated">このテストインスタンスに対応するコンポーネントインスタンス。関数コンポーネントにはインスタンスがないため、クラスコンポーネントでのみ使用できます。指定されたコンポーネント内の &lt;code&gt;this&lt;/code&gt; 値と一致します。</target>
        </trans-unit>
        <trans-unit id="1c518ce84f1f2ec0768b9431ff8843a33c87e2e0" translate="yes" xml:space="preserve">
          <source>The component type corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; component has a type of &lt;code&gt;Button&lt;/code&gt;.</source>
          <target state="translated">このテストインスタンスに対応するコンポーネントタイプ。たとえば、 &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; コンポーネントにはタイプ &lt;code&gt;Button&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="8a0029f3f238b96fbe9f5f708c5daccae03c6952" translate="yes" xml:space="preserve">
          <source>The constructor for a React component is called before it is mounted. When implementing the constructor for a &lt;code&gt;React.Component&lt;/code&gt; subclass, you should call &lt;code&gt;super(props)&lt;/code&gt; before any other statement. Otherwise, &lt;code&gt;this.props&lt;/code&gt; will be undefined in the constructor, which can lead to bugs.</source>
          <target state="translated">Reactコンポーネントのコンストラクターは、マウントされる前に呼び出されます。 &lt;code&gt;React.Component&lt;/code&gt; サブクラスのコンストラクターを実装する場合、他のステートメントの前に &lt;code&gt;super(props)&lt;/code&gt; を呼び出す必要があります。そうしないと、 &lt;code&gt;this.props&lt;/code&gt; がコンストラクターで定義されなくなり、バグが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="16c0031304d2df9c111be15322f423f7290b0447" translate="yes" xml:space="preserve">
          <source>The container components created by HOCs show up in the &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; like any other component. To ease debugging, choose a display name that communicates that it&amp;rsquo;s the result of a HOC.</source>
          <target state="translated">HOCによって作成されたコンテナーコンポーネントは、他のコンポーネントと同様に&lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Toolsに&lt;/a&gt;表示されます。デバッグを容易にするために、HOCの結果であることを伝える表示名を選択します。</target>
        </trans-unit>
        <trans-unit id="f005497689e0366001c3fb7c5e6cf6a2f89e046f" translate="yes" xml:space="preserve">
          <source>The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.</source>
          <target state="translated">エフェクトのデフォルトの動作は、レンダリングが完了するたびにエフェクトを起動することです。この方法では、依存関係のいずれかが変更された場合、エフェクトは常に再作成されます。</target>
        </trans-unit>
        <trans-unit id="a9abe7524edac0d7bf58996697456382aebf41d4" translate="yes" xml:space="preserve">
          <source>The definition of a &amp;ldquo;feature&amp;rdquo; is not universal, and it is up to you to choose the granularity. If you can&amp;rsquo;t come up with a list of top-level folders, you can ask the users of your product what major parts it consists of, and use their mental model as a blueprint.</source>
          <target state="translated">「機能」の定義は普遍的ではなく、粒度を選択するのはユーザー次第です。トップレベルのフォルダーのリストが思いつかない場合は、製品のユーザーにそれがどの主要部品で構成されているかを尋ね、そのメンタルモデルを青写真として使用できます。</target>
        </trans-unit>
        <trans-unit id="727f035106e7c393c4cb029a45dec8da874d352f" translate="yes" xml:space="preserve">
          <source>The degree of change between the most recent Next release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, &lt;strong&gt;the Next channel does not conform to semantic versioning.&lt;/strong&gt; You should expect occasional breaking changes between successive releases in the Next channel.</source>
          <target state="translated">最新の次のリリースと最新の最新のリリースとの間の変更の程度は、2つのマイナーサーバーリリース間で見られる程度とほぼ同じです。ただし、&lt;strong&gt;次のチャネルはセマンティックバージョニングに準拠していません。&lt;/strong&gt;Nextチャネルの連続するリリース間で、ときどき重大な変更が行われることを期待する必要があります。</target>
        </trans-unit>
        <trans-unit id="11c828ed161f8e904365be750c1b6b190b0b36c6" translate="yes" xml:space="preserve">
          <source>The developer can hint at which child elements may be stable across different renders with a &lt;code&gt;key&lt;/code&gt; prop.</source>
          <target state="translated">開発者は、 &lt;code&gt;key&lt;/code&gt; プロップを使用して、さまざまなレンダリング間でどの子要素が安定しているかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="90fce0d3e59b886792d5aea4491610c01d3638de" translate="yes" xml:space="preserve">
          <source>The easiest way to avoid conflicts is to prevent the React component from updating. You can do this by rendering elements that React has no reason to update, like an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">競合を回避する最も簡単な方法は、Reactコンポーネントが更新されないようにすることです。これを行うには、空の &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; のように、Reactが更新する必要のない要素をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="039378bb9c3350b891bbb97f95519708b2e90b22" translate="yes" xml:space="preserve">
          <source>The empty set of dependencies, &lt;code&gt;[]&lt;/code&gt;, means that the effect will only run once when the component mounts, and not on every re-render. The problem is that inside the &lt;code&gt;setInterval&lt;/code&gt; callback, the value of &lt;code&gt;count&lt;/code&gt; does not change, because we&amp;rsquo;ve created a closure with the value of &lt;code&gt;count&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; as it was when the effect callback ran. Every second, this callback then calls &lt;code&gt;setCount(0 + 1)&lt;/code&gt;, so the count never goes above 1.</source>
          <target state="translated">空の依存関係セット &lt;code&gt;[]&lt;/code&gt; は、コンポーネントのマウント時にエフェクトが1回だけ実行され、すべての再レンダリングでは実行されないことを意味します。問題は、 &lt;code&gt;setInterval&lt;/code&gt; コールバック内では、 &lt;code&gt;count&lt;/code&gt; の値が変化しないことです。これは、エフェクトコールバックが実行されたときのように、 &lt;code&gt;count&lt;/code&gt; の値を &lt;code&gt;0&lt;/code&gt; に設定してクロージャーを作成したためです。このコールバックは &lt;code&gt;setCount(0 + 1)&lt;/code&gt; 呼び出すため、カウントが1を超えることはありません。</target>
        </trans-unit>
        <trans-unit id="e7d18e24fe1c347ef1b3c94e07922d8cc04f6942" translate="yes" xml:space="preserve">
          <source>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append &lt;code&gt;Capture&lt;/code&gt; to the event name; for example, instead of using &lt;code&gt;onClick&lt;/code&gt;, you would use &lt;code&gt;onClickCapture&lt;/code&gt; to handle the click event in the capture phase.</source>
          <target state="translated">以下のイベントハンドラーは、バブリング段階のイベントによってトリガーされます。キャプチャフェーズのイベントハンドラーを登録するには、イベント名に &lt;code&gt;Capture&lt;/code&gt; を追加します。たとえば、 &lt;code&gt;onClick&lt;/code&gt; を使用する代わりに、 &lt;code&gt;onClickCapture&lt;/code&gt; を使用して、キャプチャフェーズでクリックイベントを処理します。</target>
        </trans-unit>
        <trans-unit id="35470d31aa9c663f5b39b9e3bf6a8825cba5c87e" translate="yes" xml:space="preserve">
          <source>The event sequence now becomes like this:</source>
          <target state="translated">これでイベントシーケンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2feb552bc0b04f016976d27749dad0528ebe0952" translate="yes" xml:space="preserve">
          <source>The exact way to do this depends on the tools you use to compile JavaScript.</source>
          <target state="translated">これを行う正確な方法は、JavaScriptをコンパイルするために使用するツールによって異なります。</target>
        </trans-unit>
        <trans-unit id="778ba0676987a60a9e2c8429a7aa41f2c83bff58" translate="yes" xml:space="preserve">
          <source>The example API returns a JSON object like this:</source>
          <target state="translated">例のAPIは、このようなJSONオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="2d6f789ab2260e267676497b52bf0d82f9dfacb6" translate="yes" xml:space="preserve">
          <source>The example below implements a common pattern: using the &lt;code&gt;ref&lt;/code&gt; callback to store a reference to a DOM node in an instance property.</source>
          <target state="translated">次の例は、共通のパターンを実装しています &lt;code&gt;ref&lt;/code&gt; コールバックを使用して、DOMノードへの参照をインスタンスプロパティに格納します。</target>
        </trans-unit>
        <trans-unit id="5f9470c3b84dc932fd588852cc8390acf73521e5" translate="yes" xml:space="preserve">
          <source>The examples below demonstrate the differences.</source>
          <target state="translated">以下の例は、その違いを示しています。</target>
        </trans-unit>
        <trans-unit id="8caf0302f63f1367b6cfadfc61944e1907afd828" translate="yes" xml:space="preserve">
          <source>The examples below have been updated to use the &lt;code&gt;React.createRef()&lt;/code&gt; API introduced in React 16.3. If you are using an earlier release of React, we recommend using &lt;a href=&quot;#callback-refs&quot;&gt;callback refs&lt;/a&gt; instead.</source>
          <target state="translated">以下の例は、React 16.3で導入された &lt;code&gt;React.createRef()&lt;/code&gt; API を使用するように更新されています。Reactの以前のリリースを使用している場合は、代わりに&lt;a href=&quot;#callback-refs&quot;&gt;コールバック参照&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="455e064548d40d5ab668249f72a1cd4f0163750c" translate="yes" xml:space="preserve">
          <source>The file input Tag</source>
          <target state="translated">ファイル入力タグ</target>
        </trans-unit>
        <trans-unit id="eb4803464d7b9f0c8c680d9449f96660c199ce10" translate="yes" xml:space="preserve">
          <source>The filtered list of products</source>
          <target state="translated">フィルタリングされた製品のリスト</target>
        </trans-unit>
        <trans-unit id="782d3e0cd7b112da27839308868fb0a14dcc498e" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;child&lt;/code&gt;) is any &lt;a href=&quot;react-component#render&quot;&gt;renderable React child&lt;/a&gt;, such as an element, string, or fragment. The second argument (&lt;code&gt;container&lt;/code&gt;) is a DOM element.</source>
          <target state="translated">最初の引数（ &lt;code&gt;child&lt;/code&gt; ）は、要素、文字列、フラグメントなど、&lt;a href=&quot;react-component#render&quot;&gt;レンダリング可能な&lt;/a&gt;任意のReact childです。2番目の引数（ &lt;code&gt;container&lt;/code&gt; ）はDOM要素です。</target>
        </trans-unit>
        <trans-unit id="b8c5930c6860f5766726b86234129269ec281ca2" translate="yes" xml:space="preserve">
          <source>The first argument is an &lt;code&gt;updater&lt;/code&gt; function with the signature:</source>
          <target state="translated">最初の引数は、シグネチャを持つ &lt;code&gt;updater&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="bb81ac8fd7276dc657a1d763df0cbcb0143cbe4c" translate="yes" xml:space="preserve">
          <source>The first parameter is the wrapped component. The second parameter retrieves the data we&amp;rsquo;re interested in, given a &lt;code&gt;DataSource&lt;/code&gt; and the current props.</source>
          <target state="translated">最初のパラメーターはラップされたコンポーネントです。2番目のパラメーターは、 &lt;code&gt;DataSource&lt;/code&gt; と現在の小道具を指定して、関心のあるデータを取得します。</target>
        </trans-unit>
        <trans-unit id="003f348ba9fdbe52c6f6090cd3f9396dc2b157db" translate="yes" xml:space="preserve">
          <source>The first part of a JSX tag determines the type of the React element.</source>
          <target state="translated">JSXタグの最初の部分でReact要素のタイプが決まります。</target>
        </trans-unit>
        <trans-unit id="917597890dc6b95bb360440dd8da1fd3c7810b0f" translate="yes" xml:space="preserve">
          <source>The first thing you&amp;rsquo;ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you&amp;rsquo;re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</source>
          <target state="translated">まず最初に、モック内のすべてのコンポーネント（およびサブコンポーネント）の周りにボックスを描画し、すべての名前を付けます。あなたがデザイナーと働いているなら、彼らはすでにこれをしているかもしれないので、彼らと話してください！Photoshopのレイヤー名は、Reactコンポーネントの名前になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="58af51c7a5ea330490a54c507bc24a5957ec1db5" translate="yes" xml:space="preserve">
          <source>The first two tags load React. The third one will load your component code.</source>
          <target state="translated">最初の2つのタグはReactを読み込みます。3つ目のタグはコンポーネントコードを読み込みます。</target>
        </trans-unit>
        <trans-unit id="63d7151a3f248b4aaf387f1b0df617c10a48c0cc" translate="yes" xml:space="preserve">
          <source>The following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don&amp;rsquo;t stress about learning them up front.</source>
          <target state="translated">次のフックは、前のセクションの基本的なフックのバリエーションであるか、特定のエッジケースでのみ必要です。事前にそれらについて学ぶことを強調しないでください。</target>
        </trans-unit>
        <trans-unit id="e308e9b3043ec57ac18e0b3c611264d1750d56e5" translate="yes" xml:space="preserve">
          <source>The following WCAG checklists provide an overview:</source>
          <target state="translated">以下のWCAGチェックリストに概要が記載されています。</target>
        </trans-unit>
        <trans-unit id="694131f03d1bab80a6c7d4c80f4b1b3a3241dee3" translate="yes" xml:space="preserve">
          <source>The following code demonstrates this. (The input is locked at first but becomes editable after a short delay.)</source>
          <target state="translated">以下のコードはこれを示しています。(入力は最初はロックされていますが、短い遅延の後に編集可能になります)</target>
        </trans-unit>
        <trans-unit id="6211b0539ce28a1c45c57e19f644594cc9415732" translate="yes" xml:space="preserve">
          <source>The following methods can be used in both the server and browser environments:</source>
          <target state="translated">以下の方法は、サーバー環境とブラウザ環境の両方で使用することができます。</target>
        </trans-unit>
        <trans-unit id="9e58ff833910cac432aba7935a817cbc0b058b56" translate="yes" xml:space="preserve">
          <source>The following resources show us how to do this:</source>
          <target state="translated">以下の資料では、その方法を紹介しています。</target>
        </trans-unit>
        <trans-unit id="98a6e91ed5c938365a3d023a4ee79e40777157be" translate="yes" xml:space="preserve">
          <source>The following toolchains offer more flexibility and choice. We recommend them to more experienced users:</source>
          <target state="translated">以下のツールチェーンは、より柔軟性と選択肢を提供します。より経験豊富なユーザーにお勧めします。</target>
        </trans-unit>
        <trans-unit id="e92b55a478f169e90eff18e9f5c9f441b0eac9b2" translate="yes" xml:space="preserve">
          <source>The granularity of error boundaries is up to you. You may wrap top-level route components to display a &amp;ldquo;Something went wrong&amp;rdquo; message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.</source>
          <target state="translated">エラー境界の粒度はあなた次第です。サーバーサイドフレームワークがクラ​​ッシュを処理することが多いのと同じように、トップレベルのルートコンポーネントをラップして、「何か問題が発生しました」というメッセージをユーザーに表示できます。また、個々のウィジェットをエラー境界でラップして、残りのアプリケーションのクラッシュからウィジェットを保護することもできます。</target>
        </trans-unit>
        <trans-unit id="2a6247bb2d42aa3e3342c1d43e5c94a83c8139f8" translate="yes" xml:space="preserve">
          <source>The inputs stay in sync because their values are computed from the same state:</source>
          <target state="translated">入力は同じ状態から値が計算されるため、同期した状態を保ちます。</target>
        </trans-unit>
        <trans-unit id="7f76c6b2c5bda1e950d51d378999359849f255f5" translate="yes" xml:space="preserve">
          <source>The keyboard</source>
          <target state="translated">キーボード</target>
        </trans-unit>
        <trans-unit id="0054077e1ddf463832b68523a2ad7ad7cfc55cae" translate="yes" xml:space="preserve">
          <source>The last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn&amp;rsquo;t have to update the DOM.</source>
          <target state="translated">最後の興味深いケースはC8です。Reactはこのコンポーネントをレンダリングする必要がありましたが、返されたReact要素は以前にレンダリングされたものと同じであるため、DOMを更新する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="650917a3548229098547ab66dc585a177cef3daa" translate="yes" xml:space="preserve">
          <source>The lazy component should then be rendered inside a &lt;code&gt;Suspense&lt;/code&gt; component, which allows us to show some fallback content (such as a loading indicator) while we&amp;rsquo;re waiting for the lazy component to load.</source>
          <target state="translated">次に、遅延コンポーネントを &lt;code&gt;Suspense&lt;/code&gt; コンポーネント内にレンダリングする必要があります。これにより、遅延コンポーネントが読み込まれるのを待っている間に、フォールバックコンテンツ（読み込みインジケーターなど）を表示できます。</target>
        </trans-unit>
        <trans-unit id="a20ca449aab3a55095a75facca274bd40f837461" translate="yes" xml:space="preserve">
          <source>The legacy context API is error-prone, and will be removed in a future major version. It still works for all 16.x releases but will show this warning message in strict mode:</source>
          <target state="translated">レガシーコンテキストAPIはエラーが発生しやすいため、将来のメジャーバージョンで削除される予定です。16.x のすべてのリリースで動作しますが、厳密なモードではこの警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="da3bba855b5bdb90a044ae1549472e5dd22f334f" translate="yes" xml:space="preserve">
          <source>The legacy context API will be removed in a future major version. Use the &lt;a href=&quot;context&quot;&gt;new context API&lt;/a&gt; introduced with version 16.3. The legacy API will continue working for all 16.x releases.</source>
          <target state="translated">レガシーコンテキストAPIは、将来のメジャーバージョンで削除される予定です。バージョン16.3で導入された&lt;a href=&quot;context&quot;&gt;新しいコンテキストAPIを&lt;/a&gt;使用します。レガシーAPIは、すべての16.xリリースで引き続き機能します。</target>
        </trans-unit>
        <trans-unit id="81ccef2b9339e6d81469f85f907bf4389c10515e" translate="yes" xml:space="preserve">
          <source>The lifecycle methods below are marked as &amp;ldquo;legacy&amp;rdquo;. They still work, but we don&amp;rsquo;t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">以下のライフサイクルメソッドは「レガシー」としてマークされています。これらは引き続き機能しますが、新しいコードで使用することはお勧めしません。レガシーライフサイクルメソッドからの移行について詳しくは、&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;このブログ投稿&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="15cd4ff64ab80f5a2212f2df0011a9c029b32518" translate="yes" xml:space="preserve">
          <source>The majority of websites aren&amp;rsquo;t, and don&amp;rsquo;t need to be, single-page apps. With &lt;strong&gt;a few lines of code and no build tooling&lt;/strong&gt;, try React in a small part of your website. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">ほとんどのウェブサイトは単一ページのアプリではなく、またそうである必要もありません。では&lt;strong&gt;、コードなしのビルドツールの数行&lt;/strong&gt;、してみてくださいあなたのウェブサイトのごく一部に反応します。次に、その存在を徐々に拡大するか、またはいくつかの動的ウィジェットに含めておくことができます。</target>
        </trans-unit>
        <trans-unit id="16f4513e10a025e9de18b63415157d7cf17b1b0f" translate="yes" xml:space="preserve">
          <source>The merging is shallow, so &lt;code&gt;this.setState({comments})&lt;/code&gt; leaves &lt;code&gt;this.state.posts&lt;/code&gt; intact, but completely replaces &lt;code&gt;this.state.comments&lt;/code&gt;.</source>
          <target state="translated">マージは浅いため、 &lt;code&gt;this.setState({comments})&lt;/code&gt; は &lt;code&gt;this.state.posts&lt;/code&gt; をそのまま残しますが、 &lt;code&gt;this.state.comments&lt;/code&gt; を完全に置き換えます。</target>
        </trans-unit>
        <trans-unit id="0dcbdabac908b8f2fc6e0ffecf4fbddf1e58850e" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="translated">このセクションのメソッドは、一般的でないユースケースに対応しています。それらは時々便利ですが、ほとんどのコンポーネントはおそらくそれらを必要としません。&lt;strong&gt;&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;このライフサイクル図&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;の上部にある[あまり一般的でないライフサイクルを表示する]チェックボックスをクリックすると、&lt;/strong&gt;&lt;strong&gt;以下のほとんどのメソッドを確認できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5a58960afc3a46f1622f9179fa142d4ab56648" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="translated">このセクションのメソッドは、一般的でないユースケースに対応しています。それらはたまに便利ですが、ほとんどのコンポーネントはおそらくそれらのどれも必要としません。&lt;strong&gt;&lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;このライフサイクル図&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;の上部にある[あまり一般的でないライフサイクルを表示する]チェックボックスをクリックすると、&lt;/strong&gt;&lt;strong&gt;以下のほとんどの方法を確認できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8fed08012b5625fe563e0b37a0ff08e44a38cb3" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">このセクションのメソッドは、Reactコンポーネントの作成で遭遇する大部分のユースケースをカバーしています。&lt;strong&gt;視覚的な参照については、&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;このライフサイクル図を&lt;/a&gt;確認してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4ced5c859243ea7f8a1e5d64710e4914cd027be" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">このセクションのメソッドは、Reactコンポーネントの作成で発生するユースケースの大部分をカバーしています。&lt;strong&gt;視覚的な参照については、&lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;このライフサイクル図を&lt;/a&gt;確認してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32e0c3ff6eb1184d53d22e7e647c950849c06e4c" translate="yes" xml:space="preserve">
          <source>The most common signature for HOCs looks like this:</source>
          <target state="translated">HOCの最も一般的な署名はこのようになります。</target>
        </trans-unit>
        <trans-unit id="01e425821d940bee1f75b9701bf9cae45803a7fb" translate="yes" xml:space="preserve">
          <source>The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named &lt;code&gt;withSubscription&lt;/code&gt;, and the wrapped component&amp;rsquo;s display name is &lt;code&gt;CommentList&lt;/code&gt;, use the display name &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt;:</source>
          <target state="translated">最も一般的な手法は、ラップされたコンポーネントの表示名をラップすることです。したがって、高次コンポーネントの名前が &lt;code&gt;withSubscription&lt;/code&gt; で、ラップされたコンポーネントの表示名が &lt;code&gt;CommentList&lt;/code&gt; である場合は、表示名 &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d772efa9541ff8cc5757d21265f1b50c9976f1e3" translate="yes" xml:space="preserve">
          <source>The most important difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; is that &lt;code&gt;props&lt;/code&gt; are passed from a parent component, but &lt;code&gt;state&lt;/code&gt; is managed by the component itself. A component cannot change its &lt;code&gt;props&lt;/code&gt;, but it can change its &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; と &lt;code&gt;props&lt;/code&gt; の最も重要な違いは、 &lt;code&gt;props&lt;/code&gt; は親コンポーネントから渡されますが、 &lt;code&gt;state&lt;/code&gt; はコンポーネント自体によって管理されることです。コンポーネントはその &lt;code&gt;props&lt;/code&gt; 変更することはできませんが、その &lt;code&gt;state&lt;/code&gt; を変更することはできます。</target>
        </trans-unit>
        <trans-unit id="5da4bb3efd80371c6e943cdabe174c4c7232ece8" translate="yes" xml:space="preserve">
          <source>The most important things we learned so far are:</source>
          <target state="translated">今まで学んできたことの中で一番大切なことは</target>
        </trans-unit>
        <trans-unit id="0f3841fcee35f1e3e8f100fa6282724ddf54ce64" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;act&lt;/code&gt; comes from the &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; pattern.</source>
          <target state="translated">&lt;code&gt;act&lt;/code&gt; という名前は、&lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt;パターンに由来しています。</target>
        </trans-unit>
        <trans-unit id="5264af61d93942a8eba8291eaa575dd302096081" translate="yes" xml:space="preserve">
          <source>The names on the left aren&amp;rsquo;t a part of the React API. You can name your own state variables:</source>
          <target state="translated">左側の名前はReact APIの一部ではありません。独自の状態変数に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="4a5345a128b80e8d405e799312115fb3b799e29d" translate="yes" xml:space="preserve">
          <source>The need to manage local state with a reducer in a complex component is common enough that we&amp;rsquo;ve built the &lt;code&gt;useReducer&lt;/code&gt; Hook right into React. You&amp;rsquo;ll find it together with other built-in Hooks in the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt;.</source>
          <target state="translated">複雑なコンポーネントでレデューサーを使用してローカル状態を管理する必要性は、Reactに &lt;code&gt;useReducer&lt;/code&gt; フックを構築するのに十分一般的です。他の組み込みフックと一緒に、&lt;a href=&quot;hooks-reference&quot;&gt;フックAPIリファレンスで&lt;/a&gt;見つけることができます。</target>
        </trans-unit>
        <trans-unit id="9f051d87ee25566d70564d3a58864ab99806f58c" translate="yes" xml:space="preserve">
          <source>The only argument to &lt;code&gt;useState&lt;/code&gt; is the initial state. In the example above, it is &lt;code&gt;0&lt;/code&gt; because our counter starts from zero. Note that unlike &lt;code&gt;this.state&lt;/code&gt;, the state here doesn&amp;rsquo;t have to be an object &amp;mdash; although it can be if you want. The initial state argument is only used during the first render.</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; の唯一の引数は初期状態です。上記の例では、それは &lt;code&gt;0&lt;/code&gt; 私たちのカウンタはゼロから始まるので。 &lt;code&gt;this.state&lt;/code&gt; とは異なり、ここでの状態はオブジェクトである必要はありません。初期状態の引数は、最初のレンダリング中にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="b534a04aeb4f463839ecea6daf302d82f8c6468e" translate="yes" xml:space="preserve">
          <source>The only difference between these two examples is that the first uses regular &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;s, but the second one uses our custom &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">これら2つの例の唯一の違いは、最初の例では通常の &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; を使用していますが、2番目の例では、カスタムの &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; コンポーネントを &lt;code&gt;useTransition&lt;/code&gt; で使用しています。</target>
        </trans-unit>
        <trans-unit id="489679e8916d61c0a6ff61f577314e68b03922ae" translate="yes" xml:space="preserve">
          <source>The only method you &lt;em&gt;must&lt;/em&gt; define in a &lt;code&gt;React.Component&lt;/code&gt; subclass is called &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;. All the other methods described on this page are optional.</source>
          <target state="translated">&lt;code&gt;React.Component&lt;/code&gt; サブクラスで定義する&lt;em&gt;必要がある&lt;/em&gt;唯一のメソッドは、&lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt;です。このページで説明されている他のすべての方法はオプションです。</target>
        </trans-unit>
        <trans-unit id="06b09efecaccac65bc2017106119837f0fe67989" translate="yes" xml:space="preserve">
          <source>The only place where you can assign &lt;code&gt;this.state&lt;/code&gt; is the constructor.</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; を割り当てることができる唯一の場所はコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="c3c884b2822ecc82667f90bc15a105ccc9d50096" translate="yes" xml:space="preserve">
          <source>The original list of products</source>
          <target state="translated">オリジナル商品一覧</target>
        </trans-unit>
        <trans-unit id="4ea78638cae1dd6caebc10f10aa13e863c90b117" translate="yes" xml:space="preserve">
          <source>The original list of products is passed in as props, so that&amp;rsquo;s not state. The search text and the checkbox seem to be state since they change over time and can&amp;rsquo;t be computed from anything. And finally, the filtered list of products isn&amp;rsquo;t state because it can be computed by combining the original list of products with the search text and value of the checkbox.</source>
          <target state="translated">製品の元のリストは小道具として渡されるため、状態ではありません。検索テキストとチェックボックスは、時間とともに変化し、何からも計算できないため、状態のように見えます。そして最後に、フィルターされた製品のリストは状態ではありません。これは、元の製品のリストと検索テキストおよびチェックボックスの値を組み合わせることによって計算できるためです。</target>
        </trans-unit>
        <trans-unit id="6f1bbb5016bd5b7f1cbbbc8bff248976ede2bdbd" translate="yes" xml:space="preserve">
          <source>The parent test instance of this test instance.</source>
          <target state="translated">このテストインスタンスの親テストインスタンス。</target>
        </trans-unit>
        <trans-unit id="75a37bc623c00c3288da02b16fb11939ee777c48" translate="yes" xml:space="preserve">
          <source>The problem here isn&amp;rsquo;t just about performance &amp;mdash; remounting a component causes the state of that component and all of its children to be lost.</source>
          <target state="translated">ここでの問題は、パフォーマンスだけではありません。コンポーネントを再マウントすると、そのコンポーネントとそのすべての子の状態が失われます。</target>
        </trans-unit>
        <trans-unit id="15386a7181b277d545f04b8eedc8056cc4a44d6c" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;PureComponent&lt;/code&gt; will do a simple comparison between the old and new values of &lt;code&gt;this.props.words&lt;/code&gt;. Since this code mutates the &lt;code&gt;words&lt;/code&gt; array in the &lt;code&gt;handleClick&lt;/code&gt; method of &lt;code&gt;WordAdder&lt;/code&gt;, the old and new values of &lt;code&gt;this.props.words&lt;/code&gt; will compare as equal, even though the actual words in the array have changed. The &lt;code&gt;ListOfWords&lt;/code&gt; will thus not update even though it has new words that should be rendered.</source>
          <target state="translated">問題があるということ &lt;code&gt;PureComponent&lt;/code&gt; は、古い値と新しい値の間の単純な比較を行います &lt;code&gt;this.props.words&lt;/code&gt; を。このコードが突然変異ので &lt;code&gt;words&lt;/code&gt; の配列 &lt;code&gt;handleClick&lt;/code&gt; の方法 &lt;code&gt;WordAdder&lt;/code&gt; の古い値と新しい値 &lt;code&gt;this.props.words&lt;/code&gt; は、アレイ内の実際の単語が変更されているにもかかわらず、同じように比較します。したがって、 &lt;code&gt;ListOfWords&lt;/code&gt; は、レンダリングする必要のある新しい単語がある場合でも更新されません。</target>
        </trans-unit>
        <trans-unit id="1f0ea7c5399c0c473f0cc17a73922eb556fef997" translate="yes" xml:space="preserve">
          <source>The problem is that it&amp;rsquo;s both unnecessary (you can use &lt;code&gt;this.props.color&lt;/code&gt; directly instead), and creates bugs (updates to the &lt;code&gt;color&lt;/code&gt; prop won&amp;rsquo;t be reflected in the state).</source>
          <target state="translated">問題は、それが不必要である（代わりに &lt;code&gt;this.props.color&lt;/code&gt; を直接使用できる）ことと、バグを作成することです（ &lt;code&gt;color&lt;/code&gt; プロップへの更新は状態に反映されません）。</target>
        </trans-unit>
        <trans-unit id="f8e70f0f5024e3a8775d44c1ce4056df7f4d3a4d" translate="yes" xml:space="preserve">
          <source>The problem is, if a context value provided by component changes, descendants that use that value won&amp;rsquo;t update if an intermediate parent returns &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. This is totally out of control of the components using context, so there&amp;rsquo;s basically no way to reliably update the context. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;This blog post&lt;/a&gt; has a good explanation of why this is a problem and how you might get around it.</source>
          <target state="translated">問題は、コンポーネントによって提供されるコンテキスト値が変更された場合、中間の親が &lt;code&gt;shouldComponentUpdate&lt;/code&gt; から &lt;code&gt;false&lt;/code&gt; を返すと、その値を使用する子孫が更新されないことです。これは、コンテキストを使用してコンポーネントを完全に制御できないため、コンテキストを確実に更新する方法は基本的にありません。&lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;このブログ投稿&lt;/a&gt;は、これがなぜ問題であり、どうすればそれを回避できるのかをよく説明しています。</target>
        </trans-unit>
        <trans-unit id="985aef5fd109f4727b2c3e05bea5a14a684f7867" translate="yes" xml:space="preserve">
          <source>The problem with this is that now we &lt;em&gt;always&lt;/em&gt; wait for both of them to be fetched. However, if it&amp;rsquo;s the &lt;em&gt;posts&lt;/em&gt; that came back first, there&amp;rsquo;s no reason to delay showing them. When fun facts load later, they won&amp;rsquo;t shift the layout because they&amp;rsquo;re already below the posts.</source>
          <target state="translated">これの問題は、両方がフェッチされるのを&lt;em&gt;常に&lt;/em&gt;待つことです。ただし、最初に戻ったのが&lt;em&gt;投稿で&lt;/em&gt;ある場合は、表示を遅らせる理由はありません。楽しい事実が後で読み込まれるとき、それらは既に投稿の下にあるため、レイアウトをシフトしません。</target>
        </trans-unit>
        <trans-unit id="03950f8935a0284b924067f2374cf9480513156a" translate="yes" xml:space="preserve">
          <source>The problem with this syntax is that a different callback is created each time the &lt;code&gt;LoggingButton&lt;/code&gt; renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</source>
          <target state="translated">この構文の問題は、 &lt;code&gt;LoggingButton&lt;/code&gt; がレンダリングされるたびに異なるコールバックが作成されることです。ほとんどの場合、これで問題ありません。ただし、このコールバックが下位コンポーネントへの小道具として渡される場合、それらのコンポーネントは追加の再レンダリングを行う可能性があります。この種のパフォーマンスの問題を回避するには、通常、コンストラクターでバインドするか、クラスフィールド構文を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d9fe552e7244a26ea298807902943abd3f5ea401" translate="yes" xml:space="preserve">
          <source>The props corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; component has &lt;code&gt;{size: 'small'}&lt;/code&gt; as props.</source>
          <target state="translated">このテストインスタンスに対応する小道具。たとえば、 &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; コンポーネントには、小道具として &lt;code&gt;{size: 'small'}&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="9fce336ce1bf6f03834b6fbd791d6f0d85f22369" translate="yes" xml:space="preserve">
          <source>The purpose of our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook is to subscribe us to a friend&amp;rsquo;s status. This is why it takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether this friend is online:</source>
          <target state="translated">私たちの &lt;code&gt;useFriendStatus&lt;/code&gt; フックの目的は、友達のステータスを登録することです。これが引数として &lt;code&gt;friendID&lt;/code&gt; を取り、この友達がオンラインかどうかを返す理由です。</target>
        </trans-unit>
        <trans-unit id="b6c0cdaae16617f0fa21ba142bf2809ac5269c18" translate="yes" xml:space="preserve">
          <source>The quickest way to try JSX in your project is to add this &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to your page:</source>
          <target state="translated">プロジェクトでJSXを試す最も簡単な方法は、この &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグをページに追加することです。</target>
        </trans-unit>
        <trans-unit id="3a47571ee342cc7e146815342e103ee52412ecda" translate="yes" xml:space="preserve">
          <source>The reason for the stutter is simple: once rendering begins, it can&amp;rsquo;t be interrupted. So the browser can&amp;rsquo;t update the text input right after the key press. No matter how good a UI library (such as React) might look on a benchmark, if it uses blocking rendering, a certain amount of work in your components will always cause stutter. And, often, there is no easy fix.</source>
          <target state="translated">スタッターの理由は単純です。一度レンダリングが始まると、中断できません。そのため、ブラウザはキーを押した直後にテキスト入力を更新できません。UIライブラリ（Reactなど）がベンチマークでどのように表示されても、それがブロッキングレンダリングを使用している場合、コンポーネントでの一定量の作業は常にスタッターを引き起こします。そして、多くの場合、簡単な修正はありません。</target>
        </trans-unit>
        <trans-unit id="6faacd46ba2798dfe6d96de925d3e8fb01c4350a" translate="yes" xml:space="preserve">
          <source>The result looks like this:</source>
          <target state="translated">結果はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="61eea536517b5e0755810228e63123231a9fbc54" translate="yes" xml:space="preserve">
          <source>The same functionality can be achieved by using appropriate event handlers instead, such as &lt;code&gt;onBlur&lt;/code&gt; and &lt;code&gt;onFocus&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;onBlur&lt;/code&gt; や &lt;code&gt;onFocus&lt;/code&gt; などの適切なイベントハンドラーを代わりに使用して、同じ機能を実現できます。</target>
        </trans-unit>
        <trans-unit id="d7784002558cdfc24a42cb236b2e3ce3aa1c6451" translate="yes" xml:space="preserve">
          <source>The search text the user has entered</source>
          <target state="translated">ユーザーが入力した検索テキスト</target>
        </trans-unit>
        <trans-unit id="271217a1e95a4db6a472aae868aac48af77b167f" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;ref&lt;/code&gt; argument only exists when you define a component with &lt;code&gt;React.forwardRef&lt;/code&gt; call. Regular function or class components don&amp;rsquo;t receive the &lt;code&gt;ref&lt;/code&gt; argument, and ref is not available in props either.</source>
          <target state="translated">2番目の &lt;code&gt;ref&lt;/code&gt; 引数は、 &lt;code&gt;React.forwardRef&lt;/code&gt; 呼び出しでコンポーネントを定義する場合にのみ存在します。通常の関数またはクラスコンポーネントは &lt;code&gt;ref&lt;/code&gt; 引数を受け取りません。また、refはプロップでも使用できません。</target>
        </trans-unit>
        <trans-unit id="55fe0f7cb0bc62f87df6f7b88593c40ba2275b33" translate="yes" xml:space="preserve">
          <source>The second parameter to &lt;code&gt;setState()&lt;/code&gt; is an optional callback function that will be executed once &lt;code&gt;setState&lt;/code&gt; is completed and the component is re-rendered. Generally we recommend using &lt;code&gt;componentDidUpdate()&lt;/code&gt; for such logic instead.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; の2番目のパラメータはオプションのコールバック関数で、 &lt;code&gt;setState&lt;/code&gt; が完了してコンポーネントが再レンダリングされると実行されます。通常、代わりにそのようなロジックには &lt;code&gt;componentDidUpdate()&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f35ac8c2adbf99f7b5bef181874b520f98344d20" translate="yes" xml:space="preserve">
          <source>The select Tag</source>
          <target state="translated">選択したタグ</target>
        </trans-unit>
        <trans-unit id="07e95df1e5b40e195c7db30f2c1280116b62015e" translate="yes" xml:space="preserve">
          <source>The signature is identical to &lt;code&gt;useEffect&lt;/code&gt;, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside &lt;code&gt;useLayoutEffect&lt;/code&gt; will be flushed synchronously, before the browser has a chance to paint.</source>
          <target state="translated">シグネチャは &lt;code&gt;useEffect&lt;/code&gt; と同じですが、すべてのDOMの変更後に同期的に起動します。これを使用して、DOMからレイアウトを読み取り、同期的に再レン​​ダリングします。 &lt;code&gt;useLayoutEffect&lt;/code&gt; 内でスケジュールされた更新は、ブラウザーがペイントする前に同期的にフラッシュされます。</target>
        </trans-unit>
        <trans-unit id="5c639e86090bfaf74758cb091cb2ea67a1fddcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the &lt;code&gt;handleClick&lt;/code&gt; method above could be rewritten using &lt;code&gt;concat&lt;/code&gt; as:</source>
          <target state="translated">この問題を回避する最も簡単な方法は、小道具または状態として使用している値の変更を回避することです。たとえば、上記の &lt;code&gt;handleClick&lt;/code&gt; メソッドは、次のように &lt;code&gt;concat&lt;/code&gt; を使用して書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="71460fd47e61e6f8130d4e6e217a7bd0d4fb7bfc" translate="yes" xml:space="preserve">
          <source>The simplest way to consume &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; models and collections from a React component is to listen to the various change events and manually force an update.</source>
          <target state="translated">Reactコンポーネントから&lt;a href=&quot;https://backbonejs.org/&quot;&gt;バックボーン&lt;/a&gt;モデルとコレクションを使用する最も簡単な方法は、さまざまな変更イベントをリッスンし、手動で更新を強制することです。</target>
        </trans-unit>
        <trans-unit id="c75dd6397b4e899517f186ce7dd6fec1fc4143c7" translate="yes" xml:space="preserve">
          <source>The simplest way to define a component is to write a JavaScript function:</source>
          <target state="translated">コンポーネントを定義する最も簡単な方法は、JavaScriptの関数を書くことです。</target>
        </trans-unit>
        <trans-unit id="ea592b9f9c12cb222debb92695fe41e5990f382a" translate="yes" xml:space="preserve">
          <source>The smallest React example looks like this:</source>
          <target state="translated">一番小さいReactの例はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="40b2a1c643d292094f43059dfae62b82207b4ff4" translate="yes" xml:space="preserve">
          <source>The solution for this problem is to use the &lt;code&gt;React.forwardRef&lt;/code&gt; API (introduced with React 16.3). &lt;a href=&quot;forwarding-refs&quot;&gt;Learn more about it in the forwarding refs section&lt;/a&gt;.</source>
          <target state="translated">この問題の解決策は、 &lt;code&gt;React.forwardRef&lt;/code&gt; API（React 16.3で導入）を使用することです。&lt;a href=&quot;forwarding-refs&quot;&gt;詳細については、転送参照セクションをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e03e04eaae4ac606ca548d267f13b377ac94de6" translate="yes" xml:space="preserve">
          <source>The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.</source>
          <target state="translated">状態には、時間の経過とともに変化する可能性のある、このコンポーネントに固有のデータが含まれています。状態はユーザー定義であり、プレーンな JavaScript オブジェクトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d178c16b57f339917ec9004067811e1e0f7f4019" translate="yes" xml:space="preserve">
          <source>The state of each component is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="translated">各コンポーネントの状態は完全に独立しています。フックは&lt;em&gt;ステートフルロジック&lt;/em&gt;を再利用する方法であり、ステート自体ではありません。実際、フックへの各&lt;em&gt;呼び出し&lt;/em&gt;は完全に分離された状態になっているため、同じカスタムフックを1つのコンポーネントで2回使用することもできます。</target>
        </trans-unit>
        <trans-unit id="22478714b7fd0f489e81d753e9c3c235e69d54ef" translate="yes" xml:space="preserve">
          <source>The state of these components is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="translated">これらのコンポーネントの状態は完全に独立しています。フックは、&lt;em&gt;ステートフルロジック&lt;/em&gt;を再利用する方法であり、ステート自体を再利用する方法ではありません。実際、フックを&lt;em&gt;呼び出す&lt;/em&gt;たびに完全に分離された状態になっているため、1つのコンポーネントで同じカスタムフックを2回使用することもできます。</target>
        </trans-unit>
        <trans-unit id="2641b617455464f7d6496f2f2334b192cde2dbee" translate="yes" xml:space="preserve">
          <source>The state starts as &lt;code&gt;{ count: 0 }&lt;/code&gt;, and we increment &lt;code&gt;state.count&lt;/code&gt; when the user clicks a button by calling &lt;code&gt;this.setState()&lt;/code&gt;. We&amp;rsquo;ll use snippets from this class throughout the page.</source>
          <target state="translated">状態は &lt;code&gt;{ count: 0 }&lt;/code&gt; から始まり、ユーザーが &lt;code&gt;this.setState()&lt;/code&gt; を呼び出してボタンをクリックすると、 &lt;code&gt;state.count&lt;/code&gt; をインクリメントします。このクラスのスニペットをページ全体で使用します。</target>
        </trans-unit>
        <trans-unit id="2573196fe586fe5ec0e5e5bd258214571daa5288" translate="yes" xml:space="preserve">
          <source>The static &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; lifecycle</source>
          <target state="translated">静的な &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; ライフサイクル</target>
        </trans-unit>
        <trans-unit id="18095f89e6ec05009ccfd909d0cb8cefbc086b0a" translate="yes" xml:space="preserve">
          <source>The stream returned from this method will return a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt;, which provides transform streams for transcoding text.</source>
          <target state="translated">このメソッドから返されるストリームは、utf-8でエンコードされたバイトストリームを返します。別のエンコーディングのストリームが必要な場合は、テキストをトランスコーディングするための変換ストリームを提供する&lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt;などのプロジェクトを見てください。</target>
        </trans-unit>
        <trans-unit id="c23c69a9c20200b9704aea13ea549c14e1ec4040" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;Hello world!&lt;/code&gt; is available in &lt;code&gt;props.children&lt;/code&gt; in the &lt;code&gt;Welcome&lt;/code&gt; component:</source>
          <target state="translated">文字列 &lt;code&gt;Hello world!&lt;/code&gt; &lt;code&gt;Welcome&lt;/code&gt; コンポーネントの &lt;code&gt;props.children&lt;/code&gt; で利用できます。</target>
        </trans-unit>
        <trans-unit id="89ccb3f5a789f0345b99477baf67e4ea269b0c4b" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&amp;ldquo;render prop&amp;rdquo;&lt;/a&gt; refers to a technique for sharing code between React components using a prop whose value is a function.</source>
          <target state="translated">&lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;「レンダープロップ」&lt;/a&gt;という用語は、値が関数であるプロップを使用してReactコンポーネント間でコードを共有する手法を指します。</target>
        </trans-unit>
        <trans-unit id="945ad83d6f6df882982c2eea500580f8486a2610" translate="yes" xml:space="preserve">
          <source>The textarea Tag</source>
          <target state="translated">textarea タグ</target>
        </trans-unit>
        <trans-unit id="0b75157dc01568e5ebeb7fddf73f5af3b9ebb9b6" translate="yes" xml:space="preserve">
          <source>The toolchains recommended on this page &lt;strong&gt;don&amp;rsquo;t require configuration to get started&lt;/strong&gt;.</source>
          <target state="translated">このページで推奨されているツールチェーンは、&lt;strong&gt;開始するための構成を必要としません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="46c2a81a73e1db62c5ec0751bf9c3489bd2fa0f4" translate="yes" xml:space="preserve">
          <source>The tradeoff we&amp;rsquo;re making here is that &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; will be inconsistent with other components and potentially show an older item. Click &amp;ldquo;Next&amp;rdquo; a few times, and you&amp;rsquo;ll notice it. But thanks to that, we were able to cut down the transition time from 1000ms to 300ms.</source>
          <target state="translated">ここで行うトレードオフは、 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; が他のコンポーネントと整合性がなく、古いアイテムを表示する可能性があることです。「次へ」を数回クリックすると、それに気づくでしょう。しかしそのおかげで、遷移時間を1000msから300msに短縮することができました。</target>
        </trans-unit>
        <trans-unit id="12aef5cfe0207aa12a859449db31e95cefb54821" translate="yes" xml:space="preserve">
          <source>The value of the checkbox</source>
          <target state="translated">チェックボックスの値</target>
        </trans-unit>
        <trans-unit id="47da38aacbdc104c0e2be9e42b4998d633ad332b" translate="yes" xml:space="preserve">
          <source>The value of the ref differs depending on the type of the node:</source>
          <target state="translated">refの値はノードの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="8d6f43e31ac36677cfe23fbc628d0bbec73cb47d" translate="yes" xml:space="preserve">
          <source>The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at:</source>
          <target state="translated">上記のバージョンは開発用であり、本番環境には適していません。React のミニ化された、最適化されたプロダクションバージョンは以下で入手できます。</target>
        </trans-unit>
        <trans-unit id="74ef4a162b977ab31ffac13bf23f9dcbf0227789" translate="yes" xml:space="preserve">
          <source>The virtual DOM (VDOM) is a programming concept where an ideal, or &amp;ldquo;virtual&amp;rdquo;, representation of a UI is kept in memory and synced with the &amp;ldquo;real&amp;rdquo; DOM by a library such as ReactDOM. This process is called &lt;a href=&quot;reconciliation&quot;&gt;reconciliation&lt;/a&gt;.</source>
          <target state="translated">仮想DOM（VDOM）は、UIの理想的な、つまり「仮想」表​​現がメモリに保持され、ReactDOMなどのライブラリによって「実際の」DOMと同期されるプログラミング概念です。このプロセスは、&lt;a href=&quot;reconciliation&quot;&gt;調整&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="574a3a781870e163cce88ef2b0762f4b08191e2e" translate="yes" xml:space="preserve">
          <source>The way changes are determined can cause some issues when passing objects as &lt;code&gt;value&lt;/code&gt;: see &lt;a href=&quot;#caveats&quot;&gt;Caveats&lt;/a&gt;.</source>
          <target state="translated">変更が決定される方法は、オブジェクトを &lt;code&gt;value&lt;/code&gt; として渡すときにいくつかの問題を引き起こす可能性があります。&lt;a href=&quot;#caveats&quot;&gt;警告を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3b1b6af3227db905819bedeb8a6cf6a56db68adc" translate="yes" xml:space="preserve">
          <source>Then add the &lt;code&gt;flow&lt;/code&gt; preset to your &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel configuration&lt;/a&gt;. For example, if you configure Babel through &lt;code&gt;.babelrc&lt;/code&gt; file, it could look like this:</source>
          <target state="translated">次に、 &lt;code&gt;flow&lt;/code&gt; プリセットを&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel&lt;/a&gt;設定に追加します。たとえば、 &lt;code&gt;.babelrc&lt;/code&gt; ファイルを使用してBabelを設定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="49b398d1b5e04088832e8b4a9d6f3fd68e540ca4" translate="yes" xml:space="preserve">
          <source>Then we can focus it elsewhere in our component when needed:</source>
          <target state="translated">そして、必要に応じてコンポーネントの他の場所に焦点を当てることができます。</target>
        </trans-unit>
        <trans-unit id="9618d02f199ba8a6ff1e620695267d9b59eba053" translate="yes" xml:space="preserve">
          <source>Then you can assert:</source>
          <target state="translated">ならば主張してもいい。</target>
        </trans-unit>
        <trans-unit id="d964dac0f67b92e21c4a4e8448328868b35a75e8" translate="yes" xml:space="preserve">
          <source>Then you can update them independently with separate &lt;code&gt;setState()&lt;/code&gt; calls:</source>
          <target state="translated">次に、個別の &lt;code&gt;setState()&lt;/code&gt; 呼び出しでそれらを個別に更新できます。</target>
        </trans-unit>
        <trans-unit id="4acfee1bfbaf53b3d5fb903139781650425ac98e" translate="yes" xml:space="preserve">
          <source>Then you can use it as a regular component:</source>
          <target state="translated">ならば、通常のコンポーネントとして使えばいいのです。</target>
        </trans-unit>
        <trans-unit id="352af5a158542075e87c87aa4822f1cc90f9c371" translate="yes" xml:space="preserve">
          <source>Then, to create a production build, add the &lt;code&gt;-p&lt;/code&gt; flag to the &lt;code&gt;build&lt;/code&gt; command:</source>
          <target state="translated">次に、本番ビルドを作成するには、 &lt;code&gt;build&lt;/code&gt; コマンドに &lt;code&gt;-p&lt;/code&gt; フラグを追加します。</target>
        </trans-unit>
        <trans-unit id="9b1892a438ed36b827ab226ef3f0d930f33d28ce" translate="yes" xml:space="preserve">
          <source>There are a few good use cases for refs:</source>
          <target state="translated">審判にはいくつかの良い使用例があります。</target>
        </trans-unit>
        <trans-unit id="6693c58ee9b46421c76137aee80156eafed70d79" translate="yes" xml:space="preserve">
          <source>There are a few less commonly used built-in Hooks that you might find useful. For example, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; lets you subscribe to React context without introducing nesting:</source>
          <target state="translated">あまり使用されないビルトインフックがいくつかあります。たとえば、&lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; を&lt;/a&gt;使用すると、ネストを導入せずにReactコンテキストをサブスクライブできます。</target>
        </trans-unit>
        <trans-unit id="67ccf0a06731ef0941dac9931fd0d028970a49b3" translate="yes" xml:space="preserve">
          <source>There are a few more heuristics, and they might change over time as we fine-tune the rule to balance finding bugs with avoiding false positives.</source>
          <target state="translated">ヒューリスティックスはもう少しありますし、バグを見つけることと偽陽性を避けることのバランスをとるためにルールを微調整しているので、時間の経過とともに変化するかもしれません。</target>
        </trans-unit>
        <trans-unit id="fb277ba2cfa0f874f335d88ec76a246c5b350e75" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentDidUpdate&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="translated">これにはいくつかの問題があります。1つは、入力コンポーネントを拡張コンポーネントとは別に再利用できないことです。あなたが別のHOCを適用した場合より決定的に、 &lt;code&gt;EnhancedComponent&lt;/code&gt; こと&lt;em&gt;も&lt;/em&gt;変異する &lt;code&gt;componentDidUpdate&lt;/code&gt; 、最初のHOCの機能が上書きされます！このHOCは、ライフサイクルメソッドを持たない関数コンポーネントでも機能しません。</target>
        </trans-unit>
        <trans-unit id="7f27bf7450b1f7493e5f3835cc19efaeea4250b6" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentWillReceiveProps&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="translated">これにはいくつかの問題があります。1つは、拡張コンポーネントとは別に入力コンポーネントを再利用できないことです。あなたが別のHOCを適用した場合より決定的に、 &lt;code&gt;EnhancedComponent&lt;/code&gt; こと&lt;em&gt;も&lt;/em&gt;変異するの &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 、最初のHOCの機能が上書きされます！このHOCは、ライフサイクルメソッドを持たない関数コンポーネントでも機能しません。</target>
        </trans-unit>
        <trans-unit id="bfc361ac490a02de7694989e5f2a21519a4e9158" translate="yes" xml:space="preserve">
          <source>There are a few ways to test React components. Broadly, they divide into two categories:</source>
          <target state="translated">Reactコンポーネントをテストする方法はいくつかあります。大きく分けると、2つのカテゴリーに分けられます。</target>
        </trans-unit>
        <trans-unit id="34efc5850f64e7842db51c2c07fdbcdd7ce86bfb" translate="yes" xml:space="preserve">
          <source>There are a number of attributes that work differently between React and HTML:</source>
          <target state="translated">ReactとHTMLでは動作が異なる属性がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="094824494a1508942600fda7b6cb25cca5aedab2" translate="yes" xml:space="preserve">
          <source>There are a number of tools we can use to assist in the creation of accessible web applications.</source>
          <target state="translated">アクセシブルなWebアプリケーションの作成を支援するために使用できるツールがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="63f2e85d0d652f9d1bc05d28f3438dd676ea31cf" translate="yes" xml:space="preserve">
          <source>There are just two of them: &lt;code&gt;setState()&lt;/code&gt; and &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="translated">それらの2つだけがあります： &lt;code&gt;setState()&lt;/code&gt; と &lt;code&gt;forceUpdate()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f815a5aa15ca4b033e70b18a3f7155b455cca3b" translate="yes" xml:space="preserve">
          <source>There are many pain points associated with deep directory nesting in JavaScript projects. It becomes harder to write relative imports between them, or to update those imports when the files are moved. Unless you have a very compelling reason to use a deep folder structure, consider limiting yourself to a maximum of three or four nested folders within a single project. Of course, this is only a recommendation, and it may not be relevant to your project.</source>
          <target state="translated">JavaScript プロジェクトの深いディレクトリの入れ子には、多くの問題点があります。フォルダ間の相対インポートを書いたり、ファイルを移動したときにインポートを更新したりすることが難しくなります。深いフォルダ構造を使用しなければならない非常にやむを得ない理由がない限り、1 つのプロジェクト内での入れ子フォルダの数は最大でも 3 つか 4 つに制限することを検討してください。もちろん、これはあくまでも推奨事項であり、あなたのプロジェクトには関係ないかもしれません。</target>
        </trans-unit>
        <trans-unit id="bb52a486a0defd5e5a737df39df0a9e362d83228" translate="yes" xml:space="preserve">
          <source>There are several different ways to specify props in JSX.</source>
          <target state="translated">JSXでpropsを指定する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ba31773d4580276a2fa01ba27c7c6e4050da9978" translate="yes" xml:space="preserve">
          <source>There are several ways to make sure functions have access to component attributes like &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt;, depending on which syntax and build steps you are using.</source>
          <target state="translated">使用している構文とビルド手順に応じて、関数が &lt;code&gt;this.props&lt;/code&gt; や &lt;code&gt;this.state&lt;/code&gt; などのコンポーネント属性にアクセスできるようにする方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="035c67657dec8a559bd085096871d672c1441169" translate="yes" xml:space="preserve">
          <source>There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;state of the art algorithms&lt;/a&gt; have a complexity in the order of O(n&lt;sup&gt;3&lt;/sup&gt;) where n is the number of elements in the tree.</source>
          <target state="translated">あるツリーを別のツリーに変換するための最小数の操作を生成するこのアルゴリズムの問​​題には、いくつかの一般的な解決策があります。ただし、&lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;最新のアルゴリズム&lt;/a&gt;はO（n &lt;sup&gt;3&lt;/sup&gt;）のオーダーの複雑さを持っています。ここで、nはツリー内の要素の数です。</target>
        </trans-unit>
        <trans-unit id="bd7701becfe3cd2853a0554a2a6f2a828400586b" translate="yes" xml:space="preserve">
          <source>There are some special rules about where you can and can&amp;rsquo;t use Hooks within a component. We&amp;rsquo;ll learn them in &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">コンポーネント内でフックを使用できる場所と使用できない場所については、いくつかの特別なルールがあります。それらは&lt;a href=&quot;hooks-rules&quot;&gt;、フックのルールで&lt;/a&gt;学習します。</target>
        </trans-unit>
        <trans-unit id="f5ab23a7947a8c9190ca88a94b27fa5bfa00f119" translate="yes" xml:space="preserve">
          <source>There are three things you should know about &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; について知っておくべきことが3つあります。</target>
        </trans-unit>
        <trans-unit id="495dcf3a5be823b2ed9fbe753129b50e1e7a9952" translate="yes" xml:space="preserve">
          <source>There are two common kinds of side effects in React components: those that don&amp;rsquo;t require cleanup, and those that do. Let&amp;rsquo;s look at this distinction in more detail.</source>
          <target state="translated">Reactコンポーネントには2つの一般的な種類の副作用があります。クリーンアップを必要としないものと、クリーンアップが必要なものです。この違いをさらに詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="7bbc4d57f5374db57bc481f127695ec68040f840" translate="yes" xml:space="preserve">
          <source>There are two different ways to initialize &lt;code&gt;useReducer&lt;/code&gt; state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:</source>
          <target state="translated">&lt;code&gt;useReducer&lt;/code&gt; 状態を初期化する方法は2つあります。ユースケースに応じてどちらかを選択できます。最も簡単な方法は、2番目の引数として初期状態を渡すことです。</target>
        </trans-unit>
        <trans-unit id="b5bced4d36eb8976c4c687005ab8da42f62d1581" translate="yes" xml:space="preserve">
          <source>There are two main reasons:</source>
          <target state="translated">理由は主に2つあります。</target>
        </trans-unit>
        <trans-unit id="b56772a4b4c1e06b0df2a414953a659ffda40d7b" translate="yes" xml:space="preserve">
          <source>There are two main ways to get declarations for a library:</source>
          <target state="translated">ライブラリの宣言を取得するには、主に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="a32a8b81054e306fc51c8a8d5d4a6e5c26811de5" translate="yes" xml:space="preserve">
          <source>There are two types of &amp;ldquo;model&amp;rdquo; data in React: props and state. It&amp;rsquo;s important to understand the distinction between the two; skim &lt;a href=&quot;state-and-lifecycle&quot;&gt;the official React docs&lt;/a&gt; if you aren&amp;rsquo;t sure what the difference is. See also &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ: What is the difference between state and props?&lt;/a&gt;</source>
          <target state="translated">Reactの「モデル」データには、小道具と状態の2種類があります。この2つの違いを理解することが重要です。違いがわからない場合&lt;a href=&quot;state-and-lifecycle&quot;&gt;は、Reactの公式ドキュメントを読み&lt;/a&gt;飛ばしてください。&lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ&lt;/a&gt;も参照してください：状態と小道具の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="972f3aee5b48db67c62cfafa5894934c6d7a06bc" translate="yes" xml:space="preserve">
          <source>There is a JavaScript proposal to add &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread properties&lt;/a&gt; to make it easier to update objects without mutation as well:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;オブジェクトスプレッドプロパティ&lt;/a&gt;を追加して、変更なしでオブジェクトを簡単に更新できるようにするJavaScriptの提案があります。</target>
        </trans-unit>
        <trans-unit id="3b6781e91bd723c7b2a32f9c7b9c767072958836" translate="yes" xml:space="preserve">
          <source>There is a common theme around Concurrent Mode features. &lt;strong&gt;Its mission is to help integrate the findings from the Human-Computer Interaction research into real UIs.&lt;/strong&gt;</source>
          <target state="translated">コンカレントモード機能には共通のテーマがあります。&lt;strong&gt;その使命は、ヒューマンコンピュータインタラクションの調査結果を実際のUIに統合することです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c02f2726f7bf82129cb0890af06297b7f6ef5f8" translate="yes" xml:space="preserve">
          <source>There is a new, shorter syntax you can use for declaring fragments. It looks like empty tags:</source>
          <target state="translated">フラグメントを宣言する際に使用できる、新しくて短い構文があります。これは空のタグのように見えます。</target>
        </trans-unit>
        <trans-unit id="268f6fed8cb60468299ecf4640f5b215834edb2a" translate="yes" xml:space="preserve">
          <source>There is a simpler way to solve this. &lt;strong&gt;Instead of making the transition shorter, we can &amp;ldquo;disconnect&amp;rdquo; the slow component from the transition&lt;/strong&gt; by wrapping it into &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">これを解決する簡単な方法があります。&lt;strong&gt;トランジションを短くする代わりに、遅いコンポーネント&lt;/strong&gt;を &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; にラップすることで&lt;strong&gt;、トランジションから低速コンポーネントを「切断」できます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2255fef7c8ea4db88004b8c5dca9f64337cd0c4f" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;an option&lt;/a&gt; to force Flow to check &lt;em&gt;all&lt;/em&gt; files regardless of the annotation. This can be too noisy for existing projects, but is reasonable for a new project if you want to fully type it with Flow.</source>
          <target state="translated">注釈に関係なく、フローに&lt;em&gt;すべての&lt;/em&gt;ファイルを強制的にチェックさせる&lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;オプション&lt;/a&gt;もあります。これは、既存のプロジェクトではうるさすぎるかもしれませんが、Flowで完全に入力したい場合は、新しいプロジェクトでは妥当です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6f37ffca9a0422d14d4f49211218871c0bda6b" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;#short-syntax&quot;&gt;short syntax&lt;/a&gt; for declaring them.</source>
          <target state="translated">それらを宣言するための新しい&lt;a href=&quot;#short-syntax&quot;&gt;短い構文&lt;/a&gt;もあります。</target>
        </trans-unit>
        <trans-unit id="f70442d13f0b33081b997d454535c8bb3c00192d" translate="yes" xml:space="preserve">
          <source>There is an internal list of &amp;ldquo;memory cells&amp;rdquo; associated with each component. They&amp;rsquo;re just JavaScript objects where we can put some data. When you call a Hook like &lt;code&gt;useState()&lt;/code&gt;, it reads the current cell (or initializes it during the first render), and then moves the pointer to the next one. This is how multiple &lt;code&gt;useState()&lt;/code&gt; calls each get independent local state.</source>
          <target state="translated">各コンポーネントに関連付けられた「メモリセル」の内部リストがあります。これらは、データを配置できるJavaScriptオブジェクトです。 &lt;code&gt;useState()&lt;/code&gt; のようなフックを呼び出すと、現在のセルが読み取られ（または最初のレンダリング中に初期化され）、ポインタが次のセルに移動します。これは、複数の &lt;code&gt;useState()&lt;/code&gt; 呼び出しがそれぞれ独立したローカル状態を取得する方法です。</target>
        </trans-unit>
        <trans-unit id="d22c59ace56ae0e2f33663b9156aad827b310eee" translate="yes" xml:space="preserve">
          <source>There is no special code for handling updates because &lt;code&gt;useEffect&lt;/code&gt; handles them &lt;em&gt;by default&lt;/em&gt;. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; は&lt;em&gt;デフォルトで&lt;/em&gt;更新を処理するため、更新を処理するための特別なコードはありません。次の効果を適用する前に、前の効果をクリーンアップします。これを説明するために、このコンポーネントが時間の経過とともに生成する可能性のある一連のサブスクライブおよびサブスクライブ解除呼び出しを次に示します。</target>
        </trans-unit>
        <trans-unit id="642dbc420d30f0e2507cbd973e44025c3ff1e85c" translate="yes" xml:space="preserve">
          <source>There is no special meaning to either &lt;code&gt;temperature&lt;/code&gt; or &lt;code&gt;onTemperatureChange&lt;/code&gt; prop names in custom components. We could have called them anything else, like name them &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;onChange&lt;/code&gt; which is a common convention.</source>
          <target state="translated">カスタムコンポーネントでは、 &lt;code&gt;temperature&lt;/code&gt; または &lt;code&gt;onTemperatureChange&lt;/code&gt; プロップ名に特別な意味はありません。 &lt;code&gt;value&lt;/code&gt; や、一般的な規則である &lt;code&gt;onChange&lt;/code&gt; などの名前を付けることもできます。</target>
        </trans-unit>
        <trans-unit id="67cb15262522dd0a8cac5f7e753834e720749476" translate="yes" xml:space="preserve">
          <source>There is no step four. &lt;strong&gt;You have just added the first React component to your website.&lt;/strong&gt;</source>
          <target state="translated">ステップ4はありません。&lt;strong&gt;Webサイトに最初のReactコンポーネントを追加しました。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdbe940e85f9c9f408b6f7b07e4942bd67b971b2" translate="yes" xml:space="preserve">
          <source>There is one caveat to the above example: refs will not get passed through. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not a prop. Like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.</source>
          <target state="translated">上記の例には注意点が1つあります。参照は渡されません。これは、 &lt;code&gt;ref&lt;/code&gt; が小道具ではないためです。 &lt;code&gt;key&lt;/code&gt; と同様に、Reactによって異なる方法で処理されます。HOCに参照を追加すると、参照はラップされたコンポーネントではなく、最も外側のコンテナーコンポーネントを参照します。</target>
        </trans-unit>
        <trans-unit id="edb71d2b04e7a94b003ba55463bb2af6d539a2e7" translate="yes" xml:space="preserve">
          <source>There should be a single &amp;ldquo;source of truth&amp;rdquo; for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">Reactアプリケーションで変更されるデータには、単一の「信頼できる情報源」があるはずです。通常、状態は最初に、レンダリングに必要なコンポーネントに追加されます。その後、他のコンポーネントでも必要な場合は、最も近い共通の祖先まで持ち上げることができます。異なるコンポーネント間で状態を同期する代わりに、&lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;トップダウンのデータフローに&lt;/a&gt;依存する必要があります。</target>
        </trans-unit>
        <trans-unit id="50e2bee19b1efd62498d4e7cf956c72bd6a2c65c" translate="yes" xml:space="preserve">
          <source>There will be no complicated tools or install requirements &amp;mdash; &lt;strong&gt;to complete this section, you only need an internet connection, and a minute of your time.&lt;/strong&gt;</source>
          <target state="translated">複雑なツールやインストール要件はありません。&lt;strong&gt;このセクションを完了するには、インターネット接続と1分の時間だけが必要です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a00d2e6fc2d4c1af40a867da6248d449045f1b6d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing left to try rendering. Because &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; suspended, React shows the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; fallback above it in the tree: &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt;. We&amp;rsquo;re done for now.</source>
          <target state="translated">レンダリングを試すために残っているものは何もありません。 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; が一時停止されているため、Reactはツリー内でその上の最も近い &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; フォールバックを表示します： &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; 。これで完了です。</target>
        </trans-unit>
        <trans-unit id="a8630452d7c496e5f59324dba0cad19af10a411b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing new inside of it &amp;mdash; the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.</source>
          <target state="translated">内部には新しいものは何もありません。ロジックは上のコンポーネントからコピーされます。コンポーネントと同様に、カスタムフックのトップレベルで無条件に他のフックのみを呼び出すようにしてください。</target>
        </trans-unit>
        <trans-unit id="f7952e7362764435c9ea989c8c2fb10bb29a9cee" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still something that feels broken about &lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;our last example&lt;/a&gt;. Sure, it&amp;rsquo;s nice not to see a &amp;ldquo;bad&amp;rdquo; loading state. &lt;strong&gt;But having no indication of progress at all feels even worse!&lt;/strong&gt; When we click &amp;ldquo;Next&amp;rdquo;, nothing happens and it feels like the app is broken.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;最後の例&lt;/a&gt;についてはまだ壊れていると感じていることがあります。確かに、「悪い」ロード状態が表示されないのはいいことです。&lt;strong&gt;しかし、進行の兆候がまったくないことはさらに悪いことです！&lt;/strong&gt;「次へ」をクリックしても何も起こらず、アプリが壊れているように感じます。</target>
        </trans-unit>
        <trans-unit id="a6bddc517086dd36d013186f2bec7354c8db9a7c" translate="yes" xml:space="preserve">
          <source>Therefore, if the condition is &lt;code&gt;true&lt;/code&gt;, the element right after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will appear in the output. If it is &lt;code&gt;false&lt;/code&gt;, React will ignore and skip it.</source>
          <target state="translated">したがって、条件が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; の直後の要素が出力に表示されます。 &lt;code&gt;false&lt;/code&gt; の場合、Reactはそれを無視してスキップします。</target>
        </trans-unit>
        <trans-unit id="acf42ba40fc8ff04bd47c18be64214611d7241a1" translate="yes" xml:space="preserve">
          <source>These acronyms all refer to the most recent versions of the ECMAScript Language Specification standard, which the JavaScript language is an implementation of. The ES6 version (also known as ES2015) includes many additions to the previous versions such as: arrow functions, classes, template literals, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; statements. You can learn more about specific versions &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">これらの頭字語はすべて、JavaScript言語が実装されているECMAScript言語仕様標準の最新バージョンを指します。ES6バージョン（ES2015とも呼ばれます）には、以前のバージョンに加えて、矢印関数、クラス、テンプレートリテラル、 &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; ステートメントなどの多くの追加機能が含まれています。特定のバージョンについて詳しくは、&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c8f570a03b769a433d84e1f653f21208428d0f" translate="yes" xml:space="preserve">
          <source>These additional methods depend on a package (&lt;code&gt;stream&lt;/code&gt;) that is &lt;strong&gt;only available on the server&lt;/strong&gt;, and won&amp;rsquo;t work in the browser.</source>
          <target state="translated">これらの追加のメソッドは&lt;strong&gt;、サーバー&lt;/strong&gt;で&lt;strong&gt;のみ使用可能な&lt;/strong&gt;パッケージ（ &lt;code&gt;stream&lt;/code&gt; ）に依存し、ブラウザーでは機能しません。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25f2c87c8d7c38128e886a538842ed24717179ac" translate="yes" xml:space="preserve">
          <source>These features are still experimental and are subject to change. They are not yet a part of a stable React release, but you can try them in an experimental build.</source>
          <target state="translated">これらの機能はまだ実験的なものであり、変更される可能性があります。これらの機能はまだ安定した React リリースの一部ではありませんが、実験的なビルドで試すことができます。</target>
        </trans-unit>
        <trans-unit id="cfd15dde0728fd1294866669352da44f07f52a05" translate="yes" xml:space="preserve">
          <source>These focus events work on all elements in the React DOM, not just form elements.</source>
          <target state="translated">これらのフォーカスイベントは、フォーム要素だけでなく、React DOM内のすべての要素で動作します。</target>
        </trans-unit>
        <trans-unit id="6edf527844fb9062eb5f03c19c4ca3c36036d6d5" translate="yes" xml:space="preserve">
          <source>These instructions are &lt;em&gt;not&lt;/em&gt; for Create React App users. Even though Create React App uses Babel under the hood, it is already configured to understand Flow. Only follow this step if you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; use Create React App.</source>
          <target state="translated">これらの手順は、Create React Appユーザー向けではあり&lt;em&gt;ません&lt;/em&gt;。Create React Appは内部でBabelを使用していますが、Flowを理解するようにすでに構成されています。Create React Appを使用&lt;em&gt;しない&lt;/em&gt;場合にのみ、この手順に従ってください。</target>
        </trans-unit>
        <trans-unit id="27cd91a26272aaf22f4c969e79b8478aeac76543" translate="yes" xml:space="preserve">
          <source>These methods are called &amp;ldquo;lifecycle methods&amp;rdquo;.</source>
          <target state="translated">これらのメソッドは「ライフサイクルメソッド」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2cf266ce8120d83117da0747bc989507336f90cb" translate="yes" xml:space="preserve">
          <source>These methods are called in the following order when an instance of a component is being created and inserted into the DOM:</source>
          <target state="translated">これらのメソッドは、コンポーネントのインスタンスを作成して DOM に挿入する際に、以下の順番で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b08807c117d4211e82a119e990441e3210202eac" translate="yes" xml:space="preserve">
          <source>These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.</source>
          <target state="translated">これらのメソッドは、レンダリング中、ライフサイクルメソッド、または子コンポーネントのコンストラクタでエラーが発生した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bf826c1be1dddf71c330af16e0387bbeaf491590" translate="yes" xml:space="preserve">
          <source>These methods are considered legacy and you should &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;avoid them&lt;/a&gt; in new code:</source>
          <target state="translated">これらのメソッドはレガシーと見なされて&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;おり&lt;/a&gt;、新しいコードではこれらを回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="5397ce3496bad1b4a47faf92ec8d097aa003eb30" translate="yes" xml:space="preserve">
          <source>These objects are called &amp;ldquo;React elements&amp;rdquo;. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</source>
          <target state="translated">これらのオブジェクトは「React要素」と呼ばれます。それらは、画面に表示したい内容の説明と考えることができます。Reactはこれらのオブジェクトを読み取り、それらを使用してDOMを構築し、それを最新の状態に保ちます。</target>
        </trans-unit>
        <trans-unit id="7b6700f21ab8958202550e8eb63814cd2f217a46" translate="yes" xml:space="preserve">
          <source>These props work similarly to the corresponding HTML attributes, with the exception of the special cases documented above.</source>
          <target state="translated">これらの小道具は、上記で説明した特殊なケースを除いて、対応するHTML属性と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="57b15873af6800f6b7b4f80c07910a05fdb08912" translate="yes" xml:space="preserve">
          <source>These two code snippets are equivalent. While &lt;strong&gt;JSX is &lt;a href=&quot;react-without-jsx&quot;&gt;completely optional&lt;/a&gt;&lt;/strong&gt;, many people find it helpful for writing UI code &amp;mdash; both with React and with other libraries.</source>
          <target state="translated">これら2つのコードスニペットは同等です。一方で&lt;strong&gt;JSXは&lt;a href=&quot;react-without-jsx&quot;&gt;完全にオプション&lt;/a&gt;&lt;/strong&gt;、多くの人々は、UIのコードを書くためにそれが参考-との両方が反応し、他のライブラリと。</target>
        </trans-unit>
        <trans-unit id="ed106eaeea3ec56157f40637b694602b4cae386d" translate="yes" xml:space="preserve">
          <source>These two examples are identical:</source>
          <target state="translated">この2つの例は同じです。</target>
        </trans-unit>
        <trans-unit id="56d15e879fdb4c26d55c62a23500106fee00015c" translate="yes" xml:space="preserve">
          <source>These two functions convert numbers. We will write another function that takes a string &lt;code&gt;temperature&lt;/code&gt; and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</source>
          <target state="translated">これら2つの関数は数値を変換します。文字列 &lt;code&gt;temperature&lt;/code&gt; とコンバーター関数を引数として取り、文字列を返す別の関数を記述します。これを使用して、他の入力に基づいて1つの入力の値を計算します。</target>
        </trans-unit>
        <trans-unit id="3699d971496c4c45664da21c1ceb710a806217eb" translate="yes" xml:space="preserve">
          <source>These two lines of code find the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; we added to our HTML in the first step, and then display our &amp;ldquo;Like&amp;rdquo; button React component inside of it.</source>
          <target state="translated">これらの2行のコードは、最初のステップでHTMLに追加した &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; を見つけ、その中に「いいね」ボタンReactコンポーネントを表示します。</target>
        </trans-unit>
        <trans-unit id="4a0587ca694e69794c117c641540939e9bf9ef81" translate="yes" xml:space="preserve">
          <source>Think of &lt;code&gt;setState()&lt;/code&gt; as a &lt;em&gt;request&lt;/em&gt; rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; は、コンポーネントを更新するための即時コマンドではなく、&lt;em&gt;要求&lt;/em&gt;と考えてください。知覚されるパフォーマンスを向上させるために、Reactはそれを遅延させ、1回のパスで複数のコンポーネントを更新する場合があります。Reactは、状態の変更がすぐに適用されることを保証しません。</target>
        </trans-unit>
        <trans-unit id="82175a17958f607718d88007b35ef471a4c8a4fc" translate="yes" xml:space="preserve">
          <source>Think of all of the pieces of data in our example application. We have:</source>
          <target state="translated">この例のアプリケーションのすべてのデータを考えてみてください。私たちは持っています。</target>
        </trans-unit>
        <trans-unit id="a9605b9c41376c59380ce0d49a74b0c4e4dec5fc" translate="yes" xml:space="preserve">
          <source>Thinking in React</source>
          <target state="translated">Reactで考える</target>
        </trans-unit>
        <trans-unit id="1ac9e8ec0e64fdd160c9350d87ed590c03f195a8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHub comment&lt;/a&gt; dives deep into the specific examples.</source>
          <target state="translated">この&lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHubコメントで&lt;/a&gt;は、具体的な例を詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="80ff15eb59c42a69211ff51d176242fbe4d315e0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;resource&lt;/code&gt; object represents the data that isn&amp;rsquo;t there yet, but might eventually get loaded. When we call &lt;code&gt;read()&lt;/code&gt;, we either get the data, or the component &amp;ldquo;suspends&amp;rdquo;.</source>
          <target state="translated">この &lt;code&gt;resource&lt;/code&gt; オブジェクトは、まだ存在しないデータを表しますが、最終的にはロードされる可能性があります。 &lt;code&gt;read()&lt;/code&gt; を呼び出すと、データを取得するか、コンポーネントを「一時停止」します。</target>
        </trans-unit>
        <trans-unit id="476f561e8a18c3f9a07a3bccf37bcc7bf21f3874" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;inversion of control&lt;/em&gt; can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. However, this isn&amp;rsquo;t the right choice in every case: moving more complexity higher in the tree makes those higher-level components more complicated and forces the lower-level components to be more flexible than you may want.</source>
          <target state="translated">この&lt;em&gt;制御の反転により&lt;/em&gt;、多くの場合、アプリケーションを通過する必要のある小道具の量を減らし、ルートコンポーネントにより多くの制御を与えることにより、コードをよりクリーンにすることができます。ただし、これはすべての場合に適切な選択ではありません。ツリーの複雑度を上げると、上位レベルのコンポーネントがより複雑になり、下位レベルのコンポーネントが必要以上に柔軟になります。</target>
        </trans-unit>
        <trans-unit id="c2d8fcc8f1d3d88cd2e77fadce662c854a2e0c6b" translate="yes" xml:space="preserve">
          <source>This API was introduced as a replacement of the deprecated &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt;.</source>
          <target state="translated">このAPIは、非推奨の &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt; の代わりとして導入されました。</target>
        </trans-unit>
        <trans-unit id="65ff46d55592f673e6ce548bfba9bb56b9ccffbe" translate="yes" xml:space="preserve">
          <source>This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and function components. And because it&amp;rsquo;s a pure function, it&amp;rsquo;s composable with other HOCs, or even with itself.</source>
          <target state="translated">このHOCは、衝突の可能性を回避しながら、変更バージョンと同じ機能を備えています。これは、クラスおよび関数コンポーネントでも同様に機能します。そして、それは純粋な関数なので、他のHOCと、またはそれ自体と組み合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="d22c37d9cec94e4690e2dd97d9efbf3bb2f8b371" translate="yes" xml:space="preserve">
          <source>This JavaScript syntax is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&amp;ldquo;array destructuring&amp;rdquo;&lt;/a&gt;. It means that we&amp;rsquo;re making two new variables &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;setFruit&lt;/code&gt;, where &lt;code&gt;fruit&lt;/code&gt; is set to the first value returned by &lt;code&gt;useState&lt;/code&gt;, and &lt;code&gt;setFruit&lt;/code&gt; is the second. It is equivalent to this code:</source>
          <target state="translated">このJavaScript構文は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;「配列の構造化解除」&lt;/a&gt;と呼ばれます。私たちは二つの新しい変数を作っていることを意味し &lt;code&gt;fruit&lt;/code&gt; や &lt;code&gt;setFruit&lt;/code&gt; 、 &lt;code&gt;fruit&lt;/code&gt; で返される最初の値に設定されている &lt;code&gt;useState&lt;/code&gt; を、そして &lt;code&gt;setFruit&lt;/code&gt; は秒です。これは次のコードと同等です。</target>
        </trans-unit>
        <trans-unit id="f39d319ca5796008fa8e12b9089eeb33281858c9" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lag behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="translated">これにより、 &lt;code&gt;input&lt;/code&gt; 用の新しいテキストの表示をすぐに開始できるため、Webページの応答性を高めることができます。一方、 &lt;code&gt;MySlowList&lt;/code&gt; は、更新前の &lt;code&gt;timeoutMs&lt;/code&gt; に従って最大2秒間「遅れ」、現在のテキストをバックグラウンドでレンダリングできるようにします。</target>
        </trans-unit>
        <trans-unit id="2faedabcd971bfb80a56e6a80e4761e335043c56" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lags behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="translated">これにより、 &lt;code&gt;input&lt;/code&gt; 用の新しいテキストの表示をすぐに開始できるため、Webページが応答しやすくなります。一方、 &lt;code&gt;MySlowList&lt;/code&gt; は、更新前の &lt;code&gt;timeoutMs&lt;/code&gt; に従って最大2秒間「遅れ」、現在のテキストをバックグラウンドでレンダリングできるようにします。</target>
        </trans-unit>
        <trans-unit id="7aada4a90bf5f5f9b0e68049574b4b5eb9269c5b" translate="yes" xml:space="preserve">
          <source>This also allows you to handle out-of-order responses with a local variable inside the effect:</source>
          <target state="translated">また、これにより、エフェクト内のローカル変数を使用して、順番外のレスポンスを処理することができます。</target>
        </trans-unit>
        <trans-unit id="d31f740bc3cca1056bef47f761e3120ae5f4ad05" translate="yes" xml:space="preserve">
          <source>This also works for effects that have a cleanup phase:</source>
          <target state="translated">これは、クリーンアップフェイズを持つエフェクトにも有効です。</target>
        </trans-unit>
        <trans-unit id="c00c421c14ae8acb27703b9f15f007c9b9f49302" translate="yes" xml:space="preserve">
          <source>This also works for user-defined components:</source>
          <target state="translated">これは、ユーザー定義のコンポーネントに対しても機能します。</target>
        </trans-unit>
        <trans-unit id="9dd47e6d4547b62faa16a4d7bcc454ad3c75bf3e" translate="yes" xml:space="preserve">
          <source>This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.</source>
          <target state="translated">このアプローチは、React の宣言的 API を可能にします。UI をどのような状態にしたいかを React に伝えると、DOM がその状態にマッチしていることを確認します。これにより、アプリを構築するために使用しなければならない属性操作、イベント処理、手動の DOM 更新が省かれます。</target>
        </trans-unit>
        <trans-unit id="52a664b8479bda397f841c5ef66ce5073db36b03" translate="yes" xml:space="preserve">
          <source>This approach is fine for learning and creating simple demos. However, it makes your website slow and &lt;strong&gt;isn&amp;rsquo;t suitable for production&lt;/strong&gt;. When you&amp;rsquo;re ready to move forward, remove this new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attributes you&amp;rsquo;ve added. Instead, in the next section you will set up a JSX preprocessor to convert all your &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags automatically.</source>
          <target state="translated">このアプローチは、簡単なデモの学習と作成には適しています。ただし、ウェブサイトが遅くなり&lt;strong&gt;、本番&lt;/strong&gt;環境に&lt;strong&gt;は適していません&lt;/strong&gt;。次に進む準備ができたら、この新しい &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグと、追加した &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; 属性を削除します。代わりに、次のセクションでは、すべての &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを自動的に変換するようにJSXプリプロセッサを設定します。</target>
        </trans-unit>
        <trans-unit id="dc7a58c1bb894f6665e299a7d4744f572f039148" translate="yes" xml:space="preserve">
          <source>This approach will work for our specific use case, but we haven&amp;rsquo;t achieved the objective of truly encapsulating the behavior in a reusable way. Now, every time we want the mouse position for a different use case, we have to create a new component (i.e. essentially another &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt;) that renders something specifically for that use case.</source>
          <target state="translated">このアプローチは特定のユースケースで機能しますが、再利用可能な方法で動作を本当にカプセル化するという目的を達成していません。ここで、別のユースケースでマウスの位置が必要になるたびに、そのユースケース用に何かをレンダリングする新しいコンポーネント（つまり、基本的には別の &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt; ）を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="2e57d12892a38e7dcd020760497cd1e93da0684e" translate="yes" xml:space="preserve">
          <source>This avoids creating an expensive object until it&amp;rsquo;s truly needed for the first time. If you use Flow or TypeScript, you can also give &lt;code&gt;getObserver()&lt;/code&gt; a non-nullable type for convenience.</source>
          <target state="translated">これにより、本当に本当に必要になるまで、高価なオブジェクトを作成する必要がなくなります。FlowまたはTypeScriptを使用する場合、利便性のために &lt;code&gt;getObserver()&lt;/code&gt; に nullを許容しない型を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="f4bfd1fe7162ecd3d60fc0279dd88e809b50adee" translate="yes" xml:space="preserve">
          <source>This behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.</source>
          <target state="translated">この動作はデフォルトで一貫性を確保し、更新ロジックの欠落によるクラスコンポーネントにありがちなバグを防ぎます。</target>
        </trans-unit>
        <trans-unit id="57cd10a74bd70a6ee7ad4242517da20969dce195" translate="yes" xml:space="preserve">
          <source>This behavior is usually not relevant. It&amp;rsquo;s only mentioned here for completeness.</source>
          <target state="translated">通常、この動作は関係ありません。ここでは、完全を期すためにのみ言及しています。</target>
        </trans-unit>
        <trans-unit id="36d268dd874440a54786b6aa3e4fd35dffcea642" translate="yes" xml:space="preserve">
          <source>This can be a problem with more complex data structures. For example, let&amp;rsquo;s say you want a &lt;code&gt;ListOfWords&lt;/code&gt; component to render a comma-separated list of words, with a parent &lt;code&gt;WordAdder&lt;/code&gt; component that lets you click a button to add a word to the list. This code does &lt;em&gt;not&lt;/em&gt; work correctly:</source>
          <target state="translated">これは、より複雑なデータ構造で問題になる可能性があります。たとえば、 &lt;code&gt;ListOfWords&lt;/code&gt; コンポーネントで単語のコンマ区切りのリストをレンダリングし、ボタンをクリックして単語をリストに追加できる親の &lt;code&gt;WordAdder&lt;/code&gt; コンポーネントを使用するとします。このコードは正しく機能し&lt;em&gt;ませ&lt;/em&gt;ん：</target>
        </trans-unit>
        <trans-unit id="e3fd91e7d534e8d25e2851069fc549d8b17681ec" translate="yes" xml:space="preserve">
          <source>This can be useful to conditionally render React elements. This JSX renders the &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; component only if &lt;code&gt;showHeader&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">これは、React要素を条件付きでレンダリングするのに役立ちます。このJSXは、 &lt;code&gt;showHeader&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; コンポーネントをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="4cda35b9ac3d3dc1a2fb8d778758e7d5c8c67eb1" translate="yes" xml:space="preserve">
          <source>This can lead to a lot of repetitive code across components. This is why &lt;strong&gt;we generally recommend to bake &lt;code&gt;useTransition&lt;/code&gt; into the &lt;em&gt;design system&lt;/em&gt; components of your app&lt;/strong&gt;. For example, we can extract the transition logic into our own &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">これにより、コンポーネント間で多くの反復的なコードが発生する可能性があります。理由はここにあり&lt;strong&gt;、我々は一般的に焼くにお勧め &lt;code&gt;useTransition&lt;/code&gt; に&lt;em&gt;設計システム&lt;/em&gt;のアプリのコンポーネント&lt;/strong&gt;。たとえば、遷移ロジックを独自の &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; コンポーネントに抽出できます。</target>
        </trans-unit>
        <trans-unit id="0acb8e50c6ec942725a3ba4829c748d2a76cb440" translate="yes" xml:space="preserve">
          <source>This change has an important implication. &lt;strong&gt;As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.&lt;/strong&gt;</source>
          <target state="translated">この変更には重要な意味があります。&lt;strong&gt;React 16以降、エラー境界でキャッチされなかったエラーにより、Reactコンポーネントツリー全体がアンマウントされます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45bd4df84d8256fb24d5cb41b9549c58035a0dac" translate="yes" xml:space="preserve">
          <source>This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong.</source>
          <target state="translated">この変更は、React 16 に移行する際に、これまで気づかなかったアプリケーションの既存のクラッシュを発見する可能性が高いことを意味します。エラーの境界線を追加することで、何か問題が発生したときに、より良いユーザーエクスペリエンスを提供することができます。</target>
        </trans-unit>
        <trans-unit id="6ef0e2d23198ee6495349b5b1d8a65e07c969027" translate="yes" xml:space="preserve">
          <source>This code &lt;strong&gt;will not&lt;/strong&gt; work if you transform classes with Babel. See &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;this issue&lt;/a&gt; for the discussion. Include the &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapter&lt;/a&gt; before you load your web components to fix this issue.</source>
          <target state="translated">このコード&lt;strong&gt;は&lt;/strong&gt;、Babelでクラスを変換する場合&lt;strong&gt;は機能しません&lt;/strong&gt;。議論については、&lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;この問題&lt;/a&gt;を参照してください。この問題を修正するためにWebコンポーネントをロードする前に、&lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapterを&lt;/a&gt;含めます。</target>
        </trans-unit>
        <trans-unit id="75a9a87d91df5d83f693447e427e9a52b32eb756" translate="yes" xml:space="preserve">
          <source>This code calls &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt;. But if the dependencies &lt;code&gt;[a, b]&lt;/code&gt; haven&amp;rsquo;t changed since the last value, &lt;code&gt;useMemo&lt;/code&gt; skips calling it a second time and simply reuses the last value it returned.</source>
          <target state="translated">このコードは、 &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt; 呼び出します。ただし、依存関係 &lt;code&gt;[a, b]&lt;/code&gt; が最後の値以降変更されていない場合、 &lt;code&gt;useMemo&lt;/code&gt; は2回目の呼び出しをスキップし、返された最後の値を再利用します。</target>
        </trans-unit>
        <trans-unit id="81c06c00fb945143b7361b0df45a46e15659b746" translate="yes" xml:space="preserve">
          <source>This code defines a React component called &lt;code&gt;LikeButton&lt;/code&gt;. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand it yet &amp;mdash; we&amp;rsquo;ll cover the building blocks of React later in our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;hands-on tutorial&lt;/a&gt; and &lt;a href=&quot;index&quot;&gt;main concepts guide&lt;/a&gt;. For now, let&amp;rsquo;s just get it showing on the screen!</source>
          <target state="translated">このコードは、 &lt;code&gt;LikeButton&lt;/code&gt; というReactコンポーネントを定義しています。まだ理解していなくても心配しないでください。Reactの構成要素については、後で&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;実践的&lt;/a&gt;&lt;a href=&quot;index&quot;&gt;な&lt;/a&gt;チュートリアルと主要なコンセプトガイドで説明します。とりあえず、画面に表示させましょう！</target>
        </trans-unit>
        <trans-unit id="ec10d5aea9322aa37f3498ec1bf3e0477eec9989" translate="yes" xml:space="preserve">
          <source>This code displays a bullet list of numbers between 1 and 5.</source>
          <target state="translated">このコードは、1から5までの数字の箇条書きリストを表示します。</target>
        </trans-unit>
        <trans-unit id="0909f97a53314c9c73d25a10366a5436355b5bcb" translate="yes" xml:space="preserve">
          <source>This code exposes the functionality to both pointer device and keyboard users. Also note the added &lt;code&gt;aria-*&lt;/code&gt; props to support screen-reader users. For simplicity&amp;rsquo;s sake the keyboard events to enable &lt;code&gt;arrow key&lt;/code&gt; interaction of the popover options have not been implemented.</source>
          <target state="translated">このコードは、ポインターデバイスとキーボードユーザーの両方に機能を公開します。また、スクリーンリーダーユーザーをサポートするために追加された &lt;code&gt;aria-*&lt;/code&gt; プロップに注意してください。簡単にするために、ポップオーバーオプションの &lt;code&gt;arrow key&lt;/code&gt; 操作を可能にするキーボードイベントは実装されていません。</target>
        </trans-unit>
        <trans-unit id="d03bff01f1b2c1f0ab0a8b09ec93a5ca0ae8ec22" translate="yes" xml:space="preserve">
          <source>This code is deceptively easy to read.</source>
          <target state="translated">このコードは騙されないように簡単に読めます。</target>
        </trans-unit>
        <trans-unit id="9c3f4795fe6fc80bbb24c51583253bdab9f12c27" translate="yes" xml:space="preserve">
          <source>This code is very readable, but unlike the examples earlier, the Suspense version doesn&amp;rsquo;t suffer from race conditions. You might be wondering why. The answer is that in the Suspense version, we don&amp;rsquo;t have to think about &lt;em&gt;time&lt;/em&gt; as much in our code. Our original code with race conditions needed to set the state &lt;em&gt;at the right moment later&lt;/em&gt;, or otherwise it would be wrong. But with Suspense, we set the state &lt;em&gt;immediately&lt;/em&gt; &amp;mdash; so it&amp;rsquo;s harder to mess it up.</source>
          <target state="translated">このコードは非常に読みやすいですが、前の例とは異なり、サスペンスバージョンは競合状態の影響を受けません。なぜだろうと思うかもしれません。答えは、サスペンスバージョンでは、コードで&lt;em&gt;時間&lt;/em&gt;をそれほど考慮する必要がないということです。競合状態を含む元のコードは、&lt;em&gt;後で適切なタイミングで&lt;/em&gt;状態を設定するために必要でした。しかし、Suspenseを使用すると、&lt;em&gt;すぐ&lt;/em&gt;に状態が設定されます。そのため、混乱させることは困難です。</target>
        </trans-unit>
        <trans-unit id="aa231c70c510f0fa3b63aa156a3b29b91e637dfa" translate="yes" xml:space="preserve">
          <source>This code logs &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; to the console.</source>
          <target state="translated">このコードは、コンソールに[2、4、6、8、10 &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; を記録します。</target>
        </trans-unit>
        <trans-unit id="6a6f4f287ca192e5cbaa9fe54b7458432ec57111" translate="yes" xml:space="preserve">
          <source>This code uses a &lt;code&gt;ref&lt;/code&gt; to store a reference to a DOM node:</source>
          <target state="translated">このコードは、 &lt;code&gt;ref&lt;/code&gt; を使用してDOMノードへの参照を格納します。</target>
        </trans-unit>
        <trans-unit id="6a8d7c8fd298f61f6a8bbce768774e83c0634e4e" translate="yes" xml:space="preserve">
          <source>This command installs the latest version of Flow into your project.</source>
          <target state="translated">このコマンドは、Flowの最新バージョンをプロジェクトにインストールします。</target>
        </trans-unit>
        <trans-unit id="e2822f37a50da57c71f17598917890486aef2cbb" translate="yes" xml:space="preserve">
          <source>This command will create a Flow configuration file that you will need to commit.</source>
          <target state="translated">このコマンドは、コミットする必要のあるフロー設定ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="7e628fdea4b27c53ebdbd7cfcab1d2dfb0cb46e5" translate="yes" xml:space="preserve">
          <source>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let&amp;rsquo;s extract a few components from it.</source>
          <target state="translated">このコンポーネントはすべてネストされているため、変更が難しく、個々のパーツを再利用することも困難です。それからいくつかのコンポーネントを抽出しましょう。</target>
        </trans-unit>
        <trans-unit id="9a4e11fd53e38859e2f4e904e8bc53c30f989275" translate="yes" xml:space="preserve">
          <source>This convention helps ensure that HOCs are as flexible and reusable as possible.</source>
          <target state="translated">この規約は、HOCが可能な限り柔軟で再利用可能なものであることを保証するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="b994c283ac2682b4140498a38b7c06a032ede4f8" translate="yes" xml:space="preserve">
          <source>This demo is a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t quite make sense yet. We&amp;rsquo;ll talk more about how it works below. Keep in mind that Suspense is more of a &lt;em&gt;mechanism&lt;/em&gt;, and particular APIs like &lt;code&gt;fetchProfileData()&lt;/code&gt; or &lt;code&gt;resource.posts.read()&lt;/code&gt; in the above example are not very important. If you&amp;rsquo;re curious, you can find their definitions right in the &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;demo sandbox&lt;/a&gt;.</source>
          <target state="translated">このデモはティーザーです。まだ意味がわからなくても心配しないでください。それがどのように機能するかについては、以下で詳しく説明します。Suspenseはより&lt;em&gt;メカニズム&lt;/em&gt;であり、上記の例の &lt;code&gt;fetchProfileData()&lt;/code&gt; や &lt;code&gt;resource.posts.read()&lt;/code&gt; などの特定のAPI はそれほど重要ではないことに注意してください。興味があれば、その定義を&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;デモのサンドボックス&lt;/a&gt;で見つけることができます。</target>
        </trans-unit>
        <trans-unit id="c154659e1f7cd40edb5f4f1f5bd3d6e54fcb386b" translate="yes" xml:space="preserve">
          <source>This document goes through the factors that can affect your environment and recommendations for some scenarios.</source>
          <target state="translated">このドキュメントでは、あなたの環境に影響を与える要因と、いくつかのシナリオのための推奨事項について説明しています。</target>
        </trans-unit>
        <trans-unit id="35b8fd0fdad43cdb6f7a55761174dc27e6567773" translate="yes" xml:space="preserve">
          <source>This document will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.</source>
          <target state="translated">このドキュメントは、フレームワークやライブラリ、開発者向けツールを扱う開発者に最も関連するものです。React を主にユーザー向けアプリケーションを構築するために使用している開発者は、当社のプレリリースチャンネルを気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="435796402e94e0bfce47d4b1891156df1a181824" translate="yes" xml:space="preserve">
          <source>This documentation always reflects the latest stable version of React. Since React 16, you can find older versions of the documentation on a &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;separate page&lt;/a&gt;. Note that documentation for past versions is snapshotted at the time of the release, and isn&amp;rsquo;t being continuously updated.</source>
          <target state="translated">このドキュメントは常に最新の安定したバージョンのReactを反映しています。React 16以降、&lt;a href=&quot;https://reactjs.org/versions&quot;&gt;別のページで&lt;/a&gt;古いバージョンのドキュメントを見つけることができます。過去のバージョンのドキュメントはリリース時にスナップショットが取られており、継続的に更新されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4f71278bd00ce0cd4a740cd181d9c507c3a29e6b" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now.</source>
          <target state="translated">このドキュメントは、早期導入者と好奇心の強い人々を対象としています。&lt;strong&gt;Reactを初めて使用する場合でも、これらの機能について心配する&lt;/strong&gt;必要はありません。今すぐに学ぶ必要はありません。</target>
        </trans-unit>
        <trans-unit id="437152ef0fb92cb09cfcc08f167fa7c209605af6" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now. For example, if you&amp;rsquo;re looking for a data fetching tutorial that works today, read &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; instead.</source>
          <target state="translated">このドキュメントは、早期導入者と好奇心の強い人々を対象としています。&lt;strong&gt;Reactを初めて使用する場合でも、これらの機能について心配する&lt;/strong&gt;必要はありません。今すぐに学ぶ必要はありません。たとえば、今日機能するデータフェッチチュートリアルを探している場合は、代わりに&lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;この記事&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="b3b7a9dc3eaa0b9d881ea28d247bfcc301b885f9" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of scope of this section.</source>
          <target state="translated">このドキュメントのセクションでは、最初のケースのテスト戦略に焦点を当てます。完全なエンドツーエンドテストは重要なワークフローへのリグレッションを防ぐために非常に有用ですが、そのようなテストは特に React コンポーネントには関係がなく、このセクションの対象外です。</target>
        </trans-unit>
        <trans-unit id="3240812f318bd40bfe50a481d020711afec7ad2b" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of the scope of this section.</source>
          <target state="translated">このドキュメントのセクションでは、最初のケースのテスト戦略に焦点を当てます。完全なエンドツーエンドテストは重要なワークフローへのリグレッションを防ぐために非常に有用ですが、そのようなテストは特に React コンポーネントには関係なく、このセクションの対象外です。</target>
        </trans-unit>
        <trans-unit id="922990d6659447b8f59207b30b32f18ac5da5266" translate="yes" xml:space="preserve">
          <source>This documentation section is useful when you want to learn more details about a particular React API. For example, &lt;a href=&quot;react-component&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt; API reference&lt;/a&gt; can provide you with details on how &lt;code&gt;setState()&lt;/code&gt; works, and what different lifecycle methods are useful for.</source>
          <target state="translated">このドキュメントセクションは、特定のReact APIの詳細を知りたい場合に役立ちます。たとえば、&lt;a href=&quot;react-component&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; APIリファレンス&lt;/a&gt;は、 &lt;code&gt;setState()&lt;/code&gt; がどのように機能するか、およびさまざまなライフサイクルメソッドがどのように役立つかについての詳細を提供します。</target>
        </trans-unit>
        <trans-unit id="6e0fc508cf47e625d8de371f53892327cc9e9bdd" translate="yes" xml:space="preserve">
          <source>This does not mean it is impossible or even necessarily difficult to combine React with other ways of affecting the DOM, you just have to be mindful of what each is doing.</source>
          <target state="translated">これは、React と DOM に影響を与える他の方法を組み合わせることが不可能であるとか、必ずしも難しいという意味ではなく、それぞれが何をしているかに注意する必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="b8276e9f3cf97b98c079c64319a9395bb85c298e" translate="yes" xml:space="preserve">
          <source>This enables a better &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;error handling experience&lt;/a&gt; in React 16 and later.</source>
          <target state="translated">これにより、React 16以降での&lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;エラー処理エクスペリエンス&lt;/a&gt;が向上します。</target>
        </trans-unit>
        <trans-unit id="6271e95bb91f56ffa298799cf7094cffbc64f6c4" translate="yes" xml:space="preserve">
          <source>This ensures, for example, that if both &lt;code&gt;Parent&lt;/code&gt; and &lt;code&gt;Child&lt;/code&gt; call &lt;code&gt;setState&lt;/code&gt; during a click event, &lt;code&gt;Child&lt;/code&gt; isn&amp;rsquo;t re-rendered twice. Instead, React &amp;ldquo;flushes&amp;rdquo; the state updates at the end of the browser event. This results in significant performance improvements in larger apps.</source>
          <target state="translated">これにより、たとえば、 &lt;code&gt;Parent&lt;/code&gt; と &lt;code&gt;Child&lt;/code&gt; 両方がクリックイベント中に &lt;code&gt;setState&lt;/code&gt; を呼び出した場合、 &lt;code&gt;Child&lt;/code&gt; が2回再レンダリングされないことが保証されます。代わりに、Reactはブラウザーイベントの最後に状態の更新を「フラッシュ」します。これにより、大きなアプリのパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="eee2a3b437fecc5c5822dcc3a1aa7661967a85bb" translate="yes" xml:space="preserve">
          <source>This example is modified for hooks from a previous example in the &lt;a href=&quot;context&quot;&gt;Context Advanced Guide&lt;/a&gt;, where you can find more information about when and how to use Context.</source>
          <target state="translated">この例は、&lt;a href=&quot;context&quot;&gt;Context Advanced Guideの&lt;/a&gt;前の例のフック用に変更されています。ここでは、Contextをいつどのように使用するかについての詳細情報を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="46bc9849fafc7153a5665495ec0e17727641f27f" translate="yes" xml:space="preserve">
          <source>This example renders a counter. When you click the button, it increments the value:</source>
          <target state="translated">この例では、カウンタをレンダリングしています。ボタンをクリックすると、値がインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="25d9404a127c52ed8d6407f955450a6c3892e5d8" translate="yes" xml:space="preserve">
          <source>This example renders a different greeting depending on the value of &lt;code&gt;isLoggedIn&lt;/code&gt; prop.</source>
          <target state="translated">この例では、 &lt;code&gt;isLoggedIn&lt;/code&gt; プロパティの値に応じて異なる挨拶をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="b723244ac7769f9d42bc741d1cc7c26e97275391" translate="yes" xml:space="preserve">
          <source>This feature was added to JavaScript in ES2018.</source>
          <target state="translated">ES2018のJavaScriptにこの機能が追加されました。</target>
        </trans-unit>
        <trans-unit id="9fa578e3db7433d9dce5a039b28793d6ebc08f28" translate="yes" xml:space="preserve">
          <source>This feels a lot better! Clicking &amp;ldquo;Refresh&amp;rdquo; doesn&amp;rsquo;t pull us away from the page we&amp;rsquo;re browsing anymore. We see something is loading &amp;ldquo;inline&amp;rdquo;, and when the data is ready, it&amp;rsquo;s displayed.</source>
          <target state="translated">これはずっと気持ちいいです！「更新」をクリックしても、閲覧しているページから離れることはありません。何かが「インライン」でロードされているのがわかり、データの準備ができると表示されます。</target>
        </trans-unit>
        <trans-unit id="53a0f3e6dfc92e9db69114ebee6eb233f6ffcd07" translate="yes" xml:space="preserve">
          <source>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it&amp;rsquo;s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called &amp;ldquo;controlled components&amp;rdquo;.</source>
          <target state="translated">このフォームには、ユーザーがフォームを送信したときに新しいページを参照するというデフォルトのHTMLフォーム動作があります。Reactでこの動作が必要な場合は、機能します。しかし、ほとんどの場合、フォームの送信を処理し、ユーザーがフォームに入力したデータにアクセスできるJavaScript関数があると便利です。これを実現する標準的な方法は、「制御されたコンポーネント」と呼ばれる手法を使用することです。</target>
        </trans-unit>
        <trans-unit id="ab7820f59467fdd32ce070f1b80bfd31db68d1ae" translate="yes" xml:space="preserve">
          <source>This form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the &lt;code&gt;connect&lt;/code&gt; function have the signature &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt;. Functions whose output type is the same as its input type are really easy to compose together.</source>
          <target state="translated">このフォームは混乱するか不要と思われるかもしれませんが、便利な特性があります。 &lt;code&gt;connect&lt;/code&gt; 関数によって返されるような単一引数のHOCには、シグネチャ &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt; 。出力タイプが入力タイプと同じである関数は、組み合わせるのが本当に簡単です。</target>
        </trans-unit>
        <trans-unit id="cb9e95f2893a4866bae321fd4e53d2d167c573c0" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;setState()&lt;/code&gt; is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:</source>
          <target state="translated">この形式の &lt;code&gt;setState()&lt;/code&gt; も非同期であり、同じサイクル中の複数の呼び出しをバッチ処理できます。たとえば、同じサイクルでアイテムの数量を複数回インクリメントしようとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="42fc90231014ca33898b042e3cf5d5166ecf1c1c" translate="yes" xml:space="preserve">
          <source>This function is a valid React component because it accepts a single &amp;ldquo;props&amp;rdquo; (which stands for properties) object argument with data and returns a React element. We call such components &amp;ldquo;function components&amp;rdquo; because they are literally JavaScript functions.</source>
          <target state="translated">この関数は、データを持つ単一の「props」（プロパティを表す）オブジェクト引数を受け入れ、React要素を返すため、有効なReactコンポーネントです。これらのコンポーネントは、文字通りJavaScript関数であるため、「関数コンポーネント」と呼びます。</target>
        </trans-unit>
        <trans-unit id="ebc1a8ba6d4628a8a3c7196192f99a87a1bd99af" translate="yes" xml:space="preserve">
          <source>This funny tag syntax is neither a string nor HTML.</source>
          <target state="translated">このおかしなタグ構文は、文字列でもHTMLでもありません。</target>
        </trans-unit>
        <trans-unit id="4443039824b2698985c389ddf03cc24cafe1255b" translate="yes" xml:space="preserve">
          <source>This gets at the root of what Concurrent Mode is. We&amp;rsquo;ve &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;previously said&lt;/a&gt; it&amp;rsquo;s a bit like React working on state update on a &amp;ldquo;branch&amp;rdquo;. Another way we can conceptualize is that wrapping a state update in &lt;code&gt;startTransition&lt;/code&gt; begins rendering it &lt;em&gt;&amp;ldquo;in a different universe&amp;rdquo;&lt;/em&gt;, much like in science fiction movies. We don&amp;rsquo;t &amp;ldquo;see&amp;rdquo; that universe directly &amp;mdash; but we can get a signal from it that tells us something is happening (&lt;code&gt;isPending&lt;/code&gt;). When the update is ready, our &amp;ldquo;universes&amp;rdquo; merge back together, and we see the result on the screen!</source>
          <target state="translated">これは、並行モードとは何かの根底にあります。&lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;以前は&lt;/a&gt;、Reactが「ブランチ」の状態更新に取り組んでいるようなものだと以前に述べました。概念化できるもう1つの方法は、状態の更新を &lt;code&gt;startTransition&lt;/code&gt; でラップすると、SF映画のように、&lt;em&gt;「別の宇宙で」&lt;/em&gt;レンダリングを開始することです。その宇宙を直接「見る」ことはしませんが、何かが起こっていることを知らせる信号（ &lt;code&gt;isPending&lt;/code&gt; ）を宇宙から得ることができます。更新の準備ができると、「ユニバース」が結合され、画面に結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="998f34489f4bb64d39d8842ae0c316430832dd96" translate="yes" xml:space="preserve">
          <source>This guide is designed for people who prefer &lt;strong&gt;learning concepts step by step&lt;/strong&gt;. If you prefer to learn by doing, check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. You might find this guide and the tutorial complementary to each other.</source>
          <target state="translated">このガイドは、&lt;strong&gt;概念を段階的に学習する&lt;/strong&gt;ことを好む人を対象としています。&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;実践&lt;/a&gt;して学習したい場合は、実践的なチュートリアルをご覧ください。このガイドとチュートリアルは互いに補完し合うかもしれません。</target>
        </trans-unit>
        <trans-unit id="a85cf72b8fe4c4bfdcedf2d7561fb56fd2aca5d8" translate="yes" xml:space="preserve">
          <source>This guide occasionally uses some of the newer JavaScript syntax in the examples. If you haven&amp;rsquo;t worked with JavaScript in the last few years, &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;these three points&lt;/a&gt; should get you most of the way.</source>
          <target state="translated">このガイドでは、例で新しいJavaScript構文の一部を使用することがあります。過去数年間にJavaScriptを使用したことがない場合は、&lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;これらの3つのポイント&lt;/a&gt;により、ほとんどの方法が得られます。</target>
        </trans-unit>
        <trans-unit id="81e4ce45e3f3a7f95f58bb8c19a35f09c68f268f" translate="yes" xml:space="preserve">
          <source>This has an interesting implication. Even if we use a GraphQL client that collects all data requirements in a single request, &lt;em&gt;streaming the response lets us show more content sooner&lt;/em&gt;. Because we render-&lt;em&gt;as-we-fetch&lt;/em&gt; (as opposed to &lt;em&gt;after&lt;/em&gt; fetching), if &lt;code&gt;user&lt;/code&gt; appears in the response earlier than &lt;code&gt;posts&lt;/code&gt;, we&amp;rsquo;ll be able to &amp;ldquo;unlock&amp;rdquo; the outer &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary before the response even finishes. We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering. Suspense doesn&amp;rsquo;t inherently suffer from this waterfall, and libraries like Relay take advantage of this.</source>
          <target state="translated">これには興味深い意味があります。 1つのリクエストですべてのデータ要件を収集するGraphQLクライアントを使用している場合でも&lt;em&gt;、レスポンスをストリーミングすることで、より多くのコンテンツをより早く表示できます&lt;/em&gt;。（&lt;em&gt;フェッチ&lt;/em&gt;した&lt;em&gt;後で&lt;/em&gt;はなく）&lt;em&gt;フェッチし&lt;/em&gt;てレンダリングするため、 &lt;code&gt;user&lt;/code&gt; が &lt;code&gt;posts&lt;/code&gt; よりも前に応答に表示される場合、応答が&lt;em&gt;完了&lt;/em&gt;する前に外側の &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界を「ロック解除」できます。以前はこれを見逃していたかもしれませんが、フェッチしてからレンダリングするソリューションでさえ、フェッチとレンダリングの間にウォーターフォールが含まれていました。サスペンスは本質的にこのウォーターフォールに悩まされることはなく、リレーのようなライブラリはこれを利用しています。</target>
        </trans-unit>
        <trans-unit id="ff59847832eda94cc856a80d664ae3e8945e2a20" translate="yes" xml:space="preserve">
          <source>This helper is considered legacy, and we encourage you to either use JSX or use &lt;code&gt;React.createElement()&lt;/code&gt; directly instead.</source>
          <target state="translated">このヘルパーはレガシーと見なされているため、代わりにJSXを使用するか、 &lt;code&gt;React.createElement()&lt;/code&gt; を直接使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="45b88d2165ef4f3c9c1467a053131dbd114d3bd3" translate="yes" xml:space="preserve">
          <source>This helps make your tests run closer to what real users would experience when using your application. The rest of these examples use &lt;code&gt;act()&lt;/code&gt; to make these guarantees.</source>
          <target state="translated">これにより、実際のユーザーがアプリケーションを使用するときに体験するものにより近いテストを実行できます。これらの例の残りの部分では、 &lt;code&gt;act()&lt;/code&gt; を使用してこれらの保証を行っています。</target>
        </trans-unit>
        <trans-unit id="812baa4dde898829de6f1ec51ca212cbe1c227c1" translate="yes" xml:space="preserve">
          <source>This illustrates how UI libraries, including React, typically work today. Once they start rendering an update, including creating new DOM nodes and running the code inside components, they can&amp;rsquo;t interrupt this work. We&amp;rsquo;ll call this approach &amp;ldquo;blocking rendering&amp;rdquo;.</source>
          <target state="translated">これは、Reactを含むUIライブラリーが今日、通常どのように機能するかを示しています。新しいDOMノードの作成やコンポーネント内のコードの実行など、更新のレンダリングを開始したら、この作業を中断することはできません。このアプローチを「ブロッキングレンダリング」と呼びます。</target>
        </trans-unit>
        <trans-unit id="fa7d8e8505d96d032001acde26d204de1f9b82ac" translate="yes" xml:space="preserve">
          <source>This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing &lt;em&gt;React tree&lt;/em&gt;, even if those elements are not ancestors in the &lt;em&gt;DOM tree&lt;/em&gt;. Assuming the following HTML structure:</source>
          <target state="translated">これには、イベントバブリングが含まれます。ポータルの内部から発生したイベントは、それらの要素が&lt;em&gt;DOMツリーの&lt;/em&gt;祖先でなくても、含まれている&lt;em&gt;Reactツリーの&lt;/em&gt;祖先に伝播し&lt;em&gt;ます&lt;/em&gt;。次のHTML構造を想定します。</target>
        </trans-unit>
        <trans-unit id="99dc48109b6cce011425c20dc166b6aaf5634758" translate="yes" xml:space="preserve">
          <source>This is a bit simplified, and in practice solutions tend to use a mix of different approaches. Still, we will look at them in isolation to better contrast their tradeoffs.</source>
          <target state="translated">これは少し単純化されていて、実際にはソリューションは異なるアプローチの組み合わせを使用する傾向があります。それでも、トレードオフをよりよく対比させるために、これらを分離して見ていきます。</target>
        </trans-unit>
        <trans-unit id="f354ebc1c8de6bed11d9fe920271b4b204cffba6" translate="yes" xml:space="preserve">
          <source>This is a rare use case. If you need it, you can &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;use a mutable ref&lt;/a&gt; to manually store a boolean value corresponding to whether you are on the first or a subsequent render, then check that flag in your effect. (If you find yourself doing this often, you could create a custom Hook for it.)</source>
          <target state="translated">これはまれなユースケースです。必要に応じて、&lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;変更可能な参照&lt;/a&gt;を使用して、最初のレンダリングまたは後続のレンダリングのどちらにいるかに対応するブール値を手動で保存し、そのフラグを効果で確認できます。（これを頻繁に行う場合は、そのためのカスタムフックを作成できます。）</target>
        </trans-unit>
        <trans-unit id="75075312cba14b3581378e03695ec96938d319ac" translate="yes" xml:space="preserve">
          <source>This is a rather convoluted pattern but it shows that you can do this escape hatch optimization if you need it. It&amp;rsquo;s more bearable if you extract it to a custom Hook:</source>
          <target state="translated">これはかなり複雑なパターンですが、必要に応じてこのエスケープハッチ最適化を実行できることを示しています。カスタムフックに抽出すると、より耐えられます。</target>
        </trans-unit>
        <trans-unit id="5227f8717f5136bb9804d5f23e2236aefaabea00" translate="yes" xml:space="preserve">
          <source>This is also &lt;strong&gt;the easiest way to integrate React into an existing website.&lt;/strong&gt; You can always add a larger toolchain if you find it helpful!</source>
          <target state="translated">これは&lt;strong&gt;、Reactを既存のWebサイトに統合する最も簡単な方法で&lt;/strong&gt;も&lt;strong&gt;あります。&lt;/strong&gt;役立つ場合は、いつでもより大きなツールチェーンを追加できます。</target>
        </trans-unit>
        <trans-unit id="23555155fd49eb625fe9b6ee74d6f52738cd077a" translate="yes" xml:space="preserve">
          <source>This is an implementation detail so avoid relying on it directly. In the future versions, React will batch updates by default in more cases.</source>
          <target state="translated">これは実装の詳細なので、直接頼るのは避けましょう。将来のバージョンでは、Reactはより多くのケースでデフォルトでバッチ更新を行うようになります。</target>
        </trans-unit>
        <trans-unit id="3a3631bbcc581acd6fff6b114d111cf6ae38309c" translate="yes" xml:space="preserve">
          <source>This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render &amp;mdash; but React class components don&amp;rsquo;t have a method like this. We could extract a separate method but we would still have to call it in two places.</source>
          <target state="translated">これは、コンポーネントがマウントされたばかりか、コンポーネントが更新されたかに関係なく、多くの場合、同じ副作用を実行したいためです。概念的には、すべてのレンダリングの後にそれを実行したいのですが、Reactクラスコンポーネントにはこのようなメソッドがありません。別のメソッドを抽出することもできますが、それでも2か所で呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="94660750769ee2d6cb7338105b6ef20240dc1dbe" translate="yes" xml:space="preserve">
          <source>This is because when we update a state variable, we &lt;em&gt;replace&lt;/em&gt; its value. This is different from &lt;code&gt;this.setState&lt;/code&gt; in a class, which &lt;em&gt;merges&lt;/em&gt; the updated fields into the object.</source>
          <target state="translated">これは、状態変数を更新すると、その値が&lt;em&gt;置き換えられる&lt;/em&gt;ためです。これは、更新されたフィールドをオブジェクトに&lt;em&gt;マージ&lt;/em&gt;するクラスの &lt;code&gt;this.setState&lt;/code&gt; とは異なります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a47325c97eec71b52ae248148cefc0b2a8e23dc" translate="yes" xml:space="preserve">
          <source>This is both more convenient from the maintenance perspective (no need to keep forwarding callbacks), and avoids the callback problem altogether. Passing &lt;code&gt;dispatch&lt;/code&gt; down like this is the recommended pattern for deep updates.</source>
          <target state="translated">これは、メンテナンスの観点から（コールバックを転送し続ける必要がないため）より便利であり、コールバックの問題を完全に回避します。このように &lt;code&gt;dispatch&lt;/code&gt; 渡すことは、深い更新に推奨されるパターンです。</target>
        </trans-unit>
        <trans-unit id="78dce35fd65045b02f21fbe73c4f3d79910e2283" translate="yes" xml:space="preserve">
          <source>This is commonly called a &amp;ldquo;top-down&amp;rdquo; or &amp;ldquo;unidirectional&amp;rdquo; data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components &amp;ldquo;below&amp;rdquo; them in the tree.</source>
          <target state="translated">これは一般に「トップダウン」または「単方向」データフローと呼ばれます。どの状態も常に特定のコンポーネントによって所有されており、その状態から派生したデータまたはUIは、ツリー内でそれらの下にあるコンポーネントにのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="f263fdbfe4befbdbe35c83008d89219aa3bc1f80" translate="yes" xml:space="preserve">
          <source>This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.</source>
          <target state="translated">これは、ユーザーの入力に基づいてすぐにレンダリングするものや、データの取得を待つ必要があるものがある場合に、インターフェイスの応答性を保つために一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="f35b27d1c72a73a47404576ed9069707f86b93da" translate="yes" xml:space="preserve">
          <source>This is enough to get our component to render, but we also want to be notified about the value changes. To do this, we will subscribe to the jQuery &lt;code&gt;change&lt;/code&gt; event on the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; managed by Chosen.</source>
          <target state="translated">これでコンポーネントをレンダリングするには十分ですが、値の変更についても通知を受けたいと考えています。これを行うには、Chosenが管理する &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; の jQuery &lt;code&gt;change&lt;/code&gt; イベントをサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="76b2cd066ec6800da2e6fca46c1c5bc66a392c5d" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;.bind&lt;/code&gt;:</source>
          <target state="translated">これは &lt;code&gt;.bind&lt;/code&gt; を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="d3c5bf674b9409038c85e451ead5b4000258b898" translate="yes" xml:space="preserve">
          <source>This is especially useful for data fetching. It is usually preferable to use &amp;ldquo;fake&amp;rdquo; data for tests to avoid the slowness and flakiness due to fetching from real API endpoints &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. This helps make the tests predictable. Libraries like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; and &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;, among others, support mocked functions. For end-to-end tests, mocking network can be more difficult, but you might also want to test the real API endpoints in them anyway.</source>
          <target state="translated">これは、データのフェッチに特に役立ちます。実際のAPIエンドポイントからのフェッチに起因する速度低下と不安定さを回避するために、テストには通常「偽の」データを使用することをお勧めします&lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;（例）&lt;/small&gt;&lt;/a&gt;。これは、テストを予測可能にするのに役立ちます。&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;や&lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;などのライブラリは、モック機能をサポートしています。エンドツーエンドのテストでは、ネットワークのモックを作成するのが難しくなる可能性がありますが、実際のAPIエンドポイントをテストすることもできます。</target>
        </trans-unit>
        <trans-unit id="91a0acb35ae332ccbc63c94a04c970a5a6662d52" translate="yes" xml:space="preserve">
          <source>This is not React-specific behavior; it is a part of &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;how functions work in JavaScript&lt;/a&gt;. Generally, if you refer to a method without &lt;code&gt;()&lt;/code&gt; after it, such as &lt;code&gt;onClick={this.handleClick}&lt;/code&gt;, you should bind that method.</source>
          <target state="translated">これはReact固有の動作ではありません。これは、&lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;JavaScriptでの関数の動作方法の&lt;/a&gt;一部です。通常、 &lt;code&gt;onClick={this.handleClick}&lt;/code&gt; のように、 &lt;code&gt;()&lt;/code&gt; の後にないメソッドを参照する場合は、そのメソッドをバインドする必要があります。</target>
        </trans-unit>
        <trans-unit id="acd30756daf69694d4f232dd03c1bf787fd40f16" translate="yes" xml:space="preserve">
          <source>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</source>
          <target state="translated">これは、任意の長さの JSX 式のリストをレンダリングするのによく役立ちます。例えば、これは HTML リストをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="5a99ff5d36d8c6c9227545d3f9b811542fdf7a14" translate="yes" xml:space="preserve">
          <source>This is one example of many cases where depending on only pointer and mouse events will break functionality for keyboard users. Always testing with the keyboard will immediately highlight the problem areas which can then be fixed by using keyboard aware event handlers.</source>
          <target state="translated">これは、ポインタとマウスのイベントだけに依存していると、キーボードユーザーの機能が壊れてしまう多くのケースの一例です。常にキーボードを使ってテストすることで、問題のある部分がすぐに浮き彫りになり、キーボードを意識したイベントハンドラを使うことで修正することができます。</target>
        </trans-unit>
        <trans-unit id="c45d9be4282e8391a17aca9ac958259838791726" translate="yes" xml:space="preserve">
          <source>This is the first chapter in a step-by-step guide about main React concepts. You can find a list of all its chapters in the navigation sidebar. If you&amp;rsquo;re reading this from a mobile device, you can access the navigation by pressing the button in the bottom right corner of your screen.</source>
          <target state="translated">これは、Reactの主要な概念に関するステップバイステップガイドの最初の章です。すべての章のリストは、ナビゲーションサイドバーにあります。これをモバイルデバイスから読んでいる場合は、画面の右下隅にあるボタンを押すと、ナビゲーションにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c25acae8adf4005a2b896567a72c2c799a087f8c" translate="yes" xml:space="preserve">
          <source>This is the only lifecycle method called on server rendering.</source>
          <target state="translated">これは、サーバーレンダリングで呼び出される唯一のライフサイクルメソッドです。</target>
        </trans-unit>
        <trans-unit id="81793ae769b5dc5c19104ac5a737a90042932a4e" translate="yes" xml:space="preserve">
          <source>This is typically implemented by attaching a &lt;code&gt;click&lt;/code&gt; event to the &lt;code&gt;window&lt;/code&gt; object that closes the popover:</source>
          <target state="translated">これは通常、ポップオーバーを閉じる &lt;code&gt;window&lt;/code&gt; オブジェクトに &lt;code&gt;click&lt;/code&gt; イベントをアタッチすることで実装されます。</target>
        </trans-unit>
        <trans-unit id="8a759a421b0f990ff09a818938bdffadcc8719ff" translate="yes" xml:space="preserve">
          <source>This is valid JSX, and &lt;code&gt;props.children&lt;/code&gt; in &lt;code&gt;MyComponent&lt;/code&gt; will simply be the string &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt;. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</source>
          <target state="translated">これは有効なJSXであり、 &lt;code&gt;MyComponent&lt;/code&gt; の &lt;code&gt;props.children&lt;/code&gt; は単に &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt; という文字列になります。。HTMLはエスケープされないため、通常、次のようにHTMLを書くのと同じようにJSXを書くことができます。</target>
        </trans-unit>
        <trans-unit id="c613ddcfbe3b097acdf335938f040949d7b413dc" translate="yes" xml:space="preserve">
          <source>This is why in React classes, we put side effects into &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:</source>
          <target state="translated">これがReactクラスで、副作用を &lt;code&gt;componentDidMount&lt;/code&gt; および &lt;code&gt;componentDidUpdate&lt;/code&gt; に入れる理由です。例に戻って、ReactがDOMに変更を加えた直後にドキュメントのタイトルを更新するReactカウンタークラスコンポーネントを次に示します。</target>
        </trans-unit>
        <trans-unit id="c62ddb716217cd9d943db6e89f3da163d5211696" translate="yes" xml:space="preserve">
          <source>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</source>
          <target state="translated">このため、ステートはしばしばローカルまたはカプセル化されていると呼ばれています。これは、それを所有して設定しているコンポーネント以外のコンポーネントからはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="18a571f38f03339764897ec37c93ff611f9faab0" translate="yes" xml:space="preserve">
          <source>This is why when we click the button, it feels like we&amp;rsquo;ve &amp;ldquo;taken a step back&amp;rdquo;. The &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary which was previously showing useful content (&lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt;) had to &amp;ldquo;recede&amp;rdquo; to showing the fallback (&lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt;). We call that a &lt;strong&gt;Receded&lt;/strong&gt; state.</source>
          <target state="translated">このため、ボタンをクリックすると、「一歩下がった」ように感じます。 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界以前に示した便利なコンテンツ（ &lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt; ）フォールバックを示すに「後退」しなければならなかった（ &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; ）。これを&lt;strong&gt;後退&lt;/strong&gt;状態と呼びます。</target>
        </trans-unit>
        <trans-unit id="718eb18e387e45c3190a58540cc9769ac7b3487c" translate="yes" xml:space="preserve">
          <source>This lets other components pass arbitrary children to them by nesting the JSX:</source>
          <target state="translated">これにより、JSXをネスティングすることで、他のコンポーネントに任意の子を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b8cee0a900fd1abfbf74aa34a43408d67133f7b3" translate="yes" xml:space="preserve">
          <source>This lets us know whether the &lt;em&gt;currently selected&lt;/em&gt; friend is online. If we pick a different friend and update the &lt;code&gt;recipientID&lt;/code&gt; state variable, our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.</source>
          <target state="translated">これにより、&lt;em&gt;現在選択されている&lt;/em&gt;友達がオンラインかどうかを知ることができます。別のフレンドを選択し、 &lt;code&gt;recipientID&lt;/code&gt; 状態変数を更新すると、 &lt;code&gt;useFriendStatus&lt;/code&gt; フックは、以前に選択されたフレンドの登録を解除し、新しく選択されたフレンドのステータスをサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="17465f6f30cbbd158822bfd9a93d4e55ec625a26" translate="yes" xml:space="preserve">
          <source>This lets us simplify &lt;code&gt;Comment&lt;/code&gt; even further:</source>
          <target state="translated">これにより、 &lt;code&gt;Comment&lt;/code&gt; をさらに簡略化できます。</target>
        </trans-unit>
        <trans-unit id="2145d5b7dc2e2f3be97d96fbee1e1d4c248b4f29" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.</source>
          <target state="translated">このライフサイクルは、子孫コンポーネントによってエラーがスローされた後に呼び出されます。投げられたエラーをパラメータとして受け取り、状態を更新するための値を返します。</target>
        </trans-unit>
        <trans-unit id="968ffe95e9be91c36d5595d98ef8add12caa0d69" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:</source>
          <target state="translated">このライフサイクルは、子孫コンポーネントによってエラーが発生した後に呼び出されます。2つのパラメータを受け取ります。</target>
        </trans-unit>
        <trans-unit id="594ba927ec8ab8edb9aadc0d0584d8c6c365a647" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillMount&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">このライフサイクルは、以前は &lt;code&gt;componentWillMount&lt;/code&gt; という名前でした。この名前はバージョン17まで&lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; 。rename -unsafe-lifecyclescodemodを&lt;/a&gt;使用して、コンポーネントを自動的に更新します。</target>
        </trans-unit>
        <trans-unit id="6588d01fe985f33b6111c5dd3aa724cc493cfaf0" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillReceiveProps&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">このライフサイクルは、以前は &lt;code&gt;componentWillReceiveProps&lt;/code&gt; という名前でした。この名前はバージョン17まで&lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; 。rename -unsafe-lifecyclescodemodを&lt;/a&gt;使用して、コンポーネントを自動的に更新します。</target>
        </trans-unit>
        <trans-unit id="94637589013bd1046cc3548741fa19cadd64d909" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillUpdate&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">このライフサイクルは、以前は &lt;code&gt;componentWillUpdate&lt;/code&gt; という名前でした。この名前はバージョン17まで&lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; 。rename -unsafe-lifecyclescodemodを&lt;/a&gt;使用して、コンポーネントを自動的に更新します。</target>
        </trans-unit>
        <trans-unit id="f1c80a55eed22ae85461d3cfcaba922c6522694d" translate="yes" xml:space="preserve">
          <source>This makes sense in the vast majority of situations. Inconsistent UI is confusing and can mislead users. (For example, it would be terrible if a messenger&amp;rsquo;s Send button and the conversation picker pane &amp;ldquo;disagreed&amp;rdquo; about which thread is currently selected.)</source>
          <target state="translated">これは、ほとんどの状況で意味があります。一貫性のないUIは混乱を招き、ユーザーを誤解させる可能性があります。（たとえば、メッセンジャーの[送信]ボタンと会話ピッカーペインが、どのスレッドが現在選択されているかについて「同意しない」場合は、ひどいことになります。）</target>
        </trans-unit>
        <trans-unit id="ef24e13773cbfa21de17ac04cc277350c44f1c93" translate="yes" xml:space="preserve">
          <source>This may work fine for users with pointer devices, such as a mouse, but operating this with the keyboard alone leads to broken functionality when tabbing to the next element as the &lt;code&gt;window&lt;/code&gt; object never receives a &lt;code&gt;click&lt;/code&gt; event. This can lead to obscured functionality which blocks users from using your application.</source>
          <target state="translated">これは、マウスなどのポインターデバイスを使用しているユーザーには問題なく機能しますが、キーボードだけで操作すると、 &lt;code&gt;window&lt;/code&gt; オブジェクトが &lt;code&gt;click&lt;/code&gt; イベントを受け取らないため、次の要素にタブ移動すると機能が破損します。これにより、ユーザーがアプリケーションを使用できなくなる機能が不明瞭になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="85ab2af6f9d4c72cf5bf3ee19ce9e396909f22dc" translate="yes" xml:space="preserve">
          <source>This means that refs intended for our &lt;code&gt;FancyButton&lt;/code&gt; component will actually be attached to the &lt;code&gt;LogProps&lt;/code&gt; component:</source>
          <target state="translated">つまり、 &lt;code&gt;FancyButton&lt;/code&gt; コンポーネント向けの参照は実際には &lt;code&gt;LogProps&lt;/code&gt; コンポーネントにアタッチされます。</target>
        </trans-unit>
        <trans-unit id="20cdec50ca2bbe2c60a25c71a851df8e68f79fdd" translate="yes" xml:space="preserve">
          <source>This means that you can use JSX inside of &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops, assign it to variables, accept it as arguments, and return it from functions:</source>
          <target state="translated">つまり、 &lt;code&gt;if&lt;/code&gt; ステートメント内および &lt;code&gt;for&lt;/code&gt; ループ内でJSXを使用し、JSX を変数に割り当て、それを引数として受け入れ、関数から返すことができます。</target>
        </trans-unit>
        <trans-unit id="3bf58efcf63a028a41c47c43c10732e6a1a269f5" translate="yes" xml:space="preserve">
          <source>This means writing ES6 classes comes with a little more boilerplate code for event handlers, but the upside is slightly better performance in large applications.</source>
          <target state="translated">つまり、ES6 クラスを書くことは、イベント ハンドラのためのより多くの定型的なコードを必要としますが、大規模なアプリケーションではパフォーマンスが若干向上するという利点があります。</target>
        </trans-unit>
        <trans-unit id="c6ccb7790fbe3b5adbb51adc314fe96e90f8b9bd" translate="yes" xml:space="preserve">
          <source>This method doesn&amp;rsquo;t have access to the component instance. If you&amp;rsquo;d like, you can reuse some code between &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; and the other class methods by extracting pure functions of the component props and state outside the class definition.</source>
          <target state="translated">このメソッドはコンポーネントインスタンスにアクセスできません。必要に &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; 、コンポーネントプロップの純粋な関数とクラス定義外の状態の純粋な関数を抽出することにより、getDerivedStateFromProps（）と他のクラスメソッドの間で一部のコードを再利用できます。</target>
        </trans-unit>
        <trans-unit id="deaaaea3817236bf17270b39c61839a1ba533f0b" translate="yes" xml:space="preserve">
          <source>This method exists for &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;rare use cases&lt;/a&gt; where the state depends on changes in props over time. For example, it might be handy for implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component that compares its previous and next children to decide which of them to animate in and out.</source>
          <target state="translated">このメソッドは、状態が時間の経過に伴う小道具の変化に依存する&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;まれなユースケースの&lt;/a&gt;ために存在します。たとえば、前の子と次の子を比較して、アニメーション化するアニメーションを決定する &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; コンポーネントを実装すると便利です。</target>
        </trans-unit>
        <trans-unit id="831ab868298258b184dc29308d4e3381f3bfdc48" translate="yes" xml:space="preserve">
          <source>This method is a good place to set up any subscriptions. If you do that, don&amp;rsquo;t forget to unsubscribe in &lt;code&gt;componentWillUnmount()&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、サブスクリプションをセットアップするのに適した場所です。その場合は、 &lt;code&gt;componentWillUnmount()&lt;/code&gt; でサブスクライブを解除することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="4ab528114f0749b536a7ef2d3ed5cc959586f962" translate="yes" xml:space="preserve">
          <source>This method is called when a component is being removed from the DOM:</source>
          <target state="translated">このメソッドは、コンポーネントが DOM から削除されるときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8d1ff3351a12658bbf9b29cefa88394ca0bb9811" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a render, as this can lead to bugs.</source>
          <target state="translated">このメソッドは、&lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;パフォーマンスの最適化&lt;/a&gt;&lt;/strong&gt;としてのみ存在し&lt;strong&gt;ます。&lt;/strong&gt;これはバグの原因となる可能性があるため、レンダリングの「防止」に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="ebb829156f7c61ef4acced6f34d456127053816e" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a rendering, as this can lead to bugs. &lt;strong&gt;Consider using the built-in &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;PureComponent&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand. &lt;code&gt;PureComponent&lt;/code&gt; performs a shallow comparison of props and state, and reduces the chance that you&amp;rsquo;ll skip a necessary update.</source>
          <target state="translated">このメソッドは、&lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;パフォーマンスの最適化&lt;/a&gt;&lt;/strong&gt;としてのみ存在し&lt;strong&gt;ます。&lt;/strong&gt;これはバグの原因となる可能性があるため、レンダリングの「防止」に依存しないでください。 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; を手動で作成する代わりに&lt;strong&gt;、&lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;PureComponent&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;を使用することを検討してください&lt;/strong&gt;。 &lt;code&gt;PureComponent&lt;/code&gt; は、小道具と状態の浅い比較を実行し、必要な更新をスキップする可能性を減らします。</target>
        </trans-unit>
        <trans-unit id="ee800d90e38eaef10a7bc57aaa91d6a6506aa2cf" translate="yes" xml:space="preserve">
          <source>This might be a bit convoluted but you can extract it into a custom Hook:</source>
          <target state="translated">ちょっと複雑かもしれませんが、カスタムフックに抽出することができます。</target>
        </trans-unit>
        <trans-unit id="e32186cfd473e2a105089ea30d4f98232d190b91" translate="yes" xml:space="preserve">
          <source>This might look strange at first, but an update during rendering is exactly what &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; has always been like conceptually.</source>
          <target state="translated">これは最初は奇妙に見えるかもしれませんが、レンダリング中の更新は、概念的に &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; が常にそうであったものとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="ef2cab890f08c2a76dbdff387f6da7cc1005dff6" translate="yes" xml:space="preserve">
          <source>This might seem like a lot to take in at first. Don&amp;rsquo;t rush it! If you&amp;rsquo;re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to &amp;ldquo;forget&amp;rdquo; how state works in classes, and look at this code with fresh eyes, it will make sense.</source>
          <target state="translated">これは、最初は多くを受け入れるように思えるかもしれません。急がないでください！説明に迷った場合は、上記のコードをもう一度見て、上から下に読んでみてください。クラスでstateがどのように機能するかを「忘れる」ことを試み、このコードを新鮮な目で見ると、それが意味をなすことをお約束します。</target>
        </trans-unit>
        <trans-unit id="d07825aa1cec991e99499e19669c9ccceb78fe54" translate="yes" xml:space="preserve">
          <source>This new function &lt;code&gt;useState&lt;/code&gt; is the first &amp;ldquo;Hook&amp;rdquo; we&amp;rsquo;ll learn about, but this example is just a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make sense yet!</source>
          <target state="translated">この新しい関数 &lt;code&gt;useState&lt;/code&gt; は、これから学習する最初の「フック」ですが、この例は単なるティーザーです。まだ意味がわからなくても心配はいりません。</target>
        </trans-unit>
        <trans-unit id="e3a722c80ed9c76ca1113dc4457219ac30784908" translate="yes" xml:space="preserve">
          <source>This only applies to development mode. &lt;em&gt;Lifecycles will not be double-invoked in production mode.&lt;/em&gt;</source>
          <target state="translated">これは開発モードにのみ適用されます。&lt;em&gt;ライフサイクルは、プロダクションモードでは二重に呼び出されません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4350c5287a7a2684318bbc298f11388e35c98227" translate="yes" xml:space="preserve">
          <source>This package provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.</source>
          <target state="translated">本パッケージは、DOMやネイティブのモバイル環境に依存することなく、Reactコンポーネントを純粋なJavaScriptオブジェクトにレンダリングするために使用できるReactレンダラーを提供します。</target>
        </trans-unit>
        <trans-unit id="8402b5bdda223e1895c6750dabf232de29a825ec" translate="yes" xml:space="preserve">
          <source>This page answers some of the frequently asked questions about &lt;a href=&quot;hooks-overview&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">このページでは、&lt;a href=&quot;hooks-overview&quot;&gt;フック&lt;/a&gt;についてよく寄せられる質問のいくつかに回答します。</target>
        </trans-unit>
        <trans-unit id="34334d5085c7858cfe5a0f8a0877627d68a2b7b4" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;re using &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; as a test runner. If you use a different test runner, you may need to adjust the API, but the overall shape of the solution will likely be the same. Read more details on setting up a testing environment on the &lt;a href=&quot;testing-environments&quot;&gt;Testing Environments&lt;/a&gt; page.</source>
          <target state="translated">このページは、&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;をテストランナーとして使用していることを前提としています。別のテストランナーを使用する場合は、APIを調整する必要がありますが、ソリューションの全体的な形状は同じになる可能性があります。テスト環境のセットアップの詳細については、「&lt;a href=&quot;testing-environments&quot;&gt;テスト環境&lt;/a&gt;」ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="3a166d200254a5d8e02bad9a5106cd778d917587" translate="yes" xml:space="preserve">
          <source>This page contains a detailed API reference for the React component class definition. It assumes you&amp;rsquo;re familiar with fundamental React concepts, such as &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt;, as well as &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt;. If you&amp;rsquo;re not, read them first.</source>
          <target state="translated">このページには、Reactコンポーネントクラス定義の詳細なAPIリファレンスが含まれています。それはあなたが基本としているお馴染みのような概念、リアクトを前提としてい&lt;a href=&quot;components-and-props&quot;&gt;コンポーネントや小道具&lt;/a&gt;のほか、&lt;a href=&quot;state-and-lifecycle&quot;&gt;州およびライフサイクルを&lt;/a&gt;。そうでない場合は、最初に読んでください。</target>
        </trans-unit>
        <trans-unit id="5b013d41bce54d9463c50238174c350420a86fd1" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;not yet available&lt;/a&gt; in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">このページ&lt;strong&gt;では、安定版リリースで&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;はまだ利用できない&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;実験的機能&lt;/strong&gt;について説明し&lt;strong&gt;ます&lt;/strong&gt;。プロダクションアプリでは、Reactの実験的ビルドに依存しないでください。これらの機能は、Reactの一部になる前に、警告なしに大幅に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="122960595a4931302583328a511b76c9b89150ab" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are not yet available in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">このページ&lt;strong&gt;では、安定版リリースではまだ利用できない実験的機能&lt;/strong&gt;について説明し&lt;strong&gt;ます&lt;/strong&gt;。プロダクションアプリでは、Reactの実験的ビルドに依存しないでください。これらの機能は、Reactの一部になる前に、警告なしに大幅に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4047aad22e87564322a6b203dc72bdb4dac3a75c" translate="yes" xml:space="preserve">
          <source>This page describes a few popular React toolchains which help with tasks like:</source>
          <target state="translated">このページでは、以下のようなタスクを支援する人気のあるReactツールチェーンについて説明します。</target>
        </trans-unit>
        <trans-unit id="e37bdca683407609c8ea8e0d16eadc7cfa276546" translate="yes" xml:space="preserve">
          <source>This page describes the APIs for the built-in Hooks in React.</source>
          <target state="translated">このページでは、Reactに内蔵されているHooksのAPIについて説明します。</target>
        </trans-unit>
        <trans-unit id="1e718f59fd28ee7f281f2c32ed198268003156f5" translate="yes" xml:space="preserve">
          <source>This page introduces the concept of state and lifecycle in a React component. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="translated">このページでは、Reactコンポーネントの状態とライフサイクルの概念を紹介します。あなたは見つけることができ&lt;a href=&quot;react-component&quot;&gt;、ここで詳細なコンポーネントAPIリファレンスを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a3489831af2b614861bf122f1b342924d1410d7" translate="yes" xml:space="preserve">
          <source>This page is an API reference for the React &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode&lt;/a&gt;. If you&amp;rsquo;re looking for a guided introduction instead, check out &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">このページは、React &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Modeの&lt;/a&gt; APIリファレンスです。代わりにガイド付きの紹介を探している場合は、&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;並行UIパターンを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="c533e178a623d6b733cedd5bdbf8ab43278f207d" translate="yes" xml:space="preserve">
          <source>This page is an overview of the React documentation and related resources.</source>
          <target state="translated">このページでは、Reactのドキュメントと関連するリソースの概要を紹介しています。</target>
        </trans-unit>
        <trans-unit id="8155926f2a677459aa518b97627e56b8d5d2b3b9" translate="yes" xml:space="preserve">
          <source>This page provides a theoretical overview of Concurrent Mode. &lt;strong&gt;For a more practical introduction, you might want to check out the next sections:&lt;/strong&gt;</source>
          <target state="translated">このページでは、コンカレントモードの理論的な概要を説明します。&lt;strong&gt;より実用的な概要については、次のセクションを確認してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a471db84150e912bcf081d5315a354a60b2801c7" translate="yes" xml:space="preserve">
          <source>This pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; if the child needs to communicate with the parent before rendering.</source>
          <target state="translated">このパターンは、直接の親から子を切り離す必要がある多くの場合に十分です。レンダリングの前に子が親と通信する必要がある場合は、&lt;a href=&quot;render-props&quot;&gt;レンダープロップ&lt;/a&gt;を使用してさらに進めることができます。</target>
        </trans-unit>
        <trans-unit id="d9fd07e4c840f003b08c9bdf6f21a1ec4e1acc30" translate="yes" xml:space="preserve">
          <source>This performs a shallow merge of &lt;code&gt;stateChange&lt;/code&gt; into the new state, e.g., to adjust a shopping cart item quantity:</source>
          <target state="translated">これにより、 &lt;code&gt;stateChange&lt;/code&gt; の浅いマージが新しい状態にマージされ、たとえば、ショッピングカートアイテムの数量が調整されます。</target>
        </trans-unit>
        <trans-unit id="846fc8c98cf14dc25d66ba13bf4262e8d78da49b" translate="yes" xml:space="preserve">
          <source>This plugin is included by default in &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">このプラグインは、&lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;Create React Appに&lt;/a&gt;デフォルトで含まれています。</target>
        </trans-unit>
        <trans-unit id="82c77f485b089c71f74af9f0894a753a93bcba93" translate="yes" xml:space="preserve">
          <source>This policy is designed to be pragmatic: certainly, we don&amp;rsquo;t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can&amp;rsquo;t make progress in improving React as fast as we&amp;rsquo;d like.</source>
          <target state="translated">このポリシーは実用的であるように設計されています。もちろん、私たちはあなたの頭痛の種を引き起こしたくありません。これらすべての変更のためにメジャーバージョンをぶつけた場合、最終的には、より多くのメジャーバージョンをリリースし、最終的にはコミュニティのバージョン管理上の苦痛を引き起こすことになります。また、Reactの改善を思いどおりに進めることができないことも意味します。</target>
        </trans-unit>
        <trans-unit id="1ea9e452d1eff58bbc103278e7e1bc082218f9a3" translate="yes" xml:space="preserve">
          <source>This poses a question of how do we know &lt;em&gt;what&lt;/em&gt; to fetch before rendering the next screen. There are several ways to solve this (for example, by integrating data fetching closer with your routing solution). If you work on a data fetching library, &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; presents a deep dive on how to accomplish this and why it&amp;rsquo;s important.</source>
          <target state="translated">これは、次の画面をレンダリングする前に&lt;em&gt;何&lt;/em&gt;をフェッチする&lt;em&gt;か&lt;/em&gt;をどのようにして知る&lt;em&gt;か&lt;/em&gt;という問題を提起します。これを解決するにはいくつかの方法があります（たとえば、データフェッチをルーティングソリューションとより密接に統合するなど）。データ取得ライブラリで作業する場合&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;、同時モードとサスペンスで優れたユーザーエクスペリエンスを構築&lt;/a&gt;することで、これを実現する方法と、それがなぜ重要であるかについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="f84a144236df428813d59f9cce1db593da13efb1" translate="yes" xml:space="preserve">
          <source>This presents a problem. If the response for fun facts arrives first, we&amp;rsquo;ll see the fun facts below the &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; fallback for posts. We might start reading them, but then the &lt;em&gt;posts&lt;/em&gt; response will come back, and shift all the facts down. This is jarring.</source>
          <target state="translated">これには問題があります。楽しい事実の応答が最初に届いた場合、 &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; 投稿のフォールバックの下に楽しい事実が表示されます。私たちはそれらを読み始めるかもしれませんが、&lt;em&gt;投稿の&lt;/em&gt;応答が戻ってきて、すべての事実を下にシフトします。これは耳障りです。</target>
        </trans-unit>
        <trans-unit id="8635080f7265c9f1c5179ee0c18eafa6af31514f" translate="yes" xml:space="preserve">
          <source>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it&amp;rsquo;s unintuitive and difficult to debug.</source>
          <target state="translated">この問題を修正することは可能ですが（効果のクリーンアップ機能を使用して、古い要求を無視またはキャンセルすることができます）、直感的でなくデバッグが困難です。</target>
        </trans-unit>
        <trans-unit id="8d1f82deaae287572c7914a6acb4b6162faaf183" translate="yes" xml:space="preserve">
          <source>This reference guide documents the &lt;code&gt;SyntheticEvent&lt;/code&gt; wrapper that forms part of React&amp;rsquo;s Event System. See the &lt;a href=&quot;handling-events&quot;&gt;Handling Events&lt;/a&gt; guide to learn more.</source>
          <target state="translated">このリファレンスガイドでは、Reactのイベントシステムの一部を構成する &lt;code&gt;SyntheticEvent&lt;/code&gt; ラッパーについて説明します。詳細については、&lt;a href=&quot;handling-events&quot;&gt;イベント&lt;/a&gt;の処理ガイドをご覧ください。</target>
        </trans-unit>
        <trans-unit id="7d398accdf2e13d5c40a6a46660190acf5d11f2a" translate="yes" xml:space="preserve">
          <source>This release is primarily aimed at early adopters, library authors, and curious people.</source>
          <target state="translated">このリリースは、主にアーリーアダプター、図書館の著者、好奇心旺盛な人々を対象としています。</target>
        </trans-unit>
        <trans-unit id="219eb5ca004ef24ebdbe9552a6315cfaaddd9726" translate="yes" xml:space="preserve">
          <source>This requirement is common enough that it is built into the &lt;code&gt;useEffect&lt;/code&gt; Hook API. You can tell React to &lt;em&gt;skip&lt;/em&gt; applying an effect if certain values haven&amp;rsquo;t changed between re-renders. To do so, pass an array as an optional second argument to &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">この要件は十分に一般的で、 &lt;code&gt;useEffect&lt;/code&gt; フックAPIに組み込まれています。再レンダリング間で特定の値が変更されていない場合は、エフェクトの適用を&lt;em&gt;スキップ&lt;/em&gt;するようにReactに指示できます。そのためには、配列をオプションの2番目の引数として &lt;code&gt;useEffect&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="72e02f13475aaf546ed6868e8e94f97eaca88513" translate="yes" xml:space="preserve">
          <source>This reveals an important insight. React always prefers to go to the Skeleton state as soon as possible. Even if we use transitions with long timeouts everywhere, React will not stay in the Pending state for longer than necessary to avoid the Receded state.</source>
          <target state="translated">これは重要な洞察を明らかにします。React は常に、できるだけ早くスケルトン状態に移行することを好みます。あらゆる場所で長いタイムアウトのあるトランジションを使用していても、ReactはReceded状態を避けるために必要以上に長くPending状態にとどまることはありません。</target>
        </trans-unit>
        <trans-unit id="4974405692544c270ead0116083e7b2246305e51" translate="yes" xml:space="preserve">
          <source>This scenario (Receded &amp;rarr; Skeleton &amp;rarr; Complete) is the default one. However, the Receded state is not very pleasant because it &amp;ldquo;hides&amp;rdquo; existing information. This is why React lets us opt into a different sequence (&lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete) with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">このシナリオ（Receded&amp;rarr;Skeleton&amp;rarr;Complete）がデフォルトです。ただし、Receded状態は既存の情報を「隠す」ため、あまり快適ではありません。これが、Reactが &lt;code&gt;useTransition&lt;/code&gt; を使用して別のシーケンス（&lt;strong&gt;保留&lt;/strong&gt; &amp;rarr;スケルトン&amp;rarr;完了）を選択できるようにする理由です。</target>
        </trans-unit>
        <trans-unit id="8932805285fb5fb9fa75db833708a1c02394b849" translate="yes" xml:space="preserve">
          <source>This section documents a legacy API. See the &lt;a href=&quot;context&quot;&gt;new API&lt;/a&gt;.</source>
          <target state="translated">このセクションでは、レガシーAPIについて説明します。&lt;a href=&quot;context&quot;&gt;新しいAPIを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="deb7679ee67f771ffc1fa43a1b5ac4df3c5b01eb" translate="yes" xml:space="preserve">
          <source>This section exists only for the reference.</source>
          <target state="translated">このセクションは参考のためだけに存在します。</target>
        </trans-unit>
        <trans-unit id="ed85cf7679f0f0f6b3d4ece5fc84efdd9e4a1ae9" translate="yes" xml:space="preserve">
          <source>This section is divided in two pages:</source>
          <target state="translated">ここでは2ページに分けてご紹介します。</target>
        </trans-unit>
        <trans-unit id="11ef194a779a4e464739e9fe4bc7b3d85cd3c158" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you configure webpack directly.</source>
          <target state="translated">このセクションはwebpackを直接設定する場合にのみ関連します。</target>
        </trans-unit>
        <trans-unit id="431d6b70a9186c1768894b47222b952f79b7c64c" translate="yes" xml:space="preserve">
          <source>This signals to the user that some work is happening. However, if the transition is relatively short (less than 500ms), it might be too distracting and make the transition itself feel &lt;em&gt;slower&lt;/em&gt;.</source>
          <target state="translated">これは、何らかの作業が行われていることをユーザーに知らせます。ただし、遷移が比較的短い（500ミリ秒未満）場合は、気が散りすぎて遷移自体が&lt;em&gt;遅く&lt;/em&gt;感じられる可能性があり&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="42c7316ea14507d8a3106cad0c901fad61aced90" translate="yes" xml:space="preserve">
          <source>This snippet is based on the &lt;a href=&quot;hooks-state&quot;&gt;counter example from the previous page&lt;/a&gt;, but we added a new feature to it: we set the document title to a custom message including the number of clicks.</source>
          <target state="translated">このスニペットは&lt;a href=&quot;hooks-state&quot;&gt;、前のページのカウンターの例に&lt;/a&gt;基づいていますが、新しい機能を追加しました。ドキュメントのタイトルを、クリック数を含むカスタムメッセージに設定しました。</target>
        </trans-unit>
        <trans-unit id="1a2b973923810065ae120310178374258ed4b621" translate="yes" xml:space="preserve">
          <source>This strategy is mostly useful while React-powered parts of the page are isolated from each other. Inside React code, it&amp;rsquo;s easier to use &lt;a href=&quot;components-and-props#composing-components&quot;&gt;component composition&lt;/a&gt; instead.</source>
          <target state="translated">この戦略は、Reactを利用したページの部分が互いに分離されている間は、ほとんど役に立ちます。Reactコード内では、代わりに&lt;a href=&quot;components-and-props#composing-components&quot;&gt;コンポーネント構成&lt;/a&gt;を使用する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="af97e3139dc5dabdecc79fb897156e2581c55f4a" translate="yes" xml:space="preserve">
          <source>This syntax is enabled by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">この構文は、&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="b6a74e9393c537e68f37f167c1398d5d5cb7b7e5" translate="yes" xml:space="preserve">
          <source>This technique can also be particularly useful with &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (also known as HOCs). Let&amp;rsquo;s start with an example HOC that logs component props to the console:</source>
          <target state="translated">この手法は、&lt;a href=&quot;higher-order-components&quot;&gt;高次コンポーネント&lt;/a&gt;（HOCとも呼ばれる）でも特に役立ちます。コンポーネントの小道具をコンソールに記録するHOCの例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="f2aa2891249ff7426f74024d6c648d613960876e" translate="yes" xml:space="preserve">
          <source>This technique is not limited to Backbone. You can use React with any model library by subscribing to its changes in the lifecycle methods and, optionally, copying the data into the local React state.</source>
          <target state="translated">このテクニックはBackboneに限定されません。ライフサイクルメソッドでその変更をサブスクライブし、オプションでローカルのReact状態にデータをコピーすることで、任意のモデルライブラリでReactを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5452f415731db14c0cf1bafa5cfea7a02476b736" translate="yes" xml:space="preserve">
          <source>This technique makes the behavior that we need to share extremely portable. To get that behavior, render a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a &lt;code&gt;render&lt;/code&gt; prop that tells it what to render with the current (x, y) of the cursor.</source>
          <target state="translated">この手法により、共有する必要がある動作が非常にポータブルになります。その動作を取得するには、レンダリング &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; で &lt;code&gt;render&lt;/code&gt; カーソルの現在の（X、Y）をレンダリングするためにどのようにそれを伝える小道具。</target>
        </trans-unit>
        <trans-unit id="cd27a6856541e6f1acbb51200bd11813ffca7cb1" translate="yes" xml:space="preserve">
          <source>This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.</source>
          <target state="translated">このユースケースは一般的ではありませんが、チャットスレッドのようにスクロール位置を特殊な方法で処理する必要があるUIでは発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="03fa86c4209790d37407690c0571a1707fae797b" translate="yes" xml:space="preserve">
          <source>This versioning policy does not apply to prerelease builds in the Next or Experimental channels. &lt;a href=&quot;release-channels&quot;&gt;Learn more about prereleases.&lt;/a&gt;</source>
          <target state="translated">このバージョン管理ポリシーは、NextチャネルまたはExperimentalチャネルのプレリリースビルドには適用されません。&lt;a href=&quot;release-channels&quot;&gt;プレリリースの詳細をご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538b744fcb20bb669203461ab8ea0f4f166bb679" translate="yes" xml:space="preserve">
          <source>This wasn&amp;rsquo;t very difficult to implement. However, if you start thinking about how this could possibly work, it might become a little mindbending. If we set the state, how come we don&amp;rsquo;t see the result right away? &lt;em&gt;Where&lt;/em&gt; is the next &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; rendering?</source>
          <target state="translated">これを実装することはそれほど難しくありませんでした。ただし、これがどのように機能するかについて考え始めると、少し心が折れるかもしれません。状態を設定すると、なぜ結果がすぐに表示されないのですか？次の &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; レンダリングは&lt;em&gt;どこに&lt;/em&gt;ありますか？</target>
        </trans-unit>
        <trans-unit id="eeb258d5f9ce72d55863431781bc340ff334eba5" translate="yes" xml:space="preserve">
          <source>This way, Chosen will know to update its DOM element when the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; children managed by React change.</source>
          <target state="translated">これにより、Chosenは、Reactによって管理される &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; の子が変更されたときに、DOM要素を更新することを認識します。</target>
        </trans-unit>
        <trans-unit id="4ec28439ceebf9c4cb58d176fb968b8783b61655" translate="yes" xml:space="preserve">
          <source>This way, components using &lt;code&gt;FancyButton&lt;/code&gt; can get a ref to the underlying &lt;code&gt;button&lt;/code&gt; DOM node and access it if necessary&amp;mdash;just like if they used a DOM &lt;code&gt;button&lt;/code&gt; directly.</source>
          <target state="translated">このように、 &lt;code&gt;FancyButton&lt;/code&gt; を使用するコンポーネントは、基になる &lt;code&gt;button&lt;/code&gt; DOMノードへの参照を取得し、必要に応じて、DOM &lt;code&gt;button&lt;/code&gt; 直接使用する場合と同様にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="f587d14d7da8b297c6acc91bd9525b1f055544f8" translate="yes" xml:space="preserve">
          <source>This way, only the higher-order component needs to know about Backbone model internals, and most components in the app can stay agnostic of Backbone.</source>
          <target state="translated">この方法では、高次のコンポーネントだけがBackboneモデルの内部について知る必要があり、アプリ内のほとんどのコンポーネントはBackboneの不可知性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="a68f6ee634325f5570e4ef9513f5baf023e798ec" translate="yes" xml:space="preserve">
          <source>This will automatically load the bundle containing the &lt;code&gt;OtherComponent&lt;/code&gt; when this component is first rendered.</source>
          <target state="translated">これ &lt;code&gt;OtherComponent&lt;/code&gt; 、このコンポーネントが最初にレンダリングされるときに、OtherComponentを含むバンドルが自動的に読み込まれます。</target>
        </trans-unit>
        <trans-unit id="4daa2bc6eb40a0cae06d556ea78d107730c1a949" translate="yes" xml:space="preserve">
          <source>This will create a production build of your app in the &lt;code&gt;build/&lt;/code&gt; folder of your project.</source>
          <target state="translated">これにより、プロジェクトの &lt;code&gt;build/&lt;/code&gt; フォルダーにアプリの本番ビルドが作成されます。</target>
        </trans-unit>
        <trans-unit id="21d07f344e93b8d1d52a83aa0e0b2781c4b8f11b" translate="yes" xml:space="preserve">
          <source>This will destroy the old &lt;code&gt;Counter&lt;/code&gt; and remount a new one.</source>
          <target state="translated">これは古い &lt;code&gt;Counter&lt;/code&gt; を破壊し、新しいカウンターを再マウントします。</target>
        </trans-unit>
        <trans-unit id="f0e763956fc3a258729b7ba8f4a255aa7e25a67d" translate="yes" xml:space="preserve">
          <source>This will let you use the Flow syntax in your code.</source>
          <target state="translated">これにより、コード内でFlow構文を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="0d22477424f4173933134c5395efeb476e21ff5a" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;useRef()&lt;/code&gt; creates a plain JavaScript object. The only difference between &lt;code&gt;useRef()&lt;/code&gt; and creating a &lt;code&gt;{current: ...}&lt;/code&gt; object yourself is that &lt;code&gt;useRef&lt;/code&gt; will give you the same ref object on every render.</source>
          <target state="translated">これは、 &lt;code&gt;useRef()&lt;/code&gt; がプレーンJavaScriptオブジェクトを作成するため機能します。 &lt;code&gt;useRef()&lt;/code&gt; と &lt;code&gt;{current: ...}&lt;/code&gt; オブジェクトを自分で作成することの唯一の違いは、 &lt;code&gt;useRef&lt;/code&gt; がすべてのレンダリングで同じrefオブジェクトを提供することです。</target>
        </trans-unit>
        <trans-unit id="b90fb512dd2dc602c018f93fa57436e6ed3df13a" translate="yes" xml:space="preserve">
          <source>This would break the consistency between &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt;, causing issues that are very hard to debug.</source>
          <target state="translated">これにより、 &lt;code&gt;props&lt;/code&gt; と &lt;code&gt;state&lt;/code&gt; の間の一貫性が失われ、デバッグが非常に困難な問題が発生します。</target>
        </trans-unit>
        <trans-unit id="95c22763d2077a1ee86e0ec4084c276829b632d6" translate="yes" xml:space="preserve">
          <source>This would make some of the new features we&amp;rsquo;re working on impossible to implement.</source>
          <target state="translated">これにより、現在取り組んでいる新機能の一部を実装できなくなります。</target>
        </trans-unit>
        <trans-unit id="c63210a01f156ac5b080f30f90aa5a8002dd873b" translate="yes" xml:space="preserve">
          <source>Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.</source>
          <target state="translated">Reactでシングルページのアプリケーションを構築することはできますが、それは必須ではありません。Reactは、既存のWebサイトの小さな部分にインタラクティブ性を追加して強化するためにも使用できます。Reactで書かれたコードは、PHPのようなものでサーバー上にレンダリングされたマークアップや、他のクライアントサイドのライブラリと共存することができます。実際、これはまさにFacebookでReactが使われている方法です。</target>
        </trans-unit>
        <trans-unit id="8ecbfeb2bc4103c08c0932a78431577e530cc4f3" translate="yes" xml:space="preserve">
          <source>Throttle</source>
          <target state="translated">Throttle</target>
        </trans-unit>
        <trans-unit id="105be49bda488aaca7ed254ac9ecc09a5112187b" translate="yes" xml:space="preserve">
          <source>Throttling prevents a function from being called more than once in a given window of time. The example below throttles a &amp;ldquo;click&amp;rdquo; handler to prevent calling it more than once per second.</source>
          <target state="translated">スロットルは、特定の時間枠内で関数が複数回呼び出されるのを防ぎます。以下の例では、「クリック」ハンドラーをスロットルして、1秒に複数回呼び出されるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="3dac8fa9afddf95742a5b60661cff381617249d8" translate="yes" xml:space="preserve">
          <source>Timing of effects</source>
          <target state="translated">効果のタイミング</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="02a6b3cc0676cb3a0bc75f54672fa33daf4c1c54" translate="yes" xml:space="preserve">
          <source>Tip: Minify JavaScript for Production</source>
          <target state="translated">ヒント:プロダクション用のJavaScriptを最小化する</target>
        </trans-unit>
        <trans-unit id="47616b21251215181f15d43775daece337895ac6" translate="yes" xml:space="preserve">
          <source>Tip: Optimizing Performance by Skipping Effects</source>
          <target state="translated">ヒント。エフェクトをスキップしてパフォーマンスを最適化</target>
        </trans-unit>
        <trans-unit id="7fa62c774597708b7f9dc61b6315405aedb3c2e8" translate="yes" xml:space="preserve">
          <source>Tip: Pass Information Between Hooks</source>
          <target state="translated">ヒント。フック間での情報の受け渡し</target>
        </trans-unit>
        <trans-unit id="6646f32e08b3abdc68e954b73a34054ed4a2fe87" translate="yes" xml:space="preserve">
          <source>Tip: Reuse a Component</source>
          <target state="translated">ヒント:コンポーネントの再利用</target>
        </trans-unit>
        <trans-unit id="3cb18070e3d87dfd34832eb7efde20c790409673" translate="yes" xml:space="preserve">
          <source>Tip: Use Multiple Effects to Separate Concerns</source>
          <target state="translated">ヒント:複数の効果を使って気になる部分を分ける</target>
        </trans-unit>
        <trans-unit id="057cb52d94797cd2b615c07e7a0fe7d5d1551b78" translate="yes" xml:space="preserve">
          <source>Tip: Using Multiple State Variables</source>
          <target state="translated">ヒント:複数の状態変数の使用</target>
        </trans-unit>
        <trans-unit id="cac26bb6c0e4c5715088485c08a32cef54843337" translate="yes" xml:space="preserve">
          <source>Tip: What Do Square Brackets Mean?</source>
          <target state="translated">ヒント:角括弧の意味は?</target>
        </trans-unit>
        <trans-unit id="0fcbdd8749f567ca5ba943cad166f28f7c8d3609" translate="yes" xml:space="preserve">
          <source>Tips for Using Effects</source>
          <target state="translated">エフェクトの使い方のコツ</target>
        </trans-unit>
        <trans-unit id="8c18a9fca169c11391ce64e4496ce6b8c1d20039" translate="yes" xml:space="preserve">
          <source>To answer these questions, we will refer to the next section on &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">これらの質問に答えるために、&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;同時UIパターンの&lt;/a&gt;次のセクションを参照します。</target>
        </trans-unit>
        <trans-unit id="cec2f6f831ea050e128a8fa50a07760d119b6ac9" translate="yes" xml:space="preserve">
          <source>To avoid re-creating the ignored initial state, we can pass a &lt;strong&gt;function&lt;/strong&gt; to &lt;code&gt;useState&lt;/code&gt;:</source>
          <target state="translated">無視された初期状態の再作成を回避するために、 &lt;code&gt;useState&lt;/code&gt; に&lt;strong&gt;関数&lt;/strong&gt;を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="67a0eb6712ca908d62558fdb45a11cb5f440325c" translate="yes" xml:space="preserve">
          <source>To avoid winding up with a large bundle, it&amp;rsquo;s good to get ahead of the problem and start &amp;ldquo;splitting&amp;rdquo; your bundle. Code-Splitting is a feature supported by bundlers like &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; and Browserify (via &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt;) which can create multiple bundles that can be dynamically loaded at runtime.</source>
          <target state="translated">大きなバンドルで終了しないようにするには、問題を先取りしてバンドルを「分割」することをお勧めします。コード分​​割は、実行時に動的にロードできる複数のバンドルを作成できる（&lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt;を介して）&lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt;、&lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt;、Browserifyなどのバンドラーによってサポートされる機能です。</target>
        </trans-unit>
        <trans-unit id="3828d4a44288ab3a5602117afc478907c184247c" translate="yes" xml:space="preserve">
          <source>To be able to show errors and hints from other packages, the compiler relies on declaration files. A declaration file provides all the type information about a library. This enables us to use javascript libraries like those on npm in our project.</source>
          <target state="translated">他のパッケージからのエラーやヒントを表示できるようにするために、コンパイラは宣言ファイルに依存しています。宣言ファイルはライブラリのすべての型情報を提供します。これにより、npm上のようなjavascriptのライブラリをプロジェクトで使用することができます。</target>
        </trans-unit>
        <trans-unit id="ee8e92cc09f5d0c415337688bf30629119745650" translate="yes" xml:space="preserve">
          <source>To build a static version of your app that renders your data model, you&amp;rsquo;ll want to build components that reuse other components and pass data using &lt;em&gt;props&lt;/em&gt;. &lt;em&gt;props&lt;/em&gt; are a way of passing data from parent to child. If you&amp;rsquo;re familiar with the concept of &lt;em&gt;state&lt;/em&gt;, &lt;strong&gt;don&amp;rsquo;t use state at all&lt;/strong&gt; to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don&amp;rsquo;t need it.</source>
          <target state="translated">データモデルをレンダリングするアプリの静的バージョンを構築するには、他のコンポーネントを再利用し、&lt;em&gt;props&lt;/em&gt;を使用してデータを渡すコンポーネントを構築する必要があります。&lt;em&gt;小道具&lt;/em&gt;は、親から子にデータを渡す方法です。&lt;em&gt;状態&lt;/em&gt;の概念に精通している場合は、この静的バージョンの構築に&lt;strong&gt;状態をまったく使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;。状態は、対話性、つまり時間とともに変化するデータのためにのみ予約されています。これはアプリの静的バージョンであるため、必要ありません。</target>
        </trans-unit>
        <trans-unit id="44e1640b1de0ce4a7e355efb726594659452c610" translate="yes" xml:space="preserve">
          <source>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY: &lt;em&gt;Don&amp;rsquo;t Repeat Yourself&lt;/em&gt;&lt;/a&gt;. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you&amp;rsquo;re building a TODO list, keep an array of the TODO items around; don&amp;rsquo;t keep a separate state variable for the count. Instead, when you want to render the TODO count, take the length of the TODO items array.</source>
          <target state="translated">アプリを正しく構築するには、まず、アプリに必要な変更可能な状態の最小限のセットを考える必要があります。ここで重要なのは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY：&lt;em&gt;自分を繰り返さないこと&lt;/em&gt;&lt;/a&gt;です。アプリケーションが必要とする状態の最小限の表現を理解し、必要に応じてその他すべてをオンデマンドで計算します。たとえば、TODOリストを作成する場合、TODO項目の配列を保持します。カウント用に個別の状態変数を保持しないでください。代わりに、TODOカウントをレンダリングする場合は、TODO項目配列の長さを使用します。</target>
        </trans-unit>
        <trans-unit id="c67fad59392ccaf9eabdb04c2a983cfc8ae6159e" translate="yes" xml:space="preserve">
          <source>To compare these approaches, we&amp;rsquo;ll implement a profile page with each of them.</source>
          <target state="translated">これらのアプローチを比較するために、それぞれのプロファイルページを実装します。</target>
        </trans-unit>
        <trans-unit id="96c475cd68a1fc17197255130dcc89b3e9015930" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;new project&lt;/strong&gt; with TypeScript support, run:</source>
          <target state="translated">TypeScriptをサポートする&lt;strong&gt;新しいプロジェクト&lt;/strong&gt;を作成するには、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="58471b12b491c92d9fe1ca36cea662b1ac465f46" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these plugins &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">本番ビルドを作成するには、必ずこれらのプラグインを追加してください&lt;strong&gt;（順序が重要です）&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2b971cbe6f62da89ac8ee7a0afbbd588d46b42f7" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these transforms &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">プロダクションビルドを作成するには、必ずこれらの変換を追加してください&lt;strong&gt;（順序が重要です）&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="09c773716596ab713897dcc4bd3d4c47765e2c72" translate="yes" xml:space="preserve">
          <source>To demonstrate how to use it, we will connect a &lt;code&gt;NameInput&lt;/code&gt; React component to a Backbone model, and update its &lt;code&gt;firstName&lt;/code&gt; attribute every time the input changes:</source>
          <target state="translated">これを使用する方法を示すために、 &lt;code&gt;NameInput&lt;/code&gt; Reactコンポーネントをバックボーンモデルに接続し、入力が変更されるたびにその &lt;code&gt;firstName&lt;/code&gt; 属性を更新します。</target>
        </trans-unit>
        <trans-unit id="0ab6586b71fbb2871880374f66e0a1257dbeeb31" translate="yes" xml:space="preserve">
          <source>To demonstrate the issue, we will add a top-level &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component that renders our &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; with a button that lets us &lt;strong&gt;switch between different profiles&lt;/strong&gt;:</source>
          <target state="translated">この問題を示すために、 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; をレンダリングするトップレベルの &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; コンポーネントを追加して、&lt;strong&gt;さまざまなプロファイルを切り替える&lt;/strong&gt;ことができるボタンを追加し&lt;strong&gt;ます&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9560e6c157be1cfbb8dadbde0a7036fe5b15715f" translate="yes" xml:space="preserve">
          <source>To demonstrate this feature, we&amp;rsquo;ll use &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;the profile switcher example&lt;/a&gt;. Click the &amp;ldquo;Next&amp;rdquo; button and notice how it takes 1 second to do a transition.</source>
          <target state="translated">この機能を説明するために&lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;、プロファイルスイッチャーの例を&lt;/a&gt;使用します。「次へ」ボタンをクリックして、トランジションを実行するのに1秒かかることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1c67e18ada396a70dc3856809cab6d64b8650311" translate="yes" xml:space="preserve">
          <source>To demonstrate this, let&amp;rsquo;s sketch out a wrapper for a generic jQuery plugin.</source>
          <target state="translated">これを実証するために、汎用jQueryプラグインのラッパーをスケッチしてみましょう。</target>
        </trans-unit>
        <trans-unit id="e825e335e101a3280e4a617d4f080f38681e18c0" translate="yes" xml:space="preserve">
          <source>To do this in Chrome:</source>
          <target state="translated">これをChromeで行うには</target>
        </trans-unit>
        <trans-unit id="61a324463a8291f2d8b2c3c948a378a1dc9f02f3" translate="yes" xml:space="preserve">
          <source>To exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; and defer showing it with &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt;. This way, the UI doesn&amp;rsquo;t appear broken before hydration.</source>
          <target state="translated">サーバーレンダリングされたHTMLからレイアウト効果を必要とするコンポーネントを除外するには、 &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; を使用して条件付きでレンダリングし、 &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt; を使用してコンポーネントの表示を延期します。このようにして、ハイドレーションの前にUIが壊れて表示されることはありません。</target>
        </trans-unit>
        <trans-unit id="eb8f9dde0c24efe373765229e6c43a7c2f9337d4" translate="yes" xml:space="preserve">
          <source>To fix it, use a second form of &lt;code&gt;setState()&lt;/code&gt; that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</source>
          <target state="translated">これを修正するには、オブジェクトではなく関数を受け入れる2番目の形式の &lt;code&gt;setState()&lt;/code&gt; を使用します。その関数は、最初の引数として以前の状態を受け取り、更新が適用されたときのプロップを2番目の引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="3d6dd3cdedde657acf900d4a89c0336446299310" translate="yes" xml:space="preserve">
          <source>To fix this, make sure that the expression before &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is always boolean:</source>
          <target state="translated">これを修正するには、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; の前の式が常にブール値であることを確認してください：</target>
        </trans-unit>
        <trans-unit id="26f99cfd42eb715ac4995805986b83748003e11d" translate="yes" xml:space="preserve">
          <source>To fix this, we will assign the type to a capitalized variable first:</source>
          <target state="translated">これを修正するために、まず大文字の変数に型を代入します。</target>
        </trans-unit>
        <trans-unit id="4180ca125a608d7a0e25df64e609f9ecb9c30f6e" translate="yes" xml:space="preserve">
          <source>To fix this, we will rename &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;Hello&lt;/code&gt; and use &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; when referring to it:</source>
          <target state="translated">これを修正するために、 &lt;code&gt;hello&lt;/code&gt; の名前を &lt;code&gt;Hello&lt;/code&gt; に変更し、 &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; を使用して参照します。</target>
        </trans-unit>
        <trans-unit id="4dbe0f13cbbf4d21a676b7a8718fc4a5f8142b73" translate="yes" xml:space="preserve">
          <source>To get around this problem, you can sometimes define the prop as an instance method, like so:</source>
          <target state="translated">この問題を回避するには、次のようにpropをインスタンスメソッドとして定義することができます。</target>
        </trans-unit>
        <trans-unit id="40ba2f6b08deb2dd30866e5b1b9d4a3ddab93d66" translate="yes" xml:space="preserve">
          <source>To get around this, lift the value into the parent&amp;rsquo;s state:</source>
          <target state="translated">これを回避するには、値を親の状態に引き上げます。</target>
        </trans-unit>
        <trans-unit id="2f2493e07779dd5286222aecb67fb87e67cc0be1" translate="yes" xml:space="preserve">
          <source>To illustrate this, let&amp;rsquo;s look at a prolific example of broken accessibility caused by click events. This is the outside click pattern, where a user can disable an opened popover by clicking outside the element.</source>
          <target state="translated">これを説明するために、クリックイベントによって引き起こされたアクセシビリティの破損の多発例を見てみましょう。これは外部クリックパターンであり、ユーザーは要素の外側をクリックして、開いているポップオーバーを無効にできます。</target>
        </trans-unit>
        <trans-unit id="13f9c02dda0f950eb210d479587b65f95f4cc303" translate="yes" xml:space="preserve">
          <source>To illustrate this, we&amp;rsquo;ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:</source>
          <target state="translated">これを説明するために、架空のチャットの例の別のコンポーネントを使用します。これは、現在選択されている友達がオンラインかどうかを表示するチャットメッセージ受信者ピッカーです。</target>
        </trans-unit>
        <trans-unit id="961d23cd4294477c013c8951229dab570e818eda" translate="yes" xml:space="preserve">
          <source>To implement this, pass a second argument to &lt;code&gt;useEffect&lt;/code&gt; that is the array of values that the effect depends on. Our updated example now looks like this:</source>
          <target state="translated">これを実装するには、効果が依存する値の配列である &lt;code&gt;useEffect&lt;/code&gt; に 2番目の引数を渡します。更新された例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="0cbe7212eb0bb22a0ce6673108171b6c2eba3a81" translate="yes" xml:space="preserve">
          <source>To implement this, we need to add &amp;ldquo;state&amp;rdquo; to the &lt;code&gt;Clock&lt;/code&gt; component.</source>
          <target state="translated">これを実装するには、 &lt;code&gt;Clock&lt;/code&gt; コンポーネントに「状態」を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e877ead3847a981597e9e8f4b95b055907cf7831" translate="yes" xml:space="preserve">
          <source>To keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.</source>
          <target state="translated">コンテキストの再レンダリングを高速に保つために、Reactは各コンテキストのコンシューマーをツリー内の別のノードにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef8ae5d271af6e506124cf18131498a70ca2be75" translate="yes" xml:space="preserve">
          <source>To learn more about the reasoning behind this convention, please read &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt;.</source>
          <target state="translated">この規則の背後にある理由について詳しくは、&lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="0cf9ecedef1338a4eac3e138d708e2dc3ae6e04d" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;16&lt;/code&gt; with the version number.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; と &lt;code&gt;react-dom&lt;/code&gt; の特定のバージョンをロードするには、 &lt;code&gt;16&lt;/code&gt; をバージョン番号に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a5eda8e7fdbff1721f24fafdb7853cef70444134" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;17&lt;/code&gt; with the version number.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; および &lt;code&gt;react-dom&lt;/code&gt; の特定のバージョンをロードするには、 &lt;code&gt;17&lt;/code&gt; をバージョン番号に置き換えます。</target>
        </trans-unit>
        <trans-unit id="9170ed3b74ebf37599d0d132e15a2a18d2b9e376" translate="yes" xml:space="preserve">
          <source>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React achieves this with &lt;strong&gt;state&lt;/strong&gt;.</source>
          <target state="translated">UIをインタラクティブにするには、基礎となるデータモデルへの変更をトリガーできる必要があります。Reactはこれを&lt;strong&gt;stateで&lt;/strong&gt;実現し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5db9a96f52fb596a5edee35fcf3c37dc6093b9ec" translate="yes" xml:space="preserve">
          <source>To opt into production profiling, React provides a special production build with profiling enabled. Read more about how to use this build at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="translated">プロダクションプロファイリングをオプトインするために、Reactはプロファイリングを有効にした特別なプロダクションビルドを提供しています。このビルドの使用方法の詳細については、&lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me / react-profilingをご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75c17fcf1c7e00497ec03d423858cf51a3dcb835" translate="yes" xml:space="preserve">
          <source>To prepare a component for assertions, wrap the code rendering it and performing updates inside an &lt;code&gt;act()&lt;/code&gt; call. This makes your test run closer to how React works in the browser.</source>
          <target state="translated">アサーション用のコンポーネントを準備するには、コードをラップしてレンダリングし、 &lt;code&gt;act()&lt;/code&gt; 呼び出し内で更新を実行します。これにより、ブラウザーでのReactの動作に近いテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="b39042bd85f101d91f59c4ce1fe317b35d4e24bd" translate="yes" xml:space="preserve">
          <source>To prevent React from touching the DOM after mounting, we will return an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; from the &lt;code&gt;render()&lt;/code&gt; method. The &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; element has no properties or children, so React has no reason to update it, leaving the jQuery plugin free to manage that part of the DOM:</source>
          <target state="translated">マウント後にReactがDOMに触れないようにするために、 &lt;code&gt;render()&lt;/code&gt; メソッドから空の &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; を返します。 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 要素は、そのDOMの一部を管理するための無料のプラグインのjQueryを残して、それを更新する理由を持っていない反応して、全く性質や子供を持っていません。</target>
        </trans-unit>
        <trans-unit id="aa5fc70f2e6ed1981d083882d48e4da2f10514fd" translate="yes" xml:space="preserve">
          <source>To recap:</source>
          <target state="translated">要約すると</target>
        </trans-unit>
        <trans-unit id="040be61ccf0b0b4ecaddbde299a3d8ac64c9d4c6" translate="yes" xml:space="preserve">
          <source>To reduce the boilerplate, we recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to encourage writing tests that use your components as the end users do.</source>
          <target state="translated">ボイラープレートを減らすために、エンドユーザーと同じようにコンポーネントを使用するテストの作成を促進するように設計された&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="42bbd6b79127d268b3e68ed35e45d252d94d666f" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">React要素をルートDOMノードにレンダリングするには、両方を&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; に&lt;/a&gt;渡します。</target>
        </trans-unit>
        <trans-unit id="cf123112fa334cc8cc9830f8fa36f2c5c572a5c3" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;code&gt;ReactDOM.render()&lt;/code&gt;:</source>
          <target state="translated">React要素をルートDOMノードにレンダリングするには、両方を &lt;code&gt;ReactDOM.render()&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="6cd0441cfa854cfc8274a8b07aebcc808a1c6f06" translate="yes" xml:space="preserve">
          <source>To set focus in React, we can use &lt;a href=&quot;refs-and-the-dom&quot;&gt;Refs to DOM elements&lt;/a&gt;.</source>
          <target state="translated">Reactにフォーカスを設定するには、&lt;a href=&quot;refs-and-the-dom&quot;&gt;DOM要素への参照を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="fc462152955304c3080ea64e57ba27af39acf454" translate="yes" xml:space="preserve">
          <source>To show that all components are truly isolated, we can create an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt;s:</source>
          <target state="translated">すべてのコンポーネントが完全に分離されていることを示すために、3つの &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt; をレンダリングする &lt;code&gt;App&lt;/code&gt; コンポーネントを作成できます。</target>
        </trans-unit>
        <trans-unit id="802b4b9df13b5c75142658af8ad751b38ada5317" translate="yes" xml:space="preserve">
          <source>To solve these problems, &lt;strong&gt;Hooks let you use more of React&amp;rsquo;s features without classes.&lt;/strong&gt; Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don&amp;rsquo;t require you to learn complex functional or reactive programming techniques.</source>
          <target state="translated">これらの問題を解決するために、&lt;strong&gt;フックを使用すると、クラスなしでReactの機能をさらに使用できるようになります。&lt;/strong&gt;概念的には、Reactコンポーネントは常に機能に近くなっています。フックは機能を受け入れますが、Reactの実用的な精神を犠牲にすることはありません。フックは必須のエスケープハッチへのアクセスを提供し、複雑な関数型または反応型プログラミング技術を学ぶ必要がありません。</target>
        </trans-unit>
        <trans-unit id="711f5e98a5aa9e9c0eca8855c68da41e1af743dd" translate="yes" xml:space="preserve">
          <source>To solve this, &lt;strong&gt;Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data)&lt;/strong&gt;, rather than forcing a split based on lifecycle methods. You may also opt into managing the component&amp;rsquo;s local state with a reducer to make it more predictable.</source>
          <target state="translated">これを解決するために、&lt;strong&gt;フック&lt;/strong&gt;を使用すると、ライフサイクルメソッドに基づいて分割を強制するのではなく、&lt;strong&gt;関連する部分（サブスクリプションの設定やデータのフェッチなど）に基づいて1つのコンポーネントを小さな関数に分割できます&lt;/strong&gt;。また、コンポーネントのローカル状態をレデューサーで管理して、より予測可能にすることもできます。</target>
        </trans-unit>
        <trans-unit id="456430f26783e12f01dfb3ab0df061bfad8fd1e5" translate="yes" xml:space="preserve">
          <source>To solve this, we will import &lt;code&gt;SuspenseList&lt;/code&gt;:</source>
          <target state="translated">これを解決するために、 &lt;code&gt;SuspenseList&lt;/code&gt; をインポートします。</target>
        </trans-unit>
        <trans-unit id="df1f73a03ded94e95f1acc62d67c8fde1d9192e4" translate="yes" xml:space="preserve">
          <source>To solve this, you could copy the methods onto the container before returning it:</source>
          <target state="translated">これを解決するには、メソッドを返す前にコンテナにコピーします。</target>
        </trans-unit>
        <trans-unit id="41cee84baf17b8b37b5a62207732214045e846c5" translate="yes" xml:space="preserve">
          <source>To specify a CSS class, use the &lt;code&gt;className&lt;/code&gt; attribute. This applies to all regular DOM and SVG elements like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, and others.</source>
          <target state="translated">CSSクラスを指定するには、 &lt;code&gt;className&lt;/code&gt; 属性を使用します。これは、 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; などの通常のすべてのDOMおよびSVG要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="ff92cd51808e0c139d5c320624daac6f819d6683" translate="yes" xml:space="preserve">
          <source>To use Flow, you need to:</source>
          <target state="translated">Flowを使用するには</target>
        </trans-unit>
        <trans-unit id="7728e4d8199feb9c930de3dba23c508446c8b19f" translate="yes" xml:space="preserve">
          <source>To use TypeScript, you need to:</source>
          <target state="translated">TypeScriptを使うには</target>
        </trans-unit>
        <trans-unit id="161f5895c0ace53ed0bdbe5b22982a6a7e932910" translate="yes" xml:space="preserve">
          <source>To write an uncontrolled component, instead of writing an event handler for every state update, you can &lt;a href=&quot;refs-and-the-dom&quot;&gt;use a ref&lt;/a&gt; to get form values from the DOM.</source>
          <target state="translated">状態の更新ごとにイベントハンドラーを作成する代わりに、制御されていないコンポーネントを作成するに&lt;a href=&quot;refs-and-the-dom&quot;&gt;は、ref&lt;/a&gt;を使用してDOMからフォームの値を取得します。</target>
        </trans-unit>
        <trans-unit id="10ccc5d107f7904bbc61b7a412891849240b695c" translate="yes" xml:space="preserve">
          <source>To write this without mutating the original object, we can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method:</source>
          <target state="translated">元のオブジェクトを変更せずにこれを書き込むには、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="7d7f0884f833f751d0ef4b5804217e883199fbd5" translate="yes" xml:space="preserve">
          <source>Touch Events</source>
          <target state="translated">タッチイベント</target>
        </trans-unit>
        <trans-unit id="f698e5b2645ac0bbc246d48b10271b68e9474767" translate="yes" xml:space="preserve">
          <source>Tradeoffs</source>
          <target state="translated">Tradeoffs</target>
        </trans-unit>
        <trans-unit id="e09ef19ed713b6bf4b952611e8fb8bed5595d988" translate="yes" xml:space="preserve">
          <source>Traditional Approaches vs Suspense</source>
          <target state="translated">伝統的なアプローチとサスペンス</target>
        </trans-unit>
        <trans-unit id="9c6bcbcbb843659ef482025bbc0496703fc2c9f1" translate="yes" xml:space="preserve">
          <source>Traditionally in React, we&amp;rsquo;ve had two popular ways to share stateful logic between components: &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt;. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.</source>
          <target state="translated">従来、Reactでは、コンポーネント間でステートフルロジックを共有する一般的な方法として、&lt;a href=&quot;render-props&quot;&gt;レンダープロップ&lt;/a&gt;と&lt;a href=&quot;higher-order-components&quot;&gt;高次&lt;/a&gt;コンポーネントの2つがありました。ツリーにコンポーネントを追加せずに、フックが同じ問題の多くを解決する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="867ed4b8bc75b5b5326132e2b60c8c0b99335d9c" translate="yes" xml:space="preserve">
          <source>Traditionally, performance concerns around inline functions in React have been related to how passing new callbacks on each render breaks &lt;code&gt;shouldComponentUpdate&lt;/code&gt; optimizations in child components. Hooks approach this problem from three sides.</source>
          <target state="translated">従来、Reactのインライン関数に関するパフォーマンスの問題は、レンダーごとに新しいコールバックを渡すと子コンポーネントの &lt;code&gt;shouldComponentUpdate&lt;/code&gt; の最適化がどのように中断されるかに関連してきました。フックはこの問題に3つの側面から取り組みます。</target>
        </trans-unit>
        <trans-unit id="79b58c889bdd40be6a9258235ddadc622908c97f" translate="yes" xml:space="preserve">
          <source>Transforming Elements</source>
          <target state="translated">変形要素</target>
        </trans-unit>
        <trans-unit id="861553513522659f696c3c2acb5a9f21bd9c2977" translate="yes" xml:space="preserve">
          <source>Transition Events</source>
          <target state="translated">移行イベント</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="dab3f667a0d8b5abd4238e47610e2d5abaeedb69" translate="yes" xml:space="preserve">
          <source>Transitions Are Everywhere</source>
          <target state="translated">トランジションはどこにでもある</target>
        </trans-unit>
        <trans-unit id="7b44f1918af555e5d533829bafdc652efe0e1809" translate="yes" xml:space="preserve">
          <source>Transitions are probably the most common Concurrent Mode pattern you&amp;rsquo;ll encounter, but there are a few more patterns you might find useful.</source>
          <target state="translated">トランジションはおそらく最も一般的な同時モードパターンですが、他にも役立つパターンがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="7a496151406c7c9004e4058dfa652f7eb082f09c" translate="yes" xml:space="preserve">
          <source>Traverse all components in &lt;code&gt;tree&lt;/code&gt; and accumulate all components where &lt;code&gt;test(component)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This is not that useful on its own, but it&amp;rsquo;s used as a primitive for other test utils.</source>
          <target state="translated">すべてのコンポーネントトラバース &lt;code&gt;tree&lt;/code&gt; 、すべてのコンポーネントに蓄積 &lt;code&gt;test(component)&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; 。これ自体はそれほど有用ではありませんが、他のテストユーティリティのプリミティブとして使用されます。</target>
        </trans-unit>
        <trans-unit id="43ac9a4202ce55afef326fe04f9278e801c3bbcd" translate="yes" xml:space="preserve">
          <source>Triggering imperative animations.</source>
          <target state="translated">命令的なアニメーションのトリガー。</target>
        </trans-unit>
        <trans-unit id="eccdf562ab40da83be6c16a48f5e930ce51f7c3d" translate="yes" xml:space="preserve">
          <source>Try React</source>
          <target state="translated">リアクトを試す</target>
        </trans-unit>
        <trans-unit id="cfb591755dd76c1452b5a348fbeebe6806df4186" translate="yes" xml:space="preserve">
          <source>Try to avoid this pattern if possible.</source>
          <target state="translated">できればこのパターンは避けるようにしましょう。</target>
        </trans-unit>
        <trans-unit id="f6062735b940c7bf271c9b6f8c2b28e0bf5e59c6" translate="yes" xml:space="preserve">
          <source>Try to resist adding abstraction too early. Now that function components can do more, it&amp;rsquo;s likely that the average function component in your codebase will become longer. This is normal &amp;mdash; don&amp;rsquo;t feel like you &lt;em&gt;have to&lt;/em&gt; immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.</source>
          <target state="translated">抽象化の追加を早めすぎないようにしてください。関数コンポーネントでより多くのことができるようになったので、コードベースの平均関数コンポーネントが長くなる可能性があります。これは正常です&amp;mdash; すぐにフックに分割する必要&lt;em&gt;がある&lt;/em&gt;ように感じないでください。ただし、カスタムフックが複雑なロジックを単純なインターフェースの背後に隠したり、乱雑なコンポーネントを解きほぐしたりするケースを見つけることもお勧めします。</target>
        </trans-unit>
        <trans-unit id="334611c431de5751798ac787ddca7df7e73e72f9" translate="yes" xml:space="preserve">
          <source>Try typing into the input now. Something&amp;rsquo;s wrong! The input is updating very slowly.</source>
          <target state="translated">ここで入力を入力してみてください。何かがおかしい！入力の更新が非常に遅い。</target>
        </trans-unit>
        <trans-unit id="1b99d50739153c959d7213579c4a965e5873684c" translate="yes" xml:space="preserve">
          <source>Two elements of different types will produce different trees.</source>
          <target state="translated">種類の異なる2つの要素で、異なる木ができあがります。</target>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="translated">型の定義</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="d3523ff7754d38fca6faee8a30f9b66412b28d78" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Basic Types</source>
          <target state="translated">TypeScript ドキュメント。基本的な型</target>
        </trans-unit>
        <trans-unit id="f9ce122df460bfd7e1f36f7b4329fefda2a5f261" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Migrating from Javascript</source>
          <target state="translated">TypeScript ドキュメント。Javascriptからの移行</target>
        </trans-unit>
        <trans-unit id="35a5e4b988fb1f5f965bda27ff40e707d14e3010" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: React and Webpack</source>
          <target state="translated">TypeScript のドキュメント。React と Webpack</target>
        </trans-unit>
        <trans-unit id="c3d225e3af7ff48de43e2bd459c9b1c338c2417b" translate="yes" xml:space="preserve">
          <source>Typechecking With PropTypes</source>
          <target state="translated">PropTypesでの型チェック</target>
        </trans-unit>
        <trans-unit id="d215bb61686448cb9ae653f89b0f5e7dd3dad265" translate="yes" xml:space="preserve">
          <source>Typically it is placed at the top of a file. Try adding it to some files in your project and run &lt;code&gt;yarn flow&lt;/code&gt; or &lt;code&gt;npm run flow&lt;/code&gt; to see if Flow already found any issues.</source>
          <target state="translated">通常、ファイルの先頭に配置されます。あなたのプロジェクトと、実行中のいくつかのファイルにそれを追加してみてください &lt;code&gt;yarn flow&lt;/code&gt; や &lt;code&gt;npm run flow&lt;/code&gt; の流れは、すでにすべての問題を発見したかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="73e9a38fd5dec87870b44081fc23f86a7fa9e9ef" translate="yes" xml:space="preserve">
          <source>Typically, elements are not used directly, but get returned from components.</source>
          <target state="translated">通常、要素は直接使用されず、コンポーネントから返されます。</target>
        </trans-unit>
        <trans-unit id="fa0ea11a83e136215d62bce59ca2e4bf0e74fd2d" translate="yes" xml:space="preserve">
          <source>Typically, in React constructors are only used for two purposes:</source>
          <target state="translated">通常、Reactではコンストラクタは2つの目的でしか使用されません。</target>
        </trans-unit>
        <trans-unit id="1daac2fa2690d23fe34be5b54bc70593b395a6de" translate="yes" xml:space="preserve">
          <source>Typically, new React apps have a single &lt;code&gt;App&lt;/code&gt; component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like &lt;code&gt;Button&lt;/code&gt; and gradually work your way to the top of the view hierarchy.</source>
          <target state="translated">通常、新しいReactアプリには最上部に単一の &lt;code&gt;App&lt;/code&gt; コンポーネントがあります。ただし、Reactを既存のアプリに統合する場合は、 &lt;code&gt;Button&lt;/code&gt; のような小さなコンポーネントからボトムアップで始め、徐々にビュー階層の最上位に向かって作業を進めます。</target>
        </trans-unit>
        <trans-unit id="68a6a755ada6660b29b2c9a473f41d1442935fd7" translate="yes" xml:space="preserve">
          <source>Typically, this method can be replaced by &lt;code&gt;componentDidUpdate()&lt;/code&gt;. If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt;.</source>
          <target state="translated">通常、このメソッドは &lt;code&gt;componentDidUpdate()&lt;/code&gt; で置き換えることができます。このメソッドでDOMから読み取っていた場合（スクロール位置を保存する場合など）は、そのロジックを &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; に移動できます。</target>
        </trans-unit>
        <trans-unit id="0f8fe4b91a258395d82ce705eae35d1dba13e5d0" translate="yes" xml:space="preserve">
          <source>UI Events</source>
          <target state="translated">UIイベント</target>
        </trans-unit>
        <trans-unit id="4fb0447cd4cc8d21fe08d8d8d1d385e065b4d751" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillMount()</source>
          <target state="translated">UNSAFE_componentWillMount()</target>
        </trans-unit>
        <trans-unit id="043736bc28e0c4444c9b35f7a1596b1baa86712f" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillReceiveProps()</source>
          <target state="translated">UNSAFE_componentWillReceiveProps()</target>
        </trans-unit>
        <trans-unit id="602b351d9bb4a7f81d1bd7cf0654468b51cd30dd" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillUpdate()</source>
          <target state="translated">UNSAFE_componentWillUpdate()</target>
        </trans-unit>
        <trans-unit id="44a89ad0f567037d498dd94937dc567d3df46056" translate="yes" xml:space="preserve">
          <source>Uncontrolled Components</source>
          <target state="translated">制御されていないコンポーネント</target>
        </trans-unit>
        <trans-unit id="91ba162b681d6b6ee5e37c09ea2e8e36df8b03a6" translate="yes" xml:space="preserve">
          <source>Under the Hood</source>
          <target state="translated">アンダーザフード</target>
        </trans-unit>
        <trans-unit id="91622521af8534f6e0a8cc517ee55a45aa6f3a6c" translate="yes" xml:space="preserve">
          <source>Unfortunately, neither using a class nor the &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; syntax helped us solve this problem. This version suffers from exactly the same race conditions, for the same reasons.</source>
          <target state="translated">残念ながら、クラスも &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 構文も使用していないため、この問題を解決できませんでした。このバージョンは、同じ理由で、まったく同じ競合状態の影響を受けます。</target>
        </trans-unit>
        <trans-unit id="9f80ce906590fe652cad0aa027fb0b4de4ce5b39" translate="yes" xml:space="preserve">
          <source>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render. For a concrete example, you can look at how &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt; enforces preloading. Our messaging about this hasn&amp;rsquo;t been very consistent in the past. Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</source>
          <target state="translated">ウォーターフォールの防止に役立つソリューションがない限り、レンダリングの前にフェッチを優先または強制するAPIをお勧めします。具体的な例として、&lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt;がプリロードを実行する方法を見ることができます。これに関する私たちのメッセージは、これまであまり一貫していませんでした。 Suspense for Data Fetchingはまだ実験段階です。したがって、本番環境での使用法からより多くを学び、問題の領域をよりよく理解するにつれて、推奨事項が時間とともに変化することを期待できます。</target>
        </trans-unit>
        <trans-unit id="961dfa537f5c77804b72ca4ff3d24ad3146c886c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;, the function passed to &lt;code&gt;useEffect&lt;/code&gt; fires &lt;strong&gt;after&lt;/strong&gt; layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn&amp;rsquo;t block the browser from updating the screen.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; や &lt;code&gt;componentDidUpdate&lt;/code&gt; とは異なり、 &lt;code&gt;useEffect&lt;/code&gt; に渡された関数は&lt;strong&gt;、&lt;/strong&gt;レイアウトとペイントの後で、遅延イベント中に発生&lt;strong&gt;し&lt;/strong&gt;ます。ほとんどの種類の作業がブラウザによる画面の更新を妨げないため、これはサブスクリプションやイベントハンドラーの設定など、多くの一般的な副作用に適しています。</target>
        </trans-unit>
        <trans-unit id="60a61e13204634a47f56d56022d06304cef51b86" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt;, effects scheduled with &lt;code&gt;useEffect&lt;/code&gt; don&amp;rsquo;t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don&amp;rsquo;t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt; Hook with an API identical to &lt;code&gt;useEffect&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; や &lt;code&gt;componentDidUpdate&lt;/code&gt; とは異なり、 &lt;code&gt;useEffect&lt;/code&gt; でスケジュールされたエフェクトは、ブラウザによる画面の更新をブロックしません。これにより、アプリの応答性が向上します。効果の大部分は同期的に発生する必要はありません。 （そのようなレイアウトの測定など）彼らは珍しいケースでは、別ある&lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; の&lt;/a&gt;と同じAPIを持つフック &lt;code&gt;useEffect&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="b85ad9f5bd023a746d09d4ff6f648319da333072" translate="yes" xml:space="preserve">
          <source>Unlike a React component, a custom Hook doesn&amp;rsquo;t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it&amp;rsquo;s just like a normal function. Its name should always start with &lt;code&gt;use&lt;/code&gt; so that you can tell at a glance that the &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; apply to it.</source>
          <target state="translated">Reactコンポーネントとは異なり、カスタムフックは特定の署名を持つ必要はありません。引数として何を取り、それが何を返すかを決定できます。つまり、通常の関数と同じです。&lt;a href=&quot;hooks-rules&quot;&gt;フック&lt;/a&gt;のルールが適用されていることが一目でわかるように、その名前は常に &lt;code&gt;use&lt;/code&gt; 始まる必要があります。</target>
        </trans-unit>
        <trans-unit id="2b66fd7542b07767f815ec47cf6d8029807d9066" translate="yes" xml:space="preserve">
          <source>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</source>
          <target state="translated">ブラウザのDOM要素とは異なり、React要素はプレーンなオブジェクトであり、安価に作成することができます。React DOMは、React要素に合わせてDOMを更新する処理をしてくれます。</target>
        </trans-unit>
        <trans-unit id="409cf1b9538e64c6ea6640e27a0a2cb930cbc916" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; method on class components, the &lt;code&gt;areEqual&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; if the props are equal and &lt;code&gt;false&lt;/code&gt; if the props are not equal. This is the inverse from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;.</source>
          <target state="translated">異なり&lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt;クラス構成要素、上の方法 &lt;code&gt;areEqual&lt;/code&gt; 関数が返す &lt;code&gt;true&lt;/code&gt; 小道具が等しいとしている場合 &lt;code&gt;false&lt;/code&gt; 小道具が等しくない場合。これは &lt;code&gt;shouldComponentUpdate&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="1d59b8380230e83e5040bef8fbd9f3658ca115f6" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;setState&lt;/code&gt; method found in class components, &lt;code&gt;useState&lt;/code&gt; does not automatically merge update objects. You can replicate this behavior by combining the function updater form with object spread syntax:</source>
          <target state="translated">クラスコンポーネントにある &lt;code&gt;setState&lt;/code&gt; メソッドとは異なり、 &lt;code&gt;useState&lt;/code&gt; は更新オブジェクトを自動的にマージしません。この動作を再現するには、関数アップデーターフォームとオブジェクトスプレッド構文を組み合わせます。</target>
        </trans-unit>
        <trans-unit id="1d4c6b47d1d280d4c980af5669c79f72a2220526" translate="yes" xml:space="preserve">
          <source>Unlike the lifecycle methods above (which React calls for you), the methods below are the methods &lt;em&gt;you&lt;/em&gt; can call from your components.</source>
          <target state="translated">上記のライフサイクルメソッド（Reactが呼び出す）とは異なり、以下のメソッド&lt;em&gt;は&lt;/em&gt;コンポーネントから呼び出す&lt;em&gt;こと&lt;/em&gt;ができるメソッド&lt;em&gt;です&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="afee7066378e96dff04ac25d626ac161d6174ffc" translate="yes" xml:space="preserve">
          <source>Unmount the in-memory tree, triggering the appropriate lifecycle events.</source>
          <target state="translated">インメモリツリーをアンマウントし、適切なライフサイクルイベントをトリガーします。</target>
        </trans-unit>
        <trans-unit id="dc1890384805c160e15933042986e8c1270701db" translate="yes" xml:space="preserve">
          <source>Unmounting</source>
          <target state="translated">Unmounting</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="7140c62e34aa56f0454814b03078ba09696680fc" translate="yes" xml:space="preserve">
          <source>Updating Context</source>
          <target state="translated">コンテキストの更新</target>
        </trans-unit>
        <trans-unit id="e8f9d5ed2b68142879f0064acd39d5dddc19e0e8" translate="yes" xml:space="preserve">
          <source>Updating Context from a Nested Component</source>
          <target state="translated">ネストされたコンポーネントからのコンテキストの更新</target>
        </trans-unit>
        <trans-unit id="636abf0ade1a63bc188164ee602e69ee61c11abf" translate="yes" xml:space="preserve">
          <source>Updating State</source>
          <target state="translated">状態の更新</target>
        </trans-unit>
        <trans-unit id="6eb521bc92ea8deef0873674e85f6a2b677e0160" translate="yes" xml:space="preserve">
          <source>Updating the Rendered Element</source>
          <target state="translated">レンダリングされた要素の更新</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cb779c71f17fb4651dcbb26ce93ad9f3b869a15e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; to let React know if a component&amp;rsquo;s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; を使用して、コンポーネントの出力が状態またはプロップの現在の変更の影響を受けていないかどうかをReactに通知します。デフォルトの動作は、すべての状態変化で再レンダリングすることであり、ほとんどの場合、デフォルトの動作に依存する必要があります。</target>
        </trans-unit>
        <trans-unit id="b1f252513f7226882a0b24dbdb6d8dcbaf0e88fb" translate="yes" xml:space="preserve">
          <source>Use HOCs For Cross-Cutting Concerns</source>
          <target state="translated">HOCを横断的な懸念事項に使用する</target>
        </trans-unit>
        <trans-unit id="efcd67afa619eafb57d29f164d865f7967e67a72" translate="yes" xml:space="preserve">
          <source>Use Render Props for Cross-Cutting Concerns</source>
          <target state="translated">レンダリングプロップスを使用して横断的な懸念事項を解決する</target>
        </trans-unit>
        <trans-unit id="945e7893698701d1a0783de1c07354e2873bcd51" translate="yes" xml:space="preserve">
          <source>Use an integrated toolchain for the best user and developer experience.</source>
          <target state="translated">統合されたツールチェーンを使用して、最高のユーザーと開発者のエクスペリエンスを実現します。</target>
        </trans-unit>
        <trans-unit id="9e6c96a7f53534a11f3be968f06caa0a7bdbcfbe" translate="yes" xml:space="preserve">
          <source>Use arrow functions, e.g. &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt;.</source>
          <target state="translated">矢印関数を使用します（例： &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7add3fa600f24de210341c304ca34869584489ae" translate="yes" xml:space="preserve">
          <source>Use as little or as much React as you need.</source>
          <target state="translated">必要に応じてReactを少しでも多く使ってください。</target>
        </trans-unit>
        <trans-unit id="a25e73bb61bda8c3da0ca1b1bab2f08d9fd2b4b1" translate="yes" xml:space="preserve">
          <source>Use refs sparingly. If you find yourself often using refs to &amp;ldquo;make things happen&amp;rdquo; in your app, consider getting more familiar with &lt;a href=&quot;lifting-state-up&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">refは慎重に使用してください。アプリで「物事を起こす」ためにrefを頻繁に使用している場合は、&lt;a href=&quot;lifting-state-up&quot;&gt;トップダウンのデータフロー&lt;/a&gt;について理解を深めることを検討してください。</target>
        </trans-unit>
        <trans-unit id="a45798aa0c2077edf1d4bdb602e7360df7b30fa1" translate="yes" xml:space="preserve">
          <source>Use the Production Build</source>
          <target state="translated">プロダクションビルドを使用する</target>
        </trans-unit>
        <trans-unit id="501943d285edf21697f4469e8359a5357bcaaa0a" translate="yes" xml:space="preserve">
          <source>Use the right file extensions</source>
          <target state="translated">正しいファイル拡張子を使用する</target>
        </trans-unit>
        <trans-unit id="d60684d4bf976b6606e32f95fd03e20ad2cdaa9b" translate="yes" xml:space="preserve">
          <source>Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</source>
          <target state="translated">コンポーネントが更新されたときに DOM を操作する機会として使用します。これは、現在のプロップと以前のプロップを比較する限り、ネットワークリクエストを行うのにも良い場所です (例えば、プロップが変更されていない場合は、ネットワークリクエストは必要ないかもしれません)。</target>
        </trans-unit>
        <trans-unit id="09bb24d7602932e8e5252fa3559cae849ed40e36" translate="yes" xml:space="preserve">
          <source>User-Defined Components Must Be Capitalized</source>
          <target state="translated">ユーザー定義のコンポーネントは大文字にする必要があります</target>
        </trans-unit>
        <trans-unit id="7bf9efc7891aa3dc73c45128d1b30d30f360d6b7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Enter&lt;/code&gt; to activate elements.</source>
          <target state="translated">&lt;code&gt;Enter&lt;/code&gt; を使用して要素をアクティブにします。</target>
        </trans-unit>
        <trans-unit id="ce90babb0b7d4740ec6dff8069a1a70de2528e0a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Function.prototype.bind&lt;/code&gt; in render creates a new function each time the component renders, which may have performance implications (see below).</source>
          <target state="translated">使用 &lt;code&gt;Function.prototype.bind&lt;/code&gt; のレンダリングにする（下記参照）の性能への影響を有することができる、新たな機能をコンポーネントをレンダリングするたびに作成します。</target>
        </trans-unit>
        <trans-unit id="0268b704052253efcc133928357695716f43f5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.lazy&lt;/code&gt;with dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.</source>
          <target state="translated">動的インポートで &lt;code&gt;React.lazy&lt;/code&gt; を使用するには、JS環境でPromiseを使用できる必要があります。これには、IE11以下のポリフィルが必要です。</target>
        </trans-unit>
        <trans-unit id="a83225bb31031d74727c744b6f62dbc383870f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ReactDOM.render()&lt;/code&gt; to hydrate a server-rendered container is deprecated and will be removed in React 17. Use &lt;a href=&quot;#hydrate&quot;&gt;&lt;code&gt;hydrate()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; を使用してサーバーレンダリングコンテナーをハイドレートすることは非推奨であり、React 17で削除されます。代わりに&lt;a href=&quot;#hydrate&quot;&gt; &lt;code&gt;hydrate()&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="48a22ac3c2727930ac2f50162b02ed7090f9a062" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Tab&lt;/code&gt; and &lt;code&gt;Shift+Tab&lt;/code&gt; to browse.</source>
          <target state="translated">&lt;code&gt;Tab&lt;/code&gt; キーと &lt;code&gt;Shift+Tab&lt;/code&gt; キーを使用して閲覧します。</target>
        </trans-unit>
        <trans-unit id="5e1ba50e8dbe44c933cf9cf96a6e9c30d740bb4f" translate="yes" xml:space="preserve">
          <source>Using Backbone Models in React Components</source>
          <target state="translated">React コンポーネントでのバックボーンモデルの使用</target>
        </trans-unit>
        <trans-unit id="c5fda53e2ec39e55fd191ee394197d4e5b88f71c" translate="yes" xml:space="preserve">
          <source>Using Dot Notation for JSX Type</source>
          <target state="translated">JSX型でドット記法を使う</target>
        </trans-unit>
        <trans-unit id="338906b8dfe048bf958f52de3a30e3c835027dc9" translate="yes" xml:space="preserve">
          <source>Using Props Other Than &lt;code&gt;render&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 以外の小道具の使用</target>
        </trans-unit>
        <trans-unit id="88a483ee4ba49991c90e9465efe4ff7c34213894" translate="yes" xml:space="preserve">
          <source>Using React in your Web Components</source>
          <target state="translated">Web コンポーネントで React を使用する</target>
        </trans-unit>
        <trans-unit id="5fc69751a627e9e7608b6451c760b3088a1776d1" translate="yes" xml:space="preserve">
          <source>Using State Correctly</source>
          <target state="translated">状態を正しく使う</target>
        </trans-unit>
        <trans-unit id="603e93ed4db9941f0130803851a41f15bbe0f4a6" translate="yes" xml:space="preserve">
          <source>Using Suspense in Practice</source>
          <target state="translated">サスペンスを実践で使う</target>
        </trans-unit>
        <trans-unit id="64afa8340add2c118e1444b499855f90bdb7bdc0" translate="yes" xml:space="preserve">
          <source>Using TypeScript with Create React App</source>
          <target state="translated">Create React AppでTypeScriptを使う</target>
        </trans-unit>
        <trans-unit id="3181824009d3d8ab8f244eb65008a1d2883dcad7" translate="yes" xml:space="preserve">
          <source>Using Web Components in React</source>
          <target state="translated">ReactでWebコンポーネントを使う</target>
        </trans-unit>
        <trans-unit id="2b2c69cb3df5e00c387989ba3ee2f2cdc8414be3" translate="yes" xml:space="preserve">
          <source>Using a Custom Hook</source>
          <target state="translated">カスタムフックの使用</target>
        </trans-unit>
        <trans-unit id="6f7d4170c0a916b341350d421df2093f43390598" translate="yes" xml:space="preserve">
          <source>Using a render prop can negate the advantage that comes from using &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; if you create the function inside a &lt;code&gt;render&lt;/code&gt; method. This is because the shallow prop comparison will always return &lt;code&gt;false&lt;/code&gt; for new props, and each &lt;code&gt;render&lt;/code&gt; in this case will generate a new value for the render prop.</source>
          <target state="translated">レンダープロップを使用すると、 &lt;code&gt;render&lt;/code&gt; メソッド内で関数を作成する場合、&lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt;を使用することで得られる利点を無効にすることができます。これは、浅いプロップ比較は新しいプロップに対して常に &lt;code&gt;false&lt;/code&gt; を返し、この場合の各 &lt;code&gt;render&lt;/code&gt; はレンダープロップに対して新しい値を生成するためです。</target>
        </trans-unit>
        <trans-unit id="49915cecc2ab68b6142d2a20882e769c815b1066" translate="yes" xml:space="preserve">
          <source>Using an arrow function in render creates a new function each time the component renders, which may break optimizations based on strict identity comparison.</source>
          <target state="translated">レンダーで矢印関数を使用すると、コンポーネントがレンダリングされるたびに新しい関数が作成されるため、厳密な同一性の比較に基づく最適化が中断される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fda59156c5563425ee7b0abda49555ce452777ef" translate="yes" xml:space="preserve">
          <source>Using context, we can avoid passing props through intermediate elements:</source>
          <target state="translated">コンテキストを使用することで、中間要素に小道具を通すことを避けることができます。</target>
        </trans-unit>
        <trans-unit id="645200f75c6ba99bc214dfeec259746827cb20cb" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Chrome</source>
          <target state="translated">Chrome でアクセシビリティ インスペクタを使用する</target>
        </trans-unit>
        <trans-unit id="1c8312836922d5bcc9a8621ff5c07034606e0932" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Firefox</source>
          <target state="translated">Firefox でアクセシビリティインスペクタを使用する</target>
        </trans-unit>
        <trans-unit id="d5154d969b060a162f316e9c1d66f061f10670c9" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in OS X Safari</source>
          <target state="translated">OS X Safariでアクセシビリティインスペクタを使用する</target>
        </trans-unit>
        <trans-unit id="34c7c3a33655d5d85c739523b21799c0f20d8a60" translate="yes" xml:space="preserve">
          <source>Using the Effect Hook</source>
          <target state="translated">エフェクトフックの使い方</target>
        </trans-unit>
        <trans-unit id="5e7e608bd7f9e83ae5e7e66cf348bd9227a4b385" translate="yes" xml:space="preserve">
          <source>Using the Next Channel for Integration Testing</source>
          <target state="translated">統合テストのための次のチャネルの使用</target>
        </trans-unit>
        <trans-unit id="2cfba3a33414eaa5fb929de86b11b61915da61b8" translate="yes" xml:space="preserve">
          <source>Using the State Hook</source>
          <target state="translated">ステートフックの使用</target>
        </trans-unit>
        <trans-unit id="ed1021f647e8e233565d10846cc30295f9907000" translate="yes" xml:space="preserve">
          <source>Using third-party libraries from npm.</source>
          <target state="translated">npmからサードパーティ製のライブラリを使用しています。</target>
        </trans-unit>
        <trans-unit id="30d2d9559518afc440cfbf857d66b14037aea32a" translate="yes" xml:space="preserve">
          <source>Using this lifecycle method often leads to bugs and inconsistencies</source>
          <target state="translated">このライフサイクル手法を使用すると、バグや矛盾が発生することがよくあります。</target>
        </trans-unit>
        <trans-unit id="b8d2760e3203f83799237c703f9e064427a4c014" translate="yes" xml:space="preserve">
          <source>Using this technique will only capture the last published value in a frame. You can see an example of how this optimization works on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この手法を使用すると、フレームで最後に公開された値のみがキャプチャされます。この最適化が&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt;でどのように機能するかの例を見ることができます</target>
        </trans-unit>
        <trans-unit id="f13ada68bafae110ed822c96f8ad142bdd952a1f" translate="yes" xml:space="preserve">
          <source>Using this, we first create a ref to an element in the JSX of a component class:</source>
          <target state="translated">これを使って、まずコンポーネントクラスのJSX内に要素へのrefを作成します。</target>
        </trans-unit>
        <trans-unit id="06db89939f2e73f5bd1f0be19ed53194716ba43e" translate="yes" xml:space="preserve">
          <source>Usually you would render lists inside a &lt;a href=&quot;components-and-props&quot;&gt;component&lt;/a&gt;.</source>
          <target state="translated">通常、&lt;a href=&quot;components-and-props&quot;&gt;コンポーネント&lt;/a&gt;内でリストをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="e48c24f8824265a1d358e010460e0be08e5de8e2" translate="yes" xml:space="preserve">
          <source>Usually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component&amp;rsquo;s data dependencies:</source>
          <target state="translated">通常、HOCは追加の引数を受け入れます。このリレーの例では、構成オブジェクトを使用して、コンポーネントのデータ依存関係を指定しています。</target>
        </trans-unit>
        <trans-unit id="b203f86fed1a8723475dce775230e059b8ed90f3" translate="yes" xml:space="preserve">
          <source>Usually, an update to Next is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.</source>
          <target state="translated">通常、Nextへのアップデートには、Experimentalへの対応するアップデートが伴います。これらは同じソースリビジョンに基づいていますが、異なる機能フラグのセットを使用して構築されています。</target>
        </trans-unit>
        <trans-unit id="f1866b2703384cc1bc55c57199a504d049c9aa7b" translate="yes" xml:space="preserve">
          <source>Usually, when we update the state, we expect to see changes on the screen immediately. This makes sense because we want to keep our app responsive to user input. However, there are cases where we might prefer to &lt;strong&gt;defer an update from appearing on the screen&lt;/strong&gt;.</source>
          <target state="translated">通常、状態を更新すると、すぐに画面に変更が表示されることが予想されます。これは、ユーザーの入力に応答するアプリを維持したいので意味があります。ただし、&lt;strong&gt;画面に表示され&lt;/strong&gt;ないように&lt;strong&gt;更新&lt;/strong&gt;を&lt;strong&gt;延期し&lt;/strong&gt;たい場合が&lt;strong&gt;あります&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a7169fb86be8f9fb1f6dc74f3d60393bc42e3fa2" translate="yes" xml:space="preserve">
          <source>Verifies that &lt;code&gt;children&lt;/code&gt; has only one child (a React element) and returns it. Otherwise this method throws an error.</source>
          <target state="translated">ことを確認する &lt;code&gt;children&lt;/code&gt; 唯一の子（リアクト要素）を持っており、それを返します。そうでない場合、このメソッドはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="b84f1567e8f5f03f192913a113aca22668c5a0d0" translate="yes" xml:space="preserve">
          <source>Verifies the object is a React element. Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">オブジェクトがReact要素であることを確認します。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="27d6aa7034ec4c5be2d4ab35f28b89ccab502b9e" translate="yes" xml:space="preserve">
          <source>Versioned Documentation</source>
          <target state="translated">バージョンアップされたドキュメント</target>
        </trans-unit>
        <trans-unit id="cd797cf0fe303d32f5502e0cd652eb3709acf2f2" translate="yes" xml:space="preserve">
          <source>Versioning Policy</source>
          <target state="translated">バージョニングポリシー</target>
        </trans-unit>
        <trans-unit id="0e87ae23796278c9462fd444edf70fe1a009d923" translate="yes" xml:space="preserve">
          <source>Video Introduction</source>
          <target state="translated">動画紹介</target>
        </trans-unit>
        <trans-unit id="c2a2aea3dead057a6a1ec3e587afea025320c2dd" translate="yes" xml:space="preserve">
          <source>View the full example source code</source>
          <target state="translated">完全なサンプルソースコードを見る</target>
        </trans-unit>
        <trans-unit id="64cfe6fcb223ea8768b2640f2636977ba0d164fb" translate="yes" xml:space="preserve">
          <source>Virtual DOM and Internals</source>
          <target state="translated">仮想 DOM と内部</target>
        </trans-unit>
        <trans-unit id="f85fbf92e499fc71591a2e669124a9722afaf021" translate="yes" xml:space="preserve">
          <source>Virtualize Long Lists</source>
          <target state="translated">ロングリストの仮想化</target>
        </trans-unit>
        <trans-unit id="2ef3ffb278db3f335c5ff68b2879712b4c381076" translate="yes" xml:space="preserve">
          <source>VoiceOver in Safari</source>
          <target state="translated">SafariのVoiceOver</target>
        </trans-unit>
        <trans-unit id="d9957a9af3a69ef84d5b820d611a3f62b1ccf86a" translate="yes" xml:space="preserve">
          <source>VoiceOver is an integrated screen reader on Apple devices.</source>
          <target state="translated">VoiceOverは、Appleデバイスに統合されたスクリーンリーダーです。</target>
        </trans-unit>
        <trans-unit id="665b0a94753596ab58c7b0bfabd4f05a281f3d86" translate="yes" xml:space="preserve">
          <source>WAI-ARIA</source>
          <target state="translated">WAI-ARIA</target>
        </trans-unit>
        <trans-unit id="55894c1196e8f880851ae38d59786f7cb22f88d8" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices - Design Patterns and Widgets</source>
          <target state="translated">WAI-ARIA オーサリングの実務-デザインパターンとウィジェット</target>
        </trans-unit>
        <trans-unit id="3354373068a65230be0efcf6468f02a4db93217b" translate="yes" xml:space="preserve">
          <source>WCAG</source>
          <target state="translated">WCAG</target>
        </trans-unit>
        <trans-unit id="0f298949c575de92097cb4a1eb81d16e079aff0f" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Color Contrast Requirement</source>
          <target state="translated">WCAG-カラーコントラスト要件の理解</target>
        </trans-unit>
        <trans-unit id="565ff00b6dae2e3752c6332ca334f9853f076fdb" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Document Title Requirement</source>
          <target state="translated">WCAG-文書タイトル要件の理解</target>
        </trans-unit>
        <trans-unit id="3def136744bad9ab3d8d08b5708b83a2526e061a" translate="yes" xml:space="preserve">
          <source>WCAG checklist from WebAIM</source>
          <target state="translated">WebAIMからのWCAGチェックリスト</target>
        </trans-unit>
        <trans-unit id="619e96fcb4ca73ba5c9ca5b445977ccd8a08c119" translate="yes" xml:space="preserve">
          <source>WCAG checklist from Wuhcag</source>
          <target state="translated">WuhcagからのWCAGチェックリスト</target>
        </trans-unit>
        <trans-unit id="b5215274e1abd7f2ddbf3a3bd7f2039a5856f846" translate="yes" xml:space="preserve">
          <source>Warning about deprecated findDOMNode usage</source>
          <target state="translated">非推奨の findDOMNode の使用法に関する警告</target>
        </trans-unit>
        <trans-unit id="e8bd43ec422f56f393d838d8328819150d1b3d60" translate="yes" xml:space="preserve">
          <source>Warning about legacy string ref API usage</source>
          <target state="translated">レガシー文字列 ref API の使用に関する警告</target>
        </trans-unit>
        <trans-unit id="49fb98c43d8b4edd758891365ce7ff43c0bf6579" translate="yes" xml:space="preserve">
          <source>Waterfalls are common in code that fetches data on render. They&amp;rsquo;re possible to solve, but as the product grows, many people prefer to use a solution that guards against this problem.</source>
          <target state="translated">ウォーターフォールは、レンダリング時にデータをフェッチするコードでは一般的です。それらは解決することが可能ですが、製品が成長するにつれて、多くの人々はこの問題を防ぐソリューションを使用することを好みます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
